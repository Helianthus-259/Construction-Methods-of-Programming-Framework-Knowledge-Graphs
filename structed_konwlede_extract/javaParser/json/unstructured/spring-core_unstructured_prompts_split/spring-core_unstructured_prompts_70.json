[
  {
    "entityId": "org.springframework.core.ResolvableType#forConstructorParameter(Constructor<?>,int)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Constructor} parameter.\r\n * @param constructor the source constructor (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @return a {@code ResolvableType} for the specified constructor parameter\r\n * @see #forConstructorParameter(Constructor, int, Class)\r\n */\r\npublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {\r\n    Assert.notNull(constructor, \"Constructor must not be null\");\r\n    return forMethodParameter(new MethodParameter(constructor, parameterIndex));\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Constructor} parameter.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@code ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forConstructorParameter(Constructor<?>,int,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Constructor} parameter\r\n * with a given implementation. Use this variant when the class that declares the\r\n * constructor includes generic parameter variables that are satisfied by the\r\n * implementation class.\r\n * @param constructor the source constructor (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified constructor parameter\r\n * @see #forConstructorParameter(Constructor, int)\r\n */\r\npublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex, Class<?> implementationClass) {\r\n    Assert.notNull(constructor, \"Constructor must not be null\");\r\n    MethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);\r\n    return forMethodParameter(methodParameter);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Constructor} parameter\n\t * with a given implementation. Use this variant when the class that declares the\n\t * constructor includes generic parameter variables that are satisfied by the\n\t * implementation class.\n\t * @param constructor the source constructor (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified constructor parameter\n\t * @see #forConstructorParameter(Constructor, int)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodReturnType(Method)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} return type.\r\n * @param method the source for the method return type\r\n * @return a {@code ResolvableType} for the specified method return\r\n * @see #forMethodReturnType(Method, Class)\r\n */\r\npublic static ResolvableType forMethodReturnType(Method method) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return forMethodParameter(new MethodParameter(method, -1));\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Method} return type.\n\t * @param method the source for the method return type\n\t * @return a {@code ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodReturnType(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} return type.\r\n * <p>Use this variant when the class that declares the method includes generic\r\n * parameter variables that are satisfied by the implementation class.\r\n * @param method the source for the method return type\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified method return\r\n * @see #forMethodReturnType(Method)\r\n */\r\npublic static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    MethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);\r\n    return forMethodParameter(methodParameter);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Method} return type.\n\t * <p>Use this variant when the class that declares the method includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param method the source for the method return type\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified method return\n\t * @see #forMethodReturnType(Method)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodParameter(Method,int)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} parameter.\r\n * @param method the source method (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int, Class)\r\n * @see #forMethodParameter(MethodParameter)\r\n */\r\npublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return forMethodParameter(new MethodParameter(method, parameterIndex));\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Method} parameter.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodParameter(Method,int,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} parameter with a\r\n * given implementation. Use this variant when the class that declares the method\r\n * includes generic parameter variables that are satisfied by the implementation class.\r\n * @param method the source method (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int, Class)\r\n * @see #forMethodParameter(MethodParameter)\r\n */\r\npublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    MethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\r\n    return forMethodParameter(methodParameter);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Method} parameter with a\n\t * given implementation. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation class.\n\t * @param method the source method (must not be {@code null})\n\t * @param parameterIndex the parameter index\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int, Class)\n\t * @see #forMethodParameter(MethodParameter)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodParameter(MethodParameter)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter}.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int)\r\n */\r\npublic static ResolvableType forMethodParameter(MethodParameter methodParameter) {\r\n    return forMethodParameter(methodParameter, (Type) null);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter}.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodParameter(MethodParameter,ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter} with a\r\n * given implementation type. Use this variant when the class that declares the method\r\n * includes generic parameter variables that are satisfied by the implementation type.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @param implementationType the implementation type\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(MethodParameter)\r\n */\r\npublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable ResolvableType implementationType) {\r\n    Assert.notNull(methodParameter, \"MethodParameter must not be null\");\r\n    implementationType = (implementationType != null ? implementationType : forType(methodParameter.getContainingClass()));\r\n    ResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\r\n    return forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodParameter(MethodParameter,Type)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter},\r\n * overriding the target type to resolve with a specific given type.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @param targetType the type to resolve (a part of the method parameter's type)\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int)\r\n */\r\npublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\r\n    Assert.notNull(methodParameter, \"MethodParameter must not be null\");\r\n    return forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter},\n\t * overriding the target type to resolve with a specific given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forMethodParameter(MethodParameter,Type,int)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter} at\r\n * a specific nesting level, overriding the target type to resolve with a specific\r\n * given type.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @param targetType the type to resolve (a part of the method parameter's type)\r\n * @param nestingLevel the nesting level to use\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @since 5.2\r\n * @see #forMethodParameter(Method, int)\r\n */\r\nstatic ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType, int nestingLevel) {\r\n    ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());\r\n    return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).getNested(nestingLevel, methodParameter.typeIndexesPerLevel);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link MethodParameter} at\n\t * a specific nesting level, overriding the target type to resolve with a specific\n\t * given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @param nestingLevel the nesting level to use\n\t * @return a {@code ResolvableType} for the specified method parameter\n\t * @since 5.2\n\t * @see #forMethodParameter(Method, int)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forArrayComponent(ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} as an array of the specified {@code componentType}.\r\n * @param componentType the component type\r\n * @return a {@code ResolvableType} as an array of the specified component type\r\n */\r\npublic static ResolvableType forArrayComponent(ResolvableType componentType) {\r\n    Assert.notNull(componentType, \"Component type must not be null\");\r\n    Class<?> arrayType = componentType.toClass().arrayType();\r\n    return new ResolvableType(arrayType, componentType, null, null);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} as an array of the specified {@code componentType}.\n\t * @param componentType the component type\n\t * @return a {@code ResolvableType} as an array of the specified component type\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forVariableBounds(TypeVariable<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the bounds of the specified {@link TypeVariable}.\r\n * @param typeVariable the type variable\r\n * @return a {@code ResolvableType} for the specified bounds\r\n * @since 6.2.3\r\n */\r\nstatic ResolvableType forVariableBounds(TypeVariable<?> typeVariable) {\r\n    return forType(resolveBounds(typeVariable.getBounds()));\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the bounds of the specified {@link TypeVariable}.\n\t * @param typeVariable the type variable\n\t * @return a {@code ResolvableType} for the specified bounds\n\t * @since 6.2.3\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveBounds(Type[])",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Type resolveBounds(Type[] bounds) {\r\n    if (bounds.length == 0 || bounds[0] == Object.class) {\r\n        return null;\r\n    }\r\n    return bounds[0];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forType(Type)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Type}.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @param type the source type (potentially {@code null})\r\n * @return a {@code ResolvableType} for the specified {@link Type}\r\n * @see #forType(Type, ResolvableType)\r\n */\r\npublic static ResolvableType forType(@Nullable Type type) {\r\n    return forType(type, null, null);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Type}.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type (potentially {@code null})\n\t * @return a {@code ResolvableType} for the specified {@link Type}\n\t * @see #forType(Type, ResolvableType)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forType(Type,ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Type} backed by the given\r\n * owner type.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @param type the source type or {@code null}\r\n * @param owner the owner type used to resolve variables\r\n * @return a {@code ResolvableType} for the specified {@link Type} and owner\r\n * @see #forType(Type)\r\n */\r\npublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\r\n    VariableResolver variableResolver = null;\r\n    if (owner != null) {\r\n        variableResolver = owner.asVariableResolver();\r\n    }\r\n    return forType(type, variableResolver);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@code ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forType(ParameterizedTypeReference<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @param typeReference the reference to obtain the source type from\r\n * @return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}\r\n * @since 4.3.12\r\n * @see #forType(Type)\r\n */\r\npublic static ResolvableType forType(ParameterizedTypeReference<?> typeReference) {\r\n    return forType(typeReference.getType(), null, null);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @param typeReference the reference to obtain the source type from\n\t * @return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}\n\t * @since 4.3.12\n\t * @see #forType(Type)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forType(Type,VariableResolver)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\r\n * {@link VariableResolver}.\r\n * @param type the source type or {@code null}\r\n * @param variableResolver the variable resolver or {@code null}\r\n * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\r\n */\r\nstatic ResolvableType forType(@Nullable Type type, @Nullable VariableResolver variableResolver) {\r\n    return forType(type, null, variableResolver);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\n\t * {@link VariableResolver}.\n\t * @param type the source type or {@code null}\n\t * @param variableResolver the variable resolver or {@code null}\n\t * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forType(Type,TypeProvider,VariableResolver)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\r\n * {@link VariableResolver}.\r\n * @param type the source type or {@code null}\r\n * @param typeProvider the type provider or {@code null}\r\n * @param variableResolver the variable resolver or {@code null}\r\n * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\r\n */\r\nstatic ResolvableType forType(@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\r\n    if (type == null && typeProvider != null) {\r\n        type = SerializableTypeWrapper.forTypeProvider(typeProvider);\r\n    }\r\n    if (type == null) {\r\n        return NONE;\r\n    }\r\n    // For simple Class references, build the wrapper right away -\r\n    // no expensive resolution necessary, so not worth caching...\r\n    if (type instanceof Class) {\r\n        return new ResolvableType(type, null, typeProvider, variableResolver);\r\n    }\r\n    // Purge empty entries on access since we don't have a clean-up thread or the like.\r\n    cache.purgeUnreferencedEntries();\r\n    // Check the cache - we may have a ResolvableType which has been resolved before...\r\n    ResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);\r\n    ResolvableType cachedType = cache.get(resultType);\r\n    if (cachedType == null) {\r\n        cachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);\r\n        cache.put(cachedType, cachedType);\r\n    }\r\n    resultType.resolved = cachedType.resolved;\r\n    return resultType;\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\n\t * {@link VariableResolver}.\n\t * @param type the source type or {@code null}\n\t * @param typeProvider the type provider or {@code null}\n\t * @param variableResolver the variable resolver or {@code null}\n\t * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#clearCache()",
    "entityType": "method",
    "code": "/**\r\n * Clear the internal {@code ResolvableType}/{@code SerializableTypeWrapper} cache.\r\n * @since 4.2\r\n */\r\npublic static void clearCache() {\r\n    cache.clear();\r\n    SerializableTypeWrapper.cache.clear();\r\n}",
    "comment": "\n\t * Clear the internal {@code ResolvableType}/{@code SerializableTypeWrapper} cache.\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.VariableResolver",
    "entityType": "class",
    "code": "/**\r\n * Return the source of the resolver (used for hashCode and equals).\r\n */\r\nObject getSource();\n/**\r\n * Resolve the specified variable.\r\n * @param variable the variable to resolve\r\n * @return the resolved variable, or {@code null} if not found\r\n */\r\n@Nullable\r\nResolvableType resolveVariable(TypeVariable<?> variable);",
    "comment": "\n\t * Strategy interface used to resolve {@link TypeVariable TypeVariables}.\n\t "
  },
  {
    "entityId": "org.springframework.core.VariableResolver#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Return the source of the resolver (used for hashCode and equals).\r\n */\r\nObject getSource();",
    "comment": "\n\t\t * Return the source of the resolver (used for hashCode and equals).\n\t\t "
  },
  {
    "entityId": "org.springframework.core.VariableResolver#resolveVariable(TypeVariable<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the specified variable.\r\n * @param variable the variable to resolve\r\n * @return the resolved variable, or {@code null} if not found\r\n */\r\n@Nullable\r\nResolvableType resolveVariable(TypeVariable<?> variable);",
    "comment": "\n\t\t * Resolve the specified variable.\n\t\t * @param variable the variable to resolve\n\t\t * @return the resolved variable, or {@code null} if not found\n\t\t "
  },
  {
    "entityId": "org.springframework.core.DefaultVariableResolver",
    "entityType": "class",
    "code": "private final ResolvableType source;\nDefaultVariableResolver(ResolvableType resolvableType) {\r\n    this.source = resolvableType;\r\n}\n@Override\r\n@Nullable\r\npublic ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    return this.source.resolveVariable(variable);\r\n}\n@Override\r\npublic Object getSource() {\r\n    return this.source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DefaultVariableResolver#resolveVariable(TypeVariable<?>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    return this.source.resolveVariable(variable);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.DefaultVariableResolver#getSource()",
    "entityType": "method",
    "code": "@Override\r\npublic Object getSource() {\r\n    return this.source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeVariablesVariableResolver",
    "entityType": "class",
    "code": "private final TypeVariable<?>[] variables;\n@Nullable\r\nprivate final ResolvableType[] generics;\npublic TypeVariablesVariableResolver(TypeVariable<?>[] variables, @Nullable ResolvableType[] generics) {\r\n    this.variables = variables;\r\n    this.generics = generics;\r\n}\n@Override\r\n@Nullable\r\npublic ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    TypeVariable<?> variableToCompare = SerializableTypeWrapper.unwrap(variable);\r\n    for (int i = 0; i < this.variables.length; i++) {\r\n        TypeVariable<?> resolvedVariable = SerializableTypeWrapper.unwrap(this.variables[i]);\r\n        if (ObjectUtils.nullSafeEquals(resolvedVariable, variableToCompare)) {\r\n            return this.generics[i];\r\n        }\r\n    }\r\n    return null;\r\n}\n@Override\r\npublic Object getSource() {\r\n    return this.generics;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeVariablesVariableResolver#resolveVariable(TypeVariable<?>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    TypeVariable<?> variableToCompare = SerializableTypeWrapper.unwrap(variable);\r\n    for (int i = 0; i < this.variables.length; i++) {\r\n        TypeVariable<?> resolvedVariable = SerializableTypeWrapper.unwrap(this.variables[i]);\r\n        if (ObjectUtils.nullSafeEquals(resolvedVariable, variableToCompare)) {\r\n            return this.generics[i];\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeVariablesVariableResolver#getSource()",
    "entityType": "method",
    "code": "@Override\r\npublic Object getSource() {\r\n    return this.generics;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType",
    "entityType": "class",
    "code": "private final Type rawType;\nprivate final Type[] typeArguments;\npublic SyntheticParameterizedType(Type rawType, Type[] typeArguments) {\r\n    this.rawType = rawType;\r\n    this.typeArguments = typeArguments;\r\n}\n@Override\r\npublic String getTypeName() {\r\n    String typeName = this.rawType.getTypeName();\r\n    if (this.typeArguments.length > 0) {\r\n        StringJoiner stringJoiner = new StringJoiner(\", \", \"<\", \">\");\r\n        for (Type argument : this.typeArguments) {\r\n            stringJoiner.add(argument.getTypeName());\r\n        }\r\n        return typeName + stringJoiner;\r\n    }\r\n    return typeName;\r\n}\n@Override\r\n@Nullable\r\npublic Type getOwnerType() {\r\n    return null;\r\n}\n@Override\r\npublic Type getRawType() {\r\n    return this.rawType;\r\n}\n@Override\r\npublic Type[] getActualTypeArguments() {\r\n    return this.typeArguments;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ParameterizedType that && that.getOwnerType() == null && this.rawType.equals(that.getRawType()) && Arrays.equals(this.typeArguments, that.getActualTypeArguments())));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return (this.rawType.hashCode() * 31 + Arrays.hashCode(this.typeArguments));\r\n}\n@Override\r\npublic String toString() {\r\n    return getTypeName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#getTypeName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getTypeName() {\r\n    String typeName = this.rawType.getTypeName();\r\n    if (this.typeArguments.length > 0) {\r\n        StringJoiner stringJoiner = new StringJoiner(\", \", \"<\", \">\");\r\n        for (Type argument : this.typeArguments) {\r\n            stringJoiner.add(argument.getTypeName());\r\n        }\r\n        return typeName + stringJoiner;\r\n    }\r\n    return typeName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#getOwnerType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Type getOwnerType() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#getRawType()",
    "entityType": "method",
    "code": "@Override\r\npublic Type getRawType() {\r\n    return this.rawType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#getActualTypeArguments()",
    "entityType": "method",
    "code": "@Override\r\npublic Type[] getActualTypeArguments() {\r\n    return this.typeArguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ParameterizedType that && that.getOwnerType() == null && this.rawType.equals(that.getRawType()) && Arrays.equals(this.typeArguments, that.getActualTypeArguments())));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return (this.rawType.hashCode() * 31 + Arrays.hashCode(this.typeArguments));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SyntheticParameterizedType#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return getTypeName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WildcardBounds",
    "entityType": "class",
    "code": "private final Kind kind;\nprivate final ResolvableType[] bounds;\n/**\r\n * Internal constructor to create a new {@link WildcardBounds} instance.\r\n * @param kind the kind of bounds\r\n * @param bounds the bounds\r\n * @see #get(ResolvableType)\r\n */\r\npublic WildcardBounds(Kind kind, ResolvableType[] bounds) {\r\n    this.kind = kind;\r\n    this.bounds = bounds;\r\n}\n/**\r\n * Return {@code true} if these bounds are the same kind as the specified bounds.\r\n */\r\npublic boolean isSameKind(WildcardBounds bounds) {\r\n    return this.kind == bounds.kind;\r\n}\n/**\r\n * Return {@code true} if these bounds are assignable from all the specified types.\r\n * @param types the types to test against\r\n * @return {@code true} if these bounds are assignable from all types\r\n */\r\npublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\r\n    for (ResolvableType bound : this.bounds) {\r\n        boolean matched = false;\r\n        for (ResolvableType type : types) {\r\n            if (this.kind == Kind.UPPER ? bound.isAssignableFrom(type, false, matchedBefore, false) : type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                matched = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Return {@code true} if these bounds are assignable from the specified type.\r\n * @param type the type to test against\r\n * @return {@code true} if these bounds are assignable from the type\r\n * @since 6.2\r\n */\r\npublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\r\n    for (ResolvableType bound : this.bounds) {\r\n        if (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) : !type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Return {@code true} if these bounds are assignable to the specified type.\r\n * @param type the type to test against\r\n * @return {@code true} if these bounds are assignable to the type\r\n * @since 6.2\r\n */\r\npublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\r\n    if (this.kind == Kind.UPPER) {\r\n        for (ResolvableType bound : this.bounds) {\r\n            if (type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    } else {\r\n        return (type.resolve() == Object.class);\r\n    }\r\n}\n/**\r\n * Return {@code true} if these bounds are equal to the specified type.\r\n * @param type the type to test against\r\n * @return {@code true} if these bounds are equal to the type\r\n * @since 6.2.3\r\n */\r\npublic boolean equalsType(ResolvableType type) {\r\n    for (ResolvableType bound : this.bounds) {\r\n        if (!type.equalsType(bound)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Return the underlying bounds.\r\n */\r\npublic ResolvableType[] getBounds() {\r\n    return this.bounds;\r\n}\n/**\r\n * Get a {@link WildcardBounds} instance for the specified type, returning\r\n * {@code null} if the specified type cannot be resolved to a {@link WildcardType}\r\n * or an equivalent unresolvable type variable.\r\n * @param type the source type\r\n * @return a {@link WildcardBounds} instance or {@code null}\r\n */\r\n@Nullable\r\npublic static WildcardBounds get(ResolvableType type) {\r\n    ResolvableType candidate = type;\r\n    while (!(candidate.getType() instanceof WildcardType || candidate.isUnresolvableTypeVariable())) {\r\n        if (candidate == NONE) {\r\n            return null;\r\n        }\r\n        candidate = candidate.resolveType();\r\n    }\r\n    Kind boundsType;\r\n    Type[] bounds;\r\n    if (candidate.getType() instanceof WildcardType wildcardType) {\r\n        boundsType = (wildcardType.getLowerBounds().length > 0 ? Kind.LOWER : Kind.UPPER);\r\n        bounds = (boundsType == Kind.UPPER ? wildcardType.getUpperBounds() : wildcardType.getLowerBounds());\r\n    } else {\r\n        boundsType = Kind.UPPER;\r\n        bounds = ((TypeVariable<?>) candidate.getType()).getBounds();\r\n    }\r\n    ResolvableType[] resolvableBounds = new ResolvableType[bounds.length];\r\n    for (int i = 0; i < bounds.length; i++) {\r\n        resolvableBounds[i] = ResolvableType.forType(bounds[i], type.variableResolver);\r\n    }\r\n    return new WildcardBounds(boundsType, resolvableBounds);\r\n}\n/**\r\n * The various kinds of bounds.\r\n */\r\nenum Kind {\r\n\r\n    UPPER, LOWER\r\n}",
    "comment": "\n\t * Internal helper to handle bounds from {@link WildcardType WildcardTypes}.\n\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#isSameKind(WildcardBounds)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if these bounds are the same kind as the specified bounds.\r\n */\r\npublic boolean isSameKind(WildcardBounds bounds) {\r\n    return this.kind == bounds.kind;\r\n}",
    "comment": "\n\t\t * Return {@code true} if these bounds are the same kind as the specified bounds.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#isAssignableFrom(ResolvableType[],Map<Type,Type>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if these bounds are assignable from all the specified types.\r\n * @param types the types to test against\r\n * @return {@code true} if these bounds are assignable from all types\r\n */\r\npublic boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\r\n    for (ResolvableType bound : this.bounds) {\r\n        boolean matched = false;\r\n        for (ResolvableType type : types) {\r\n            if (this.kind == Kind.UPPER ? bound.isAssignableFrom(type, false, matchedBefore, false) : type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                matched = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!matched) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t\t * Return {@code true} if these bounds are assignable from all the specified types.\n\t\t * @param types the types to test against\n\t\t * @return {@code true} if these bounds are assignable from all types\n\t\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#isAssignableFrom(ResolvableType,Map<Type,Type>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if these bounds are assignable from the specified type.\r\n * @param type the type to test against\r\n * @return {@code true} if these bounds are assignable from the type\r\n * @since 6.2\r\n */\r\npublic boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\r\n    for (ResolvableType bound : this.bounds) {\r\n        if (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) : !type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t\t * Return {@code true} if these bounds are assignable from the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable from the type\n\t\t * @since 6.2\n\t\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#isAssignableTo(ResolvableType,Map<Type,Type>)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if these bounds are assignable to the specified type.\r\n * @param type the type to test against\r\n * @return {@code true} if these bounds are assignable to the type\r\n * @since 6.2\r\n */\r\npublic boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\r\n    if (this.kind == Kind.UPPER) {\r\n        for (ResolvableType bound : this.bounds) {\r\n            if (type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    } else {\r\n        return (type.resolve() == Object.class);\r\n    }\r\n}",
    "comment": "\n\t\t * Return {@code true} if these bounds are assignable to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are assignable to the type\n\t\t * @since 6.2\n\t\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#equalsType(ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if these bounds are equal to the specified type.\r\n * @param type the type to test against\r\n * @return {@code true} if these bounds are equal to the type\r\n * @since 6.2.3\r\n */\r\npublic boolean equalsType(ResolvableType type) {\r\n    for (ResolvableType bound : this.bounds) {\r\n        if (!type.equalsType(bound)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t\t * Return {@code true} if these bounds are equal to the specified type.\n\t\t * @param type the type to test against\n\t\t * @return {@code true} if these bounds are equal to the type\n\t\t * @since 6.2.3\n\t\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#getBounds()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying bounds.\r\n */\r\npublic ResolvableType[] getBounds() {\r\n    return this.bounds;\r\n}",
    "comment": "\n\t\t * Return the underlying bounds.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.WildcardBounds#get(ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Get a {@link WildcardBounds} instance for the specified type, returning\r\n * {@code null} if the specified type cannot be resolved to a {@link WildcardType}\r\n * or an equivalent unresolvable type variable.\r\n * @param type the source type\r\n * @return a {@link WildcardBounds} instance or {@code null}\r\n */\r\n@Nullable\r\npublic static WildcardBounds get(ResolvableType type) {\r\n    ResolvableType candidate = type;\r\n    while (!(candidate.getType() instanceof WildcardType || candidate.isUnresolvableTypeVariable())) {\r\n        if (candidate == NONE) {\r\n            return null;\r\n        }\r\n        candidate = candidate.resolveType();\r\n    }\r\n    Kind boundsType;\r\n    Type[] bounds;\r\n    if (candidate.getType() instanceof WildcardType wildcardType) {\r\n        boundsType = (wildcardType.getLowerBounds().length > 0 ? Kind.LOWER : Kind.UPPER);\r\n        bounds = (boundsType == Kind.UPPER ? wildcardType.getUpperBounds() : wildcardType.getLowerBounds());\r\n    } else {\r\n        boundsType = Kind.UPPER;\r\n        bounds = ((TypeVariable<?>) candidate.getType()).getBounds();\r\n    }\r\n    ResolvableType[] resolvableBounds = new ResolvableType[bounds.length];\r\n    for (int i = 0; i < bounds.length; i++) {\r\n        resolvableBounds[i] = ResolvableType.forType(bounds[i], type.variableResolver);\r\n    }\r\n    return new WildcardBounds(boundsType, resolvableBounds);\r\n}",
    "comment": "\n\t\t * Get a {@link WildcardBounds} instance for the specified type, returning\n\t\t * {@code null} if the specified type cannot be resolved to a {@link WildcardType}\n\t\t * or an equivalent unresolvable type variable.\n\t\t * @param type the source type\n\t\t * @return a {@link WildcardBounds} instance or {@code null}\n\t\t "
  },
  {
    "entityId": "org.springframework.core.EmptyType",
    "entityType": "class",
    "code": "static final Type INSTANCE = new EmptyType();\nObject readResolve() {\r\n    return INSTANCE;\r\n}",
    "comment": "\n\t * Internal {@link Type} used to represent an empty value.\n\t "
  },
  {
    "entityId": "org.springframework.core.EmptyType#readResolve()",
    "entityType": "method",
    "code": "Object readResolve() {\r\n    return INSTANCE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeProvider",
    "entityType": "class",
    "code": "/**\r\n * Return the {@link ResolvableType} describing this instance\r\n * (or {@code null} if some sort of default should be applied instead).\r\n */\r\n@Nullable\r\nResolvableType getResolvableType();",
    "comment": "\n * Any object can implement this interface to provide its actual {@link ResolvableType}.\n *\n * <p>Such information is very useful when figuring out if the instance matches a generic\n * signature as Java does not convey the signature at runtime.\n *\n * <p>Users of this interface should be careful in complex hierarchy scenarios, especially\n * when the generic type signature of the class changes in subclasses. It is always\n * possible to return {@code null} to fallback on a default behavior.\n *\n * @author Stephane Nicoll\n * @since 4.2\n "
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeProvider#getResolvableType()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link ResolvableType} describing this instance\r\n * (or {@code null} if some sort of default should be applied instead).\r\n */\r\n@Nullable\r\nResolvableType getResolvableType();",
    "comment": "\n\t * Return the {@link ResolvableType} describing this instance\n\t * (or {@code null} if some sort of default should be applied instead).\n\t "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeWrapper",
    "entityType": "class",
    "code": "private static final Class<?>[] SUPPORTED_SERIALIZABLE_TYPES = { GenericArrayType.class, ParameterizedType.class, TypeVariable.class, WildcardType.class };\nstatic final ConcurrentReferenceHashMap<Type, Type> cache = new ConcurrentReferenceHashMap<>(256);\nprivate SerializableTypeWrapper() {\r\n}\n/**\r\n * Return a {@link Serializable} variant of {@link Field#getGenericType()}.\r\n */\r\n@Nullable\r\npublic static Type forField(Field field) {\r\n    return forTypeProvider(new FieldTypeProvider(field));\r\n}\n/**\r\n * Return a {@link Serializable} variant of\r\n * {@link MethodParameter#getGenericParameterType()}.\r\n */\r\n@Nullable\r\npublic static Type forMethodParameter(MethodParameter methodParameter) {\r\n    return forTypeProvider(new MethodParameterTypeProvider(methodParameter));\r\n}\n/**\r\n * Unwrap the given type, effectively returning the original non-serializable type.\r\n * @param type the type to unwrap\r\n * @return the original non-serializable type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Type> T unwrap(T type) {\r\n    Type unwrapped = null;\r\n    if (type instanceof SerializableTypeProxy proxy) {\r\n        unwrapped = proxy.getTypeProvider().getType();\r\n    }\r\n    return (unwrapped != null ? (T) unwrapped : type);\r\n}\n/**\r\n * Return a {@link Serializable} {@link Type} backed by a {@link TypeProvider} .\r\n * <p>If type artifacts are generally not serializable in the current runtime\r\n * environment, this delegate will simply return the original {@code Type} as-is.\r\n */\r\n@Nullable\r\nstatic Type forTypeProvider(TypeProvider provider) {\r\n    Type providedType = provider.getType();\r\n    if (providedType == null || providedType instanceof Serializable) {\r\n        // No serializable type wrapping necessary (for example, for java.lang.Class)\r\n        return providedType;\r\n    }\r\n    if (NativeDetector.inNativeImage() || !Serializable.class.isAssignableFrom(Class.class)) {\r\n        // Let's skip any wrapping attempts if types are generally not serializable in\r\n        // the current runtime environment (even java.lang.Class itself, for example, on GraalVM native images)\r\n        return providedType;\r\n    }\r\n    // Obtain a serializable type proxy for the given provider...\r\n    Type cached = cache.get(providedType);\r\n    if (cached != null) {\r\n        return cached;\r\n    }\r\n    for (Class<?> type : SUPPORTED_SERIALIZABLE_TYPES) {\r\n        if (type.isInstance(providedType)) {\r\n            ClassLoader classLoader = provider.getClass().getClassLoader();\r\n            Class<?>[] interfaces = new Class<?>[] { type, SerializableTypeProxy.class, Serializable.class };\r\n            InvocationHandler handler = new TypeProxyInvocationHandler(provider);\r\n            cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);\r\n            cache.put(providedType, cached);\r\n            return cached;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Unsupported Type class: \" + providedType.getClass().getName());\r\n}\n/**\r\n * Additional interface implemented by the type proxy.\r\n */\r\ninterface SerializableTypeProxy {\r\n\r\n    /**\r\n     * Return the underlying type provider.\r\n     */\r\n    TypeProvider getTypeProvider();\r\n}\n/**\r\n * A {@link Serializable} interface providing access to a {@link Type}.\r\n */\r\n@SuppressWarnings(\"serial\")\r\ninterface TypeProvider extends Serializable {\r\n\r\n    /**\r\n     * Return the (possibly non {@link Serializable}) {@link Type}.\r\n     */\r\n    @Nullable\r\n    Type getType();\r\n\r\n    /**\r\n     * Return the source of the type, or {@code null} if not known.\r\n     * <p>The default implementation returns {@code null}.\r\n     */\r\n    @Nullable\r\n    default Object getSource() {\r\n        return null;\r\n    }\r\n}\n/**\r\n * {@link Serializable} {@link InvocationHandler} used by the proxied {@link Type}.\r\n * Provides serialization support and enhances any methods that return {@code Type}\r\n * or {@code Type[]}.\r\n */\r\n@SuppressWarnings(\"serial\")\r\nprivate static class TypeProxyInvocationHandler implements InvocationHandler, Serializable {\r\n\r\n    private final TypeProvider provider;\r\n\r\n    public TypeProxyInvocationHandler(TypeProvider provider) {\r\n        this.provider = provider;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n        switch(method.getName()) {\r\n            case \"equals\" ->\r\n                {\r\n                    Object other = args[0];\r\n                    // Unwrap proxies for speed\r\n                    if (other instanceof Type otherType) {\r\n                        other = unwrap(otherType);\r\n                    }\r\n                    return ObjectUtils.nullSafeEquals(this.provider.getType(), other);\r\n                }\r\n            case \"hashCode\" ->\r\n                {\r\n                    return ObjectUtils.nullSafeHashCode(this.provider.getType());\r\n                }\r\n            case \"getTypeProvider\" ->\r\n                {\r\n                    return this.provider;\r\n                }\r\n        }\r\n        if (Type.class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\r\n            return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));\r\n        } else if (Type[].class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\r\n            Object returnValue = ReflectionUtils.invokeMethod(method, this.provider.getType());\r\n            if (returnValue == null) {\r\n                return null;\r\n            }\r\n            @Nullable\r\n            Type[] result = new Type[((Type[]) returnValue).length];\r\n            for (int i = 0; i < result.length; i++) {\r\n                result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));\r\n            }\r\n            return result;\r\n        }\r\n        Type type = this.provider.getType();\r\n        if (type instanceof TypeVariable<?> tv && method.getName().equals(\"getName\")) {\r\n            // Avoid reflection for common comparison of type variables\r\n            return tv.getName();\r\n        }\r\n        return ReflectionUtils.invokeMethod(method, type, args);\r\n    }\r\n}\n/**\r\n * {@link TypeProvider} for {@link Type Types} obtained from a {@link Field}.\r\n */\r\n@SuppressWarnings(\"serial\")\r\nstatic class FieldTypeProvider implements TypeProvider {\r\n\r\n    private final String fieldName;\r\n\r\n    private final Class<?> declaringClass;\r\n\r\n    private transient Field field;\r\n\r\n    public FieldTypeProvider(Field field) {\r\n        this.fieldName = field.getName();\r\n        this.declaringClass = field.getDeclaringClass();\r\n        this.field = field;\r\n    }\r\n\r\n    @Override\r\n    public Type getType() {\r\n        return this.field.getGenericType();\r\n    }\r\n\r\n    @Override\r\n    public Object getSource() {\r\n        return this.field;\r\n    }\r\n\r\n    private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n        inputStream.defaultReadObject();\r\n        try {\r\n            this.field = this.declaringClass.getDeclaredField(this.fieldName);\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Could not find original class structure\", ex);\r\n        }\r\n    }\r\n}\n/**\r\n * {@link TypeProvider} for {@link Type Types} obtained from a {@link MethodParameter}.\r\n */\r\n@SuppressWarnings(\"serial\")\r\nstatic class MethodParameterTypeProvider implements TypeProvider {\r\n\r\n    @Nullable\r\n    private final String methodName;\r\n\r\n    private final Class<?>[] parameterTypes;\r\n\r\n    private final Class<?> declaringClass;\r\n\r\n    private final int parameterIndex;\r\n\r\n    private transient MethodParameter methodParameter;\r\n\r\n    public MethodParameterTypeProvider(MethodParameter methodParameter) {\r\n        this.methodName = (methodParameter.getMethod() != null ? methodParameter.getMethod().getName() : null);\r\n        this.parameterTypes = methodParameter.getExecutable().getParameterTypes();\r\n        this.declaringClass = methodParameter.getDeclaringClass();\r\n        this.parameterIndex = methodParameter.getParameterIndex();\r\n        this.methodParameter = methodParameter;\r\n    }\r\n\r\n    @Override\r\n    public Type getType() {\r\n        return this.methodParameter.getGenericParameterType();\r\n    }\r\n\r\n    @Override\r\n    public Object getSource() {\r\n        return this.methodParameter;\r\n    }\r\n\r\n    private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n        inputStream.defaultReadObject();\r\n        try {\r\n            if (this.methodName != null) {\r\n                this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);\r\n            } else {\r\n                this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);\r\n            }\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Could not find original class structure\", ex);\r\n        }\r\n    }\r\n}\n/**\r\n * {@link TypeProvider} for {@link Type Types} obtained by invoking a no-arg method.\r\n */\r\n@SuppressWarnings(\"serial\")\r\nstatic class MethodInvokeTypeProvider implements TypeProvider {\r\n\r\n    private final TypeProvider provider;\r\n\r\n    private final String methodName;\r\n\r\n    private final Class<?> declaringClass;\r\n\r\n    private final int index;\r\n\r\n    private transient Method method;\r\n\r\n    @Nullable\r\n    private transient volatile Object result;\r\n\r\n    public MethodInvokeTypeProvider(TypeProvider provider, Method method, int index) {\r\n        this.provider = provider;\r\n        this.methodName = method.getName();\r\n        this.declaringClass = method.getDeclaringClass();\r\n        this.index = index;\r\n        this.method = method;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Type getType() {\r\n        Object result = this.result;\r\n        if (result == null) {\r\n            // Lazy invocation of the target method on the provided type\r\n            result = ReflectionUtils.invokeMethod(this.method, this.provider.getType());\r\n            // Cache the result for further calls to getType()\r\n            this.result = result;\r\n        }\r\n        return (result instanceof Type[] results ? results[this.index] : (Type) result);\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Object getSource() {\r\n        return null;\r\n    }\r\n\r\n    private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n        inputStream.defaultReadObject();\r\n        Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName);\r\n        if (method == null) {\r\n            throw new IllegalStateException(\"Cannot find method on deserialization: \" + this.methodName);\r\n        }\r\n        if (method.getReturnType() != Type.class && method.getReturnType() != Type[].class) {\r\n            throw new IllegalStateException(\"Invalid return type on deserialized method - needs to be Type or Type[]: \" + method);\r\n        }\r\n        this.method = method;\r\n    }\r\n}",
    "comment": "\n * Internal utility class that can be used to obtain wrapped {@link Serializable}\n * variants of {@link java.lang.reflect.Type java.lang.reflect.Types}.\n *\n * <p>{@link #forField(Field) Fields} or {@link #forMethodParameter(MethodParameter)\n * MethodParameters} can be used as the root source for a serializable type.\n * Alternatively, a regular {@link Class} can also be used as source.\n *\n * <p>The returned type will either be a {@link Class} or a serializable proxy of\n * {@link GenericArrayType}, {@link ParameterizedType}, {@link TypeVariable} or\n * {@link WildcardType}. With the exception of {@link Class} (which is final) calls\n * to methods that return further {@link Type Types} (for example\n * {@link GenericArrayType#getGenericComponentType()}) will be automatically wrapped.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeWrapper#forField(Field)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Serializable} variant of {@link Field#getGenericType()}.\r\n */\r\n@Nullable\r\npublic static Type forField(Field field) {\r\n    return forTypeProvider(new FieldTypeProvider(field));\r\n}",
    "comment": "\n\t * Return a {@link Serializable} variant of {@link Field#getGenericType()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeWrapper#forMethodParameter(MethodParameter)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Serializable} variant of\r\n * {@link MethodParameter#getGenericParameterType()}.\r\n */\r\n@Nullable\r\npublic static Type forMethodParameter(MethodParameter methodParameter) {\r\n    return forTypeProvider(new MethodParameterTypeProvider(methodParameter));\r\n}",
    "comment": "\n\t * Return a {@link Serializable} variant of\n\t * {@link MethodParameter#getGenericParameterType()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeWrapper#unwrap(T)",
    "entityType": "method",
    "code": "/**\r\n * Unwrap the given type, effectively returning the original non-serializable type.\r\n * @param type the type to unwrap\r\n * @return the original non-serializable type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Type> T unwrap(T type) {\r\n    Type unwrapped = null;\r\n    if (type instanceof SerializableTypeProxy proxy) {\r\n        unwrapped = proxy.getTypeProvider().getType();\r\n    }\r\n    return (unwrapped != null ? (T) unwrapped : type);\r\n}",
    "comment": "\n\t * Unwrap the given type, effectively returning the original non-serializable type.\n\t * @param type the type to unwrap\n\t * @return the original non-serializable type\n\t "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeWrapper#forTypeProvider(TypeProvider)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Serializable} {@link Type} backed by a {@link TypeProvider} .\r\n * <p>If type artifacts are generally not serializable in the current runtime\r\n * environment, this delegate will simply return the original {@code Type} as-is.\r\n */\r\n@Nullable\r\nstatic Type forTypeProvider(TypeProvider provider) {\r\n    Type providedType = provider.getType();\r\n    if (providedType == null || providedType instanceof Serializable) {\r\n        // No serializable type wrapping necessary (for example, for java.lang.Class)\r\n        return providedType;\r\n    }\r\n    if (NativeDetector.inNativeImage() || !Serializable.class.isAssignableFrom(Class.class)) {\r\n        // Let's skip any wrapping attempts if types are generally not serializable in\r\n        // the current runtime environment (even java.lang.Class itself, for example, on GraalVM native images)\r\n        return providedType;\r\n    }\r\n    // Obtain a serializable type proxy for the given provider...\r\n    Type cached = cache.get(providedType);\r\n    if (cached != null) {\r\n        return cached;\r\n    }\r\n    for (Class<?> type : SUPPORTED_SERIALIZABLE_TYPES) {\r\n        if (type.isInstance(providedType)) {\r\n            ClassLoader classLoader = provider.getClass().getClassLoader();\r\n            Class<?>[] interfaces = new Class<?>[] { type, SerializableTypeProxy.class, Serializable.class };\r\n            InvocationHandler handler = new TypeProxyInvocationHandler(provider);\r\n            cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);\r\n            cache.put(providedType, cached);\r\n            return cached;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Unsupported Type class: \" + providedType.getClass().getName());\r\n}",
    "comment": "\n\t * Return a {@link Serializable} {@link Type} backed by a {@link TypeProvider} .\n\t * <p>If type artifacts are generally not serializable in the current runtime\n\t * environment, this delegate will simply return the original {@code Type} as-is.\n\t "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeProxy",
    "entityType": "class",
    "code": "/**\r\n * Return the underlying type provider.\r\n */\r\nTypeProvider getTypeProvider();",
    "comment": "\n\t * Additional interface implemented by the type proxy.\n\t "
  },
  {
    "entityId": "org.springframework.core.SerializableTypeProxy#getTypeProvider()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying type provider.\r\n */\r\nTypeProvider getTypeProvider();",
    "comment": "\n\t\t * Return the underlying type provider.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.TypeProvider",
    "entityType": "class",
    "code": "/**\r\n * Return the (possibly non {@link Serializable}) {@link Type}.\r\n */\r\n@Nullable\r\nType getType();\n/**\r\n * Return the source of the type, or {@code null} if not known.\r\n * <p>The default implementation returns {@code null}.\r\n */\r\n@Nullable\r\ndefault Object getSource() {\r\n    return null;\r\n}",
    "comment": "\n\t * A {@link Serializable} interface providing access to a {@link Type}.\n\t "
  },
  {
    "entityId": "org.springframework.core.TypeProvider#getType()",
    "entityType": "method",
    "code": "/**\r\n * Return the (possibly non {@link Serializable}) {@link Type}.\r\n */\r\n@Nullable\r\nType getType();",
    "comment": "\n\t\t * Return the (possibly non {@link Serializable}) {@link Type}.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.TypeProvider#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Return the source of the type, or {@code null} if not known.\r\n * <p>The default implementation returns {@code null}.\r\n */\r\n@Nullable\r\ndefault Object getSource() {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Return the source of the type, or {@code null} if not known.\n\t\t * <p>The default implementation returns {@code null}.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.TypeProxyInvocationHandler",
    "entityType": "class",
    "code": "private final TypeProvider provider;\npublic TypeProxyInvocationHandler(TypeProvider provider) {\r\n    this.provider = provider;\r\n}\n@Override\r\n@Nullable\r\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n    switch(method.getName()) {\r\n        case \"equals\" ->\r\n            {\r\n                Object other = args[0];\r\n                // Unwrap proxies for speed\r\n                if (other instanceof Type otherType) {\r\n                    other = unwrap(otherType);\r\n                }\r\n                return ObjectUtils.nullSafeEquals(this.provider.getType(), other);\r\n            }\r\n        case \"hashCode\" ->\r\n            {\r\n                return ObjectUtils.nullSafeHashCode(this.provider.getType());\r\n            }\r\n        case \"getTypeProvider\" ->\r\n            {\r\n                return this.provider;\r\n            }\r\n    }\r\n    if (Type.class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\r\n        return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));\r\n    } else if (Type[].class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\r\n        Object returnValue = ReflectionUtils.invokeMethod(method, this.provider.getType());\r\n        if (returnValue == null) {\r\n            return null;\r\n        }\r\n        @Nullable\r\n        Type[] result = new Type[((Type[]) returnValue).length];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));\r\n        }\r\n        return result;\r\n    }\r\n    Type type = this.provider.getType();\r\n    if (type instanceof TypeVariable<?> tv && method.getName().equals(\"getName\")) {\r\n        // Avoid reflection for common comparison of type variables\r\n        return tv.getName();\r\n    }\r\n    return ReflectionUtils.invokeMethod(method, type, args);\r\n}",
    "comment": "\n\t * {@link Serializable} {@link InvocationHandler} used by the proxied {@link Type}.\n\t * Provides serialization support and enhances any methods that return {@code Type}\n\t * or {@code Type[]}.\n\t "
  },
  {
    "entityId": "org.springframework.core.TypeProxyInvocationHandler#invoke(Object,Method,Object[])",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n    switch(method.getName()) {\r\n        case \"equals\" ->\r\n            {\r\n                Object other = args[0];\r\n                // Unwrap proxies for speed\r\n                if (other instanceof Type otherType) {\r\n                    other = unwrap(otherType);\r\n                }\r\n                return ObjectUtils.nullSafeEquals(this.provider.getType(), other);\r\n            }\r\n        case \"hashCode\" ->\r\n            {\r\n                return ObjectUtils.nullSafeHashCode(this.provider.getType());\r\n            }\r\n        case \"getTypeProvider\" ->\r\n            {\r\n                return this.provider;\r\n            }\r\n    }\r\n    if (Type.class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\r\n        return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));\r\n    } else if (Type[].class == method.getReturnType() && ObjectUtils.isEmpty(args)) {\r\n        Object returnValue = ReflectionUtils.invokeMethod(method, this.provider.getType());\r\n        if (returnValue == null) {\r\n            return null;\r\n        }\r\n        @Nullable\r\n        Type[] result = new Type[((Type[]) returnValue).length];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));\r\n        }\r\n        return result;\r\n    }\r\n    Type type = this.provider.getType();\r\n    if (type instanceof TypeVariable<?> tv && method.getName().equals(\"getName\")) {\r\n        // Avoid reflection for common comparison of type variables\r\n        return tv.getName();\r\n    }\r\n    return ReflectionUtils.invokeMethod(method, type, args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FieldTypeProvider",
    "entityType": "class",
    "code": "private final String fieldName;\nprivate final Class<?> declaringClass;\nprivate transient Field field;\npublic FieldTypeProvider(Field field) {\r\n    this.fieldName = field.getName();\r\n    this.declaringClass = field.getDeclaringClass();\r\n    this.field = field;\r\n}\n@Override\r\npublic Type getType() {\r\n    return this.field.getGenericType();\r\n}\n@Override\r\npublic Object getSource() {\r\n    return this.field;\r\n}\nprivate void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n    inputStream.defaultReadObject();\r\n    try {\r\n        this.field = this.declaringClass.getDeclaredField(this.fieldName);\r\n    } catch (Throwable ex) {\r\n        throw new IllegalStateException(\"Could not find original class structure\", ex);\r\n    }\r\n}",
    "comment": "\n\t * {@link TypeProvider} for {@link Type Types} obtained from a {@link Field}.\n\t "
  },
  {
    "entityId": "org.springframework.core.FieldTypeProvider#getType()",
    "entityType": "method",
    "code": "@Override\r\npublic Type getType() {\r\n    return this.field.getGenericType();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FieldTypeProvider#getSource()",
    "entityType": "method",
    "code": "@Override\r\npublic Object getSource() {\r\n    return this.field;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FieldTypeProvider#readObject(ObjectInputStream)",
    "entityType": "method",
    "code": "private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n    inputStream.defaultReadObject();\r\n    try {\r\n        this.field = this.declaringClass.getDeclaredField(this.fieldName);\r\n    } catch (Throwable ex) {\r\n        throw new IllegalStateException(\"Could not find original class structure\", ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameterTypeProvider",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final String methodName;\nprivate final Class<?>[] parameterTypes;\nprivate final Class<?> declaringClass;\nprivate final int parameterIndex;\nprivate transient MethodParameter methodParameter;\npublic MethodParameterTypeProvider(MethodParameter methodParameter) {\r\n    this.methodName = (methodParameter.getMethod() != null ? methodParameter.getMethod().getName() : null);\r\n    this.parameterTypes = methodParameter.getExecutable().getParameterTypes();\r\n    this.declaringClass = methodParameter.getDeclaringClass();\r\n    this.parameterIndex = methodParameter.getParameterIndex();\r\n    this.methodParameter = methodParameter;\r\n}\n@Override\r\npublic Type getType() {\r\n    return this.methodParameter.getGenericParameterType();\r\n}\n@Override\r\npublic Object getSource() {\r\n    return this.methodParameter;\r\n}\nprivate void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n    inputStream.defaultReadObject();\r\n    try {\r\n        if (this.methodName != null) {\r\n            this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);\r\n        } else {\r\n            this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);\r\n        }\r\n    } catch (Throwable ex) {\r\n        throw new IllegalStateException(\"Could not find original class structure\", ex);\r\n    }\r\n}",
    "comment": "\n\t * {@link TypeProvider} for {@link Type Types} obtained from a {@link MethodParameter}.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameterTypeProvider#getType()",
    "entityType": "method",
    "code": "@Override\r\npublic Type getType() {\r\n    return this.methodParameter.getGenericParameterType();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameterTypeProvider#getSource()",
    "entityType": "method",
    "code": "@Override\r\npublic Object getSource() {\r\n    return this.methodParameter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameterTypeProvider#readObject(ObjectInputStream)",
    "entityType": "method",
    "code": "private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n    inputStream.defaultReadObject();\r\n    try {\r\n        if (this.methodName != null) {\r\n            this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);\r\n        } else {\r\n            this.methodParameter = new MethodParameter(this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);\r\n        }\r\n    } catch (Throwable ex) {\r\n        throw new IllegalStateException(\"Could not find original class structure\", ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodInvokeTypeProvider",
    "entityType": "class",
    "code": "private final TypeProvider provider;\nprivate final String methodName;\nprivate final Class<?> declaringClass;\nprivate final int index;\nprivate transient Method method;\n@Nullable\r\nprivate transient volatile Object result;\npublic MethodInvokeTypeProvider(TypeProvider provider, Method method, int index) {\r\n    this.provider = provider;\r\n    this.methodName = method.getName();\r\n    this.declaringClass = method.getDeclaringClass();\r\n    this.index = index;\r\n    this.method = method;\r\n}\n@Override\r\n@Nullable\r\npublic Type getType() {\r\n    Object result = this.result;\r\n    if (result == null) {\r\n        // Lazy invocation of the target method on the provided type\r\n        result = ReflectionUtils.invokeMethod(this.method, this.provider.getType());\r\n        // Cache the result for further calls to getType()\r\n        this.result = result;\r\n    }\r\n    return (result instanceof Type[] results ? results[this.index] : (Type) result);\r\n}\n@Override\r\n@Nullable\r\npublic Object getSource() {\r\n    return null;\r\n}\nprivate void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n    inputStream.defaultReadObject();\r\n    Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName);\r\n    if (method == null) {\r\n        throw new IllegalStateException(\"Cannot find method on deserialization: \" + this.methodName);\r\n    }\r\n    if (method.getReturnType() != Type.class && method.getReturnType() != Type[].class) {\r\n        throw new IllegalStateException(\"Invalid return type on deserialized method - needs to be Type or Type[]: \" + method);\r\n    }\r\n    this.method = method;\r\n}",
    "comment": "\n\t * {@link TypeProvider} for {@link Type Types} obtained by invoking a no-arg method.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodInvokeTypeProvider#getType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Type getType() {\r\n    Object result = this.result;\r\n    if (result == null) {\r\n        // Lazy invocation of the target method on the provided type\r\n        result = ReflectionUtils.invokeMethod(this.method, this.provider.getType());\r\n        // Cache the result for further calls to getType()\r\n        this.result = result;\r\n    }\r\n    return (result instanceof Type[] results ? results[this.index] : (Type) result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodInvokeTypeProvider#getSource()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object getSource() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodInvokeTypeProvider#readObject(ObjectInputStream)",
    "entityType": "method",
    "code": "private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\r\n    inputStream.defaultReadObject();\r\n    Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName);\r\n    if (method == null) {\r\n        throw new IllegalStateException(\"Cannot find method on deserialization: \" + this.methodName);\r\n    }\r\n    if (method.getReturnType() != Type.class && method.getReturnType() != Type[].class) {\r\n        throw new IllegalStateException(\"Invalid return type on deserialized method - needs to be Type or Type[]: \" + method);\r\n    }\r\n    this.method = method;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.serializer.DefaultDeserializer",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final ClassLoader classLoader;\n/**\r\n * Create a {@code DefaultDeserializer} with default {@link ObjectInputStream}\r\n * configuration, using the \"latest user-defined ClassLoader\".\r\n */\r\npublic DefaultDeserializer() {\r\n    this.classLoader = null;\r\n}\n/**\r\n * Create a {@code DefaultDeserializer} for using an {@link ObjectInputStream}\r\n * with the given {@code ClassLoader}.\r\n * @param classLoader the ClassLoader to use\r\n * @since 4.2.1\r\n * @see ConfigurableObjectInputStream#ConfigurableObjectInputStream(InputStream, ClassLoader)\r\n */\r\npublic DefaultDeserializer(@Nullable ClassLoader classLoader) {\r\n    this.classLoader = classLoader;\r\n}\n/**\r\n * Read from the supplied {@code InputStream} and deserialize the contents\r\n * into an object.\r\n * @see ObjectInputStream#readObject()\r\n */\r\n@Override\r\npublic Object deserialize(InputStream inputStream) throws IOException {\r\n    ObjectInputStream objectInputStream = new ConfigurableObjectInputStream(inputStream, this.classLoader);\r\n    try {\r\n        return objectInputStream.readObject();\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new IOException(\"Failed to deserialize object type\", ex);\r\n    }\r\n}",
    "comment": "\n * A default {@link Deserializer} implementation that reads an input stream\n * using Java serialization.\n *\n * @author Gary Russell\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0.5\n * @see ObjectInputStream\n "
  },
  {
    "entityId": "org.springframework.core.serializer.DefaultDeserializer#deserialize(InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Read from the supplied {@code InputStream} and deserialize the contents\r\n * into an object.\r\n * @see ObjectInputStream#readObject()\r\n */\r\n@Override\r\npublic Object deserialize(InputStream inputStream) throws IOException {\r\n    ObjectInputStream objectInputStream = new ConfigurableObjectInputStream(inputStream, this.classLoader);\r\n    try {\r\n        return objectInputStream.readObject();\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new IOException(\"Failed to deserialize object type\", ex);\r\n    }\r\n}",
    "comment": "\n\t * Read from the supplied {@code InputStream} and deserialize the contents\n\t * into an object.\n\t * @see ObjectInputStream#readObject()\n\t "
  },
  {
    "entityId": "org.springframework.core.serializer.DefaultSerializer",
    "entityType": "class",
    "code": "/**\r\n * Writes the source object to an output stream using Java serialization.\r\n * The source object must implement {@link Serializable}.\r\n * @see ObjectOutputStream#writeObject(Object)\r\n */\r\n@Override\r\npublic void serialize(Object object, OutputStream outputStream) throws IOException {\r\n    if (!(object instanceof Serializable)) {\r\n        throw new IllegalArgumentException(getClass().getSimpleName() + \" requires a Serializable payload \" + \"but received an object of type [\" + object.getClass().getName() + \"]\");\r\n    }\r\n    ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\r\n    objectOutputStream.writeObject(object);\r\n    objectOutputStream.flush();\r\n}",
    "comment": "\n * A {@link Serializer} implementation that writes an object to an output stream\n * using Java serialization.\n *\n * @author Gary Russell\n * @author Mark Fisher\n * @since 3.0.5\n "
  },
  {
    "entityId": "org.springframework.core.serializer.DefaultSerializer#serialize(Object,OutputStream)",
    "entityType": "method",
    "code": "/**\r\n * Writes the source object to an output stream using Java serialization.\r\n * The source object must implement {@link Serializable}.\r\n * @see ObjectOutputStream#writeObject(Object)\r\n */\r\n@Override\r\npublic void serialize(Object object, OutputStream outputStream) throws IOException {\r\n    if (!(object instanceof Serializable)) {\r\n        throw new IllegalArgumentException(getClass().getSimpleName() + \" requires a Serializable payload \" + \"but received an object of type [\" + object.getClass().getName() + \"]\");\r\n    }\r\n    ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\r\n    objectOutputStream.writeObject(object);\r\n    objectOutputStream.flush();\r\n}",
    "comment": "\n\t * Writes the source object to an output stream using Java serialization.\n\t * The source object must implement {@link Serializable}.\n\t * @see ObjectOutputStream#writeObject(Object)\n\t "
  },
  {
    "entityId": "org.springframework.core.serializer.Deserializer",
    "entityType": "class",
    "code": "/**\r\n * Read (assemble) an object of type T from the given InputStream.\r\n * <p>Note: Implementations should not close the given InputStream\r\n * (or any decorators of that InputStream) but rather leave this up\r\n * to the caller.\r\n * @param inputStream the input stream\r\n * @return the deserialized object\r\n * @throws IOException in case of errors reading from the stream\r\n */\r\nT deserialize(InputStream inputStream) throws IOException;\n/**\r\n * Read (assemble) an object of type T from the given byte array.\r\n * @param serialized the byte array\r\n * @return the deserialized object\r\n * @throws IOException in case of deserialization failure\r\n * @since 5.2.7\r\n */\r\ndefault T deserializeFromByteArray(byte[] serialized) throws IOException {\r\n    return deserialize(new ByteArrayInputStream(serialized));\r\n}",
    "comment": "\n * A strategy interface for converting from data in an InputStream to an Object.\n *\n * @author Gary Russell\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0.5\n * @param <T> the object type\n * @see Serializer\n "
  },
  {
    "entityId": "org.springframework.core.serializer.Deserializer#deserialize(InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Read (assemble) an object of type T from the given InputStream.\r\n * <p>Note: Implementations should not close the given InputStream\r\n * (or any decorators of that InputStream) but rather leave this up\r\n * to the caller.\r\n * @param inputStream the input stream\r\n * @return the deserialized object\r\n * @throws IOException in case of errors reading from the stream\r\n */\r\nT deserialize(InputStream inputStream) throws IOException;",
    "comment": "\n\t * Read (assemble) an object of type T from the given InputStream.\n\t * <p>Note: Implementations should not close the given InputStream\n\t * (or any decorators of that InputStream) but rather leave this up\n\t * to the caller.\n\t * @param inputStream the input stream\n\t * @return the deserialized object\n\t * @throws IOException in case of errors reading from the stream\n\t "
  },
  {
    "entityId": "org.springframework.core.serializer.Deserializer#deserializeFromByteArray(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Read (assemble) an object of type T from the given byte array.\r\n * @param serialized the byte array\r\n * @return the deserialized object\r\n * @throws IOException in case of deserialization failure\r\n * @since 5.2.7\r\n */\r\ndefault T deserializeFromByteArray(byte[] serialized) throws IOException {\r\n    return deserialize(new ByteArrayInputStream(serialized));\r\n}",
    "comment": "\n\t * Read (assemble) an object of type T from the given byte array.\n\t * @param serialized the byte array\n\t * @return the deserialized object\n\t * @throws IOException in case of deserialization failure\n\t * @since 5.2.7\n\t "
  },
  {
    "entityId": "org.springframework.core.serializer.Serializer",
    "entityType": "class",
    "code": "/**\r\n * Write an object of type T to the given OutputStream.\r\n * <p>Note: Implementations should not close the given OutputStream\r\n * (or any decorators of that OutputStream) but rather leave this up\r\n * to the caller.\r\n * @param object the object to serialize\r\n * @param outputStream the output stream\r\n * @throws IOException in case of errors writing to the stream\r\n */\r\nvoid serialize(T object, OutputStream outputStream) throws IOException;\n/**\r\n * Turn an object of type T into a serialized byte array.\r\n * @param object the object to serialize\r\n * @return the resulting byte array\r\n * @throws IOException in case of serialization failure\r\n * @since 5.2.7\r\n */\r\ndefault byte[] serializeToByteArray(T object) throws IOException {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\r\n    serialize(object, out);\r\n    return out.toByteArray();\r\n}",
    "comment": "\n * A strategy interface for streaming an object to an OutputStream.\n *\n * @author Gary Russell\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0.5\n * @param <T> the object type\n * @see Deserializer\n "
  },
  {
    "entityId": "org.springframework.core.serializer.Serializer#serialize(T,OutputStream)",
    "entityType": "method",
    "code": "/**\r\n * Write an object of type T to the given OutputStream.\r\n * <p>Note: Implementations should not close the given OutputStream\r\n * (or any decorators of that OutputStream) but rather leave this up\r\n * to the caller.\r\n * @param object the object to serialize\r\n * @param outputStream the output stream\r\n * @throws IOException in case of errors writing to the stream\r\n */\r\nvoid serialize(T object, OutputStream outputStream) throws IOException;",
    "comment": "\n\t * Write an object of type T to the given OutputStream.\n\t * <p>Note: Implementations should not close the given OutputStream\n\t * (or any decorators of that OutputStream) but rather leave this up\n\t * to the caller.\n\t * @param object the object to serialize\n\t * @param outputStream the output stream\n\t * @throws IOException in case of errors writing to the stream\n\t "
  },
  {
    "entityId": "org.springframework.core.serializer.Serializer#serializeToByteArray(T)",
    "entityType": "method",
    "code": "/**\r\n * Turn an object of type T into a serialized byte array.\r\n * @param object the object to serialize\r\n * @return the resulting byte array\r\n * @throws IOException in case of serialization failure\r\n * @since 5.2.7\r\n */\r\ndefault byte[] serializeToByteArray(T object) throws IOException {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\r\n    serialize(object, out);\r\n    return out.toByteArray();\r\n}",
    "comment": "\n\t * Turn an object of type T into a serialized byte array.\n\t * @param object the object to serialize\n\t * @return the resulting byte array\n\t * @throws IOException in case of serialization failure\n\t * @since 5.2.7\n\t "
  },
  {
    "entityId": "org.springframework.core.serializer.support.DeserializingConverter",
    "entityType": "class",
    "code": "private final Deserializer<Object> deserializer;\n/**\r\n * Create a {@code DeserializingConverter} with default {@link java.io.ObjectInputStream}\r\n * configuration, using the \"latest user-defined ClassLoader\".\r\n * @see DefaultDeserializer#DefaultDeserializer()\r\n */\r\npublic DeserializingConverter() {\r\n    this.deserializer = new DefaultDeserializer();\r\n}\n/**\r\n * Create a {@code DeserializingConverter} for using an {@link java.io.ObjectInputStream}\r\n * with the given {@code ClassLoader}.\r\n * @param classLoader the ClassLoader to use\r\n * @since 4.2.1\r\n * @see DefaultDeserializer#DefaultDeserializer(ClassLoader)\r\n */\r\npublic DeserializingConverter(@Nullable ClassLoader classLoader) {\r\n    this.deserializer = new DefaultDeserializer(classLoader);\r\n}\n/**\r\n * Create a {@code DeserializingConverter} that delegates to the provided {@link Deserializer}.\r\n */\r\npublic DeserializingConverter(Deserializer<Object> deserializer) {\r\n    Assert.notNull(deserializer, \"Deserializer must not be null\");\r\n    this.deserializer = deserializer;\r\n}\n@Override\r\npublic Object convert(byte[] source) {\r\n    ByteArrayInputStream byteStream = new ByteArrayInputStream(source);\r\n    try {\r\n        return this.deserializer.deserialize(byteStream);\r\n    } catch (Throwable ex) {\r\n        throw new SerializationFailedException(\"Failed to deserialize payload. \" + \"Is the byte array a result of corresponding serialization for \" + this.deserializer.getClass().getSimpleName() + \"?\", ex);\r\n    }\r\n}",
    "comment": "\n * A {@link Converter} that delegates to a\n * {@link org.springframework.core.serializer.Deserializer}\n * to convert data in a byte array to an object.\n *\n * @author Gary Russell\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 3.0.5\n "
  },
  {
    "entityId": "org.springframework.core.serializer.support.DeserializingConverter#convert(byte[])",
    "entityType": "method",
    "code": "@Override\r\npublic Object convert(byte[] source) {\r\n    ByteArrayInputStream byteStream = new ByteArrayInputStream(source);\r\n    try {\r\n        return this.deserializer.deserialize(byteStream);\r\n    } catch (Throwable ex) {\r\n        throw new SerializationFailedException(\"Failed to deserialize payload. \" + \"Is the byte array a result of corresponding serialization for \" + this.deserializer.getClass().getSimpleName() + \"?\", ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.serializer.support.SerializationDelegate",
    "entityType": "class",
    "code": "private final Serializer<Object> serializer;\nprivate final Deserializer<Object> deserializer;\n/**\r\n * Create a {@code SerializationDelegate} with a default serializer/deserializer\r\n * for the given {@code ClassLoader}.\r\n * @see DefaultDeserializer\r\n * @see DefaultDeserializer#DefaultDeserializer(ClassLoader)\r\n */\r\npublic SerializationDelegate(ClassLoader classLoader) {\r\n    this.serializer = new DefaultSerializer();\r\n    this.deserializer = new DefaultDeserializer(classLoader);\r\n}\n/**\r\n * Create a {@code SerializationDelegate} with the given serializer/deserializer.\r\n * @param serializer the {@link Serializer} to use (never {@code null)}\r\n * @param deserializer the {@link Deserializer} to use (never {@code null)}\r\n */\r\npublic SerializationDelegate(Serializer<Object> serializer, Deserializer<Object> deserializer) {\r\n    Assert.notNull(serializer, \"Serializer must not be null\");\r\n    Assert.notNull(deserializer, \"Deserializer must not be null\");\r\n    this.serializer = serializer;\r\n    this.deserializer = deserializer;\r\n}\n@Override\r\npublic void serialize(Object object, OutputStream outputStream) throws IOException {\r\n    this.serializer.serialize(object, outputStream);\r\n}\n@Override\r\npublic Object deserialize(InputStream inputStream) throws IOException {\r\n    return this.deserializer.deserialize(inputStream);\r\n}",
    "comment": "\n * A convenient delegate with pre-arranged configuration state for common\n * serialization needs. Implements {@link Serializer} and {@link Deserializer}\n * itself, so can also be passed into such more specific callback methods.\n *\n * @author Juergen Hoeller\n * @since 4.3\n "
  },
  {
    "entityId": "org.springframework.core.serializer.support.SerializationDelegate#serialize(Object,OutputStream)",
    "entityType": "method",
    "code": "@Override\r\npublic void serialize(Object object, OutputStream outputStream) throws IOException {\r\n    this.serializer.serialize(object, outputStream);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.serializer.support.SerializationDelegate#deserialize(InputStream)",
    "entityType": "method",
    "code": "@Override\r\npublic Object deserialize(InputStream inputStream) throws IOException {\r\n    return this.deserializer.deserialize(inputStream);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.serializer.support.SerializationFailedException",
    "entityType": "class",
    "code": "/**\r\n * Construct a {@code SerializationException} with the specified detail message.\r\n * @param message the detail message\r\n */\r\npublic SerializationFailedException(String message) {\r\n    super(message);\r\n}\n/**\r\n * Construct a {@code SerializationException} with the specified detail message\r\n * and nested exception.\r\n * @param message the detail message\r\n * @param cause the nested exception\r\n */\r\npublic SerializationFailedException(String message, Throwable cause) {\r\n    super(message, cause);\r\n}",
    "comment": "\n * Wrapper for the native IOException (or similar) when a\n * {@link org.springframework.core.serializer.Serializer} or\n * {@link org.springframework.core.serializer.Deserializer} failed.\n * Thrown by {@link SerializingConverter} and {@link DeserializingConverter}.\n *\n * @author Gary Russell\n * @author Juergen Hoeller\n * @since 3.0.5\n "
  },
  {
    "entityId": "org.springframework.core.serializer.support.SerializingConverter",
    "entityType": "class",
    "code": "private final Serializer<Object> serializer;\n/**\r\n * Create a default {@code SerializingConverter} that uses standard Java serialization.\r\n */\r\npublic SerializingConverter() {\r\n    this.serializer = new DefaultSerializer();\r\n}\n/**\r\n * Create a {@code SerializingConverter} that delegates to the provided {@link Serializer}.\r\n */\r\npublic SerializingConverter(Serializer<Object> serializer) {\r\n    Assert.notNull(serializer, \"Serializer must not be null\");\r\n    this.serializer = serializer;\r\n}\n/**\r\n * Serializes the source object and returns the byte array result.\r\n */\r\n@Override\r\npublic byte[] convert(Object source) {\r\n    try {\r\n        return this.serializer.serializeToByteArray(source);\r\n    } catch (Throwable ex) {\r\n        throw new SerializationFailedException(\"Failed to serialize object using \" + this.serializer.getClass().getSimpleName(), ex);\r\n    }\r\n}",
    "comment": "\n * A {@link Converter} that delegates to a\n * {@link org.springframework.core.serializer.Serializer}\n * to convert an object to a byte array.\n *\n * @author Gary Russell\n * @author Mark Fisher\n * @since 3.0.5\n "
  },
  {
    "entityId": "org.springframework.core.serializer.support.SerializingConverter#convert(Object)",
    "entityType": "method",
    "code": "/**\r\n * Serializes the source object and returns the byte array result.\r\n */\r\n@Override\r\npublic byte[] convert(Object source) {\r\n    try {\r\n        return this.serializer.serializeToByteArray(source);\r\n    } catch (Throwable ex) {\r\n        throw new SerializationFailedException(\"Failed to serialize object using \" + this.serializer.getClass().getSimpleName(), ex);\r\n    }\r\n}",
    "comment": "\n\t * Serializes the source object and returns the byte array result.\n\t "
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry",
    "entityType": "class",
    "code": "/**\r\n * Logger available to subclasses.\r\n */\r\nprotected final Log logger = LogFactory.getLog(getClass());\n/**\r\n * Map from alias to canonical name.\r\n */\r\nprivate final Map<String, String> aliasMap = new ConcurrentHashMap<>(16);\n/**\r\n * List of alias names, in registration order.\r\n */\r\nprivate final List<String> aliasNames = new ArrayList<>(16);\n@Override\r\npublic void registerAlias(String name, String alias) {\r\n    Assert.hasText(name, \"'name' must not be empty\");\r\n    Assert.hasText(alias, \"'alias' must not be empty\");\r\n    synchronized (this.aliasMap) {\r\n        if (alias.equals(name)) {\r\n            this.aliasMap.remove(alias);\r\n            this.aliasNames.remove(alias);\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Alias definition '\" + alias + \"' ignored since it points to same name\");\r\n            }\r\n        } else {\r\n            String registeredName = this.aliasMap.get(alias);\r\n            if (registeredName != null) {\r\n                if (registeredName.equals(name)) {\r\n                    // An existing alias - no need to re-register\r\n                    return;\r\n                }\r\n                if (!allowAliasOverriding()) {\r\n                    throw new IllegalStateException(\"Cannot define alias '\" + alias + \"' for name '\" + name + \"': It is already registered for name '\" + registeredName + \"'.\");\r\n                }\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Overriding alias '\" + alias + \"' definition for registered name '\" + registeredName + \"' with new target name '\" + name + \"'\");\r\n                }\r\n            }\r\n            checkForAliasCircle(name, alias);\r\n            this.aliasMap.put(alias, name);\r\n            this.aliasNames.add(alias);\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Alias definition '\" + alias + \"' registered for name '\" + name + \"'\");\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Determine whether alias overriding is allowed.\r\n * <p>Default is {@code true}.\r\n */\r\nprotected boolean allowAliasOverriding() {\r\n    return true;\r\n}\n/**\r\n * Determine whether the given name has the given alias registered.\r\n * @param name the name to check\r\n * @param alias the alias to look for\r\n * @since 4.2.1\r\n */\r\npublic boolean hasAlias(String name, String alias) {\r\n    String registeredName = this.aliasMap.get(alias);\r\n    return ObjectUtils.nullSafeEquals(registeredName, name) || (registeredName != null && hasAlias(name, registeredName));\r\n}\n@Override\r\npublic void removeAlias(String alias) {\r\n    synchronized (this.aliasMap) {\r\n        String name = this.aliasMap.remove(alias);\r\n        this.aliasNames.remove(alias);\r\n        if (name == null) {\r\n            throw new IllegalStateException(\"No alias '\" + alias + \"' registered\");\r\n        }\r\n    }\r\n}\n@Override\r\npublic boolean isAlias(String name) {\r\n    return this.aliasMap.containsKey(name);\r\n}\n@Override\r\npublic String[] getAliases(String name) {\r\n    List<String> result = new ArrayList<>();\r\n    synchronized (this.aliasMap) {\r\n        retrieveAliases(name, result);\r\n    }\r\n    return StringUtils.toStringArray(result);\r\n}\n/**\r\n * Transitively retrieve all aliases for the given name.\r\n * @param name the target name to find aliases for\r\n * @param result the resulting aliases list\r\n */\r\nprivate void retrieveAliases(String name, List<String> result) {\r\n    this.aliasMap.forEach((alias, registeredName) -> {\r\n        if (registeredName.equals(name)) {\r\n            result.add(alias);\r\n            retrieveAliases(alias, result);\r\n        }\r\n    });\r\n}\n/**\r\n * Resolve all alias target names and aliases registered in this\r\n * registry, applying the given {@link StringValueResolver} to them.\r\n * <p>The value resolver may for example resolve placeholders\r\n * in target bean names and even in alias names.\r\n * @param valueResolver the StringValueResolver to apply\r\n */\r\npublic void resolveAliases(StringValueResolver valueResolver) {\r\n    Assert.notNull(valueResolver, \"StringValueResolver must not be null\");\r\n    synchronized (this.aliasMap) {\r\n        List<String> aliasNamesCopy = new ArrayList<>(this.aliasNames);\r\n        aliasNamesCopy.forEach(alias -> {\r\n            String registeredName = this.aliasMap.get(alias);\r\n            if (registeredName != null) {\r\n                String resolvedAlias = valueResolver.resolveStringValue(alias);\r\n                String resolvedName = valueResolver.resolveStringValue(registeredName);\r\n                if (resolvedAlias == null || resolvedName == null || resolvedAlias.equals(resolvedName)) {\r\n                    this.aliasMap.remove(alias);\r\n                    this.aliasNames.remove(alias);\r\n                } else if (!resolvedAlias.equals(alias)) {\r\n                    String existingName = this.aliasMap.get(resolvedAlias);\r\n                    if (existingName != null) {\r\n                        if (existingName.equals(resolvedName)) {\r\n                            // Pointing to existing alias - just remove placeholder\r\n                            this.aliasMap.remove(alias);\r\n                            this.aliasNames.remove(alias);\r\n                            return;\r\n                        }\r\n                        throw new IllegalStateException(\"Cannot register resolved alias '\" + resolvedAlias + \"' (original: '\" + alias + \"') for name '\" + resolvedName + \"': It is already registered for name '\" + existingName + \"'.\");\r\n                    }\r\n                    checkForAliasCircle(resolvedName, resolvedAlias);\r\n                    this.aliasMap.remove(alias);\r\n                    this.aliasNames.remove(alias);\r\n                    this.aliasMap.put(resolvedAlias, resolvedName);\r\n                    this.aliasNames.add(resolvedAlias);\r\n                } else if (!registeredName.equals(resolvedName)) {\r\n                    this.aliasMap.put(alias, resolvedName);\r\n                    this.aliasNames.add(alias);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\n/**\r\n * Check whether the given name points back to the given alias as an alias\r\n * in the other direction already, catching a circular reference upfront\r\n * and throwing a corresponding IllegalStateException.\r\n * @param name the candidate name\r\n * @param alias the candidate alias\r\n * @see #registerAlias\r\n * @see #hasAlias\r\n */\r\nprotected void checkForAliasCircle(String name, String alias) {\r\n    if (hasAlias(alias, name)) {\r\n        throw new IllegalStateException(\"Cannot register alias '\" + alias + \"' for name '\" + name + \"': Circular reference - '\" + name + \"' is a direct or indirect alias for '\" + alias + \"' already\");\r\n    }\r\n}\n/**\r\n * Determine the raw name, resolving aliases to canonical names.\r\n * @param name the user-specified name\r\n * @return the transformed name\r\n */\r\npublic String canonicalName(String name) {\r\n    String canonicalName = name;\r\n    // Handle aliasing...\r\n    String resolvedName;\r\n    do {\r\n        resolvedName = this.aliasMap.get(canonicalName);\r\n        if (resolvedName != null) {\r\n            canonicalName = resolvedName;\r\n        }\r\n    } while (resolvedName != null);\r\n    return canonicalName;\r\n}",
    "comment": "\n * Simple implementation of the {@link AliasRegistry} interface.\n *\n * <p>Serves as base class for\n * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}\n * implementations.\n *\n * @author Juergen Hoeller\n * @author Qimiao Chen\n * @author Sam Brannen\n * @since 2.5.2\n "
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#registerAlias(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerAlias(String name, String alias) {\r\n    Assert.hasText(name, \"'name' must not be empty\");\r\n    Assert.hasText(alias, \"'alias' must not be empty\");\r\n    synchronized (this.aliasMap) {\r\n        if (alias.equals(name)) {\r\n            this.aliasMap.remove(alias);\r\n            this.aliasNames.remove(alias);\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Alias definition '\" + alias + \"' ignored since it points to same name\");\r\n            }\r\n        } else {\r\n            String registeredName = this.aliasMap.get(alias);\r\n            if (registeredName != null) {\r\n                if (registeredName.equals(name)) {\r\n                    // An existing alias - no need to re-register\r\n                    return;\r\n                }\r\n                if (!allowAliasOverriding()) {\r\n                    throw new IllegalStateException(\"Cannot define alias '\" + alias + \"' for name '\" + name + \"': It is already registered for name '\" + registeredName + \"'.\");\r\n                }\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Overriding alias '\" + alias + \"' definition for registered name '\" + registeredName + \"' with new target name '\" + name + \"'\");\r\n                }\r\n            }\r\n            checkForAliasCircle(name, alias);\r\n            this.aliasMap.put(alias, name);\r\n            this.aliasNames.add(alias);\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Alias definition '\" + alias + \"' registered for name '\" + name + \"'\");\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#allowAliasOverriding()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether alias overriding is allowed.\r\n * <p>Default is {@code true}.\r\n */\r\nprotected boolean allowAliasOverriding() {\r\n    return true;\r\n}",
    "comment": "\n\t * Determine whether alias overriding is allowed.\n\t * <p>Default is {@code true}.\n\t "
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#hasAlias(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given name has the given alias registered.\r\n * @param name the name to check\r\n * @param alias the alias to look for\r\n * @since 4.2.1\r\n */\r\npublic boolean hasAlias(String name, String alias) {\r\n    String registeredName = this.aliasMap.get(alias);\r\n    return ObjectUtils.nullSafeEquals(registeredName, name) || (registeredName != null && hasAlias(name, registeredName));\r\n}",
    "comment": "\n\t * Determine whether the given name has the given alias registered.\n\t * @param name the name to check\n\t * @param alias the alias to look for\n\t * @since 4.2.1\n\t "
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#removeAlias(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void removeAlias(String alias) {\r\n    synchronized (this.aliasMap) {\r\n        String name = this.aliasMap.remove(alias);\r\n        this.aliasNames.remove(alias);\r\n        if (name == null) {\r\n            throw new IllegalStateException(\"No alias '\" + alias + \"' registered\");\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#isAlias(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAlias(String name) {\r\n    return this.aliasMap.containsKey(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#getAliases(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getAliases(String name) {\r\n    List<String> result = new ArrayList<>();\r\n    synchronized (this.aliasMap) {\r\n        retrieveAliases(name, result);\r\n    }\r\n    return StringUtils.toStringArray(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#retrieveAliases(String,List<String>)",
    "entityType": "method",
    "code": "/**\r\n * Transitively retrieve all aliases for the given name.\r\n * @param name the target name to find aliases for\r\n * @param result the resulting aliases list\r\n */\r\nprivate void retrieveAliases(String name, List<String> result) {\r\n    this.aliasMap.forEach((alias, registeredName) -> {\r\n        if (registeredName.equals(name)) {\r\n            result.add(alias);\r\n            retrieveAliases(alias, result);\r\n        }\r\n    });\r\n}",
    "comment": "\n\t * Transitively retrieve all aliases for the given name.\n\t * @param name the target name to find aliases for\n\t * @param result the resulting aliases list\n\t "
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#resolveAliases(StringValueResolver)",
    "entityType": "method",
    "code": "/**\r\n * Resolve all alias target names and aliases registered in this\r\n * registry, applying the given {@link StringValueResolver} to them.\r\n * <p>The value resolver may for example resolve placeholders\r\n * in target bean names and even in alias names.\r\n * @param valueResolver the StringValueResolver to apply\r\n */\r\npublic void resolveAliases(StringValueResolver valueResolver) {\r\n    Assert.notNull(valueResolver, \"StringValueResolver must not be null\");\r\n    synchronized (this.aliasMap) {\r\n        List<String> aliasNamesCopy = new ArrayList<>(this.aliasNames);\r\n        aliasNamesCopy.forEach(alias -> {\r\n            String registeredName = this.aliasMap.get(alias);\r\n            if (registeredName != null) {\r\n                String resolvedAlias = valueResolver.resolveStringValue(alias);\r\n                String resolvedName = valueResolver.resolveStringValue(registeredName);\r\n                if (resolvedAlias == null || resolvedName == null || resolvedAlias.equals(resolvedName)) {\r\n                    this.aliasMap.remove(alias);\r\n                    this.aliasNames.remove(alias);\r\n                } else if (!resolvedAlias.equals(alias)) {\r\n                    String existingName = this.aliasMap.get(resolvedAlias);\r\n                    if (existingName != null) {\r\n                        if (existingName.equals(resolvedName)) {\r\n                            // Pointing to existing alias - just remove placeholder\r\n                            this.aliasMap.remove(alias);\r\n                            this.aliasNames.remove(alias);\r\n                            return;\r\n                        }\r\n                        throw new IllegalStateException(\"Cannot register resolved alias '\" + resolvedAlias + \"' (original: '\" + alias + \"') for name '\" + resolvedName + \"': It is already registered for name '\" + existingName + \"'.\");\r\n                    }\r\n                    checkForAliasCircle(resolvedName, resolvedAlias);\r\n                    this.aliasMap.remove(alias);\r\n                    this.aliasNames.remove(alias);\r\n                    this.aliasMap.put(resolvedAlias, resolvedName);\r\n                    this.aliasNames.add(resolvedAlias);\r\n                } else if (!registeredName.equals(resolvedName)) {\r\n                    this.aliasMap.put(alias, resolvedName);\r\n                    this.aliasNames.add(alias);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}",
    "comment": "\n\t * Resolve all alias target names and aliases registered in this\n\t * registry, applying the given {@link StringValueResolver} to them.\n\t * <p>The value resolver may for example resolve placeholders\n\t * in target bean names and even in alias names.\n\t * @param valueResolver the StringValueResolver to apply\n\t "
  },
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#checkForAliasCircle(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given name points back to the given alias as an alias\r\n * in the other direction already, catching a circular reference upfront\r\n * and throwing a corresponding IllegalStateException.\r\n * @param name the candidate name\r\n * @param alias the candidate alias\r\n * @see #registerAlias\r\n * @see #hasAlias\r\n */\r\nprotected void checkForAliasCircle(String name, String alias) {\r\n    if (hasAlias(alias, name)) {\r\n        throw new IllegalStateException(\"Cannot register alias '\" + alias + \"' for name '\" + name + \"': Circular reference - '\" + name + \"' is a direct or indirect alias for '\" + alias + \"' already\");\r\n    }\r\n}",
    "comment": "\n\t * Check whether the given name points back to the given alias as an alias\n\t * in the other direction already, catching a circular reference upfront\n\t * and throwing a corresponding IllegalStateException.\n\t * @param name the candidate name\n\t * @param alias the candidate alias\n\t * @see #registerAlias\n\t * @see #hasAlias\n\t "
  }
]