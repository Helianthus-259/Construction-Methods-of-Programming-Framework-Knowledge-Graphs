[
  {
    "entityId": "org.springframework.asm.Frame#getAbstractTypeFromApiFormat(SymbolTable,Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Static methods to get abstract types from other type formats\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the abstract type corresponding to the given public API frame element type.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param type a frame element type described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\r\n *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\r\n *     a NEW instruction (for uninitialized types).\r\n * @return the abstract type corresponding to the given frame element type.\r\n */\r\nstatic int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {\r\n    if (type instanceof Integer) {\r\n        return CONSTANT_KIND | ((Integer) type).intValue();\r\n    } else if (type instanceof String) {\r\n        String descriptor = Type.getObjectType((String) type).getDescriptor();\r\n        return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\r\n    } else {\r\n        Label label = (Label) type;\r\n        if ((label.flags & Label.FLAG_RESOLVED) != 0) {\r\n            return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", label.bytecodeOffset);\r\n        } else {\r\n            return FORWARD_UNINITIALIZED_KIND | symbolTable.addForwardUninitializedType(\"\", label);\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Returns the abstract type corresponding to the given public API frame element type.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param type a frame element type described using the same format as in {@link\n   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\n   *     a NEW instruction (for uninitialized types).\n   * @return the abstract type corresponding to the given frame element type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#getAbstractTypeFromInternalName(SymbolTable,String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the abstract type corresponding to the internal name of a class.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param internalName the internal name of a class. This must <i>not</i> be an array type\r\n *     descriptor.\r\n * @return the abstract type value corresponding to the given internal name.\r\n */\r\nstatic int getAbstractTypeFromInternalName(final SymbolTable symbolTable, final String internalName) {\r\n    return REFERENCE_KIND | symbolTable.addType(internalName);\r\n}",
    "comment": "\n   * Returns the abstract type corresponding to the internal name of a class.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param internalName the internal name of a class. This must <i>not</i> be an array type\n   *     descriptor.\n   * @return the abstract type value corresponding to the given internal name.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#getAbstractTypeFromDescriptor(SymbolTable,String,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the abstract type corresponding to the given type descriptor.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param buffer a string ending with a type descriptor.\r\n * @param offset the start offset of the type descriptor in buffer.\r\n * @return the abstract type corresponding to the given type descriptor.\r\n */\r\nprivate static int getAbstractTypeFromDescriptor(final SymbolTable symbolTable, final String buffer, final int offset) {\r\n    String internalName;\r\n    switch(buffer.charAt(offset)) {\r\n        case 'V':\r\n            return 0;\r\n        case 'Z':\r\n        case 'C':\r\n        case 'B':\r\n        case 'S':\r\n        case 'I':\r\n            return INTEGER;\r\n        case 'F':\r\n            return FLOAT;\r\n        case 'J':\r\n            return LONG;\r\n        case 'D':\r\n            return DOUBLE;\r\n        case 'L':\r\n            internalName = buffer.substring(offset + 1, buffer.length() - 1);\r\n            return REFERENCE_KIND | symbolTable.addType(internalName);\r\n        case '[':\r\n            int elementDescriptorOffset = offset + 1;\r\n            while (buffer.charAt(elementDescriptorOffset) == '[') {\r\n                ++elementDescriptorOffset;\r\n            }\r\n            int typeValue;\r\n            switch(buffer.charAt(elementDescriptorOffset)) {\r\n                case 'Z':\r\n                    typeValue = BOOLEAN;\r\n                    break;\r\n                case 'C':\r\n                    typeValue = CHAR;\r\n                    break;\r\n                case 'B':\r\n                    typeValue = BYTE;\r\n                    break;\r\n                case 'S':\r\n                    typeValue = SHORT;\r\n                    break;\r\n                case 'I':\r\n                    typeValue = INTEGER;\r\n                    break;\r\n                case 'F':\r\n                    typeValue = FLOAT;\r\n                    break;\r\n                case 'J':\r\n                    typeValue = LONG;\r\n                    break;\r\n                case 'D':\r\n                    typeValue = DOUBLE;\r\n                    break;\r\n                case 'L':\r\n                    internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\r\n                    typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Invalid descriptor fragment: \" + buffer.substring(elementDescriptorOffset));\r\n            }\r\n            return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + buffer.substring(offset));\r\n    }\r\n}",
    "comment": "\n   * Returns the abstract type corresponding to the given type descriptor.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param buffer a string ending with a type descriptor.\n   * @param offset the start offset of the type descriptor in buffer.\n   * @return the abstract type corresponding to the given type descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#setInputFrameFromDescriptor(SymbolTable,int,String,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods related to the input frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Sets the input frame from the given method description. This method is used to initialize the\r\n * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\r\n * attribute).\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param access the method's access flags.\r\n * @param descriptor the method descriptor.\r\n * @param maxLocals the maximum number of local variables of the method.\r\n */\r\nfinal void setInputFrameFromDescriptor(final SymbolTable symbolTable, final int access, final String descriptor, final int maxLocals) {\r\n    inputLocals = new int[maxLocals];\r\n    inputStack = new int[0];\r\n    int inputLocalIndex = 0;\r\n    if ((access & Opcodes.ACC_STATIC) == 0) {\r\n        if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\r\n            inputLocals[inputLocalIndex++] = REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\r\n        } else {\r\n            inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\r\n        }\r\n    }\r\n    for (Type argumentType : Type.getArgumentTypes(descriptor)) {\r\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\r\n        inputLocals[inputLocalIndex++] = abstractType;\r\n        if (abstractType == LONG || abstractType == DOUBLE) {\r\n            inputLocals[inputLocalIndex++] = TOP;\r\n        }\r\n    }\r\n    while (inputLocalIndex < maxLocals) {\r\n        inputLocals[inputLocalIndex++] = TOP;\r\n    }\r\n}",
    "comment": "\n   * Sets the input frame from the given method description. This method is used to initialize the\n   * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\n   * attribute).\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param access the method's access flags.\n   * @param descriptor the method descriptor.\n   * @param maxLocals the maximum number of local variables of the method.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#setInputFrameFromApiFormat(SymbolTable,int,Object[],int,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Sets the input frame from the given public API frame description.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param numLocal the number of local variables.\r\n * @param local the local variable types, described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}.\r\n * @param numStack the number of operand stack elements.\r\n * @param stack the operand stack types, described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}.\r\n */\r\nfinal void setInputFrameFromApiFormat(final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n    int inputLocalIndex = 0;\r\n    for (int i = 0; i < numLocal; ++i) {\r\n        inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);\r\n        if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {\r\n            inputLocals[inputLocalIndex++] = TOP;\r\n        }\r\n    }\r\n    while (inputLocalIndex < inputLocals.length) {\r\n        inputLocals[inputLocalIndex++] = TOP;\r\n    }\r\n    int numStackTop = 0;\r\n    for (int i = 0; i < numStack; ++i) {\r\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n            ++numStackTop;\r\n        }\r\n    }\r\n    inputStack = new int[numStack + numStackTop];\r\n    int inputStackIndex = 0;\r\n    for (int i = 0; i < numStack; ++i) {\r\n        inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);\r\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n            inputStack[inputStackIndex++] = TOP;\r\n        }\r\n    }\r\n    outputStackTop = 0;\r\n    initializationCount = 0;\r\n}",
    "comment": "\n   * Sets the input frame from the given public API frame description.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param numLocal the number of local variables.\n   * @param local the local variable types, described using the same format as in {@link\n   *     MethodVisitor#visitFrame}.\n   * @param numStack the number of operand stack elements.\n   * @param stack the operand stack types, described using the same format as in {@link\n   *     MethodVisitor#visitFrame}.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#getInputStackSize()",
    "entityType": "method",
    "code": "final int getInputStackSize() {\r\n    return inputStack.length;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Frame#getLocal(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods related to the output frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the abstract type stored at the given local variable index in the output frame.\r\n *\r\n * @param localIndex the index of the local variable whose value must be returned.\r\n * @return the abstract type stored at the given local variable index in the output frame.\r\n */\r\nprivate int getLocal(final int localIndex) {\r\n    if (outputLocals == null || localIndex >= outputLocals.length) {\r\n        // If this local has never been assigned in this basic block, it is still equal to its value\r\n        // in the input frame.\r\n        return LOCAL_KIND | localIndex;\r\n    } else {\r\n        int abstractType = outputLocals[localIndex];\r\n        if (abstractType == 0) {\r\n            // If this local has never been assigned in this basic block, so it is still equal to its\r\n            // value in the input frame.\r\n            abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\r\n        }\r\n        return abstractType;\r\n    }\r\n}",
    "comment": "\n   * Returns the abstract type stored at the given local variable index in the output frame.\n   *\n   * @param localIndex the index of the local variable whose value must be returned.\n   * @return the abstract type stored at the given local variable index in the output frame.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#setLocal(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Replaces the abstract type stored at the given local variable index in the output frame.\r\n *\r\n * @param localIndex the index of the output frame local variable that must be set.\r\n * @param abstractType the value that must be set.\r\n */\r\nprivate void setLocal(final int localIndex, final int abstractType) {\r\n    // Create and/or resize the output local variables array if necessary.\r\n    if (outputLocals == null) {\r\n        outputLocals = new int[10];\r\n    }\r\n    int outputLocalsLength = outputLocals.length;\r\n    if (localIndex >= outputLocalsLength) {\r\n        int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\r\n        System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\r\n        outputLocals = newOutputLocals;\r\n    }\r\n    // Set the local variable.\r\n    outputLocals[localIndex] = abstractType;\r\n}",
    "comment": "\n   * Replaces the abstract type stored at the given local variable index in the output frame.\n   *\n   * @param localIndex the index of the output frame local variable that must be set.\n   * @param abstractType the value that must be set.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#push(int)",
    "entityType": "method",
    "code": "/**\r\n * Pushes the given abstract type on the output frame stack.\r\n *\r\n * @param abstractType an abstract type.\r\n */\r\nprivate void push(final int abstractType) {\r\n    // Create and/or resize the output stack array if necessary.\r\n    if (outputStack == null) {\r\n        outputStack = new int[10];\r\n    }\r\n    int outputStackLength = outputStack.length;\r\n    if (outputStackTop >= outputStackLength) {\r\n        int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\r\n        System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\r\n        outputStack = newOutputStack;\r\n    }\r\n    // Pushes the abstract type on the output stack.\r\n    outputStack[outputStackTop++] = abstractType;\r\n    // Updates the maximum size reached by the output stack, if needed (note that this size is\r\n    // relative to the input stack size, which is not known yet).\r\n    short outputStackSize = (short) (outputStackStart + outputStackTop);\r\n    if (outputStackSize > owner.outputStackMax) {\r\n        owner.outputStackMax = outputStackSize;\r\n    }\r\n}",
    "comment": "\n   * Pushes the given abstract type on the output frame stack.\n   *\n   * @param abstractType an abstract type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#push(SymbolTable,String)",
    "entityType": "method",
    "code": "/**\r\n * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param descriptor a type or method descriptor (in which case its return type is pushed).\r\n */\r\nprivate void push(final SymbolTable symbolTable, final String descriptor) {\r\n    int typeDescriptorOffset = descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;\r\n    int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\r\n    if (abstractType != 0) {\r\n        push(abstractType);\r\n        if (abstractType == LONG || abstractType == DOUBLE) {\r\n            push(TOP);\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param descriptor a type or method descriptor (in which case its return type is pushed).\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#pop()",
    "entityType": "method",
    "code": "/**\r\n * Pops an abstract type from the output frame stack and returns its value.\r\n *\r\n * @return the abstract type that has been popped from the output frame stack.\r\n */\r\nprivate int pop() {\r\n    if (outputStackTop > 0) {\r\n        return outputStack[--outputStackTop];\r\n    } else {\r\n        // If the output frame stack is empty, pop from the input stack.\r\n        return STACK_KIND | -(--outputStackStart);\r\n    }\r\n}",
    "comment": "\n   * Pops an abstract type from the output frame stack and returns its value.\n   *\n   * @return the abstract type that has been popped from the output frame stack.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#pop(int)",
    "entityType": "method",
    "code": "/**\r\n * Pops the given number of abstract types from the output frame stack.\r\n *\r\n * @param elements the number of abstract types that must be popped.\r\n */\r\nprivate void pop(final int elements) {\r\n    if (outputStackTop >= elements) {\r\n        outputStackTop -= elements;\r\n    } else {\r\n        // If the number of elements to be popped is greater than the number of elements in the output\r\n        // stack, clear it, and pop the remaining elements from the input stack.\r\n        outputStackStart -= elements - outputStackTop;\r\n        outputStackTop = 0;\r\n    }\r\n}",
    "comment": "\n   * Pops the given number of abstract types from the output frame stack.\n   *\n   * @param elements the number of abstract types that must be popped.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#pop(String)",
    "entityType": "method",
    "code": "/**\r\n * Pops as many abstract types from the output frame stack as described by the given descriptor.\r\n *\r\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\r\n */\r\nprivate void pop(final String descriptor) {\r\n    char firstDescriptorChar = descriptor.charAt(0);\r\n    if (firstDescriptorChar == '(') {\r\n        pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\r\n    } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\r\n        pop(2);\r\n    } else {\r\n        pop(1);\r\n    }\r\n}",
    "comment": "\n   * Pops as many abstract types from the output frame stack as described by the given descriptor.\n   *\n   * @param descriptor a type or method descriptor (in which case its argument types are popped).\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#addInitializedType(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods to handle uninitialized types\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds an abstract type to the list of types on which a constructor is invoked in the basic\r\n * block.\r\n *\r\n * @param abstractType an abstract type on a which a constructor is invoked.\r\n */\r\nprivate void addInitializedType(final int abstractType) {\r\n    // Create and/or resize the initializations array if necessary.\r\n    if (initializations == null) {\r\n        initializations = new int[2];\r\n    }\r\n    int initializationsLength = initializations.length;\r\n    if (initializationCount >= initializationsLength) {\r\n        int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\r\n        System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\r\n        initializations = newInitializations;\r\n    }\r\n    // Store the abstract type.\r\n    initializations[initializationCount++] = abstractType;\r\n}",
    "comment": "\n   * Adds an abstract type to the list of types on which a constructor is invoked in the basic\n   * block.\n   *\n   * @param abstractType an abstract type on a which a constructor is invoked.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#getInitializedType(SymbolTable,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the \"initialized\" abstract type corresponding to the given abstract type.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param abstractType an abstract type.\r\n * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\r\n *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\r\n *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\r\n *     abstractType.\r\n */\r\nprivate int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\r\n    if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {\r\n        for (int i = 0; i < initializationCount; ++i) {\r\n            int initializedType = initializations[i];\r\n            int dim = initializedType & DIM_MASK;\r\n            int kind = initializedType & KIND_MASK;\r\n            int value = initializedType & VALUE_MASK;\r\n            if (kind == LOCAL_KIND) {\r\n                initializedType = dim + inputLocals[value];\r\n            } else if (kind == STACK_KIND) {\r\n                initializedType = dim + inputStack[inputStack.length - value];\r\n            }\r\n            if (abstractType == initializedType) {\r\n                if (abstractType == UNINITIALIZED_THIS) {\r\n                    return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\r\n                } else {\r\n                    return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return abstractType;\r\n}",
    "comment": "\n   * Returns the \"initialized\" abstract type corresponding to the given abstract type.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param abstractType an abstract type.\n   * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\n   *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\n   *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\n   *     abstractType.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#execute(int,int,Symbol,SymbolTable)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Main method, to simulate the execution of each instruction on the output frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Simulates the action of the given instruction on the output stack frame.\r\n *\r\n * @param opcode the opcode of the instruction.\r\n * @param arg the numeric operand of the instruction, if any.\r\n * @param argSymbol the Symbol operand of the instruction, if any.\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n */\r\nvoid execute(final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\r\n    // Abstract types popped from the stack or read from local variables.\r\n    int abstractType1;\r\n    int abstractType2;\r\n    int abstractType3;\r\n    int abstractType4;\r\n    switch(opcode) {\r\n        case Opcodes.NOP:\r\n        case Opcodes.INEG:\r\n        case Opcodes.LNEG:\r\n        case Opcodes.FNEG:\r\n        case Opcodes.DNEG:\r\n        case Opcodes.I2B:\r\n        case Opcodes.I2C:\r\n        case Opcodes.I2S:\r\n        case Opcodes.GOTO:\r\n        case Opcodes.RETURN:\r\n            break;\r\n        case Opcodes.ACONST_NULL:\r\n            push(NULL);\r\n            break;\r\n        case Opcodes.ICONST_M1:\r\n        case Opcodes.ICONST_0:\r\n        case Opcodes.ICONST_1:\r\n        case Opcodes.ICONST_2:\r\n        case Opcodes.ICONST_3:\r\n        case Opcodes.ICONST_4:\r\n        case Opcodes.ICONST_5:\r\n        case Opcodes.BIPUSH:\r\n        case Opcodes.SIPUSH:\r\n        case Opcodes.ILOAD:\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCONST_0:\r\n        case Opcodes.LCONST_1:\r\n        case Opcodes.LLOAD:\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FCONST_0:\r\n        case Opcodes.FCONST_1:\r\n        case Opcodes.FCONST_2:\r\n        case Opcodes.FLOAD:\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DCONST_0:\r\n        case Opcodes.DCONST_1:\r\n        case Opcodes.DLOAD:\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LDC:\r\n            switch(argSymbol.tag) {\r\n                case Symbol.CONSTANT_INTEGER_TAG:\r\n                    push(INTEGER);\r\n                    break;\r\n                case Symbol.CONSTANT_LONG_TAG:\r\n                    push(LONG);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_FLOAT_TAG:\r\n                    push(FLOAT);\r\n                    break;\r\n                case Symbol.CONSTANT_DOUBLE_TAG:\r\n                    push(DOUBLE);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_CLASS_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\r\n                    break;\r\n                case Symbol.CONSTANT_STRING_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\r\n                    break;\r\n                case Symbol.CONSTANT_DYNAMIC_TAG:\r\n                    push(symbolTable, argSymbol.value);\r\n                    break;\r\n                default:\r\n                    throw new AssertionError();\r\n            }\r\n            break;\r\n        case Opcodes.ALOAD:\r\n            push(getLocal(arg));\r\n            break;\r\n        case Opcodes.LALOAD:\r\n        case Opcodes.D2L:\r\n            pop(2);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.DALOAD:\r\n        case Opcodes.L2D:\r\n            pop(2);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.AALOAD:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\r\n            break;\r\n        case Opcodes.ISTORE:\r\n        case Opcodes.FSTORE:\r\n        case Opcodes.ASTORE:\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    // The type of the previous local variable is not known yet, but if it later appears\r\n                    // to be LONG or DOUBLE, we should then use TOP instead.\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.LSTORE:\r\n        case Opcodes.DSTORE:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            setLocal(arg + 1, TOP);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    // The type of the previous local variable is not known yet, but if it later appears\r\n                    // to be LONG or DOUBLE, we should then use TOP instead.\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.IASTORE:\r\n        case Opcodes.BASTORE:\r\n        case Opcodes.CASTORE:\r\n        case Opcodes.SASTORE:\r\n        case Opcodes.FASTORE:\r\n        case Opcodes.AASTORE:\r\n            pop(3);\r\n            break;\r\n        case Opcodes.LASTORE:\r\n        case Opcodes.DASTORE:\r\n            pop(4);\r\n            break;\r\n        case Opcodes.POP:\r\n        case Opcodes.IFEQ:\r\n        case Opcodes.IFNE:\r\n        case Opcodes.IFLT:\r\n        case Opcodes.IFGE:\r\n        case Opcodes.IFGT:\r\n        case Opcodes.IFLE:\r\n        case Opcodes.IRETURN:\r\n        case Opcodes.FRETURN:\r\n        case Opcodes.ARETURN:\r\n        case Opcodes.TABLESWITCH:\r\n        case Opcodes.LOOKUPSWITCH:\r\n        case Opcodes.ATHROW:\r\n        case Opcodes.MONITORENTER:\r\n        case Opcodes.MONITOREXIT:\r\n        case Opcodes.IFNULL:\r\n        case Opcodes.IFNONNULL:\r\n            pop(1);\r\n            break;\r\n        case Opcodes.POP2:\r\n        case Opcodes.IF_ICMPEQ:\r\n        case Opcodes.IF_ICMPNE:\r\n        case Opcodes.IF_ICMPLT:\r\n        case Opcodes.IF_ICMPGE:\r\n        case Opcodes.IF_ICMPGT:\r\n        case Opcodes.IF_ICMPLE:\r\n        case Opcodes.IF_ACMPEQ:\r\n        case Opcodes.IF_ACMPNE:\r\n        case Opcodes.LRETURN:\r\n        case Opcodes.DRETURN:\r\n            pop(2);\r\n            break;\r\n        case Opcodes.DUP:\r\n            abstractType1 = pop();\r\n            push(abstractType1);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            abstractType4 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType4);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.SWAP:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            break;\r\n        case Opcodes.IALOAD:\r\n        case Opcodes.BALOAD:\r\n        case Opcodes.CALOAD:\r\n        case Opcodes.SALOAD:\r\n        case Opcodes.IADD:\r\n        case Opcodes.ISUB:\r\n        case Opcodes.IMUL:\r\n        case Opcodes.IDIV:\r\n        case Opcodes.IREM:\r\n        case Opcodes.IAND:\r\n        case Opcodes.IOR:\r\n        case Opcodes.IXOR:\r\n        case Opcodes.ISHL:\r\n        case Opcodes.ISHR:\r\n        case Opcodes.IUSHR:\r\n        case Opcodes.L2I:\r\n        case Opcodes.D2I:\r\n        case Opcodes.FCMPL:\r\n        case Opcodes.FCMPG:\r\n            pop(2);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LADD:\r\n        case Opcodes.LSUB:\r\n        case Opcodes.LMUL:\r\n        case Opcodes.LDIV:\r\n        case Opcodes.LREM:\r\n        case Opcodes.LAND:\r\n        case Opcodes.LOR:\r\n        case Opcodes.LXOR:\r\n            pop(4);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FALOAD:\r\n        case Opcodes.FADD:\r\n        case Opcodes.FSUB:\r\n        case Opcodes.FMUL:\r\n        case Opcodes.FDIV:\r\n        case Opcodes.FREM:\r\n        case Opcodes.L2F:\r\n        case Opcodes.D2F:\r\n            pop(2);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DADD:\r\n        case Opcodes.DSUB:\r\n        case Opcodes.DMUL:\r\n        case Opcodes.DDIV:\r\n        case Opcodes.DREM:\r\n            pop(4);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LSHL:\r\n        case Opcodes.LSHR:\r\n        case Opcodes.LUSHR:\r\n            pop(3);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.IINC:\r\n            setLocal(arg, INTEGER);\r\n            break;\r\n        case Opcodes.I2L:\r\n        case Opcodes.F2L:\r\n            pop(1);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.I2F:\r\n            pop(1);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.I2D:\r\n        case Opcodes.F2D:\r\n            pop(1);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.F2I:\r\n        case Opcodes.ARRAYLENGTH:\r\n        case Opcodes.INSTANCEOF:\r\n            pop(1);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCMP:\r\n        case Opcodes.DCMPL:\r\n        case Opcodes.DCMPG:\r\n            pop(4);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.JSR:\r\n        case Opcodes.RET:\r\n            throw new IllegalArgumentException(\"JSR/RET are not supported with computeFrames option\");\r\n        case Opcodes.GETSTATIC:\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTSTATIC:\r\n            pop(argSymbol.value);\r\n            break;\r\n        case Opcodes.GETFIELD:\r\n            pop(1);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTFIELD:\r\n            pop(argSymbol.value);\r\n            pop();\r\n            break;\r\n        case Opcodes.INVOKEVIRTUAL:\r\n        case Opcodes.INVOKESPECIAL:\r\n        case Opcodes.INVOKESTATIC:\r\n        case Opcodes.INVOKEINTERFACE:\r\n            pop(argSymbol.value);\r\n            if (opcode != Opcodes.INVOKESTATIC) {\r\n                abstractType1 = pop();\r\n                if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\r\n                    addInitializedType(abstractType1);\r\n                }\r\n            }\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.INVOKEDYNAMIC:\r\n            pop(argSymbol.value);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.NEW:\r\n            push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\r\n            break;\r\n        case Opcodes.NEWARRAY:\r\n            pop();\r\n            switch(arg) {\r\n                case Opcodes.T_BOOLEAN:\r\n                    push(ARRAY_OF | BOOLEAN);\r\n                    break;\r\n                case Opcodes.T_CHAR:\r\n                    push(ARRAY_OF | CHAR);\r\n                    break;\r\n                case Opcodes.T_BYTE:\r\n                    push(ARRAY_OF | BYTE);\r\n                    break;\r\n                case Opcodes.T_SHORT:\r\n                    push(ARRAY_OF | SHORT);\r\n                    break;\r\n                case Opcodes.T_INT:\r\n                    push(ARRAY_OF | INTEGER);\r\n                    break;\r\n                case Opcodes.T_FLOAT:\r\n                    push(ARRAY_OF | FLOAT);\r\n                    break;\r\n                case Opcodes.T_DOUBLE:\r\n                    push(ARRAY_OF | DOUBLE);\r\n                    break;\r\n                case Opcodes.T_LONG:\r\n                    push(ARRAY_OF | LONG);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException();\r\n            }\r\n            break;\r\n        case Opcodes.ANEWARRAY:\r\n            String arrayElementType = argSymbol.value;\r\n            pop();\r\n            if (arrayElementType.charAt(0) == '[') {\r\n                push(symbolTable, '[' + arrayElementType);\r\n            } else {\r\n                push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));\r\n            }\r\n            break;\r\n        case Opcodes.CHECKCAST:\r\n            String castType = argSymbol.value;\r\n            pop();\r\n            if (castType.charAt(0) == '[') {\r\n                push(symbolTable, castType);\r\n            } else {\r\n                push(REFERENCE_KIND | symbolTable.addType(castType));\r\n            }\r\n            break;\r\n        case Opcodes.MULTIANEWARRAY:\r\n            pop(arg);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "comment": "\n   * Simulates the action of the given instruction on the output stack frame.\n   *\n   * @param opcode the opcode of the instruction.\n   * @param arg the numeric operand of the instruction, if any.\n   * @param argSymbol the Symbol operand of the instruction, if any.\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReaderTests",
    "entityType": "class",
    "code": "public static final String CONTENT = \"<root xmlns='http://springframework.org/spring-ws'><child/></root>\";\n@Override\r\nprotected AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException {\r\n    return new StaxStreamXMLReader(inputFactory.createXMLStreamReader(inputStream));\r\n}\n@Test\r\nvoid partial() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(CONTENT));\r\n    // skip to root\r\n    streamReader.nextTag();\r\n    assertThat(streamReader.getName()).as(\"Invalid element\").isEqualTo(new QName(\"http://springframework.org/spring-ws\", \"root\"));\r\n    // skip to child\r\n    streamReader.nextTag();\r\n    assertThat(streamReader.getName()).as(\"Invalid element\").isEqualTo(new QName(\"http://springframework.org/spring-ws\", \"child\"));\r\n    StaxStreamXMLReader xmlReader = new StaxStreamXMLReader(streamReader);\r\n    ContentHandler contentHandler = mock();\r\n    xmlReader.setContentHandler(contentHandler);\r\n    xmlReader.parse(new InputSource());\r\n    verify(contentHandler).setDocumentLocator(any(Locator.class));\r\n    verify(contentHandler).startDocument();\r\n    verify(contentHandler).startElement(eq(\"http://springframework.org/spring-ws\"), eq(\"child\"), eq(\"child\"), any(Attributes.class));\r\n    verify(contentHandler).endElement(\"http://springframework.org/spring-ws\", \"child\", \"child\");\r\n    verify(contentHandler).endDocument();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReaderTests#createStaxXmlReader(InputStream)",
    "entityType": "method",
    "code": "@Override\r\nprotected AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException {\r\n    return new StaxStreamXMLReader(inputFactory.createXMLStreamReader(inputStream));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Frame#getConcreteOutputType(int,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Frame merging methods, used in the second step of the stack map frame computation algorithm\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Computes the concrete output type corresponding to a given abstract output type.\r\n *\r\n * @param abstractOutputType an abstract output type.\r\n * @param numStack the size of the input stack, used to resolve abstract output types of\r\n *     STACK_KIND kind.\r\n * @return the concrete output type corresponding to 'abstractOutputType'.\r\n */\r\nprivate int getConcreteOutputType(final int abstractOutputType, final int numStack) {\r\n    int dim = abstractOutputType & DIM_MASK;\r\n    int kind = abstractOutputType & KIND_MASK;\r\n    if (kind == LOCAL_KIND) {\r\n        // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\r\n        // the beginning of the basic block corresponding to this frame (which is known when\r\n        // this method is called, but was not when the abstract type was computed).\r\n        int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\r\n        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0 && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\r\n            concreteOutputType = TOP;\r\n        }\r\n        return concreteOutputType;\r\n    } else if (kind == STACK_KIND) {\r\n        // By definition, a STACK_KIND type designates the concrete type of a local variable at\r\n        // the beginning of the basic block corresponding to this frame (which is known when\r\n        // this method is called, but was not when the abstract type was computed).\r\n        int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\r\n        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0 && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\r\n            concreteOutputType = TOP;\r\n        }\r\n        return concreteOutputType;\r\n    } else {\r\n        return abstractOutputType;\r\n    }\r\n}",
    "comment": "\n   * Computes the concrete output type corresponding to a given abstract output type.\n   *\n   * @param abstractOutputType an abstract output type.\n   * @param numStack the size of the input stack, used to resolve abstract output types of\n   *     STACK_KIND kind.\n   * @return the concrete output type corresponding to 'abstractOutputType'.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamXMLReaderTests#partial()",
    "entityType": "method",
    "code": "@Test\r\nvoid partial() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(CONTENT));\r\n    // skip to root\r\n    streamReader.nextTag();\r\n    assertThat(streamReader.getName()).as(\"Invalid element\").isEqualTo(new QName(\"http://springframework.org/spring-ws\", \"root\"));\r\n    // skip to child\r\n    streamReader.nextTag();\r\n    assertThat(streamReader.getName()).as(\"Invalid element\").isEqualTo(new QName(\"http://springframework.org/spring-ws\", \"child\"));\r\n    StaxStreamXMLReader xmlReader = new StaxStreamXMLReader(streamReader);\r\n    ContentHandler contentHandler = mock();\r\n    xmlReader.setContentHandler(contentHandler);\r\n    xmlReader.parse(new InputSource());\r\n    verify(contentHandler).setDocumentLocator(any(Locator.class));\r\n    verify(contentHandler).startDocument();\r\n    verify(contentHandler).startElement(eq(\"http://springframework.org/spring-ws\"), eq(\"child\"), eq(\"child\"), any(Attributes.class));\r\n    verify(contentHandler).endElement(\"http://springframework.org/spring-ws\", \"child\", \"child\");\r\n    verify(contentHandler).endDocument();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Frame#merge(SymbolTable,Frame,int)",
    "entityType": "method",
    "code": "/**\r\n * Merges the input frame of the given {@link Frame} with the input and output frames of this\r\n * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation\r\n * (the input and output frames of this {@link Frame} are never changed).\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame\r\n *     of a successor, in the control flow graph, of the basic block corresponding to this frame.\r\n * @param catchTypeIndex if 'frame' corresponds to an exception handler basic block, the type\r\n *     table index of the caught exception type, otherwise 0.\r\n * @return {@literal true} if the input frame of 'frame' has been changed by this operation.\r\n */\r\nfinal boolean merge(final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {\r\n    boolean frameChanged = false;\r\n    // Compute the concrete types of the local variables at the end of the basic block corresponding\r\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\r\n    // those of the local variables in the input frame of dstFrame.\r\n    int numLocal = inputLocals.length;\r\n    int numStack = inputStack.length;\r\n    if (dstFrame.inputLocals == null) {\r\n        dstFrame.inputLocals = new int[numLocal];\r\n        frameChanged = true;\r\n    }\r\n    for (int i = 0; i < numLocal; ++i) {\r\n        int concreteOutputType;\r\n        if (outputLocals != null && i < outputLocals.length) {\r\n            int abstractOutputType = outputLocals[i];\r\n            if (abstractOutputType == 0) {\r\n                // If the local variable has never been assigned in this basic block, it is equal to its\r\n                // value at the beginning of the block.\r\n                concreteOutputType = inputLocals[i];\r\n            } else {\r\n                concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\r\n            }\r\n        } else {\r\n            // If the local variable has never been assigned in this basic block, it is equal to its\r\n            // value at the beginning of the block.\r\n            concreteOutputType = inputLocals[i];\r\n        }\r\n        // concreteOutputType might be an uninitialized type from the input locals or from the input\r\n        // stack. However, if a constructor has been called for this class type in the basic block,\r\n        // then this type is no longer uninitialized at the end of basic block.\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\r\n    }\r\n    // If dstFrame is an exception handler block, it can be reached from any instruction of the\r\n    // basic block corresponding to this frame, in particular from the first one. Therefore, the\r\n    // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this\r\n    // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one\r\n    // element stack containing the caught exception type).\r\n    if (catchTypeIndex > 0) {\r\n        for (int i = 0; i < numLocal; ++i) {\r\n            frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);\r\n        }\r\n        if (dstFrame.inputStack == null) {\r\n            dstFrame.inputStack = new int[1];\r\n            frameChanged = true;\r\n        }\r\n        frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);\r\n        return frameChanged;\r\n    }\r\n    // Compute the concrete types of the stack operands at the end of the basic block corresponding\r\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\r\n    // those of the stack operands in the input frame of dstFrame.\r\n    int numInputStack = inputStack.length + outputStackStart;\r\n    if (dstFrame.inputStack == null) {\r\n        dstFrame.inputStack = new int[numInputStack + outputStackTop];\r\n        frameChanged = true;\r\n    }\r\n    // First, do this for the stack operands that have not been popped in the basic block\r\n    // corresponding to this frame, and which are therefore equal to their value in the input\r\n    // frame (except for uninitialized types, which may have been initialized).\r\n    for (int i = 0; i < numInputStack; ++i) {\r\n        int concreteOutputType = inputStack[i];\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\r\n    }\r\n    // Then, do this for the stack operands that have pushed in the basic block (this code is the\r\n    // same as the one above for local variables).\r\n    for (int i = 0; i < outputStackTop; ++i) {\r\n        int abstractOutputType = outputStack[i];\r\n        int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\r\n    }\r\n    return frameChanged;\r\n}",
    "comment": "\n   * Merges the input frame of the given {@link Frame} with the input and output frames of this\n   * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation\n   * (the input and output frames of this {@link Frame} are never changed).\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame\n   *     of a successor, in the control flow graph, of the basic block corresponding to this frame.\n   * @param catchTypeIndex if 'frame' corresponds to an exception handler basic block, the type\n   *     table index of the caught exception type, otherwise 0.\n   * @return {@literal true} if the input frame of 'frame' has been changed by this operation.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#merge(SymbolTable,int,int[],int)",
    "entityType": "method",
    "code": "/**\r\n * Merges the type at the given index in the given abstract type array with the given type.\r\n * Returns {@literal true} if the type array has been modified by this operation.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param sourceType the abstract type with which the abstract type array element must be merged.\r\n *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\r\n *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\r\n *     {@literal null} array dimensions.\r\n * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},\r\n *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\r\n *     kind, with positive or {@literal null} array dimensions.\r\n * @param dstIndex the index of the type that must be merged in dstTypes.\r\n * @return {@literal true} if the type array has been modified by this operation.\r\n */\r\nprivate static boolean merge(final SymbolTable symbolTable, final int sourceType, final int[] dstTypes, final int dstIndex) {\r\n    int dstType = dstTypes[dstIndex];\r\n    if (dstType == sourceType) {\r\n        // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\r\n        return false;\r\n    }\r\n    int srcType = sourceType;\r\n    if ((sourceType & ~DIM_MASK) == NULL) {\r\n        if (dstType == NULL) {\r\n            return false;\r\n        }\r\n        srcType = NULL;\r\n    }\r\n    if (dstType == 0) {\r\n        // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\r\n        dstTypes[dstIndex] = srcType;\r\n        return true;\r\n    }\r\n    int mergedType;\r\n    if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\r\n        // If dstType is a reference type of any array dimension.\r\n        if (srcType == NULL) {\r\n            // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\r\n            return false;\r\n        } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\r\n            // If srcType has the same array dimension and the same kind as dstType.\r\n            if ((dstType & KIND_MASK) == REFERENCE_KIND) {\r\n                // If srcType and dstType are reference types with the same array dimension,\r\n                // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\r\n                mergedType = (srcType & DIM_MASK) | REFERENCE_KIND | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\r\n            } else {\r\n                // If srcType and dstType are array types of equal dimension but different element types,\r\n                // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\r\n                int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\r\n                mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\r\n            }\r\n        } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\r\n            // If srcType is any other reference or array type,\r\n            // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\r\n            // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\r\n            // with a non reference element type (and similarly for dstDim).\r\n            int srcDim = srcType & DIM_MASK;\r\n            if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\r\n                srcDim = ELEMENT_OF + srcDim;\r\n            }\r\n            int dstDim = dstType & DIM_MASK;\r\n            if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\r\n                dstDim = ELEMENT_OF + dstDim;\r\n            }\r\n            mergedType = Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\r\n        } else {\r\n            // If srcType is any other type, merge(srcType, dstType) = TOP.\r\n            mergedType = TOP;\r\n        }\r\n    } else if (dstType == NULL) {\r\n        // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\r\n        // an array type or a reference type.\r\n        mergedType = (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\r\n    } else {\r\n        // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\r\n        mergedType = TOP;\r\n    }\r\n    if (mergedType != dstType) {\r\n        dstTypes[dstIndex] = mergedType;\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "comment": "\n   * Merges the type at the given index in the given abstract type array with the given type.\n   * Returns {@literal true} if the type array has been modified by this operation.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param sourceType the abstract type with which the abstract type array element must be merged.\n   *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\n   *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\n   *     {@literal null} array dimensions.\n   * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},\n   *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\n   *     kind, with positive or {@literal null} array dimensions.\n   * @param dstIndex the index of the type that must be merged in dstTypes.\n   * @return {@literal true} if the type array has been modified by this operation.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#accept(MethodWriter)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Frame output methods, to generate StackMapFrame attributes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\r\n * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\r\n * {@link MethodWriter#visitFrameEnd} methods.\r\n *\r\n * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\r\n *     Frame}.\r\n */\r\nfinal void accept(final MethodWriter methodWriter) {\r\n    // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\r\n    // all trailing TOP types.\r\n    int[] localTypes = inputLocals;\r\n    int numLocal = 0;\r\n    int numTrailingTop = 0;\r\n    int i = 0;\r\n    while (i < localTypes.length) {\r\n        int localType = localTypes[i];\r\n        i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\r\n        if (localType == TOP) {\r\n            numTrailingTop++;\r\n        } else {\r\n            numLocal += numTrailingTop + 1;\r\n            numTrailingTop = 0;\r\n        }\r\n    }\r\n    // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\r\n    int[] stackTypes = inputStack;\r\n    int numStack = 0;\r\n    i = 0;\r\n    while (i < stackTypes.length) {\r\n        int stackType = stackTypes[i];\r\n        i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\r\n        numStack++;\r\n    }\r\n    // Visit the frame and its content.\r\n    int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\r\n    i = 0;\r\n    while (numLocal-- > 0) {\r\n        int localType = localTypes[i];\r\n        i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\r\n        methodWriter.visitAbstractType(frameIndex++, localType);\r\n    }\r\n    i = 0;\r\n    while (numStack-- > 0) {\r\n        int stackType = stackTypes[i];\r\n        i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\r\n        methodWriter.visitAbstractType(frameIndex++, stackType);\r\n    }\r\n    methodWriter.visitFrameEnd();\r\n}",
    "comment": "\n   * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\n   * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\n   * {@link MethodWriter#visitFrameEnd} methods.\n   *\n   * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\n   *     Frame}.\n   "
  },
  {
    "entityId": "org.springframework.asm.Frame#putAbstractType(SymbolTable,int,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\r\n * format used in StackMapTable attributes.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\r\n *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link\r\n *     Frame#FORWARD_UNINITIALIZED_KIND} types.\r\n * @param output where the abstract type must be put.\r\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\r\n *     4.7.4</a>\r\n */\r\nstatic void putAbstractType(final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\r\n    int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\r\n    if (arrayDimensions == 0) {\r\n        int typeValue = abstractType & VALUE_MASK;\r\n        switch(abstractType & KIND_MASK) {\r\n            case CONSTANT_KIND:\r\n                output.putByte(typeValue);\r\n                break;\r\n            case REFERENCE_KIND:\r\n                output.putByte(ITEM_OBJECT).putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);\r\n                break;\r\n            case UNINITIALIZED_KIND:\r\n                output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data);\r\n                break;\r\n            case FORWARD_UNINITIALIZED_KIND:\r\n                output.putByte(ITEM_UNINITIALIZED);\r\n                symbolTable.getForwardUninitializedLabel(typeValue).put(output);\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    } else {\r\n        // Case of an array type, we need to build its descriptor first.\r\n        // SPRING PATCH: larger initial size\r\n        StringBuilder typeDescriptor = new StringBuilder(32);\r\n        while (arrayDimensions-- > 0) {\r\n            typeDescriptor.append('[');\r\n        }\r\n        if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\r\n            typeDescriptor.append('L').append(symbolTable.getType(abstractType & VALUE_MASK).value).append(';');\r\n        } else {\r\n            switch(abstractType & VALUE_MASK) {\r\n                case Frame.ITEM_ASM_BOOLEAN:\r\n                    typeDescriptor.append('Z');\r\n                    break;\r\n                case Frame.ITEM_ASM_BYTE:\r\n                    typeDescriptor.append('B');\r\n                    break;\r\n                case Frame.ITEM_ASM_CHAR:\r\n                    typeDescriptor.append('C');\r\n                    break;\r\n                case Frame.ITEM_ASM_SHORT:\r\n                    typeDescriptor.append('S');\r\n                    break;\r\n                case Frame.ITEM_INTEGER:\r\n                    typeDescriptor.append('I');\r\n                    break;\r\n                case Frame.ITEM_FLOAT:\r\n                    typeDescriptor.append('F');\r\n                    break;\r\n                case Frame.ITEM_LONG:\r\n                    typeDescriptor.append('J');\r\n                    break;\r\n                case Frame.ITEM_DOUBLE:\r\n                    typeDescriptor.append('D');\r\n                    break;\r\n                default:\r\n                    throw new AssertionError();\r\n            }\r\n        }\r\n        output.putByte(ITEM_OBJECT).putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index);\r\n    }\r\n}",
    "comment": "\n   * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\n   * format used in StackMapTable attributes.\n   *\n   * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\n   * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\n   *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link\n   *     Frame#FORWARD_UNINITIALIZED_KIND} types.\n   * @param output where the abstract type must be put.\n   * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n   *     4.7.4</a>\n   "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid isStaxSourceInvalid() {\r\n    assertThat(StaxUtils.isStaxSource(new DOMSource())).as(\"A StAX Source\").isFalse();\r\n    assertThat(StaxUtils.isStaxSource(new SAXSource())).as(\"A StAX Source\").isFalse();\r\n    assertThat(StaxUtils.isStaxSource(new StreamSource())).as(\"A StAX Source\").isFalse();\r\n}\n@Test\r\nvoid isStaxSource() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    String expected = \"<element/>\";\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(expected));\r\n    Source source = StaxUtils.createCustomStaxSource(streamReader);\r\n    assertThat(StaxUtils.isStaxSource(source)).as(\"Not a StAX Source\").isTrue();\r\n}\n@Test\r\nvoid isStaxSourceJaxp14() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    String expected = \"<element/>\";\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(expected));\r\n    StAXSource source = new StAXSource(streamReader);\r\n    assertThat(StaxUtils.isStaxSource(source)).as(\"Not a StAX Source\").isTrue();\r\n}\n@Test\r\nvoid isStaxResultInvalid() {\r\n    assertThat(StaxUtils.isStaxResult(new DOMResult())).as(\"A StAX Result\").isFalse();\r\n    assertThat(StaxUtils.isStaxResult(new SAXResult())).as(\"A StAX Result\").isFalse();\r\n    assertThat(StaxUtils.isStaxResult(new StreamResult())).as(\"A StAX Result\").isFalse();\r\n}\n@Test\r\nvoid isStaxResult() throws Exception {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\r\n    XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(new StringWriter());\r\n    Result result = StaxUtils.createCustomStaxResult(streamWriter);\r\n    assertThat(StaxUtils.isStaxResult(result)).as(\"Not a StAX Result\").isTrue();\r\n}\n@Test\r\nvoid isStaxResultJaxp14() throws Exception {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\r\n    XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(new StringWriter());\r\n    StAXResult result = new StAXResult(streamWriter);\r\n    assertThat(StaxUtils.isStaxResult(result)).as(\"Not a StAX Result\").isTrue();\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests#isStaxSourceInvalid()",
    "entityType": "method",
    "code": "@Test\r\nvoid isStaxSourceInvalid() {\r\n    assertThat(StaxUtils.isStaxSource(new DOMSource())).as(\"A StAX Source\").isFalse();\r\n    assertThat(StaxUtils.isStaxSource(new SAXSource())).as(\"A StAX Source\").isFalse();\r\n    assertThat(StaxUtils.isStaxSource(new StreamSource())).as(\"A StAX Source\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests#isStaxSource()",
    "entityType": "method",
    "code": "@Test\r\nvoid isStaxSource() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    String expected = \"<element/>\";\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(expected));\r\n    Source source = StaxUtils.createCustomStaxSource(streamReader);\r\n    assertThat(StaxUtils.isStaxSource(source)).as(\"Not a StAX Source\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests#isStaxSourceJaxp14()",
    "entityType": "method",
    "code": "@Test\r\nvoid isStaxSourceJaxp14() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    String expected = \"<element/>\";\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(expected));\r\n    StAXSource source = new StAXSource(streamReader);\r\n    assertThat(StaxUtils.isStaxSource(source)).as(\"Not a StAX Source\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests#isStaxResultInvalid()",
    "entityType": "method",
    "code": "@Test\r\nvoid isStaxResultInvalid() {\r\n    assertThat(StaxUtils.isStaxResult(new DOMResult())).as(\"A StAX Result\").isFalse();\r\n    assertThat(StaxUtils.isStaxResult(new SAXResult())).as(\"A StAX Result\").isFalse();\r\n    assertThat(StaxUtils.isStaxResult(new StreamResult())).as(\"A StAX Result\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests#isStaxResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid isStaxResult() throws Exception {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\r\n    XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(new StringWriter());\r\n    Result result = StaxUtils.createCustomStaxResult(streamWriter);\r\n    assertThat(StaxUtils.isStaxResult(result)).as(\"Not a StAX Result\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxUtilsTests#isStaxResultJaxp14()",
    "entityType": "method",
    "code": "@Test\r\nvoid isStaxResultJaxp14() throws Exception {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\r\n    XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(new StringWriter());\r\n    StAXResult result = new StAXResult(streamWriter);\r\n    assertThat(StaxUtils.isStaxResult(result)).as(\"Not a StAX Result\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Handle",
    "entityType": "class",
    "code": "/**\r\n * The kind of field or method designated by this Handle. Should be {@link Opcodes#H_GETFIELD},\r\n * {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link\r\n * Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL},\r\n * {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n */\r\nprivate final int tag;\n/**\r\n * The internal name of the class that owns the field or method designated by this handle.\r\n */\r\nprivate final String owner;\n/**\r\n * The name of the field or method designated by this handle.\r\n */\r\nprivate final String name;\n/**\r\n * The descriptor of the field or method designated by this handle.\r\n */\r\nprivate final String descriptor;\n/**\r\n * Whether the owner is an interface or not.\r\n */\r\nprivate final boolean isInterface;\n/**\r\n * Constructs a new field or method handle.\r\n *\r\n * @param tag the kind of field or method designated by this Handle. Must be {@link\r\n *     Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link\r\n *     Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC},\r\n *     {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link\r\n *     Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of the class that owns the field or method designated by this\r\n *     handle (see {@link Type#getInternalName()}).\r\n * @param name the name of the field or method designated by this handle.\r\n * @param descriptor the descriptor of the field or method designated by this handle.\r\n * @deprecated this constructor has been superseded by {@link #Handle(int, String, String, String,\r\n *     boolean)}.\r\n */\r\n@Deprecated\r\npublic Handle(final int tag, final String owner, final String name, final String descriptor) {\r\n    this(tag, owner, name, descriptor, tag == Opcodes.H_INVOKEINTERFACE);\r\n}\n/**\r\n * Constructs a new field or method handle.\r\n *\r\n * @param tag the kind of field or method designated by this Handle. Must be {@link\r\n *     Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link\r\n *     Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC},\r\n *     {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link\r\n *     Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of the class that owns the field or method designated by this\r\n *     handle (see {@link Type#getInternalName()}).\r\n * @param name the name of the field or method designated by this handle.\r\n * @param descriptor the descriptor of the field or method designated by this handle.\r\n * @param isInterface whether the owner is an interface or not.\r\n */\r\npublic Handle(final int tag, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    this.tag = tag;\r\n    this.owner = owner;\r\n    this.name = name;\r\n    this.descriptor = descriptor;\r\n    this.isInterface = isInterface;\r\n}\n/**\r\n * Returns the kind of field or method designated by this handle.\r\n *\r\n * @return {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},\r\n *     {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n */\r\npublic int getTag() {\r\n    return tag;\r\n}\n/**\r\n * Returns the internal name of the class that owns the field or method designated by this handle.\r\n *\r\n * @return the internal name of the class that owns the field or method designated by this handle\r\n *     (see {@link Type#getInternalName()}).\r\n */\r\npublic String getOwner() {\r\n    return owner;\r\n}\n/**\r\n * Returns the name of the field or method designated by this handle.\r\n *\r\n * @return the name of the field or method designated by this handle.\r\n */\r\npublic String getName() {\r\n    return name;\r\n}\n/**\r\n * Returns the descriptor of the field or method designated by this handle.\r\n *\r\n * @return the descriptor of the field or method designated by this handle.\r\n */\r\npublic String getDesc() {\r\n    return descriptor;\r\n}\n/**\r\n * Returns true if the owner of the field or method designated by this handle is an interface.\r\n *\r\n * @return true if the owner of the field or method designated by this handle is an interface.\r\n */\r\npublic boolean isInterface() {\r\n    return isInterface;\r\n}\n@Override\r\npublic boolean equals(final Object object) {\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof Handle)) {\r\n        return false;\r\n    }\r\n    Handle handle = (Handle) object;\r\n    return tag == handle.tag && isInterface == handle.isInterface && owner.equals(handle.owner) && name.equals(handle.name) && descriptor.equals(handle.descriptor);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return tag + (isInterface ? 64 : 0) + owner.hashCode() * name.hashCode() * descriptor.hashCode();\r\n}\n/**\r\n * Returns the textual representation of this handle. The textual representation is:\r\n *\r\n * <ul>\r\n *   <li>for a reference to a class: owner \".\" name descriptor \" (\" tag \")\",\r\n *   <li>for a reference to an interface: owner \".\" name descriptor \" (\" tag \" itf)\".\r\n * </ul>\r\n */\r\n@Override\r\npublic String toString() {\r\n    return owner + '.' + name + descriptor + \" (\" + tag + (isInterface ? \" itf\" : \"\") + ')';\r\n}",
    "comment": "\n * A reference to a field or a method.\n *\n * @author Remi Forax\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.Handle#getTag()",
    "entityType": "method",
    "code": "/**\r\n * Returns the kind of field or method designated by this handle.\r\n *\r\n * @return {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},\r\n *     {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n */\r\npublic int getTag() {\r\n    return tag;\r\n}",
    "comment": "\n   * Returns the kind of field or method designated by this handle.\n   *\n   * @return {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},\n   *     {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handle#getOwner()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the class that owns the field or method designated by this handle.\r\n *\r\n * @return the internal name of the class that owns the field or method designated by this handle\r\n *     (see {@link Type#getInternalName()}).\r\n */\r\npublic String getOwner() {\r\n    return owner;\r\n}",
    "comment": "\n   * Returns the internal name of the class that owns the field or method designated by this handle.\n   *\n   * @return the internal name of the class that owns the field or method designated by this handle\n   *     (see {@link Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.Handle#getName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the name of the field or method designated by this handle.\r\n *\r\n * @return the name of the field or method designated by this handle.\r\n */\r\npublic String getName() {\r\n    return name;\r\n}",
    "comment": "\n   * Returns the name of the field or method designated by this handle.\n   *\n   * @return the name of the field or method designated by this handle.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handle#getDesc()",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor of the field or method designated by this handle.\r\n *\r\n * @return the descriptor of the field or method designated by this handle.\r\n */\r\npublic String getDesc() {\r\n    return descriptor;\r\n}",
    "comment": "\n   * Returns the descriptor of the field or method designated by this handle.\n   *\n   * @return the descriptor of the field or method designated by this handle.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handle#isInterface()",
    "entityType": "method",
    "code": "/**\r\n * Returns true if the owner of the field or method designated by this handle is an interface.\r\n *\r\n * @return true if the owner of the field or method designated by this handle is an interface.\r\n */\r\npublic boolean isInterface() {\r\n    return isInterface;\r\n}",
    "comment": "\n   * Returns true if the owner of the field or method designated by this handle is an interface.\n   *\n   * @return true if the owner of the field or method designated by this handle is an interface.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handle#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(final Object object) {\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof Handle)) {\r\n        return false;\r\n    }\r\n    Handle handle = (Handle) object;\r\n    return tag == handle.tag && isInterface == handle.isInterface && owner.equals(handle.owner) && name.equals(handle.name) && descriptor.equals(handle.descriptor);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Handle#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return tag + (isInterface ? 64 : 0) + owner.hashCode() * name.hashCode() * descriptor.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Handle#toString()",
    "entityType": "method",
    "code": "/**\r\n * Returns the textual representation of this handle. The textual representation is:\r\n *\r\n * <ul>\r\n *   <li>for a reference to a class: owner \".\" name descriptor \" (\" tag \")\",\r\n *   <li>for a reference to an interface: owner \".\" name descriptor \" (\" tag \" itf)\".\r\n * </ul>\r\n */\r\n@Override\r\npublic String toString() {\r\n    return owner + '.' + name + descriptor + \" (\" + tag + (isInterface ? \" itf\" : \"\") + ')';\r\n}",
    "comment": "\n   * Returns the textual representation of this handle. The textual representation is:\n   *\n   * <ul>\n   *   <li>for a reference to a class: owner \".\" name descriptor \" (\" tag \")\",\n   *   <li>for a reference to an interface: owner \".\" name descriptor \" (\" tag \" itf)\".\n   * </ul>\n   "
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid enableIndentingSunnyDay() {\r\n    Transformer transformer = new StubTransformer();\r\n    TransformerUtils.enableIndenting(transformer);\r\n    String indent = transformer.getOutputProperty(OutputKeys.INDENT);\r\n    assertThat(indent).isNotNull();\r\n    assertThat(indent).isEqualTo(\"yes\");\r\n    String indentAmount = transformer.getOutputProperty(\"{http://xml.apache.org/xalan}indent-amount\");\r\n    assertThat(indentAmount).isNotNull();\r\n    assertThat(indentAmount).isEqualTo(String.valueOf(TransformerUtils.DEFAULT_INDENT_AMOUNT));\r\n}\n@Test\r\nvoid enableIndentingSunnyDayWithCustomKosherIndentAmount() {\r\n    final String indentAmountProperty = \"10\";\r\n    Transformer transformer = new StubTransformer();\r\n    TransformerUtils.enableIndenting(transformer, Integer.parseInt(indentAmountProperty));\r\n    String indent = transformer.getOutputProperty(OutputKeys.INDENT);\r\n    assertThat(indent).isNotNull();\r\n    assertThat(indent).isEqualTo(\"yes\");\r\n    String indentAmount = transformer.getOutputProperty(\"{http://xml.apache.org/xalan}indent-amount\");\r\n    assertThat(indentAmount).isNotNull();\r\n    assertThat(indentAmount).isEqualTo(indentAmountProperty);\r\n}\n@Test\r\nvoid disableIndentingSunnyDay() {\r\n    Transformer transformer = new StubTransformer();\r\n    TransformerUtils.disableIndenting(transformer);\r\n    String indent = transformer.getOutputProperty(OutputKeys.INDENT);\r\n    assertThat(indent).isNotNull();\r\n    assertThat(indent).isEqualTo(\"no\");\r\n}\n@Test\r\nvoid enableIndentingWithNullTransformer() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TransformerUtils.enableIndenting(null));\r\n}\n@Test\r\nvoid disableIndentingWithNullTransformer() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TransformerUtils.disableIndenting(null));\r\n}\n@Test\r\nvoid enableIndentingWithNegativeIndentAmount() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TransformerUtils.enableIndenting(new StubTransformer(), -21938));\r\n}\n@Test\r\nvoid enableIndentingWithZeroIndentAmount() {\r\n    TransformerUtils.enableIndenting(new StubTransformer(), 0);\r\n}\nprivate static class StubTransformer extends Transformer {\r\n\r\n    private Properties outputProperties = new Properties();\r\n\r\n    @Override\r\n    public void transform(Source xmlSource, Result outputTarget) throws TransformerException {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void setParameter(String name, Object value) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public Object getParameter(String name) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void clearParameters() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void setURIResolver(URIResolver resolver) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public URIResolver getURIResolver() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void setOutputProperties(Properties oformat) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public Properties getOutputProperties() {\r\n        return this.outputProperties;\r\n    }\r\n\r\n    @Override\r\n    public void setOutputProperty(String name, String value) throws IllegalArgumentException {\r\n        this.outputProperties.setProperty(name, value);\r\n    }\r\n\r\n    @Override\r\n    public String getOutputProperty(String name) throws IllegalArgumentException {\r\n        return this.outputProperties.getProperty(name);\r\n    }\r\n\r\n    @Override\r\n    public void setErrorListener(ErrorListener listener) throws IllegalArgumentException {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public ErrorListener getErrorListener() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}",
    "comment": "\n * Tests for {@link TransformerUtils}.\n *\n * @author Rick Evans\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#enableIndentingSunnyDay()",
    "entityType": "method",
    "code": "@Test\r\nvoid enableIndentingSunnyDay() {\r\n    Transformer transformer = new StubTransformer();\r\n    TransformerUtils.enableIndenting(transformer);\r\n    String indent = transformer.getOutputProperty(OutputKeys.INDENT);\r\n    assertThat(indent).isNotNull();\r\n    assertThat(indent).isEqualTo(\"yes\");\r\n    String indentAmount = transformer.getOutputProperty(\"{http://xml.apache.org/xalan}indent-amount\");\r\n    assertThat(indentAmount).isNotNull();\r\n    assertThat(indentAmount).isEqualTo(String.valueOf(TransformerUtils.DEFAULT_INDENT_AMOUNT));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#enableIndentingSunnyDayWithCustomKosherIndentAmount()",
    "entityType": "method",
    "code": "@Test\r\nvoid enableIndentingSunnyDayWithCustomKosherIndentAmount() {\r\n    final String indentAmountProperty = \"10\";\r\n    Transformer transformer = new StubTransformer();\r\n    TransformerUtils.enableIndenting(transformer, Integer.parseInt(indentAmountProperty));\r\n    String indent = transformer.getOutputProperty(OutputKeys.INDENT);\r\n    assertThat(indent).isNotNull();\r\n    assertThat(indent).isEqualTo(\"yes\");\r\n    String indentAmount = transformer.getOutputProperty(\"{http://xml.apache.org/xalan}indent-amount\");\r\n    assertThat(indentAmount).isNotNull();\r\n    assertThat(indentAmount).isEqualTo(indentAmountProperty);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#disableIndentingSunnyDay()",
    "entityType": "method",
    "code": "@Test\r\nvoid disableIndentingSunnyDay() {\r\n    Transformer transformer = new StubTransformer();\r\n    TransformerUtils.disableIndenting(transformer);\r\n    String indent = transformer.getOutputProperty(OutputKeys.INDENT);\r\n    assertThat(indent).isNotNull();\r\n    assertThat(indent).isEqualTo(\"no\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#enableIndentingWithNullTransformer()",
    "entityType": "method",
    "code": "@Test\r\nvoid enableIndentingWithNullTransformer() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TransformerUtils.enableIndenting(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#disableIndentingWithNullTransformer()",
    "entityType": "method",
    "code": "@Test\r\nvoid disableIndentingWithNullTransformer() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TransformerUtils.disableIndenting(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#enableIndentingWithNegativeIndentAmount()",
    "entityType": "method",
    "code": "@Test\r\nvoid enableIndentingWithNegativeIndentAmount() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> TransformerUtils.enableIndenting(new StubTransformer(), -21938));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.TransformerUtilsTests#enableIndentingWithZeroIndentAmount()",
    "entityType": "method",
    "code": "@Test\r\nvoid enableIndentingWithZeroIndentAmount() {\r\n    TransformerUtils.enableIndenting(new StubTransformer(), 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer",
    "entityType": "class",
    "code": "private Properties outputProperties = new Properties();\n@Override\r\npublic void transform(Source xmlSource, Result outputTarget) throws TransformerException {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic void setParameter(String name, Object value) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic Object getParameter(String name) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic void clearParameters() {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic void setURIResolver(URIResolver resolver) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic URIResolver getURIResolver() {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic void setOutputProperties(Properties oformat) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic Properties getOutputProperties() {\r\n    return this.outputProperties;\r\n}\n@Override\r\npublic void setOutputProperty(String name, String value) throws IllegalArgumentException {\r\n    this.outputProperties.setProperty(name, value);\r\n}\n@Override\r\npublic String getOutputProperty(String name) throws IllegalArgumentException {\r\n    return this.outputProperties.getProperty(name);\r\n}\n@Override\r\npublic void setErrorListener(ErrorListener listener) throws IllegalArgumentException {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic ErrorListener getErrorListener() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#transform(Source,Result)",
    "entityType": "method",
    "code": "@Override\r\npublic void transform(Source xmlSource, Result outputTarget) throws TransformerException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#setParameter(String,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void setParameter(String name, Object value) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#getParameter(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Object getParameter(String name) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#clearParameters()",
    "entityType": "method",
    "code": "@Override\r\npublic void clearParameters() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#setURIResolver(URIResolver)",
    "entityType": "method",
    "code": "@Override\r\npublic void setURIResolver(URIResolver resolver) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#getURIResolver()",
    "entityType": "method",
    "code": "@Override\r\npublic URIResolver getURIResolver() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#setOutputProperties(Properties)",
    "entityType": "method",
    "code": "@Override\r\npublic void setOutputProperties(Properties oformat) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#getOutputProperties()",
    "entityType": "method",
    "code": "@Override\r\npublic Properties getOutputProperties() {\r\n    return this.outputProperties;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#setOutputProperty(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setOutputProperty(String name, String value) throws IllegalArgumentException {\r\n    this.outputProperties.setProperty(name, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#getOutputProperty(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String getOutputProperty(String name) throws IllegalArgumentException {\r\n    return this.outputProperties.getProperty(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#setErrorListener(ErrorListener)",
    "entityType": "method",
    "code": "@Override\r\npublic void setErrorListener(ErrorListener listener) throws IllegalArgumentException {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StubTransformer#getErrorListener()",
    "entityType": "method",
    "code": "@Override\r\npublic ErrorListener getErrorListener() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Handler",
    "entityType": "class",
    "code": "/**\r\n * The start_pc field of this JVMS exception_table entry. Corresponds to the beginning of the\r\n * exception handler's scope (inclusive).\r\n */\r\nfinal Label startPc;\n/**\r\n * The end_pc field of this JVMS exception_table entry. Corresponds to the end of the exception\r\n * handler's scope (exclusive).\r\n */\r\nfinal Label endPc;\n/**\r\n * The handler_pc field of this JVMS exception_table entry. Corresponding to the beginning of the\r\n * exception handler's code.\r\n */\r\nfinal Label handlerPc;\n/**\r\n * The catch_type field of this JVMS exception_table entry. This is the constant pool index of the\r\n * internal name of the type of exceptions handled by this handler, or 0 to catch any exceptions.\r\n */\r\nfinal int catchType;\n/**\r\n * The internal name of the type of exceptions handled by this handler, or {@literal null} to\r\n * catch any exceptions.\r\n */\r\nfinal String catchTypeDescriptor;\n/**\r\n * The next exception handler.\r\n */\r\nHandler nextHandler;\n/**\r\n * Constructs a new Handler.\r\n *\r\n * @param startPc the start_pc field of this JVMS exception_table entry.\r\n * @param endPc the end_pc field of this JVMS exception_table entry.\r\n * @param handlerPc the handler_pc field of this JVMS exception_table entry.\r\n * @param catchType The catch_type field of this JVMS exception_table entry.\r\n * @param catchTypeDescriptor The internal name of the type of exceptions handled by this handler,\r\n *     or {@literal null} to catch any exceptions.\r\n */\r\nHandler(final Label startPc, final Label endPc, final Label handlerPc, final int catchType, final String catchTypeDescriptor) {\r\n    this.startPc = startPc;\r\n    this.endPc = endPc;\r\n    this.handlerPc = handlerPc;\r\n    this.catchType = catchType;\r\n    this.catchTypeDescriptor = catchTypeDescriptor;\r\n}\n/**\r\n * Constructs a new Handler from the given one, with a different scope.\r\n *\r\n * @param handler an existing Handler.\r\n * @param startPc the start_pc field of this JVMS exception_table entry.\r\n * @param endPc the end_pc field of this JVMS exception_table entry.\r\n */\r\nHandler(final Handler handler, final Label startPc, final Label endPc) {\r\n    this(startPc, endPc, handler.handlerPc, handler.catchType, handler.catchTypeDescriptor);\r\n    this.nextHandler = handler.nextHandler;\r\n}\n/**\r\n * Removes the range between start and end from the Handler list that begins with the given\r\n * element.\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @param start the start of the range to be removed.\r\n * @param end the end of the range to be removed. Maybe {@literal null}.\r\n * @return the exception handler list with the start-end range removed.\r\n */\r\nstatic Handler removeRange(final Handler firstHandler, final Label start, final Label end) {\r\n    if (firstHandler == null) {\r\n        return null;\r\n    } else {\r\n        firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end);\r\n    }\r\n    int handlerStart = firstHandler.startPc.bytecodeOffset;\r\n    int handlerEnd = firstHandler.endPc.bytecodeOffset;\r\n    int rangeStart = start.bytecodeOffset;\r\n    int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset;\r\n    // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect.\r\n    if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) {\r\n        return firstHandler;\r\n    }\r\n    if (rangeStart <= handlerStart) {\r\n        if (rangeEnd >= handlerEnd) {\r\n            // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler.\r\n            return firstHandler.nextHandler;\r\n        } else {\r\n            // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[\r\n            return new Handler(firstHandler, end, firstHandler.endPc);\r\n        }\r\n    } else if (rangeEnd >= handlerEnd) {\r\n        // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[\r\n        return new Handler(firstHandler, firstHandler.startPc, start);\r\n    } else {\r\n        // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ =\r\n        //     [handlerStart,rangeStart[ + [rangeEnd,handerEnd[\r\n        firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc);\r\n        return new Handler(firstHandler, firstHandler.startPc, start);\r\n    }\r\n}\n/**\r\n * Returns the number of elements of the Handler list that begins with the given element.\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @return the number of elements of the Handler list that begins with 'handler'.\r\n */\r\nstatic int getExceptionTableLength(final Handler firstHandler) {\r\n    int length = 0;\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        length++;\r\n        handler = handler.nextHandler;\r\n    }\r\n    return length;\r\n}\n/**\r\n * Returns the size in bytes of the JVMS exception_table corresponding to the Handler list that\r\n * begins with the given element. <i>This includes the exception_table_length field.</i>\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @return the size in bytes of the exception_table_length and exception_table structures.\r\n */\r\nstatic int getExceptionTableSize(final Handler firstHandler) {\r\n    return 2 + 8 * getExceptionTableLength(firstHandler);\r\n}\n/**\r\n * Puts the JVMS exception_table corresponding to the Handler list that begins with the given\r\n * element. <i>This includes the exception_table_length field.</i>\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @param output where the exception_table_length and exception_table structures must be put.\r\n */\r\nstatic void putExceptionTable(final Handler firstHandler, final ByteVector output) {\r\n    output.putShort(getExceptionTableLength(firstHandler));\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        output.putShort(handler.startPc.bytecodeOffset).putShort(handler.endPc.bytecodeOffset).putShort(handler.handlerPc.bytecodeOffset).putShort(handler.catchType);\r\n        handler = handler.nextHandler;\r\n    }\r\n}",
    "comment": "\n * Information about an exception handler. Corresponds to an element of the exception_table array of\n * a Code attribute, as defined in the Java Virtual Machine Specification (JVMS). Handler instances\n * can be chained together, with their {@link #nextHandler} field, to describe a full JVMS\n * exception_table array.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3\">JVMS\n *     4.7.3</a>\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.Handler#removeRange(Handler,Label,Label)",
    "entityType": "method",
    "code": "/**\r\n * Removes the range between start and end from the Handler list that begins with the given\r\n * element.\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @param start the start of the range to be removed.\r\n * @param end the end of the range to be removed. Maybe {@literal null}.\r\n * @return the exception handler list with the start-end range removed.\r\n */\r\nstatic Handler removeRange(final Handler firstHandler, final Label start, final Label end) {\r\n    if (firstHandler == null) {\r\n        return null;\r\n    } else {\r\n        firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end);\r\n    }\r\n    int handlerStart = firstHandler.startPc.bytecodeOffset;\r\n    int handlerEnd = firstHandler.endPc.bytecodeOffset;\r\n    int rangeStart = start.bytecodeOffset;\r\n    int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset;\r\n    // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect.\r\n    if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) {\r\n        return firstHandler;\r\n    }\r\n    if (rangeStart <= handlerStart) {\r\n        if (rangeEnd >= handlerEnd) {\r\n            // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler.\r\n            return firstHandler.nextHandler;\r\n        } else {\r\n            // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[\r\n            return new Handler(firstHandler, end, firstHandler.endPc);\r\n        }\r\n    } else if (rangeEnd >= handlerEnd) {\r\n        // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[\r\n        return new Handler(firstHandler, firstHandler.startPc, start);\r\n    } else {\r\n        // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ =\r\n        //     [handlerStart,rangeStart[ + [rangeEnd,handerEnd[\r\n        firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc);\r\n        return new Handler(firstHandler, firstHandler.startPc, start);\r\n    }\r\n}",
    "comment": "\n   * Removes the range between start and end from the Handler list that begins with the given\n   * element.\n   *\n   * @param firstHandler the beginning of a Handler list. May be {@literal null}.\n   * @param start the start of the range to be removed.\n   * @param end the end of the range to be removed. Maybe {@literal null}.\n   * @return the exception handler list with the start-end range removed.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handler#getExceptionTableLength(Handler)",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of elements of the Handler list that begins with the given element.\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @return the number of elements of the Handler list that begins with 'handler'.\r\n */\r\nstatic int getExceptionTableLength(final Handler firstHandler) {\r\n    int length = 0;\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        length++;\r\n        handler = handler.nextHandler;\r\n    }\r\n    return length;\r\n}",
    "comment": "\n   * Returns the number of elements of the Handler list that begins with the given element.\n   *\n   * @param firstHandler the beginning of a Handler list. May be {@literal null}.\n   * @return the number of elements of the Handler list that begins with 'handler'.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handler#getExceptionTableSize(Handler)",
    "entityType": "method",
    "code": "/**\r\n * Returns the size in bytes of the JVMS exception_table corresponding to the Handler list that\r\n * begins with the given element. <i>This includes the exception_table_length field.</i>\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @return the size in bytes of the exception_table_length and exception_table structures.\r\n */\r\nstatic int getExceptionTableSize(final Handler firstHandler) {\r\n    return 2 + 8 * getExceptionTableLength(firstHandler);\r\n}",
    "comment": "\n   * Returns the size in bytes of the JVMS exception_table corresponding to the Handler list that\n   * begins with the given element. <i>This includes the exception_table_length field.</i>\n   *\n   * @param firstHandler the beginning of a Handler list. May be {@literal null}.\n   * @return the size in bytes of the exception_table_length and exception_table structures.\n   "
  },
  {
    "entityId": "org.springframework.asm.Handler#putExceptionTable(Handler,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the JVMS exception_table corresponding to the Handler list that begins with the given\r\n * element. <i>This includes the exception_table_length field.</i>\r\n *\r\n * @param firstHandler the beginning of a Handler list. May be {@literal null}.\r\n * @param output where the exception_table_length and exception_table structures must be put.\r\n */\r\nstatic void putExceptionTable(final Handler firstHandler, final ByteVector output) {\r\n    output.putShort(getExceptionTableLength(firstHandler));\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        output.putShort(handler.startPc.bytecodeOffset).putShort(handler.endPc.bytecodeOffset).putShort(handler.handlerPc.bytecodeOffset).putShort(handler.catchType);\r\n        handler = handler.nextHandler;\r\n    }\r\n}",
    "comment": "\n   * Puts the JVMS exception_table corresponding to the Handler list that begins with the given\n   * element. <i>This includes the exception_table_length field.</i>\n   *\n   * @param firstHandler the beginning of a Handler list. May be {@literal null}.\n   * @param output where the exception_table_length and exception_table structures must be put.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReaderTests",
    "entityType": "class",
    "code": "private static final String XML = \"<?pi content?><root xmlns='namespace'><prefix:child xmlns:prefix='namespace2'>content</prefix:child></root>\";\nprivate XMLEventStreamReader streamReader;\n@BeforeEach\r\nvoid createStreamReader() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    streamReader = new XMLEventStreamReader(eventReader);\r\n}\n@Test\r\nvoid readAll() throws Exception {\r\n    while (streamReader.hasNext()) {\r\n        streamReader.next();\r\n    }\r\n}\n@Test\r\nvoid readCorrect() throws Exception {\r\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\r\n    StAXSource source = new StAXSource(streamReader);\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    Predicate<Node> nodeFilter = n -> n.getNodeType() != Node.DOCUMENT_TYPE_NODE && n.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE;\r\n    assertThat(XmlContent.from(writer)).isSimilarTo(XML, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReaderTests#createStreamReader()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid createStreamReader() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    streamReader = new XMLEventStreamReader(eventReader);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReaderTests#readAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid readAll() throws Exception {\r\n    while (streamReader.hasNext()) {\r\n        streamReader.next();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamReaderTests#readCorrect()",
    "entityType": "method",
    "code": "@Test\r\nvoid readCorrect() throws Exception {\r\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\r\n    StAXSource source = new StAXSource(streamReader);\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    Predicate<Node> nodeFilter = n -> n.getNodeType() != Node.DOCUMENT_TYPE_NODE && n.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE;\r\n    assertThat(XmlContent.from(writer)).isSimilarTo(XML, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Label",
    "entityType": "class",
    "code": "/**\r\n * A flag indicating that a label is only used for debug attributes. Such a label is not the start\r\n * of a basic block, the target of a jump instruction, or an exception handler. It can be safely\r\n * ignored in control flow graph analysis algorithms (for optimization purposes).\r\n */\r\nstatic final int FLAG_DEBUG_ONLY = 1;\n/**\r\n * A flag indicating that a label is the target of a jump instruction, or the start of an\r\n * exception handler.\r\n */\r\nstatic final int FLAG_JUMP_TARGET = 2;\n/**\r\n * A flag indicating that the bytecode offset of a label is known.\r\n */\r\nstatic final int FLAG_RESOLVED = 4;\n/**\r\n * A flag indicating that a label corresponds to a reachable basic block.\r\n */\r\nstatic final int FLAG_REACHABLE = 8;\n/**\r\n * A flag indicating that the basic block corresponding to a label ends with a subroutine call. By\r\n * construction in {@link MethodWriter#visitJumpInsn}, labels with this flag set have at least two\r\n * outgoing edges:\r\n *\r\n * <ul>\r\n *   <li>the first one corresponds to the instruction that follows the jsr instruction in the\r\n *       bytecode, i.e. where execution continues when it returns from the jsr call. This is a\r\n *       virtual control flow edge, since execution never goes directly from the jsr to the next\r\n *       instruction. Instead, it goes to the subroutine and eventually returns to the instruction\r\n *       following the jsr. This virtual edge is used to compute the real outgoing edges of the\r\n *       basic blocks ending with a ret instruction, in {@link #addSubroutineRetSuccessors}.\r\n *   <li>the second one corresponds to the target of the jsr instruction,\r\n * </ul>\r\n */\r\nstatic final int FLAG_SUBROUTINE_CALLER = 16;\n/**\r\n * A flag indicating that the basic block corresponding to a label is the start of a subroutine.\r\n */\r\nstatic final int FLAG_SUBROUTINE_START = 32;\n/**\r\n * A flag indicating that the basic block corresponding to a label is the end of a subroutine.\r\n */\r\nstatic final int FLAG_SUBROUTINE_END = 64;\n/**\r\n * A flag indicating that this label has at least one associated line number.\r\n */\r\nstatic final int FLAG_LINE_NUMBER = 128;\n/**\r\n * The number of elements to add to the {@link #otherLineNumbers} array when it needs to be\r\n * resized to store a new source line number.\r\n */\r\nstatic final int LINE_NUMBERS_CAPACITY_INCREMENT = 4;\n/**\r\n * The number of elements to add to the {@link #forwardReferences} array when it needs to be\r\n * resized to store a new forward reference.\r\n */\r\nstatic final int FORWARD_REFERENCES_CAPACITY_INCREMENT = 6;\n/**\r\n * The bit mask to extract the type of a forward reference to this label. The extracted type is\r\n * either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link #FORWARD_REFERENCE_TYPE_WIDE}.\r\n *\r\n * @see #forwardReferences\r\n */\r\nstatic final int FORWARD_REFERENCE_TYPE_MASK = 0xF0000000;\n/**\r\n * The type of forward references stored with two bytes in the bytecode. This is the case, for\r\n * instance, of a forward reference from an ifnull instruction.\r\n */\r\nstatic final int FORWARD_REFERENCE_TYPE_SHORT = 0x10000000;\n/**\r\n * The type of forward references stored in four bytes in the bytecode. This is the case, for\r\n * instance, of a forward reference from a lookupswitch instruction.\r\n */\r\nstatic final int FORWARD_REFERENCE_TYPE_WIDE = 0x20000000;\n/**\r\n * The type of forward references stored in two bytes in the <i>stack map table</i>. This is the\r\n * case of the labels of {@link Frame#ITEM_UNINITIALIZED} stack map frame elements, when the NEW\r\n * instruction is after the &lt;init&gt; constructor call (in bytecode offset order).\r\n */\r\nstatic final int FORWARD_REFERENCE_TYPE_STACK_MAP = 0x30000000;\n/**\r\n * The bit mask to extract the 'handle' of a forward reference to this label. The extracted handle\r\n * is the bytecode offset where the forward reference value is stored (using either 2 or 4 bytes,\r\n * as indicated by the {@link #FORWARD_REFERENCE_TYPE_MASK}).\r\n *\r\n * @see #forwardReferences\r\n */\r\nstatic final int FORWARD_REFERENCE_HANDLE_MASK = 0x0FFFFFFF;\n/**\r\n * A sentinel element used to indicate the end of a list of labels.\r\n *\r\n * @see #nextListElement\r\n */\r\nstatic final Label EMPTY_LIST = new Label();\n/**\r\n * A user managed state associated with this label. Warning: this field is used by the ASM tree\r\n * package. In order to use it with the ASM tree package you must override the getLabelNode method\r\n * in MethodNode.\r\n */\r\npublic Object info;\n/**\r\n * The type and status of this label or its corresponding basic block. Must be zero or more of\r\n * {@link #FLAG_DEBUG_ONLY}, {@link #FLAG_JUMP_TARGET}, {@link #FLAG_RESOLVED}, {@link\r\n * #FLAG_REACHABLE}, {@link #FLAG_SUBROUTINE_CALLER}, {@link #FLAG_SUBROUTINE_START}, {@link\r\n * #FLAG_SUBROUTINE_END}.\r\n */\r\nshort flags;\n/**\r\n * The source line number corresponding to this label, if {@link #FLAG_LINE_NUMBER} is set. If\r\n * there are several source line numbers corresponding to this label, the first one is stored in\r\n * this field, and the remaining ones are stored in {@link #otherLineNumbers}.\r\n */\r\nprivate short lineNumber;\n/**\r\n * The source line numbers corresponding to this label, in addition to {@link #lineNumber}, or\r\n * null. The first element of this array is the number n of source line numbers it contains, which\r\n * are stored between indices 1 and n (inclusive).\r\n */\r\nprivate int[] otherLineNumbers;\n/**\r\n * The offset of this label in the bytecode of its method, in bytes. This value is set if and only\r\n * if the {@link #FLAG_RESOLVED} flag is set.\r\n */\r\nint bytecodeOffset;\n/**\r\n * The forward references to this label. The first element is the number of forward references,\r\n * times 2 (this corresponds to the index of the last element actually used in this array). Then,\r\n * each forward reference is described with two consecutive integers noted\r\n * 'sourceInsnBytecodeOffset' and 'reference':\r\n *\r\n * <ul>\r\n *   <li>'sourceInsnBytecodeOffset' is the bytecode offset of the instruction that contains the\r\n *       forward reference,\r\n *   <li>'reference' contains the type and the offset in the bytecode where the forward reference\r\n *       value must be stored, which can be extracted with {@link #FORWARD_REFERENCE_TYPE_MASK}\r\n *       and {@link #FORWARD_REFERENCE_HANDLE_MASK}.\r\n * </ul>\r\n *\r\n * <p>For instance, for an ifnull instruction at bytecode offset x, 'sourceInsnBytecodeOffset' is\r\n * equal to x, and 'reference' is of type {@link #FORWARD_REFERENCE_TYPE_SHORT} with value x + 1\r\n * (because the ifnull instruction uses a 2 bytes bytecode offset operand stored one byte after\r\n * the start of the instruction itself). For the default case of a lookupswitch instruction at\r\n * bytecode offset x, 'sourceInsnBytecodeOffset' is equal to x, and 'reference' is of type {@link\r\n * #FORWARD_REFERENCE_TYPE_WIDE} with value between x + 1 and x + 4 (because the lookupswitch\r\n * instruction uses a 4 bytes bytecode offset operand stored one to four bytes after the start of\r\n * the instruction itself).\r\n */\r\nprivate int[] forwardReferences;\n// -----------------------------------------------------------------------------------------------\r\n// Fields for the control flow and data flow graph analysis algorithms (used to compute the\r\n// maximum stack size or the stack map frames). A control flow graph contains one node per \"basic\r\n// block\", and one edge per \"jump\" from one basic block to another. Each node (i.e., each basic\r\n// block) is represented with the Label object that corresponds to the first instruction of this\r\n// basic block. Each node also stores the list of its successors in the graph, as a linked list of\r\n// Edge objects.\r\n//\r\n// The control flow analysis algorithms used to compute the maximum stack size or the stack map\r\n// frames are similar and use two steps. The first step, during the visit of each instruction,\r\n// builds information about the state of the local variables and the operand stack at the end of\r\n// each basic block, called the \"output frame\", <i>relatively</i> to the frame state at the\r\n// beginning of the basic block, which is called the \"input frame\", and which is <i>unknown</i>\r\n// during this step. The second step, in {@link MethodWriter#computeAllFrames} and {@link\r\n// MethodWriter#computeMaxStackAndLocal}, is a fix point algorithm\r\n// that computes information about the input frame of each basic block, from the input state of\r\n// the first basic block (known from the method signature), and by the using the previously\r\n// computed relative output frames.\r\n//\r\n// The algorithm used to compute the maximum stack size only computes the relative output and\r\n// absolute input stack heights, while the algorithm used to compute stack map frames computes\r\n// relative output frames and absolute input frames.\r\n/**\r\n * The number of elements in the input stack of the basic block corresponding to this label. This\r\n * field is computed in {@link MethodWriter#computeMaxStackAndLocal}.\r\n */\r\nshort inputStackSize;\n/**\r\n * The number of elements in the output stack, at the end of the basic block corresponding to this\r\n * label. This field is only computed for basic blocks that end with a RET instruction.\r\n */\r\nshort outputStackSize;\n/**\r\n * The maximum height reached by the output stack, relatively to the top of the input stack, in\r\n * the basic block corresponding to this label. This maximum is always positive or {@literal\r\n * null}.\r\n */\r\nshort outputStackMax;\n/**\r\n * The id of the subroutine to which this basic block belongs, or 0. If the basic block belongs to\r\n * several subroutines, this is the id of the \"oldest\" subroutine that contains it (with the\r\n * convention that a subroutine calling another one is \"older\" than the callee). This field is\r\n * computed in {@link MethodWriter#computeMaxStackAndLocal}, if the method contains JSR\r\n * instructions.\r\n */\r\nshort subroutineId;\n/**\r\n * The input and output stack map frames of the basic block corresponding to this label. This\r\n * field is only used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} or {@link\r\n * MethodWriter#COMPUTE_INSERTED_FRAMES} option is used.\r\n */\r\nFrame frame;\n/**\r\n * The successor of this label, in the order they are visited in {@link MethodVisitor#visitLabel}.\r\n * This linked list does not include labels used for debug info only. If the {@link\r\n * MethodWriter#COMPUTE_ALL_FRAMES} or {@link MethodWriter#COMPUTE_INSERTED_FRAMES} option is used\r\n * then it does not contain either successive labels that denote the same bytecode offset (in this\r\n * case only the first label appears in this list).\r\n */\r\nLabel nextBasicBlock;\n/**\r\n * The outgoing edges of the basic block corresponding to this label, in the control flow graph of\r\n * its method. These edges are stored in a linked list of {@link Edge} objects, linked to each\r\n * other by their {@link Edge#nextEdge} field.\r\n */\r\nEdge outgoingEdges;\n/**\r\n * The next element in the list of labels to which this label belongs, or {@literal null} if it\r\n * does not belong to any list. All lists of labels must end with the {@link #EMPTY_LIST}\r\n * sentinel, in order to ensure that this field is null if and only if this label does not belong\r\n * to a list of labels. Note that there can be several lists of labels at the same time, but that\r\n * a label can belong to at most one list at a time (unless some lists share a common tail, but\r\n * this is not used in practice).\r\n *\r\n * <p>List of labels are used in {@link MethodWriter#computeAllFrames} and {@link\r\n * MethodWriter#computeMaxStackAndLocal} to compute stack map frames and the maximum stack size,\r\n * respectively, as well as in {@link #markSubroutine} and {@link #addSubroutineRetSuccessors} to\r\n * compute the basic blocks belonging to subroutines and their outgoing edges. Outside of these\r\n * methods, this field should be null (this property is a precondition and a postcondition of\r\n * these methods).\r\n */\r\nLabel nextListElement;\n// -----------------------------------------------------------------------------------------------\r\n// Constructor and accessors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new label.\r\n */\r\npublic Label() {\r\n    // Nothing to do.\r\n}\n/**\r\n * Returns the bytecode offset corresponding to this label. This offset is computed from the start\r\n * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is\r\n * normally not needed by class generators or adapters.</i>\r\n *\r\n * @return the bytecode offset corresponding to this label.\r\n * @throws IllegalStateException if this label is not resolved yet.\r\n */\r\npublic int getOffset() {\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        throw new IllegalStateException(\"Label offset position has not been resolved yet\");\r\n    }\r\n    return bytecodeOffset;\r\n}\n/**\r\n * Returns the \"canonical\" {@link Label} instance corresponding to this label's bytecode offset,\r\n * if known, otherwise the label itself. The canonical instance is the first label (in the order\r\n * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It\r\n * cannot be known for labels which have not been visited yet.\r\n *\r\n * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option\r\n * is used.</i>\r\n *\r\n * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This\r\n *     corresponds to the \"canonical\" label instance described above thanks to the way the label\r\n *     frame is set in {@link MethodWriter#visitLabel}.\r\n */\r\nfinal Label getCanonicalInstance() {\r\n    return frame == null ? this : frame.owner;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods to manage line numbers\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a source line number corresponding to this label.\r\n *\r\n * @param lineNumber a source line number (which should be strictly positive).\r\n */\r\nfinal void addLineNumber(final int lineNumber) {\r\n    if ((flags & FLAG_LINE_NUMBER) == 0) {\r\n        flags |= FLAG_LINE_NUMBER;\r\n        this.lineNumber = (short) lineNumber;\r\n    } else {\r\n        if (otherLineNumbers == null) {\r\n            otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT];\r\n        }\r\n        int otherLineNumberIndex = ++otherLineNumbers[0];\r\n        if (otherLineNumberIndex >= otherLineNumbers.length) {\r\n            int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];\r\n            System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length);\r\n            otherLineNumbers = newLineNumbers;\r\n        }\r\n        otherLineNumbers[otherLineNumberIndex] = lineNumber;\r\n    }\r\n}\n/**\r\n * Makes the given visitor visit this label and its source line numbers, if applicable.\r\n *\r\n * @param methodVisitor a method visitor.\r\n * @param visitLineNumbers whether to visit of the label's source line numbers, if any.\r\n */\r\nfinal void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {\r\n    methodVisitor.visitLabel(this);\r\n    if (visitLineNumbers && (flags & FLAG_LINE_NUMBER) != 0) {\r\n        methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this);\r\n        if (otherLineNumbers != null) {\r\n            for (int i = 1; i <= otherLineNumbers[0]; ++i) {\r\n                methodVisitor.visitLineNumber(otherLineNumbers[i], this);\r\n            }\r\n        }\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods to compute offsets and to manage forward references\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\r\n * is known, the relative bytecode offset between the label and the instruction referencing it is\r\n * computed and written directly. Otherwise, a null relative offset is written and a new forward\r\n * reference is declared for this label.\r\n *\r\n * @param code the bytecode of the method. This is where the reference is appended.\r\n * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\r\n *     reference to be appended.\r\n * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).\r\n */\r\nfinal void put(final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        if (wideReference) {\r\n            addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length);\r\n            code.putInt(-1);\r\n        } else {\r\n            addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length);\r\n            code.putShort(-1);\r\n        }\r\n    } else {\r\n        if (wideReference) {\r\n            code.putInt(bytecodeOffset - sourceInsnBytecodeOffset);\r\n        } else {\r\n            code.putShort(bytecodeOffset - sourceInsnBytecodeOffset);\r\n        }\r\n    }\r\n}\n/**\r\n * Puts a reference to this label in the <i>stack map table</i> of a method. If the bytecode\r\n * offset of the label is known, it is written directly. Otherwise, a null relative offset is\r\n * written and a new forward reference is declared for this label.\r\n *\r\n * @param stackMapTableEntries the stack map table where the label offset must be added.\r\n */\r\nfinal void put(final ByteVector stackMapTableEntries) {\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        addForwardReference(0, FORWARD_REFERENCE_TYPE_STACK_MAP, stackMapTableEntries.length);\r\n    }\r\n    stackMapTableEntries.putShort(bytecodeOffset);\r\n}\n/**\r\n * Adds a forward reference to this label. This method must be called only for a true forward\r\n * reference, i.e. only if this label is not resolved yet. For backward references, the relative\r\n * bytecode offset of the reference can be, and must be, computed and stored directly.\r\n *\r\n * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\r\n *     reference stored at referenceHandle.\r\n * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\r\n *     #FORWARD_REFERENCE_TYPE_WIDE}.\r\n * @param referenceHandle the offset in the bytecode where the forward reference value must be\r\n *     stored.\r\n */\r\nprivate void addForwardReference(final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {\r\n    if (forwardReferences == null) {\r\n        forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n    }\r\n    int lastElementIndex = forwardReferences[0];\r\n    if (lastElementIndex + 2 >= forwardReferences.length) {\r\n        int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n        System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);\r\n        forwardReferences = newValues;\r\n    }\r\n    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;\r\n    forwardReferences[++lastElementIndex] = referenceType | referenceHandle;\r\n    forwardReferences[0] = lastElementIndex;\r\n}\n/**\r\n * Sets the bytecode offset of this label to the given value and resolves the forward references\r\n * to this label, if any. This method must be called when this label is added to the bytecode of\r\n * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\r\n * where left in the bytecode (and optionally in the stack map table) by each forward reference\r\n * previously added to this label.\r\n *\r\n * @param code the bytecode of the method.\r\n * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the\r\n *     method. Maybe {@literal null}.\r\n * @param bytecodeOffset the bytecode offset of this label.\r\n * @return {@literal true} if a blank that was left for this label was too small to store the\r\n *     offset. In such a case the corresponding jump instruction is replaced with an equivalent\r\n *     ASM specific instruction using an unsigned two bytes offset. These ASM specific\r\n *     instructions are later replaced with standard bytecode instructions with wider offsets (4\r\n *     bytes instead of 2), in ClassReader.\r\n */\r\nfinal boolean resolve(final byte[] code, final ByteVector stackMapTableEntries, final int bytecodeOffset) {\r\n    this.flags |= FLAG_RESOLVED;\r\n    this.bytecodeOffset = bytecodeOffset;\r\n    if (forwardReferences == null) {\r\n        return false;\r\n    }\r\n    boolean hasAsmInstructions = false;\r\n    for (int i = forwardReferences[0]; i > 0; i -= 2) {\r\n        final int sourceInsnBytecodeOffset = forwardReferences[i - 1];\r\n        final int reference = forwardReferences[i];\r\n        final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;\r\n        int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;\r\n        if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {\r\n            if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {\r\n                // Change the opcode of the jump instruction, in order to be able to find it later in\r\n                // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except\r\n                // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to\r\n                // 65535, which is sufficient since the size of a method is limited to 65535 bytes).\r\n                int opcode = code[sourceInsnBytecodeOffset] & 0xFF;\r\n                if (opcode < Opcodes.IFNULL) {\r\n                    // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR.\r\n                    code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA);\r\n                } else {\r\n                    // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL.\r\n                    code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA);\r\n                }\r\n                hasAsmInstructions = true;\r\n            }\r\n            code[handle++] = (byte) (relativeOffset >>> 8);\r\n            code[handle] = (byte) relativeOffset;\r\n        } else if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_WIDE) {\r\n            code[handle++] = (byte) (relativeOffset >>> 24);\r\n            code[handle++] = (byte) (relativeOffset >>> 16);\r\n            code[handle++] = (byte) (relativeOffset >>> 8);\r\n            code[handle] = (byte) relativeOffset;\r\n        } else {\r\n            stackMapTableEntries.data[handle++] = (byte) (bytecodeOffset >>> 8);\r\n            stackMapTableEntries.data[handle] = (byte) bytecodeOffset;\r\n        }\r\n    }\r\n    return hasAsmInstructions;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods related to subroutines\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Finds the basic blocks that belong to the subroutine starting with the basic block\r\n * corresponding to this label, and marks these blocks as belonging to this subroutine. This\r\n * method follows the control flow graph to find all the blocks that are reachable from the\r\n * current basic block WITHOUT following any jsr target.\r\n *\r\n * <p>Note: a precondition and postcondition of this method is that all labels must have a null\r\n * {@link #nextListElement}.\r\n *\r\n * @param subroutineId the id of the subroutine starting with the basic block corresponding to\r\n *     this label.\r\n */\r\nfinal void markSubroutine(final short subroutineId) {\r\n    // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks\r\n    // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from\r\n    // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the\r\n    // control flow graph to the list of blocks to process (if not already done).\r\n    Label listOfBlocksToProcess = this;\r\n    listOfBlocksToProcess.nextListElement = EMPTY_LIST;\r\n    while (listOfBlocksToProcess != EMPTY_LIST) {\r\n        // Remove a basic block from the list of blocks to process.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        basicBlock.nextListElement = null;\r\n        // If it is not already marked as belonging to a subroutine, mark it as belonging to\r\n        // subroutineId and add its successors to the list of blocks to process (unless already done).\r\n        if (basicBlock.subroutineId == 0) {\r\n            basicBlock.subroutineId = subroutineId;\r\n            listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);\r\n        }\r\n    }\r\n}\n/**\r\n * Finds the basic blocks that end a subroutine starting with the basic block corresponding to\r\n * this label and, for each one of them, adds an outgoing edge to the basic block following the\r\n * given subroutine call. In other words, completes the control flow graph by adding the edges\r\n * corresponding to the return from this subroutine, when called from the given caller basic\r\n * block.\r\n *\r\n * <p>Note: a precondition and postcondition of this method is that all labels must have a null\r\n * {@link #nextListElement}.\r\n *\r\n * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\r\n *     this label. This label is supposed to correspond to the start of a subroutine.\r\n */\r\nfinal void addSubroutineRetSuccessors(final Label subroutineCaller) {\r\n    // Data flow algorithm: put this basic block in a list blocks to process (which are blocks\r\n    // belonging to a subroutine starting with this label) and, while there are blocks to process,\r\n    // remove one from the list, put it in a list of blocks that have been processed, add a return\r\n    // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks\r\n    // in the control flow graph to the list of blocks to process (if not already done).\r\n    Label listOfProcessedBlocks = EMPTY_LIST;\r\n    Label listOfBlocksToProcess = this;\r\n    listOfBlocksToProcess.nextListElement = EMPTY_LIST;\r\n    while (listOfBlocksToProcess != EMPTY_LIST) {\r\n        // Move a basic block from the list of blocks to process to the list of processed blocks.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = basicBlock.nextListElement;\r\n        basicBlock.nextListElement = listOfProcessedBlocks;\r\n        listOfProcessedBlocks = basicBlock;\r\n        // Add an edge from this block to the successor of the caller basic block, if this block is\r\n        // the end of a subroutine and if this block and subroutineCaller do not belong to the same\r\n        // subroutine.\r\n        if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) {\r\n            basicBlock.outgoingEdges = new Edge(basicBlock.outputStackSize, // By construction, the first outgoing edge of a basic block that ends with a jsr\r\n            // instruction leads to the jsr continuation block, i.e. where execution continues\r\n            // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}).\r\n            subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges);\r\n        }\r\n        // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does\r\n        // not push basic blocks which are already in a list. Here this means either in the list of\r\n        // blocks to process, or in the list of already processed blocks. This second list is\r\n        // important to make sure we don't reprocess an already processed block.\r\n        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);\r\n    }\r\n    // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null,\r\n    // so that this method can be called again with a different subroutine or subroutine caller.\r\n    while (listOfProcessedBlocks != EMPTY_LIST) {\r\n        Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement;\r\n        listOfProcessedBlocks.nextListElement = null;\r\n        listOfProcessedBlocks = newListOfProcessedBlocks;\r\n    }\r\n}\n/**\r\n * Adds the successors of this label in the method's control flow graph (except those\r\n * corresponding to a jsr target, and those already in a list of labels) to the given list of\r\n * blocks to process, and returns the new list.\r\n *\r\n * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their\r\n *     {@link #nextListElement} field.\r\n * @return the new list of blocks to process.\r\n */\r\nprivate Label pushSuccessors(final Label listOfLabelsToProcess) {\r\n    Label newListOfLabelsToProcess = listOfLabelsToProcess;\r\n    Edge outgoingEdge = outgoingEdges;\r\n    while (outgoingEdge != null) {\r\n        // By construction, the second outgoing edge of a basic block that ends with a jsr instruction\r\n        // leads to the jsr target (see {@link #FLAG_SUBROUTINE_CALLER}).\r\n        boolean isJsrTarget = (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge;\r\n        if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {\r\n            // Add this successor to the list of blocks to process, if it does not already belong to a\r\n            // list of labels.\r\n            outgoingEdge.successor.nextListElement = newListOfLabelsToProcess;\r\n            newListOfLabelsToProcess = outgoingEdge.successor;\r\n        }\r\n        outgoingEdge = outgoingEdge.nextEdge;\r\n    }\r\n    return newListOfLabelsToProcess;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Overridden Object methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns a string representation of this label.\r\n *\r\n * @return a string representation of this label.\r\n */\r\n@Override\r\npublic String toString() {\r\n    return \"L\" + System.identityHashCode(this);\r\n}",
    "comment": "\n * A position in the bytecode of a method. Labels are used for jump, goto, and switch instructions,\n * and for try catch blocks. A label designates the <i>instruction</i> that is just after. Note\n * however that there can be other elements between a label and the instruction it designates (such\n * as other labels, stack map frames, line numbers, etc.).\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.Label#getOffset()",
    "entityType": "method",
    "code": "/**\r\n * Returns the bytecode offset corresponding to this label. This offset is computed from the start\r\n * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is\r\n * normally not needed by class generators or adapters.</i>\r\n *\r\n * @return the bytecode offset corresponding to this label.\r\n * @throws IllegalStateException if this label is not resolved yet.\r\n */\r\npublic int getOffset() {\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        throw new IllegalStateException(\"Label offset position has not been resolved yet\");\r\n    }\r\n    return bytecodeOffset;\r\n}",
    "comment": "\n   * Returns the bytecode offset corresponding to this label. This offset is computed from the start\n   * of the method's bytecode. <i>This method is intended for {@link Attribute} sub classes, and is\n   * normally not needed by class generators or adapters.</i>\n   *\n   * @return the bytecode offset corresponding to this label.\n   * @throws IllegalStateException if this label is not resolved yet.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#getCanonicalInstance()",
    "entityType": "method",
    "code": "/**\r\n * Returns the \"canonical\" {@link Label} instance corresponding to this label's bytecode offset,\r\n * if known, otherwise the label itself. The canonical instance is the first label (in the order\r\n * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It\r\n * cannot be known for labels which have not been visited yet.\r\n *\r\n * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option\r\n * is used.</i>\r\n *\r\n * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This\r\n *     corresponds to the \"canonical\" label instance described above thanks to the way the label\r\n *     frame is set in {@link MethodWriter#visitLabel}.\r\n */\r\nfinal Label getCanonicalInstance() {\r\n    return frame == null ? this : frame.owner;\r\n}",
    "comment": "\n   * Returns the \"canonical\" {@link Label} instance corresponding to this label's bytecode offset,\n   * if known, otherwise the label itself. The canonical instance is the first label (in the order\n   * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It\n   * cannot be known for labels which have not been visited yet.\n   *\n   * <p><i>This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option\n   * is used.</i>\n   *\n   * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This\n   *     corresponds to the \"canonical\" label instance described above thanks to the way the label\n   *     frame is set in {@link MethodWriter#visitLabel}.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#addLineNumber(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods to manage line numbers\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a source line number corresponding to this label.\r\n *\r\n * @param lineNumber a source line number (which should be strictly positive).\r\n */\r\nfinal void addLineNumber(final int lineNumber) {\r\n    if ((flags & FLAG_LINE_NUMBER) == 0) {\r\n        flags |= FLAG_LINE_NUMBER;\r\n        this.lineNumber = (short) lineNumber;\r\n    } else {\r\n        if (otherLineNumbers == null) {\r\n            otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT];\r\n        }\r\n        int otherLineNumberIndex = ++otherLineNumbers[0];\r\n        if (otherLineNumberIndex >= otherLineNumbers.length) {\r\n            int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];\r\n            System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length);\r\n            otherLineNumbers = newLineNumbers;\r\n        }\r\n        otherLineNumbers[otherLineNumberIndex] = lineNumber;\r\n    }\r\n}",
    "comment": "\n   * Adds a source line number corresponding to this label.\n   *\n   * @param lineNumber a source line number (which should be strictly positive).\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#accept(MethodVisitor,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Makes the given visitor visit this label and its source line numbers, if applicable.\r\n *\r\n * @param methodVisitor a method visitor.\r\n * @param visitLineNumbers whether to visit of the label's source line numbers, if any.\r\n */\r\nfinal void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {\r\n    methodVisitor.visitLabel(this);\r\n    if (visitLineNumbers && (flags & FLAG_LINE_NUMBER) != 0) {\r\n        methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this);\r\n        if (otherLineNumbers != null) {\r\n            for (int i = 1; i <= otherLineNumbers[0]; ++i) {\r\n                methodVisitor.visitLineNumber(otherLineNumbers[i], this);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Makes the given visitor visit this label and its source line numbers, if applicable.\n   *\n   * @param methodVisitor a method visitor.\n   * @param visitLineNumbers whether to visit of the label's source line numbers, if any.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#put(ByteVector,int,boolean)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods to compute offsets and to manage forward references\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\r\n * is known, the relative bytecode offset between the label and the instruction referencing it is\r\n * computed and written directly. Otherwise, a null relative offset is written and a new forward\r\n * reference is declared for this label.\r\n *\r\n * @param code the bytecode of the method. This is where the reference is appended.\r\n * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\r\n *     reference to be appended.\r\n * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).\r\n */\r\nfinal void put(final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        if (wideReference) {\r\n            addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length);\r\n            code.putInt(-1);\r\n        } else {\r\n            addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length);\r\n            code.putShort(-1);\r\n        }\r\n    } else {\r\n        if (wideReference) {\r\n            code.putInt(bytecodeOffset - sourceInsnBytecodeOffset);\r\n        } else {\r\n            code.putShort(bytecodeOffset - sourceInsnBytecodeOffset);\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\n   * is known, the relative bytecode offset between the label and the instruction referencing it is\n   * computed and written directly. Otherwise, a null relative offset is written and a new forward\n   * reference is declared for this label.\n   *\n   * @param code the bytecode of the method. This is where the reference is appended.\n   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\n   *     reference to be appended.\n   * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#put(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts a reference to this label in the <i>stack map table</i> of a method. If the bytecode\r\n * offset of the label is known, it is written directly. Otherwise, a null relative offset is\r\n * written and a new forward reference is declared for this label.\r\n *\r\n * @param stackMapTableEntries the stack map table where the label offset must be added.\r\n */\r\nfinal void put(final ByteVector stackMapTableEntries) {\r\n    if ((flags & FLAG_RESOLVED) == 0) {\r\n        addForwardReference(0, FORWARD_REFERENCE_TYPE_STACK_MAP, stackMapTableEntries.length);\r\n    }\r\n    stackMapTableEntries.putShort(bytecodeOffset);\r\n}",
    "comment": "\n   * Puts a reference to this label in the <i>stack map table</i> of a method. If the bytecode\n   * offset of the label is known, it is written directly. Otherwise, a null relative offset is\n   * written and a new forward reference is declared for this label.\n   *\n   * @param stackMapTableEntries the stack map table where the label offset must be added.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#addForwardReference(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a forward reference to this label. This method must be called only for a true forward\r\n * reference, i.e. only if this label is not resolved yet. For backward references, the relative\r\n * bytecode offset of the reference can be, and must be, computed and stored directly.\r\n *\r\n * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\r\n *     reference stored at referenceHandle.\r\n * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\r\n *     #FORWARD_REFERENCE_TYPE_WIDE}.\r\n * @param referenceHandle the offset in the bytecode where the forward reference value must be\r\n *     stored.\r\n */\r\nprivate void addForwardReference(final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {\r\n    if (forwardReferences == null) {\r\n        forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n    }\r\n    int lastElementIndex = forwardReferences[0];\r\n    if (lastElementIndex + 2 >= forwardReferences.length) {\r\n        int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n        System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);\r\n        forwardReferences = newValues;\r\n    }\r\n    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;\r\n    forwardReferences[++lastElementIndex] = referenceType | referenceHandle;\r\n    forwardReferences[0] = lastElementIndex;\r\n}",
    "comment": "\n   * Adds a forward reference to this label. This method must be called only for a true forward\n   * reference, i.e. only if this label is not resolved yet. For backward references, the relative\n   * bytecode offset of the reference can be, and must be, computed and stored directly.\n   *\n   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\n   *     reference stored at referenceHandle.\n   * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\n   *     #FORWARD_REFERENCE_TYPE_WIDE}.\n   * @param referenceHandle the offset in the bytecode where the forward reference value must be\n   *     stored.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#resolve(byte[],ByteVector,int)",
    "entityType": "method",
    "code": "/**\r\n * Sets the bytecode offset of this label to the given value and resolves the forward references\r\n * to this label, if any. This method must be called when this label is added to the bytecode of\r\n * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\r\n * where left in the bytecode (and optionally in the stack map table) by each forward reference\r\n * previously added to this label.\r\n *\r\n * @param code the bytecode of the method.\r\n * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the\r\n *     method. Maybe {@literal null}.\r\n * @param bytecodeOffset the bytecode offset of this label.\r\n * @return {@literal true} if a blank that was left for this label was too small to store the\r\n *     offset. In such a case the corresponding jump instruction is replaced with an equivalent\r\n *     ASM specific instruction using an unsigned two bytes offset. These ASM specific\r\n *     instructions are later replaced with standard bytecode instructions with wider offsets (4\r\n *     bytes instead of 2), in ClassReader.\r\n */\r\nfinal boolean resolve(final byte[] code, final ByteVector stackMapTableEntries, final int bytecodeOffset) {\r\n    this.flags |= FLAG_RESOLVED;\r\n    this.bytecodeOffset = bytecodeOffset;\r\n    if (forwardReferences == null) {\r\n        return false;\r\n    }\r\n    boolean hasAsmInstructions = false;\r\n    for (int i = forwardReferences[0]; i > 0; i -= 2) {\r\n        final int sourceInsnBytecodeOffset = forwardReferences[i - 1];\r\n        final int reference = forwardReferences[i];\r\n        final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;\r\n        int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;\r\n        if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {\r\n            if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) {\r\n                // Change the opcode of the jump instruction, in order to be able to find it later in\r\n                // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except\r\n                // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to\r\n                // 65535, which is sufficient since the size of a method is limited to 65535 bytes).\r\n                int opcode = code[sourceInsnBytecodeOffset] & 0xFF;\r\n                if (opcode < Opcodes.IFNULL) {\r\n                    // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR.\r\n                    code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA);\r\n                } else {\r\n                    // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL.\r\n                    code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA);\r\n                }\r\n                hasAsmInstructions = true;\r\n            }\r\n            code[handle++] = (byte) (relativeOffset >>> 8);\r\n            code[handle] = (byte) relativeOffset;\r\n        } else if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_WIDE) {\r\n            code[handle++] = (byte) (relativeOffset >>> 24);\r\n            code[handle++] = (byte) (relativeOffset >>> 16);\r\n            code[handle++] = (byte) (relativeOffset >>> 8);\r\n            code[handle] = (byte) relativeOffset;\r\n        } else {\r\n            stackMapTableEntries.data[handle++] = (byte) (bytecodeOffset >>> 8);\r\n            stackMapTableEntries.data[handle] = (byte) bytecodeOffset;\r\n        }\r\n    }\r\n    return hasAsmInstructions;\r\n}",
    "comment": "\n   * Sets the bytecode offset of this label to the given value and resolves the forward references\n   * to this label, if any. This method must be called when this label is added to the bytecode of\n   * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\n   * where left in the bytecode (and optionally in the stack map table) by each forward reference\n   * previously added to this label.\n   *\n   * @param code the bytecode of the method.\n   * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the\n   *     method. Maybe {@literal null}.\n   * @param bytecodeOffset the bytecode offset of this label.\n   * @return {@literal true} if a blank that was left for this label was too small to store the\n   *     offset. In such a case the corresponding jump instruction is replaced with an equivalent\n   *     ASM specific instruction using an unsigned two bytes offset. These ASM specific\n   *     instructions are later replaced with standard bytecode instructions with wider offsets (4\n   *     bytes instead of 2), in ClassReader.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#markSubroutine(short)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods related to subroutines\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Finds the basic blocks that belong to the subroutine starting with the basic block\r\n * corresponding to this label, and marks these blocks as belonging to this subroutine. This\r\n * method follows the control flow graph to find all the blocks that are reachable from the\r\n * current basic block WITHOUT following any jsr target.\r\n *\r\n * <p>Note: a precondition and postcondition of this method is that all labels must have a null\r\n * {@link #nextListElement}.\r\n *\r\n * @param subroutineId the id of the subroutine starting with the basic block corresponding to\r\n *     this label.\r\n */\r\nfinal void markSubroutine(final short subroutineId) {\r\n    // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks\r\n    // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from\r\n    // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the\r\n    // control flow graph to the list of blocks to process (if not already done).\r\n    Label listOfBlocksToProcess = this;\r\n    listOfBlocksToProcess.nextListElement = EMPTY_LIST;\r\n    while (listOfBlocksToProcess != EMPTY_LIST) {\r\n        // Remove a basic block from the list of blocks to process.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        basicBlock.nextListElement = null;\r\n        // If it is not already marked as belonging to a subroutine, mark it as belonging to\r\n        // subroutineId and add its successors to the list of blocks to process (unless already done).\r\n        if (basicBlock.subroutineId == 0) {\r\n            basicBlock.subroutineId = subroutineId;\r\n            listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Finds the basic blocks that belong to the subroutine starting with the basic block\n   * corresponding to this label, and marks these blocks as belonging to this subroutine. This\n   * method follows the control flow graph to find all the blocks that are reachable from the\n   * current basic block WITHOUT following any jsr target.\n   *\n   * <p>Note: a precondition and postcondition of this method is that all labels must have a null\n   * {@link #nextListElement}.\n   *\n   * @param subroutineId the id of the subroutine starting with the basic block corresponding to\n   *     this label.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#addSubroutineRetSuccessors(Label)",
    "entityType": "method",
    "code": "/**\r\n * Finds the basic blocks that end a subroutine starting with the basic block corresponding to\r\n * this label and, for each one of them, adds an outgoing edge to the basic block following the\r\n * given subroutine call. In other words, completes the control flow graph by adding the edges\r\n * corresponding to the return from this subroutine, when called from the given caller basic\r\n * block.\r\n *\r\n * <p>Note: a precondition and postcondition of this method is that all labels must have a null\r\n * {@link #nextListElement}.\r\n *\r\n * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\r\n *     this label. This label is supposed to correspond to the start of a subroutine.\r\n */\r\nfinal void addSubroutineRetSuccessors(final Label subroutineCaller) {\r\n    // Data flow algorithm: put this basic block in a list blocks to process (which are blocks\r\n    // belonging to a subroutine starting with this label) and, while there are blocks to process,\r\n    // remove one from the list, put it in a list of blocks that have been processed, add a return\r\n    // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks\r\n    // in the control flow graph to the list of blocks to process (if not already done).\r\n    Label listOfProcessedBlocks = EMPTY_LIST;\r\n    Label listOfBlocksToProcess = this;\r\n    listOfBlocksToProcess.nextListElement = EMPTY_LIST;\r\n    while (listOfBlocksToProcess != EMPTY_LIST) {\r\n        // Move a basic block from the list of blocks to process to the list of processed blocks.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = basicBlock.nextListElement;\r\n        basicBlock.nextListElement = listOfProcessedBlocks;\r\n        listOfProcessedBlocks = basicBlock;\r\n        // Add an edge from this block to the successor of the caller basic block, if this block is\r\n        // the end of a subroutine and if this block and subroutineCaller do not belong to the same\r\n        // subroutine.\r\n        if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) {\r\n            basicBlock.outgoingEdges = new Edge(basicBlock.outputStackSize, // By construction, the first outgoing edge of a basic block that ends with a jsr\r\n            // instruction leads to the jsr continuation block, i.e. where execution continues\r\n            // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}).\r\n            subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges);\r\n        }\r\n        // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does\r\n        // not push basic blocks which are already in a list. Here this means either in the list of\r\n        // blocks to process, or in the list of already processed blocks. This second list is\r\n        // important to make sure we don't reprocess an already processed block.\r\n        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);\r\n    }\r\n    // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null,\r\n    // so that this method can be called again with a different subroutine or subroutine caller.\r\n    while (listOfProcessedBlocks != EMPTY_LIST) {\r\n        Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement;\r\n        listOfProcessedBlocks.nextListElement = null;\r\n        listOfProcessedBlocks = newListOfProcessedBlocks;\r\n    }\r\n}",
    "comment": "\n   * Finds the basic blocks that end a subroutine starting with the basic block corresponding to\n   * this label and, for each one of them, adds an outgoing edge to the basic block following the\n   * given subroutine call. In other words, completes the control flow graph by adding the edges\n   * corresponding to the return from this subroutine, when called from the given caller basic\n   * block.\n   *\n   * <p>Note: a precondition and postcondition of this method is that all labels must have a null\n   * {@link #nextListElement}.\n   *\n   * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\n   *     this label. This label is supposed to correspond to the start of a subroutine.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#pushSuccessors(Label)",
    "entityType": "method",
    "code": "/**\r\n * Adds the successors of this label in the method's control flow graph (except those\r\n * corresponding to a jsr target, and those already in a list of labels) to the given list of\r\n * blocks to process, and returns the new list.\r\n *\r\n * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their\r\n *     {@link #nextListElement} field.\r\n * @return the new list of blocks to process.\r\n */\r\nprivate Label pushSuccessors(final Label listOfLabelsToProcess) {\r\n    Label newListOfLabelsToProcess = listOfLabelsToProcess;\r\n    Edge outgoingEdge = outgoingEdges;\r\n    while (outgoingEdge != null) {\r\n        // By construction, the second outgoing edge of a basic block that ends with a jsr instruction\r\n        // leads to the jsr target (see {@link #FLAG_SUBROUTINE_CALLER}).\r\n        boolean isJsrTarget = (flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && outgoingEdge == outgoingEdges.nextEdge;\r\n        if (!isJsrTarget && outgoingEdge.successor.nextListElement == null) {\r\n            // Add this successor to the list of blocks to process, if it does not already belong to a\r\n            // list of labels.\r\n            outgoingEdge.successor.nextListElement = newListOfLabelsToProcess;\r\n            newListOfLabelsToProcess = outgoingEdge.successor;\r\n        }\r\n        outgoingEdge = outgoingEdge.nextEdge;\r\n    }\r\n    return newListOfLabelsToProcess;\r\n}",
    "comment": "\n   * Adds the successors of this label in the method's control flow graph (except those\n   * corresponding to a jsr target, and those already in a list of labels) to the given list of\n   * blocks to process, and returns the new list.\n   *\n   * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their\n   *     {@link #nextListElement} field.\n   * @return the new list of blocks to process.\n   "
  },
  {
    "entityId": "org.springframework.asm.Label#toString()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Overridden Object methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns a string representation of this label.\r\n *\r\n * @return a string representation of this label.\r\n */\r\n@Override\r\npublic String toString() {\r\n    return \"L\" + System.identityHashCode(this);\r\n}",
    "comment": "\n   * Returns a string representation of this label.\n   *\n   * @return a string representation of this label.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamWriterTests",
    "entityType": "class",
    "code": "private static final String XML = \"<?pi content?><root xmlns='namespace'><prefix:child xmlns:prefix='namespace2'><!--comment-->content</prefix:child></root>\";\nprivate XMLEventStreamWriter streamWriter;\nprivate StringWriter stringWriter;\n@BeforeEach\r\nvoid createStreamReader() throws Exception {\r\n    stringWriter = new StringWriter();\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\r\n    XMLEventWriter eventWriter = outputFactory.createXMLEventWriter(stringWriter);\r\n    streamWriter = new XMLEventStreamWriter(eventWriter, XMLEventFactory.newInstance());\r\n}\n@Test\r\nvoid write() throws Exception {\r\n    streamWriter.writeStartDocument();\r\n    streamWriter.writeProcessingInstruction(\"pi\", \"content\");\r\n    streamWriter.writeStartElement(\"namespace\", \"root\");\r\n    streamWriter.writeDefaultNamespace(\"namespace\");\r\n    streamWriter.writeStartElement(\"prefix\", \"child\", \"namespace2\");\r\n    streamWriter.writeNamespace(\"prefix\", \"namespace2\");\r\n    streamWriter.writeComment(\"comment\");\r\n    streamWriter.writeCharacters(\"content\");\r\n    streamWriter.writeEndElement();\r\n    streamWriter.writeEndElement();\r\n    streamWriter.writeEndDocument();\r\n    Predicate<Node> nodeFilter = n -> n.getNodeType() != Node.DOCUMENT_TYPE_NODE && n.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE;\r\n    assertThat(XmlContent.from(stringWriter)).isSimilarTo(XML, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamWriterTests#createStreamReader()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid createStreamReader() throws Exception {\r\n    stringWriter = new StringWriter();\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();\r\n    XMLEventWriter eventWriter = outputFactory.createXMLEventWriter(stringWriter);\r\n    streamWriter = new XMLEventStreamWriter(eventWriter, XMLEventFactory.newInstance());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XMLEventStreamWriterTests#write()",
    "entityType": "method",
    "code": "@Test\r\nvoid write() throws Exception {\r\n    streamWriter.writeStartDocument();\r\n    streamWriter.writeProcessingInstruction(\"pi\", \"content\");\r\n    streamWriter.writeStartElement(\"namespace\", \"root\");\r\n    streamWriter.writeDefaultNamespace(\"namespace\");\r\n    streamWriter.writeStartElement(\"prefix\", \"child\", \"namespace2\");\r\n    streamWriter.writeNamespace(\"prefix\", \"namespace2\");\r\n    streamWriter.writeComment(\"comment\");\r\n    streamWriter.writeCharacters(\"content\");\r\n    streamWriter.writeEndElement();\r\n    streamWriter.writeEndElement();\r\n    streamWriter.writeEndDocument();\r\n    Predicate<Node> nodeFilter = n -> n.getNodeType() != Node.DOCUMENT_TYPE_NODE && n.getNodeType() != Node.PROCESSING_INSTRUCTION_NODE;\r\n    assertThat(XmlContent.from(stringWriter)).isSimilarTo(XML, nodeFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodTooLargeException",
    "entityType": "class",
    "code": "private static final long serialVersionUID = 6807380416709738314L;\nprivate final String className;\nprivate final String methodName;\nprivate final String descriptor;\nprivate final int codeSize;\n/**\r\n * Constructs a new {@link MethodTooLargeException}.\r\n *\r\n * @param className the internal name of the owner class (see {@link Type#getInternalName()}).\r\n * @param methodName the name of the method.\r\n * @param descriptor the descriptor of the method.\r\n * @param codeSize the size of the method's Code attribute, in bytes.\r\n */\r\npublic MethodTooLargeException(final String className, final String methodName, final String descriptor, final int codeSize) {\r\n    super(\"Method too large: \" + className + \".\" + methodName + \" \" + descriptor);\r\n    this.className = className;\r\n    this.methodName = methodName;\r\n    this.descriptor = descriptor;\r\n    this.codeSize = codeSize;\r\n}\n/**\r\n * Returns the internal name of the owner class.\r\n *\r\n * @return the internal name of the owner class (see {@link Type#getInternalName()}).\r\n */\r\npublic String getClassName() {\r\n    return className;\r\n}\n/**\r\n * Returns the name of the method.\r\n *\r\n * @return the name of the method.\r\n */\r\npublic String getMethodName() {\r\n    return methodName;\r\n}\n/**\r\n * Returns the descriptor of the method.\r\n *\r\n * @return the descriptor of the method.\r\n */\r\npublic String getDescriptor() {\r\n    return descriptor;\r\n}\n/**\r\n * Returns the size of the method's Code attribute, in bytes.\r\n *\r\n * @return the size of the method's Code attribute, in bytes.\r\n */\r\npublic int getCodeSize() {\r\n    return codeSize;\r\n}",
    "comment": "\n * Exception thrown when the Code attribute of a method produced by a {@link ClassWriter} is too\n * large.\n *\n * @author Jason Zaugg\n "
  },
  {
    "entityId": "org.springframework.asm.MethodTooLargeException#getClassName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the owner class.\r\n *\r\n * @return the internal name of the owner class (see {@link Type#getInternalName()}).\r\n */\r\npublic String getClassName() {\r\n    return className;\r\n}",
    "comment": "\n   * Returns the internal name of the owner class.\n   *\n   * @return the internal name of the owner class (see {@link Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodTooLargeException#getMethodName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the name of the method.\r\n *\r\n * @return the name of the method.\r\n */\r\npublic String getMethodName() {\r\n    return methodName;\r\n}",
    "comment": "\n   * Returns the name of the method.\n   *\n   * @return the name of the method.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodTooLargeException#getDescriptor()",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor of the method.\r\n *\r\n * @return the descriptor of the method.\r\n */\r\npublic String getDescriptor() {\r\n    return descriptor;\r\n}",
    "comment": "\n   * Returns the descriptor of the method.\n   *\n   * @return the descriptor of the method.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodTooLargeException#getCodeSize()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size of the method's Code attribute, in bytes.\r\n *\r\n * @return the size of the method's Code attribute, in bytes.\r\n */\r\npublic int getCodeSize() {\r\n    return codeSize;\r\n}",
    "comment": "\n   * Returns the size of the method's Code attribute, in bytes.\n   *\n   * @return the size of the method's Code attribute, in bytes.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.XmlValidationModeDetectorTests",
    "entityType": "class",
    "code": "private final XmlValidationModeDetector xmlValidationModeDetector = new XmlValidationModeDetector();\n@ParameterizedTest\r\n@ValueSource(strings = { \"dtdWithNoComments.xml\", \"dtdWithLeadingComment.xml\", \"dtdWithTrailingComment.xml\", \"dtdWithTrailingCommentAcrossMultipleLines.xml\", \"dtdWithCommentOnNextLine.xml\", \"dtdWithMultipleComments.xml\" })\r\nvoid dtdDetection(String fileName) throws Exception {\r\n    assertValidationMode(fileName, VALIDATION_DTD);\r\n}\n@ParameterizedTest\r\n@ValueSource(strings = { \"xsdWithNoComments.xml\", \"xsdWithMultipleComments.xml\", \"xsdWithDoctypeInComment.xml\", \"xsdWithDoctypeInOpenCommentWithAdditionalCommentOnSameLine.xml\" })\r\nvoid xsdDetection(String fileName) throws Exception {\r\n    assertValidationMode(fileName, VALIDATION_XSD);\r\n}\nprivate void assertValidationMode(String fileName, int expectedValidationMode) throws IOException {\r\n    try (InputStream inputStream = getClass().getResourceAsStream(fileName)) {\r\n        assertThat(xmlValidationModeDetector.detectValidationMode(inputStream)).as(\"Validation Mode\").isEqualTo(expectedValidationMode);\r\n    }\r\n}",
    "comment": "\n * Tests for {@link XmlValidationModeDetector}.\n *\n * @author Sam Brannen\n * @since 5.1.10\n "
  },
  {
    "entityId": "org.springframework.util.xml.XmlValidationModeDetectorTests#dtdDetection(String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@ValueSource(strings = { \"dtdWithNoComments.xml\", \"dtdWithLeadingComment.xml\", \"dtdWithTrailingComment.xml\", \"dtdWithTrailingCommentAcrossMultipleLines.xml\", \"dtdWithCommentOnNextLine.xml\", \"dtdWithMultipleComments.xml\" })\r\nvoid dtdDetection(String fileName) throws Exception {\r\n    assertValidationMode(fileName, VALIDATION_DTD);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XmlValidationModeDetectorTests#xsdDetection(String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@ValueSource(strings = { \"xsdWithNoComments.xml\", \"xsdWithMultipleComments.xml\", \"xsdWithDoctypeInComment.xml\", \"xsdWithDoctypeInOpenCommentWithAdditionalCommentOnSameLine.xml\" })\r\nvoid xsdDetection(String fileName) throws Exception {\r\n    assertValidationMode(fileName, VALIDATION_XSD);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.XmlValidationModeDetectorTests#assertValidationMode(String,int)",
    "entityType": "method",
    "code": "private void assertValidationMode(String fileName, int expectedValidationMode) throws IOException {\r\n    try (InputStream inputStream = getClass().getResourceAsStream(fileName)) {\r\n        assertThat(xmlValidationModeDetector.detectValidationMode(inputStream)).as(\"Validation Mode\").isEqualTo(expectedValidationMode);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.VirtualThreadTaskExecutorTests",
    "entityType": "class",
    "code": "@Test\r\nvoid virtualThreadsWithoutName() {\r\n    final Object monitor = new Object();\r\n    VirtualThreadTaskExecutor executor = new VirtualThreadTaskExecutor();\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).isEmpty();\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}\n@Test\r\nvoid virtualThreadsWithNamePrefix() {\r\n    final Object monitor = new Object();\r\n    VirtualThreadTaskExecutor executor = new VirtualThreadTaskExecutor(\"test-\");\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).isEqualTo(\"test-0\");\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}\n@Test\r\nvoid simpleWithVirtualThreadFactory() {\r\n    final Object monitor = new Object();\r\n    SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(Thread.ofVirtual().name(\"test\").factory());\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).isEqualTo(\"test\");\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}\n@Test\r\nvoid simpleWithVirtualThreadFlag() {\r\n    final String customPrefix = \"chankPop#\";\r\n    final Object monitor = new Object();\r\n    SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(customPrefix);\r\n    executor.setVirtualThreads(true);\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).startsWith(customPrefix);\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}\nprivate void executeAndWait(TaskExecutor executor, Runnable task, Object monitor) {\r\n    synchronized (monitor) {\r\n        executor.execute(task);\r\n        try {\r\n            monitor.wait();\r\n        } catch (InterruptedException ignored) ;\r\n    }\r\n}\nprivate static final class NoOpRunnable implements Runnable {\r\n\r\n    @Override\r\n    public void run() {\r\n        // no-op\r\n    }\r\n}\nprivate abstract static class AbstractNotifyingRunnable implements Runnable {\r\n\r\n    private final Object monitor;\r\n\r\n    protected AbstractNotifyingRunnable(Object monitor) {\r\n        this.monitor = monitor;\r\n    }\r\n\r\n    @Override\r\n    public final void run() {\r\n        synchronized (this.monitor) {\r\n            try {\r\n                doRun();\r\n            } finally {\r\n                this.monitor.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    protected abstract void doRun();\r\n}\nprivate static final class ThreadNameHarvester extends AbstractNotifyingRunnable {\r\n\r\n    private final AtomicInteger runCount = new AtomicInteger();\r\n\r\n    private String threadName;\r\n\r\n    private boolean virtual;\r\n\r\n    protected ThreadNameHarvester(Object monitor) {\r\n        super(monitor);\r\n    }\r\n\r\n    public String getThreadName() {\r\n        return this.threadName;\r\n    }\r\n\r\n    public boolean isVirtual() {\r\n        return this.virtual;\r\n    }\r\n\r\n    public int runCount() {\r\n        return this.runCount.get();\r\n    }\r\n\r\n    @Override\r\n    protected void doRun() {\r\n        Thread thread = Thread.currentThread();\r\n        this.threadName = thread.getName();\r\n        this.virtual = thread.isVirtual();\r\n        runCount.incrementAndGet();\r\n    }\r\n}",
    "comment": "\n * @author Juergen Hoeller\n * @since 6.1\n "
  },
  {
    "entityId": "org.springframework.core.task.VirtualThreadTaskExecutorTests#virtualThreadsWithoutName()",
    "entityType": "method",
    "code": "@Test\r\nvoid virtualThreadsWithoutName() {\r\n    final Object monitor = new Object();\r\n    VirtualThreadTaskExecutor executor = new VirtualThreadTaskExecutor();\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).isEmpty();\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.VirtualThreadTaskExecutorTests#virtualThreadsWithNamePrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid virtualThreadsWithNamePrefix() {\r\n    final Object monitor = new Object();\r\n    VirtualThreadTaskExecutor executor = new VirtualThreadTaskExecutor(\"test-\");\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).isEqualTo(\"test-0\");\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.VirtualThreadTaskExecutorTests#simpleWithVirtualThreadFactory()",
    "entityType": "method",
    "code": "@Test\r\nvoid simpleWithVirtualThreadFactory() {\r\n    final Object monitor = new Object();\r\n    SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(Thread.ofVirtual().name(\"test\").factory());\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).isEqualTo(\"test\");\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.VirtualThreadTaskExecutorTests#simpleWithVirtualThreadFlag()",
    "entityType": "method",
    "code": "@Test\r\nvoid simpleWithVirtualThreadFlag() {\r\n    final String customPrefix = \"chankPop#\";\r\n    final Object monitor = new Object();\r\n    SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(customPrefix);\r\n    executor.setVirtualThreads(true);\r\n    ThreadNameHarvester task = new ThreadNameHarvester(monitor);\r\n    executeAndWait(executor, task, monitor);\r\n    assertThat(task.getThreadName()).startsWith(customPrefix);\r\n    assertThat(task.isVirtual()).isTrue();\r\n    assertThat(task.runCount()).isOne();\r\n}",
    "comment": ""
  }
]