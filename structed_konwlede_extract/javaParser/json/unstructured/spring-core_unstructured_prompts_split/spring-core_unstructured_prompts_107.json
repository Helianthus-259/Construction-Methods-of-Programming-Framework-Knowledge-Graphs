[
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    // TransactionalClass is NOT annotated or meta-annotated with @Component\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithSubSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithSubSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getSuperClassForAllScenarios()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSuperClassForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isNull();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isNull();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but we should still find it on classes.\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(NonInheritedAnnotationClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getSuperClassSourceForTypesWithSingleCandidateType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSuperClassSourceForTypesWithSingleCandidateType() {\r\n    // no class-level annotation\r\n    List<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class, transactionalCandidateList)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class, transactionalCandidateList)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class, transactionalCandidateList)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class, transactionalCandidateList)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class, transactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class, transactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but should still find it on classes.\r\n    List<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class, orderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class, orderCandidateList)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class, orderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class, orderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getSuperClassSourceForTypesWithMultipleCandidateTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\r\n    List<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\r\n    // no class-level annotation\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class, candidates)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class, candidates)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class, candidates)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class, candidates)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class, candidates)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class, candidates)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClassForTypes() should still find it on\r\n    // classes.\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class, candidates)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class, candidates)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class, candidates)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class, candidates)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    // class hierarchy mixed with @Transactional and @Order declarations\r\n    assertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class, candidates)).isEqualTo(TransactionalClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class, candidates)).isEqualTo(TransactionalAndOrderedClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class, candidates)).isEqualTo(TransactionalAndOrderedClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getSuperClassSourceWithTypeIn(Class<?>,List<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "private Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\r\n    return MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent)).map(MergedAnnotation::getSource).findFirst().orElse(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isDirectlyPresentForAllScenarios()",
    "entityType": "method",
    "code": "@Test\r\nvoid isDirectlyPresentForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(Transactional.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).isDirectlyPresent(Transactional.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(Transactional.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(Transactional.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(Order.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).isDirectlyPresent(Order.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(Order.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).isDirectlyPresent(Order.class)).isFalse();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(Order.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).isDirectlyPresent(Order.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(Order.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).isDirectlyPresent(Order.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getAggregateIndexForAllScenarios()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAggregateIndexForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(-1);\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(0);\r\n    // Since we're not traversing interface hierarchies the following,\r\n    // though perhaps counterintuitive, must be false:\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(1);\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(-1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectWithoutAttributeAliases() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectWithNestedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectWithNestedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\r\n    MergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(Arrays.stream(filters).map(filter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectWithAttributeAliases1()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectWithAttributeAliases1() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\r\n    assertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\r\n    assertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectWithAttributeAliases2()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectWithAttributeAliases2() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\r\n    assertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\r\n    assertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectWithAttributeAliasesWithDifferentValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotations.from(method).get(RequestMapping.class)).withMessageContaining(\"attribute 'path' and its alias 'value'\").withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getValueFromAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getValueFromAnnotation() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getInt(\"value\")).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getValueFromNonPublicAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation annotation = declaredAnnotations[0];\r\n    MergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\r\n    assertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDefaultValueFromAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueFromAnnotation() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\r\n    MergedAnnotation<Order> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDefaultValueFromNonPublicAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation declaredAnnotation = declaredAnnotations[0];\r\n    MergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\r\n    assertThat(annotation.getType().getName()).isEqualTo(\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\r\n    assertThat(annotation.getDefaultValue(\"value\")).contains(-1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDefaultValueFromAnnotationType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueFromAnnotationType() {\r\n    MergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\r\n    assertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamRepeatableDeclaredOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableDeclaredOnMethod() throws Exception {\r\n    Method method = InterfaceWithRepeated.class.getMethod(\"foo\");\r\n    Stream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\r\n    Stream<String> values = annotations.map(annotation -> annotation.getString(\"value\"));\r\n    assertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamRepeatableDeclaredOnClassWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\r\n    assertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\r\n    RepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\r\n    MergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class, SearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\r\n    assertThat(annotations.stream(TestConfiguration.class).map(annotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\r\n    assertThat(annotations.stream(TestConfiguration.class).map(annotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamRepeatableDeclaredOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableDeclaredOnClass() {\r\n    Class<?> element = MyRepeatableClass.class;\r\n    String[] expectedValuesJava = { \"A\", \"B\", \"C\" };\r\n    String[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamRepeatableDeclaredOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableDeclaredOnSuperclass() {\r\n    Class<?> element = SubMyRepeatableClass.class;\r\n    String[] expectedValuesJava = { \"A\", \"B\", \"C\" };\r\n    String[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamRepeatableDeclaredOnClassAndSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableDeclaredOnClassAndSuperclass() {\r\n    Class<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    String[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\r\n    String[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamRepeatableDeclaredOnMultipleSuperclasses()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\r\n    Class<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    String[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\r\n    String[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamDirectRepeatablesDeclaredOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamDirectRepeatablesDeclaredOnClass() {\r\n    Class<?> element = MyRepeatableClass.class;\r\n    String[] expectedValuesJava = { \"A\", \"B\", \"C\" };\r\n    String[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\r\n    testRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamDirectRepeatablesDeclaredOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamDirectRepeatablesDeclaredOnSuperclass() {\r\n    Class<?> element = SubMyRepeatableClass.class;\r\n    String[] expectedValuesJava = ;;\r\n    String[] expectedValuesSpring = ;;\r\n    testRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testRepeatables(SearchStrategy,Class<?>,String[],String[])",
    "entityType": "method",
    "code": "private void testRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expectedValuesJava, String[] expectedValuesSpring) {\r\n    testJavaRepeatables(searchStrategy, element, expectedValuesJava);\r\n    testExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\r\n    testStandardRepeatables(searchStrategy, element, expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testJavaRepeatables(SearchStrategy,Class<?>,String[])",
    "entityType": "method",
    "code": "private void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\r\n    MyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ? element.getDeclaredAnnotationsByType(MyRepeatable.class) : element.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testExplicitRepeatables(SearchStrategy,Class<?>,String[])",
    "entityType": "method",
    "code": "private void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\r\n    MergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, RepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class), AnnotationFilter.PLAIN);\r\n    Stream<String> values = annotations.stream(MyRepeatable.class).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(annotation -> annotation.getString(\"value\"));\r\n    assertThat(values).containsExactly(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testStandardRepeatables(SearchStrategy,Class<?>,String[])",
    "entityType": "method",
    "code": "private void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\r\n    Stream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(annotation -> annotation.getString(\"value\"));\r\n    assertThat(values).containsExactly(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Component synthesizedComponent = MergedAnnotation.from(component).synthesize();\r\n    assertThat(synthesizedComponent).isNotNull();\r\n    assertThat(synthesizedComponent).isEqualTo(component);\r\n    assertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizedAnnotationShouldReuseJdkProxyClass()",
    "entityType": "method",
    "code": "/**\r\n * @since 6.0\r\n */\r\n@Test\r\nvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    RequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\r\n    assertThat(jdkRequestMapping).isNotNull();\r\n    assertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\r\n    assertThat(jdkRequestMapping.path()).containsExactly(\"\");\r\n    RequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\r\n    assertSynthesized(synthesizedRequestMapping);\r\n    assertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\r\n    assertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\r\n    assertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\r\n}",
    "comment": "\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeAlreadySynthesized()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAlreadySynthesized() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    RequestMapping webMapping = method.getAnnotation(RequestMapping.class);\r\n    assertThat(webMapping).isNotNull();\r\n    RequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\r\n    RequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\r\n    assertSynthesized(synthesizedWebMapping);\r\n    assertSynthesized(synthesizedAgainWebMapping);\r\n    assertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\r\n    assertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\r\n    assertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\r\n    assertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\r\n    assertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeShouldNotSynthesizeNonsynthesizableAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"getId\");\r\n    Id id = method.getAnnotation(Id.class);\r\n    assertThat(id).isNotNull();\r\n    Id synthesizedId = MergedAnnotation.from(id).synthesize();\r\n    assertThat(id).isEqualTo(synthesizedId);\r\n    // It doesn't make sense to synthesize @Id since it declares zero attributes.\r\n    assertNotSynthesized(synthesizedId);\r\n    assertThat(id).isSameAs(synthesizedId);\r\n    GeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\r\n    assertThat(generatedValue).isNotNull();\r\n    GeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\r\n    assertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\r\n    // It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\r\n    assertNotSynthesized(synthesizedGeneratedValue);\r\n    assertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenUsingMergedAnnotationsFromApi()",
    "entityType": "method",
    "code": "// gh-28716\r\n@Test\r\nvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\r\n    Field directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\r\n    MergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\r\n    RootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\r\n    assertThat(rootAnnotation.flag()).isFalse();\r\n    assertNotSynthesized(rootAnnotation);\r\n    Field metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\r\n    mergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\r\n    rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\r\n    assertThat(rootAnnotation.flag()).isTrue();\r\n    assertSynthesized(rootAnnotation);\r\n    Field metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\r\n    mergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\r\n    rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\r\n    assertThat(rootAnnotation.flag()).isTrue();\r\n    assertSynthesized(rootAnnotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi()",
    "entityType": "method",
    "code": "// gh-28704\r\n@Test\r\nvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\r\n    MergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\r\n    EnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\r\n    assertNotSynthesized(enableWebSecurity);\r\n    EnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\r\n    assertNotSynthesized(enableGlobalAuthentication);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations()",
    "entityType": "method",
    "code": "/**\r\n * If an attempt is made to synthesize an annotation from an annotation instance\r\n * that has already been synthesized, the original synthesized annotation should\r\n * ideally be returned as-is without creating a new proxy instance with the same\r\n * values.\r\n */\r\n@Test\r\nvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    RequestMapping webMapping = method.getAnnotation(RequestMapping.class);\r\n    assertThat(webMapping).isNotNull();\r\n    MergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\r\n    RequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\r\n    assertSynthesized(synthesizedWebMapping1);\r\n    assertSynthesized(synthesizedWebMapping2);\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\r\n    // Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\r\n    assertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\r\n    // Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\r\n    assertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\r\n    RequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\r\n    // Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\r\n    assertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\r\n}",
    "comment": "\n\t * If an attempt is made to synthesize an annotation from an annotation instance\n\t * that has already been synthesized, the original synthesized annotation should\n\t * ideally be returned as-is without creating a new proxy instance with the same\n\t * values.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAliasForIsMissingAttributeDeclaration()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\r\n    AliasForWithMissingAttributeDeclaration annotation = AliasForWithMissingAttributeDeclarationClass.class.getAnnotation(AliasForWithMissingAttributeDeclaration.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\").withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName()).withMessageContaining(\"points to itself\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAliasForHasDuplicateAttributeDeclaration()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\r\n    AliasForWithDuplicateAttributeDeclaration annotation = AliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(AliasForWithDuplicateAttributeDeclaration.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\").withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName()).withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasForNonexistentAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\r\n    AliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(AliasForNonexistentAttribute.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\").withMessageContaining(AliasForNonexistentAttribute.class.getName()).withMessageContaining(\"declares an alias for 'bar' which is not present\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\r\n    AliasForWithMirroredAliasForWrongAttribute annotation = AliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(AliasForWithMirroredAliasForWrongAttribute.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" + AliasForWithMirroredAliasForWrongAttribute.class.getName() + \"] declares an alias for 'quux' which is not present.\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasForAttributeOfDifferentType()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\r\n    AliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(AliasForAttributeOfDifferentType.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"Misconfigured aliases\").withMessageContaining(AliasForAttributeOfDifferentType.class.getName()).withMessageContaining(\"attribute 'foo'\").withMessageContaining(\"attribute 'bar'\").withMessageContaining(\"same return type\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasForWithMissingDefaultValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\r\n    AliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(AliasForWithMissingDefaultValues.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"Misconfigured aliases\").withMessageContaining(AliasForWithMissingDefaultValues.class.getName()).withMessageContaining(\"attribute 'foo' in annotation\").withMessageContaining(\"attribute 'bar' in annotation\").withMessageContaining(\"default values\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\r\n    AliasForAttributeWithDifferentDefaultValue annotation = AliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(AliasForAttributeWithDifferentDefaultValue.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"Misconfigured aliases\").withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName()).withMessageContaining(\"attribute 'foo' in annotation\").withMessageContaining(\"attribute 'bar' in annotation\").withMessageContaining(\"same default value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\r\n    AliasedComposedTestConfigurationNotMetaPresent annotation = AliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(AliasedComposedTestConfigurationNotMetaPresent.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\").withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName()).withMessageContaining(\"declares an alias for attribute 'location' in annotation\").withMessageContaining(TestConfiguration.class.getName()).withMessageContaining(\"not meta-present\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithImplicitAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithImplicitAliases() {\r\n    testSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\r\n    testSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\r\n    testSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\r\n    testSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testSynthesisWithImplicitAliases(Class<?>,String)",
    "entityType": "method",
    "code": "private void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\r\n    ImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\r\n    assertThat(config).isNotNull();\r\n    ImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.value()).isEqualTo(expected);\r\n    assertThat(synthesized.location1()).isEqualTo(expected);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(expected);\r\n    assertThat(synthesized.groovyScript()).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\r\n    testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class, \"value\");\r\n    testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class, \"location\");\r\n    testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class, \"xmlFile\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?>,String)",
    "entityType": "method",
    "code": "private void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\r\n    ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\r\n    assertThat(config).isNotNull();\r\n    ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.value()).isEqualTo(expected);\r\n    assertThat(synthesized.location()).isEqualTo(expected);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithImplicitAliasesForAliasPair()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithImplicitAliasesForAliasPair() {\r\n    ImplicitAliasesForAliasPairTestConfiguration config = ImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(ImplicitAliasesForAliasPairTestConfiguration.class);\r\n    ImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithTransitiveImplicitAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithTransitiveImplicitAliases() {\r\n    TransitiveImplicitAliasesTestConfiguration config = TransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(TransitiveImplicitAliasesTestConfiguration.class);\r\n    TransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.xml()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithTransitiveImplicitAliasesForAliasPair()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\r\n    TransitiveImplicitAliasesForAliasPairTestConfiguration config = TransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(TransitiveImplicitAliasesForAliasPairTestConfiguration.class);\r\n    TransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.xml()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithImplicitAliasesWithMissingDefaultValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\r\n    Class<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType = ImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\r\n    ImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(clazz, config)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"default values\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithImplicitAliasesWithDifferentDefaultValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\r\n    Class<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType = ImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\r\n    ImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(clazz, config)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"same default value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithImplicitAliasesWithDuplicateValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\r\n    Class<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType = ImplicitAliasesWithDuplicateValuesTestConfiguration.class;\r\n    ImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(clazz, config)).withMessageStartingWith(\"Different @AliasFor mirror values for annotation\").withMessageContaining(annotationType.getName()).withMessageContaining(\"declared on class\").withMessageContaining(clazz.getName()).withMessageContaining(\"are declared with values of\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Map<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\r\n    MergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\r\n    Component synthesizedComponent = annotation.synthesize();\r\n    assertSynthesized(synthesizedComponent);\r\n    assertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithNestedMap()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeFromMapWithNestedMap() {\r\n    ComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\r\n    assertThat(componentScan).isNotNull();\r\n    assertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\r\n    Map<String, Object> map = MergedAnnotation.from(componentScan).asMap(annotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\r\n    Map<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\r\n    assertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\r\n    filterMap.put(\"pattern\", \"newFoo\");\r\n    filterMap.put(\"enigma\", 42);\r\n    MergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(ComponentScanSingleFilter.class, map);\r\n    ComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\r\n    assertSynthesized(synthesizedComponentScan);\r\n    assertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithNestedArrayOfMaps()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeFromMapWithNestedArrayOfMaps() {\r\n    ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\r\n    assertThat(componentScan).isNotNull();\r\n    Map<String, Object> map = MergedAnnotation.from(componentScan).asMap(annotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\r\n    Map<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\r\n    List<String> patterns = Arrays.stream(filters).map(m -> (String) m.get(\"pattern\")).toList();\r\n    assertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\r\n    filters[0].put(\"pattern\", \"newFoo\");\r\n    filters[0].put(\"enigma\", 42);\r\n    filters[1].put(\"pattern\", \"newBar\");\r\n    filters[1].put(\"enigma\", 42);\r\n    MergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\r\n    ComponentScan synthesizedComponentScan = annotation.synthesize();\r\n    assertSynthesized(synthesizedComponentScan);\r\n    assertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern)).containsExactly(\"newFoo\", \"newBar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromDefaultsWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromDefaultsWithoutAttributeAliases() {\r\n    MergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\r\n    AnnotationWithDefaults synthesized = annotation.synthesize();\r\n    assertThat(synthesized.text()).isEqualTo(\"enigma\");\r\n    assertThat(synthesized.predicate()).isTrue();\r\n    assertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromDefaultsWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromDefaultsWithAttributeAliases() {\r\n    MergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\r\n    TestConfiguration synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEmpty();\r\n    assertThat(synthesized.location()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWhenAttributeAliasesWithDifferentValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithMinimalAttributesWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\r\n    Map<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\r\n    MergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\r\n    TestConfiguration synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.location()).isEqualTo(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\r\n    synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Collections.singletonMap(\"value\", \"/foo\"));\r\n    synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Collections.singletonMap(\"path\", \"/foo\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String,Object>)",
    "entityType": "method",
    "code": "private void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\r\n    MergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\r\n    GetMapping synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEqualTo(\"/foo\");\r\n    assertThat(synthesized.path()).isEqualTo(\"/foo\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithImplicitAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithImplicitAttributeAliases() {\r\n    testSynthesisFromMapWithImplicitAliases(\"value\");\r\n    testSynthesisFromMapWithImplicitAliases(\"location1\");\r\n    testSynthesisFromMapWithImplicitAliases(\"location2\");\r\n    testSynthesisFromMapWithImplicitAliases(\"location3\");\r\n    testSynthesisFromMapWithImplicitAliases(\"xmlFile\");\r\n    testSynthesisFromMapWithImplicitAliases(\"groovyScript\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testSynthesisFromMapWithImplicitAliases(String)",
    "entityType": "method",
    "code": "private void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\r\n    Map<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\r\n    MergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(ImplicitAliasesTestConfiguration.class, map);\r\n    ImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithMissingAttributeValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithMissingAttributeValue() {\r\n    testMissingTextAttribute(Collections.emptyMap());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithNullAttributeValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithNullAttributeValue() {\r\n    Map<String, Object> map = Collections.singletonMap(\"text\", null);\r\n    assertThat(map).containsKey(\"text\");\r\n    testMissingTextAttribute(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testMissingTextAttribute(Map<String,Object>)",
    "entityType": "method",
    "code": "private void testMissingTextAttribute(Map<String, Object> attributes) {\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() -> MergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text()).withMessage(\"No value found for attribute named 'text' in merged annotation \" + AnnotationWithoutDefaults.class.getCanonicalName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromMapWithAttributeOfIncorrectType()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromMapWithAttributeOfIncorrectType() {\r\n    Map<String, Object> map = Collections.singletonMap(\"value\", 42L);\r\n    MergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\r\n    assertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value()).withMessage(\"Attribute 'value' in annotation \" + \"org.springframework.core.testfixture.stereotype.Component should be \" + \"compatible with java.lang.String but a java.lang.Long value was returned\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeFromAnnotationAttributesWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Map<String, Object> attributes = MergedAnnotation.from(component).asMap();\r\n    Component synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized).isEqualTo(component);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#toStringForSynthesizedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStringForSynthesizedAnnotations() throws Exception {\r\n    Method methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    RequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithAliases).isNotNull();\r\n    Method methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\r\n    RequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\r\n    assertThat(methodWithPathAndValue).isNotNull();\r\n    RequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\r\n    assertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\r\n    // The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\r\n    // should produce almost the same toString() results as synthesized annotations for\r\n    // handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\r\n    // in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\r\n    // we do not test the JDK implementation.\r\n    // assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\r\n    assertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\r\n    assertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#assertToStringForWebMappingWithPathAndValue(RequestMapping)",
    "entityType": "method",
    "code": "private void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\r\n    assertThat(webMapping.toString()).startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\").contains(// Strings\r\n    \"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\", // Characters\r\n    \"ch='X'\", \"chars={'X'}\", // Enums\r\n    \"method={GET, POST}\", // Classes\r\n    \"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\", \"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\", // Bytes\r\n    \"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\", // Shorts\r\n    \"shortValue=9876\", \"shorts={9876}\", // Longs\r\n    \"longValue=42L\", \"longs={42L}\", // Floats\r\n    \"floatValue=3.14f\", \"floats={3.14f}\", // Doubles\r\n    \"doubleValue=99.999d\", \"doubles={99.999d}\").endsWith(\")\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#equalsForSynthesizedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsForSynthesizedAnnotations() throws Exception {\r\n    Method methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    RequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithAliases).isNotNull();\r\n    Method methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\r\n    RequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithPathAndValue).isNotNull();\r\n    RequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\r\n    // Equality amongst standard annotations\r\n    assertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\r\n    assertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\r\n    // Inequality amongst standard annotations\r\n    assertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\r\n    assertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\r\n    // Equality amongst synthesized annotations\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\r\n    assertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\r\n    assertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\r\n    // Equality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\r\n    assertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\r\n    // Inequality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\r\n    assertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#hashCodeForSynthesizedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid hashCodeForSynthesizedAnnotations() throws Exception {\r\n    Method methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    RequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithAliases).isNotNull();\r\n    Method methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\r\n    RequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithPathAndValue).isNotNull();\r\n    RequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\r\n    assertThat(synthesizedWebMapping1).isNotNull();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\r\n    assertThat(synthesizedWebMapping2).isNotNull();\r\n    // Equality amongst standard annotations\r\n    assertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\r\n    assertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\r\n    // Inequality amongst standard annotations\r\n    assertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\r\n    assertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\r\n    // Equality amongst synthesized annotations\r\n    assertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\r\n    assertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\r\n    assertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\r\n    assertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\r\n    // Equality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\r\n    assertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\r\n    // Inequality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\r\n    assertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeNonPublicWithAttributeAliasesFromDifferentPackage()",
    "entityType": "method",
    "code": "/**\r\n * Fully reflection-based test that verifies support for synthesizing\r\n * annotations across packages with non-public visibility of user types\r\n * (for example, a non-public annotation that uses {@code @AliasFor}).\r\n */\r\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\r\n    Class<?> type = ClassUtils.forName(\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\", null);\r\n    Class<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\", null);\r\n    Annotation annotation = type.getAnnotation(annotationType);\r\n    assertThat(annotation).isNotNull();\r\n    MergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\r\n    Annotation synthesizedAnnotation = mergedAnnotation.synthesize();\r\n    assertSynthesized(synthesizedAnnotation);\r\n    assertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\r\n    assertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\r\n}",
    "comment": "\n\t * Fully reflection-based test that verifies support for synthesizing\n\t * annotations across packages with non-public visibility of user types\n\t * (for example, a non-public annotation that uses {@code @AliasFor}).\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithArrayOfAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithArrayOfAnnotations() {\r\n    Hierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\r\n    assertThat(hierarchy).isNotNull();\r\n    Hierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\r\n    assertSynthesized(synthesizedHierarchy);\r\n    TestConfiguration[] configs = synthesizedHierarchy.value();\r\n    assertThat(configs).isNotNull();\r\n    assertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n    assertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\r\n    assertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\r\n    TestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\r\n    assertThat(contextConfig).isNotNull();\r\n    // Alter array returned from synthesized annotation\r\n    configs[0] = contextConfig;\r\n    assertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\r\n    // Re-retrieve the array from the synthesized annotation\r\n    configs = synthesizedHierarchy.value();\r\n    assertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#synthesizeWithArrayOfChars()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithArrayOfChars() {\r\n    CharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\r\n    assertThat(charsContainer).isNotNull();\r\n    CharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\r\n    assertSynthesized(synthesizedCharsContainer);\r\n    char[] chars = synthesizedCharsContainer.chars();\r\n    assertThat(chars).containsExactly('x', 'y', 'z');\r\n    // Alter array returned from synthesized annotation\r\n    chars[0] = '?';\r\n    // Re-retrieve the array from the synthesized annotation\r\n    chars = synthesizedCharsContainer.chars();\r\n    assertThat(chars).containsExactly('x', 'y', 'z');\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getValueWhenHasDefaultOverride()",
    "entityType": "method",
    "code": "@Test\r\nvoid getValueWhenHasDefaultOverride() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class).get(DefaultOverrideRoot.class);\r\n    assertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getValueWhenHasDefaultOverrideWithImplicitAlias()",
    "entityType": "method",
    "code": "// gh-22654\r\n@Test\r\nvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\r\n    MergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class).get(DefaultOverrideRoot.class);\r\n    assertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\r\n    MergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class).get(DefaultOverrideRoot.class);\r\n    assertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getValueWhenHasDefaultOverrideWithExplicitAlias()",
    "entityType": "method",
    "code": "// gh-22654\r\n@Test\r\nvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class).get(DefaultOverrideExplicitAliasRoot.class);\r\n    assertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getValueWhenThreeDeepMetaWithValue()",
    "entityType": "method",
    "code": "// gh-22703\r\n@Test\r\nvoid getValueWhenThreeDeepMetaWithValue() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class).get(ValueAttribute.class);\r\n    assertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#asAnnotationAttributesReturnsPopulatedAnnotationAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class).get(SpringApplicationConfiguration.class);\r\n    AnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\r\n    assertThat(attributes).containsEntry(\"classes\", new String[] { Number.class.getName() });\r\n    assertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getId()",
    "entityType": "method",
    "code": "@Id\r\n@GeneratedValue(strategy = \"AUTO\")\r\nprivate Long getId() {\r\n    return 42L;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#assertSynthesized(Annotation)",
    "entityType": "method",
    "code": "// @formatter:on\r\nstatic void assertSynthesized(Annotation annotation) {\r\n    assertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#assertNotSynthesized(Annotation)",
    "entityType": "method",
    "code": "static void assertNotSynthesized(Annotation annotation) {\r\n    assertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests",
    "entityType": "class",
    "code": "@Test\r\nvoid preconditions() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.search(null)).withMessage(\"SearchStrategy must not be null\");\r\n    Search search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.withEnclosingClasses(null)).withMessage(\"Predicate must not be null\");\r\n    assertThatIllegalStateException().isThrownBy(() -> search.withEnclosingClasses(Search.always)).withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.withAnnotationFilter(null)).withMessage(\"AnnotationFilter must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.withRepeatableContainers(null)).withMessage(\"RepeatableContainers must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.from(null)).withMessage(\"AnnotatedElement must not be null\");\r\n}\n@Test\r\nvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\r\n    Stream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT).from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\r\n}\n@Test\r\nvoid searchFromClassWithCustomAnnotationFilter() {\r\n    Stream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT).withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\")).from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Transactional.class, Component.class);\r\n}\n@Test\r\nvoid searchFromClassWithCustomRepeatableContainers() {\r\n    assertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\r\n    RepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\r\n    MergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT).withRepeatableContainers(containers).from(HierarchyClass.class);\r\n    assertThat(annotations.stream(TestConfiguration.class)).map(annotation -> annotation.getString(\"location\")).containsExactly(\"A\", \"B\");\r\n    assertThat(annotations.stream(TestConfiguration.class)).map(annotation -> annotation.getString(\"value\")).containsExactly(\"A\", \"B\");\r\n}\n/**\r\n * @since 6.0\r\n */\r\n@Test\r\nvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\r\n    Class<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\r\n    Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\r\n    assertThat(search.from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\r\n    Stream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    classes = search.withEnclosingClasses(Search.always).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    classes = search.withEnclosingClasses(ClassUtils::isInnerClass).withRepeatableContainers(RepeatableContainers.none()).withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\")).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class);\r\n}\n/**\r\n * @since 6.0\r\n */\r\n@Test\r\nvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\r\n    Class<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\r\n    Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\r\n    assertThat(search.from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\r\n    Stream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    classes = search.withEnclosingClasses(Search.always).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n}",
    "comment": "\n\t * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\n\t * that verify behavior of the fluent {@link Search} API.\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests#preconditions()",
    "entityType": "method",
    "code": "@Test\r\nvoid preconditions() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.search(null)).withMessage(\"SearchStrategy must not be null\");\r\n    Search search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.withEnclosingClasses(null)).withMessage(\"Predicate must not be null\");\r\n    assertThatIllegalStateException().isThrownBy(() -> search.withEnclosingClasses(Search.always)).withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.withAnnotationFilter(null)).withMessage(\"AnnotationFilter must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.withRepeatableContainers(null)).withMessage(\"RepeatableContainers must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> search.from(null)).withMessage(\"AnnotatedElement must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests#searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers()",
    "entityType": "method",
    "code": "@Test\r\nvoid searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\r\n    Stream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT).from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests#searchFromClassWithCustomAnnotationFilter()",
    "entityType": "method",
    "code": "@Test\r\nvoid searchFromClassWithCustomAnnotationFilter() {\r\n    Stream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT).withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\")).from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Transactional.class, Component.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests#searchFromClassWithCustomRepeatableContainers()",
    "entityType": "method",
    "code": "@Test\r\nvoid searchFromClassWithCustomRepeatableContainers() {\r\n    assertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\r\n    RepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\r\n    MergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT).withRepeatableContainers(containers).from(HierarchyClass.class);\r\n    assertThat(annotations.stream(TestConfiguration.class)).map(annotation -> annotation.getString(\"location\")).containsExactly(\"A\", \"B\");\r\n    assertThat(annotations.stream(TestConfiguration.class)).map(annotation -> annotation.getString(\"value\")).containsExactly(\"A\", \"B\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests#searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates()",
    "entityType": "method",
    "code": "/**\r\n * @since 6.0\r\n */\r\n@Test\r\nvoid searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\r\n    Class<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\r\n    Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\r\n    assertThat(search.from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\r\n    Stream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    classes = search.withEnclosingClasses(Search.always).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    classes = search.withEnclosingClasses(ClassUtils::isInnerClass).withRepeatableContainers(RepeatableContainers.none()).withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\")).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class);\r\n}",
    "comment": "\n\t\t * @since 6.0\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.FluentSearchApiTests#searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates()",
    "entityType": "method",
    "code": "/**\r\n * @since 6.0\r\n */\r\n@Test\r\nvoid searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\r\n    Class<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\r\n    Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\r\n    assertThat(search.from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\r\n    assertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\r\n    Stream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    classes = search.withEnclosingClasses(Search.always).from(testCase).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n}",
    "comment": "\n\t\t * @since 6.0\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.ConventionBasedAnnotationAttributeOverrideTests",
    "entityType": "class",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\r\n    // SPR-13554: convention mapping mixed with AliasFor annotations\r\n    // xmlConfigFiles can be used because it has an AliasFor annotation\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\r\n    // SPR-13554: convention mapping mixed with AliasFor annotations\r\n    // locations doesn't apply because it has no AliasFor annotation\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).isEmpty();\r\n    assertThat(annotation.getStringArray(\"value\")).isEmpty();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\r\n}\n@Test\r\nvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\r\n    testGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).isEmpty();\r\n    assertThat(annotation.getStringArray(\"value\")).isEmpty();\r\n    assertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\r\n}\n@Test\r\nvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\r\n    testGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\r\n}",
    "comment": ""
  }
]