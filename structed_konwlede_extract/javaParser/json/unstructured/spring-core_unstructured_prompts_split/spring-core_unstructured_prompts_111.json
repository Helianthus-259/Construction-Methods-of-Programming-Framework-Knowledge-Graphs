[
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests#getPriorityValueNoAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPriorityValueNoAnnotation() {\r\n    assertThat(OrderUtils.getPriority(SimpleOrder.class)).isNull();\r\n    assertThat(OrderUtils.getPriority(SimpleOrder.class)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests#getPriorityValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPriorityValue() {\r\n    assertThat(OrderUtils.getPriority(OrderAndPriority.class)).isEqualTo(Integer.valueOf(55));\r\n    assertThat(OrderUtils.getPriority(OrderAndPriority.class)).isEqualTo(Integer.valueOf(55));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SimpleOrder",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SimplePriority",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderAndPriority",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.NoOrder",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests",
    "entityType": "class",
    "code": "@Test\r\nvoid createWhenPackagesIsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PackagesAnnotationFilter((String[]) null)).withMessage(\"Packages array must not be null\");\r\n}\n@Test\r\nvoid createWhenPackagesContainsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PackagesAnnotationFilter((String) null)).withMessage(\"Packages array must not have empty elements\");\r\n}\n@Test\r\nvoid createWhenPackagesContainsEmptyTextThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PackagesAnnotationFilter(\"\")).withMessage(\"Packages array must not have empty elements\");\r\n}\n@Test\r\nvoid matchesWhenInPackageReturnsTrue() {\r\n    PackagesAnnotationFilter filter = new PackagesAnnotationFilter(\"com.example\");\r\n    assertThat(filter.matches(\"com.example.Component\")).isTrue();\r\n}\n@Test\r\nvoid matchesWhenNotInPackageReturnsFalse() {\r\n    PackagesAnnotationFilter filter = new PackagesAnnotationFilter(\"com.example\");\r\n    assertThat(filter.matches(\"org.springframework.stereotype.Component\")).isFalse();\r\n}\n@Test\r\nvoid matchesWhenInSimilarPackageReturnsFalse() {\r\n    PackagesAnnotationFilter filter = new PackagesAnnotationFilter(\"com.example\");\r\n    assertThat(filter.matches(\"com.examples.Component\")).isFalse();\r\n}\n@Test\r\nvoid equalsAndHashCode() {\r\n    PackagesAnnotationFilter filter1 = new PackagesAnnotationFilter(\"com.example\", \"org.springframework\");\r\n    PackagesAnnotationFilter filter2 = new PackagesAnnotationFilter(\"org.springframework\", \"com.example\");\r\n    PackagesAnnotationFilter filter3 = new PackagesAnnotationFilter(\"com.examples\");\r\n    assertThat(filter1.hashCode()).isEqualTo(filter2.hashCode());\r\n    assertThat(filter1).isEqualTo(filter1).isEqualTo(filter2).isNotEqualTo(filter3);\r\n}",
    "comment": "\n * Tests for {@link PackagesAnnotationFilter}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#createWhenPackagesIsNullThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWhenPackagesIsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PackagesAnnotationFilter((String[]) null)).withMessage(\"Packages array must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#createWhenPackagesContainsNullThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWhenPackagesContainsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PackagesAnnotationFilter((String) null)).withMessage(\"Packages array must not have empty elements\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#createWhenPackagesContainsEmptyTextThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid createWhenPackagesContainsEmptyTextThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PackagesAnnotationFilter(\"\")).withMessage(\"Packages array must not have empty elements\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#matchesWhenInPackageReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchesWhenInPackageReturnsTrue() {\r\n    PackagesAnnotationFilter filter = new PackagesAnnotationFilter(\"com.example\");\r\n    assertThat(filter.matches(\"com.example.Component\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#matchesWhenNotInPackageReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchesWhenNotInPackageReturnsFalse() {\r\n    PackagesAnnotationFilter filter = new PackagesAnnotationFilter(\"com.example\");\r\n    assertThat(filter.matches(\"org.springframework.stereotype.Component\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#matchesWhenInSimilarPackageReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchesWhenInSimilarPackageReturnsFalse() {\r\n    PackagesAnnotationFilter filter = new PackagesAnnotationFilter(\"com.example\");\r\n    assertThat(filter.matches(\"com.examples.Component\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilterTests#equalsAndHashCode()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsAndHashCode() {\r\n    PackagesAnnotationFilter filter1 = new PackagesAnnotationFilter(\"com.example\", \"org.springframework\");\r\n    PackagesAnnotationFilter filter2 = new PackagesAnnotationFilter(\"org.springframework\", \"com.example\");\r\n    PackagesAnnotationFilter filter3 = new PackagesAnnotationFilter(\"com.examples\");\r\n    assertThat(filter1.hashCode()).isEqualTo(filter2.hashCode());\r\n    assertThat(filter1).isEqualTo(filter1).isEqualTo(filter2).isNotEqualTo(filter3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainersTests",
    "entityType": "class",
    "code": "@Nested\r\nclass StandardRepeatableContainersTests {\r\n\r\n    @Test\r\n    void standardRepeatablesWhenNonRepeatableReturnsNull() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), NonRepeatableTestCase.class, NonRepeatable.class);\r\n        assertThat(values).isNull();\r\n    }\r\n\r\n    @Test\r\n    void standardRepeatablesWhenSingleReturnsNull() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), SingleStandardRepeatableTestCase.class, StandardRepeatable.class);\r\n        assertThat(values).isNull();\r\n    }\r\n\r\n    @Test\r\n    void standardRepeatablesWhenContainerButNotRepeatableReturnsNull() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), ExplicitRepeatablesTestCase.class, ExplicitContainer.class);\r\n        assertThat(values).isNull();\r\n    }\r\n\r\n    @Test\r\n    void standardRepeatablesWhenContainerReturnsRepeats() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n        assertThat(values).containsExactly(\"a\", \"b\");\r\n    }\r\n\r\n    @Test\r\n    void standardRepeatablesWithContainerWithMultipleAttributes() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class, StandardContainerWithMultipleAttributes.class);\r\n        assertThat(values).containsExactly(\"a\", \"b\");\r\n    }\r\n}\n@Nested\r\nclass ExplicitRepeatableContainerTests {\r\n\r\n    @Test\r\n    void ofExplicitWhenNonRepeatableReturnsNull() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), NonRepeatableTestCase.class, NonRepeatable.class);\r\n        assertThat(values).isNull();\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenStandardRepeatableContainerReturnsNull() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n        assertThat(values).isNull();\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenContainerReturnsRepeats() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), ExplicitRepeatablesTestCase.class, ExplicitContainer.class);\r\n        assertThat(values).containsExactly(\"a\", \"b\");\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenContainerIsNullDeducesContainer() {\r\n        Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(StandardRepeatable.class, null), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n        assertThat(values).containsExactly(\"a\", \"b\");\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenHasNoValueThrowsException() {\r\n        assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidNoValue.class)).withMessageContaining(\"Invalid declaration of container type [%s] for repeatable annotation [%s]\", InvalidNoValue.class.getName(), ExplicitRepeatable.class.getName());\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenValueIsNotArrayThrowsException() {\r\n        assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidNotArray.class)).withMessage(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\", InvalidNotArray.class.getName(), ExplicitRepeatable.class.getName());\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenValueIsArrayOfWrongTypeThrowsException() {\r\n        assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidWrongArrayType.class)).withMessage(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\", InvalidWrongArrayType.class.getName(), ExplicitRepeatable.class.getName());\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenAnnotationIsNullThrowsException() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> RepeatableContainers.of(null, null)).withMessage(\"Repeatable must not be null\");\r\n    }\r\n\r\n    @Test\r\n    void ofExplicitWhenContainerIsNullAndNotRepeatableThrowsException() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, null)).withMessage(\"Annotation type must be a repeatable annotation: failed to resolve container type for %s\", ExplicitRepeatable.class.getName());\r\n    }\r\n}\n@Test\r\nvoid standardAndExplicitReturnsRepeats() {\r\n    RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables().and(ExplicitContainer.class, ExplicitRepeatable.class);\r\n    assertThat(findRepeatedAnnotationValues(repeatableContainers, StandardRepeatablesTestCase.class, StandardContainer.class)).containsExactly(\"a\", \"b\");\r\n    assertThat(findRepeatedAnnotationValues(repeatableContainers, ExplicitRepeatablesTestCase.class, ExplicitContainer.class)).containsExactly(\"a\", \"b\");\r\n}\n@Test\r\nvoid noneAlwaysReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.none(), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).isNull();\r\n}\n@Test\r\nvoid equalsAndHashcode() {\r\n    RepeatableContainers c1 = RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class);\r\n    RepeatableContainers c2 = RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class);\r\n    RepeatableContainers c3 = RepeatableContainers.standardRepeatables();\r\n    RepeatableContainers c4 = RepeatableContainers.standardRepeatables().and(ExplicitContainer.class, ExplicitRepeatable.class);\r\n    assertThat(c1).hasSameHashCodeAs(c2);\r\n    assertThat(c1).isEqualTo(c1).isEqualTo(c2);\r\n    assertThat(c1).isNotEqualTo(c3).isNotEqualTo(c4);\r\n}\nprivate static Object[] findRepeatedAnnotationValues(RepeatableContainers containers, Class<?> element, Class<? extends Annotation> annotationType) {\r\n    Annotation[] annotations = containers.findRepeatedAnnotations(element.getAnnotation(annotationType));\r\n    return extractValues(annotations);\r\n}\nprivate static Object[] extractValues(Annotation[] annotations) {\r\n    if (annotations == null) {\r\n        return null;\r\n    }\r\n    return Arrays.stream(annotations).map(AnnotationUtils::getValue).toArray(Object[]::new);\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NonRepeatable {\r\n\r\n    String value() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface StandardContainer {\r\n\r\n    StandardRepeatable[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(StandardContainer.class)\r\n@interface StandardRepeatable {\r\n\r\n    String value() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ExplicitContainer {\r\n\r\n    ExplicitRepeatable[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ExplicitRepeatable {\r\n\r\n    String value() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface InvalidNoValue {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface InvalidNotArray {\r\n\r\n    int value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface InvalidWrongArrayType {\r\n\r\n    StandardRepeatable[] value();\r\n}\n@NonRepeatable(\"a\")\r\nstatic class NonRepeatableTestCase {\r\n}\n@StandardRepeatable(\"a\")\r\nstatic class SingleStandardRepeatableTestCase {\r\n}\n@StandardRepeatable(\"a\")\r\n@StandardRepeatable(\"b\")\r\nstatic class StandardRepeatablesTestCase {\r\n}\n@ExplicitContainer({ @ExplicitRepeatable(\"a\"), @ExplicitRepeatable(\"b\") })\r\nstatic class ExplicitRepeatablesTestCase {\r\n}",
    "comment": "\n * Tests for {@link RepeatableContainers}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainersTests#standardAndExplicitReturnsRepeats()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardAndExplicitReturnsRepeats() {\r\n    RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables().and(ExplicitContainer.class, ExplicitRepeatable.class);\r\n    assertThat(findRepeatedAnnotationValues(repeatableContainers, StandardRepeatablesTestCase.class, StandardContainer.class)).containsExactly(\"a\", \"b\");\r\n    assertThat(findRepeatedAnnotationValues(repeatableContainers, ExplicitRepeatablesTestCase.class, ExplicitContainer.class)).containsExactly(\"a\", \"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainersTests#noneAlwaysReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid noneAlwaysReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.none(), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainersTests#equalsAndHashcode()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsAndHashcode() {\r\n    RepeatableContainers c1 = RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class);\r\n    RepeatableContainers c2 = RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class);\r\n    RepeatableContainers c3 = RepeatableContainers.standardRepeatables();\r\n    RepeatableContainers c4 = RepeatableContainers.standardRepeatables().and(ExplicitContainer.class, ExplicitRepeatable.class);\r\n    assertThat(c1).hasSameHashCodeAs(c2);\r\n    assertThat(c1).isEqualTo(c1).isEqualTo(c2);\r\n    assertThat(c1).isNotEqualTo(c3).isNotEqualTo(c4);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainersTests#findRepeatedAnnotationValues(RepeatableContainers,Class<?>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private static Object[] findRepeatedAnnotationValues(RepeatableContainers containers, Class<?> element, Class<? extends Annotation> annotationType) {\r\n    Annotation[] annotations = containers.findRepeatedAnnotations(element.getAnnotation(annotationType));\r\n    return extractValues(annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainersTests#extractValues(Annotation[])",
    "entityType": "method",
    "code": "private static Object[] extractValues(Annotation[] annotations) {\r\n    if (annotations == null) {\r\n        return null;\r\n    }\r\n    return Arrays.stream(annotations).map(AnnotationUtils::getValue).toArray(Object[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainersTests",
    "entityType": "class",
    "code": "@Test\r\nvoid standardRepeatablesWhenNonRepeatableReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), NonRepeatableTestCase.class, NonRepeatable.class);\r\n    assertThat(values).isNull();\r\n}\n@Test\r\nvoid standardRepeatablesWhenSingleReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), SingleStandardRepeatableTestCase.class, StandardRepeatable.class);\r\n    assertThat(values).isNull();\r\n}\n@Test\r\nvoid standardRepeatablesWhenContainerButNotRepeatableReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), ExplicitRepeatablesTestCase.class, ExplicitContainer.class);\r\n    assertThat(values).isNull();\r\n}\n@Test\r\nvoid standardRepeatablesWhenContainerReturnsRepeats() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}\n@Test\r\nvoid standardRepeatablesWithContainerWithMultipleAttributes() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class, StandardContainerWithMultipleAttributes.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainersTests#standardRepeatablesWhenNonRepeatableReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardRepeatablesWhenNonRepeatableReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), NonRepeatableTestCase.class, NonRepeatable.class);\r\n    assertThat(values).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainersTests#standardRepeatablesWhenSingleReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardRepeatablesWhenSingleReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), SingleStandardRepeatableTestCase.class, StandardRepeatable.class);\r\n    assertThat(values).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainersTests#standardRepeatablesWhenContainerButNotRepeatableReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardRepeatablesWhenContainerButNotRepeatableReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), ExplicitRepeatablesTestCase.class, ExplicitContainer.class);\r\n    assertThat(values).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainersTests#standardRepeatablesWhenContainerReturnsRepeats()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardRepeatablesWhenContainerReturnsRepeats() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainersTests#standardRepeatablesWithContainerWithMultipleAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardRepeatablesWithContainerWithMultipleAttributes() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.standardRepeatables(), StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class, StandardContainerWithMultipleAttributes.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests",
    "entityType": "class",
    "code": "@Test\r\nvoid ofExplicitWhenNonRepeatableReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), NonRepeatableTestCase.class, NonRepeatable.class);\r\n    assertThat(values).isNull();\r\n}\n@Test\r\nvoid ofExplicitWhenStandardRepeatableContainerReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).isNull();\r\n}\n@Test\r\nvoid ofExplicitWhenContainerReturnsRepeats() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), ExplicitRepeatablesTestCase.class, ExplicitContainer.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}\n@Test\r\nvoid ofExplicitWhenContainerIsNullDeducesContainer() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(StandardRepeatable.class, null), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}\n@Test\r\nvoid ofExplicitWhenHasNoValueThrowsException() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidNoValue.class)).withMessageContaining(\"Invalid declaration of container type [%s] for repeatable annotation [%s]\", InvalidNoValue.class.getName(), ExplicitRepeatable.class.getName());\r\n}\n@Test\r\nvoid ofExplicitWhenValueIsNotArrayThrowsException() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidNotArray.class)).withMessage(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\", InvalidNotArray.class.getName(), ExplicitRepeatable.class.getName());\r\n}\n@Test\r\nvoid ofExplicitWhenValueIsArrayOfWrongTypeThrowsException() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidWrongArrayType.class)).withMessage(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\", InvalidWrongArrayType.class.getName(), ExplicitRepeatable.class.getName());\r\n}\n@Test\r\nvoid ofExplicitWhenAnnotationIsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> RepeatableContainers.of(null, null)).withMessage(\"Repeatable must not be null\");\r\n}\n@Test\r\nvoid ofExplicitWhenContainerIsNullAndNotRepeatableThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, null)).withMessage(\"Annotation type must be a repeatable annotation: failed to resolve container type for %s\", ExplicitRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenNonRepeatableReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenNonRepeatableReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), NonRepeatableTestCase.class, NonRepeatable.class);\r\n    assertThat(values).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenStandardRepeatableContainerReturnsNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenStandardRepeatableContainerReturnsNull() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenContainerReturnsRepeats()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenContainerReturnsRepeats() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(ExplicitRepeatable.class, ExplicitContainer.class), ExplicitRepeatablesTestCase.class, ExplicitContainer.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenContainerIsNullDeducesContainer()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenContainerIsNullDeducesContainer() {\r\n    Object[] values = findRepeatedAnnotationValues(RepeatableContainers.of(StandardRepeatable.class, null), StandardRepeatablesTestCase.class, StandardContainer.class);\r\n    assertThat(values).containsExactly(\"a\", \"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenHasNoValueThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenHasNoValueThrowsException() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidNoValue.class)).withMessageContaining(\"Invalid declaration of container type [%s] for repeatable annotation [%s]\", InvalidNoValue.class.getName(), ExplicitRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenValueIsNotArrayThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenValueIsNotArrayThrowsException() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidNotArray.class)).withMessage(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\", InvalidNotArray.class.getName(), ExplicitRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenValueIsArrayOfWrongTypeThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenValueIsArrayOfWrongTypeThrowsException() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, InvalidWrongArrayType.class)).withMessage(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\", InvalidWrongArrayType.class.getName(), ExplicitRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenAnnotationIsNullThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenAnnotationIsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> RepeatableContainers.of(null, null)).withMessage(\"Repeatable must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainerTests#ofExplicitWhenContainerIsNullAndNotRepeatableThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofExplicitWhenContainerIsNullAndNotRepeatableThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> RepeatableContainers.of(ExplicitRepeatable.class, null)).withMessage(\"Annotation type must be a repeatable annotation: failed to resolve container type for %s\", ExplicitRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.NonRepeatableTestCase",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleStandardRepeatableTestCase",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatablesTestCase",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatablesTestCase",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass",
    "entityType": "class",
    "code": "",
    "comment": "\n * Class annotated with a non-public (i.e., package private) custom annotation\n * that uses {@code @AliasFor}.\n *\n * @author Sam Brannen\n * @since 4.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.subpackage.NonPublicAnnotatedClass",
    "entityType": "class",
    "code": "",
    "comment": "\n * Class annotated with a non-public (i.e., package private) custom annotation.\n *\n * @author Sam Brannen\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests",
    "entityType": "class",
    "code": "private Method method;\nprivate SynthesizingMethodParameter stringParameter;\nprivate SynthesizingMethodParameter longParameter;\nprivate SynthesizingMethodParameter intReturnType;\n@BeforeEach\r\nvoid setUp() throws NoSuchMethodException {\r\n    method = getClass().getMethod(\"method\", String.class, long.class);\r\n    stringParameter = new SynthesizingMethodParameter(method, 0);\r\n    longParameter = new SynthesizingMethodParameter(method, 1);\r\n    intReturnType = new SynthesizingMethodParameter(method, -1);\r\n}\n@Test\r\nvoid equals() throws NoSuchMethodException {\r\n    assertThat(stringParameter).isEqualTo(stringParameter);\r\n    assertThat(longParameter).isEqualTo(longParameter);\r\n    assertThat(intReturnType).isEqualTo(intReturnType);\r\n    assertThat(stringParameter).isNotEqualTo(longParameter);\r\n    assertThat(stringParameter).isNotEqualTo(intReturnType);\r\n    assertThat(longParameter).isNotEqualTo(stringParameter);\r\n    assertThat(longParameter).isNotEqualTo(intReturnType);\r\n    assertThat(intReturnType).isNotEqualTo(stringParameter);\r\n    assertThat(intReturnType).isNotEqualTo(longParameter);\r\n    Method method = getClass().getMethod(\"method\", String.class, long.class);\r\n    MethodParameter methodParameter = new SynthesizingMethodParameter(method, 0);\r\n    assertThat(methodParameter).isEqualTo(stringParameter);\r\n    assertThat(stringParameter).isEqualTo(methodParameter);\r\n    assertThat(methodParameter).isNotEqualTo(longParameter);\r\n    assertThat(longParameter).isNotEqualTo(methodParameter);\r\n    methodParameter = new MethodParameter(method, 0);\r\n    assertThat(methodParameter).isEqualTo(stringParameter);\r\n    assertThat(stringParameter).isEqualTo(methodParameter);\r\n    assertThat(methodParameter).isNotEqualTo(longParameter);\r\n    assertThat(longParameter).isNotEqualTo(methodParameter);\r\n}\n@Test\r\nvoid testHashCode() throws NoSuchMethodException {\r\n    assertThat(stringParameter.hashCode()).isEqualTo(stringParameter.hashCode());\r\n    assertThat(longParameter.hashCode()).isEqualTo(longParameter.hashCode());\r\n    assertThat(intReturnType.hashCode()).isEqualTo(intReturnType.hashCode());\r\n    Method method = getClass().getMethod(\"method\", String.class, long.class);\r\n    SynthesizingMethodParameter methodParameter = new SynthesizingMethodParameter(method, 0);\r\n    assertThat(methodParameter.hashCode()).isEqualTo(stringParameter.hashCode());\r\n    assertThat(methodParameter.hashCode()).isNotEqualTo(longParameter.hashCode());\r\n}\n@Test\r\nvoid factoryMethods() {\r\n    assertThat(SynthesizingMethodParameter.forExecutable(method, 0)).isEqualTo(stringParameter);\r\n    assertThat(SynthesizingMethodParameter.forExecutable(method, 1)).isEqualTo(longParameter);\r\n    assertThat(SynthesizingMethodParameter.forParameter(method.getParameters()[0])).isEqualTo(stringParameter);\r\n    assertThat(SynthesizingMethodParameter.forParameter(method.getParameters()[1])).isEqualTo(longParameter);\r\n}\n@Test\r\nvoid indexValidation() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new SynthesizingMethodParameter(method, 2));\r\n}\npublic int method(String p1, long p2) {\r\n    return 42;\r\n}",
    "comment": "\n * @author Juergen Hoeller\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() throws NoSuchMethodException {\r\n    method = getClass().getMethod(\"method\", String.class, long.class);\r\n    stringParameter = new SynthesizingMethodParameter(method, 0);\r\n    longParameter = new SynthesizingMethodParameter(method, 1);\r\n    intReturnType = new SynthesizingMethodParameter(method, -1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests#equals()",
    "entityType": "method",
    "code": "@Test\r\nvoid equals() throws NoSuchMethodException {\r\n    assertThat(stringParameter).isEqualTo(stringParameter);\r\n    assertThat(longParameter).isEqualTo(longParameter);\r\n    assertThat(intReturnType).isEqualTo(intReturnType);\r\n    assertThat(stringParameter).isNotEqualTo(longParameter);\r\n    assertThat(stringParameter).isNotEqualTo(intReturnType);\r\n    assertThat(longParameter).isNotEqualTo(stringParameter);\r\n    assertThat(longParameter).isNotEqualTo(intReturnType);\r\n    assertThat(intReturnType).isNotEqualTo(stringParameter);\r\n    assertThat(intReturnType).isNotEqualTo(longParameter);\r\n    Method method = getClass().getMethod(\"method\", String.class, long.class);\r\n    MethodParameter methodParameter = new SynthesizingMethodParameter(method, 0);\r\n    assertThat(methodParameter).isEqualTo(stringParameter);\r\n    assertThat(stringParameter).isEqualTo(methodParameter);\r\n    assertThat(methodParameter).isNotEqualTo(longParameter);\r\n    assertThat(longParameter).isNotEqualTo(methodParameter);\r\n    methodParameter = new MethodParameter(method, 0);\r\n    assertThat(methodParameter).isEqualTo(stringParameter);\r\n    assertThat(stringParameter).isEqualTo(methodParameter);\r\n    assertThat(methodParameter).isNotEqualTo(longParameter);\r\n    assertThat(longParameter).isNotEqualTo(methodParameter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests#testHashCode()",
    "entityType": "method",
    "code": "@Test\r\nvoid testHashCode() throws NoSuchMethodException {\r\n    assertThat(stringParameter.hashCode()).isEqualTo(stringParameter.hashCode());\r\n    assertThat(longParameter.hashCode()).isEqualTo(longParameter.hashCode());\r\n    assertThat(intReturnType.hashCode()).isEqualTo(intReturnType.hashCode());\r\n    Method method = getClass().getMethod(\"method\", String.class, long.class);\r\n    SynthesizingMethodParameter methodParameter = new SynthesizingMethodParameter(method, 0);\r\n    assertThat(methodParameter.hashCode()).isEqualTo(stringParameter.hashCode());\r\n    assertThat(methodParameter.hashCode()).isNotEqualTo(longParameter.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests#factoryMethods()",
    "entityType": "method",
    "code": "@Test\r\nvoid factoryMethods() {\r\n    assertThat(SynthesizingMethodParameter.forExecutable(method, 0)).isEqualTo(stringParameter);\r\n    assertThat(SynthesizingMethodParameter.forExecutable(method, 1)).isEqualTo(longParameter);\r\n    assertThat(SynthesizingMethodParameter.forParameter(method.getParameters()[0])).isEqualTo(stringParameter);\r\n    assertThat(SynthesizingMethodParameter.forParameter(method.getParameters()[1])).isEqualTo(longParameter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests#indexValidation()",
    "entityType": "method",
    "code": "@Test\r\nvoid indexValidation() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new SynthesizingMethodParameter(method, 2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameterTests#method(String,long)",
    "entityType": "method",
    "code": "public int method(String p1, long p2) {\r\n    return 42;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests",
    "entityType": "class",
    "code": "@Test\r\nvoid mappingWhenMirroredReturnsMirroredValues() {\r\n    testExplicitMirror(WithExplicitMirrorA.class);\r\n    testExplicitMirror(WithExplicitMirrorB.class);\r\n}\nprivate void testExplicitMirror(Class<?> annotatedClass) {\r\n    TypeMappedAnnotation<ExplicitMirror> annotation = getTypeMappedAnnotation(annotatedClass, ExplicitMirror.class);\r\n    assertThat(annotation.getString(\"a\")).isEqualTo(\"test\");\r\n    assertThat(annotation.getString(\"b\")).isEqualTo(\"test\");\r\n}\n@Test\r\nvoid mappingExplicitAliasToMetaAnnotationReturnsMappedValues() {\r\n    TypeMappedAnnotation<?> annotation = getTypeMappedAnnotation(WithExplicitAliasToMetaAnnotation.class, ExplicitAliasToMetaAnnotation.class, ExplicitAliasMetaAnnotationTarget.class);\r\n    assertThat(annotation.getString(\"aliased\")).isEqualTo(\"aliased\");\r\n    assertThat(annotation.getString(\"nonAliased\")).isEqualTo(\"nonAliased\");\r\n}\n@Test\r\nvoid mappingConventionAliasToMetaAnnotationReturnsMappedValues() {\r\n    TypeMappedAnnotation<?> annotation = getTypeMappedAnnotation(WithConventionAliasToMetaAnnotation.class, ConventionAliasToMetaAnnotation.class, ConventionAliasMetaAnnotationTarget.class);\r\n    assertThat(annotation.getString(\"value\")).isEmpty();\r\n    assertThat(annotation.getString(\"convention\")).isEqualTo(\"convention\");\r\n}\n@Test\r\nvoid adaptFromEmptyArrayToAnyComponentType() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ArrayTypes.class);\r\n    Map<String, Object> attributes = new HashMap<>();\r\n    for (int i = 0; i < methods.size(); i++) {\r\n        attributes.put(methods.get(i).getName(), new Object[] ;);\r\n    }\r\n    MergedAnnotation<ArrayTypes> annotation = TypeMappedAnnotation.of(null, null, ArrayTypes.class, attributes);\r\n    assertThat(annotation.getValue(\"stringValue\")).contains(new String[] ;);\r\n    assertThat(annotation.getValue(\"byteValue\")).contains(new byte[] ;);\r\n    assertThat(annotation.getValue(\"shortValue\")).contains(new short[] ;);\r\n    assertThat(annotation.getValue(\"intValue\")).contains(new int[] ;);\r\n    assertThat(annotation.getValue(\"longValue\")).contains(new long[] ;);\r\n    assertThat(annotation.getValue(\"booleanValue\")).contains(new boolean[] ;);\r\n    assertThat(annotation.getValue(\"charValue\")).contains(new char[] ;);\r\n    assertThat(annotation.getValue(\"doubleValue\")).contains(new double[] ;);\r\n    assertThat(annotation.getValue(\"floatValue\")).contains(new float[] ;);\r\n    assertThat(annotation.getValue(\"classValue\")).contains(new Class<?>[] ;);\r\n    assertThat(annotation.getValue(\"annotationValue\")).contains(new MergedAnnotation<?>[] ;);\r\n    assertThat(annotation.getValue(\"enumValue\")).contains(new ExampleEnum[] ;);\r\n}\n@Test\r\nvoid adaptFromNestedMergedAnnotation() {\r\n    MergedAnnotation<Nested> nested = MergedAnnotation.of(Nested.class);\r\n    MergedAnnotation<?> annotation = TypeMappedAnnotation.of(null, null, NestedContainer.class, Collections.singletonMap(\"value\", nested));\r\n    assertThat(annotation.getAnnotation(\"value\", Nested.class)).isSameAs(nested);\r\n}\n@Test\r\nvoid adaptFromStringToClass() {\r\n    MergedAnnotation<?> annotation = TypeMappedAnnotation.of(null, null, ClassAttributes.class, Collections.singletonMap(\"classValue\", InputStream.class.getName()));\r\n    assertThat(annotation.getString(\"classValue\")).isEqualTo(InputStream.class.getName());\r\n    assertThat(annotation.getClass(\"classValue\")).isEqualTo(InputStream.class);\r\n}\n@Test\r\nvoid adaptFromStringArrayToClassArray() {\r\n    MergedAnnotation<?> annotation = TypeMappedAnnotation.of(null, null, ClassAttributes.class, Collections.singletonMap(\"classArrayValue\", new String[] { InputStream.class.getName() }));\r\n    assertThat(annotation.getStringArray(\"classArrayValue\")).containsExactly(InputStream.class.getName());\r\n    assertThat(annotation.getClassArray(\"classArrayValue\")).containsExactly(InputStream.class);\r\n}\nprivate <A extends Annotation> TypeMappedAnnotation<A> getTypeMappedAnnotation(Class<?> source, Class<A> annotationType) {\r\n    return getTypeMappedAnnotation(source, annotationType, annotationType);\r\n}\nprivate <A extends Annotation> TypeMappedAnnotation<A> getTypeMappedAnnotation(Class<?> source, Class<? extends Annotation> rootAnnotationType, Class<A> annotationType) {\r\n    Annotation rootAnnotation = source.getAnnotation(rootAnnotationType);\r\n    AnnotationTypeMapping mapping = getMapping(rootAnnotation, annotationType);\r\n    return TypeMappedAnnotation.createIfPossible(mapping, source, rootAnnotation, 0, IntrospectionFailureLogger.INFO);\r\n}\nprivate AnnotationTypeMapping getMapping(Annotation annotation, Class<? extends Annotation> mappedAnnotationType) {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType());\r\n    for (int i = 0; i < mappings.size(); i++) {\r\n        AnnotationTypeMapping candidate = mappings.get(i);\r\n        if (candidate.getAnnotationType().equals(mappedAnnotationType)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"No mapping from \" + annotation + \" to \" + mappedAnnotationType);\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ExplicitMirror {\r\n\r\n    @AliasFor(\"b\")\r\n    String a() default \"\";\r\n\r\n    @AliasFor(\"a\")\r\n    String b() default \"\";\r\n}\n@ExplicitMirror(a = \"test\")\r\nstatic class WithExplicitMirrorA {\r\n}\n@ExplicitMirror(b = \"test\")\r\nstatic class WithExplicitMirrorB {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@ExplicitAliasMetaAnnotationTarget(nonAliased = \"nonAliased\")\r\n@interface ExplicitAliasToMetaAnnotation {\r\n\r\n    @AliasFor(annotation = ExplicitAliasMetaAnnotationTarget.class)\r\n    String aliased() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ExplicitAliasMetaAnnotationTarget {\r\n\r\n    String aliased() default \"\";\r\n\r\n    String nonAliased() default \"\";\r\n}\n@ExplicitAliasToMetaAnnotation(aliased = \"aliased\")\r\nprivate static class WithExplicitAliasToMetaAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ConventionAliasMetaAnnotationTarget {\r\n\r\n    String value() default \"\";\r\n\r\n    String convention() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@ConventionAliasMetaAnnotationTarget\r\n@interface ConventionAliasToMetaAnnotation {\r\n\r\n    String value() default \"\";\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ConventionAliasMetaAnnotationTarget.class)\r\n    String convention() default \"\";\r\n}\n@ConventionAliasToMetaAnnotation(value = \"value\", convention = \"convention\")\r\nprivate static class WithConventionAliasToMetaAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ArrayTypes {\r\n\r\n    String[] stringValue();\r\n\r\n    byte[] byteValue();\r\n\r\n    short[] shortValue();\r\n\r\n    int[] intValue();\r\n\r\n    long[] longValue();\r\n\r\n    boolean[] booleanValue();\r\n\r\n    char[] charValue();\r\n\r\n    double[] doubleValue();\r\n\r\n    float[] floatValue();\r\n\r\n    Class<?>[] classValue();\r\n\r\n    ExplicitMirror[] annotationValue();\r\n\r\n    ExampleEnum[] enumValue();\r\n}\nenum ExampleEnum {\r\n\r\n    ONE, TWO, THREE\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NestedContainer {\r\n\r\n    Nested value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface Nested {\r\n\r\n    String value() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ClassAttributes {\r\n\r\n    Class<?> classValue();\r\n\r\n    Class<?>[] classArrayValue();\r\n}",
    "comment": "\n * Tests for {@link TypeMappedAnnotation}. See also {@link MergedAnnotationsTests}\n * for a much more extensive collection of tests.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#mappingWhenMirroredReturnsMirroredValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid mappingWhenMirroredReturnsMirroredValues() {\r\n    testExplicitMirror(WithExplicitMirrorA.class);\r\n    testExplicitMirror(WithExplicitMirrorB.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#testExplicitMirror(Class<?>)",
    "entityType": "method",
    "code": "private void testExplicitMirror(Class<?> annotatedClass) {\r\n    TypeMappedAnnotation<ExplicitMirror> annotation = getTypeMappedAnnotation(annotatedClass, ExplicitMirror.class);\r\n    assertThat(annotation.getString(\"a\")).isEqualTo(\"test\");\r\n    assertThat(annotation.getString(\"b\")).isEqualTo(\"test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#mappingExplicitAliasToMetaAnnotationReturnsMappedValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid mappingExplicitAliasToMetaAnnotationReturnsMappedValues() {\r\n    TypeMappedAnnotation<?> annotation = getTypeMappedAnnotation(WithExplicitAliasToMetaAnnotation.class, ExplicitAliasToMetaAnnotation.class, ExplicitAliasMetaAnnotationTarget.class);\r\n    assertThat(annotation.getString(\"aliased\")).isEqualTo(\"aliased\");\r\n    assertThat(annotation.getString(\"nonAliased\")).isEqualTo(\"nonAliased\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#mappingConventionAliasToMetaAnnotationReturnsMappedValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid mappingConventionAliasToMetaAnnotationReturnsMappedValues() {\r\n    TypeMappedAnnotation<?> annotation = getTypeMappedAnnotation(WithConventionAliasToMetaAnnotation.class, ConventionAliasToMetaAnnotation.class, ConventionAliasMetaAnnotationTarget.class);\r\n    assertThat(annotation.getString(\"value\")).isEmpty();\r\n    assertThat(annotation.getString(\"convention\")).isEqualTo(\"convention\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#adaptFromEmptyArrayToAnyComponentType()",
    "entityType": "method",
    "code": "@Test\r\nvoid adaptFromEmptyArrayToAnyComponentType() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ArrayTypes.class);\r\n    Map<String, Object> attributes = new HashMap<>();\r\n    for (int i = 0; i < methods.size(); i++) {\r\n        attributes.put(methods.get(i).getName(), new Object[] ;);\r\n    }\r\n    MergedAnnotation<ArrayTypes> annotation = TypeMappedAnnotation.of(null, null, ArrayTypes.class, attributes);\r\n    assertThat(annotation.getValue(\"stringValue\")).contains(new String[] ;);\r\n    assertThat(annotation.getValue(\"byteValue\")).contains(new byte[] ;);\r\n    assertThat(annotation.getValue(\"shortValue\")).contains(new short[] ;);\r\n    assertThat(annotation.getValue(\"intValue\")).contains(new int[] ;);\r\n    assertThat(annotation.getValue(\"longValue\")).contains(new long[] ;);\r\n    assertThat(annotation.getValue(\"booleanValue\")).contains(new boolean[] ;);\r\n    assertThat(annotation.getValue(\"charValue\")).contains(new char[] ;);\r\n    assertThat(annotation.getValue(\"doubleValue\")).contains(new double[] ;);\r\n    assertThat(annotation.getValue(\"floatValue\")).contains(new float[] ;);\r\n    assertThat(annotation.getValue(\"classValue\")).contains(new Class<?>[] ;);\r\n    assertThat(annotation.getValue(\"annotationValue\")).contains(new MergedAnnotation<?>[] ;);\r\n    assertThat(annotation.getValue(\"enumValue\")).contains(new ExampleEnum[] ;);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#adaptFromNestedMergedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid adaptFromNestedMergedAnnotation() {\r\n    MergedAnnotation<Nested> nested = MergedAnnotation.of(Nested.class);\r\n    MergedAnnotation<?> annotation = TypeMappedAnnotation.of(null, null, NestedContainer.class, Collections.singletonMap(\"value\", nested));\r\n    assertThat(annotation.getAnnotation(\"value\", Nested.class)).isSameAs(nested);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#adaptFromStringToClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid adaptFromStringToClass() {\r\n    MergedAnnotation<?> annotation = TypeMappedAnnotation.of(null, null, ClassAttributes.class, Collections.singletonMap(\"classValue\", InputStream.class.getName()));\r\n    assertThat(annotation.getString(\"classValue\")).isEqualTo(InputStream.class.getName());\r\n    assertThat(annotation.getClass(\"classValue\")).isEqualTo(InputStream.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#adaptFromStringArrayToClassArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid adaptFromStringArrayToClassArray() {\r\n    MergedAnnotation<?> annotation = TypeMappedAnnotation.of(null, null, ClassAttributes.class, Collections.singletonMap(\"classArrayValue\", new String[] { InputStream.class.getName() }));\r\n    assertThat(annotation.getStringArray(\"classArrayValue\")).containsExactly(InputStream.class.getName());\r\n    assertThat(annotation.getClassArray(\"classArrayValue\")).containsExactly(InputStream.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#getTypeMappedAnnotation(Class<?>,Class<A>)",
    "entityType": "method",
    "code": "private <A extends Annotation> TypeMappedAnnotation<A> getTypeMappedAnnotation(Class<?> source, Class<A> annotationType) {\r\n    return getTypeMappedAnnotation(source, annotationType, annotationType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#getTypeMappedAnnotation(Class<?>,Class<? extends Annotation>,Class<A>)",
    "entityType": "method",
    "code": "private <A extends Annotation> TypeMappedAnnotation<A> getTypeMappedAnnotation(Class<?> source, Class<? extends Annotation> rootAnnotationType, Class<A> annotationType) {\r\n    Annotation rootAnnotation = source.getAnnotation(rootAnnotationType);\r\n    AnnotationTypeMapping mapping = getMapping(rootAnnotation, annotationType);\r\n    return TypeMappedAnnotation.createIfPossible(mapping, source, rootAnnotation, 0, IntrospectionFailureLogger.INFO);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotationTests#getMapping(Annotation,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private AnnotationTypeMapping getMapping(Annotation annotation, Class<? extends Annotation> mappedAnnotationType) {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType());\r\n    for (int i = 0; i < mappings.size(); i++) {\r\n        AnnotationTypeMapping candidate = mappings.get(i);\r\n        if (candidate.getAnnotationType().equals(mappedAnnotationType)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"No mapping from \" + annotation + \" to \" + mappedAnnotationType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithExplicitMirrorA",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithExplicitMirrorB",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithExplicitAliasToMetaAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithConventionAliasToMetaAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupportTests",
    "entityType": "class",
    "code": "private static final String NAME = \"name\";\nprivate static final String VALUE = \"value\";\nprivate final AttributeAccessor attributeAccessor = new SimpleAttributeAccessorSupport();\n@Test\r\nvoid setAndGet() {\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(VALUE);\r\n}\n@Test\r\nvoid setAndHas() {\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isTrue();\r\n}\n@Test\r\nvoid computeAttribute() {\r\n    AtomicInteger atomicInteger = new AtomicInteger();\r\n    Function<String, String> computeFunction = name -> \"computed-\" + atomicInteger.incrementAndGet();\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.computeAttribute(NAME, computeFunction);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(\"computed-1\");\r\n    this.attributeAccessor.computeAttribute(NAME, computeFunction);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(\"computed-1\");\r\n    this.attributeAccessor.removeAttribute(NAME);\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.computeAttribute(NAME, computeFunction);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(\"computed-2\");\r\n}\n@Test\r\nvoid remove() {\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    assertThat(this.attributeAccessor.removeAttribute(NAME)).isEqualTo(VALUE);\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n}\n@Test\r\nvoid attributeNames() {\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    this.attributeAccessor.setAttribute(\"abc\", \"123\");\r\n    assertThat(this.attributeAccessor.attributeNames()).contains(\"abc\", NAME);\r\n}\n@SuppressWarnings(\"serial\")\r\nprivate static class SimpleAttributeAccessorSupport extends AttributeAccessorSupport {\r\n}",
    "comment": "\n * Tests for {@link AttributeAccessorSupport}.\n *\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 2.0\n "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupportTests#setAndGet()",
    "entityType": "method",
    "code": "@Test\r\nvoid setAndGet() {\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupportTests#setAndHas()",
    "entityType": "method",
    "code": "@Test\r\nvoid setAndHas() {\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupportTests#computeAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid computeAttribute() {\r\n    AtomicInteger atomicInteger = new AtomicInteger();\r\n    Function<String, String> computeFunction = name -> \"computed-\" + atomicInteger.incrementAndGet();\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.computeAttribute(NAME, computeFunction);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(\"computed-1\");\r\n    this.attributeAccessor.computeAttribute(NAME, computeFunction);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(\"computed-1\");\r\n    this.attributeAccessor.removeAttribute(NAME);\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.computeAttribute(NAME, computeFunction);\r\n    assertThat(this.attributeAccessor.getAttribute(NAME)).isEqualTo(\"computed-2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupportTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    assertThat(this.attributeAccessor.removeAttribute(NAME)).isEqualTo(VALUE);\r\n    assertThat(this.attributeAccessor.hasAttribute(NAME)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupportTests#attributeNames()",
    "entityType": "method",
    "code": "@Test\r\nvoid attributeNames() {\r\n    this.attributeAccessor.setAttribute(NAME, VALUE);\r\n    this.attributeAccessor.setAttribute(\"abc\", \"123\");\r\n    assertThat(this.attributeAccessor.attributeNames()).contains(\"abc\", NAME);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SimpleAttributeAccessorSupport",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests",
    "entityType": "class",
    "code": "private static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\r\n    Method[] methods = targetType.getMethods();\r\n    for (Method m : methods) {\r\n        if (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\r\n            return m;\r\n        }\r\n    }\r\n    return null;\r\n}\n@Test\r\nvoid findBridgedMethod() throws Exception {\r\n    Method unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\r\n    Method bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\r\n    assertThat(unbridged.isBridge()).isFalse();\r\n    assertThat(bridged.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\r\n}\n@Test\r\nvoid findBridgedVarargMethod() throws Exception {\r\n    Method unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\r\n    Method bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\r\n    assertThat(unbridged.isBridge()).isFalse();\r\n    assertThat(bridged.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\r\n}\n@Test\r\nvoid findBridgedMethodInHierarchy() throws Exception {\r\n    Method bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"add\");\r\n    assertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\r\n    assertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\r\n}\n@Test\r\nvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\r\n    Method originalMethod = Adder.class.getMethod(\"add\", Object.class);\r\n    assertThat(originalMethod.isBridge()).isFalse();\r\n    Method bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"add\");\r\n    assertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\r\n    assertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\r\n}\n@Test\r\nvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\r\n    Method originalMethod = Adder.class.getMethod(\"add\", Object.class);\r\n    Method mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\r\n    assertThat(mostSpecificMethod).isSameAs(originalMethod);\r\n}\n@Test\r\nvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\r\n    Method originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\r\n    assertThat(originalMethod.isBridge()).isFalse();\r\n    Method bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\r\n    assertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\r\n    assertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid isBridgeMethodFor() throws Exception {\r\n    Method bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\r\n    Method other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\r\n    Method bridge;\r\n    if (IdeUtils.runningInEclipse()) {\r\n        bridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\r\n    } else {\r\n        bridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\r\n    }\r\n    assertThat(bridge.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\r\n}\n@Test\r\nvoid doubleParameterization() throws Exception {\r\n    Method objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\r\n    Method serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\r\n    Method stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\r\n    Method integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\r\n}\n@Test\r\nvoid findBridgedMethodFromMultipleBridges() throws Exception {\r\n    Method loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\r\n    assertThat(loadWithObjectReturn).isNotNull();\r\n    Method loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\r\n    assertThat(loadWithSettingsReturn).isNotNull();\r\n    assertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\r\n    Method method = SettingsDaoImpl.class.getMethod(\"load\");\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\r\n}\n@Test\r\nvoid findBridgedMethodFromParent() throws Exception {\r\n    Method loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\r\n    assertThat(loadFromParentBridge.isBridge()).isTrue();\r\n    Method loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\r\n    assertThat(loadFromParent.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\r\n}\n@Test\r\nvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\r\n    Method bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\r\n    assertThat(actualMethod.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\r\n}\n@Test\r\nvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\r\n    Method bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\r\n    assertThat(actualMethod.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\r\n}\n@Test\r\nvoid withGenericParameter() {\r\n    Method[] methods = StringGenericParameter.class.getMethods();\r\n    Method bridgeMethod = null;\r\n    Method bridgedMethod = null;\r\n    for (Method method : methods) {\r\n        if (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\r\n            if (method.getReturnType().equals(Object.class)) {\r\n                bridgeMethod = method;\r\n            } else {\r\n                bridgedMethod = method;\r\n            }\r\n        }\r\n    }\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    boolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\r\n    assertThat(condition).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid onAllMethods() {\r\n    Method[] methods = StringList.class.getMethods();\r\n    for (Method method : methods) {\r\n        assertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\r\n    }\r\n}\n@Test\r\nvoid spr2583() throws Exception {\r\n    Method bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\r\n    assertThat(otherMethod.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr2603() throws Exception {\r\n    Method objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\r\n    Method abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\r\n    assertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\r\n}\n@Test\r\nvoid spr2648() {\r\n    Method bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\r\n}\n@Test\r\nvoid spr2763() throws Exception {\r\n    Method bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3041() throws Exception {\r\n    Method bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3173() throws Exception {\r\n    Method bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3304() throws Exception {\r\n    Method bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3324() throws Exception {\r\n    Method bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3357() throws Exception {\r\n    Method bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\"doSomething\", DomainObjectSuper.class, Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3485() throws Exception {\r\n    Method bridgedMethod = DomainObject.class.getDeclaredMethod(\"method2\", ParameterType.class, byte[].class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = DomainObject.class.getDeclaredMethod(\"method2\", Serializable.class, Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}\n@Test\r\nvoid spr3534() {\r\n    Method bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\r\n}\n// SPR-16103\r\n@Test\r\nvoid testClassHierarchy() throws Exception {\r\n    doTestHierarchyResolution(FooClass.class);\r\n}\n// SPR-16103\r\n@Test\r\nvoid testInterfaceHierarchy() throws Exception {\r\n    doTestHierarchyResolution(FooInterface.class);\r\n}\nprivate void doTestHierarchyResolution(Class<?> clazz) throws Exception {\r\n    for (Method method : clazz.getDeclaredMethods()) {\r\n        Method bridged = BridgeMethodResolver.findBridgedMethod(method);\r\n        Method expected = clazz.getMethod(\"test\", FooEntity.class);\r\n        assertThat(bridged).isEqualTo(expected);\r\n    }\r\n}\npublic interface Foo<T extends Serializable> {\r\n\r\n    void someMethod(T theArg, Object otherArg);\r\n\r\n    void someVarargMethod(T theArg, Object... otherArg);\r\n}\npublic static class MyFoo implements Foo<String> {\r\n\r\n    public void someMethod(Integer theArg, Object otherArg) {\r\n    }\r\n\r\n    @Override\r\n    public void someMethod(String theArg, Object otherArg) {\r\n    }\r\n\r\n    @Override\r\n    public void someVarargMethod(String theArg, Object... otherArgs) {\r\n    }\r\n}\npublic abstract static class Bar<T> {\r\n\r\n    void someMethod(Map<?, ?> m, Object otherArg) {\r\n    }\r\n\r\n    void someMethod(T theArg, Map<?, ?> m) {\r\n    }\r\n\r\n    abstract void someMethod(T theArg, Object otherArg);\r\n}\npublic abstract static class InterBar<T extends CharSequence> extends Bar<T> {\r\n\r\n    @Override\r\n    void someMethod(T theArg, Object otherArg) {\r\n    }\r\n}\npublic abstract static class SubBar<T extends StringProducer> extends InterBar<T> {\r\n}\npublic interface StringProducer extends CharSequence {\r\n}\npublic static class MyBar extends InterBar<String> {\r\n\r\n    @Override\r\n    public void someMethod(String theArg, Object otherArg) {\r\n    }\r\n\r\n    public void someMethod(Integer theArg, Object otherArg) {\r\n    }\r\n}\npublic interface Adder<T> {\r\n\r\n    void add(T item);\r\n}\npublic abstract static class AbstractDateAdder implements Adder<Date> {\r\n\r\n    @Override\r\n    public abstract void add(Date date);\r\n}\npublic static class DateAdder extends AbstractDateAdder {\r\n\r\n    @Override\r\n    public void add(Date date) {\r\n    }\r\n}\npublic static class FakeAdder {\r\n\r\n    public void add(Date date) {\r\n    }\r\n}\npublic static class Enclosing<T> {\r\n\r\n    public class Enclosed<S> {\r\n\r\n        public class ReallyDeepNow<R> {\r\n\r\n            void someMethod(S s, T t, R r) {\r\n            }\r\n        }\r\n    }\r\n}\npublic static class ExtendsEnclosing extends Enclosing<String> {\r\n\r\n    public class ExtendsEnclosed extends Enclosed<Integer> {\r\n\r\n        public class ExtendsReallyDeepNow extends ReallyDeepNow<Long> {\r\n\r\n            @Override\r\n            void someMethod(Integer s, String t, Long r) {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        }\r\n    }\r\n}\npublic interface Boo<E, T extends Serializable> {\r\n\r\n    void foo(E e);\r\n\r\n    void foo(T t);\r\n}\npublic static class MyBoo implements Boo<String, Integer> {\r\n\r\n    @Override\r\n    public void foo(String e) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void foo(Integer t) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\npublic interface Settings {\r\n}\npublic interface ConcreteSettings extends Settings {\r\n}\npublic interface Dao<T, S> {\r\n\r\n    T load();\r\n\r\n    S loadFromParent();\r\n}\npublic interface SettingsDao<T extends Settings, S> extends Dao<T, S> {\r\n\r\n    @Override\r\n    T load();\r\n}\npublic interface ConcreteSettingsDao extends SettingsDao<ConcreteSettings, String> {\r\n\r\n    @Override\r\n    String loadFromParent();\r\n}\nabstract static class AbstractDaoImpl<T, S> implements Dao<T, S> {\r\n\r\n    protected T object;\r\n\r\n    protected S otherObject;\r\n\r\n    protected AbstractDaoImpl(T object, S otherObject) {\r\n        this.object = object;\r\n        this.otherObject = otherObject;\r\n    }\r\n\r\n    // @Transactional(readOnly = true)\r\n    @Override\r\n    public S loadFromParent() {\r\n        return otherObject;\r\n    }\r\n}\nstatic class SettingsDaoImpl extends AbstractDaoImpl<ConcreteSettings, String> implements ConcreteSettingsDao {\r\n\r\n    protected SettingsDaoImpl(ConcreteSettings object) {\r\n        super(object, \"From Parent\");\r\n    }\r\n\r\n    // @Transactional(readOnly = true)\r\n    @Override\r\n    public ConcreteSettings load() {\r\n        return super.object;\r\n    }\r\n}\npublic interface Bounded<E> {\r\n\r\n    boolean boundedOperation(E e);\r\n}\nprivate static class AbstractBounded<E> implements Bounded<E> {\r\n\r\n    @Override\r\n    public boolean boundedOperation(E myE) {\r\n        return true;\r\n    }\r\n}\nprivate static class SerializableBounded<E extends HashMap & Delayed> extends AbstractBounded<E> {\r\n\r\n    @Override\r\n    public boolean boundedOperation(E myE) {\r\n        return false;\r\n    }\r\n}\npublic interface GenericParameter<T> {\r\n\r\n    T getFor(Class<T> cls);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class StringGenericParameter implements GenericParameter<String> {\r\n\r\n    @Override\r\n    public String getFor(Class<String> cls) {\r\n        return \"foo\";\r\n    }\r\n\r\n    public String getFor(Integer integer) {\r\n        return \"foo\";\r\n    }\r\n}\nprivate static class StringList implements List<String> {\r\n\r\n    @Override\r\n    public int size() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean contains(Object o) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public Iterator<String> iterator() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public Object[] toArray() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public <T> T[] toArray(T[] a) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean add(String o) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean remove(Object o) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean containsAll(Collection<?> c) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean addAll(Collection<? extends String> c) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean addAll(int index, Collection<? extends String> c) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean removeAll(Collection<?> c) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public boolean retainAll(Collection<?> c) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public String get(int index) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public String set(int index, String element) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void add(int index, String element) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public String remove(int index) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public int indexOf(Object o) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public int lastIndexOf(Object o) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public ListIterator<String> listIterator() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public ListIterator<String> listIterator(int index) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public List<String> subList(int fromIndex, int toIndex) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\npublic interface Event {\r\n\r\n    int getPriority();\r\n}\npublic static class GenericEvent implements Event {\r\n\r\n    private int priority;\r\n\r\n    @Override\r\n    public int getPriority() {\r\n        return priority;\r\n    }\r\n\r\n    /**\r\n     * Constructor that takes an event priority\r\n     */\r\n    public GenericEvent(int priority) {\r\n        this.priority = priority;\r\n    }\r\n\r\n    /**\r\n     * Default Constructor\r\n     */\r\n    public GenericEvent() {\r\n    }\r\n}\npublic interface UserInitiatedEvent {\r\n}\npublic abstract static class BaseUserInitiatedEvent extends GenericEvent implements UserInitiatedEvent {\r\n}\npublic static class MessageEvent extends BaseUserInitiatedEvent {\r\n}\npublic interface Channel<E extends Event> {\r\n\r\n    void send(E event);\r\n\r\n    void subscribe(final Receiver<E> receiver, Class<E> event);\r\n\r\n    void unsubscribe(final Receiver<E> receiver, Class<E> event);\r\n}\npublic interface Broadcaster {\r\n}\npublic interface EventBroadcaster extends Broadcaster {\r\n\r\n    void subscribe();\r\n\r\n    void unsubscribe();\r\n\r\n    void setChannel(Channel<?> channel);\r\n}\npublic static class GenericBroadcasterImpl implements Broadcaster {\r\n}\n@SuppressWarnings({ \"unused\", \"unchecked\" })\r\npublic abstract static class GenericEventBroadcasterImpl<T extends Event> extends GenericBroadcasterImpl implements EventBroadcaster {\r\n\r\n    private Class<T>[] subscribingEvents;\r\n\r\n    private Channel<T> channel;\r\n\r\n    /**\r\n     * Abstract method to retrieve instance of subclass\r\n     *\r\n     * @return receiver instance\r\n     */\r\n    public abstract Receiver<T> getInstance();\r\n\r\n    @Override\r\n    public void setChannel(Channel channel) {\r\n        this.channel = channel;\r\n    }\r\n\r\n    private String beanName;\r\n\r\n    public void setBeanName(String name) {\r\n        this.beanName = name;\r\n    }\r\n\r\n    @Override\r\n    public void subscribe() {\r\n    }\r\n\r\n    @Override\r\n    public void unsubscribe() {\r\n    }\r\n\r\n    public GenericEventBroadcasterImpl(Class<? extends T>... events) {\r\n    }\r\n}\npublic interface Receiver<E extends Event> {\r\n\r\n    void receive(E event);\r\n}\npublic interface MessageBroadcaster extends Receiver<MessageEvent> {\r\n}\npublic static class RemovedMessageEvent extends MessageEvent {\r\n}\npublic static class NewMessageEvent extends MessageEvent {\r\n}\npublic static class ModifiedMessageEvent extends MessageEvent {\r\n}\n@SuppressWarnings({ \"serial\", \"unchecked\" })\r\npublic static class MessageBroadcasterImpl extends GenericEventBroadcasterImpl<MessageEvent> implements // implement an unrelated interface first (SPR-16288)\r\nSerializable, MessageBroadcaster {\r\n\r\n    public MessageBroadcasterImpl() {\r\n        super(NewMessageEvent.class);\r\n    }\r\n\r\n    @Override\r\n    public void receive(MessageEvent event) {\r\n        throw new UnsupportedOperationException(\"should not be called, use subclassed events\");\r\n    }\r\n\r\n    public void receive(NewMessageEvent event) {\r\n    }\r\n\r\n    @Override\r\n    public Receiver<MessageEvent> getInstance() {\r\n        return null;\r\n    }\r\n\r\n    public void receive(RemovedMessageEvent event) {\r\n    }\r\n\r\n    public void receive(ModifiedMessageEvent event) {\r\n    }\r\n}\n//-----------------------------\r\n// SPR-2454 Test Classes\r\n//-----------------------------\r\npublic interface SimpleGenericRepository<T> {\r\n\r\n    Class<T> getPersistentClass();\r\n\r\n    List<T> findByQuery();\r\n\r\n    List<T> findAll();\r\n\r\n    T refresh(T entity);\r\n\r\n    T saveOrUpdate(T entity);\r\n\r\n    void delete(Collection<T> entities);\r\n}\npublic interface RepositoryRegistry {\r\n\r\n    <T> SimpleGenericRepository<T> getFor(Class<T> entityType);\r\n}\n@SuppressWarnings(\"unchecked\")\r\npublic static class SettableRepositoryRegistry<R extends SimpleGenericRepository<?>> implements RepositoryRegistry {\r\n\r\n    protected void injectInto(R rep) {\r\n    }\r\n\r\n    public void register(R rep) {\r\n    }\r\n\r\n    public void register(R... reps) {\r\n    }\r\n\r\n    public void setRepos(R... reps) {\r\n    }\r\n\r\n    @Override\r\n    public <T> SimpleGenericRepository<T> getFor(Class<T> entityType) {\r\n        return null;\r\n    }\r\n\r\n    public void afterPropertiesSet() {\r\n    }\r\n}\npublic interface ConvenientGenericRepository<T, ID extends Serializable> extends SimpleGenericRepository<T> {\r\n\r\n    T findById(ID id, boolean lock);\r\n\r\n    List<T> findByExample(T exampleInstance);\r\n\r\n    void delete(ID id);\r\n\r\n    void delete(T entity);\r\n}\npublic static class GenericHibernateRepository<T, ID extends Serializable> implements ConvenientGenericRepository<T, ID> {\r\n\r\n    /**\r\n     * @param c Mandatory. The domain class this repository is responsible for.\r\n     */\r\n    // Since it is impossible to determine the actual type of a type\r\n    // parameter (!), we resort to requiring the caller to provide the\r\n    // actual type as parameter, too.\r\n    // Not set in a constructor to enable easy CGLIB-proxying (passing\r\n    // constructor arguments to Spring AOP proxies is quite cumbersome).\r\n    public void setPersistentClass(Class<T> c) {\r\n    }\r\n\r\n    @Override\r\n    public Class<T> getPersistentClass() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public T findById(ID id, boolean lock) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public List<T> findAll() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public List<T> findByExample(T exampleInstance) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public List<T> findByQuery() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public T saveOrUpdate(T entity) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void delete(T entity) {\r\n    }\r\n\r\n    @Override\r\n    public T refresh(T entity) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void delete(ID id) {\r\n    }\r\n\r\n    @Override\r\n    public void delete(Collection<T> entities) {\r\n    }\r\n}\npublic static class HibernateRepositoryRegistry extends SettableRepositoryRegistry<GenericHibernateRepository<?, ?>> {\r\n\r\n    @Override\r\n    public void injectInto(GenericHibernateRepository<?, ?> rep) {\r\n    }\r\n\r\n    @Override\r\n    public <T> GenericHibernateRepository<T, ?> getFor(Class<T> entityType) {\r\n        return null;\r\n    }\r\n}\n//-------------------\r\n// SPR-2603 classes\r\n//-------------------\r\npublic interface Homer<E> {\r\n\r\n    void foo(E e);\r\n}\npublic static class MyHomer<T extends Bounded<T>, L extends T> implements Homer<L> {\r\n\r\n    @Override\r\n    public void foo(L t) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\npublic static class YourHomer<T extends AbstractBounded<T>, L extends T> extends MyHomer<T, L> {\r\n\r\n    @Override\r\n    public void foo(L t) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\npublic interface GenericDao<T> {\r\n\r\n    void saveOrUpdate(T t);\r\n}\npublic interface ConvenienceGenericDao<T> extends GenericDao<T> {\r\n}\npublic static class GenericSqlMapDao<T extends Serializable> implements ConvenienceGenericDao<T> {\r\n\r\n    @Override\r\n    public void saveOrUpdate(T t) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\npublic static class GenericSqlMapIntegerDao<T extends Number> extends GenericSqlMapDao<T> {\r\n\r\n    @Override\r\n    public void saveOrUpdate(T t) {\r\n    }\r\n}\npublic static class Permission {\r\n}\npublic static class User {\r\n}\npublic interface UserDao {\r\n\r\n    // @Transactional\r\n    void save(User user);\r\n\r\n    // @Transactional\r\n    void save(Permission perm);\r\n}\npublic abstract static class AbstractDao<T> {\r\n\r\n    public void save(T t) {\r\n    }\r\n\r\n    public void saveVararg(T t, Object... args) {\r\n    }\r\n}\npublic static class UserDaoImpl extends AbstractDao<User> implements UserDao {\r\n\r\n    @Override\r\n    public void save(Permission perm) {\r\n    }\r\n\r\n    @Override\r\n    public void saveVararg(User user, Object... args) {\r\n    }\r\n}\npublic interface DaoInterface<T, P> {\r\n\r\n    T get(P id);\r\n}\npublic abstract static class BusinessGenericDao<T, PK extends Serializable> implements DaoInterface<T, PK> {\r\n\r\n    public void save(T object) {\r\n    }\r\n}\npublic static class Business<T> {\r\n}\npublic static class BusinessDao extends BusinessGenericDao<Business<?>, Long> {\r\n\r\n    @Override\r\n    public void save(Business<?> business) {\r\n    }\r\n\r\n    @Override\r\n    public Business<?> get(Long id) {\r\n        return null;\r\n    }\r\n\r\n    public Business<?> get(String code) {\r\n        return null;\r\n    }\r\n}\n//-------------------\r\n// SPR-3304 classes\r\n//-------------------\r\nprivate static class MegaEvent {\r\n}\nprivate static class MegaMessageEvent extends MegaEvent {\r\n}\nprivate static class NewMegaMessageEvent extends MegaEvent {\r\n}\nprivate static class ModifiedMegaMessageEvent extends MegaEvent {\r\n}\npublic interface MegaReceiver<E extends MegaEvent> {\r\n\r\n    void receive(E event);\r\n}\npublic interface MegaMessageProducer extends MegaReceiver<MegaMessageEvent> {\r\n}\nprivate static class Other<S, E> {\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {\r\n\r\n    public void receive(NewMegaMessageEvent event) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    public void receive(ModifiedMegaMessageEvent event) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @Override\r\n    public void receive(MegaMessageEvent event) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\n//-------------------\r\n// SPR-3357 classes\r\n//-------------------\r\nprivate static class DomainObjectSuper {\r\n}\nprivate static class DomainObjectExtendsSuper extends DomainObjectSuper {\r\n}\npublic interface IGenericInterface<D extends DomainObjectSuper> {\r\n\r\n    <T> void doSomething(final D domainObject, final T value);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate abstract static class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {\r\n\r\n    @Override\r\n    public <T> void doSomething(D domainObject, T value) {\r\n    }\r\n\r\n    public void anotherBaseMethod() {\r\n    }\r\n}\nprivate static class ExtendsAbstractImplementsInterface extends AbstractImplementsInterface<DomainObjectExtendsSuper> {\r\n\r\n    @Override\r\n    public <T> void doSomething(DomainObjectExtendsSuper domainObject, T value) {\r\n        super.doSomething(domainObject, value);\r\n    }\r\n}\n//-------------------\r\n// SPR-3485 classes\r\n//-------------------\r\n@SuppressWarnings(\"serial\")\r\nprivate static class ParameterType implements Serializable {\r\n}\nprivate static class AbstractDomainObject<P extends Serializable, R> {\r\n\r\n    public R method1(P p) {\r\n        return null;\r\n    }\r\n\r\n    public void method2(P p, R r) {\r\n    }\r\n}\nprivate static class DomainObject extends AbstractDomainObject<ParameterType, byte[]> {\r\n\r\n    @Override\r\n    public byte[] method1(ParameterType p) {\r\n        return super.method1(p);\r\n    }\r\n\r\n    @Override\r\n    public void method2(ParameterType p, byte[] r) {\r\n        super.method2(p, r);\r\n    }\r\n}\n//-------------------\r\n// SPR-3534 classes\r\n//-------------------\r\npublic interface SearchProvider<RETURN_TYPE, CONDITIONS_TYPE> {\r\n\r\n    Collection<RETURN_TYPE> findBy(CONDITIONS_TYPE conditions);\r\n}\npublic static class SearchConditions {\r\n}\npublic interface IExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<?>> extends SearchProvider<S, T> {\r\n}\npublic static class ExternalMessage {\r\n}\npublic static class ExternalMessageSearchConditions<T extends ExternalMessage> extends SearchConditions {\r\n}\npublic static class ExternalMessageProvider<S extends ExternalMessage, T extends ExternalMessageSearchConditions<S>> implements IExternalMessageProvider<S, T> {\r\n\r\n    @Override\r\n    public Collection<S> findBy(T conditions) {\r\n        return null;\r\n    }\r\n}\npublic static class EmailMessage extends ExternalMessage {\r\n}\npublic static class EmailSearchConditions extends ExternalMessageSearchConditions<EmailMessage> {\r\n}\npublic static class EmailMessageProvider extends ExternalMessageProvider<EmailMessage, EmailSearchConditions> {\r\n}\npublic static class TestEmailProvider extends EmailMessageProvider {\r\n\r\n    @Override\r\n    public Collection<EmailMessage> findBy(EmailSearchConditions conditions) {\r\n        return null;\r\n    }\r\n}\n//-------------------\r\n// SPR-16103 classes\r\n//-------------------\r\npublic abstract static class BaseEntity {\r\n}\npublic static class FooEntity extends BaseEntity {\r\n}\npublic static class BaseClass<T> {\r\n\r\n    public <S extends T> S test(S T) {\r\n        return null;\r\n    }\r\n}\npublic static class EntityClass<T extends BaseEntity> extends BaseClass<T> {\r\n\r\n    @Override\r\n    public <S extends T> S test(S T) {\r\n        return null;\r\n    }\r\n}\npublic static class FooClass extends EntityClass<FooEntity> {\r\n\r\n    @Override\r\n    public <S extends FooEntity> S test(S T) {\r\n        return null;\r\n    }\r\n}\npublic interface BaseInterface<T> {\r\n\r\n    <S extends T> S test(S T);\r\n}\npublic interface EntityInterface<T extends BaseEntity> extends BaseInterface<T> {\r\n\r\n    @Override\r\n    <S extends T> S test(S T);\r\n}\npublic interface FooInterface extends EntityInterface<FooEntity> {\r\n\r\n    @Override\r\n    <S extends FooEntity> S test(S T);\r\n}",
    "comment": "\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findMethodWithReturnType(String,Class<?>,Class<SettingsDaoImpl>)",
    "entityType": "method",
    "code": "private static Method findMethodWithReturnType(String name, Class<?> returnType, Class<SettingsDaoImpl> targetType) {\r\n    Method[] methods = targetType.getMethods();\r\n    for (Method m : methods) {\r\n        if (m.getName().equals(name) && m.getReturnType().equals(returnType)) {\r\n            return m;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethod() throws Exception {\r\n    Method unbridged = MyFoo.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\r\n    Method bridged = MyFoo.class.getDeclaredMethod(\"someMethod\", Serializable.class, Object.class);\r\n    assertThat(unbridged.isBridge()).isFalse();\r\n    assertThat(bridged.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedVarargMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedVarargMethod() throws Exception {\r\n    Method unbridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", String.class, Object[].class);\r\n    Method bridged = MyFoo.class.getDeclaredMethod(\"someVarargMethod\", Serializable.class, Object[].class);\r\n    assertThat(unbridged.isBridge()).isFalse();\r\n    assertThat(bridged.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(unbridged)).as(\"Unbridged method not returned directly\").isEqualTo(unbridged);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridged)).as(\"Incorrect bridged method returned\").isEqualTo(unbridged);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethodInHierarchy()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethodInHierarchy() throws Exception {\r\n    Method bridgeMethod = DateAdder.class.getMethod(\"add\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"add\");\r\n    assertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\r\n    assertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethodFromOriginalMethodInHierarchy()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethodFromOriginalMethodInHierarchy() throws Exception {\r\n    Method originalMethod = Adder.class.getMethod(\"add\", Object.class);\r\n    assertThat(originalMethod.isBridge()).isFalse();\r\n    Method bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, DateAdder.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"add\");\r\n    assertThat(bridgedMethod.getParameterCount()).isEqualTo(1);\r\n    assertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(Date.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethodFromOriginalMethodNotInHierarchy()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethodFromOriginalMethodNotInHierarchy() throws Exception {\r\n    Method originalMethod = Adder.class.getMethod(\"add\", Object.class);\r\n    Method mostSpecificMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, FakeAdder.class);\r\n    assertThat(mostSpecificMethod).isSameAs(originalMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethodInHierarchyWithBoundedGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethodInHierarchyWithBoundedGenerics() throws Exception {\r\n    Method originalMethod = Bar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\r\n    assertThat(originalMethod.isBridge()).isFalse();\r\n    Method bridgedMethod = BridgeMethodResolver.getMostSpecificMethod(originalMethod, SubBar.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"someMethod\");\r\n    assertThat(bridgedMethod.getParameterCount()).isEqualTo(2);\r\n    assertThat(bridgedMethod.getParameterTypes()[0]).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#isBridgeMethodFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid isBridgeMethodFor() throws Exception {\r\n    Method bridged = MyBar.class.getDeclaredMethod(\"someMethod\", String.class, Object.class);\r\n    Method other = MyBar.class.getDeclaredMethod(\"someMethod\", Integer.class, Object.class);\r\n    Method bridge;\r\n    if (IdeUtils.runningInEclipse()) {\r\n        bridge = InterBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\r\n    } else {\r\n        bridge = MyBar.class.getDeclaredMethod(\"someMethod\", Object.class, Object.class);\r\n    }\r\n    assertThat(bridge.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, bridged, MyBar.class)).as(\"Should be bridge method\").isTrue();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridge, other, MyBar.class)).as(\"Should not be bridge method\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#doubleParameterization()",
    "entityType": "method",
    "code": "@Test\r\nvoid doubleParameterization() throws Exception {\r\n    Method objectBridge = MyBoo.class.getDeclaredMethod(\"foo\", Object.class);\r\n    Method serializableBridge = MyBoo.class.getDeclaredMethod(\"foo\", Serializable.class);\r\n    Method stringFoo = MyBoo.class.getDeclaredMethod(\"foo\", String.class);\r\n    Method integerFoo = MyBoo.class.getDeclaredMethod(\"foo\", Integer.class);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(objectBridge)).as(\"foo(String) not resolved.\").isEqualTo(stringFoo);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(serializableBridge)).as(\"foo(Integer) not resolved.\").isEqualTo(integerFoo);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethodFromMultipleBridges()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethodFromMultipleBridges() throws Exception {\r\n    Method loadWithObjectReturn = findMethodWithReturnType(\"load\", Object.class, SettingsDaoImpl.class);\r\n    assertThat(loadWithObjectReturn).isNotNull();\r\n    Method loadWithSettingsReturn = findMethodWithReturnType(\"load\", Settings.class, SettingsDaoImpl.class);\r\n    assertThat(loadWithSettingsReturn).isNotNull();\r\n    assertThat(loadWithSettingsReturn).isNotSameAs(loadWithObjectReturn);\r\n    Method method = SettingsDaoImpl.class.getMethod(\"load\");\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(loadWithObjectReturn)).isEqualTo(method);\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(loadWithSettingsReturn)).isEqualTo(method);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#findBridgedMethodFromParent()",
    "entityType": "method",
    "code": "@Test\r\nvoid findBridgedMethodFromParent() throws Exception {\r\n    Method loadFromParentBridge = SettingsDaoImpl.class.getMethod(\"loadFromParent\");\r\n    assertThat(loadFromParentBridge.isBridge()).isTrue();\r\n    Method loadFromParent = AbstractDaoImpl.class.getMethod(\"loadFromParent\");\r\n    assertThat(loadFromParent.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(loadFromParentBridge)).isEqualTo(loadFromParent);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#withSingleBoundParameterizedOnInstantiate()",
    "entityType": "method",
    "code": "@Test\r\nvoid withSingleBoundParameterizedOnInstantiate() throws Exception {\r\n    Method bridgeMethod = DelayQueue.class.getMethod(\"add\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method actualMethod = DelayQueue.class.getMethod(\"add\", Delayed.class);\r\n    assertThat(actualMethod.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#withDoubleBoundParameterizedOnInstantiate()",
    "entityType": "method",
    "code": "@Test\r\nvoid withDoubleBoundParameterizedOnInstantiate() throws Exception {\r\n    Method bridgeMethod = SerializableBounded.class.getMethod(\"boundedOperation\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method actualMethod = SerializableBounded.class.getMethod(\"boundedOperation\", HashMap.class);\r\n    assertThat(actualMethod.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(actualMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#withGenericParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid withGenericParameter() {\r\n    Method[] methods = StringGenericParameter.class.getMethods();\r\n    Method bridgeMethod = null;\r\n    Method bridgedMethod = null;\r\n    for (Method method : methods) {\r\n        if (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\r\n            if (method.getReturnType().equals(Object.class)) {\r\n                bridgeMethod = method;\r\n            } else {\r\n                bridgedMethod = method;\r\n            }\r\n        }\r\n    }\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    boolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\r\n    assertThat(condition).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#onAllMethods()",
    "entityType": "method",
    "code": "@Test\r\nvoid onAllMethods() {\r\n    Method[] methods = StringList.class.getMethods();\r\n    for (Method method : methods) {\r\n        assertThat(BridgeMethodResolver.findBridgedMethod(method)).isNotNull();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr2583()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr2583() throws Exception {\r\n    Method bridgedMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", MessageEvent.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", Event.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    Method otherMethod = MessageBroadcasterImpl.class.getMethod(\"receive\", NewMessageEvent.class);\r\n    assertThat(otherMethod.isBridge()).isFalse();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, otherMethod, MessageBroadcasterImpl.class)).as(\"Match identified incorrectly\").isFalse();\r\n    assertThat(BridgeMethodResolver.isBridgeMethodFor(bridgeMethod, bridgedMethod, MessageBroadcasterImpl.class)).as(\"Match not found correctly\").isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr2603()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr2603() throws Exception {\r\n    Method objectBridge = YourHomer.class.getDeclaredMethod(\"foo\", Bounded.class);\r\n    Method abstractBoundedFoo = YourHomer.class.getDeclaredMethod(\"foo\", AbstractBounded.class);\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(objectBridge);\r\n    assertThat(bridgedMethod).as(\"foo(AbstractBounded) not resolved.\").isEqualTo(abstractBoundedFoo);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr2648()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr2648() {\r\n    Method bridgeMethod = ReflectionUtils.findMethod(GenericSqlMapIntegerDao.class, \"saveOrUpdate\", Object.class);\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"saveOrUpdate\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr2763()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr2763() throws Exception {\r\n    Method bridgedMethod = AbstractDao.class.getDeclaredMethod(\"save\", Object.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"save\", User.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3041()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3041() throws Exception {\r\n    Method bridgedMethod = BusinessDao.class.getDeclaredMethod(\"save\", Business.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = BusinessDao.class.getDeclaredMethod(\"save\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3173()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3173() throws Exception {\r\n    Method bridgedMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", User.class, Object[].class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = UserDaoImpl.class.getDeclaredMethod(\"saveVararg\", Object.class, Object[].class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3304()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3304() throws Exception {\r\n    Method bridgedMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaMessageEvent.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = MegaMessageProducerImpl.class.getDeclaredMethod(\"receive\", MegaEvent.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3324()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3324() throws Exception {\r\n    Method bridgedMethod = BusinessDao.class.getDeclaredMethod(\"get\", Long.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = BusinessDao.class.getDeclaredMethod(\"get\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3357()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3357() throws Exception {\r\n    Method bridgedMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\"doSomething\", DomainObjectExtendsSuper.class, Object.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = ExtendsAbstractImplementsInterface.class.getDeclaredMethod(\"doSomething\", DomainObjectSuper.class, Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3485()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3485() throws Exception {\r\n    Method bridgedMethod = DomainObject.class.getDeclaredMethod(\"method2\", ParameterType.class, byte[].class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    Method bridgeMethod = DomainObject.class.getDeclaredMethod(\"method2\", Serializable.class, Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(BridgeMethodResolver.findBridgedMethod(bridgeMethod)).isEqualTo(bridgedMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#spr3534()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr3534() {\r\n    Method bridgeMethod = ReflectionUtils.findMethod(TestEmailProvider.class, \"findBy\", Object.class);\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(bridgeMethod);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getName()).isEqualTo(\"findBy\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolverTests#testClassHierarchy()",
    "entityType": "method",
    "code": "// SPR-16103\r\n@Test\r\nvoid testClassHierarchy() throws Exception {\r\n    doTestHierarchyResolution(FooClass.class);\r\n}",
    "comment": ""
  }
]