[
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#findValueOfType()",
    "entityType": "method",
    "code": "@Test\r\nvoid findValueOfType() {\r\n    List<Integer> integerList = new ArrayList<>();\r\n    integerList.add(1);\r\n    assertThat(CollectionUtils.findValueOfType(integerList, Integer.class)).isEqualTo(1);\r\n    Set<Integer> integerSet = new HashSet<>();\r\n    integerSet.add(2);\r\n    assertThat(CollectionUtils.findValueOfType(integerSet, Integer.class)).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#findValueOfTypeWithEmptyCollection()",
    "entityType": "method",
    "code": "@Test\r\nvoid findValueOfTypeWithEmptyCollection() {\r\n    List<Integer> emptyList = new ArrayList<>();\r\n    assertThat(CollectionUtils.findValueOfType(emptyList, Integer.class)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#findValueOfTypeWithMoreThanOneValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid findValueOfTypeWithMoreThanOneValue() {\r\n    List<Integer> integerList = new ArrayList<>();\r\n    integerList.add(1);\r\n    integerList.add(2);\r\n    assertThat(CollectionUtils.findValueOfType(integerList, Integer.class)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#hasUniqueObject()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUniqueObject() {\r\n    List<String> list = new ArrayList<>();\r\n    list.add(\"myElement\");\r\n    list.add(\"myOtherElement\");\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\r\n    list = new ArrayList<>();\r\n    list.add(\"myElement\");\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isTrue();\r\n    list = new ArrayList<>();\r\n    list.add(\"myElement\");\r\n    list.add(null);\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\r\n    list = new ArrayList<>();\r\n    list.add(null);\r\n    list.add(\"myElement\");\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\r\n    list = new ArrayList<>();\r\n    list.add(null);\r\n    list.add(null);\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isTrue();\r\n    list = new ArrayList<>();\r\n    list.add(null);\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isTrue();\r\n    list = new ArrayList<>();\r\n    assertThat(CollectionUtils.hasUniqueObject(list)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#findCommonElementType()",
    "entityType": "method",
    "code": "@Test\r\nvoid findCommonElementType() {\r\n    List<Integer> integerList = new ArrayList<>();\r\n    integerList.add(1);\r\n    integerList.add(2);\r\n    assertThat(CollectionUtils.findCommonElementType(integerList)).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#findCommonElementTypeWithEmptyCollection()",
    "entityType": "method",
    "code": "@Test\r\nvoid findCommonElementTypeWithEmptyCollection() {\r\n    List<Integer> emptyList = new ArrayList<>();\r\n    assertThat(CollectionUtils.findCommonElementType(emptyList)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#findCommonElementTypeWithDifferentElementType()",
    "entityType": "method",
    "code": "@Test\r\nvoid findCommonElementTypeWithDifferentElementType() {\r\n    List<Object> list = new ArrayList<>();\r\n    list.add(1);\r\n    list.add(\"foo\");\r\n    assertThat(CollectionUtils.findCommonElementType(list)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#firstElementWithSet()",
    "entityType": "method",
    "code": "@Test\r\nvoid firstElementWithSet() {\r\n    Set<Integer> set = new HashSet<>();\r\n    set.add(17);\r\n    set.add(3);\r\n    set.add(2);\r\n    set.add(1);\r\n    assertThat(CollectionUtils.firstElement(set)).isEqualTo(17);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#firstElementWithSortedSet()",
    "entityType": "method",
    "code": "@Test\r\nvoid firstElementWithSortedSet() {\r\n    SortedSet<Integer> sortedSet = new TreeSet<>();\r\n    sortedSet.add(17);\r\n    sortedSet.add(3);\r\n    sortedSet.add(2);\r\n    sortedSet.add(1);\r\n    assertThat(CollectionUtils.firstElement(sortedSet)).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#firstElementWithList()",
    "entityType": "method",
    "code": "@Test\r\nvoid firstElementWithList() {\r\n    List<Integer> list = new ArrayList<>();\r\n    list.add(1);\r\n    list.add(2);\r\n    list.add(3);\r\n    assertThat(CollectionUtils.firstElement(list)).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#lastElementWithSet()",
    "entityType": "method",
    "code": "@Test\r\nvoid lastElementWithSet() {\r\n    Set<Integer> set = new HashSet<>();\r\n    set.add(17);\r\n    set.add(3);\r\n    set.add(2);\r\n    set.add(1);\r\n    assertThat(CollectionUtils.lastElement(set)).isEqualTo(3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#lastElementWithSortedSet()",
    "entityType": "method",
    "code": "@Test\r\nvoid lastElementWithSortedSet() {\r\n    SortedSet<Integer> sortedSet = new TreeSet<>();\r\n    sortedSet.add(17);\r\n    sortedSet.add(3);\r\n    sortedSet.add(2);\r\n    sortedSet.add(1);\r\n    assertThat(CollectionUtils.lastElement(sortedSet)).isEqualTo(17);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#lastElementWithList()",
    "entityType": "method",
    "code": "@Test\r\nvoid lastElementWithList() {\r\n    List<Integer> list = new ArrayList<>();\r\n    list.add(1);\r\n    list.add(2);\r\n    list.add(3);\r\n    assertThat(CollectionUtils.lastElement(list)).isEqualTo(3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#toArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid toArray() {\r\n    Vector<String> vector = new Vector<>();\r\n    vector.add(\"foo\");\r\n    vector.add(\"bar\");\r\n    Enumeration<String> enumeration = vector.elements();\r\n    assertThat(CollectionUtils.toArray(enumeration, new String[] ;)).containsExactly(\"foo\", \"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#conversionOfEmptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid conversionOfEmptyMap() {\r\n    MultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(new HashMap<>());\r\n    assertThat(asMultiValueMap).isEmpty();\r\n    assertThat(asMultiValueMap).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#conversionOfNonEmptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid conversionOfNonEmptyMap() {\r\n    Map<String, List<String>> wrapped = new HashMap<>();\r\n    wrapped.put(\"key\", Arrays.asList(\"first\", \"second\"));\r\n    MultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(wrapped);\r\n    assertThat(asMultiValueMap).containsAllEntriesOf(wrapped);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#changesValueByReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid changesValueByReference() {\r\n    Map<String, List<String>> wrapped = new HashMap<>();\r\n    MultiValueMap<String, String> asMultiValueMap = CollectionUtils.toMultiValueMap(wrapped);\r\n    assertThat(asMultiValueMap).doesNotContainKeys(\"key\");\r\n    wrapped.put(\"key\", new ArrayList<>());\r\n    assertThat(asMultiValueMap).containsKey(\"key\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollectionUtilsTests#compositeMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid compositeMap() {\r\n    Map<String, String> first = new HashMap<>();\r\n    first.put(\"key1\", \"value1\");\r\n    first.put(\"key2\", \"value2\");\r\n    Map<String, String> second = new HashMap<>();\r\n    second.put(\"key3\", \"value3\");\r\n    second.put(\"key4\", \"value4\");\r\n    Map<String, String> compositeMap = CollectionUtils.compositeMap(first, second);\r\n    assertThat(compositeMap).containsKeys(\"key1\", \"key2\", \"key3\", \"key4\");\r\n    assertThat(compositeMap).containsValues(\"value1\", \"value2\", \"value3\", \"value4\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Instance",
    "entityType": "class",
    "code": "private final String name;\npublic Instance(String name) {\r\n    this.name = name;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object rhs) {\r\n    if (this == rhs) {\r\n        return true;\r\n    }\r\n    if (rhs == null || this.getClass() != rhs.getClass()) {\r\n        return false;\r\n    }\r\n    Instance instance = (Instance) rhs;\r\n    return this.name.equals(instance.name);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.name.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Instance#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object rhs) {\r\n    if (this == rhs) {\r\n        return true;\r\n    }\r\n    if (rhs == null || this.getClass() != rhs.getClass()) {\r\n        return false;\r\n    }\r\n    Instance instance = (Instance) rhs;\r\n    return this.name.equals(instance.name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Instance#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.name.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates",
    "entityType": "class",
    "code": "ReflectionHintsPredicates() {\r\n}\n/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given type.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param typeReference the type\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic TypeHintPredicate onType(TypeReference typeReference) {\r\n    Assert.notNull(typeReference, \"'typeReference' must not be null\");\r\n    return new TypeHintPredicate(typeReference);\r\n}\n/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given type.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param type the type\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic TypeHintPredicate onType(Class<?> type) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    return new TypeHintPredicate(TypeReference.of(type));\r\n}\n/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given constructor.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param constructor the constructor\r\n * @return the {@link RuntimeHints} predicate\r\n * @deprecated since 7.0 in favor of {@link #onConstructorInvocation(Constructor)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic ConstructorHintPredicate onConstructor(Constructor<?> constructor) {\r\n    Assert.notNull(constructor, \"'constructor' must not be null\");\r\n    return new ConstructorHintPredicate(constructor);\r\n}\n/**\r\n * Return a predicate that checks whether an invocation hint is registered for the given constructor.\r\n * @param constructor the constructor\r\n * @return the {@link RuntimeHints} predicate\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onConstructorInvocation(Constructor<?> constructor) {\r\n    Assert.notNull(constructor, \"'constructor' must not be null\");\r\n    return new ConstructorHintPredicate(constructor).invoke();\r\n}\n/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given method.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param method the method\r\n * @return the {@link RuntimeHints} predicate\r\n * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Method)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic MethodHintPredicate onMethod(Method method) {\r\n    Assert.notNull(method, \"'method' must not be null\");\r\n    return new MethodHintPredicate(method);\r\n}\n/**\r\n * Return a predicate that checks whether an invocation hint is registered for the given method.\r\n * @param method the method\r\n * @return the {@link RuntimeHints} predicate\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onMethodInvocation(Method method) {\r\n    Assert.notNull(method, \"'method' must not be null\");\r\n    return new MethodHintPredicate(method).invoke();\r\n}\n/**\r\n * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param type the type holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Class, String)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic MethodHintPredicate onMethod(Class<?> type, String methodName) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return new MethodHintPredicate(getMethod(type, methodName));\r\n}\n/**\r\n * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * @param type the type holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onMethodInvocation(Class<?> type, String methodName) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return new MethodHintPredicate(getMethod(type, methodName)).invoke();\r\n}\n/**\r\n * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param className the name of the class holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @deprecated since 7.0 in favor of {@link #onMethodInvocation(String, String)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic MethodHintPredicate onMethod(String className, String methodName) throws ClassNotFoundException {\r\n    Assert.hasText(className, \"'className' must not be empty\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return onMethod(Class.forName(className), methodName);\r\n}\n/**\r\n * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * @param className the name of the class holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onMethodInvocation(String className, String methodName) throws ClassNotFoundException {\r\n    Assert.hasText(className, \"'className' must not be empty\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return onMethod(Class.forName(className), methodName).invoke();\r\n}\nprivate Method getMethod(Class<?> type, String methodName) {\r\n    ReflectionUtils.MethodFilter selector = method -> methodName.equals(method.getName());\r\n    Set<Method> methods = MethodIntrospector.selectMethods(type, selector);\r\n    if (methods.size() == 1) {\r\n        return methods.iterator().next();\r\n    } else if (methods.size() > 1) {\r\n        throw new IllegalArgumentException(\"Found multiple methods named '%s' on class %s\".formatted(methodName, type.getName()));\r\n    } else {\r\n        throw new IllegalArgumentException(\"No method named '%s' on class %s\".formatted(methodName, type.getName()));\r\n    }\r\n}\n/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param type the type holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @deprecated since 7.0 in favor of {@link #onFieldAccess(Class, String)} with similar semantics.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Predicate<RuntimeHints> onField(Class<?> type, String fieldName) {\r\n    return onFieldAccess(type, fieldName);\r\n}\n/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param type the type holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onFieldAccess(Class<?> type, String fieldName) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.hasText(fieldName, \"'fieldName' must not be empty\");\r\n    Field field = ReflectionUtils.findField(type, fieldName);\r\n    if (field == null) {\r\n        throw new IllegalArgumentException(\"No field named '%s' on class %s\".formatted(fieldName, type.getName()));\r\n    }\r\n    return new FieldHintPredicate(field);\r\n}\n/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param className the name of the class holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @deprecated since 7.0 in favor of {@link #onFieldAccess(String, String)} with similar semantics.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Predicate<RuntimeHints> onField(String className, String fieldName) throws ClassNotFoundException {\r\n    return onFieldAccess(className, fieldName);\r\n}\n/**\r\n * Return a predicate that checks whether an invocation hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param className the name of the class holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onFieldAccess(String className, String fieldName) throws ClassNotFoundException {\r\n    Assert.hasText(className, \"'className' must not be empty\");\r\n    Assert.hasText(fieldName, \"'fieldName' must not be empty\");\r\n    return onFieldAccess(Class.forName(className), fieldName);\r\n}\n/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the given field.\r\n * @param field the field\r\n * @return the {@link RuntimeHints} predicate\r\n * @deprecated since 7.0 in favor of {@link #onFieldAccess(Field)} with similar semantics.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Predicate<RuntimeHints> onField(Field field) {\r\n    return onFieldAccess(field);\r\n}\n/**\r\n * Return a predicate that checks whether an invocation hint is registered for the given field.\r\n * @param field the field\r\n * @return the {@link RuntimeHints} predicate\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onFieldAccess(Field field) {\r\n    Assert.notNull(field, \"'field' must not be null\");\r\n    return new FieldHintPredicate(field);\r\n}\npublic static class TypeHintPredicate implements Predicate<RuntimeHints> {\r\n\r\n    private final TypeReference type;\r\n\r\n    TypeHintPredicate(TypeReference type) {\r\n        this.type = type;\r\n    }\r\n\r\n    @Nullable\r\n    private TypeHint getTypeHint(RuntimeHints hints) {\r\n        return hints.reflection().getTypeHint(this.type);\r\n    }\r\n\r\n    @Override\r\n    public boolean test(RuntimeHints hints) {\r\n        return getTypeHint(hints) != null;\r\n    }\r\n\r\n    /**\r\n     * Refine the current predicate to only match if the given {@link MemberCategory} is present.\r\n     * @param memberCategory the member category\r\n     * @return the refined {@link RuntimeHints} predicate\r\n     */\r\n    public Predicate<RuntimeHints> withMemberCategory(MemberCategory memberCategory) {\r\n        Assert.notNull(memberCategory, \"'memberCategory' must not be null\");\r\n        return and(hints -> {\r\n            TypeHint hint = getTypeHint(hints);\r\n            return (hint != null && hint.getMemberCategories().contains(memberCategory));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\r\n     * @param memberCategories the member categories\r\n     * @return the refined {@link RuntimeHints} predicate\r\n     */\r\n    public Predicate<RuntimeHints> withMemberCategories(MemberCategory... memberCategories) {\r\n        Assert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\r\n        return and(hints -> {\r\n            TypeHint hint = getTypeHint(hints);\r\n            return (hint != null && hint.getMemberCategories().containsAll(Arrays.asList(memberCategories)));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\r\n     * @param memberCategories the member categories\r\n     * @return the refined {@link RuntimeHints} predicate\r\n     */\r\n    public Predicate<RuntimeHints> withAnyMemberCategory(MemberCategory... memberCategories) {\r\n        Assert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\r\n        return and(hints -> {\r\n            TypeHint hint = getTypeHint(hints);\r\n            return (hint != null && Arrays.stream(memberCategories).anyMatch(memberCategory -> hint.getMemberCategories().contains(memberCategory)));\r\n        });\r\n    }\r\n}\n@Deprecated(since = \"7.0\", forRemoval = true)\r\n@SuppressWarnings(\"removal\")\r\npublic abstract static class ExecutableHintPredicate<T extends Executable> implements Predicate<RuntimeHints> {\r\n\r\n    protected final T executable;\r\n\r\n    protected ExecutableMode executableMode = ExecutableMode.INTROSPECT;\r\n\r\n    ExecutableHintPredicate(T executable) {\r\n        this.executable = executable;\r\n    }\r\n\r\n    /**\r\n     * Refine the current predicate to match for reflection introspection on the current type.\r\n     * @return the refined {@link RuntimeHints} predicate\r\n     */\r\n    public ExecutableHintPredicate<T> introspect() {\r\n        this.executableMode = ExecutableMode.INTROSPECT;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Refine the current predicate to match for reflection invocation on the current type.\r\n     * @return the refined {@link RuntimeHints} predicate\r\n     */\r\n    public ExecutableHintPredicate<T> invoke() {\r\n        this.executableMode = ExecutableMode.INVOKE;\r\n        return this;\r\n    }\r\n\r\n    abstract Predicate<RuntimeHints> exactMatch();\r\n\r\n    /**\r\n     * Indicate whether the specified {@code ExecutableHint} covers the\r\n     * reflection needs of the specified executable definition.\r\n     * @return {@code true} if the member matches (same type, name, and parameters),\r\n     * and the configured {@code ExecutableMode} is compatible\r\n     */\r\n    static boolean includes(ExecutableHint hint, String name, List<TypeReference> parameterTypes, ExecutableMode executableModes) {\r\n        return hint.getName().equals(name) && hint.getParameterTypes().equals(parameterTypes) && (hint.getMode().equals(ExecutableMode.INVOKE) || !executableModes.equals(ExecutableMode.INVOKE));\r\n    }\r\n}\n@Deprecated(since = \"7.0\", forRemoval = true)\r\n@SuppressWarnings(\"removal\")\r\npublic static class ConstructorHintPredicate extends ExecutableHintPredicate<Constructor<?>> {\r\n\r\n    ConstructorHintPredicate(Constructor<?> constructor) {\r\n        super(constructor);\r\n    }\r\n\r\n    @Override\r\n    public boolean test(RuntimeHints runtimeHints) {\r\n        return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE)).or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS).and(hints -> this.executableMode == ExecutableMode.INVOKE)).or(exactMatch()).test(runtimeHints);\r\n    }\r\n\r\n    @Override\r\n    Predicate<RuntimeHints> exactMatch() {\r\n        return hints -> {\r\n            TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n            return (hint != null && hint.constructors().anyMatch(executableHint -> {\r\n                List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n                return includes(executableHint, \"<init>\", parameters, this.executableMode);\r\n            }));\r\n        };\r\n    }\r\n}\n@Deprecated(since = \"7.0\", forRemoval = true)\r\n@SuppressWarnings(\"removal\")\r\npublic static class MethodHintPredicate extends ExecutableHintPredicate<Method> {\r\n\r\n    MethodHintPredicate(Method method) {\r\n        super(method);\r\n    }\r\n\r\n    @Override\r\n    public boolean test(RuntimeHints runtimeHints) {\r\n        return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS).and(hints -> !Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or(exactMatch()).test(runtimeHints);\r\n    }\r\n\r\n    @Override\r\n    Predicate<RuntimeHints> exactMatch() {\r\n        return hints -> {\r\n            TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n            return (hint != null && hint.methods().anyMatch(executableHint -> {\r\n                List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n                return includes(executableHint, this.executable.getName(), parameters, this.executableMode);\r\n            }));\r\n        };\r\n    }\r\n}\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic static class FieldHintPredicate implements Predicate<RuntimeHints> {\r\n\r\n    private final Field field;\r\n\r\n    FieldHintPredicate(Field field) {\r\n        this.field = field;\r\n    }\r\n\r\n    @Override\r\n    public boolean test(RuntimeHints runtimeHints) {\r\n        TypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\r\n        if (typeHint == null) {\r\n            return false;\r\n        }\r\n        return memberCategoryMatch(typeHint) || exactMatch(typeHint);\r\n    }\r\n\r\n    @SuppressWarnings(\"removal\")\r\n    private boolean memberCategoryMatch(TypeHint typeHint) {\r\n        if (Modifier.isPublic(this.field.getModifiers())) {\r\n            return typeHint.getMemberCategories().contains(MemberCategory.ACCESS_PUBLIC_FIELDS) || typeHint.getMemberCategories().contains(MemberCategory.PUBLIC_FIELDS);\r\n        } else {\r\n            return typeHint.getMemberCategories().contains(MemberCategory.ACCESS_DECLARED_FIELDS) || typeHint.getMemberCategories().contains(MemberCategory.DECLARED_FIELDS);\r\n        }\r\n    }\r\n\r\n    private boolean exactMatch(TypeHint typeHint) {\r\n        return typeHint.fields().anyMatch(fieldHint -> this.field.getName().equals(fieldHint.getName()));\r\n    }\r\n}",
    "comment": "\n * Generator of {@link ReflectionHints} predicates, testing whether the given hints\n * match the expected behavior for reflection.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given type.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param typeReference the type\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic TypeHintPredicate onType(TypeReference typeReference) {\r\n    Assert.notNull(typeReference, \"'typeReference' must not be null\");\r\n    return new TypeHintPredicate(typeReference);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param typeReference the type\n\t * @return the {@link RuntimeHints} predicate\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given type.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param type the type\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic TypeHintPredicate onType(Class<?> type) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    return new TypeHintPredicate(TypeReference.of(type));\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflection hint is registered for the given type.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type\n\t * @return the {@link RuntimeHints} predicate\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onConstructor(Constructor<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given constructor.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param constructor the constructor\r\n * @return the {@link RuntimeHints} predicate\r\n * @deprecated since 7.0 in favor of {@link #onConstructorInvocation(Constructor)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic ConstructorHintPredicate onConstructor(Constructor<?> constructor) {\r\n    Assert.notNull(constructor, \"'constructor' must not be null\");\r\n    return new ConstructorHintPredicate(constructor);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflection hint is registered for the given constructor.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onConstructorInvocation(Constructor)}\n\t * or {@link #onType(Class)}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onConstructorInvocation(Constructor<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether an invocation hint is registered for the given constructor.\r\n * @param constructor the constructor\r\n * @return the {@link RuntimeHints} predicate\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onConstructorInvocation(Constructor<?> constructor) {\r\n    Assert.notNull(constructor, \"'constructor' must not be null\");\r\n    return new ConstructorHintPredicate(constructor).invoke();\r\n}",
    "comment": "\n\t * Return a predicate that checks whether an invocation hint is registered for the given constructor.\n\t * @param constructor the constructor\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the given method.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param method the method\r\n * @return the {@link RuntimeHints} predicate\r\n * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Method)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic MethodHintPredicate onMethod(Method method) {\r\n    Assert.notNull(method, \"'method' must not be null\");\r\n    return new MethodHintPredicate(method);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflection hint is registered for the given method.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Method)}\n\t * or {@link #onType(Class)}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onMethodInvocation(Method)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether an invocation hint is registered for the given method.\r\n * @param method the method\r\n * @return the {@link RuntimeHints} predicate\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onMethodInvocation(Method method) {\r\n    Assert.notNull(method, \"'method' must not be null\");\r\n    return new MethodHintPredicate(method).invoke();\r\n}",
    "comment": "\n\t * Return a predicate that checks whether an invocation hint is registered for the given method.\n\t * @param method the method\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onMethod(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param type the type holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Class, String)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic MethodHintPredicate onMethod(Class<?> type, String methodName) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return new MethodHintPredicate(getMethod(type, methodName));\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(Class, String)}\n\t * or {@link #onType(Class)}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onMethodInvocation(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * @param type the type holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onMethodInvocation(Class<?> type, String methodName) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return new MethodHintPredicate(getMethod(type, methodName)).invoke();\r\n}",
    "comment": "\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param type the type holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onMethod(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * By default, both introspection and invocation hints match.\r\n * <p>The returned type exposes additional methods that refine the predicate behavior.\r\n * @param className the name of the class holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @deprecated since 7.0 in favor of {@link #onMethodInvocation(String, String)}\r\n * or {@link #onType(Class)}.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic MethodHintPredicate onMethod(String className, String methodName) throws ClassNotFoundException {\r\n    Assert.hasText(className, \"'className' must not be empty\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return onMethod(Class.forName(className), methodName);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflection hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * By default, both introspection and invocation hints match.\n\t * <p>The returned type exposes additional methods that refine the predicate behavior.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @deprecated since 7.0 in favor of {@link #onMethodInvocation(String, String)}\n\t * or {@link #onType(Class)}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onMethodInvocation(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\r\n * This looks up a method on the given type with the expected name, if unique.\r\n * @param className the name of the class holding the method\r\n * @param methodName the method name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onMethodInvocation(String className, String methodName) throws ClassNotFoundException {\r\n    Assert.hasText(className, \"'className' must not be empty\");\r\n    Assert.hasText(methodName, \"'methodName' must not be empty\");\r\n    return onMethod(Class.forName(className), methodName).invoke();\r\n}",
    "comment": "\n\t * Return a predicate that checks whether an invocation hint is registered for the method that matches the given selector.\n\t * This looks up a method on the given type with the expected name, if unique.\n\t * @param className the name of the class holding the method\n\t * @param methodName the method name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if the method cannot be found or if multiple methods are found with the same name.\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#getMethod(Class<?>,String)",
    "entityType": "method",
    "code": "private Method getMethod(Class<?> type, String methodName) {\r\n    ReflectionUtils.MethodFilter selector = method -> methodName.equals(method.getName());\r\n    Set<Method> methods = MethodIntrospector.selectMethods(type, selector);\r\n    if (methods.size() == 1) {\r\n        return methods.iterator().next();\r\n    } else if (methods.size() > 1) {\r\n        throw new IllegalArgumentException(\"Found multiple methods named '%s' on class %s\".formatted(methodName, type.getName()));\r\n    } else {\r\n        throw new IllegalArgumentException(\"No method named '%s' on class %s\".formatted(methodName, type.getName()));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onField(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param type the type holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @deprecated since 7.0 in favor of {@link #onFieldAccess(Class, String)} with similar semantics.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Predicate<RuntimeHints> onField(Class<?> type, String fieldName) {\r\n    return onFieldAccess(type, fieldName);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Class, String)} with similar semantics.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onFieldAccess(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param type the type holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onFieldAccess(Class<?> type, String fieldName) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.hasText(fieldName, \"'fieldName' must not be empty\");\r\n    Field field = ReflectionUtils.findField(type, fieldName);\r\n    if (field == null) {\r\n        throw new IllegalArgumentException(\"No field named '%s' on class %s\".formatted(fieldName, type.getName()));\r\n    }\r\n    return new FieldHintPredicate(field);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param type the type holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onField(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param className the name of the class holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @deprecated since 7.0 in favor of {@link #onFieldAccess(String, String)} with similar semantics.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Predicate<RuntimeHints> onField(String className, String fieldName) throws ClassNotFoundException {\r\n    return onFieldAccess(className, fieldName);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflective field access hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(String, String)} with similar semantics.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onFieldAccess(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether an invocation hint is registered for the field.\r\n * This looks up a field on the given type with the expected name, if present.\r\n * @param className the name of the class holding the field\r\n * @param fieldName the field name\r\n * @return the {@link RuntimeHints} predicate\r\n * @throws ClassNotFoundException if the class cannot be resolved.\r\n * @throws IllegalArgumentException if a field cannot be found with the given name.\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onFieldAccess(String className, String fieldName) throws ClassNotFoundException {\r\n    Assert.hasText(className, \"'className' must not be empty\");\r\n    Assert.hasText(fieldName, \"'fieldName' must not be empty\");\r\n    return onFieldAccess(Class.forName(className), fieldName);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether an invocation hint is registered for the field.\n\t * This looks up a field on the given type with the expected name, if present.\n\t * @param className the name of the class holding the field\n\t * @param fieldName the field name\n\t * @return the {@link RuntimeHints} predicate\n\t * @throws ClassNotFoundException if the class cannot be resolved.\n\t * @throws IllegalArgumentException if a field cannot be found with the given name.\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onField(Field)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a reflective field access hint is registered for the given field.\r\n * @param field the field\r\n * @return the {@link RuntimeHints} predicate\r\n * @deprecated since 7.0 in favor of {@link #onFieldAccess(Field)} with similar semantics.\r\n */\r\n@Deprecated(since = \"7.0\", forRemoval = true)\r\npublic Predicate<RuntimeHints> onField(Field field) {\r\n    return onFieldAccess(field);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a reflective field access hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @deprecated since 7.0 in favor of {@link #onFieldAccess(Field)} with similar semantics.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ReflectionHintsPredicates#onFieldAccess(Field)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether an invocation hint is registered for the given field.\r\n * @param field the field\r\n * @return the {@link RuntimeHints} predicate\r\n * @since 7.0\r\n */\r\npublic Predicate<RuntimeHints> onFieldAccess(Field field) {\r\n    Assert.notNull(field, \"'field' must not be null\");\r\n    return new FieldHintPredicate(field);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether an invocation hint is registered for the given field.\n\t * @param field the field\n\t * @return the {@link RuntimeHints} predicate\n\t * @since 7.0\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.TypeHintPredicate",
    "entityType": "class",
    "code": "private final TypeReference type;\nTypeHintPredicate(TypeReference type) {\r\n    this.type = type;\r\n}\n@Nullable\r\nprivate TypeHint getTypeHint(RuntimeHints hints) {\r\n    return hints.reflection().getTypeHint(this.type);\r\n}\n@Override\r\npublic boolean test(RuntimeHints hints) {\r\n    return getTypeHint(hints) != null;\r\n}\n/**\r\n * Refine the current predicate to only match if the given {@link MemberCategory} is present.\r\n * @param memberCategory the member category\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> withMemberCategory(MemberCategory memberCategory) {\r\n    Assert.notNull(memberCategory, \"'memberCategory' must not be null\");\r\n    return and(hints -> {\r\n        TypeHint hint = getTypeHint(hints);\r\n        return (hint != null && hint.getMemberCategories().contains(memberCategory));\r\n    });\r\n}\n/**\r\n * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\r\n * @param memberCategories the member categories\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> withMemberCategories(MemberCategory... memberCategories) {\r\n    Assert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\r\n    return and(hints -> {\r\n        TypeHint hint = getTypeHint(hints);\r\n        return (hint != null && hint.getMemberCategories().containsAll(Arrays.asList(memberCategories)));\r\n    });\r\n}\n/**\r\n * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\r\n * @param memberCategories the member categories\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> withAnyMemberCategory(MemberCategory... memberCategories) {\r\n    Assert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\r\n    return and(hints -> {\r\n        TypeHint hint = getTypeHint(hints);\r\n        return (hint != null && Arrays.stream(memberCategories).anyMatch(memberCategory -> hint.getMemberCategories().contains(memberCategory)));\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.TypeHintPredicate#getTypeHint(RuntimeHints)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate TypeHint getTypeHint(RuntimeHints hints) {\r\n    return hints.reflection().getTypeHint(this.type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.TypeHintPredicate#test(RuntimeHints)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(RuntimeHints hints) {\r\n    return getTypeHint(hints) != null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.TypeHintPredicate#withMemberCategory(MemberCategory)",
    "entityType": "method",
    "code": "/**\r\n * Refine the current predicate to only match if the given {@link MemberCategory} is present.\r\n * @param memberCategory the member category\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> withMemberCategory(MemberCategory memberCategory) {\r\n    Assert.notNull(memberCategory, \"'memberCategory' must not be null\");\r\n    return and(hints -> {\r\n        TypeHint hint = getTypeHint(hints);\r\n        return (hint != null && hint.getMemberCategories().contains(memberCategory));\r\n    });\r\n}",
    "comment": "\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory} is present.\n\t\t * @param memberCategory the member category\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.TypeHintPredicate#withMemberCategories(MemberCategory)",
    "entityType": "method",
    "code": "/**\r\n * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\r\n * @param memberCategories the member categories\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> withMemberCategories(MemberCategory... memberCategories) {\r\n    Assert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\r\n    return and(hints -> {\r\n        TypeHint hint = getTypeHint(hints);\r\n        return (hint != null && hint.getMemberCategories().containsAll(Arrays.asList(memberCategories)));\r\n    });\r\n}",
    "comment": "\n\t\t * Refine the current predicate to only match if the given {@link MemberCategory categories} are present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.TypeHintPredicate#withAnyMemberCategory(MemberCategory)",
    "entityType": "method",
    "code": "/**\r\n * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\r\n * @param memberCategories the member categories\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> withAnyMemberCategory(MemberCategory... memberCategories) {\r\n    Assert.notEmpty(memberCategories, \"'memberCategories' must not be empty\");\r\n    return and(hints -> {\r\n        TypeHint hint = getTypeHint(hints);\r\n        return (hint != null && Arrays.stream(memberCategories).anyMatch(memberCategory -> hint.getMemberCategories().contains(memberCategory)));\r\n    });\r\n}",
    "comment": "\n\t\t * Refine the current predicate to match if any of the given {@link MemberCategory categories} is present.\n\t\t * @param memberCategories the member categories\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ExecutableHintPredicate",
    "entityType": "class",
    "code": "protected final T executable;\nprotected ExecutableMode executableMode = ExecutableMode.INTROSPECT;\nExecutableHintPredicate(T executable) {\r\n    this.executable = executable;\r\n}\n/**\r\n * Refine the current predicate to match for reflection introspection on the current type.\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic ExecutableHintPredicate<T> introspect() {\r\n    this.executableMode = ExecutableMode.INTROSPECT;\r\n    return this;\r\n}\n/**\r\n * Refine the current predicate to match for reflection invocation on the current type.\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic ExecutableHintPredicate<T> invoke() {\r\n    this.executableMode = ExecutableMode.INVOKE;\r\n    return this;\r\n}\nabstract Predicate<RuntimeHints> exactMatch();\n/**\r\n * Indicate whether the specified {@code ExecutableHint} covers the\r\n * reflection needs of the specified executable definition.\r\n * @return {@code true} if the member matches (same type, name, and parameters),\r\n * and the configured {@code ExecutableMode} is compatible\r\n */\r\nstatic boolean includes(ExecutableHint hint, String name, List<TypeReference> parameterTypes, ExecutableMode executableModes) {\r\n    return hint.getName().equals(name) && hint.getParameterTypes().equals(parameterTypes) && (hint.getMode().equals(ExecutableMode.INVOKE) || !executableModes.equals(ExecutableMode.INVOKE));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ExecutableHintPredicate#introspect()",
    "entityType": "method",
    "code": "/**\r\n * Refine the current predicate to match for reflection introspection on the current type.\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic ExecutableHintPredicate<T> introspect() {\r\n    this.executableMode = ExecutableMode.INTROSPECT;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Refine the current predicate to match for reflection introspection on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ExecutableHintPredicate#invoke()",
    "entityType": "method",
    "code": "/**\r\n * Refine the current predicate to match for reflection invocation on the current type.\r\n * @return the refined {@link RuntimeHints} predicate\r\n */\r\npublic ExecutableHintPredicate<T> invoke() {\r\n    this.executableMode = ExecutableMode.INVOKE;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Refine the current predicate to match for reflection invocation on the current type.\n\t\t * @return the refined {@link RuntimeHints} predicate\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ExecutableHintPredicate#exactMatch()",
    "entityType": "method",
    "code": "abstract Predicate<RuntimeHints> exactMatch();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ExecutableHintPredicate#includes(ExecutableHint,String,List<TypeReference>,ExecutableMode)",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether the specified {@code ExecutableHint} covers the\r\n * reflection needs of the specified executable definition.\r\n * @return {@code true} if the member matches (same type, name, and parameters),\r\n * and the configured {@code ExecutableMode} is compatible\r\n */\r\nstatic boolean includes(ExecutableHint hint, String name, List<TypeReference> parameterTypes, ExecutableMode executableModes) {\r\n    return hint.getName().equals(name) && hint.getParameterTypes().equals(parameterTypes) && (hint.getMode().equals(ExecutableMode.INVOKE) || !executableModes.equals(ExecutableMode.INVOKE));\r\n}",
    "comment": "\n\t\t * Indicate whether the specified {@code ExecutableHint} covers the\n\t\t * reflection needs of the specified executable definition.\n\t\t * @return {@code true} if the member matches (same type, name, and parameters),\n\t\t * and the configured {@code ExecutableMode} is compatible\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ConstructorHintPredicate",
    "entityType": "class",
    "code": "ConstructorHintPredicate(Constructor<?> constructor) {\r\n    super(constructor);\r\n}\n@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE)).or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS).and(hints -> this.executableMode == ExecutableMode.INVOKE)).or(exactMatch()).test(runtimeHints);\r\n}\n@Override\r\nPredicate<RuntimeHints> exactMatch() {\r\n    return hints -> {\r\n        TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n        return (hint != null && hint.constructors().anyMatch(executableHint -> {\r\n            List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n            return includes(executableHint, \"<init>\", parameters, this.executableMode);\r\n        }));\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ConstructorHintPredicate#test(RuntimeHints)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE)).or(new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS).and(hints -> this.executableMode == ExecutableMode.INVOKE)).or(exactMatch()).test(runtimeHints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ConstructorHintPredicate#exactMatch()",
    "entityType": "method",
    "code": "@Override\r\nPredicate<RuntimeHints> exactMatch() {\r\n    return hints -> {\r\n        TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n        return (hint != null && hint.constructors().anyMatch(executableHint -> {\r\n            List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n            return includes(executableHint, \"<init>\", parameters, this.executableMode);\r\n        }));\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.MethodHintPredicate",
    "entityType": "class",
    "code": "MethodHintPredicate(Method method) {\r\n    super(method);\r\n}\n@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS).and(hints -> !Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or(exactMatch()).test(runtimeHints);\r\n}\n@Override\r\nPredicate<RuntimeHints> exactMatch() {\r\n    return hints -> {\r\n        TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n        return (hint != null && hint.methods().anyMatch(executableHint -> {\r\n            List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n            return includes(executableHint, this.executable.getName(), parameters, this.executableMode);\r\n        }));\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.MethodHintPredicate#test(RuntimeHints)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    return (new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).and(hints -> this.executableMode == ExecutableMode.INTROSPECT)).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_PUBLIC_METHODS).and(hints -> Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or((new TypeHintPredicate(TypeReference.of(this.executable.getDeclaringClass())).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS).and(hints -> !Modifier.isPublic(this.executable.getModifiers())).and(hints -> this.executableMode == ExecutableMode.INVOKE))).or(exactMatch()).test(runtimeHints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.MethodHintPredicate#exactMatch()",
    "entityType": "method",
    "code": "@Override\r\nPredicate<RuntimeHints> exactMatch() {\r\n    return hints -> {\r\n        TypeHint hint = hints.reflection().getTypeHint(this.executable.getDeclaringClass());\r\n        return (hint != null && hint.methods().anyMatch(executableHint -> {\r\n            List<TypeReference> parameters = TypeReference.listOf(this.executable.getParameterTypes());\r\n            return includes(executableHint, this.executable.getName(), parameters, this.executableMode);\r\n        }));\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.FieldHintPredicate",
    "entityType": "class",
    "code": "private final Field field;\nFieldHintPredicate(Field field) {\r\n    this.field = field;\r\n}\n@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    TypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\r\n    if (typeHint == null) {\r\n        return false;\r\n    }\r\n    return memberCategoryMatch(typeHint) || exactMatch(typeHint);\r\n}\n@SuppressWarnings(\"removal\")\r\nprivate boolean memberCategoryMatch(TypeHint typeHint) {\r\n    if (Modifier.isPublic(this.field.getModifiers())) {\r\n        return typeHint.getMemberCategories().contains(MemberCategory.ACCESS_PUBLIC_FIELDS) || typeHint.getMemberCategories().contains(MemberCategory.PUBLIC_FIELDS);\r\n    } else {\r\n        return typeHint.getMemberCategories().contains(MemberCategory.ACCESS_DECLARED_FIELDS) || typeHint.getMemberCategories().contains(MemberCategory.DECLARED_FIELDS);\r\n    }\r\n}\nprivate boolean exactMatch(TypeHint typeHint) {\r\n    return typeHint.fields().anyMatch(fieldHint -> this.field.getName().equals(fieldHint.getName()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.FieldHintPredicate#test(RuntimeHints)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(RuntimeHints runtimeHints) {\r\n    TypeHint typeHint = runtimeHints.reflection().getTypeHint(this.field.getDeclaringClass());\r\n    if (typeHint == null) {\r\n        return false;\r\n    }\r\n    return memberCategoryMatch(typeHint) || exactMatch(typeHint);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.FieldHintPredicate#memberCategoryMatch(TypeHint)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"removal\")\r\nprivate boolean memberCategoryMatch(TypeHint typeHint) {\r\n    if (Modifier.isPublic(this.field.getModifiers())) {\r\n        return typeHint.getMemberCategories().contains(MemberCategory.ACCESS_PUBLIC_FIELDS) || typeHint.getMemberCategories().contains(MemberCategory.PUBLIC_FIELDS);\r\n    } else {\r\n        return typeHint.getMemberCategories().contains(MemberCategory.ACCESS_DECLARED_FIELDS) || typeHint.getMemberCategories().contains(MemberCategory.DECLARED_FIELDS);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.FieldHintPredicate#exactMatch(TypeHint)",
    "entityType": "method",
    "code": "private boolean exactMatch(TypeHint typeHint) {\r\n    return typeHint.fields().anyMatch(fieldHint -> this.field.getName().equals(fieldHint.getName()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparatorTests",
    "entityType": "class",
    "code": "@Test\r\nvoid shouldCompareWithTrueLow() {\r\n    Comparator<Boolean> c = new BooleanComparator(true);\r\n    assertThat(c.compare(true, false)).isLessThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}\n@Test\r\nvoid shouldCompareWithTrueHigh() {\r\n    Comparator<Boolean> c = new BooleanComparator(false);\r\n    assertThat(c.compare(true, false)).isGreaterThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}\n@Test\r\nvoid shouldCompareFromTrueLow() {\r\n    Comparator<Boolean> c = BooleanComparator.TRUE_LOW;\r\n    assertThat(c.compare(true, false)).isLessThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}\n@Test\r\nvoid shouldCompareFromTrueHigh() {\r\n    Comparator<Boolean> c = BooleanComparator.TRUE_HIGH;\r\n    assertThat(c.compare(true, false)).isGreaterThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}",
    "comment": "\n * Tests for {@link BooleanComparator}.\n *\n * @author Keith Donald\n * @author Chris Beams\n * @author Phillip Webb\n * @author Eugene Rabii\n "
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparatorTests#shouldCompareWithTrueLow()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareWithTrueLow() {\r\n    Comparator<Boolean> c = new BooleanComparator(true);\r\n    assertThat(c.compare(true, false)).isLessThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparatorTests#shouldCompareWithTrueHigh()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareWithTrueHigh() {\r\n    Comparator<Boolean> c = new BooleanComparator(false);\r\n    assertThat(c.compare(true, false)).isGreaterThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparatorTests#shouldCompareFromTrueLow()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareFromTrueLow() {\r\n    Comparator<Boolean> c = BooleanComparator.TRUE_LOW;\r\n    assertThat(c.compare(true, false)).isLessThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparatorTests#shouldCompareFromTrueHigh()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareFromTrueHigh() {\r\n    Comparator<Boolean> c = BooleanComparator.TRUE_HIGH;\r\n    assertThat(c.compare(true, false)).isGreaterThan(0);\r\n    assertThat(c.compare(Boolean.TRUE, Boolean.TRUE)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.ComparableComparatorTests",
    "entityType": "class",
    "code": "@Test\r\nvoid comparableComparator() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator<String> c = new ComparableComparator<>();\r\n    assertThat(c.compare(\"abc\", \"cde\")).isLessThan(0);\r\n}\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid shouldNeedComparable() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator c = new ComparableComparator();\r\n    Object o1 = new Object();\r\n    Object o2 = new Object();\r\n    assertThatExceptionOfType(ClassCastException.class).isThrownBy(() -> c.compare(o1, o2));\r\n}",
    "comment": "\n * Tests for {@link ComparableComparator}.\n *\n * @author Keith Donald\n * @author Chris Beams\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.util.comparator.ComparableComparatorTests#comparableComparator()",
    "entityType": "method",
    "code": "@Test\r\nvoid comparableComparator() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator<String> c = new ComparableComparator<>();\r\n    assertThat(c.compare(\"abc\", \"cde\")).isLessThan(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.ComparableComparatorTests#shouldNeedComparable()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid shouldNeedComparable() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator c = new ComparableComparator();\r\n    Object o1 = new Object();\r\n    Object o2 = new Object();\r\n    assertThatExceptionOfType(ClassCastException.class).isThrownBy(() -> c.compare(o1, o2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ResourceHintsPredicates",
    "entityType": "class",
    "code": "private static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();\nResourceHintsPredicates() {\r\n}\n/**\r\n * Return a predicate that checks whether a resource hint is registered for the given bundle name.\r\n * @param bundleName the resource bundle name\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> forBundle(String bundleName) {\r\n    Assert.hasText(bundleName, \"resource bundle name should not be empty\");\r\n    return runtimeHints -> runtimeHints.resources().resourceBundleHints().anyMatch(bundleHint -> bundleName.equals(bundleHint.getBaseName()));\r\n}\n/**\r\n * Return a predicate that checks whether a resource hint is registered for the given\r\n * resource name, located in the given type's package.\r\n * <p>For example, {@code forResource(org.example.MyClass, \"myResource.txt\")}\r\n * will match against {@code \"org/example/myResource.txt\"}.\r\n * <p>If the given resource name is an absolute path (i.e., starts with a\r\n * leading slash), the supplied type will be ignored. For example,\r\n * {@code forResource(org.example.MyClass, \"/myResource.txt\")} will match against\r\n * {@code \"myResource.txt\"}.\r\n * @param type the type's package where to look for the resource\r\n * @param resourceName the resource name\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> forResource(TypeReference type, String resourceName) {\r\n    String absoluteName = resolveAbsoluteResourceName(type, resourceName);\r\n    return forResource(absoluteName);\r\n}\nprivate String resolveAbsoluteResourceName(TypeReference type, String resourceName) {\r\n    // absolute path\r\n    if (resourceName.startsWith(\"/\")) {\r\n        return resourceName.substring(1);\r\n    } else // default package\r\n    if (type.getPackageName().isEmpty()) {\r\n        return resourceName;\r\n    } else // relative path\r\n    {\r\n        return type.getPackageName().replace('.', '/') + \"/\" + resourceName;\r\n    }\r\n}\n/**\r\n * Return a predicate that checks whether a resource hint is registered for\r\n * the given resource name.\r\n * <p>A leading slash will be removed.\r\n * @param resourceName the absolute resource name\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> forResource(String resourceName) {\r\n    String resourceNameToUse = (resourceName.startsWith(\"/\") ? resourceName.substring(1) : resourceName);\r\n    return hints -> {\r\n        AggregatedResourcePatternHints aggregatedResourcePatternHints = AggregatedResourcePatternHints.of(hints.resources());\r\n        return aggregatedResourcePatternHints.includes().stream().anyMatch(included -> PATH_MATCHER.match(included.getPattern(), resourceNameToUse));\r\n    };\r\n}\nprivate record AggregatedResourcePatternHints(List<ResourcePatternHint> includes) {\r\n\r\n    static AggregatedResourcePatternHints of(ResourceHints resourceHints) {\r\n        List<ResourcePatternHint> includes = new ArrayList<>();\r\n        resourceHints.resourcePatternHints().forEach(resourcePatternHint -> includes.addAll(resourcePatternHint.getIncludes()));\r\n        return new AggregatedResourcePatternHints(includes);\r\n    }\r\n}",
    "comment": "\n * Generator of {@link ResourceHints} predicates, testing whether the given hints\n * match the expected behavior for resources.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ResourceHintsPredicates#forBundle(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a resource hint is registered for the given bundle name.\r\n * @param bundleName the resource bundle name\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> forBundle(String bundleName) {\r\n    Assert.hasText(bundleName, \"resource bundle name should not be empty\");\r\n    return runtimeHints -> runtimeHints.resources().resourceBundleHints().anyMatch(bundleHint -> bundleName.equals(bundleHint.getBaseName()));\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a resource hint is registered for the given bundle name.\n\t * @param bundleName the resource bundle name\n\t * @return the {@link RuntimeHints} predicate\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ResourceHintsPredicates#forResource(TypeReference,String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a resource hint is registered for the given\r\n * resource name, located in the given type's package.\r\n * <p>For example, {@code forResource(org.example.MyClass, \"myResource.txt\")}\r\n * will match against {@code \"org/example/myResource.txt\"}.\r\n * <p>If the given resource name is an absolute path (i.e., starts with a\r\n * leading slash), the supplied type will be ignored. For example,\r\n * {@code forResource(org.example.MyClass, \"/myResource.txt\")} will match against\r\n * {@code \"myResource.txt\"}.\r\n * @param type the type's package where to look for the resource\r\n * @param resourceName the resource name\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> forResource(TypeReference type, String resourceName) {\r\n    String absoluteName = resolveAbsoluteResourceName(type, resourceName);\r\n    return forResource(absoluteName);\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a resource hint is registered for the given\n\t * resource name, located in the given type's package.\n\t * <p>For example, {@code forResource(org.example.MyClass, \"myResource.txt\")}\n\t * will match against {@code \"org/example/myResource.txt\"}.\n\t * <p>If the given resource name is an absolute path (i.e., starts with a\n\t * leading slash), the supplied type will be ignored. For example,\n\t * {@code forResource(org.example.MyClass, \"/myResource.txt\")} will match against\n\t * {@code \"myResource.txt\"}.\n\t * @param type the type's package where to look for the resource\n\t * @param resourceName the resource name\n\t * @return the {@link RuntimeHints} predicate\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ResourceHintsPredicates#resolveAbsoluteResourceName(TypeReference,String)",
    "entityType": "method",
    "code": "private String resolveAbsoluteResourceName(TypeReference type, String resourceName) {\r\n    // absolute path\r\n    if (resourceName.startsWith(\"/\")) {\r\n        return resourceName.substring(1);\r\n    } else // default package\r\n    if (type.getPackageName().isEmpty()) {\r\n        return resourceName;\r\n    } else // relative path\r\n    {\r\n        return type.getPackageName().replace('.', '/') + \"/\" + resourceName;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.ResourceHintsPredicates#forResource(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a resource hint is registered for\r\n * the given resource name.\r\n * <p>A leading slash will be removed.\r\n * @param resourceName the absolute resource name\r\n * @return the {@link RuntimeHints} predicate\r\n */\r\npublic Predicate<RuntimeHints> forResource(String resourceName) {\r\n    String resourceNameToUse = (resourceName.startsWith(\"/\") ? resourceName.substring(1) : resourceName);\r\n    return hints -> {\r\n        AggregatedResourcePatternHints aggregatedResourcePatternHints = AggregatedResourcePatternHints.of(hints.resources());\r\n        return aggregatedResourcePatternHints.includes().stream().anyMatch(included -> PATH_MATCHER.match(included.getPattern(), resourceNameToUse));\r\n    };\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a resource hint is registered for\n\t * the given resource name.\n\t * <p>A leading slash will be removed.\n\t * @param resourceName the absolute resource name\n\t * @return the {@link RuntimeHints} predicate\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.ComparatorsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid nullsLow() {\r\n    assertThat(Comparators.nullsLow().compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsLow().compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsLow().compare(null, \"boo\")).isNegative();\r\n    assertThat(Comparators.nullsLow().compare(\"boo\", null)).isPositive();\r\n}\n@Test\r\nvoid nullsLowWithExplicitComparator() {\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(null, \"boo\")).isNegative();\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(\"boo\", null)).isPositive();\r\n}\n@Test\r\nvoid nullsHigh() {\r\n    assertThat(Comparators.nullsHigh().compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsHigh().compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsHigh().compare(null, \"boo\")).isPositive();\r\n    assertThat(Comparators.nullsHigh().compare(\"boo\", null)).isNegative();\r\n}\n@Test\r\nvoid nullsHighWithExplicitComparator() {\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(null, \"boo\")).isPositive();\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(\"boo\", null)).isNegative();\r\n}",
    "comment": "\n * Tests for {@link Comparators}.\n *\n * @since 6.1.2\n * @author Mathieu Amblard\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.comparator.ComparatorsTests#nullsLow()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullsLow() {\r\n    assertThat(Comparators.nullsLow().compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsLow().compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsLow().compare(null, \"boo\")).isNegative();\r\n    assertThat(Comparators.nullsLow().compare(\"boo\", null)).isPositive();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.ComparatorsTests#nullsLowWithExplicitComparator()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullsLowWithExplicitComparator() {\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(null, \"boo\")).isNegative();\r\n    assertThat(Comparators.nullsLow(String::compareTo).compare(\"boo\", null)).isPositive();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.ComparatorsTests#nullsHigh()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullsHigh() {\r\n    assertThat(Comparators.nullsHigh().compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsHigh().compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsHigh().compare(null, \"boo\")).isPositive();\r\n    assertThat(Comparators.nullsHigh().compare(\"boo\", null)).isNegative();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.ComparatorsTests#nullsHighWithExplicitComparator()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullsHighWithExplicitComparator() {\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(null, null)).isZero();\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(null, \"boo\")).isPositive();\r\n    assertThat(Comparators.nullsHigh(String::compareTo).compare(\"boo\", null)).isNegative();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.RuntimeHintsPredicates",
    "entityType": "class",
    "code": "private static final ReflectionHintsPredicates reflection = new ReflectionHintsPredicates();\nprivate static final ResourceHintsPredicates resource = new ResourceHintsPredicates();\nprivate static final SerializationHintsPredicates serialization = new SerializationHintsPredicates();\nprivate static final ProxyHintsPredicates proxies = new ProxyHintsPredicates();\nprivate RuntimeHintsPredicates() {\r\n}\n/**\r\n * Return a predicate generator for {@link ReflectionHints reflection hints}.\r\n * @return the predicate generator\r\n */\r\npublic static ReflectionHintsPredicates reflection() {\r\n    return reflection;\r\n}\n/**\r\n * Return a predicate generator for {@link ResourceHints resource hints}.\r\n * @return the predicate generator\r\n */\r\npublic static ResourceHintsPredicates resource() {\r\n    return resource;\r\n}\n/**\r\n * Return a predicate generator for {@link SerializationHints serialization hints}.\r\n * @return the predicate generator\r\n */\r\npublic static SerializationHintsPredicates serialization() {\r\n    return serialization;\r\n}\n/**\r\n * Return a predicate generator for {@link ProxyHints proxy hints}.\r\n * @return the predicate generator\r\n */\r\npublic static ProxyHintsPredicates proxies() {\r\n    return proxies;\r\n}",
    "comment": "\n * Static generator of predicates that test whether the given {@link RuntimeHints}\n * instance matches the expected behavior for reflection, resource, serialization,\n * or proxy generation.\n *\n * <p>This utility class can be used by {@link RuntimeHintsRegistrar} to conditionally\n * register hints depending on what's present already. This can also be used as a\n * testing utility for checking proper registration of hints:\n * <pre class=\"code\">\n * Predicate&lt;RuntimeHints&gt; predicate = RuntimeHintsPredicates.reflection().onMethod(MyClass.class, \"someMethod\").invoke();\n * assertThat(predicate).accepts(runtimeHints);\n * </pre>\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.RuntimeHintsPredicates#reflection()",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate generator for {@link ReflectionHints reflection hints}.\r\n * @return the predicate generator\r\n */\r\npublic static ReflectionHintsPredicates reflection() {\r\n    return reflection;\r\n}",
    "comment": "\n\t * Return a predicate generator for {@link ReflectionHints reflection hints}.\n\t * @return the predicate generator\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.RuntimeHintsPredicates#resource()",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate generator for {@link ResourceHints resource hints}.\r\n * @return the predicate generator\r\n */\r\npublic static ResourceHintsPredicates resource() {\r\n    return resource;\r\n}",
    "comment": "\n\t * Return a predicate generator for {@link ResourceHints resource hints}.\n\t * @return the predicate generator\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.RuntimeHintsPredicates#serialization()",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate generator for {@link SerializationHints serialization hints}.\r\n * @return the predicate generator\r\n */\r\npublic static SerializationHintsPredicates serialization() {\r\n    return serialization;\r\n}",
    "comment": "\n\t * Return a predicate generator for {@link SerializationHints serialization hints}.\n\t * @return the predicate generator\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.RuntimeHintsPredicates#proxies()",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate generator for {@link ProxyHints proxy hints}.\r\n * @return the predicate generator\r\n */\r\npublic static ProxyHintsPredicates proxies() {\r\n    return proxies;\r\n}",
    "comment": "\n\t * Return a predicate generator for {@link ProxyHints proxy hints}.\n\t * @return the predicate generator\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparatorTests",
    "entityType": "class",
    "code": "private C1 c1 = new C1();\nprivate C2 c2 = new C2();\nprivate C3 c3 = new C3();\nprivate C4 c4 = new C4();\n@Test\r\nvoid shouldCompareClasses() {\r\n    Comparator<Object> comparator = new InstanceComparator<>(C1.class, C2.class);\r\n    assertThat(comparator.compare(c1, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c1, c2)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c2, c1)).isEqualTo(1);\r\n    assertThat(comparator.compare(c2, c3)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c2, c4)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c3, c4)).isEqualTo(0);\r\n}\n@Test\r\nvoid shouldCompareInterfaces() {\r\n    Comparator<Object> comparator = new InstanceComparator<>(I1.class, I2.class);\r\n    assertThat(comparator.compare(c1, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c1, c2)).isEqualTo(0);\r\n    assertThat(comparator.compare(c2, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c1, c3)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c3, c1)).isEqualTo(1);\r\n    assertThat(comparator.compare(c3, c4)).isEqualTo(0);\r\n}\n@Test\r\nvoid shouldCompareMix() {\r\n    Comparator<Object> comparator = new InstanceComparator<>(I1.class, C3.class);\r\n    assertThat(comparator.compare(c1, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c3, c4)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c3, null)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c4, null)).isEqualTo(0);\r\n}\nprivate interface I1 {\r\n}\nprivate interface I2 {\r\n}\nprivate static class C1 implements I1 {\r\n}\nprivate static class C2 implements I1 {\r\n}\nprivate static class C3 implements I2 {\r\n}\nprivate static class C4 implements I2 {\r\n}",
    "comment": "\n * Tests for {@link InstanceComparator}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparatorTests#shouldCompareClasses()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareClasses() {\r\n    Comparator<Object> comparator = new InstanceComparator<>(C1.class, C2.class);\r\n    assertThat(comparator.compare(c1, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c1, c2)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c2, c1)).isEqualTo(1);\r\n    assertThat(comparator.compare(c2, c3)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c2, c4)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c3, c4)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparatorTests#shouldCompareInterfaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareInterfaces() {\r\n    Comparator<Object> comparator = new InstanceComparator<>(I1.class, I2.class);\r\n    assertThat(comparator.compare(c1, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c1, c2)).isEqualTo(0);\r\n    assertThat(comparator.compare(c2, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c1, c3)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c3, c1)).isEqualTo(1);\r\n    assertThat(comparator.compare(c3, c4)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparatorTests#shouldCompareMix()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCompareMix() {\r\n    Comparator<Object> comparator = new InstanceComparator<>(I1.class, C3.class);\r\n    assertThat(comparator.compare(c1, c1)).isEqualTo(0);\r\n    assertThat(comparator.compare(c3, c4)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c3, null)).isEqualTo(-1);\r\n    assertThat(comparator.compare(c4, null)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.I1",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.I2",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.C1",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.C2",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.C3",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.C4",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.SerializationHintsPredicates",
    "entityType": "class",
    "code": "SerializationHintsPredicates() {\r\n}\n/**\r\n * Return a predicate that checks whether a {@link SerializationHints\r\n * serialization hint} is registered for the given type.\r\n * @param type the type to check\r\n * @return the {@link RuntimeHints} predicate\r\n * @see java.lang.reflect.Proxy\r\n */\r\npublic Predicate<RuntimeHints> onType(Class<?> type) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    return onType(TypeReference.of(type));\r\n}\n/**\r\n * Return a predicate that checks whether a {@link SerializationHints\r\n * serialization hint} is registered for the given type reference.\r\n * @param typeReference the type to check\r\n * @return the {@link RuntimeHints} predicate\r\n * @see java.lang.reflect.Proxy\r\n */\r\npublic Predicate<RuntimeHints> onType(TypeReference typeReference) {\r\n    Assert.notNull(typeReference, \"'typeReference' must not be null\");\r\n    return hints -> hints.serialization().javaSerializationHints().anyMatch(hint -> hint.getType().equals(typeReference));\r\n}",
    "comment": "\n * Generator of {@link SerializationHints} predicates, testing whether the\n * given hints match the expected behavior for serialization.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.SerializationHintsPredicates#onType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a {@link SerializationHints\r\n * serialization hint} is registered for the given type.\r\n * @param type the type to check\r\n * @return the {@link RuntimeHints} predicate\r\n * @see java.lang.reflect.Proxy\r\n */\r\npublic Predicate<RuntimeHints> onType(Class<?> type) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    return onType(TypeReference.of(type));\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a {@link SerializationHints\n\t * serialization hint} is registered for the given type.\n\t * @param type the type to check\n\t * @return the {@link RuntimeHints} predicate\n\t * @see java.lang.reflect.Proxy\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.predicate.SerializationHintsPredicates#onType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Return a predicate that checks whether a {@link SerializationHints\r\n * serialization hint} is registered for the given type reference.\r\n * @param typeReference the type to check\r\n * @return the {@link RuntimeHints} predicate\r\n * @see java.lang.reflect.Proxy\r\n */\r\npublic Predicate<RuntimeHints> onType(TypeReference typeReference) {\r\n    Assert.notNull(typeReference, \"'typeReference' must not be null\");\r\n    return hints -> hints.serialization().javaSerializationHints().anyMatch(hint -> hint.getType().equals(typeReference));\r\n}",
    "comment": "\n\t * Return a predicate that checks whether a {@link SerializationHints\n\t * serialization hint} is registered for the given type reference.\n\t * @param typeReference the type to check\n\t * @return the {@link RuntimeHints} predicate\n\t * @see java.lang.reflect.Proxy\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparatorTests",
    "entityType": "class",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid shouldCompareWithNullsLow() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator<String> c = NullSafeComparator.NULLS_LOW;\r\n    assertThat(c.compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(c.compare(null, null)).isZero();\r\n    assertThat(c.compare(null, \"boo\")).isNegative();\r\n    assertThat(c.compare(\"boo\", null)).isPositive();\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid shouldCompareWithNullsHigh() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator<String> c = NullSafeComparator.NULLS_HIGH;\r\n    assertThat(c.compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(c.compare(null, null)).isZero();\r\n    assertThat(c.compare(null, \"boo\")).isPositive();\r\n    assertThat(c.compare(\"boo\", null)).isNegative();\r\n}",
    "comment": "\n * Tests for {@link NullSafeComparator}.\n *\n * @author Keith Donald\n * @author Chris Beams\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparatorTests#shouldCompareWithNullsLow()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid shouldCompareWithNullsLow() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator<String> c = NullSafeComparator.NULLS_LOW;\r\n    assertThat(c.compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(c.compare(null, null)).isZero();\r\n    assertThat(c.compare(null, \"boo\")).isNegative();\r\n    assertThat(c.compare(\"boo\", null)).isPositive();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparatorTests#shouldCompareWithNullsHigh()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid shouldCompareWithNullsHigh() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    Comparator<String> c = NullSafeComparator.NULLS_HIGH;\r\n    assertThat(c.compare(\"boo\", \"boo\")).isZero();\r\n    assertThat(c.compare(null, null)).isZero();\r\n    assertThat(c.compare(null, \"boo\")).isPositive();\r\n    assertThat(c.compare(\"boo\", null)).isNegative();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ProxyHints",
    "entityType": "class",
    "code": "private final Set<JdkProxyHint> jdkProxies = new LinkedHashSet<>();\n/**\r\n * Return the interface-based proxies that are required.\r\n * @return a stream of {@link JdkProxyHint}\r\n */\r\npublic Stream<JdkProxyHint> jdkProxyHints() {\r\n    return this.jdkProxies.stream();\r\n}\n/**\r\n * Register a {@link JdkProxyHint}.\r\n * @param jdkProxyHint the consumer of the hint builder\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ProxyHints registerJdkProxy(Consumer<JdkProxyHint.Builder> jdkProxyHint) {\r\n    JdkProxyHint.Builder builder = new JdkProxyHint.Builder();\r\n    jdkProxyHint.accept(builder);\r\n    this.jdkProxies.add(builder.build());\r\n    return this;\r\n}\n/**\r\n * Register that a JDK proxy implementing the interfaces defined by the\r\n * specified {@linkplain TypeReference type references} is required.\r\n * @param proxiedInterfaces the type references for the interfaces the proxy\r\n * should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ProxyHints registerJdkProxy(TypeReference... proxiedInterfaces) {\r\n    return registerJdkProxy(jdkProxyHint -> jdkProxyHint.proxiedInterfaces(proxiedInterfaces));\r\n}\n/**\r\n * Register that a JDK proxy implementing the specified interfaces is\r\n * required.\r\n * <p>When registering a JDK proxy for Spring AOP, consider using\r\n * {@link org.springframework.aop.framework.AopProxyUtils#completeJdkProxyInterfaces(Class...)\r\n * AopProxyUtils.completeJdkProxyInterfaces()} for convenience.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ProxyHints registerJdkProxy(Class<?>... proxiedInterfaces) {\r\n    return registerJdkProxy(jdkProxyHint -> jdkProxyHint.proxiedInterfaces(proxiedInterfaces));\r\n}",
    "comment": "\n * Gather the need for using proxies at runtime.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  }
]