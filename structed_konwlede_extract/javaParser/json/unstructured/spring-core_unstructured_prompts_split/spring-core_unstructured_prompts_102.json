[
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAttributesReturnsAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAttributesReturnsAttributes() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(0);\r\n    AttributeMethods attributes = mapping.getAttributes();\r\n    assertThat(attributes.size()).isEqualTo(2);\r\n    assertThat(attributes.get(0).getName()).isEqualTo(\"alias\");\r\n    assertThat(attributes.get(1).getName()).isEqualTo(\"convention\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMappingReturnsAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAliasMappingReturnsAttributes() throws Exception {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\r\n    assertThat(getAliasMapping(mapping, 0)).isEqualTo(Mapped.class.getDeclaredMethod(\"alias\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getConventionMappingReturnsAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getConventionMappingReturnsAttributes() throws Exception {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(Mapped.class).get(1);\r\n    assertThat(getConventionMapping(mapping, 1)).isEqualTo(Mapped.class.getDeclaredMethod(\"convention\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getMirrorSetWhenAliasPairReturnsMirrors()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMirrorSetWhenAliasPairReturnsMirrors() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\r\n    MirrorSets mirrorSets = mapping.getMirrorSets();\r\n    assertThat(mirrorSets.size()).isEqualTo(1);\r\n    assertThat(mirrorSets.get(0).size()).isEqualTo(2);\r\n    assertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\r\n    assertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getMirrorSetWhenImplicitMirrorsReturnsMirrors()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMirrorSetWhenImplicitMirrorsReturnsMirrors() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ImplicitMirrors.class).get(0);\r\n    MirrorSets mirrorSets = mapping.getMirrorSets();\r\n    assertThat(mirrorSets.size()).isEqualTo(1);\r\n    assertThat(mirrorSets.get(0).size()).isEqualTo(2);\r\n    assertThat(mirrorSets.get(0).get(0).getName()).isEqualTo(\"a\");\r\n    assertThat(mirrorSets.get(0).get(1).getName()).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getMirrorSetWhenThreeDeepReturnsMirrors()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMirrorSetWhenThreeDeepReturnsMirrors() {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\r\n    AnnotationTypeMapping mappingA = mappings.get(0);\r\n    MirrorSets mirrorSetsA = mappingA.getMirrorSets();\r\n    assertThat(mirrorSetsA.size()).isEqualTo(2);\r\n    assertThat(getNames(mirrorSetsA.get(0))).containsExactly(\"a1\", \"a2\", \"a3\");\r\n    AnnotationTypeMapping mappingB = mappings.get(1);\r\n    MirrorSets mirrorSetsB = mappingB.getMirrorSets();\r\n    assertThat(mirrorSetsB.size()).isEqualTo(1);\r\n    assertThat(getNames(mirrorSetsB.get(0))).containsExactly(\"b1\", \"b2\");\r\n    AnnotationTypeMapping mappingC = mappings.get(2);\r\n    MirrorSets mirrorSetsC = mappingC.getMirrorSets();\r\n    assertThat(mirrorSetsC.size()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMappingWhenThreeDeepReturnsMappedAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAliasMappingWhenThreeDeepReturnsMappedAttributes() {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ThreeDeepA.class);\r\n    AnnotationTypeMapping mappingA = mappings.get(0);\r\n    assertThat(getAliasMapping(mappingA, 0)).isNull();\r\n    assertThat(getAliasMapping(mappingA, 1)).isNull();\r\n    assertThat(getAliasMapping(mappingA, 2)).isNull();\r\n    assertThat(getAliasMapping(mappingA, 3)).isNull();\r\n    assertThat(getAliasMapping(mappingA, 4)).isNull();\r\n    AnnotationTypeMapping mappingB = mappings.get(1);\r\n    assertThat(getAliasMapping(mappingB, 0).getName()).isEqualTo(\"a1\");\r\n    assertThat(getAliasMapping(mappingB, 1).getName()).isEqualTo(\"a1\");\r\n    AnnotationTypeMapping mappingC = mappings.get(2);\r\n    assertThat(getAliasMapping(mappingC, 0).getName()).isEqualTo(\"a1\");\r\n    assertThat(getAliasMapping(mappingC, 1).getName()).isEqualTo(\"a4\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAliasMappingsWhenHasDefinedAttributesReturnsMappedAttributes() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(DefinedAttributes.class).get(1);\r\n    assertThat(getAliasMapping(mapping, 0)).isNull();\r\n    assertThat(getAliasMapping(mapping, 1).getName()).isEqualTo(\"value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#resolveMirrorsWhenAliasPairResolves()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveMirrorsWhenAliasPairResolves() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\r\n    Method[] resolvedA = resolveMirrorSets(mapping, WithAliasPairA.class, AliasPair.class);\r\n    assertThat(resolvedA[0].getName()).isEqualTo(\"a\");\r\n    assertThat(resolvedA[1].getName()).isEqualTo(\"a\");\r\n    Method[] resolvedB = resolveMirrorSets(mapping, WithAliasPairB.class, AliasPair.class);\r\n    assertThat(resolvedB[0].getName()).isEqualTo(\"b\");\r\n    assertThat(resolvedB[1].getName()).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#resolveMirrorsWhenHasSameValuesUsesFirst()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveMirrorsWhenHasSameValuesUsesFirst() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\r\n    Method[] resolved = resolveMirrorSets(mapping, WithSameValueAliasPair.class, AliasPair.class);\r\n    assertThat(resolved[0].getName()).isEqualTo(\"a\");\r\n    assertThat(resolved[1].getName()).isEqualTo(\"a\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveMirrorsWhenOnlyHasDefaultValuesUsesFirst() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\r\n    Method[] resolved = resolveMirrorSets(mapping, WithDefaultValueAliasPair.class, AliasPair.class);\r\n    assertThat(resolved[0].getName()).isEqualTo(\"a\");\r\n    assertThat(resolved[1].getName()).isEqualTo(\"a\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#resolveMirrorsWhenHasDifferentValuesThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveMirrorsWhenHasDifferentValuesThrowsException() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(AliasPair.class).get(0);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> resolveMirrorSets(mapping, WithDifferentValueAliasPair.class, AliasPair.class)).withMessage(\"Different @AliasFor mirror values for annotation [\" + AliasPair.class.getName() + \"] declared on \" + WithDifferentValueAliasPair.class.getName() + \"; attribute 'a' and its alias 'b' are declared with values of [test1] and [test2].\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveMirrorsWhenHasWithMultipleRoutesToAliasReturnsMirrors() {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MultipleRoutesToAliasA.class);\r\n    AnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\r\n    assertThat(mappingsA.getMirrorSets().size()).isZero();\r\n    AnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\r\n    assertThat(getNames(mappingsB.getMirrorSets().get(0))).containsExactly(\"b1\", \"b2\", \"b3\");\r\n    AnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\r\n    assertThat(getNames(mappingsC.getMirrorSets().get(0))).containsExactly(\"c1\", \"c2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAliasMappingWhenHasWithMultipleRoutesToAliasReturnsMappedAttributes() {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(MultipleRoutesToAliasA.class);\r\n    AnnotationTypeMapping mappingsA = getMapping(mappings, MultipleRoutesToAliasA.class);\r\n    assertThat(getAliasMapping(mappingsA, 0)).isNull();\r\n    AnnotationTypeMapping mappingsB = getMapping(mappings, MultipleRoutesToAliasB.class);\r\n    assertThat(getAliasMapping(mappingsB, 0).getName()).isEqualTo(\"a1\");\r\n    assertThat(getAliasMapping(mappingsB, 1).getName()).isEqualTo(\"a1\");\r\n    assertThat(getAliasMapping(mappingsB, 2).getName()).isEqualTo(\"a1\");\r\n    AnnotationTypeMapping mappingsC = getMapping(mappings, MultipleRoutesToAliasC.class);\r\n    assertThat(getAliasMapping(mappingsC, 0).getName()).isEqualTo(\"a1\");\r\n    assertThat(getAliasMapping(mappingsC, 1).getName()).isEqualTo(\"a1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getConventionMappingWhenConventionToExplicitAliasesReturnsMappedAttributes() {\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(ConventionToExplicitAliases.class);\r\n    AnnotationTypeMapping mapping = getMapping(mappings, ConventionToExplicitAliasesTarget.class);\r\n    assertThat(mapping.getConventionMapping(0)).isEqualTo(0);\r\n    assertThat(mapping.getConventionMapping(1)).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEquivalentToDefaultValueWhenValueAndDefaultAreNullReturnsTrue() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValue.class).get(0);\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, null, ReflectionUtils::invokeMethod)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEquivalentToDefaultValueWhenValueAndDefaultMatchReturnsTrue() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, InputStream.class, ReflectionUtils::invokeMethod)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEquivalentToDefaultValueWhenClassAndStringNamesMatchReturnsTrue() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, \"java.io.InputStream\", ReflectionUtils::invokeMethod)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEquivalentToDefaultValueWhenClassArrayAndStringArrayNamesMatchReturnsTrue() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassArrayValueWithDefault.class).get(0);\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, new String[] { \"java.io.InputStream\", \"java.io.OutputStream\" }, ReflectionUtils::invokeMethod)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsMap() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\r\n    Map<String, Object> value = Collections.singletonMap(\"value\", \"java.io.InputStream\");\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation()",
    "entityType": "method",
    "code": "// gh-24375\r\n@Test\r\nvoid isEquivalentToDefaultValueWhenNestedAnnotationAndExtractedValuesMatchReturnsTrueAndValueSuppliedAsTypeMappedAnnotation() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(NestedValue.class).get(0);\r\n    Map<String, String> attributes = Collections.singletonMap(\"value\", \"java.io.InputStream\");\r\n    MergedAnnotation<ClassValue> value = TypeMappedAnnotation.of(getClass().getClassLoader(), null, ClassValue.class, attributes);\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, value, TypeMappedAnnotation::extractFromMap)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#isEquivalentToDefaultValueWhenNotMatchingReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEquivalentToDefaultValueWhenNotMatchingReturnsFalse() {\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(ClassValueWithDefault.class).get(0);\r\n    assertThat(mapping.isEquivalentToDefaultValue(0, OutputStream.class, ReflectionUtils::invokeMethod)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#resolveMirrorSets(AnnotationTypeMapping,Class<?>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private Method[] resolveMirrorSets(AnnotationTypeMapping mapping, Class<?> element, Class<? extends Annotation> annotationClass) {\r\n    Annotation annotation = element.getAnnotation(annotationClass);\r\n    int[] resolved = mapping.getMirrorSets().resolve(element.getName(), annotation, ReflectionUtils::invokeMethod);\r\n    Method[] result = new Method[resolved.length];\r\n    for (int i = 0; i < resolved.length; i++) {\r\n        result[i] = resolved[i] != -1 ? mapping.getAttributes().get(resolved[i]) : null;\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAliasMapping(AnnotationTypeMapping,int)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Method getAliasMapping(AnnotationTypeMapping mapping, int attributeIndex) {\r\n    int mapped = mapping.getAliasMapping(attributeIndex);\r\n    return mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getConventionMapping(AnnotationTypeMapping,int)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Method getConventionMapping(AnnotationTypeMapping mapping, int attributeIndex) {\r\n    int mapped = mapping.getConventionMapping(attributeIndex);\r\n    return mapped != -1 ? mapping.getRoot().getAttributes().get(mapped) : null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getMapping(AnnotationTypeMappings,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private AnnotationTypeMapping getMapping(AnnotationTypeMappings mappings, Class<? extends Annotation> annotationType) {\r\n    for (AnnotationTypeMapping candidate : getAll(mappings)) {\r\n        if (candidate.getAnnotationType() == annotationType) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getAll(AnnotationTypeMappings)",
    "entityType": "method",
    "code": "private List<AnnotationTypeMapping> getAll(AnnotationTypeMappings mappings) {\r\n    // AnnotationTypeMappings does not implement Iterable so we don't create\r\n    // too many garbage Iterators\r\n    return IntStream.range(0, mappings.size()).mapToObj(mappings::get).collect(toList());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappingsTests#getNames(MirrorSet)",
    "entityType": "method",
    "code": "private List<String> getNames(MirrorSet mirrorSet) {\r\n    List<String> names = new ArrayList<>(mirrorSet.size());\r\n    for (int i = 0; i < mirrorSet.size(); i++) {\r\n        names.add(mirrorSet.get(i).getName());\r\n    }\r\n    return names;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithAliasPairA",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithAliasPairB",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithSameValueAliasPair",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithDifferentValueAliasPair",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithDefaultValueAliasPair",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests",
    "entityType": "class",
    "code": "@BeforeEach\r\nvoid clearCacheBeforeTests() {\r\n    AnnotationUtils.clearCache();\r\n}\n@Test\r\nvoid findMethodAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"annotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\r\n    // @Order is not @Inherited\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    // getAnnotation() does not search on interfaces\r\n    assertThat(getAnnotation(m, Order.class)).isNull();\r\n    // findAnnotation() does search on interfaces\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Component.class)).isNull();\r\n    assertThat(getAnnotation(m, Component.class)).isNull();\r\n    assertThat(findAnnotation(m, Component.class)).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationOnRoot() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"annotatedOnRoot\");\r\n    assertThat(m.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationOnRootButOverridden() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationNotAnnotated() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"notAnnotated\");\r\n    assertThat(findAnnotation(m, Order.class)).isNull();\r\n}\n@Test\r\nvoid findMethodAnnotationOnBridgeMethod() throws Exception {\r\n    Method bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\r\n    assertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\r\n    // As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\r\n    // annotation on its 'bridged' method [1]; however, the Eclipse compiler does\r\n    // not support this [2]. Thus, we effectively ignore the following\r\n    // assertion if the test is currently executing within the Eclipse IDE.\r\n    //\r\n    // [1] https://bugs.openjdk.java.net/browse/JDK-6695379\r\n    // [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\r\n    //\r\n    if (!IdeUtils.runningInEclipse()) {\r\n        assertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\r\n    }\r\n    assertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\r\n    assertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationOnBridgedMethod() throws Exception {\r\n    Method bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\r\n    assertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\r\n    assertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\r\n    assertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\r\n    assertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationFromInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n// SPR-16060\r\n@Test\r\nvoid findMethodAnnotationFromGenericInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n// SPR-17146\r\n@Test\r\nvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\r\n    Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\r\n    Method method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n@Test\r\nvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\r\n    Method method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n// @since 4.1.2\r\n@Test\r\nvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\r\n    Component component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\r\n    assertThat(component).isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}\n// @since 4.0.3\r\n@Test\r\nvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\r\n    Transactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\r\n    assertThat(transactional).isNotNull();\r\n    assertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\r\n}\n// @since 4.0.3\r\n@Test\r\nvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\r\n    Component component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\r\n    assertThat(component).isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\r\n    Component component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\r\n    assertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\r\n    Component component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\r\n    assertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    // TransactionalClass is NOT annotated or meta-annotated with @Component\r\n    Component component = findAnnotation(TransactionalClass.class, Component.class);\r\n    assertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\r\n}\n@Test\r\nvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    Component component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\r\n    assertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnInheritedAnnotationInterface() {\r\n    Transactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\r\n    Transactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\r\n    Transactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\r\n    Order order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\r\n    Order order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\r\n}\n// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\r\n    Order order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findAnnotationDeclaringClassForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClass() should still find it on classes.\r\n    assertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n}\n@Test\r\nvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\r\n    // no class-level annotation\r\n    List<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClassForTypes() should still find it on classes.\r\n    List<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n}\n@Test\r\nvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\r\n    List<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\r\n    // no class-level annotation\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClassForTypes() should still find it on classes.\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    // class hierarchy mixed with @Transactional and @Order declarations\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\r\n}\n@Test\r\nvoid isAnnotationDeclaredLocallyForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\r\n}\n@Test\r\nvoid isAnnotationInheritedForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\r\n    // isAnnotationInherited() does not currently traverse interface hierarchies.\r\n    // Thus the following, though perhaps counterintuitive, must be false:\r\n    assertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\r\n}\n@Test\r\nvoid isAnnotationMetaPresentForPlainType() {\r\n    assertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\r\n}\n@Test\r\nvoid getAnnotationAttributesWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    AnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\r\n    assertThat(attributes.annotationType()).isEqualTo(Component.class);\r\n}\n@Test\r\nvoid getAnnotationAttributesWithNestedAnnotations() {\r\n    ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\r\n    assertThat(componentScan).isNotNull();\r\n    AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\r\n    Filter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(filters).isNotNull();\r\n    List<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\r\n}\n@Test\r\nvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    WebMapping webMapping = method.getAnnotation(WebMapping.class);\r\n    AnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\r\n    assertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\r\n    assertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\r\n    assertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\r\n    method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    webMapping = method.getAnnotation(WebMapping.class);\r\n    attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\r\n    assertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\r\n    assertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\r\n    assertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\r\n}\n@Test\r\nvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\r\n    WebMapping webMapping = method.getAnnotation(WebMapping.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> getAnnotationAttributes(webMapping)).withMessageContaining(\"attribute 'path' and its alias 'value'\").withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\r\n}\n@Test\r\nvoid getValueFromAnnotation() throws Exception {\r\n    Method method = SimpleFoo.class.getMethod(\"something\", Object.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(getValue(order, VALUE)).isEqualTo(1);\r\n    assertThat(getValue(order)).isEqualTo(1);\r\n}\n@Test\r\nvoid getValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation annotation = declaredAnnotations[0];\r\n    assertThat(annotation).isNotNull();\r\n    assertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(getValue(annotation, VALUE)).isEqualTo(42);\r\n    assertThat(getValue(annotation)).isEqualTo(42);\r\n}\n@Test\r\nvoid getDefaultValueFromAnnotation() throws Exception {\r\n    Method method = SimpleFoo.class.getMethod(\"something\", Object.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n    assertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n}\n@Test\r\nvoid getDefaultValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation annotation = declaredAnnotations[0];\r\n    assertThat(annotation).isNotNull();\r\n    assertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\r\n    assertThat(getDefaultValue(annotation)).isEqualTo(-1);\r\n}\n@Test\r\nvoid getDefaultValueFromAnnotationType() {\r\n    assertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n    assertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n}\n@Test\r\nvoid findRepeatableAnnotation() {\r\n    Repeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\r\n    assertThat(repeatable).isNotNull();\r\n    assertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\r\n}\n@Test\r\nvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\r\n    Method method = InterfaceWithRepeated.class.getMethod(\"foo\");\r\n    Set<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(annotations).isNotNull();\r\n    List<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\r\n}\n@Test\r\nvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\r\n    final List<String> expectedLocations = asList(\"A\", \"B\");\r\n    Set<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\r\n    assertThat(annotations).isNotNull();\r\n    assertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\r\n    annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\r\n    assertThat(annotations).isNotNull();\r\n    List<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\r\n    assertThat(locations).isEqualTo(expectedLocations);\r\n    List<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedLocations);\r\n}\n@Test\r\nvoid getRepeatableAnnotationsDeclaredOnClass() {\r\n    final List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\r\n    final List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\r\n    // Java 8\r\n    MyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}\n@Test\r\nvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\r\n    final Class<?> clazz = SubMyRepeatableClass.class;\r\n    final List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\r\n    final List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}\n@Test\r\nvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\r\n    final Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    final List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\r\n    final List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}\n@Test\r\nvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\r\n    final Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    final List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\r\n    final List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}\n@Test\r\nvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\r\n    final List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\r\n    final List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\r\n    // Java 8\r\n    MyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}\n@Test\r\nvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\r\n    final Class<?> clazz = SubMyRepeatableClass.class;\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    assertThat(array).isEmpty();\r\n    // Spring\r\n    Set<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    assertThat(set).isEmpty();\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    assertThat(set).isEmpty();\r\n}\n@Test\r\nvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\r\n    Class<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType = ImplicitAliasesWithMissingDefaultValuesContextConfig.class;\r\n    ImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\r\n    assertThat(config).isNotNull();\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> synthesizeAnnotation(config, clazz)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"default values\");\r\n}\n@Test\r\nvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\r\n    Class<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType = ImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\r\n    ImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\r\n    assertThat(config).isNotNull();\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> synthesizeAnnotation(config, clazz)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"same default value\");\r\n}\n@Test\r\nvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\r\n    Class<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType = ImplicitAliasesWithDuplicateValuesContextConfig.class;\r\n    ImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\r\n    assertThat(config).isNotNull();\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> synthesizeAnnotation(config, clazz).location1()).withMessageStartingWith(\"Different @AliasFor mirror values\").withMessageContaining(annotationType.getName()).withMessageContaining(\"declared on class\").withMessageContaining(clazz.getName()).withMessageContaining(\"attribute 'location1' and its alias 'location2'\").withMessageContaining(\"with values of [1] and [2]\");\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Map<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\r\n    Component synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\r\n    assertThat(synthesizedComponent).isNotNull();\r\n    assertThat(synthesizedComponent).isNotSameAs(component);\r\n    assertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\r\n    assertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeAnnotationFromMapWithNestedMap() {\r\n    ComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\r\n    assertThat(componentScan).isNotNull();\r\n    assertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\r\n    AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanSingleFilterClass.class, componentScan, false, true);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\r\n    Map<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\r\n    assertThat(filterMap).isNotNull();\r\n    assertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\r\n    // Modify nested map\r\n    filterMap.put(\"pattern\", \"newFoo\");\r\n    filterMap.put(\"enigma\", 42);\r\n    ComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(attributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\r\n    assertThat(synthesizedComponentScan).isNotNull();\r\n    assertThat(synthesizedComponentScan).isNotSameAs(componentScan);\r\n    assertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\r\n    ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\r\n    assertThat(componentScan).isNotNull();\r\n    AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\r\n    Map<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\r\n    assertThat(filters).isNotNull();\r\n    List<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\r\n    // Modify nested maps\r\n    filters[0].put(\"pattern\", \"newFoo\");\r\n    filters[0].put(\"enigma\", 42);\r\n    filters[1].put(\"pattern\", \"newBar\");\r\n    filters[1].put(\"enigma\", 42);\r\n    ComponentScan synthesizedComponentScan = synthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\r\n    assertThat(synthesizedComponentScan).isNotNull();\r\n    assertThat(synthesizedComponentScan).isNotSameAs(componentScan);\r\n    patterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\r\n}\n@Test\r\nvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\r\n    AnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\r\n    assertThat(annotationWithDefaults).isNotNull();\r\n    assertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\r\n    assertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\r\n    assertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\r\n}\n@Test\r\nvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\r\n    ContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\r\n    assertThat(contextConfig).isNotNull();\r\n    assertThat(contextConfig.value()).as(\"value: \").isEmpty();\r\n    assertThat(contextConfig.location()).as(\"location: \").isEmpty();\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\r\n    Map<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\r\n    ContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\r\n    assertThat(contextConfig).isNotNull();\r\n    assertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\r\n    assertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\r\n    Map<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\r\n    Get get = synthesizeAnnotation(map, Get.class, null);\r\n    assertThat(get).isNotNull();\r\n    assertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\r\n    assertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\r\n    map = Collections.singletonMap(\"path\", \"/foo\");\r\n    get = synthesizeAnnotation(map, Get.class, null);\r\n    assertThat(get).isNotNull();\r\n    assertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\r\n    assertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\r\n}\nprivate void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\r\n    Map<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\r\n    ImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\r\n    assertThat(config).isNotNull();\r\n    assertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\r\n    assertMissingTextAttribute(Collections.emptyMap());\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithNullAttributeValue() {\r\n    Map<String, Object> map = Collections.singletonMap(\"text\", null);\r\n    assertThat(map.containsKey(\"text\")).isTrue();\r\n    assertMissingTextAttribute(map);\r\n}\nprivate void assertMissingTextAttribute(Map<String, Object> attributes) {\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() -> synthesizeAnnotation(attributes, AnnotationWithoutDefaults.class, null).text()).withMessageContaining(\"No value found for attribute named 'text' in merged annotation\");\r\n}\n@Test\r\nvoid synthesizeAnnotationFromMapWithAttributeOfIncorrectType() {\r\n    Map<String, Object> map = Collections.singletonMap(VALUE, 42L);\r\n    assertThatIllegalStateException().isThrownBy(() -> synthesizeAnnotation(map, Component.class, null).value()).withMessageContaining(\"Attribute 'value' in annotation org.springframework.core.testfixture.stereotype.Component \" + \"should be compatible with java.lang.String but a java.lang.Long value was returned\");\r\n}\n@Test\r\nvoid synthesizeAnnotationFromAnnotationAttributesWithoutAttributeAliases() {\r\n    // 1) Get an annotation\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    // 2) Convert the annotation into AnnotationAttributes\r\n    AnnotationAttributes attributes = getAnnotationAttributes(WebController.class, component);\r\n    assertThat(attributes).isNotNull();\r\n    // 3) Synthesize the AnnotationAttributes back into an annotation\r\n    Component synthesizedComponent = synthesizeAnnotation(attributes, Component.class, WebController.class);\r\n    assertThat(synthesizedComponent).isNotNull();\r\n    // 4) Verify that the original and synthesized annotations are equivalent\r\n    assertThat(synthesizedComponent).isNotSameAs(component);\r\n    assertThat(synthesizedComponent).isEqualTo(component);\r\n    assertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\r\n    assertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\r\n}\n// gh-22702\r\n@Test\r\nvoid findAnnotationWithRepeatablesElements() {\r\n    assertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class, TestRepeatable.class)).isNull();\r\n    assertThat(AnnotationUtils.findAnnotation(TestRepeatablesClass.class, TestRepeatableContainer.class)).isNotNull();\r\n}\n// gh-23856\r\n@Test\r\nvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() {\r\n    MyRepeatableContainer annotation = AnnotationUtils.findAnnotation(MyRepeatableMeta1And2.class, MyRepeatableContainer.class);\r\n    assertThat(annotation).isNotNull();\r\n    assertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\r\n}\n// gh-23856\r\n@Test\r\nvoid findAnnotationFindsRepeatableContainerOnComposedAnnotationMetaAnnotatedWithRepeatableAnnotationsOnMethod() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations\");\r\n    MyRepeatableContainer annotation = AnnotationUtils.findAnnotation(method, MyRepeatableContainer.class);\r\n    assertThat(annotation).isNotNull();\r\n    assertThat(annotation.value()).extracting(MyRepeatable::value).containsExactly(\"meta1\", \"meta2\");\r\n}\n// gh-23929\r\n@Test\r\nvoid findDeprecatedAnnotation() {\r\n    assertThat(getAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\r\n    assertThat(getAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNull();\r\n    assertThat(findAnnotation(DeprecatedClass.class, Deprecated.class)).isNotNull();\r\n    assertThat(findAnnotation(SubclassOfDeprecatedClass.class, Deprecated.class)).isNotNull();\r\n}\n@SafeVarargs\r\nstatic <T> T[] asArray(T... arr) {\r\n    return arr;\r\n}\n@Component(\"meta1\")\r\n@Order\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface Meta1 {\r\n}\n@Component(\"meta2\")\r\n@Transactional(readOnly = true)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface Meta2 {\r\n}\n@Meta2\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaMeta {\r\n}\n@MetaMeta\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaMetaMeta {\r\n}\n@MetaCycle3\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaCycle1 {\r\n}\n@MetaCycle1\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaCycle2 {\r\n}\n@MetaCycle2\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaCycle3 {\r\n}\n@Meta1\r\ninterface InterfaceWithMetaAnnotation {\r\n}\n@Meta2\r\nstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\r\n}\n@Meta1\r\nstatic class ClassWithInheritedMetaAnnotation {\r\n}\n@Meta2\r\nstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\r\n}\nstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\r\n}\n@Transactional\r\nstatic class ClassWithInheritedAnnotation {\r\n}\n@Meta2\r\nstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\r\n}\nstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\r\n}\n@MetaMeta\r\nstatic class MetaMetaAnnotatedClass {\r\n}\n@MetaMetaMeta\r\nstatic class MetaMetaMetaAnnotatedClass {\r\n}\n@MetaCycle3\r\nstatic class MetaCycleAnnotatedClass {\r\n}\npublic interface AnnotatedInterface {\r\n\r\n    @Order(0)\r\n    void fromInterfaceImplementedByRoot();\r\n}\npublic static class Root implements AnnotatedInterface {\r\n\r\n    @Order(27)\r\n    public void annotatedOnRoot() {\r\n    }\r\n\r\n    @Meta1\r\n    public void metaAnnotatedOnRoot() {\r\n    }\r\n\r\n    public void overrideToAnnotate() {\r\n    }\r\n\r\n    @Order(27)\r\n    public void overrideWithoutNewAnnotation() {\r\n    }\r\n\r\n    public void notAnnotated() {\r\n    }\r\n\r\n    @Override\r\n    public void fromInterfaceImplementedByRoot() {\r\n    }\r\n}\npublic static class Leaf extends Root {\r\n\r\n    @Order(25)\r\n    public void annotatedOnLeaf() {\r\n    }\r\n\r\n    @Meta1\r\n    public void metaAnnotatedOnLeaf() {\r\n    }\r\n\r\n    @MetaMeta\r\n    public void metaMetaAnnotatedOnLeaf() {\r\n    }\r\n\r\n    @Override\r\n    @Order(1)\r\n    public void overrideToAnnotate() {\r\n    }\r\n\r\n    @Override\r\n    public void overrideWithoutNewAnnotation() {\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface Transactional {\r\n\r\n    boolean readOnly() default false;\r\n}\npublic abstract static class Foo<T> {\r\n\r\n    @Order(1)\r\n    public abstract void something(T arg);\r\n}\npublic static class SimpleFoo extends Foo<String> {\r\n\r\n    @Override\r\n    @Transactional\r\n    public void something(final String arg) {\r\n    }\r\n}\n@Transactional\r\npublic interface InheritedAnnotationInterface {\r\n}\npublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\r\n}\npublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\r\n}\n@Order\r\npublic interface NonInheritedAnnotationInterface {\r\n}\npublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\r\n}\npublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\r\n}\npublic static class NonAnnotatedClass {\r\n}\npublic interface NonAnnotatedInterface {\r\n}\n@Transactional\r\npublic static class InheritedAnnotationClass {\r\n}\npublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\r\n}\n@Order\r\npublic static class NonInheritedAnnotationClass {\r\n}\npublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\r\n}\n@Transactional\r\npublic static class TransactionalClass {\r\n}\n@Order\r\npublic static class TransactionalAndOrderedClass extends TransactionalClass {\r\n}\npublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\r\n}\npublic interface InterfaceWithAnnotatedMethod {\r\n\r\n    @Order\r\n    void foo();\r\n}\npublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\r\n\r\n    @Override\r\n    public void foo() {\r\n    }\r\n}\npublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\r\n\r\n    @Override\r\n    public void foo() {\r\n    }\r\n}\npublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\r\n}\npublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod extends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\r\n\r\n    @Override\r\n    public void foo() {\r\n    }\r\n}\npublic interface InterfaceWithGenericAnnotatedMethod<T> {\r\n\r\n    @Order\r\n    void foo(T t);\r\n}\npublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\r\n\r\n    @Override\r\n    public void foo(String t) {\r\n    }\r\n}\npublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\r\n\r\n    @Order\r\n    abstract void foo(T t);\r\n}\npublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\r\n\r\n    @Override\r\n    public void foo(String t) {\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface MyRepeatableContainer {\r\n\r\n    MyRepeatable[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@Repeatable(MyRepeatableContainer.class)\r\n@interface MyRepeatable {\r\n\r\n    String value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@MyRepeatable(\"meta1\")\r\n@interface MyRepeatableMeta1 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@MyRepeatable(\"meta2\")\r\n@interface MyRepeatableMeta2 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@MyRepeatable(\"meta1\")\r\n@MyRepeatable(\"meta2\")\r\n@interface MyRepeatableMeta1And2 {\r\n}\n@MyRepeatableMeta1And2\r\nvoid methodWithComposedAnnotationMetaAnnotatedWithRepeatableAnnotations() ;\ninterface InterfaceWithRepeated {\r\n\r\n    @MyRepeatable(\"A\")\r\n    @MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\r\n    @MyRepeatableMeta1\r\n    void foo();\r\n}\n@MyRepeatable(\"A\")\r\n@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\r\n@MyRepeatableMeta1\r\nstatic class MyRepeatableClass {\r\n}\nstatic class SubMyRepeatableClass extends MyRepeatableClass {\r\n}\n@MyRepeatable(\"X\")\r\n@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\r\n@MyRepeatableMeta2\r\nstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\r\n}\nstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\r\n}\nenum RequestMethod {\r\n\r\n    GET, POST\r\n}\n/**\r\n * Mock of {@code org.springframework.web.bind.annotation.RequestMapping}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface WebMapping {\r\n\r\n    String name();\r\n\r\n    @AliasFor(\"path\")\r\n    String[] value() default \"\";\r\n\r\n    @AliasFor(attribute = \"value\")\r\n    String[] path() default \"\";\r\n\r\n    RequestMethod[] method() default {};\r\n}\n/**\r\n * Mock of {@code org.springframework.web.bind.annotation.GetMapping}, except\r\n * that the String arrays are overridden with single String elements.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@WebMapping(method = RequestMethod.GET, name = \"\")\r\n@interface Get {\r\n\r\n    @AliasFor(annotation = WebMapping.class)\r\n    String value() default \"\";\r\n\r\n    @AliasFor(annotation = WebMapping.class)\r\n    String path() default \"\";\r\n}\n/**\r\n * Mock of {@code org.springframework.web.bind.annotation.PostMapping}, except\r\n * that the path is overridden by convention with single String element.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@WebMapping(method = RequestMethod.POST, name = \"\")\r\n@interface Post {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = WebMapping.class)\r\n    String path() default \"\";\r\n}\n@Component(\"webController\")\r\nstatic class WebController {\r\n\r\n    @WebMapping(value = \"/test\", name = \"foo\")\r\n    public void handleMappedWithValueAttribute() {\r\n    }\r\n\r\n    @WebMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\r\n    public void handleMappedWithPathAttribute() {\r\n    }\r\n\r\n    @Get(\"/test\")\r\n    public void getMappedWithValueAttribute() {\r\n    }\r\n\r\n    @Get(path = \"/test\")\r\n    public void getMappedWithPathAttribute() {\r\n    }\r\n\r\n    @Post(path = \"/test\")\r\n    public void postMappedWithPathAttribute() {\r\n    }\r\n\r\n    /**\r\n     * mapping is logically \"equal\" to handleMappedWithPathAttribute().\r\n     */\r\n    @WebMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\r\n    public void handleMappedWithSamePathAndValueAttributes() {\r\n    }\r\n\r\n    @WebMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\r\n    public void handleMappedWithDifferentPathAndValueAttributes() {\r\n    }\r\n}\n/**\r\n * Mock of {@code org.springframework.test.context.ContextConfiguration}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ContextConfig {\r\n\r\n    @AliasFor(\"location\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(\"value\")\r\n    String location() default \"\";\r\n\r\n    Class<?> klass() default Object.class;\r\n}\n/**\r\n * Mock of {@code org.springframework.test.context.ContextHierarchy}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface Hierarchy {\r\n\r\n    ContextConfig[] value();\r\n}\n@Hierarchy({ @ContextConfig(\"A\"), @ContextConfig(location = \"B\") })\r\nstatic class ConfigHierarchyTestCase {\r\n}\n@ContextConfig(\"simple.xml\")\r\nstatic class SimpleConfigTestCase {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface CharsContainer {\r\n\r\n    @AliasFor(attribute = \"chars\")\r\n    char[] value() default {};\r\n\r\n    @AliasFor(attribute = \"value\")\r\n    char[] chars() default {};\r\n}\n@CharsContainer(chars = { 'x', 'y', 'z' })\r\nstatic class GroupOfCharsClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithMissingAttributeDeclaration {\r\n\r\n    @AliasFor\r\n    String foo() default \"\";\r\n}\n@AliasForWithMissingAttributeDeclaration\r\nstatic class AliasForWithMissingAttributeDeclarationClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithDuplicateAttributeDeclaration {\r\n\r\n    @AliasFor(value = \"bar\", attribute = \"baz\")\r\n    String foo() default \"\";\r\n}\n@AliasForWithDuplicateAttributeDeclaration\r\nstatic class AliasForWithDuplicateAttributeDeclarationClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForNonexistentAttribute {\r\n\r\n    @AliasFor(\"bar\")\r\n    String foo() default \"\";\r\n}\n@AliasForNonexistentAttribute\r\nstatic class AliasForNonexistentAttributeClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithoutMirroredAliasFor {\r\n\r\n    @AliasFor(\"bar\")\r\n    String foo() default \"\";\r\n\r\n    String bar() default \"\";\r\n}\n@AliasForWithoutMirroredAliasFor\r\nstatic class AliasForWithoutMirroredAliasForClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithMirroredAliasForWrongAttribute {\r\n\r\n    @AliasFor(attribute = \"bar\")\r\n    String[] foo() default \"\";\r\n\r\n    @AliasFor(attribute = \"quux\")\r\n    String[] bar() default \"\";\r\n}\n@AliasForWithMirroredAliasForWrongAttribute\r\nstatic class AliasForWithMirroredAliasForWrongAttributeClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForAttributeOfDifferentType {\r\n\r\n    @AliasFor(\"bar\")\r\n    String[] foo() default \"\";\r\n\r\n    @AliasFor(\"foo\")\r\n    boolean bar() default true;\r\n}\n@AliasForAttributeOfDifferentType\r\nstatic class AliasForAttributeOfDifferentTypeClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithMissingDefaultValues {\r\n\r\n    @AliasFor(attribute = \"bar\")\r\n    String foo();\r\n\r\n    @AliasFor(attribute = \"foo\")\r\n    String bar();\r\n}\n@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\r\nstatic class AliasForWithMissingDefaultValuesClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForAttributeWithDifferentDefaultValue {\r\n\r\n    @AliasFor(\"bar\")\r\n    String foo() default \"X\";\r\n\r\n    @AliasFor(\"foo\")\r\n    String bar() default \"Z\";\r\n}\n@AliasForAttributeWithDifferentDefaultValue\r\nstatic class AliasForAttributeWithDifferentDefaultValueClass {\r\n}\n// @ContextConfig --> Intentionally NOT meta-present\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedContextConfigNotMetaPresent {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String xmlConfigFile();\r\n}\n@AliasedComposedContextConfigNotMetaPresent(xmlConfigFile = \"test.xml\")\r\nstatic class AliasedComposedContextConfigNotMetaPresentClass {\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String xmlConfigFile();\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface ImplicitAliasesContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String xmlFile() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String groovyScript() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location1() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location2() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location3() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"klass\")\r\n    Class<?> configClass() default Object.class;\r\n\r\n    String nonAliasedAttribute() default \"\";\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesContextConfig(groovyScript = \"groovyScript\")\r\nstatic class GroovyImplicitAliasesContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesContextConfig(xmlFile = \"xmlFile\")\r\nstatic class XmlImplicitAliasesContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesContextConfig(\"value\")\r\nstatic class ValueImplicitAliasesContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesContextConfig(location1 = \"location1\")\r\nstatic class Location1ImplicitAliasesContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesContextConfig(location2 = \"location2\")\r\nstatic class Location2ImplicitAliasesContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesContextConfig(location3 = \"location3\")\r\nstatic class Location3ImplicitAliasesContextConfigClass {\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\r\n\r\n    // intentionally omitted: attribute = \"value\"\r\n    @AliasFor(annotation = ContextConfig.class)\r\n    String value() default \"\";\r\n\r\n    // intentionally omitted: attribute = \"locations\"\r\n    @AliasFor(annotation = ContextConfig.class)\r\n    String location() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String xmlFile() default \"\";\r\n}\n@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedContextConfig {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"xmlFile\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig.class, attribute = \"location\")\r\n    String groovy() default \"\";\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(\"value\")\r\nstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(location = \"location\")\r\nstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\r\n}\n// Attribute value intentionally matches attribute name:\r\n@ImplicitAliasesWithImpliedAliasNamesOmittedContextConfig(xmlFile = \"xmlFile\")\r\nstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass {\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithMissingDefaultValuesContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location1();\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location2();\r\n}\n@ImplicitAliasesWithMissingDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\r\nstatic class ImplicitAliasesWithMissingDefaultValuesContextConfigClass {\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithDifferentDefaultValuesContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location1() default \"foo\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location2() default \"bar\";\r\n}\n@ImplicitAliasesWithDifferentDefaultValuesContextConfig(location1 = \"1\", location2 = \"2\")\r\nstatic class ImplicitAliasesWithDifferentDefaultValuesContextConfigClass {\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithDuplicateValuesContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location1() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String location2() default \"\";\r\n}\n@ImplicitAliasesWithDuplicateValuesContextConfig(location1 = \"1\", location2 = \"2\")\r\nstatic class ImplicitAliasesWithDuplicateValuesContextConfigClass {\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesForAliasPairContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"location\")\r\n    String xmlFile() default \"\";\r\n\r\n    @AliasFor(annotation = ContextConfig.class, value = \"value\")\r\n    String groovyScript() default \"\";\r\n}\n@ImplicitAliasesForAliasPairContextConfig(xmlFile = \"test.xml\")\r\nstatic class ImplicitAliasesForAliasPairContextConfigClass {\r\n}\n@ImplicitAliasesContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesContextConfig {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFile\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScript\")\r\n    String groovy() default \"\";\r\n}\n@TransitiveImplicitAliasesContextConfig(xml = \"test.xml\")\r\nstatic class TransitiveImplicitAliasesContextConfigClass {\r\n}\n@ImplicitAliasesForAliasPairContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesForAliasPairContextConfig {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"xmlFile\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesForAliasPairContextConfig.class, attribute = \"groovyScript\")\r\n    String groovy() default \"\";\r\n}\n@TransitiveImplicitAliasesForAliasPairContextConfig(xml = \"test.xml\")\r\nstatic class TransitiveImplicitAliasesForAliasPairContextConfigClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({})\r\n@interface Filter {\r\n\r\n    String pattern();\r\n}\n/**\r\n * Mock of {@code org.springframework.context.annotation.ComponentScan}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComponentScan {\r\n\r\n    Filter[] excludeFilters() default {};\r\n}\n@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\") })\r\nstatic class ComponentScanClass {\r\n}\n/**\r\n * Mock of {@code org.springframework.context.annotation.ComponentScan}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComponentScanSingleFilter {\r\n\r\n    Filter value();\r\n}\n@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\r\nstatic class ComponentScanSingleFilterClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AnnotationWithDefaults {\r\n\r\n    String text() default \"enigma\";\r\n\r\n    boolean predicate() default true;\r\n\r\n    char[] characters() default { 'a', 'b', 'c' };\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AnnotationWithoutDefaults {\r\n\r\n    String text();\r\n}\n@ContextConfig(value = \"foo\", location = \"bar\")\r\ninterface ContextConfigMismatch {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(TestRepeatableContainer.class)\r\n@interface TestRepeatable {\r\n\r\n    String value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestRepeatableContainer {\r\n\r\n    TestRepeatable[] value();\r\n}\n@TestRepeatable(\"a\")\r\n@TestRepeatable(\"b\")\r\nstatic class TestRepeatablesClass {\r\n}\n@Deprecated\r\nstatic class DeprecatedClass {\r\n}\nstatic class SubclassOfDeprecatedClass extends DeprecatedClass {\r\n}",
    "comment": "\n * Tests for {@link AnnotationUtils}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#clearCacheBeforeTests()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid clearCacheBeforeTests() {\r\n    AnnotationUtils.clearCache();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnLeaf()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"annotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithAnnotationOnMethodInInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithAnnotationOnMethodInInterface() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\r\n    // @Order is not @Inherited\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    // getAnnotation() does not search on interfaces\r\n    assertThat(getAnnotation(m, Order.class)).isNull();\r\n    // findAnnotation() does search on interfaces\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithMetaAnnotationOnLeaf()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithMetaAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithMetaMetaAnnotationOnLeaf()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithMetaMetaAnnotationOnLeaf() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\r\n    assertThat(m.getAnnotation(Component.class)).isNull();\r\n    assertThat(getAnnotation(m, Component.class)).isNull();\r\n    assertThat(findAnnotation(m, Component.class)).isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnRoot()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationOnRoot() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"annotatedOnRoot\");\r\n    assertThat(m.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationWithMetaAnnotationOnRoot()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findMethodAnnotationWithMetaAnnotationOnRoot() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNotNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnRootButOverridden()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationOnRootButOverridden() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\r\n    assertThat(m.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(m, Order.class)).isNull();\r\n    assertThat(findAnnotation(m, Order.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationNotAnnotated()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationNotAnnotated() throws Exception {\r\n    Method m = Leaf.class.getMethod(\"notAnnotated\");\r\n    assertThat(findAnnotation(m, Order.class)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnBridgeMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationOnBridgeMethod() throws Exception {\r\n    Method bridgeMethod = SimpleFoo.class.getMethod(\"something\", Object.class);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(bridgeMethod.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(bridgeMethod, Order.class)).isNull();\r\n    assertThat(findAnnotation(bridgeMethod, Order.class)).isNotNull();\r\n    // As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\r\n    // annotation on its 'bridged' method [1]; however, the Eclipse compiler does\r\n    // not support this [2]. Thus, we effectively ignore the following\r\n    // assertion if the test is currently executing within the Eclipse IDE.\r\n    //\r\n    // [1] https://bugs.openjdk.java.net/browse/JDK-6695379\r\n    // [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\r\n    //\r\n    if (!IdeUtils.runningInEclipse()) {\r\n        assertThat(bridgeMethod.getAnnotation(Transactional.class)).isNotNull();\r\n    }\r\n    assertThat(getAnnotation(bridgeMethod, Transactional.class)).isNotNull();\r\n    assertThat(findAnnotation(bridgeMethod, Transactional.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationOnBridgedMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationOnBridgedMethod() throws Exception {\r\n    Method bridgedMethod = SimpleFoo.class.getMethod(\"something\", String.class);\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    assertThat(bridgedMethod.getAnnotation(Order.class)).isNull();\r\n    assertThat(getAnnotation(bridgedMethod, Order.class)).isNull();\r\n    assertThat(findAnnotation(bridgedMethod, Order.class)).isNotNull();\r\n    assertThat(bridgedMethod.getAnnotation(Transactional.class)).isNotNull();\r\n    assertThat(getAnnotation(bridgedMethod, Transactional.class)).isNotNull();\r\n    assertThat(findAnnotation(bridgedMethod, Transactional.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationFromInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationFromInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationFromGenericInterface()",
    "entityType": "method",
    "code": "// SPR-16060\r\n@Test\r\nvoid findMethodAnnotationFromGenericInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationFromGenericSuperclass()",
    "entityType": "method",
    "code": "// SPR-17146\r\n@Test\r\nvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\r\n    Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationFromInterfaceOnSuper()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationFromInterfaceOnSuper() throws Exception {\r\n    Method method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMethodAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\r\n    Method method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces()",
    "entityType": "method",
    "code": "// @since 4.1.2\r\n@Test\r\nvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\r\n    Component component = findAnnotation(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, Component.class);\r\n    assertThat(component).isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}",
    "comment": " @since 4.1.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations()",
    "entityType": "method",
    "code": "// @since 4.0.3\r\n@Test\r\nvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\r\n    Transactional transactional = findAnnotation(SubSubClassWithInheritedAnnotation.class, Transactional.class);\r\n    assertThat(transactional).isNotNull();\r\n    assertThat(transactional.readOnly()).as(\"readOnly flag for SubSubClassWithInheritedAnnotation\").isTrue();\r\n}",
    "comment": " @since 4.0.3"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations()",
    "entityType": "method",
    "code": "// @since 4.0.3\r\n@Test\r\nvoid findClassAnnotationFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\r\n    Component component = findAnnotation(SubSubClassWithInheritedMetaAnnotation.class, Component.class);\r\n    assertThat(component).isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}",
    "comment": " @since 4.0.3"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnMetaMetaAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findClassAnnotationOnMetaMetaAnnotatedClass() {\r\n    Component component = findAnnotation(MetaMetaAnnotatedClass.class, Component.class);\r\n    assertThat(component).as(\"Should find meta-annotation on composed annotation on class\").isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnMetaMetaMetaAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findClassAnnotationOnMetaMetaMetaAnnotatedClass() {\r\n    Component component = findAnnotation(MetaMetaMetaAnnotatedClass.class, Component.class);\r\n    assertThat(component).as(\"Should find meta-annotation on meta-annotation on composed annotation on class\").isNotNull();\r\n    assertThat(component.value()).isEqualTo(\"meta2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findClassAnnotationOnAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    // TransactionalClass is NOT annotated or meta-annotated with @Component\r\n    Component component = findAnnotation(TransactionalClass.class, Component.class);\r\n    assertThat(component).as(\"Should not find @Component on TransactionalClass\").isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findClassAnnotationOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    Component component = findAnnotation(MetaCycleAnnotatedClass.class, Component.class);\r\n    assertThat(component).as(\"Should not find @Component on MetaCycleAnnotatedClass\").isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnInheritedAnnotationInterface() {\r\n    Transactional tx = findAnnotation(InheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(tx).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubInheritedAnnotationInterface() {\r\n    Transactional tx = findAnnotation(SubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(tx).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnSubSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubSubInheritedAnnotationInterface() {\r\n    Transactional tx = findAnnotation(SubSubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(tx).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnNonInheritedAnnotationInterface() {\r\n    Order order = findAnnotation(NonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(order).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubNonInheritedAnnotationInterface() {\r\n    Order order = findAnnotation(SubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(order).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findClassAnnotationOnSubSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "// @since 4.2\r\n@Test\r\nvoid findClassAnnotationOnSubSubNonInheritedAnnotationInterface() {\r\n    Order order = findAnnotation(SubSubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(order).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": " @since 4.2"
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findAnnotationDeclaringClassForAllScenarios()",
    "entityType": "method",
    "code": "@Test\r\nvoid findAnnotationDeclaringClassForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClass() should still find it on classes.\r\n    assertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findAnnotationDeclaringClassForTypesWithSingleCandidateType()",
    "entityType": "method",
    "code": "@Test\r\nvoid findAnnotationDeclaringClassForTypesWithSingleCandidateType() {\r\n    // no class-level annotation\r\n    List<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClassForTypes() should still find it on classes.\r\n    List<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {\r\n    List<Class<? extends Annotation>> candidates = asList(Transactional.class, Order.class);\r\n    // no class-level annotation\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClassForTypes() should still find it on classes.\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class)).isNull();\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    // class hierarchy mixed with @Transactional and @Order declarations\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class)).isEqualTo(TransactionalClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\r\n    assertThat(findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class)).isEqualTo(TransactionalAndOrderedClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#isAnnotationDeclaredLocallyForAllScenarios()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotationDeclaredLocallyForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedInterface.class)).isFalse();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, NonAnnotatedClass.class)).isFalse();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationInterface.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, InheritedAnnotationClass.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Transactional.class, SubInheritedAnnotationClass.class)).isFalse();\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationInterface.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, NonInheritedAnnotationClass.class)).isTrue();\r\n    assertThat(isAnnotationDeclaredLocally(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#isAnnotationInheritedForAllScenarios()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotationInheritedForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(isAnnotationInherited(Transactional.class, NonAnnotatedInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Transactional.class, NonAnnotatedClass.class)).isFalse();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationInterface.class)).isFalse();\r\n    // isAnnotationInherited() does not currently traverse interface hierarchies.\r\n    // Thus the following, though perhaps counterintuitive, must be false:\r\n    assertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Transactional.class, InheritedAnnotationClass.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Transactional.class, SubInheritedAnnotationClass.class)).isTrue();\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationInterface.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Order.class, NonInheritedAnnotationClass.class)).isFalse();\r\n    assertThat(isAnnotationInherited(Order.class, SubNonInheritedAnnotationClass.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#isAnnotationMetaPresentForPlainType()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotationMetaPresentForPlainType() {\r\n    assertThat(isAnnotationMetaPresent(Order.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotationMetaPresent(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getAnnotationAttributesWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationAttributesWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    AnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(component);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.getString(VALUE)).as(\"value attribute: \").isEqualTo(\"webController\");\r\n    assertThat(attributes.annotationType()).isEqualTo(Component.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getAnnotationAttributesWithNestedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationAttributesWithNestedAnnotations() {\r\n    ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\r\n    assertThat(componentScan).isNotNull();\r\n    AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\r\n    Filter[] filters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(filters).isNotNull();\r\n    List<String> patterns = stream(filters).map(Filter::pattern).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getAnnotationAttributesWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationAttributesWithAttributeAliases() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    WebMapping webMapping = method.getAnnotation(WebMapping.class);\r\n    AnnotationAttributes attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\r\n    assertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"foo\");\r\n    assertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\r\n    assertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\r\n    method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    webMapping = method.getAnnotation(WebMapping.class);\r\n    attributes = (AnnotationAttributes) getAnnotationAttributes(webMapping);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(WebMapping.class);\r\n    assertThat(attributes.getString(\"name\")).as(\"name attribute: \").isEqualTo(\"bar\");\r\n    assertThat(attributes.getStringArray(VALUE)).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\r\n    assertThat(attributes.getStringArray(\"path\")).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getAnnotationAttributesWithAttributeAliasesWithDifferentValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationAttributesWithAttributeAliasesWithDifferentValues() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\r\n    WebMapping webMapping = method.getAnnotation(WebMapping.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> getAnnotationAttributes(webMapping)).withMessageContaining(\"attribute 'path' and its alias 'value'\").withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getValueFromAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getValueFromAnnotation() throws Exception {\r\n    Method method = SimpleFoo.class.getMethod(\"something\", Object.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(getValue(order, VALUE)).isEqualTo(1);\r\n    assertThat(getValue(order)).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getValueFromNonPublicAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation annotation = declaredAnnotations[0];\r\n    assertThat(annotation).isNotNull();\r\n    assertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(getValue(annotation, VALUE)).isEqualTo(42);\r\n    assertThat(getValue(annotation)).isEqualTo(42);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getDefaultValueFromAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueFromAnnotation() throws Exception {\r\n    Method method = SimpleFoo.class.getMethod(\"something\", Object.class);\r\n    Order order = findAnnotation(method, Order.class);\r\n    assertThat(getDefaultValue(order, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n    assertThat(getDefaultValue(order)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getDefaultValueFromNonPublicAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation annotation = declaredAnnotations[0];\r\n    assertThat(annotation).isNotNull();\r\n    assertThat(annotation.annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(getDefaultValue(annotation, VALUE)).isEqualTo(-1);\r\n    assertThat(getDefaultValue(annotation)).isEqualTo(-1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getDefaultValueFromAnnotationType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueFromAnnotationType() {\r\n    assertThat(getDefaultValue(Order.class, VALUE)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n    assertThat(getDefaultValue(Order.class)).isEqualTo(Ordered.LOWEST_PRECEDENCE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#findRepeatableAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findRepeatableAnnotation() {\r\n    Repeatable repeatable = findAnnotation(MyRepeatable.class, Repeatable.class);\r\n    assertThat(repeatable).isNotNull();\r\n    assertThat(repeatable.value()).isEqualTo(MyRepeatableContainer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getRepeatableAnnotationsDeclaredOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsDeclaredOnMethod() throws Exception {\r\n    Method method = InterfaceWithRepeated.class.getMethod(\"foo\");\r\n    Set<MyRepeatable> annotations = getRepeatableAnnotations(method, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(annotations).isNotNull();\r\n    List<String> values = annotations.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(asList(\"A\", \"B\", \"C\", \"meta1\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsDeclaredOnClassWithAttributeAliases() {\r\n    final List<String> expectedLocations = asList(\"A\", \"B\");\r\n    Set<ContextConfig> annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, null);\r\n    assertThat(annotations).isNotNull();\r\n    assertThat(annotations).as(\"size if container type is omitted: \").isEmpty();\r\n    annotations = getRepeatableAnnotations(ConfigHierarchyTestCase.class, ContextConfig.class, Hierarchy.class);\r\n    assertThat(annotations).isNotNull();\r\n    List<String> locations = annotations.stream().map(ContextConfig::location).collect(toList());\r\n    assertThat(locations).isEqualTo(expectedLocations);\r\n    List<String> values = annotations.stream().map(ContextConfig::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedLocations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getRepeatableAnnotationsDeclaredOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsDeclaredOnClass() {\r\n    final List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\r\n    final List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\r\n    // Java 8\r\n    MyRepeatable[] array = MyRepeatableClass.class.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getRepeatableAnnotationsDeclaredOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsDeclaredOnSuperclass() {\r\n    final Class<?> clazz = SubMyRepeatableClass.class;\r\n    final List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\r\n    final List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getRepeatableAnnotationsDeclaredOnClassAndSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsDeclaredOnClassAndSuperclass() {\r\n    final Class<?> clazz = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    final List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\r\n    final List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getRepeatableAnnotationsDeclaredOnMultipleSuperclasses()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsDeclaredOnMultipleSuperclasses() {\r\n    final Class<?> clazz = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    final List<String> expectedValuesJava = asList(\"X\", \"Y\", \"Z\");\r\n    final List<String> expectedValuesSpring = asList(\"X\", \"Y\", \"Z\", \"meta2\");\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getDeclaredRepeatableAnnotationsDeclaredOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDeclaredRepeatableAnnotationsDeclaredOnClass() {\r\n    final List<String> expectedValuesJava = asList(\"A\", \"B\", \"C\");\r\n    final List<String> expectedValuesSpring = asList(\"A\", \"B\", \"C\", \"meta1\");\r\n    // Java 8\r\n    MyRepeatable[] array = MyRepeatableClass.class.getDeclaredAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    List<String> values = stream(array).map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesJava);\r\n    // Spring\r\n    Set<MyRepeatable> set = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getDeclaredRepeatableAnnotations(MyRepeatableClass.class, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    values = set.stream().map(MyRepeatable::value).collect(toList());\r\n    assertThat(values).isEqualTo(expectedValuesSpring);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#getDeclaredRepeatableAnnotationsDeclaredOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDeclaredRepeatableAnnotationsDeclaredOnSuperclass() {\r\n    final Class<?> clazz = SubMyRepeatableClass.class;\r\n    // Java 8\r\n    MyRepeatable[] array = clazz.getDeclaredAnnotationsByType(MyRepeatable.class);\r\n    assertThat(array).isNotNull();\r\n    assertThat(array).isEmpty();\r\n    // Spring\r\n    Set<MyRepeatable> set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class, MyRepeatableContainer.class);\r\n    assertThat(set).isNotNull();\r\n    assertThat(set).isEmpty();\r\n    // When container type is omitted and therefore inferred from @Repeatable\r\n    set = getDeclaredRepeatableAnnotations(clazz, MyRepeatable.class);\r\n    assertThat(set).isNotNull();\r\n    assertThat(set).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationWithImplicitAliasesWithMissingDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithMissingDefaultValuesContextConfigClass.class;\r\n    Class<ImplicitAliasesWithMissingDefaultValuesContextConfig> annotationType = ImplicitAliasesWithMissingDefaultValuesContextConfig.class;\r\n    ImplicitAliasesWithMissingDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\r\n    assertThat(config).isNotNull();\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> synthesizeAnnotation(config, clazz)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"default values\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationWithImplicitAliasesWithDifferentDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDifferentDefaultValuesContextConfigClass.class;\r\n    Class<ImplicitAliasesWithDifferentDefaultValuesContextConfig> annotationType = ImplicitAliasesWithDifferentDefaultValuesContextConfig.class;\r\n    ImplicitAliasesWithDifferentDefaultValuesContextConfig config = clazz.getAnnotation(annotationType);\r\n    assertThat(config).isNotNull();\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> synthesizeAnnotation(config, clazz)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"same default value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationWithImplicitAliasesWithDuplicateValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationWithImplicitAliasesWithDuplicateValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDuplicateValuesContextConfigClass.class;\r\n    Class<ImplicitAliasesWithDuplicateValuesContextConfig> annotationType = ImplicitAliasesWithDuplicateValuesContextConfig.class;\r\n    ImplicitAliasesWithDuplicateValuesContextConfig config = clazz.getAnnotation(annotationType);\r\n    assertThat(config).isNotNull();\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> synthesizeAnnotation(config, clazz).location1()).withMessageStartingWith(\"Different @AliasFor mirror values\").withMessageContaining(annotationType.getName()).withMessageContaining(\"declared on class\").withMessageContaining(clazz.getName()).withMessageContaining(\"attribute 'location1' and its alias 'location2'\").withMessageContaining(\"with values of [1] and [2]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromMapWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Map<String, Object> map = Collections.singletonMap(VALUE, \"webController\");\r\n    Component synthesizedComponent = synthesizeAnnotation(map, Component.class, WebController.class);\r\n    assertThat(synthesizedComponent).isNotNull();\r\n    assertThat(synthesizedComponent).isNotSameAs(component);\r\n    assertThat(component.value()).as(\"value from component: \").isEqualTo(\"webController\");\r\n    assertThat(synthesizedComponent.value()).as(\"value from synthesized component: \").isEqualTo(\"webController\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithNestedMap()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeAnnotationFromMapWithNestedMap() {\r\n    ComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\r\n    assertThat(componentScan).isNotNull();\r\n    assertThat(componentScan.value().pattern()).as(\"value from ComponentScan: \").isEqualTo(\"*Foo\");\r\n    AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanSingleFilterClass.class, componentScan, false, true);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(ComponentScanSingleFilter.class);\r\n    Map<String, Object> filterMap = (Map<String, Object>) attributes.get(\"value\");\r\n    assertThat(filterMap).isNotNull();\r\n    assertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\r\n    // Modify nested map\r\n    filterMap.put(\"pattern\", \"newFoo\");\r\n    filterMap.put(\"enigma\", 42);\r\n    ComponentScanSingleFilter synthesizedComponentScan = synthesizeAnnotation(attributes, ComponentScanSingleFilter.class, ComponentScanSingleFilterClass.class);\r\n    assertThat(synthesizedComponentScan).isNotNull();\r\n    assertThat(synthesizedComponentScan).isNotSameAs(componentScan);\r\n    assertThat(synthesizedComponentScan.value().pattern()).as(\"value from synthesized ComponentScan: \").isEqualTo(\"newFoo\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithNestedArrayOfMaps()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeAnnotationFromMapWithNestedArrayOfMaps() {\r\n    ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\r\n    assertThat(componentScan).isNotNull();\r\n    AnnotationAttributes attributes = getAnnotationAttributes(ComponentScanClass.class, componentScan, false, true);\r\n    assertThat(attributes).isNotNull();\r\n    assertThat(attributes.annotationType()).isEqualTo(ComponentScan.class);\r\n    Map<String, Object>[] filters = (Map[]) attributes.get(\"excludeFilters\");\r\n    assertThat(filters).isNotNull();\r\n    List<String> patterns = stream(filters).map(m -> (String) m.get(\"pattern\")).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"*Foo\", \"*Bar\"));\r\n    // Modify nested maps\r\n    filters[0].put(\"pattern\", \"newFoo\");\r\n    filters[0].put(\"enigma\", 42);\r\n    filters[1].put(\"pattern\", \"newBar\");\r\n    filters[1].put(\"enigma\", 42);\r\n    ComponentScan synthesizedComponentScan = synthesizeAnnotation(attributes, ComponentScan.class, ComponentScanClass.class);\r\n    assertThat(synthesizedComponentScan).isNotNull();\r\n    assertThat(synthesizedComponentScan).isNotSameAs(componentScan);\r\n    patterns = stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"newFoo\", \"newBar\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromDefaultsWithoutAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromDefaultsWithoutAttributeAliases() {\r\n    AnnotationWithDefaults annotationWithDefaults = synthesizeAnnotation(AnnotationWithDefaults.class);\r\n    assertThat(annotationWithDefaults).isNotNull();\r\n    assertThat(annotationWithDefaults.text()).as(\"text: \").isEqualTo(\"enigma\");\r\n    assertThat(annotationWithDefaults.predicate()).as(\"predicate: \").isTrue();\r\n    assertThat(annotationWithDefaults.characters()).as(\"characters: \").isEqualTo(new char[] { 'a', 'b', 'c' });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromDefaultsWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromDefaultsWithAttributeAliases() {\r\n    ContextConfig contextConfig = synthesizeAnnotation(ContextConfig.class);\r\n    assertThat(contextConfig).isNotNull();\r\n    assertThat(contextConfig.value()).as(\"value: \").isEmpty();\r\n    assertThat(contextConfig.location()).as(\"location: \").isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromMapWithMinimalAttributesWithAttributeAliases() {\r\n    Map<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\r\n    ContextConfig contextConfig = synthesizeAnnotation(map, ContextConfig.class, null);\r\n    assertThat(contextConfig).isNotNull();\r\n    assertThat(contextConfig.value()).as(\"value: \").isEqualTo(\"test.xml\");\r\n    assertThat(contextConfig.location()).as(\"location: \").isEqualTo(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\r\n    Map<String, Object> map = Collections.singletonMap(\"value\", \"/foo\");\r\n    Get get = synthesizeAnnotation(map, Get.class, null);\r\n    assertThat(get).isNotNull();\r\n    assertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\r\n    assertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\r\n    map = Collections.singletonMap(\"path\", \"/foo\");\r\n    get = synthesizeAnnotation(map, Get.class, null);\r\n    assertThat(get).isNotNull();\r\n    assertThat(get.value()).as(\"value: \").isEqualTo(\"/foo\");\r\n    assertThat(get.path()).as(\"path: \").isEqualTo(\"/foo\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithImplicitAttributeAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromMapWithImplicitAttributeAliases() {\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"value\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"location1\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"location2\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"location3\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"xmlFile\");\r\n    assertAnnotationSynthesisFromMapWithImplicitAliases(\"groovyScript\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#assertAnnotationSynthesisFromMapWithImplicitAliases(String)",
    "entityType": "method",
    "code": "private void assertAnnotationSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\r\n    Map<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\r\n    ImplicitAliasesContextConfig config = synthesizeAnnotation(map, ImplicitAliasesContextConfig.class, null);\r\n    assertThat(config).isNotNull();\r\n    assertThat(config.value()).as(\"value: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.location1()).as(\"location1: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.location2()).as(\"location2: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.location3()).as(\"location3: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.xmlFile()).as(\"xmlFile: \").isEqualTo(attributeNameAndValue);\r\n    assertThat(config.groovyScript()).as(\"groovyScript: \").isEqualTo(attributeNameAndValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtilsTests#synthesizeAnnotationFromMapWithMissingAttributeValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeAnnotationFromMapWithMissingAttributeValue() {\r\n    assertMissingTextAttribute(Collections.emptyMap());\r\n}",
    "comment": ""
  }
]