[
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processClassHierarchy(C,Class<?>,AnnotationsProcessor<C,R>,boolean,Predicate<Class<?>>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processClassHierarchy(C context, Class<?> source, AnnotationsProcessor<C, R> processor, boolean includeInterfaces, Predicate<Class<?>> searchEnclosingClass) {\r\n    return processClassHierarchy(context, new int[] { 0 }, source, processor, includeInterfaces, searchEnclosingClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processClassHierarchy(C,int[],Class<?>,AnnotationsProcessor<C,R>,boolean,Predicate<Class<?>>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processClassHierarchy(C context, int[] aggregateIndex, Class<?> source, AnnotationsProcessor<C, R> processor, boolean includeInterfaces, Predicate<Class<?>> searchEnclosingClass) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, aggregateIndex[0]);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        if (hasPlainJavaAnnotationsOnly(source)) {\r\n            return null;\r\n        }\r\n        @Nullable\r\n        Annotation[] annotations = getDeclaredAnnotations(source, false);\r\n        result = processor.doWithAnnotations(context, aggregateIndex[0], source, annotations);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        aggregateIndex[0]++;\r\n        if (includeInterfaces) {\r\n            for (Class<?> interfaceType : source.getInterfaces()) {\r\n                R interfacesResult = processClassHierarchy(context, aggregateIndex, interfaceType, processor, true, searchEnclosingClass);\r\n                if (interfacesResult != null) {\r\n                    return interfacesResult;\r\n                }\r\n            }\r\n        }\r\n        Class<?> superclass = source.getSuperclass();\r\n        if (superclass != Object.class && superclass != null) {\r\n            R superclassResult = processClassHierarchy(context, aggregateIndex, superclass, processor, includeInterfaces, searchEnclosingClass);\r\n            if (superclassResult != null) {\r\n                return superclassResult;\r\n            }\r\n        }\r\n        if (searchEnclosingClass.test(source)) {\r\n            // Since merely attempting to load the enclosing class may result in\r\n            // automatic loading of sibling nested classes that in turn results\r\n            // in an exception such as NoClassDefFoundError, we wrap the following\r\n            // in its own dedicated try-catch block in order not to preemptively\r\n            // halt the annotation scanning process.\r\n            try {\r\n                Class<?> enclosingClass = source.getEnclosingClass();\r\n                if (enclosingClass != null) {\r\n                    R enclosingResult = processClassHierarchy(context, aggregateIndex, enclosingClass, processor, includeInterfaces, searchEnclosingClass);\r\n                    if (enclosingResult != null) {\r\n                        return enclosingResult;\r\n                    }\r\n                }\r\n            } catch (Throwable ex) {\r\n                AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processMethod(C,Method,SearchStrategy,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processMethod(C context, Method source, SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor) {\r\n    return switch(searchStrategy) {\r\n        case DIRECT, INHERITED_ANNOTATIONS ->\r\n            processMethodInheritedAnnotations(context, source, processor);\r\n        case SUPERCLASS ->\r\n            processMethodHierarchy(context, new int[] { 0 }, source.getDeclaringClass(), processor, source, false);\r\n        case TYPE_HIERARCHY ->\r\n            processMethodHierarchy(context, new int[] { 0 }, source.getDeclaringClass(), processor, source, true);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processMethodInheritedAnnotations(C,Method,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processMethodInheritedAnnotations(C context, Method source, AnnotationsProcessor<C, R> processor) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, 0);\r\n        return (result != null ? result : processMethodAnnotations(context, 0, source, processor));\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processMethodHierarchy(C,int[],Class<?>,AnnotationsProcessor<C,R>,Method,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processMethodHierarchy(C context, int[] aggregateIndex, Class<?> sourceClass, AnnotationsProcessor<C, R> processor, Method rootMethod, boolean includeInterfaces) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, aggregateIndex[0]);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        if (hasPlainJavaAnnotationsOnly(sourceClass)) {\r\n            return null;\r\n        }\r\n        boolean calledProcessor = false;\r\n        if (sourceClass == rootMethod.getDeclaringClass()) {\r\n            result = processMethodAnnotations(context, aggregateIndex[0], rootMethod, processor);\r\n            calledProcessor = true;\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } else {\r\n            for (Method candidateMethod : getBaseTypeMethods(context, sourceClass)) {\r\n                if (candidateMethod != null && isOverride(rootMethod, candidateMethod)) {\r\n                    result = processMethodAnnotations(context, aggregateIndex[0], candidateMethod, processor);\r\n                    calledProcessor = true;\r\n                    if (result != null) {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (Modifier.isPrivate(rootMethod.getModifiers())) {\r\n            return null;\r\n        }\r\n        if (calledProcessor) {\r\n            aggregateIndex[0]++;\r\n        }\r\n        if (includeInterfaces) {\r\n            for (Class<?> interfaceType : sourceClass.getInterfaces()) {\r\n                R interfacesResult = processMethodHierarchy(context, aggregateIndex, interfaceType, processor, rootMethod, true);\r\n                if (interfacesResult != null) {\r\n                    return interfacesResult;\r\n                }\r\n            }\r\n        }\r\n        Class<?> superclass = sourceClass.getSuperclass();\r\n        if (superclass != Object.class && superclass != null) {\r\n            R superclassResult = processMethodHierarchy(context, aggregateIndex, superclass, processor, rootMethod, includeInterfaces);\r\n            if (superclassResult != null) {\r\n                return superclassResult;\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(rootMethod, ex);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#getBaseTypeMethods(C,Class<?>)",
    "entityType": "method",
    "code": "// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\nprivate static <C> Method[] getBaseTypeMethods(C context, Class<?> baseType) {\r\n    if (baseType == Object.class || hasPlainJavaAnnotationsOnly(baseType)) {\r\n        return NO_METHODS;\r\n    }\r\n    @Nullable\r\n    Method[] methods = baseTypeMethodsCache.get(baseType);\r\n    if (methods == null) {\r\n        methods = ReflectionUtils.getDeclaredMethods(baseType);\r\n        int cleared = 0;\r\n        for (int i = 0; i < methods.length; i++) {\r\n            //noinspection DataFlowIssue\r\n            if (Modifier.isPrivate(methods[i].getModifiers()) || hasPlainJavaAnnotationsOnly(methods[i]) || getDeclaredAnnotations(methods[i], false).length == 0) {\r\n                methods[i] = null;\r\n                cleared++;\r\n            }\r\n        }\r\n        if (cleared == methods.length) {\r\n            methods = NO_METHODS;\r\n        }\r\n        baseTypeMethodsCache.put(baseType, methods);\r\n    }\r\n    return methods;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#isOverride(Method,Method)",
    "entityType": "method",
    "code": "private static boolean isOverride(Method rootMethod, Method candidateMethod) {\r\n    return (!Modifier.isPrivate(candidateMethod.getModifiers()) && candidateMethod.getName().equals(rootMethod.getName()) && hasSameParameterTypes(rootMethod, candidateMethod));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#hasSameParameterTypes(Method,Method)",
    "entityType": "method",
    "code": "private static boolean hasSameParameterTypes(Method rootMethod, Method candidateMethod) {\r\n    if (candidateMethod.getParameterCount() != rootMethod.getParameterCount()) {\r\n        return false;\r\n    }\r\n    Class<?>[] rootParameterTypes = rootMethod.getParameterTypes();\r\n    Class<?>[] candidateParameterTypes = candidateMethod.getParameterTypes();\r\n    if (Arrays.equals(candidateParameterTypes, rootParameterTypes)) {\r\n        return true;\r\n    }\r\n    return hasSameGenericTypeParameters(rootMethod, candidateMethod, rootParameterTypes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#hasSameGenericTypeParameters(Method,Method,Class<?>[])",
    "entityType": "method",
    "code": "private static boolean hasSameGenericTypeParameters(Method rootMethod, Method candidateMethod, Class<?>[] rootParameterTypes) {\r\n    Class<?> sourceDeclaringClass = rootMethod.getDeclaringClass();\r\n    Class<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\r\n    if (!candidateDeclaringClass.isAssignableFrom(sourceDeclaringClass)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < rootParameterTypes.length; i++) {\r\n        Class<?> resolvedParameterType = ResolvableType.forMethodParameter(candidateMethod, i, sourceDeclaringClass).resolve();\r\n        if (rootParameterTypes[i] != resolvedParameterType) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processMethodAnnotations(C,int,Method,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processMethodAnnotations(C context, int aggregateIndex, Method source, AnnotationsProcessor<C, R> processor) {\r\n    @Nullable\r\n    Annotation[] annotations = getDeclaredAnnotations(source, false);\r\n    R result = processor.doWithAnnotations(context, aggregateIndex, source, annotations);\r\n    if (result != null) {\r\n        return result;\r\n    }\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(source);\r\n    if (bridgedMethod != source) {\r\n        @Nullable\r\n        Annotation[] bridgedAnnotations = getDeclaredAnnotations(bridgedMethod, true);\r\n        for (int i = 0; i < bridgedAnnotations.length; i++) {\r\n            if (ObjectUtils.containsElement(annotations, bridgedAnnotations[i])) {\r\n                bridgedAnnotations[i] = null;\r\n            }\r\n        }\r\n        return processor.doWithAnnotations(context, aggregateIndex, source, bridgedAnnotations);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processElement(C,AnnotatedElement,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processElement(C context, AnnotatedElement source, AnnotationsProcessor<C, R> processor) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, 0);\r\n        return (result != null ? result : processor.doWithAnnotations(context, 0, source, getDeclaredAnnotations(source, false)));\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#getDeclaredAnnotation(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nstatic <A extends Annotation> A getDeclaredAnnotation(AnnotatedElement source, Class<A> annotationType) {\r\n    @Nullable\r\n    Annotation[] annotations = getDeclaredAnnotations(source, false);\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null && annotationType == annotation.annotationType()) {\r\n            return (A) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#getDeclaredAnnotations(AnnotatedElement,boolean)",
    "entityType": "method",
    "code": "// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\nstatic Annotation[] getDeclaredAnnotations(AnnotatedElement source, boolean defensive) {\r\n    boolean cached = false;\r\n    @Nullable\r\n    Annotation[] annotations = declaredAnnotationCache.get(source);\r\n    if (annotations != null) {\r\n        cached = true;\r\n    } else {\r\n        annotations = source.getDeclaredAnnotations();\r\n        if (annotations.length != 0) {\r\n            boolean allIgnored = true;\r\n            for (int i = 0; i < annotations.length; i++) {\r\n                Annotation annotation = annotations[i];\r\n                //noinspection DataFlowIssue\r\n                if (isIgnorable(annotation.annotationType()) || !AttributeMethods.forAnnotationType(annotation.annotationType()).canLoad(annotation)) {\r\n                    annotations[i] = null;\r\n                } else {\r\n                    allIgnored = false;\r\n                }\r\n            }\r\n            annotations = (allIgnored ? NO_ANNOTATIONS : annotations);\r\n            if (source instanceof Class || source instanceof Member) {\r\n                //noinspection NullableProblems\r\n                declaredAnnotationCache.put(source, annotations);\r\n                cached = true;\r\n            }\r\n        }\r\n    }\r\n    if (!defensive || annotations.length == 0 || !cached) {\r\n        return annotations;\r\n    }\r\n    return annotations.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#isIgnorable(Class<?>)",
    "entityType": "method",
    "code": "private static boolean isIgnorable(Class<?> annotationType) {\r\n    return AnnotationFilter.PLAIN.matches(annotationType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#isKnownEmpty(AnnotatedElement,SearchStrategy,Predicate<Class<?>>)",
    "entityType": "method",
    "code": "static boolean isKnownEmpty(AnnotatedElement source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass) {\r\n    if (hasPlainJavaAnnotationsOnly(source)) {\r\n        return true;\r\n    }\r\n    if (searchStrategy == SearchStrategy.DIRECT || isWithoutHierarchy(source, searchEnclosingClass)) {\r\n        if (source instanceof Method method && method.isBridge()) {\r\n            return false;\r\n        }\r\n        return getDeclaredAnnotations(source, false).length == 0;\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#hasPlainJavaAnnotationsOnly(Object)",
    "entityType": "method",
    "code": "static boolean hasPlainJavaAnnotationsOnly(@Nullable Object annotatedElement) {\r\n    if (annotatedElement instanceof Class<?> clazz) {\r\n        return hasPlainJavaAnnotationsOnly(clazz);\r\n    } else if (annotatedElement instanceof Member member) {\r\n        return hasPlainJavaAnnotationsOnly(member.getDeclaringClass());\r\n    } else {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#hasPlainJavaAnnotationsOnly(Class<?>)",
    "entityType": "method",
    "code": "static boolean hasPlainJavaAnnotationsOnly(Class<?> type) {\r\n    return (type.getName().startsWith(\"java.\") || type == Ordered.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#isWithoutHierarchy(AnnotatedElement,Predicate<Class<?>>)",
    "entityType": "method",
    "code": "private static boolean isWithoutHierarchy(AnnotatedElement source, Predicate<Class<?>> searchEnclosingClass) {\r\n    if (source == Object.class) {\r\n        return true;\r\n    }\r\n    if (source instanceof Class<?> sourceClass) {\r\n        boolean noSuperTypes = (sourceClass.getSuperclass() == Object.class && sourceClass.getInterfaces().length == 0);\r\n        return (searchEnclosingClass.test(sourceClass) ? noSuperTypes && sourceClass.getEnclosingClass() == null : noSuperTypes);\r\n    }\r\n    if (source instanceof Method sourceMethod) {\r\n        return (Modifier.isPrivate(sourceMethod.getModifiers()) || isWithoutHierarchy(sourceMethod.getDeclaringClass(), searchEnclosingClass));\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#clearCache()",
    "entityType": "method",
    "code": "static void clearCache() {\r\n    declaredAnnotationCache.clear();\r\n    baseTypeMethodsCache.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping",
    "entityType": "class",
    "code": "private static final Log logger = LogFactory.getLog(AnnotationTypeMapping.class);\nprivate static final Predicate<? super Annotation> isBeanValidationConstraint = annotation -> annotation.annotationType().getName().equals(\"jakarta.validation.Constraint\");\n/**\r\n * Set used to track which convention-based annotation attribute overrides\r\n * have already been checked. Each key is the combination of the fully\r\n * qualified class name of a composed annotation and a meta-annotation\r\n * that it is either present or meta-present on the composed annotation,\r\n * separated by a dash.\r\n * @since 6.0\r\n * @see #addConventionMappings()\r\n */\r\nprivate static final Set<String> conventionBasedOverrideCheckCache = ConcurrentHashMap.newKeySet();\nprivate static final MirrorSet[] EMPTY_MIRROR_SETS = new MirrorSet[0];\nprivate static final int[] EMPTY_INT_ARRAY = new int[0];\n@Nullable\r\nprivate final AnnotationTypeMapping source;\nprivate final AnnotationTypeMapping root;\nprivate final int distance;\nprivate final Class<? extends Annotation> annotationType;\nprivate final List<Class<? extends Annotation>> metaTypes;\n@Nullable\r\nprivate final Annotation annotation;\nprivate final AttributeMethods attributes;\nprivate final MirrorSets mirrorSets;\nprivate final int[] aliasMappings;\nprivate final int[] conventionMappings;\nprivate final int[] annotationValueMappings;\nprivate final AnnotationTypeMapping[] annotationValueSource;\nprivate final Map<Method, List<Method>> aliasedBy;\nprivate final boolean synthesizable;\nprivate final Set<Method> claimedAliases = new HashSet<>();\nAnnotationTypeMapping(@Nullable AnnotationTypeMapping source, Class<? extends Annotation> annotationType, @Nullable Annotation annotation, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    this.source = source;\r\n    this.root = (source != null ? source.getRoot() : this);\r\n    this.distance = (source == null ? 0 : source.getDistance() + 1);\r\n    this.annotationType = annotationType;\r\n    this.metaTypes = merge(source != null ? source.getMetaTypes() : null, annotationType);\r\n    this.annotation = annotation;\r\n    this.attributes = AttributeMethods.forAnnotationType(annotationType);\r\n    this.mirrorSets = new MirrorSets();\r\n    this.aliasMappings = filledIntArray(this.attributes.size());\r\n    this.conventionMappings = filledIntArray(this.attributes.size());\r\n    this.annotationValueMappings = filledIntArray(this.attributes.size());\r\n    this.annotationValueSource = new AnnotationTypeMapping[this.attributes.size()];\r\n    this.aliasedBy = resolveAliasedForTargets();\r\n    processAliases();\r\n    addConventionMappings();\r\n    addConventionAnnotationValues();\r\n    this.synthesizable = computeSynthesizableFlag(visitedAnnotationTypes);\r\n}\nprivate static <T> List<T> merge(@Nullable List<T> existing, T element) {\r\n    if (existing == null) {\r\n        return Collections.singletonList(element);\r\n    }\r\n    List<T> merged = new ArrayList<>(existing.size() + 1);\r\n    merged.addAll(existing);\r\n    merged.add(element);\r\n    return Collections.unmodifiableList(merged);\r\n}\nprivate Map<Method, List<Method>> resolveAliasedForTargets() {\r\n    Map<Method, List<Method>> aliasedBy = new HashMap<>();\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\r\n        if (aliasFor != null) {\r\n            Method target = resolveAliasTarget(attribute, aliasFor);\r\n            aliasedBy.computeIfAbsent(target, key -> new ArrayList<>()).add(attribute);\r\n        }\r\n    }\r\n    return Collections.unmodifiableMap(aliasedBy);\r\n}\nprivate Method resolveAliasTarget(Method attribute, AliasFor aliasFor) {\r\n    return resolveAliasTarget(attribute, aliasFor, true);\r\n}\nprivate Method resolveAliasTarget(Method attribute, AliasFor aliasFor, boolean checkAliasPair) {\r\n    if (StringUtils.hasText(aliasFor.value()) && StringUtils.hasText(aliasFor.attribute())) {\r\n        throw new AnnotationConfigurationException(String.format(\"In @AliasFor declared on %s, attribute 'attribute' and its alias 'value' \" + \"are present with values of '%s' and '%s', but only one is permitted.\", AttributeMethods.describe(attribute), aliasFor.attribute(), aliasFor.value()));\r\n    }\r\n    Class<? extends Annotation> targetAnnotation = aliasFor.annotation();\r\n    if (targetAnnotation == Annotation.class) {\r\n        targetAnnotation = this.annotationType;\r\n    }\r\n    String targetAttributeName = aliasFor.attribute();\r\n    if (!StringUtils.hasLength(targetAttributeName)) {\r\n        targetAttributeName = aliasFor.value();\r\n    }\r\n    if (!StringUtils.hasLength(targetAttributeName)) {\r\n        targetAttributeName = attribute.getName();\r\n    }\r\n    Method target = AttributeMethods.forAnnotationType(targetAnnotation).get(targetAttributeName);\r\n    if (target == null) {\r\n        if (targetAnnotation == this.annotationType) {\r\n            throw new AnnotationConfigurationException(String.format(\"@AliasFor declaration on %s declares an alias for '%s' which is not present.\", AttributeMethods.describe(attribute), targetAttributeName));\r\n        }\r\n        throw new AnnotationConfigurationException(String.format(\"%s is declared as an @AliasFor nonexistent %s.\", StringUtils.capitalize(AttributeMethods.describe(attribute)), AttributeMethods.describe(targetAnnotation, targetAttributeName)));\r\n    }\r\n    if (target.equals(attribute)) {\r\n        throw new AnnotationConfigurationException(String.format(\"@AliasFor declaration on %s points to itself. \" + \"Specify 'annotation' to point to a same-named attribute on a meta-annotation.\", AttributeMethods.describe(attribute)));\r\n    }\r\n    if (!isCompatibleReturnType(attribute.getReturnType(), target.getReturnType())) {\r\n        throw new AnnotationConfigurationException(String.format(\"Misconfigured aliases: %s and %s must declare the same return type.\", AttributeMethods.describe(attribute), AttributeMethods.describe(target)));\r\n    }\r\n    if (isAliasPair(target) && checkAliasPair) {\r\n        AliasFor targetAliasFor = target.getAnnotation(AliasFor.class);\r\n        if (targetAliasFor != null) {\r\n            Method mirror = resolveAliasTarget(target, targetAliasFor, false);\r\n            if (!mirror.equals(attribute)) {\r\n                throw new AnnotationConfigurationException(String.format(\"%s must be declared as an @AliasFor %s, not %s.\", StringUtils.capitalize(AttributeMethods.describe(target)), AttributeMethods.describe(attribute), AttributeMethods.describe(mirror)));\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\nprivate boolean isAliasPair(Method target) {\r\n    return (this.annotationType == target.getDeclaringClass());\r\n}\nprivate boolean isCompatibleReturnType(Class<?> attributeType, Class<?> targetType) {\r\n    return (attributeType == targetType || attributeType == targetType.componentType());\r\n}\nprivate void processAliases() {\r\n    List<Method> aliases = new ArrayList<>();\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        aliases.clear();\r\n        aliases.add(this.attributes.get(i));\r\n        collectAliases(aliases);\r\n        if (aliases.size() > 1) {\r\n            processAliases(i, aliases);\r\n        }\r\n    }\r\n}\nprivate void collectAliases(List<Method> aliases) {\r\n    AnnotationTypeMapping mapping = this;\r\n    while (mapping != null) {\r\n        int size = aliases.size();\r\n        for (int j = 0; j < size; j++) {\r\n            List<Method> additional = mapping.aliasedBy.get(aliases.get(j));\r\n            if (additional != null) {\r\n                aliases.addAll(additional);\r\n            }\r\n        }\r\n        mapping = mapping.source;\r\n    }\r\n}\nprivate void processAliases(int attributeIndex, List<Method> aliases) {\r\n    int rootAttributeIndex = getFirstRootAttributeIndex(aliases);\r\n    AnnotationTypeMapping mapping = this;\r\n    while (mapping != null) {\r\n        if (rootAttributeIndex != -1 && mapping != this.root) {\r\n            for (int i = 0; i < mapping.attributes.size(); i++) {\r\n                if (aliases.contains(mapping.attributes.get(i))) {\r\n                    mapping.aliasMappings[i] = rootAttributeIndex;\r\n                }\r\n            }\r\n        }\r\n        mapping.mirrorSets.updateFrom(aliases);\r\n        mapping.claimedAliases.addAll(aliases);\r\n        if (mapping.annotation != null) {\r\n            int[] resolvedMirrors = mapping.mirrorSets.resolve(null, mapping.annotation, AnnotationUtils::invokeAnnotationMethod);\r\n            for (int i = 0; i < mapping.attributes.size(); i++) {\r\n                if (aliases.contains(mapping.attributes.get(i))) {\r\n                    this.annotationValueMappings[attributeIndex] = resolvedMirrors[i];\r\n                    this.annotationValueSource[attributeIndex] = mapping;\r\n                }\r\n            }\r\n        }\r\n        mapping = mapping.source;\r\n    }\r\n}\nprivate int getFirstRootAttributeIndex(Collection<Method> aliases) {\r\n    AttributeMethods rootAttributes = this.root.getAttributes();\r\n    for (int i = 0; i < rootAttributes.size(); i++) {\r\n        if (aliases.contains(rootAttributes.get(i))) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\nprivate void addConventionMappings() {\r\n    if (this.distance == 0) {\r\n        return;\r\n    }\r\n    AttributeMethods rootAttributes = this.root.getAttributes();\r\n    int[] mappings = this.conventionMappings;\r\n    Set<String> conventionMappedAttributes = new HashSet<>();\r\n    for (int i = 0; i < mappings.length; i++) {\r\n        String name = this.attributes.get(i).getName();\r\n        int mapped = rootAttributes.indexOf(name);\r\n        if (!MergedAnnotation.VALUE.equals(name) && mapped != -1 && !isExplicitAttributeOverride(name)) {\r\n            conventionMappedAttributes.add(name);\r\n            mappings[i] = mapped;\r\n            MirrorSet mirrors = getMirrorSets().getAssigned(i);\r\n            if (mirrors != null) {\r\n                for (int j = 0; j < mirrors.size(); j++) {\r\n                    mappings[mirrors.getAttributeIndex(j)] = mapped;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    String rootAnnotationTypeName = this.root.annotationType.getName();\r\n    String cacheKey = rootAnnotationTypeName + '-' + this.annotationType.getName();\r\n    // We want to avoid duplicate log warnings as much as possible, without full synchronization,\r\n    // and we intentionally invoke add() before checking if any convention-based overrides were\r\n    // actually encountered in order to ensure that we add a \"tracked\" entry for the current cache\r\n    // key in any case.\r\n    // In addition, we do NOT want to log warnings for custom Java Bean Validation constraint\r\n    // annotations that are meta-annotated with other constraint annotations -- for example,\r\n    // @org.hibernate.validator.constraints.URL which overrides attributes in\r\n    // @jakarta.validation.constraints.Pattern.\r\n    if (conventionBasedOverrideCheckCache.add(cacheKey) && !conventionMappedAttributes.isEmpty() && Arrays.stream(this.annotationType.getAnnotations()).noneMatch(isBeanValidationConstraint) && logger.isWarnEnabled()) {\r\n        logger.warn(\"\"\"\r\n            Support for convention-based annotation attribute overrides is deprecated \\\r\n            and will be removed in Spring Framework 7.0. Please annotate the following \\\r\n            attributes in @%s with appropriate @AliasFor declarations: %s\"\"\".formatted(rootAnnotationTypeName, conventionMappedAttributes));\r\n    }\r\n}\n/**\r\n * Determine if the given annotation attribute in the {@linkplain #getRoot()\r\n * root annotation} is an explicit annotation attribute override for an\r\n * attribute in a meta-annotation, explicit in the sense that the override\r\n * is declared via {@link AliasFor @AliasFor}.\r\n * <p>If the named attribute does not exist in the root annotation, this\r\n * method returns {@code false}.\r\n * @param name the name of the annotation attribute to check\r\n * @since 6.0\r\n */\r\nprivate boolean isExplicitAttributeOverride(String name) {\r\n    Method attribute = this.root.getAttributes().get(name);\r\n    if (attribute != null) {\r\n        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\r\n        return ((aliasFor != null) && (aliasFor.annotation() != Annotation.class) && (aliasFor.annotation() != this.root.annotationType));\r\n    }\r\n    return false;\r\n}\nprivate void addConventionAnnotationValues() {\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        boolean isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());\r\n        AnnotationTypeMapping mapping = this;\r\n        while (mapping != null && mapping.distance > 0) {\r\n            int mapped = mapping.getAttributes().indexOf(attribute.getName());\r\n            if (mapped != -1 && isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) {\r\n                this.annotationValueMappings[i] = mapped;\r\n                this.annotationValueSource[i] = mapping;\r\n            }\r\n            mapping = mapping.source;\r\n        }\r\n    }\r\n}\nprivate boolean isBetterConventionAnnotationValue(int index, boolean isValueAttribute, AnnotationTypeMapping mapping) {\r\n    if (this.annotationValueMappings[index] == -1) {\r\n        return true;\r\n    }\r\n    int existingDistance = this.annotationValueSource[index].distance;\r\n    return !isValueAttribute && existingDistance > mapping.distance;\r\n}\n@SuppressWarnings(\"unchecked\")\r\nprivate boolean computeSynthesizableFlag(Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    // Track that we have visited the current annotation type.\r\n    visitedAnnotationTypes.add(this.annotationType);\r\n    // Uses @AliasFor for local aliases?\r\n    for (int index : this.aliasMappings) {\r\n        if (index != -1) {\r\n            return true;\r\n        }\r\n    }\r\n    // Uses @AliasFor for attribute overrides in meta-annotations?\r\n    if (!this.aliasedBy.isEmpty()) {\r\n        return true;\r\n    }\r\n    // Uses convention-based attribute overrides in meta-annotations?\r\n    for (int index : this.conventionMappings) {\r\n        if (index != -1) {\r\n            return true;\r\n        }\r\n    }\r\n    // Has nested annotations or arrays of annotations that are synthesizable?\r\n    if (getAttributes().hasNestedAnnotation()) {\r\n        AttributeMethods attributeMethods = getAttributes();\r\n        for (int i = 0; i < attributeMethods.size(); i++) {\r\n            Method method = attributeMethods.get(i);\r\n            Class<?> type = method.getReturnType();\r\n            if (type.isAnnotation() || (type.isArray() && type.componentType().isAnnotation())) {\r\n                Class<? extends Annotation> annotationType = (Class<? extends Annotation>) (type.isAnnotation() ? type : type.componentType());\r\n                // Ensure we have not yet visited the current nested annotation type, in order\r\n                // to avoid infinite recursion for JVM languages other than Java that support\r\n                // recursive annotation definitions.\r\n                if (visitedAnnotationTypes.add(annotationType)) {\r\n                    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType, visitedAnnotationTypes).get(0);\r\n                    if (mapping.isSynthesizable()) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Method called after all mappings have been set. At this point no further\r\n * lookups from child mappings will occur.\r\n */\r\nvoid afterAllMappingsSet() {\r\n    validateAllAliasesClaimed();\r\n    for (int i = 0; i < this.mirrorSets.size(); i++) {\r\n        validateMirrorSet(this.mirrorSets.get(i));\r\n    }\r\n    this.claimedAliases.clear();\r\n}\nprivate void validateAllAliasesClaimed() {\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\r\n        if (aliasFor != null && !this.claimedAliases.contains(attribute)) {\r\n            Method target = resolveAliasTarget(attribute, aliasFor);\r\n            throw new AnnotationConfigurationException(String.format(\"@AliasFor declaration on %s declares an alias for %s which is not meta-present.\", AttributeMethods.describe(attribute), AttributeMethods.describe(target)));\r\n        }\r\n    }\r\n}\nprivate void validateMirrorSet(MirrorSet mirrorSet) {\r\n    Method firstAttribute = mirrorSet.get(0);\r\n    Object firstDefaultValue = firstAttribute.getDefaultValue();\r\n    for (int i = 1; i <= mirrorSet.size() - 1; i++) {\r\n        Method mirrorAttribute = mirrorSet.get(i);\r\n        Object mirrorDefaultValue = mirrorAttribute.getDefaultValue();\r\n        if (firstDefaultValue == null || mirrorDefaultValue == null) {\r\n            throw new AnnotationConfigurationException(String.format(\"Misconfigured aliases: %s and %s must declare default values.\", AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));\r\n        }\r\n        if (!ObjectUtils.nullSafeEquals(firstDefaultValue, mirrorDefaultValue)) {\r\n            throw new AnnotationConfigurationException(String.format(\"Misconfigured aliases: %s and %s must declare the same default value.\", AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));\r\n        }\r\n    }\r\n}\n/**\r\n * Get the root mapping.\r\n * @return the root mapping\r\n */\r\nAnnotationTypeMapping getRoot() {\r\n    return this.root;\r\n}\n/**\r\n * Get the source of the mapping or {@code null}.\r\n * @return the source of the mapping\r\n */\r\n@Nullable\r\nAnnotationTypeMapping getSource() {\r\n    return this.source;\r\n}\n/**\r\n * Get the distance of this mapping.\r\n * @return the distance of the mapping\r\n */\r\nint getDistance() {\r\n    return this.distance;\r\n}\n/**\r\n * Get the type of the mapped annotation.\r\n * @return the annotation type\r\n */\r\nClass<? extends Annotation> getAnnotationType() {\r\n    return this.annotationType;\r\n}\nList<Class<? extends Annotation>> getMetaTypes() {\r\n    return this.metaTypes;\r\n}\n/**\r\n * Get the source annotation for this mapping. This will be the\r\n * meta-annotation, or {@code null} if this is the root mapping.\r\n * @return the source annotation of the mapping\r\n */\r\n@Nullable\r\nAnnotation getAnnotation() {\r\n    return this.annotation;\r\n}\n/**\r\n * Get the annotation attributes for the mapping annotation type.\r\n * @return the attribute methods\r\n */\r\nAttributeMethods getAttributes() {\r\n    return this.attributes;\r\n}\n/**\r\n * Get the related index of an alias mapped attribute, or {@code -1} if\r\n * there is no mapping. The resulting value is the index of the attribute on\r\n * the root annotation that can be invoked in order to obtain the actual\r\n * value.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @return the mapped attribute index or {@code -1}\r\n */\r\nint getAliasMapping(int attributeIndex) {\r\n    return this.aliasMappings[attributeIndex];\r\n}\n/**\r\n * Get the related index of a convention mapped attribute, or {@code -1}\r\n * if there is no mapping. The resulting value is the index of the attribute\r\n * on the root annotation that can be invoked in order to obtain the actual\r\n * value.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @return the mapped attribute index or {@code -1}\r\n */\r\nint getConventionMapping(int attributeIndex) {\r\n    return this.conventionMappings[attributeIndex];\r\n}\n/**\r\n * Get a mapped attribute value from the most suitable\r\n * {@link #getAnnotation() meta-annotation}.\r\n * <p>The resulting value is obtained from the closest meta-annotation,\r\n * taking into consideration both convention and alias based mapping rules.\r\n * For root mappings, this method will always return {@code null}.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @param metaAnnotationsOnly if only meta annotations should be considered.\r\n * If this parameter is {@code false} then aliases within the annotation will\r\n * also be considered.\r\n * @return the mapped annotation value, or {@code null}\r\n */\r\n@Nullable\r\nObject getMappedAnnotationValue(int attributeIndex, boolean metaAnnotationsOnly) {\r\n    int mappedIndex = this.annotationValueMappings[attributeIndex];\r\n    if (mappedIndex == -1) {\r\n        return null;\r\n    }\r\n    AnnotationTypeMapping source = this.annotationValueSource[attributeIndex];\r\n    if (source == this && metaAnnotationsOnly) {\r\n        return null;\r\n    }\r\n    return AnnotationUtils.invokeAnnotationMethod(source.attributes.get(mappedIndex), source.annotation);\r\n}\n/**\r\n * Determine if the specified value is equivalent to the default value of the\r\n * attribute at the given index.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @param value the value to check\r\n * @param valueExtractor the value extractor used to extract values from any\r\n * nested annotations\r\n * @return {@code true} if the value is equivalent to the default value\r\n */\r\nboolean isEquivalentToDefaultValue(int attributeIndex, Object value, ValueExtractor valueExtractor) {\r\n    Method attribute = this.attributes.get(attributeIndex);\r\n    return isEquivalentToDefaultValue(attribute, value, valueExtractor);\r\n}\n/**\r\n * Get the mirror sets for this type mapping.\r\n * @return the attribute mirror sets\r\n */\r\nMirrorSets getMirrorSets() {\r\n    return this.mirrorSets;\r\n}\n/**\r\n * Determine if the mapped annotation is <em>synthesizable</em>.\r\n * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\r\n * for an explanation of what is considered synthesizable.\r\n * @return {@code true} if the mapped annotation is synthesizable\r\n * @since 5.2.6\r\n */\r\nboolean isSynthesizable() {\r\n    return this.synthesizable;\r\n}\nprivate static int[] filledIntArray(int size) {\r\n    if (size == 0) {\r\n        return EMPTY_INT_ARRAY;\r\n    }\r\n    int[] array = new int[size];\r\n    Arrays.fill(array, -1);\r\n    return array;\r\n}\nprivate static boolean isEquivalentToDefaultValue(Method attribute, Object value, ValueExtractor valueExtractor) {\r\n    return areEquivalent(attribute.getDefaultValue(), value, valueExtractor);\r\n}\nprivate static boolean areEquivalent(@Nullable Object value, @Nullable Object extractedValue, ValueExtractor valueExtractor) {\r\n    if (ObjectUtils.nullSafeEquals(value, extractedValue)) {\r\n        return true;\r\n    }\r\n    if (value instanceof Class<?> clazz && extractedValue instanceof String string) {\r\n        return areEquivalent(clazz, string);\r\n    }\r\n    if (value instanceof Class<?>[] classes && extractedValue instanceof String[] strings) {\r\n        return areEquivalent(classes, strings);\r\n    }\r\n    if (value instanceof Annotation annotation) {\r\n        return areEquivalent(annotation, extractedValue, valueExtractor);\r\n    }\r\n    return false;\r\n}\nprivate static boolean areEquivalent(Class<?>[] value, String[] extractedValue) {\r\n    if (value.length != extractedValue.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < value.length; i++) {\r\n        if (!areEquivalent(value[i], extractedValue[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\nprivate static boolean areEquivalent(Class<?> value, String extractedValue) {\r\n    return value.getName().equals(extractedValue);\r\n}\nprivate static boolean areEquivalent(Annotation annotation, @Nullable Object extractedValue, ValueExtractor valueExtractor) {\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        Method attribute = attributes.get(i);\r\n        Object value1 = AnnotationUtils.invokeAnnotationMethod(attribute, annotation);\r\n        Object value2;\r\n        if (extractedValue instanceof TypeMappedAnnotation<?> typeMappedAnnotation) {\r\n            value2 = typeMappedAnnotation.getValue(attribute.getName()).orElse(null);\r\n        } else {\r\n            value2 = valueExtractor.extract(attribute, extractedValue);\r\n        }\r\n        if (!areEquivalent(value1, value2, valueExtractor)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * A collection of {@link MirrorSet} instances that provides details of all\r\n * defined mirrors.\r\n */\r\nclass MirrorSets {\r\n\r\n    private MirrorSet[] mirrorSets;\r\n\r\n    private final MirrorSet[] assigned;\r\n\r\n    MirrorSets() {\r\n        this.assigned = attributes.size() > 0 ? new MirrorSet[attributes.size()] : EMPTY_MIRROR_SETS;\r\n        this.mirrorSets = EMPTY_MIRROR_SETS;\r\n    }\r\n\r\n    void updateFrom(Collection<Method> aliases) {\r\n        MirrorSet mirrorSet = null;\r\n        int size = 0;\r\n        int last = -1;\r\n        for (int i = 0; i < attributes.size(); i++) {\r\n            Method attribute = attributes.get(i);\r\n            if (aliases.contains(attribute)) {\r\n                size++;\r\n                if (size > 1) {\r\n                    if (mirrorSet == null) {\r\n                        mirrorSet = new MirrorSet();\r\n                        this.assigned[last] = mirrorSet;\r\n                    }\r\n                    this.assigned[i] = mirrorSet;\r\n                }\r\n                last = i;\r\n            }\r\n        }\r\n        if (mirrorSet != null) {\r\n            mirrorSet.update();\r\n            Set<MirrorSet> unique = new LinkedHashSet<>(Arrays.asList(this.assigned));\r\n            unique.remove(null);\r\n            this.mirrorSets = unique.toArray(EMPTY_MIRROR_SETS);\r\n        }\r\n    }\r\n\r\n    int size() {\r\n        return this.mirrorSets.length;\r\n    }\r\n\r\n    MirrorSet get(int index) {\r\n        return this.mirrorSets[index];\r\n    }\r\n\r\n    @Nullable\r\n    MirrorSet getAssigned(int attributeIndex) {\r\n        return this.assigned[attributeIndex];\r\n    }\r\n\r\n    int[] resolve(@Nullable Object source, @Nullable Object annotation, ValueExtractor valueExtractor) {\r\n        if (attributes.size() == 0) {\r\n            return EMPTY_INT_ARRAY;\r\n        }\r\n        int[] result = new int[attributes.size()];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = i;\r\n        }\r\n        for (int i = 0; i < size(); i++) {\r\n            MirrorSet mirrorSet = get(i);\r\n            int resolved = mirrorSet.resolve(source, annotation, valueExtractor);\r\n            for (int j = 0; j < mirrorSet.size; j++) {\r\n                result[mirrorSet.indexes[j]] = resolved;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * A single set of mirror attributes.\r\n     */\r\n    class MirrorSet {\r\n\r\n        private int size;\r\n\r\n        private final int[] indexes = new int[attributes.size()];\r\n\r\n        void update() {\r\n            this.size = 0;\r\n            Arrays.fill(this.indexes, -1);\r\n            for (int i = 0; i < MirrorSets.this.assigned.length; i++) {\r\n                if (MirrorSets.this.assigned[i] == this) {\r\n                    this.indexes[this.size] = i;\r\n                    this.size++;\r\n                }\r\n            }\r\n        }\r\n\r\n        <A> int resolve(@Nullable Object source, @Nullable A annotation, ValueExtractor valueExtractor) {\r\n            int result = -1;\r\n            Object lastValue = null;\r\n            for (int i = 0; i < this.size; i++) {\r\n                Method attribute = attributes.get(this.indexes[i]);\r\n                Object value = valueExtractor.extract(attribute, annotation);\r\n                boolean isDefaultValue = (value == null || isEquivalentToDefaultValue(attribute, value, valueExtractor));\r\n                if (isDefaultValue || ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n                    if (result == -1) {\r\n                        result = this.indexes[i];\r\n                    }\r\n                    continue;\r\n                }\r\n                if (lastValue != null && !ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n                    String on = (source != null) ? \" declared on \" + source : \"\";\r\n                    throw new AnnotationConfigurationException(String.format(\"Different @AliasFor mirror values for annotation [%s]%s; attribute '%s' \" + \"and its alias '%s' are declared with values of [%s] and [%s].\", getAnnotationType().getName(), on, attributes.get(result).getName(), attribute.getName(), ObjectUtils.nullSafeToString(lastValue), ObjectUtils.nullSafeToString(value)));\r\n                }\r\n                result = this.indexes[i];\r\n                lastValue = value;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        int size() {\r\n            return this.size;\r\n        }\r\n\r\n        Method get(int index) {\r\n            int attributeIndex = this.indexes[index];\r\n            return attributes.get(attributeIndex);\r\n        }\r\n\r\n        int getAttributeIndex(int index) {\r\n            return this.indexes[index];\r\n        }\r\n    }\r\n}",
    "comment": "\n * Provides mapping information for a single annotation (or meta-annotation) in\n * the context of a root annotation type.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 5.2\n * @see AnnotationTypeMappings\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#merge(List<T>,T)",
    "entityType": "method",
    "code": "private static <T> List<T> merge(@Nullable List<T> existing, T element) {\r\n    if (existing == null) {\r\n        return Collections.singletonList(element);\r\n    }\r\n    List<T> merged = new ArrayList<>(existing.size() + 1);\r\n    merged.addAll(existing);\r\n    merged.add(element);\r\n    return Collections.unmodifiableList(merged);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#resolveAliasedForTargets()",
    "entityType": "method",
    "code": "private Map<Method, List<Method>> resolveAliasedForTargets() {\r\n    Map<Method, List<Method>> aliasedBy = new HashMap<>();\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\r\n        if (aliasFor != null) {\r\n            Method target = resolveAliasTarget(attribute, aliasFor);\r\n            aliasedBy.computeIfAbsent(target, key -> new ArrayList<>()).add(attribute);\r\n        }\r\n    }\r\n    return Collections.unmodifiableMap(aliasedBy);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#resolveAliasTarget(Method,AliasFor)",
    "entityType": "method",
    "code": "private Method resolveAliasTarget(Method attribute, AliasFor aliasFor) {\r\n    return resolveAliasTarget(attribute, aliasFor, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#resolveAliasTarget(Method,AliasFor,boolean)",
    "entityType": "method",
    "code": "private Method resolveAliasTarget(Method attribute, AliasFor aliasFor, boolean checkAliasPair) {\r\n    if (StringUtils.hasText(aliasFor.value()) && StringUtils.hasText(aliasFor.attribute())) {\r\n        throw new AnnotationConfigurationException(String.format(\"In @AliasFor declared on %s, attribute 'attribute' and its alias 'value' \" + \"are present with values of '%s' and '%s', but only one is permitted.\", AttributeMethods.describe(attribute), aliasFor.attribute(), aliasFor.value()));\r\n    }\r\n    Class<? extends Annotation> targetAnnotation = aliasFor.annotation();\r\n    if (targetAnnotation == Annotation.class) {\r\n        targetAnnotation = this.annotationType;\r\n    }\r\n    String targetAttributeName = aliasFor.attribute();\r\n    if (!StringUtils.hasLength(targetAttributeName)) {\r\n        targetAttributeName = aliasFor.value();\r\n    }\r\n    if (!StringUtils.hasLength(targetAttributeName)) {\r\n        targetAttributeName = attribute.getName();\r\n    }\r\n    Method target = AttributeMethods.forAnnotationType(targetAnnotation).get(targetAttributeName);\r\n    if (target == null) {\r\n        if (targetAnnotation == this.annotationType) {\r\n            throw new AnnotationConfigurationException(String.format(\"@AliasFor declaration on %s declares an alias for '%s' which is not present.\", AttributeMethods.describe(attribute), targetAttributeName));\r\n        }\r\n        throw new AnnotationConfigurationException(String.format(\"%s is declared as an @AliasFor nonexistent %s.\", StringUtils.capitalize(AttributeMethods.describe(attribute)), AttributeMethods.describe(targetAnnotation, targetAttributeName)));\r\n    }\r\n    if (target.equals(attribute)) {\r\n        throw new AnnotationConfigurationException(String.format(\"@AliasFor declaration on %s points to itself. \" + \"Specify 'annotation' to point to a same-named attribute on a meta-annotation.\", AttributeMethods.describe(attribute)));\r\n    }\r\n    if (!isCompatibleReturnType(attribute.getReturnType(), target.getReturnType())) {\r\n        throw new AnnotationConfigurationException(String.format(\"Misconfigured aliases: %s and %s must declare the same return type.\", AttributeMethods.describe(attribute), AttributeMethods.describe(target)));\r\n    }\r\n    if (isAliasPair(target) && checkAliasPair) {\r\n        AliasFor targetAliasFor = target.getAnnotation(AliasFor.class);\r\n        if (targetAliasFor != null) {\r\n            Method mirror = resolveAliasTarget(target, targetAliasFor, false);\r\n            if (!mirror.equals(attribute)) {\r\n                throw new AnnotationConfigurationException(String.format(\"%s must be declared as an @AliasFor %s, not %s.\", StringUtils.capitalize(AttributeMethods.describe(target)), AttributeMethods.describe(attribute), AttributeMethods.describe(mirror)));\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isAliasPair(Method)",
    "entityType": "method",
    "code": "private boolean isAliasPair(Method target) {\r\n    return (this.annotationType == target.getDeclaringClass());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isCompatibleReturnType(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "private boolean isCompatibleReturnType(Class<?> attributeType, Class<?> targetType) {\r\n    return (attributeType == targetType || attributeType == targetType.componentType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#processAliases()",
    "entityType": "method",
    "code": "private void processAliases() {\r\n    List<Method> aliases = new ArrayList<>();\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        aliases.clear();\r\n        aliases.add(this.attributes.get(i));\r\n        collectAliases(aliases);\r\n        if (aliases.size() > 1) {\r\n            processAliases(i, aliases);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#collectAliases(List<Method>)",
    "entityType": "method",
    "code": "private void collectAliases(List<Method> aliases) {\r\n    AnnotationTypeMapping mapping = this;\r\n    while (mapping != null) {\r\n        int size = aliases.size();\r\n        for (int j = 0; j < size; j++) {\r\n            List<Method> additional = mapping.aliasedBy.get(aliases.get(j));\r\n            if (additional != null) {\r\n                aliases.addAll(additional);\r\n            }\r\n        }\r\n        mapping = mapping.source;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#processAliases(int,List<Method>)",
    "entityType": "method",
    "code": "private void processAliases(int attributeIndex, List<Method> aliases) {\r\n    int rootAttributeIndex = getFirstRootAttributeIndex(aliases);\r\n    AnnotationTypeMapping mapping = this;\r\n    while (mapping != null) {\r\n        if (rootAttributeIndex != -1 && mapping != this.root) {\r\n            for (int i = 0; i < mapping.attributes.size(); i++) {\r\n                if (aliases.contains(mapping.attributes.get(i))) {\r\n                    mapping.aliasMappings[i] = rootAttributeIndex;\r\n                }\r\n            }\r\n        }\r\n        mapping.mirrorSets.updateFrom(aliases);\r\n        mapping.claimedAliases.addAll(aliases);\r\n        if (mapping.annotation != null) {\r\n            int[] resolvedMirrors = mapping.mirrorSets.resolve(null, mapping.annotation, AnnotationUtils::invokeAnnotationMethod);\r\n            for (int i = 0; i < mapping.attributes.size(); i++) {\r\n                if (aliases.contains(mapping.attributes.get(i))) {\r\n                    this.annotationValueMappings[attributeIndex] = resolvedMirrors[i];\r\n                    this.annotationValueSource[attributeIndex] = mapping;\r\n                }\r\n            }\r\n        }\r\n        mapping = mapping.source;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getFirstRootAttributeIndex(Collection<Method>)",
    "entityType": "method",
    "code": "private int getFirstRootAttributeIndex(Collection<Method> aliases) {\r\n    AttributeMethods rootAttributes = this.root.getAttributes();\r\n    for (int i = 0; i < rootAttributes.size(); i++) {\r\n        if (aliases.contains(rootAttributes.get(i))) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#addConventionMappings()",
    "entityType": "method",
    "code": "private void addConventionMappings() {\r\n    if (this.distance == 0) {\r\n        return;\r\n    }\r\n    AttributeMethods rootAttributes = this.root.getAttributes();\r\n    int[] mappings = this.conventionMappings;\r\n    Set<String> conventionMappedAttributes = new HashSet<>();\r\n    for (int i = 0; i < mappings.length; i++) {\r\n        String name = this.attributes.get(i).getName();\r\n        int mapped = rootAttributes.indexOf(name);\r\n        if (!MergedAnnotation.VALUE.equals(name) && mapped != -1 && !isExplicitAttributeOverride(name)) {\r\n            conventionMappedAttributes.add(name);\r\n            mappings[i] = mapped;\r\n            MirrorSet mirrors = getMirrorSets().getAssigned(i);\r\n            if (mirrors != null) {\r\n                for (int j = 0; j < mirrors.size(); j++) {\r\n                    mappings[mirrors.getAttributeIndex(j)] = mapped;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    String rootAnnotationTypeName = this.root.annotationType.getName();\r\n    String cacheKey = rootAnnotationTypeName + '-' + this.annotationType.getName();\r\n    // We want to avoid duplicate log warnings as much as possible, without full synchronization,\r\n    // and we intentionally invoke add() before checking if any convention-based overrides were\r\n    // actually encountered in order to ensure that we add a \"tracked\" entry for the current cache\r\n    // key in any case.\r\n    // In addition, we do NOT want to log warnings for custom Java Bean Validation constraint\r\n    // annotations that are meta-annotated with other constraint annotations -- for example,\r\n    // @org.hibernate.validator.constraints.URL which overrides attributes in\r\n    // @jakarta.validation.constraints.Pattern.\r\n    if (conventionBasedOverrideCheckCache.add(cacheKey) && !conventionMappedAttributes.isEmpty() && Arrays.stream(this.annotationType.getAnnotations()).noneMatch(isBeanValidationConstraint) && logger.isWarnEnabled()) {\r\n        logger.warn(\"\"\"\r\n            Support for convention-based annotation attribute overrides is deprecated \\\r\n            and will be removed in Spring Framework 7.0. Please annotate the following \\\r\n            attributes in @%s with appropriate @AliasFor declarations: %s\"\"\".formatted(rootAnnotationTypeName, conventionMappedAttributes));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isExplicitAttributeOverride(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the given annotation attribute in the {@linkplain #getRoot()\r\n * root annotation} is an explicit annotation attribute override for an\r\n * attribute in a meta-annotation, explicit in the sense that the override\r\n * is declared via {@link AliasFor @AliasFor}.\r\n * <p>If the named attribute does not exist in the root annotation, this\r\n * method returns {@code false}.\r\n * @param name the name of the annotation attribute to check\r\n * @since 6.0\r\n */\r\nprivate boolean isExplicitAttributeOverride(String name) {\r\n    Method attribute = this.root.getAttributes().get(name);\r\n    if (attribute != null) {\r\n        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\r\n        return ((aliasFor != null) && (aliasFor.annotation() != Annotation.class) && (aliasFor.annotation() != this.root.annotationType));\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine if the given annotation attribute in the {@linkplain #getRoot()\n\t * root annotation} is an explicit annotation attribute override for an\n\t * attribute in a meta-annotation, explicit in the sense that the override\n\t * is declared via {@link AliasFor @AliasFor}.\n\t * <p>If the named attribute does not exist in the root annotation, this\n\t * method returns {@code false}.\n\t * @param name the name of the annotation attribute to check\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#addConventionAnnotationValues()",
    "entityType": "method",
    "code": "private void addConventionAnnotationValues() {\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        boolean isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());\r\n        AnnotationTypeMapping mapping = this;\r\n        while (mapping != null && mapping.distance > 0) {\r\n            int mapped = mapping.getAttributes().indexOf(attribute.getName());\r\n            if (mapped != -1 && isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) {\r\n                this.annotationValueMappings[i] = mapped;\r\n                this.annotationValueSource[i] = mapping;\r\n            }\r\n            mapping = mapping.source;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isBetterConventionAnnotationValue(int,boolean,AnnotationTypeMapping)",
    "entityType": "method",
    "code": "private boolean isBetterConventionAnnotationValue(int index, boolean isValueAttribute, AnnotationTypeMapping mapping) {\r\n    if (this.annotationValueMappings[index] == -1) {\r\n        return true;\r\n    }\r\n    int existingDistance = this.annotationValueSource[index].distance;\r\n    return !isValueAttribute && existingDistance > mapping.distance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#computeSynthesizableFlag(Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nprivate boolean computeSynthesizableFlag(Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    // Track that we have visited the current annotation type.\r\n    visitedAnnotationTypes.add(this.annotationType);\r\n    // Uses @AliasFor for local aliases?\r\n    for (int index : this.aliasMappings) {\r\n        if (index != -1) {\r\n            return true;\r\n        }\r\n    }\r\n    // Uses @AliasFor for attribute overrides in meta-annotations?\r\n    if (!this.aliasedBy.isEmpty()) {\r\n        return true;\r\n    }\r\n    // Uses convention-based attribute overrides in meta-annotations?\r\n    for (int index : this.conventionMappings) {\r\n        if (index != -1) {\r\n            return true;\r\n        }\r\n    }\r\n    // Has nested annotations or arrays of annotations that are synthesizable?\r\n    if (getAttributes().hasNestedAnnotation()) {\r\n        AttributeMethods attributeMethods = getAttributes();\r\n        for (int i = 0; i < attributeMethods.size(); i++) {\r\n            Method method = attributeMethods.get(i);\r\n            Class<?> type = method.getReturnType();\r\n            if (type.isAnnotation() || (type.isArray() && type.componentType().isAnnotation())) {\r\n                Class<? extends Annotation> annotationType = (Class<? extends Annotation>) (type.isAnnotation() ? type : type.componentType());\r\n                // Ensure we have not yet visited the current nested annotation type, in order\r\n                // to avoid infinite recursion for JVM languages other than Java that support\r\n                // recursive annotation definitions.\r\n                if (visitedAnnotationTypes.add(annotationType)) {\r\n                    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType, visitedAnnotationTypes).get(0);\r\n                    if (mapping.isSynthesizable()) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#afterAllMappingsSet()",
    "entityType": "method",
    "code": "/**\r\n * Method called after all mappings have been set. At this point no further\r\n * lookups from child mappings will occur.\r\n */\r\nvoid afterAllMappingsSet() {\r\n    validateAllAliasesClaimed();\r\n    for (int i = 0; i < this.mirrorSets.size(); i++) {\r\n        validateMirrorSet(this.mirrorSets.get(i));\r\n    }\r\n    this.claimedAliases.clear();\r\n}",
    "comment": "\n\t * Method called after all mappings have been set. At this point no further\n\t * lookups from child mappings will occur.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#validateAllAliasesClaimed()",
    "entityType": "method",
    "code": "private void validateAllAliasesClaimed() {\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);\r\n        if (aliasFor != null && !this.claimedAliases.contains(attribute)) {\r\n            Method target = resolveAliasTarget(attribute, aliasFor);\r\n            throw new AnnotationConfigurationException(String.format(\"@AliasFor declaration on %s declares an alias for %s which is not meta-present.\", AttributeMethods.describe(attribute), AttributeMethods.describe(target)));\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#validateMirrorSet(MirrorSet)",
    "entityType": "method",
    "code": "private void validateMirrorSet(MirrorSet mirrorSet) {\r\n    Method firstAttribute = mirrorSet.get(0);\r\n    Object firstDefaultValue = firstAttribute.getDefaultValue();\r\n    for (int i = 1; i <= mirrorSet.size() - 1; i++) {\r\n        Method mirrorAttribute = mirrorSet.get(i);\r\n        Object mirrorDefaultValue = mirrorAttribute.getDefaultValue();\r\n        if (firstDefaultValue == null || mirrorDefaultValue == null) {\r\n            throw new AnnotationConfigurationException(String.format(\"Misconfigured aliases: %s and %s must declare default values.\", AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));\r\n        }\r\n        if (!ObjectUtils.nullSafeEquals(firstDefaultValue, mirrorDefaultValue)) {\r\n            throw new AnnotationConfigurationException(String.format(\"Misconfigured aliases: %s and %s must declare the same default value.\", AttributeMethods.describe(firstAttribute), AttributeMethods.describe(mirrorAttribute)));\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getRoot()",
    "entityType": "method",
    "code": "/**\r\n * Get the root mapping.\r\n * @return the root mapping\r\n */\r\nAnnotationTypeMapping getRoot() {\r\n    return this.root;\r\n}",
    "comment": "\n\t * Get the root mapping.\n\t * @return the root mapping\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Get the source of the mapping or {@code null}.\r\n * @return the source of the mapping\r\n */\r\n@Nullable\r\nAnnotationTypeMapping getSource() {\r\n    return this.source;\r\n}",
    "comment": "\n\t * Get the source of the mapping or {@code null}.\n\t * @return the source of the mapping\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getDistance()",
    "entityType": "method",
    "code": "/**\r\n * Get the distance of this mapping.\r\n * @return the distance of the mapping\r\n */\r\nint getDistance() {\r\n    return this.distance;\r\n}",
    "comment": "\n\t * Get the distance of this mapping.\n\t * @return the distance of the mapping\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getAnnotationType()",
    "entityType": "method",
    "code": "/**\r\n * Get the type of the mapped annotation.\r\n * @return the annotation type\r\n */\r\nClass<? extends Annotation> getAnnotationType() {\r\n    return this.annotationType;\r\n}",
    "comment": "\n\t * Get the type of the mapped annotation.\n\t * @return the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getMetaTypes()",
    "entityType": "method",
    "code": "List<Class<? extends Annotation>> getMetaTypes() {\r\n    return this.metaTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * Get the source annotation for this mapping. This will be the\r\n * meta-annotation, or {@code null} if this is the root mapping.\r\n * @return the source annotation of the mapping\r\n */\r\n@Nullable\r\nAnnotation getAnnotation() {\r\n    return this.annotation;\r\n}",
    "comment": "\n\t * Get the source annotation for this mapping. This will be the\n\t * meta-annotation, or {@code null} if this is the root mapping.\n\t * @return the source annotation of the mapping\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getAttributes()",
    "entityType": "method",
    "code": "/**\r\n * Get the annotation attributes for the mapping annotation type.\r\n * @return the attribute methods\r\n */\r\nAttributeMethods getAttributes() {\r\n    return this.attributes;\r\n}",
    "comment": "\n\t * Get the annotation attributes for the mapping annotation type.\n\t * @return the attribute methods\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getAliasMapping(int)",
    "entityType": "method",
    "code": "/**\r\n * Get the related index of an alias mapped attribute, or {@code -1} if\r\n * there is no mapping. The resulting value is the index of the attribute on\r\n * the root annotation that can be invoked in order to obtain the actual\r\n * value.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @return the mapped attribute index or {@code -1}\r\n */\r\nint getAliasMapping(int attributeIndex) {\r\n    return this.aliasMappings[attributeIndex];\r\n}",
    "comment": "\n\t * Get the related index of an alias mapped attribute, or {@code -1} if\n\t * there is no mapping. The resulting value is the index of the attribute on\n\t * the root annotation that can be invoked in order to obtain the actual\n\t * value.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @return the mapped attribute index or {@code -1}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getConventionMapping(int)",
    "entityType": "method",
    "code": "/**\r\n * Get the related index of a convention mapped attribute, or {@code -1}\r\n * if there is no mapping. The resulting value is the index of the attribute\r\n * on the root annotation that can be invoked in order to obtain the actual\r\n * value.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @return the mapped attribute index or {@code -1}\r\n */\r\nint getConventionMapping(int attributeIndex) {\r\n    return this.conventionMappings[attributeIndex];\r\n}",
    "comment": "\n\t * Get the related index of a convention mapped attribute, or {@code -1}\n\t * if there is no mapping. The resulting value is the index of the attribute\n\t * on the root annotation that can be invoked in order to obtain the actual\n\t * value.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @return the mapped attribute index or {@code -1}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getMappedAnnotationValue(int,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Get a mapped attribute value from the most suitable\r\n * {@link #getAnnotation() meta-annotation}.\r\n * <p>The resulting value is obtained from the closest meta-annotation,\r\n * taking into consideration both convention and alias based mapping rules.\r\n * For root mappings, this method will always return {@code null}.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @param metaAnnotationsOnly if only meta annotations should be considered.\r\n * If this parameter is {@code false} then aliases within the annotation will\r\n * also be considered.\r\n * @return the mapped annotation value, or {@code null}\r\n */\r\n@Nullable\r\nObject getMappedAnnotationValue(int attributeIndex, boolean metaAnnotationsOnly) {\r\n    int mappedIndex = this.annotationValueMappings[attributeIndex];\r\n    if (mappedIndex == -1) {\r\n        return null;\r\n    }\r\n    AnnotationTypeMapping source = this.annotationValueSource[attributeIndex];\r\n    if (source == this && metaAnnotationsOnly) {\r\n        return null;\r\n    }\r\n    return AnnotationUtils.invokeAnnotationMethod(source.attributes.get(mappedIndex), source.annotation);\r\n}",
    "comment": "\n\t * Get a mapped attribute value from the most suitable\n\t * {@link #getAnnotation() meta-annotation}.\n\t * <p>The resulting value is obtained from the closest meta-annotation,\n\t * taking into consideration both convention and alias based mapping rules.\n\t * For root mappings, this method will always return {@code null}.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @param metaAnnotationsOnly if only meta annotations should be considered.\n\t * If this parameter is {@code false} then aliases within the annotation will\n\t * also be considered.\n\t * @return the mapped annotation value, or {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isEquivalentToDefaultValue(int,Object,ValueExtractor)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified value is equivalent to the default value of the\r\n * attribute at the given index.\r\n * @param attributeIndex the attribute index of the source attribute\r\n * @param value the value to check\r\n * @param valueExtractor the value extractor used to extract values from any\r\n * nested annotations\r\n * @return {@code true} if the value is equivalent to the default value\r\n */\r\nboolean isEquivalentToDefaultValue(int attributeIndex, Object value, ValueExtractor valueExtractor) {\r\n    Method attribute = this.attributes.get(attributeIndex);\r\n    return isEquivalentToDefaultValue(attribute, value, valueExtractor);\r\n}",
    "comment": "\n\t * Determine if the specified value is equivalent to the default value of the\n\t * attribute at the given index.\n\t * @param attributeIndex the attribute index of the source attribute\n\t * @param value the value to check\n\t * @param valueExtractor the value extractor used to extract values from any\n\t * nested annotations\n\t * @return {@code true} if the value is equivalent to the default value\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#getMirrorSets()",
    "entityType": "method",
    "code": "/**\r\n * Get the mirror sets for this type mapping.\r\n * @return the attribute mirror sets\r\n */\r\nMirrorSets getMirrorSets() {\r\n    return this.mirrorSets;\r\n}",
    "comment": "\n\t * Get the mirror sets for this type mapping.\n\t * @return the attribute mirror sets\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isSynthesizable()",
    "entityType": "method",
    "code": "/**\r\n * Determine if the mapped annotation is <em>synthesizable</em>.\r\n * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\r\n * for an explanation of what is considered synthesizable.\r\n * @return {@code true} if the mapped annotation is synthesizable\r\n * @since 5.2.6\r\n */\r\nboolean isSynthesizable() {\r\n    return this.synthesizable;\r\n}",
    "comment": "\n\t * Determine if the mapped annotation is <em>synthesizable</em>.\n\t * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\n\t * for an explanation of what is considered synthesizable.\n\t * @return {@code true} if the mapped annotation is synthesizable\n\t * @since 5.2.6\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#filledIntArray(int)",
    "entityType": "method",
    "code": "private static int[] filledIntArray(int size) {\r\n    if (size == 0) {\r\n        return EMPTY_INT_ARRAY;\r\n    }\r\n    int[] array = new int[size];\r\n    Arrays.fill(array, -1);\r\n    return array;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#isEquivalentToDefaultValue(Method,Object,ValueExtractor)",
    "entityType": "method",
    "code": "private static boolean isEquivalentToDefaultValue(Method attribute, Object value, ValueExtractor valueExtractor) {\r\n    return areEquivalent(attribute.getDefaultValue(), value, valueExtractor);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#areEquivalent(Object,Object,ValueExtractor)",
    "entityType": "method",
    "code": "private static boolean areEquivalent(@Nullable Object value, @Nullable Object extractedValue, ValueExtractor valueExtractor) {\r\n    if (ObjectUtils.nullSafeEquals(value, extractedValue)) {\r\n        return true;\r\n    }\r\n    if (value instanceof Class<?> clazz && extractedValue instanceof String string) {\r\n        return areEquivalent(clazz, string);\r\n    }\r\n    if (value instanceof Class<?>[] classes && extractedValue instanceof String[] strings) {\r\n        return areEquivalent(classes, strings);\r\n    }\r\n    if (value instanceof Annotation annotation) {\r\n        return areEquivalent(annotation, extractedValue, valueExtractor);\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#areEquivalent(Class<?>[],String[])",
    "entityType": "method",
    "code": "private static boolean areEquivalent(Class<?>[] value, String[] extractedValue) {\r\n    if (value.length != extractedValue.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < value.length; i++) {\r\n        if (!areEquivalent(value[i], extractedValue[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#areEquivalent(Class<?>,String)",
    "entityType": "method",
    "code": "private static boolean areEquivalent(Class<?> value, String extractedValue) {\r\n    return value.getName().equals(extractedValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMapping#areEquivalent(Annotation,Object,ValueExtractor)",
    "entityType": "method",
    "code": "private static boolean areEquivalent(Annotation annotation, @Nullable Object extractedValue, ValueExtractor valueExtractor) {\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        Method attribute = attributes.get(i);\r\n        Object value1 = AnnotationUtils.invokeAnnotationMethod(attribute, annotation);\r\n        Object value2;\r\n        if (extractedValue instanceof TypeMappedAnnotation<?> typeMappedAnnotation) {\r\n            value2 = typeMappedAnnotation.getValue(attribute.getName()).orElse(null);\r\n        } else {\r\n            value2 = valueExtractor.extract(attribute, extractedValue);\r\n        }\r\n        if (!areEquivalent(value1, value2, valueExtractor)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSets",
    "entityType": "class",
    "code": "private MirrorSet[] mirrorSets;\nprivate final MirrorSet[] assigned;\nMirrorSets() {\r\n    this.assigned = attributes.size() > 0 ? new MirrorSet[attributes.size()] : EMPTY_MIRROR_SETS;\r\n    this.mirrorSets = EMPTY_MIRROR_SETS;\r\n}\nvoid updateFrom(Collection<Method> aliases) {\r\n    MirrorSet mirrorSet = null;\r\n    int size = 0;\r\n    int last = -1;\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        Method attribute = attributes.get(i);\r\n        if (aliases.contains(attribute)) {\r\n            size++;\r\n            if (size > 1) {\r\n                if (mirrorSet == null) {\r\n                    mirrorSet = new MirrorSet();\r\n                    this.assigned[last] = mirrorSet;\r\n                }\r\n                this.assigned[i] = mirrorSet;\r\n            }\r\n            last = i;\r\n        }\r\n    }\r\n    if (mirrorSet != null) {\r\n        mirrorSet.update();\r\n        Set<MirrorSet> unique = new LinkedHashSet<>(Arrays.asList(this.assigned));\r\n        unique.remove(null);\r\n        this.mirrorSets = unique.toArray(EMPTY_MIRROR_SETS);\r\n    }\r\n}\nint size() {\r\n    return this.mirrorSets.length;\r\n}\nMirrorSet get(int index) {\r\n    return this.mirrorSets[index];\r\n}\n@Nullable\r\nMirrorSet getAssigned(int attributeIndex) {\r\n    return this.assigned[attributeIndex];\r\n}\nint[] resolve(@Nullable Object source, @Nullable Object annotation, ValueExtractor valueExtractor) {\r\n    if (attributes.size() == 0) {\r\n        return EMPTY_INT_ARRAY;\r\n    }\r\n    int[] result = new int[attributes.size()];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = i;\r\n    }\r\n    for (int i = 0; i < size(); i++) {\r\n        MirrorSet mirrorSet = get(i);\r\n        int resolved = mirrorSet.resolve(source, annotation, valueExtractor);\r\n        for (int j = 0; j < mirrorSet.size; j++) {\r\n            result[mirrorSet.indexes[j]] = resolved;\r\n        }\r\n    }\r\n    return result;\r\n}\n/**\r\n * A single set of mirror attributes.\r\n */\r\nclass MirrorSet {\r\n\r\n    private int size;\r\n\r\n    private final int[] indexes = new int[attributes.size()];\r\n\r\n    void update() {\r\n        this.size = 0;\r\n        Arrays.fill(this.indexes, -1);\r\n        for (int i = 0; i < MirrorSets.this.assigned.length; i++) {\r\n            if (MirrorSets.this.assigned[i] == this) {\r\n                this.indexes[this.size] = i;\r\n                this.size++;\r\n            }\r\n        }\r\n    }\r\n\r\n    <A> int resolve(@Nullable Object source, @Nullable A annotation, ValueExtractor valueExtractor) {\r\n        int result = -1;\r\n        Object lastValue = null;\r\n        for (int i = 0; i < this.size; i++) {\r\n            Method attribute = attributes.get(this.indexes[i]);\r\n            Object value = valueExtractor.extract(attribute, annotation);\r\n            boolean isDefaultValue = (value == null || isEquivalentToDefaultValue(attribute, value, valueExtractor));\r\n            if (isDefaultValue || ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n                if (result == -1) {\r\n                    result = this.indexes[i];\r\n                }\r\n                continue;\r\n            }\r\n            if (lastValue != null && !ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n                String on = (source != null) ? \" declared on \" + source : \"\";\r\n                throw new AnnotationConfigurationException(String.format(\"Different @AliasFor mirror values for annotation [%s]%s; attribute '%s' \" + \"and its alias '%s' are declared with values of [%s] and [%s].\", getAnnotationType().getName(), on, attributes.get(result).getName(), attribute.getName(), ObjectUtils.nullSafeToString(lastValue), ObjectUtils.nullSafeToString(value)));\r\n            }\r\n            result = this.indexes[i];\r\n            lastValue = value;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    int size() {\r\n        return this.size;\r\n    }\r\n\r\n    Method get(int index) {\r\n        int attributeIndex = this.indexes[index];\r\n        return attributes.get(attributeIndex);\r\n    }\r\n\r\n    int getAttributeIndex(int index) {\r\n        return this.indexes[index];\r\n    }\r\n}",
    "comment": "\n\t * A collection of {@link MirrorSet} instances that provides details of all\n\t * defined mirrors.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSets#updateFrom(Collection<Method>)",
    "entityType": "method",
    "code": "void updateFrom(Collection<Method> aliases) {\r\n    MirrorSet mirrorSet = null;\r\n    int size = 0;\r\n    int last = -1;\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        Method attribute = attributes.get(i);\r\n        if (aliases.contains(attribute)) {\r\n            size++;\r\n            if (size > 1) {\r\n                if (mirrorSet == null) {\r\n                    mirrorSet = new MirrorSet();\r\n                    this.assigned[last] = mirrorSet;\r\n                }\r\n                this.assigned[i] = mirrorSet;\r\n            }\r\n            last = i;\r\n        }\r\n    }\r\n    if (mirrorSet != null) {\r\n        mirrorSet.update();\r\n        Set<MirrorSet> unique = new LinkedHashSet<>(Arrays.asList(this.assigned));\r\n        unique.remove(null);\r\n        this.mirrorSets = unique.toArray(EMPTY_MIRROR_SETS);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSets#size()",
    "entityType": "method",
    "code": "int size() {\r\n    return this.mirrorSets.length;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSets#get(int)",
    "entityType": "method",
    "code": "MirrorSet get(int index) {\r\n    return this.mirrorSets[index];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSets#getAssigned(int)",
    "entityType": "method",
    "code": "@Nullable\r\nMirrorSet getAssigned(int attributeIndex) {\r\n    return this.assigned[attributeIndex];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSets#resolve(Object,Object,ValueExtractor)",
    "entityType": "method",
    "code": "int[] resolve(@Nullable Object source, @Nullable Object annotation, ValueExtractor valueExtractor) {\r\n    if (attributes.size() == 0) {\r\n        return EMPTY_INT_ARRAY;\r\n    }\r\n    int[] result = new int[attributes.size()];\r\n    for (int i = 0; i < result.length; i++) {\r\n        result[i] = i;\r\n    }\r\n    for (int i = 0; i < size(); i++) {\r\n        MirrorSet mirrorSet = get(i);\r\n        int resolved = mirrorSet.resolve(source, annotation, valueExtractor);\r\n        for (int j = 0; j < mirrorSet.size; j++) {\r\n            result[mirrorSet.indexes[j]] = resolved;\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSet",
    "entityType": "class",
    "code": "private int size;\nprivate final int[] indexes = new int[attributes.size()];\nvoid update() {\r\n    this.size = 0;\r\n    Arrays.fill(this.indexes, -1);\r\n    for (int i = 0; i < MirrorSets.this.assigned.length; i++) {\r\n        if (MirrorSets.this.assigned[i] == this) {\r\n            this.indexes[this.size] = i;\r\n            this.size++;\r\n        }\r\n    }\r\n}\n<A> int resolve(@Nullable Object source, @Nullable A annotation, ValueExtractor valueExtractor) {\r\n    int result = -1;\r\n    Object lastValue = null;\r\n    for (int i = 0; i < this.size; i++) {\r\n        Method attribute = attributes.get(this.indexes[i]);\r\n        Object value = valueExtractor.extract(attribute, annotation);\r\n        boolean isDefaultValue = (value == null || isEquivalentToDefaultValue(attribute, value, valueExtractor));\r\n        if (isDefaultValue || ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n            if (result == -1) {\r\n                result = this.indexes[i];\r\n            }\r\n            continue;\r\n        }\r\n        if (lastValue != null && !ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n            String on = (source != null) ? \" declared on \" + source : \"\";\r\n            throw new AnnotationConfigurationException(String.format(\"Different @AliasFor mirror values for annotation [%s]%s; attribute '%s' \" + \"and its alias '%s' are declared with values of [%s] and [%s].\", getAnnotationType().getName(), on, attributes.get(result).getName(), attribute.getName(), ObjectUtils.nullSafeToString(lastValue), ObjectUtils.nullSafeToString(value)));\r\n        }\r\n        result = this.indexes[i];\r\n        lastValue = value;\r\n    }\r\n    return result;\r\n}\nint size() {\r\n    return this.size;\r\n}\nMethod get(int index) {\r\n    int attributeIndex = this.indexes[index];\r\n    return attributes.get(attributeIndex);\r\n}\nint getAttributeIndex(int index) {\r\n    return this.indexes[index];\r\n}",
    "comment": "\n\t\t * A single set of mirror attributes.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSet#update()",
    "entityType": "method",
    "code": "void update() {\r\n    this.size = 0;\r\n    Arrays.fill(this.indexes, -1);\r\n    for (int i = 0; i < MirrorSets.this.assigned.length; i++) {\r\n        if (MirrorSets.this.assigned[i] == this) {\r\n            this.indexes[this.size] = i;\r\n            this.size++;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSet#resolve(Object,A,ValueExtractor)",
    "entityType": "method",
    "code": "<A> int resolve(@Nullable Object source, @Nullable A annotation, ValueExtractor valueExtractor) {\r\n    int result = -1;\r\n    Object lastValue = null;\r\n    for (int i = 0; i < this.size; i++) {\r\n        Method attribute = attributes.get(this.indexes[i]);\r\n        Object value = valueExtractor.extract(attribute, annotation);\r\n        boolean isDefaultValue = (value == null || isEquivalentToDefaultValue(attribute, value, valueExtractor));\r\n        if (isDefaultValue || ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n            if (result == -1) {\r\n                result = this.indexes[i];\r\n            }\r\n            continue;\r\n        }\r\n        if (lastValue != null && !ObjectUtils.nullSafeEquals(lastValue, value)) {\r\n            String on = (source != null) ? \" declared on \" + source : \"\";\r\n            throw new AnnotationConfigurationException(String.format(\"Different @AliasFor mirror values for annotation [%s]%s; attribute '%s' \" + \"and its alias '%s' are declared with values of [%s] and [%s].\", getAnnotationType().getName(), on, attributes.get(result).getName(), attribute.getName(), ObjectUtils.nullSafeToString(lastValue), ObjectUtils.nullSafeToString(value)));\r\n        }\r\n        result = this.indexes[i];\r\n        lastValue = value;\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSet#size()",
    "entityType": "method",
    "code": "int size() {\r\n    return this.size;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSet#get(int)",
    "entityType": "method",
    "code": "Method get(int index) {\r\n    int attributeIndex = this.indexes[index];\r\n    return attributes.get(attributeIndex);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MirrorSet#getAttributeIndex(int)",
    "entityType": "method",
    "code": "int getAttributeIndex(int index) {\r\n    return this.indexes[index];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings",
    "entityType": "class",
    "code": "private static final IntrospectionFailureLogger failureLogger = IntrospectionFailureLogger.DEBUG;\nprivate static final Map<AnnotationFilter, Cache> standardRepeatablesCache = new ConcurrentReferenceHashMap<>();\nprivate static final Map<AnnotationFilter, Cache> noRepeatablesCache = new ConcurrentReferenceHashMap<>();\nprivate final RepeatableContainers repeatableContainers;\nprivate final AnnotationFilter filter;\nprivate final List<AnnotationTypeMapping> mappings;\nprivate AnnotationTypeMappings(RepeatableContainers repeatableContainers, AnnotationFilter filter, Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    this.repeatableContainers = repeatableContainers;\r\n    this.filter = filter;\r\n    this.mappings = new ArrayList<>();\r\n    addAllMappings(annotationType, visitedAnnotationTypes);\r\n    this.mappings.forEach(AnnotationTypeMapping::afterAllMappingsSet);\r\n}\nprivate void addAllMappings(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    Deque<AnnotationTypeMapping> queue = new ArrayDeque<>();\r\n    addIfPossible(queue, null, annotationType, null, visitedAnnotationTypes);\r\n    while (!queue.isEmpty()) {\r\n        AnnotationTypeMapping mapping = queue.removeFirst();\r\n        this.mappings.add(mapping);\r\n        addMetaAnnotationsToQueue(queue, mapping);\r\n    }\r\n}\nprivate void addMetaAnnotationsToQueue(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source) {\r\n    @Nullable\r\n    Annotation[] metaAnnotations = AnnotationsScanner.getDeclaredAnnotations(source.getAnnotationType(), false);\r\n    for (Annotation metaAnnotation : metaAnnotations) {\r\n        if (!isMappable(source, metaAnnotation)) {\r\n            continue;\r\n        }\r\n        Annotation[] repeatedAnnotations = this.repeatableContainers.findRepeatedAnnotations(metaAnnotation);\r\n        if (repeatedAnnotations != null) {\r\n            for (Annotation repeatedAnnotation : repeatedAnnotations) {\r\n                if (!isMappable(source, repeatedAnnotation)) {\r\n                    continue;\r\n                }\r\n                addIfPossible(queue, source, repeatedAnnotation);\r\n            }\r\n        } else {\r\n            addIfPossible(queue, source, metaAnnotation);\r\n        }\r\n    }\r\n}\nprivate void addIfPossible(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source, Annotation ann) {\r\n    addIfPossible(queue, source, ann.annotationType(), ann, new HashSet<>());\r\n}\nprivate void addIfPossible(Deque<AnnotationTypeMapping> queue, @Nullable AnnotationTypeMapping source, Class<? extends Annotation> annotationType, @Nullable Annotation ann, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    try {\r\n        queue.addLast(new AnnotationTypeMapping(source, annotationType, ann, visitedAnnotationTypes));\r\n    } catch (Exception ex) {\r\n        AnnotationUtils.rethrowAnnotationConfigurationException(ex);\r\n        if (failureLogger.isEnabled()) {\r\n            failureLogger.log(\"Failed to introspect meta-annotation \" + annotationType.getName(), (source != null ? source.getAnnotationType() : null), ex);\r\n        }\r\n    }\r\n}\n@Contract(\"_, null -> false\")\r\nprivate boolean isMappable(AnnotationTypeMapping source, @Nullable Annotation metaAnnotation) {\r\n    return (metaAnnotation != null && !this.filter.matches(metaAnnotation) && !AnnotationFilter.PLAIN.matches(source.getAnnotationType()) && !isAlreadyMapped(source, metaAnnotation));\r\n}\nprivate boolean isAlreadyMapped(AnnotationTypeMapping source, Annotation metaAnnotation) {\r\n    Class<? extends Annotation> annotationType = metaAnnotation.annotationType();\r\n    AnnotationTypeMapping mapping = source;\r\n    while (mapping != null) {\r\n        if (mapping.getAnnotationType() == annotationType) {\r\n            return true;\r\n        }\r\n        mapping = mapping.getSource();\r\n    }\r\n    return false;\r\n}\n/**\r\n * Get the total number of contained mappings.\r\n * @return the total number of mappings\r\n */\r\nint size() {\r\n    return this.mappings.size();\r\n}\n/**\r\n * Get an individual mapping from this instance.\r\n * <p>Index {@code 0} will always return the root mapping; higher indexes\r\n * will return meta-annotation mappings.\r\n * @param index the index to return\r\n * @return the {@link AnnotationTypeMapping}\r\n * @throws IndexOutOfBoundsException if the index is out of range\r\n * ({@code index < 0 || index >= size()})\r\n */\r\nAnnotationTypeMapping get(int index) {\r\n    return this.mappings.get(index);\r\n}\n/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType) {\r\n    return forAnnotationType(annotationType, new HashSet<>());\r\n}\n/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return forAnnotationType(annotationType, RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, visitedAnnotationTypes);\r\n}\n/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the meta-annotations\r\n * @param annotationFilter the annotation filter used to limit which\r\n * annotations are considered\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    return forAnnotationType(annotationType, repeatableContainers, annotationFilter, new HashSet<>());\r\n}\n/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the meta-annotations\r\n * @param annotationFilter the annotation filter used to limit which\r\n * annotations are considered\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    if (repeatableContainers == RepeatableContainers.standardRepeatables()) {\r\n        return standardRepeatablesCache.computeIfAbsent(annotationFilter, key -> new Cache(repeatableContainers, key)).get(annotationType, visitedAnnotationTypes);\r\n    }\r\n    if (repeatableContainers == RepeatableContainers.none()) {\r\n        return noRepeatablesCache.computeIfAbsent(annotationFilter, key -> new Cache(repeatableContainers, key)).get(annotationType, visitedAnnotationTypes);\r\n    }\r\n    return new AnnotationTypeMappings(repeatableContainers, annotationFilter, annotationType, visitedAnnotationTypes);\r\n}\nstatic void clearCache() {\r\n    standardRepeatablesCache.clear();\r\n    noRepeatablesCache.clear();\r\n}\n/**\r\n * Cache created per {@link AnnotationFilter}.\r\n */\r\nprivate static class Cache {\r\n\r\n    private final RepeatableContainers repeatableContainers;\r\n\r\n    private final AnnotationFilter filter;\r\n\r\n    private final Map<Class<? extends Annotation>, AnnotationTypeMappings> mappings;\r\n\r\n    /**\r\n     * Create a cache instance with the specified filter.\r\n     * @param filter the annotation filter\r\n     */\r\n    Cache(RepeatableContainers repeatableContainers, AnnotationFilter filter) {\r\n        this.repeatableContainers = repeatableContainers;\r\n        this.filter = filter;\r\n        this.mappings = new ConcurrentReferenceHashMap<>();\r\n    }\r\n\r\n    /**\r\n     * Get or create {@link AnnotationTypeMappings} for the specified annotation type.\r\n     * @param annotationType the annotation type\r\n     * @param visitedAnnotationTypes the set of annotations that we have already\r\n     * visited; used to avoid infinite recursion for recursive annotations which\r\n     * some JVM languages support (such as Kotlin)\r\n     * @return a new or existing {@link AnnotationTypeMappings} instance\r\n     */\r\n    AnnotationTypeMappings get(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n        return this.mappings.computeIfAbsent(annotationType, key -> createMappings(key, visitedAnnotationTypes));\r\n    }\r\n\r\n    private AnnotationTypeMappings createMappings(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n        return new AnnotationTypeMappings(this.repeatableContainers, this.filter, annotationType, visitedAnnotationTypes);\r\n    }\r\n}",
    "comment": "\n * Provides {@link AnnotationTypeMapping} information for a single source\n * annotation type. Performs a recursive breadth first crawl of all\n * meta-annotations to ultimately provide a quick way to map the attributes of\n * a root {@link Annotation}.\n *\n * <p>Supports convention based merging of meta-annotations as well as implicit\n * and explicit {@link AliasFor @AliasFor} aliases. Also provides information\n * about mirrored attributes.\n *\n * <p>This class is designed to be cached so that meta-annotations only need to\n * be searched once, regardless of how many times they are actually used.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n * @see AnnotationTypeMapping\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#addAllMappings(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "private void addAllMappings(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    Deque<AnnotationTypeMapping> queue = new ArrayDeque<>();\r\n    addIfPossible(queue, null, annotationType, null, visitedAnnotationTypes);\r\n    while (!queue.isEmpty()) {\r\n        AnnotationTypeMapping mapping = queue.removeFirst();\r\n        this.mappings.add(mapping);\r\n        addMetaAnnotationsToQueue(queue, mapping);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#addMetaAnnotationsToQueue(Deque<AnnotationTypeMapping>,AnnotationTypeMapping)",
    "entityType": "method",
    "code": "private void addMetaAnnotationsToQueue(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source) {\r\n    @Nullable\r\n    Annotation[] metaAnnotations = AnnotationsScanner.getDeclaredAnnotations(source.getAnnotationType(), false);\r\n    for (Annotation metaAnnotation : metaAnnotations) {\r\n        if (!isMappable(source, metaAnnotation)) {\r\n            continue;\r\n        }\r\n        Annotation[] repeatedAnnotations = this.repeatableContainers.findRepeatedAnnotations(metaAnnotation);\r\n        if (repeatedAnnotations != null) {\r\n            for (Annotation repeatedAnnotation : repeatedAnnotations) {\r\n                if (!isMappable(source, repeatedAnnotation)) {\r\n                    continue;\r\n                }\r\n                addIfPossible(queue, source, repeatedAnnotation);\r\n            }\r\n        } else {\r\n            addIfPossible(queue, source, metaAnnotation);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#addIfPossible(Deque<AnnotationTypeMapping>,AnnotationTypeMapping,Annotation)",
    "entityType": "method",
    "code": "private void addIfPossible(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source, Annotation ann) {\r\n    addIfPossible(queue, source, ann.annotationType(), ann, new HashSet<>());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#addIfPossible(Deque<AnnotationTypeMapping>,AnnotationTypeMapping,Class<? extends Annotation>,Annotation,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "private void addIfPossible(Deque<AnnotationTypeMapping> queue, @Nullable AnnotationTypeMapping source, Class<? extends Annotation> annotationType, @Nullable Annotation ann, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    try {\r\n        queue.addLast(new AnnotationTypeMapping(source, annotationType, ann, visitedAnnotationTypes));\r\n    } catch (Exception ex) {\r\n        AnnotationUtils.rethrowAnnotationConfigurationException(ex);\r\n        if (failureLogger.isEnabled()) {\r\n            failureLogger.log(\"Failed to introspect meta-annotation \" + annotationType.getName(), (source != null ? source.getAnnotationType() : null), ex);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#isMappable(AnnotationTypeMapping,Annotation)",
    "entityType": "method",
    "code": "@Contract(\"_, null -> false\")\r\nprivate boolean isMappable(AnnotationTypeMapping source, @Nullable Annotation metaAnnotation) {\r\n    return (metaAnnotation != null && !this.filter.matches(metaAnnotation) && !AnnotationFilter.PLAIN.matches(source.getAnnotationType()) && !isAlreadyMapped(source, metaAnnotation));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#isAlreadyMapped(AnnotationTypeMapping,Annotation)",
    "entityType": "method",
    "code": "private boolean isAlreadyMapped(AnnotationTypeMapping source, Annotation metaAnnotation) {\r\n    Class<? extends Annotation> annotationType = metaAnnotation.annotationType();\r\n    AnnotationTypeMapping mapping = source;\r\n    while (mapping != null) {\r\n        if (mapping.getAnnotationType() == annotationType) {\r\n            return true;\r\n        }\r\n        mapping = mapping.getSource();\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#size()",
    "entityType": "method",
    "code": "/**\r\n * Get the total number of contained mappings.\r\n * @return the total number of mappings\r\n */\r\nint size() {\r\n    return this.mappings.size();\r\n}",
    "comment": "\n\t * Get the total number of contained mappings.\n\t * @return the total number of mappings\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#get(int)",
    "entityType": "method",
    "code": "/**\r\n * Get an individual mapping from this instance.\r\n * <p>Index {@code 0} will always return the root mapping; higher indexes\r\n * will return meta-annotation mappings.\r\n * @param index the index to return\r\n * @return the {@link AnnotationTypeMapping}\r\n * @throws IndexOutOfBoundsException if the index is out of range\r\n * ({@code index < 0 || index >= size()})\r\n */\r\nAnnotationTypeMapping get(int index) {\r\n    return this.mappings.get(index);\r\n}",
    "comment": "\n\t * Get an individual mapping from this instance.\n\t * <p>Index {@code 0} will always return the root mapping; higher indexes\n\t * will return meta-annotation mappings.\n\t * @param index the index to return\n\t * @return the {@link AnnotationTypeMapping}\n\t * @throws IndexOutOfBoundsException if the index is out of range\n\t * ({@code index < 0 || index >= size()})\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#forAnnotationType(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType) {\r\n    return forAnnotationType(annotationType, new HashSet<>());\r\n}",
    "comment": "\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @return type mappings for the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#forAnnotationType(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return forAnnotationType(annotationType, RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, visitedAnnotationTypes);\r\n}",
    "comment": "\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @param visitedAnnotationTypes the set of annotations that we have already\n\t * visited; used to avoid infinite recursion for recursive annotations which\n\t * some JVM languages support (such as Kotlin)\n\t * @return type mappings for the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#forAnnotationType(Class<? extends Annotation>,RepeatableContainers,AnnotationFilter)",
    "entityType": "method",
    "code": "/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the meta-annotations\r\n * @param annotationFilter the annotation filter used to limit which\r\n * annotations are considered\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    return forAnnotationType(annotationType, repeatableContainers, annotationFilter, new HashSet<>());\r\n}",
    "comment": "\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the meta-annotations\n\t * @param annotationFilter the annotation filter used to limit which\n\t * annotations are considered\n\t * @return type mappings for the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#forAnnotationType(Class<? extends Annotation>,RepeatableContainers,AnnotationFilter,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "/**\r\n * Create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the source annotation type\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the meta-annotations\r\n * @param annotationFilter the annotation filter used to limit which\r\n * annotations are considered\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return type mappings for the annotation type\r\n */\r\nstatic AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    if (repeatableContainers == RepeatableContainers.standardRepeatables()) {\r\n        return standardRepeatablesCache.computeIfAbsent(annotationFilter, key -> new Cache(repeatableContainers, key)).get(annotationType, visitedAnnotationTypes);\r\n    }\r\n    if (repeatableContainers == RepeatableContainers.none()) {\r\n        return noRepeatablesCache.computeIfAbsent(annotationFilter, key -> new Cache(repeatableContainers, key)).get(annotationType, visitedAnnotationTypes);\r\n    }\r\n    return new AnnotationTypeMappings(repeatableContainers, annotationFilter, annotationType, visitedAnnotationTypes);\r\n}",
    "comment": "\n\t * Create {@link AnnotationTypeMappings} for the specified annotation type.\n\t * @param annotationType the source annotation type\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the meta-annotations\n\t * @param annotationFilter the annotation filter used to limit which\n\t * annotations are considered\n\t * @param visitedAnnotationTypes the set of annotations that we have already\n\t * visited; used to avoid infinite recursion for recursive annotations which\n\t * some JVM languages support (such as Kotlin)\n\t * @return type mappings for the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationTypeMappings#clearCache()",
    "entityType": "method",
    "code": "static void clearCache() {\r\n    standardRepeatablesCache.clear();\r\n    noRepeatablesCache.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.Cache",
    "entityType": "class",
    "code": "private final RepeatableContainers repeatableContainers;\nprivate final AnnotationFilter filter;\nprivate final Map<Class<? extends Annotation>, AnnotationTypeMappings> mappings;\n/**\r\n * Create a cache instance with the specified filter.\r\n * @param filter the annotation filter\r\n */\r\nCache(RepeatableContainers repeatableContainers, AnnotationFilter filter) {\r\n    this.repeatableContainers = repeatableContainers;\r\n    this.filter = filter;\r\n    this.mappings = new ConcurrentReferenceHashMap<>();\r\n}\n/**\r\n * Get or create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the annotation type\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return a new or existing {@link AnnotationTypeMappings} instance\r\n */\r\nAnnotationTypeMappings get(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return this.mappings.computeIfAbsent(annotationType, key -> createMappings(key, visitedAnnotationTypes));\r\n}\nprivate AnnotationTypeMappings createMappings(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return new AnnotationTypeMappings(this.repeatableContainers, this.filter, annotationType, visitedAnnotationTypes);\r\n}",
    "comment": "\n\t * Cache created per {@link AnnotationFilter}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Cache#get(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "/**\r\n * Get or create {@link AnnotationTypeMappings} for the specified annotation type.\r\n * @param annotationType the annotation type\r\n * @param visitedAnnotationTypes the set of annotations that we have already\r\n * visited; used to avoid infinite recursion for recursive annotations which\r\n * some JVM languages support (such as Kotlin)\r\n * @return a new or existing {@link AnnotationTypeMappings} instance\r\n */\r\nAnnotationTypeMappings get(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return this.mappings.computeIfAbsent(annotationType, key -> createMappings(key, visitedAnnotationTypes));\r\n}",
    "comment": "\n\t\t * Get or create {@link AnnotationTypeMappings} for the specified annotation type.\n\t\t * @param annotationType the annotation type\n\t\t * @param visitedAnnotationTypes the set of annotations that we have already\n\t\t * visited; used to avoid infinite recursion for recursive annotations which\n\t\t * some JVM languages support (such as Kotlin)\n\t\t * @return a new or existing {@link AnnotationTypeMappings} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Cache#createMappings(Class<? extends Annotation>,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "private AnnotationTypeMappings createMappings(Class<? extends Annotation> annotationType, Set<Class<? extends Annotation>> visitedAnnotationTypes) {\r\n    return new AnnotationTypeMappings(this.repeatableContainers, this.filter, annotationType, visitedAnnotationTypes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils",
    "entityType": "class",
    "code": "/**\r\n * The attribute name for annotations with a single element.\r\n */\r\npublic static final String VALUE = MergedAnnotation.VALUE;\nprivate static final AnnotationFilter JAVA_LANG_ANNOTATION_FILTER = AnnotationFilter.packages(\"java.lang.annotation\");\nprivate static final Map<Class<? extends Annotation>, Map<String, DefaultValueHolder>> defaultValuesCache = new ConcurrentReferenceHashMap<>();\n/**\r\n * Determine whether the given class is a candidate for carrying one of the specified\r\n * annotations (at type, method or field level).\r\n * @param clazz the class to introspect\r\n * @param annotationTypes the searchable annotation types\r\n * @return {@code false} if the class is known to have no such annotations at any level;\r\n * {@code true} otherwise. Callers will usually perform full method/field introspection\r\n * if {@code true} is being returned here.\r\n * @since 5.2\r\n * @see #isCandidateClass(Class, Class)\r\n * @see #isCandidateClass(Class, String)\r\n */\r\npublic static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {\r\n    for (Class<? extends Annotation> annotationType : annotationTypes) {\r\n        if (isCandidateClass(clazz, annotationType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Determine whether the given class is a candidate for carrying the specified annotation\r\n * (at type, method or field level).\r\n * @param clazz the class to introspect\r\n * @param annotationType the searchable annotation type\r\n * @return {@code false} if the class is known to have no such annotations at any level;\r\n * {@code true} otherwise. Callers will usually perform full method/field introspection\r\n * if {@code true} is being returned here.\r\n * @since 5.2\r\n * @see #isCandidateClass(Class, String)\r\n */\r\npublic static boolean isCandidateClass(Class<?> clazz, @Nullable Class<? extends Annotation> annotationType) {\r\n    return (annotationType != null && isCandidateClass(clazz, annotationType.getName()));\r\n}\n/**\r\n * Determine whether the given class is a candidate for carrying the specified annotation\r\n * (at type, method or field level).\r\n * @param clazz the class to introspect\r\n * @param annotationName the fully-qualified name of the searchable annotation type\r\n * @return {@code false} if the class is known to have no such annotations at any level;\r\n * {@code true} otherwise. Callers will usually perform full method/field introspection\r\n * if {@code true} is being returned here.\r\n * @since 5.2\r\n * @see #isCandidateClass(Class, Class)\r\n */\r\npublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\r\n    if (annotationName.startsWith(\"java.\")) {\r\n        return true;\r\n    }\r\n    if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n/**\r\n * Get a single {@link Annotation} of {@code annotationType} from the supplied\r\n * annotation: either the given annotation itself or a direct meta-annotation\r\n * thereof.\r\n * <p>Note that this method supports only a single level of meta-annotations.\r\n * For support for arbitrary levels of meta-annotations, use one of the\r\n * {@code find*()} methods instead.\r\n * @param annotation the Annotation to check\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 4.0\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (annotationType.isInstance(annotation)) {\r\n        return synthesizeAnnotation((A) annotation, annotationType);\r\n    }\r\n    // Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...\r\n    if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {\r\n        return null;\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotation, new Annotation[] { annotation }, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\r\n}\n/**\r\n * Get a single {@link Annotation} of {@code annotationType} from the supplied\r\n * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\r\n * <em>meta-present</em> on the {@code AnnotatedElement}.\r\n * <p>Note that this method supports only a single level of meta-annotations.\r\n * For support for arbitrary levels of meta-annotations, use\r\n * {@link #findAnnotation(AnnotatedElement, Class)} instead.\r\n * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 3.1\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotatedElement.getAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\r\n}\nprivate static <A extends Annotation> boolean isSingleLevelPresent(MergedAnnotation<A> mergedAnnotation) {\r\n    int distance = mergedAnnotation.getDistance();\r\n    return (distance == 0 || distance == 1);\r\n}\n/**\r\n * Get a single {@link Annotation} of {@code annotationType} from the\r\n * supplied {@link Method}, where the annotation is either <em>present</em>\r\n * or <em>meta-present</em> on the method.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Note that this method supports only a single level of meta-annotations.\r\n * For support for arbitrary levels of meta-annotations, use\r\n * {@link #findAnnotation(Method, Class)} instead.\r\n * @param method the method to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\r\n * @see #getAnnotation(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {\r\n    Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);\r\n    return getAnnotation((AnnotatedElement) resolvedMethod, annotationType);\r\n}\n/**\r\n * Get all {@link Annotation Annotations} that are <em>present</em> on the\r\n * supplied {@link AnnotatedElement}.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\r\n * @return the annotations found, an empty array, or {@code null} if not\r\n * resolvable (for example, because nested Class values in annotation attributes\r\n * failed to resolve at runtime)\r\n * @since 4.0.8\r\n * @see AnnotatedElement#getAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static Annotation @Nullable [] getAnnotations(AnnotatedElement annotatedElement) {\r\n    try {\r\n        return synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);\r\n    } catch (Throwable ex) {\r\n        handleIntrospectionFailure(annotatedElement, ex);\r\n        return null;\r\n    }\r\n}\n/**\r\n * Get all {@link Annotation Annotations} that are <em>present</em> on the\r\n * supplied {@link Method}.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * @param method the Method to retrieve annotations from\r\n * @return the annotations found, an empty array, or {@code null} if not\r\n * resolvable (for example, because nested Class values in annotation attributes\r\n * failed to resolve at runtime)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\r\n * @see AnnotatedElement#getAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static Annotation @Nullable [] getAnnotations(Method method) {\r\n    try {\r\n        return synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);\r\n    } catch (Throwable ex) {\r\n        handleIntrospectionFailure(method, ex);\r\n        return null;\r\n    }\r\n}\n/**\r\n * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\r\n * {@code annotationType} from the supplied {@link AnnotatedElement}, where\r\n * such annotations are either <em>present</em>, <em>indirectly present</em>,\r\n * or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\r\n * with support for automatic detection of a <em>container annotation</em>\r\n * declared via @{@link java.lang.annotation.Repeatable} (when running on\r\n * Java 8 or higher) and with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    return getRepeatableAnnotations(annotatedElement, annotationType, null);\r\n}\n/**\r\n * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\r\n * {@code annotationType} from the supplied {@link AnnotatedElement}, where\r\n * such annotations are either <em>present</em>, <em>indirectly present</em>,\r\n * or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\r\n * with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @param containerAnnotationType the type of the container that holds\r\n * the annotations; may be {@code null} if a container is not supported\r\n * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\r\n * when running on Java 8 or higher\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\r\n    RepeatableContainers repeatableContainers = (containerAnnotationType != null ? RepeatableContainers.of(annotationType, containerAnnotationType) : RepeatableContainers.standardRepeatables());\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers).stream(annotationType).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\r\n * of {@code annotationType} from the supplied {@link AnnotatedElement},\r\n * where such annotations are either <em>directly present</em>,\r\n * <em>indirectly present</em>, or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\r\n * with support for automatic detection of a <em>container annotation</em>\r\n * declared via @{@link java.lang.annotation.Repeatable} (when running on\r\n * Java 8 or higher) and with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    return getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\r\n}\n/**\r\n * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\r\n * of {@code annotationType} from the supplied {@link AnnotatedElement},\r\n * where such annotations are either <em>directly present</em>,\r\n * <em>indirectly present</em>, or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\r\n * with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @param containerAnnotationType the type of the container that holds\r\n * the annotations; may be {@code null} if a container is not supported\r\n * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\r\n * when running on Java 8 or higher\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\r\n    RepeatableContainers repeatableContainers = containerAnnotationType != null ? RepeatableContainers.of(annotationType, containerAnnotationType) : RepeatableContainers.standardRepeatables();\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers).stream(annotationType).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the\r\n * supplied {@link AnnotatedElement}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>directly present</em> on the supplied element.\r\n * <p><strong>Warning</strong>: this method operates generically on\r\n * annotated elements. In other words, this method does not execute\r\n * specialized search algorithms for classes or methods. If you require\r\n * the more specific semantics of {@link #findAnnotation(Class, Class)}\r\n * or {@link #findAnnotation(Method, Class)}, invoke one of those methods\r\n * instead.\r\n * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 4.2\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(AnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotatedElement.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}\n/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the supplied\r\n * {@link Method}, traversing its super methods (i.e. from superclasses and\r\n * interfaces) if the annotation is not <em>directly present</em> on the given\r\n * method itself.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>directly present</em> on the method.\r\n * <p>Annotations on methods are not inherited by default, so we need to handle\r\n * this explicitly.\r\n * @param method the method to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @see #getAnnotation(Method, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {\r\n        return method.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}\n/**\r\n * Find a single {@link Annotation} of {@code annotationType} on the\r\n * supplied {@link Class}, traversing its interfaces, annotations, and\r\n * superclasses if the annotation is not <em>directly present</em> on\r\n * the given class itself.\r\n * <p>This method explicitly handles class-level annotations which are not\r\n * declared as {@link java.lang.annotation.Inherited inherited} <em>as well\r\n * as meta-annotations and annotations on interfaces</em>.\r\n * <p>The algorithm operates as follows:\r\n * <ol>\r\n * <li>Search for the annotation on the given class and return it if found.\r\n * <li>Recursively search through all annotations that the given class declares.\r\n * <li>Recursively search through all interfaces that the given class declares.\r\n * <li>Recursively search through the superclass hierarchy of the given class.\r\n * </ol>\r\n * <p>Note: in this context, the term <em>recursively</em> means that the search\r\n * process continues by returning to step #1 with the current interface,\r\n * annotation, or superclass as the class to look for annotations on.\r\n * @param clazz the class to look for annotations on\r\n * @param annotationType the type of annotation to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\r\n        A annotation = clazz.getDeclaredAnnotation(annotationType);\r\n        if (annotation != null) {\r\n            return annotation;\r\n        }\r\n        // For backwards compatibility, perform a superclass search with plain annotations\r\n        // even if not marked as @Inherited: for example, a findAnnotation search for @Deprecated\r\n        Class<?> superclass = clazz.getSuperclass();\r\n        if (superclass == null || superclass == Object.class) {\r\n            return null;\r\n        }\r\n        return findAnnotation(superclass, annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}\n/**\r\n * Find the first {@link Class} in the inheritance hierarchy of the\r\n * specified {@code clazz} (including the specified {@code clazz} itself)\r\n * on which an annotation of the specified {@code annotationType} is\r\n * <em>directly present</em>.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked; the inheritance hierarchy for interfaces will\r\n * not be traversed.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>The standard {@link Class} API does not provide a mechanism for\r\n * determining which class in an inheritance hierarchy actually declares\r\n * an {@link Annotation}, so we need to handle this explicitly.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on (may be {@code null})\r\n * @return the first {@link Class} in the inheritance hierarchy that\r\n * declares an annotation of the specified {@code annotationType},\r\n * or {@code null} if not found\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see Class#getDeclaredAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Class<?> findAnnotationDeclaringClass(Class<? extends Annotation> annotationType, @Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).get(annotationType, MergedAnnotation::isDirectlyPresent).getSource();\r\n}\n/**\r\n * Find the first {@link Class} in the inheritance hierarchy of the\r\n * specified {@code clazz} (including the specified {@code clazz} itself)\r\n * on which at least one of the specified {@code annotationTypes} is\r\n * <em>directly present</em>.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked; the inheritance hierarchy for interfaces will\r\n * not be traversed.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>The standard {@link Class} API does not provide a mechanism for\r\n * determining which class in an inheritance hierarchy actually declares\r\n * one of several candidate {@linkplain Annotation annotations}, so we\r\n * need to handle this explicitly.\r\n * @param annotationTypes the annotation types to look for\r\n * @param clazz the class to check for the annotation on (may be {@code null})\r\n * @return the first {@link Class} in the inheritance hierarchy that\r\n * declares an annotation of at least one of the specified\r\n * {@code annotationTypes}, or {@code null} if not found\r\n * @since 3.2.2\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see Class#getDeclaredAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Class<?> findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>> annotationTypes, @Nullable Class<?> clazz) {\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    MergedAnnotation<?> merged = MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent)).findFirst().orElse(null);\r\n    return (merged != null && merged.getSource() instanceof Class<?> sourceClass ? sourceClass : null);\r\n}\n/**\r\n * Determine whether an annotation of the specified {@code annotationType}\r\n * is declared locally (i.e. <em>directly present</em>) on the supplied\r\n * {@code clazz}.\r\n * <p>The supplied {@link Class} may represent any type.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>Note: This method does <strong>not</strong> determine if the annotation\r\n * is {@linkplain java.lang.annotation.Inherited inherited}.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on\r\n * @return {@code true} if an annotation of the specified {@code annotationType}\r\n * is <em>directly present</em>\r\n * @see java.lang.Class#getDeclaredAnnotations()\r\n * @see java.lang.Class#getDeclaredAnnotation(Class)\r\n */\r\npublic static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {\r\n    return MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();\r\n}\n/**\r\n * Determine whether an annotation of the specified {@code annotationType}\r\n * is <em>present</em> on the supplied {@code clazz} and is\r\n * {@linkplain java.lang.annotation.Inherited inherited}\r\n * (i.e. not <em>directly present</em>).\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * <p>If the supplied {@code clazz} is an interface, only the interface\r\n * itself will be checked. In accordance with standard meta-annotation\r\n * semantics in Java, the inheritance hierarchy for interfaces will not\r\n * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}\r\n * for the {@code @Inherited} meta-annotation for further details regarding\r\n * annotation inheritance.\r\n * @param annotationType the annotation type to look for\r\n * @param clazz the class to check for the annotation on\r\n * @return {@code true} if an annotation of the specified {@code annotationType}\r\n * is <em>present</em> and <em>inherited</em>\r\n * @see Class#isAnnotationPresent(Class)\r\n * @see #isAnnotationDeclaredLocally(Class, Class)\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {\r\n    return MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS).stream(annotationType).filter(MergedAnnotation::isDirectlyPresent).findFirst().orElseGet(MergedAnnotation::missing).getAggregateIndex() > 0;\r\n}\n/**\r\n * Determine if an annotation of type {@code metaAnnotationType} is\r\n * <em>meta-present</em> on the supplied {@code annotationType}.\r\n * @param annotationType the annotation type to search on\r\n * @param metaAnnotationType the type of meta-annotation to search for\r\n * @return {@code true} if such an annotation is meta-present\r\n * @since 4.2.1\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType, @Nullable Class<? extends Annotation> metaAnnotationType) {\r\n    if (metaAnnotationType == null) {\r\n        return false;\r\n    }\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(metaAnnotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {\r\n        return annotationType.isAnnotationPresent(metaAnnotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).isPresent(metaAnnotationType);\r\n}\n/**\r\n * Determine if the supplied {@link Annotation} is defined in the core JDK\r\n * {@code java.lang.annotation} package.\r\n * @param annotation the annotation to check\r\n * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\r\n */\r\npublic static boolean isInJavaLangAnnotationPackage(@Nullable Annotation annotation) {\r\n    return (annotation != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotation));\r\n}\n/**\r\n * Determine if the {@link Annotation} with the supplied name is defined\r\n * in the core JDK {@code java.lang.annotation} package.\r\n * @param annotationType the name of the annotation type to check\r\n * @return {@code true} if the annotation is in the {@code java.lang.annotation} package\r\n * @since 4.2\r\n */\r\npublic static boolean isInJavaLangAnnotationPackage(@Nullable String annotationType) {\r\n    return (annotationType != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotationType));\r\n}\n/**\r\n * Check the declared attributes of the given annotation, in particular covering\r\n * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for\r\n * {@code Class} values (instead of early {@code Class.getAnnotations() failure}).\r\n * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}\r\n * won't fail either (when attempted later on).\r\n * @param annotation the annotation to validate\r\n * @throws IllegalStateException if a declared {@code Class} attribute could not be read\r\n * @since 4.3.15\r\n * @see Class#getAnnotations()\r\n * @see #getAnnotationAttributes(Annotation)\r\n */\r\npublic static void validateAnnotation(Annotation annotation) {\r\n    AttributeMethods.forAnnotationType(annotation.annotationType()).validate(annotation);\r\n}\n/**\r\n * Retrieve the given annotation's attributes as a {@link Map}, preserving all\r\n * attribute types.\r\n * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\r\n * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\r\n * set to {@code false}.\r\n * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\r\n * However, the {@code Map} signature has been preserved for binary compatibility.\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @return the Map of annotation attributes, with attribute names as keys and\r\n * corresponding attribute values as values (never {@code null})\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\r\n * @see #getAnnotationAttributes(Annotation, boolean, boolean)\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\r\n */\r\npublic static Map<String, @Nullable Object> getAnnotationAttributes(Annotation annotation) {\r\n    return getAnnotationAttributes(null, annotation);\r\n}\n/**\r\n * Retrieve the given annotation's attributes as a {@link Map}.\r\n * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}\r\n * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}.\r\n * <p>Note: This method actually returns an {@link AnnotationAttributes} instance.\r\n * However, the {@code Map} signature has been preserved for binary compatibility.\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @return the Map of annotation attributes, with attribute names as keys and\r\n * corresponding attribute values as values (never {@code null})\r\n * @see #getAnnotationAttributes(Annotation, boolean, boolean)\r\n */\r\npublic static Map<String, @Nullable Object> getAnnotationAttributes(Annotation annotation, boolean classValuesAsString) {\r\n    return getAnnotationAttributes(annotation, classValuesAsString, false);\r\n}\n/**\r\n * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\r\n * <p>This method provides fully recursive annotation reading capabilities on par with\r\n * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested annotations into\r\n * {@link AnnotationAttributes} maps (for compatibility with\r\n * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\r\n * {@code Annotation} instances\r\n * @return the annotation attributes (a specialized Map) with attribute names as keys\r\n * and corresponding attribute values as values (never {@code null})\r\n * @since 3.1.1\r\n */\r\npublic static AnnotationAttributes getAnnotationAttributes(Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    return getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}\n/**\r\n * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\r\n * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}\r\n * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters\r\n * set to {@code false}.\r\n * @param annotatedElement the element that is annotated with the supplied annotation;\r\n * may be {@code null} if unknown\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @return the annotation attributes (a specialized Map) with attribute names as keys\r\n * and corresponding attribute values as values (never {@code null})\r\n * @since 4.2\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\r\n */\r\npublic static AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation) {\r\n    return getAnnotationAttributes(annotatedElement, annotation, false, false);\r\n}\n/**\r\n * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map.\r\n * <p>This method provides fully recursive annotation reading capabilities on par with\r\n * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}.\r\n * @param annotatedElement the element that is annotated with the supplied annotation;\r\n * may be {@code null} if unknown\r\n * @param annotation the annotation to retrieve the attributes for\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested annotations into\r\n * {@link AnnotationAttributes} maps (for compatibility with\r\n * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as\r\n * {@code Annotation} instances\r\n * @return the annotation attributes (a specialized Map) with attribute names as keys\r\n * and corresponding attribute values as values (never {@code null})\r\n * @since 4.2\r\n */\r\npublic static AnnotationAttributes getAnnotationAttributes(@Nullable AnnotatedElement annotatedElement, Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\r\n    return MergedAnnotation.from(annotatedElement, annotation).withNonMergedAttributes().asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);\r\n}\n/**\r\n * Register the annotation-declared default values for the given attributes,\r\n * if available.\r\n * @param attributes the annotation attributes to process\r\n * @since 4.3.2\r\n */\r\npublic static void registerDefaultValues(AnnotationAttributes attributes) {\r\n    Class<? extends Annotation> annotationType = attributes.annotationType();\r\n    if (annotationType != null && Modifier.isPublic(annotationType.getModifiers()) && !AnnotationFilter.PLAIN.matches(annotationType)) {\r\n        Map<String, DefaultValueHolder> defaultValues = getDefaultValues(annotationType);\r\n        defaultValues.forEach(attributes::putIfAbsent);\r\n    }\r\n}\nprivate static Map<String, DefaultValueHolder> getDefaultValues(Class<? extends Annotation> annotationType) {\r\n    return defaultValuesCache.computeIfAbsent(annotationType, AnnotationUtils::computeDefaultValues);\r\n}\nprivate static Map<String, DefaultValueHolder> computeDefaultValues(Class<? extends Annotation> annotationType) {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\r\n    if (!methods.hasDefaultValueMethod()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    Map<String, DefaultValueHolder> result = CollectionUtils.newLinkedHashMap(methods.size());\r\n    if (!methods.hasNestedAnnotation()) {\r\n        // Use simpler method if there are no nested annotations\r\n        for (int i = 0; i < methods.size(); i++) {\r\n            Method method = methods.get(i);\r\n            Object defaultValue = method.getDefaultValue();\r\n            if (defaultValue != null) {\r\n                result.put(method.getName(), new DefaultValueHolder(defaultValue));\r\n            }\r\n        }\r\n    } else {\r\n        // If we have nested annotations, we need them as nested maps\r\n        AnnotationAttributes attributes = MergedAnnotation.of(annotationType).asMap(annotation -> new AnnotationAttributes(annotation.getType(), true), Adapt.ANNOTATION_TO_MAP);\r\n        for (Map.Entry<String, Object> element : attributes.entrySet()) {\r\n            result.put(element.getKey(), new DefaultValueHolder(element.getValue()));\r\n        }\r\n    }\r\n    return result;\r\n}\n/**\r\n * Post-process the supplied {@link AnnotationAttributes}, preserving nested\r\n * annotations as {@code Annotation} instances.\r\n * <p>Specifically, this method enforces <em>attribute alias</em> semantics\r\n * for annotation attributes that are annotated with {@link AliasFor @AliasFor}\r\n * and replaces default value placeholders with their original default values.\r\n * @param annotatedElement the element that is annotated with an annotation or\r\n * annotation hierarchy from which the supplied attributes were created;\r\n * may be {@code null} if unknown\r\n * @param attributes the annotation attributes to post-process\r\n * @param classValuesAsString whether to convert Class references into Strings (for\r\n * compatibility with {@link org.springframework.core.type.AnnotationMetadata})\r\n * or to preserve them as Class references\r\n * @since 4.3.2\r\n * @see #getDefaultValue(Class, String)\r\n */\r\npublic static void postProcessAnnotationAttributes(@Nullable Object annotatedElement, @Nullable AnnotationAttributes attributes, boolean classValuesAsString) {\r\n    if (attributes == null) {\r\n        return;\r\n    }\r\n    if (!attributes.validated) {\r\n        Class<? extends Annotation> annotationType = attributes.annotationType();\r\n        if (annotationType == null) {\r\n            return;\r\n        }\r\n        AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\r\n        for (int i = 0; i < mapping.getMirrorSets().size(); i++) {\r\n            MirrorSet mirrorSet = mapping.getMirrorSets().get(i);\r\n            int resolved = mirrorSet.resolve(attributes.displayName, attributes, AnnotationUtils::getAttributeValueForMirrorResolution);\r\n            if (resolved != -1) {\r\n                Method attribute = mapping.getAttributes().get(resolved);\r\n                Object value = attributes.get(attribute.getName());\r\n                for (int j = 0; j < mirrorSet.size(); j++) {\r\n                    Method mirror = mirrorSet.get(j);\r\n                    if (mirror != attribute) {\r\n                        attributes.put(mirror.getName(), adaptValue(annotatedElement, value, classValuesAsString));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {\r\n        String attributeName = attributeEntry.getKey();\r\n        Object value = attributeEntry.getValue();\r\n        if (value instanceof DefaultValueHolder defaultValueHolder) {\r\n            value = defaultValueHolder.defaultValue;\r\n            attributes.put(attributeName, adaptValue(annotatedElement, value, classValuesAsString));\r\n        }\r\n    }\r\n}\n@Nullable\r\nprivate static Object getAttributeValueForMirrorResolution(Method attribute, @Nullable Object attributes) {\r\n    if (!(attributes instanceof AnnotationAttributes annotationAttributes)) {\r\n        return null;\r\n    }\r\n    Object result = annotationAttributes.get(attribute.getName());\r\n    return (result instanceof DefaultValueHolder defaultValueHolder ? defaultValueHolder.defaultValue : result);\r\n}\n@Nullable\r\nprivate static Object adaptValue(@Nullable Object annotatedElement, @Nullable Object value, boolean classValuesAsString) {\r\n    if (classValuesAsString) {\r\n        if (value instanceof Class<?> clazz) {\r\n            return clazz.getName();\r\n        }\r\n        if (value instanceof Class<?>[] classes) {\r\n            String[] names = new String[classes.length];\r\n            for (int i = 0; i < classes.length; i++) {\r\n                names[i] = classes[i].getName();\r\n            }\r\n            return names;\r\n        }\r\n    }\r\n    if (value instanceof Annotation annotation) {\r\n        return MergedAnnotation.from(annotatedElement, annotation).synthesize();\r\n    }\r\n    if (value instanceof Annotation[] annotations) {\r\n        Annotation[] synthesized = (Annotation[]) Array.newInstance(annotations.getClass().componentType(), annotations.length);\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            synthesized[i] = MergedAnnotation.from(annotatedElement, annotations[i]).synthesize();\r\n        }\r\n        return synthesized;\r\n    }\r\n    return value;\r\n}\n/**\r\n * Retrieve the <em>value</em> of the {@code value} attribute of a\r\n * single-element Annotation, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the value\r\n * @return the attribute value, or {@code null} if not found unless the attribute\r\n * value cannot be retrieved due to an {@link AnnotationConfigurationException},\r\n * in which case such an exception will be rethrown\r\n * @see #getValue(Annotation, String)\r\n */\r\n@Nullable\r\npublic static Object getValue(Annotation annotation) {\r\n    return getValue(annotation, VALUE);\r\n}\n/**\r\n * Retrieve the <em>value</em> of a named attribute, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the value\r\n * @param attributeName the name of the attribute value to retrieve\r\n * @return the attribute value, or {@code null} if not found unless the attribute\r\n * value cannot be retrieved due to an {@link AnnotationConfigurationException},\r\n * in which case such an exception will be rethrown\r\n * @see #getValue(Annotation)\r\n */\r\n@Nullable\r\npublic static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {\r\n    if (annotation == null || !StringUtils.hasText(attributeName)) {\r\n        return null;\r\n    }\r\n    try {\r\n        for (Method method : annotation.annotationType().getDeclaredMethods()) {\r\n            if (method.getName().equals(attributeName) && method.getParameterCount() == 0) {\r\n                return invokeAnnotationMethod(method, annotation);\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        handleValueRetrievalFailure(annotation, ex);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Invoke the supplied annotation attribute {@link Method} on the supplied\r\n * {@link Annotation}.\r\n * <p>An attempt will first be made to invoke the method via the annotation's\r\n * {@link InvocationHandler} (if the annotation instance is a JDK dynamic proxy).\r\n * If that fails, an attempt will be made to invoke the method via reflection.\r\n * @param method the method to invoke\r\n * @param annotation the annotation on which to invoke the method\r\n * @return the value returned from the method invocation\r\n * @since 5.3.24\r\n */\r\n@Nullable\r\nstatic Object invokeAnnotationMethod(Method method, @Nullable Object annotation) {\r\n    if (annotation == null) {\r\n        return null;\r\n    }\r\n    if (Proxy.isProxyClass(annotation.getClass())) {\r\n        try {\r\n            InvocationHandler handler = Proxy.getInvocationHandler(annotation);\r\n            return handler.invoke(annotation, method, null);\r\n        } catch (Throwable ex) {\r\n            // Ignore and fall back to reflection below\r\n        }\r\n    }\r\n    return ReflectionUtils.invokeMethod(method, annotation);\r\n}\n/**\r\n * If the supplied throwable is an {@link AnnotationConfigurationException},\r\n * it will be cast to an {@code AnnotationConfigurationException} and thrown,\r\n * allowing it to propagate to the caller.\r\n * <p>Otherwise, this method does nothing.\r\n * @param ex the throwable to inspect\r\n */\r\nstatic void rethrowAnnotationConfigurationException(Throwable ex) {\r\n    if (ex instanceof AnnotationConfigurationException exception) {\r\n        throw exception;\r\n    }\r\n}\n/**\r\n * Handle the supplied annotation introspection exception.\r\n * <p>If the supplied exception is an {@link AnnotationConfigurationException},\r\n * it will simply be thrown, allowing it to propagate to the caller, and\r\n * nothing will be logged.\r\n * <p>Otherwise, this method logs an introspection failure (in particular for\r\n * a {@link TypeNotPresentException}) before moving on, assuming nested\r\n * {@code Class} values were not resolvable within annotation attributes and\r\n * thereby effectively pretending there were no annotations on the specified\r\n * element.\r\n * @param element the element that we tried to introspect annotations on\r\n * @param ex the exception that we encountered\r\n * @see #rethrowAnnotationConfigurationException\r\n * @see IntrospectionFailureLogger\r\n */\r\nstatic void handleIntrospectionFailure(AnnotatedElement element, Throwable ex) {\r\n    rethrowAnnotationConfigurationException(ex);\r\n    IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;\r\n    boolean meta = false;\r\n    if (element instanceof Class<?> clazz && Annotation.class.isAssignableFrom(clazz)) {\r\n        // Meta-annotation introspection failure\r\n        logger = IntrospectionFailureLogger.DEBUG;\r\n        meta = true;\r\n    }\r\n    if (logger.isEnabled()) {\r\n        logger.log(\"Failed to \" + (meta ? \"meta-introspect annotation \" : \"introspect annotations on \") + element + \": \" + ex);\r\n    }\r\n}\n/**\r\n * Handle the supplied value retrieval exception.\r\n * @param annotation the annotation instance from which to retrieve the value\r\n * @param ex the exception that we encountered\r\n * @see #handleIntrospectionFailure\r\n */\r\nprivate static void handleValueRetrievalFailure(Annotation annotation, Throwable ex) {\r\n    rethrowAnnotationConfigurationException(ex);\r\n    IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;\r\n    if (logger.isEnabled()) {\r\n        logger.log(\"Failed to retrieve value from \" + annotation + \": \" + ex);\r\n    }\r\n}\n/**\r\n * Retrieve the <em>default value</em> of the {@code value} attribute\r\n * of a single-element Annotation, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the default value\r\n * @return the default value, or {@code null} if not found\r\n * @see #getDefaultValue(Annotation, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(Annotation annotation) {\r\n    return getDefaultValue(annotation, VALUE);\r\n}\n/**\r\n * Retrieve the <em>default value</em> of a named attribute, given an annotation instance.\r\n * @param annotation the annotation instance from which to retrieve the default value\r\n * @param attributeName the name of the attribute value to retrieve\r\n * @return the default value of the named attribute, or {@code null} if not found\r\n * @see #getDefaultValue(Class, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {\r\n    return (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);\r\n}\n/**\r\n * Retrieve the <em>default value</em> of the {@code value} attribute\r\n * of a single-element Annotation, given the {@link Class annotation type}.\r\n * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\r\n * @return the default value, or {@code null} if not found\r\n * @see #getDefaultValue(Class, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(Class<? extends Annotation> annotationType) {\r\n    return getDefaultValue(annotationType, VALUE);\r\n}\n/**\r\n * Retrieve the <em>default value</em> of a named attribute, given the\r\n * {@link Class annotation type}.\r\n * @param annotationType the <em>annotation type</em> for which the default value should be retrieved\r\n * @param attributeName the name of the attribute value to retrieve.\r\n * @return the default value of the named attribute, or {@code null} if not found\r\n * @see #getDefaultValue(Annotation, String)\r\n */\r\n@Nullable\r\npublic static Object getDefaultValue(@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {\r\n    if (annotationType == null || !StringUtils.hasText(attributeName)) {\r\n        return null;\r\n    }\r\n    return MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);\r\n}\n/**\r\n * <em>Synthesize</em> an annotation from the supplied {@code annotation}\r\n * by wrapping it in a dynamic proxy that transparently enforces\r\n * <em>attribute alias</em> semantics for annotation attributes that are\r\n * annotated with {@link AliasFor @AliasFor}.\r\n * @param annotation the annotation to synthesize\r\n * @param annotatedElement the element that is annotated with the supplied\r\n * annotation; may be {@code null} if unknown\r\n * @return the synthesized annotation if the supplied annotation is\r\n * <em>synthesizable</em>; {@code null} if the supplied annotation is\r\n * {@code null}; otherwise the supplied annotation unmodified\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Class)\r\n */\r\npublic static <A extends Annotation> A synthesizeAnnotation(A annotation, @Nullable AnnotatedElement annotatedElement) {\r\n    if (isSynthesizedAnnotation(annotation) || AnnotationFilter.PLAIN.matches(annotation)) {\r\n        return annotation;\r\n    }\r\n    return MergedAnnotation.from(annotatedElement, annotation).synthesize();\r\n}\n/**\r\n * <em>Synthesize</em> an annotation from its default attributes values.\r\n * <p>This method simply delegates to\r\n * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},\r\n * supplying an empty map for the source attribute values and {@code null}\r\n * for the {@link AnnotatedElement}.\r\n * @param annotationType the type of annotation to synthesize\r\n * @return the synthesized annotation\r\n * @throws IllegalArgumentException if a required attribute is missing\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\r\n */\r\npublic static <A extends Annotation> A synthesizeAnnotation(Class<A> annotationType) {\r\n    return synthesizeAnnotation(Collections.emptyMap(), annotationType, null);\r\n}\n/**\r\n * <em>Synthesize</em> an annotation from the supplied map of annotation\r\n * attributes by wrapping the map in a dynamic proxy that implements an\r\n * annotation of the specified {@code annotationType} and transparently\r\n * enforces <em>attribute alias</em> semantics for annotation attributes\r\n * that are annotated with {@link AliasFor @AliasFor}.\r\n * <p>The supplied map must contain a key-value pair for every attribute\r\n * defined in the supplied {@code annotationType} that is not aliased or\r\n * does not have a default value. Nested maps and nested arrays of maps\r\n * will be recursively synthesized into nested annotations or nested\r\n * arrays of annotations, respectively.\r\n * <p>Note that {@link AnnotationAttributes} is a specialized type of\r\n * {@link Map} that is an ideal candidate for this method's\r\n * {@code attributes} argument.\r\n * @param attributes the map of annotation attributes to synthesize\r\n * @param annotationType the type of annotation to synthesize\r\n * @param annotatedElement the element that is annotated with the annotation\r\n * corresponding to the supplied attributes; may be {@code null} if unknown\r\n * @return the synthesized annotation\r\n * @throws IllegalArgumentException if a required attribute is missing or if an\r\n * attribute is not of the correct type\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Class)\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation)\r\n * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)\r\n */\r\npublic static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes, Class<A> annotationType, @Nullable AnnotatedElement annotatedElement) {\r\n    try {\r\n        return MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();\r\n    } catch (NoSuchElementException | IllegalStateException ex) {\r\n        throw new IllegalArgumentException(ex);\r\n    }\r\n}\n/**\r\n * <em>Synthesize</em> an array of annotations from the supplied array\r\n * of {@code annotations} by creating a new array of the same size and\r\n * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,\r\n * AnnotatedElement) synthesized} versions of the annotations from the input\r\n * array.\r\n * @param annotations the array of annotations to synthesize\r\n * @param annotatedElement the element that is annotated with the supplied\r\n * array of annotations; may be {@code null} if unknown\r\n * @return a new array of synthesized annotations, or {@code null} if\r\n * the supplied array is {@code null}\r\n * @throws AnnotationConfigurationException if invalid configuration of\r\n * {@code @AliasFor} is detected\r\n * @since 4.2\r\n * @see #synthesizeAnnotation(Annotation, AnnotatedElement)\r\n * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)\r\n */\r\nstatic Annotation[] synthesizeAnnotationArray(Annotation[] annotations, AnnotatedElement annotatedElement) {\r\n    if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotations;\r\n    }\r\n    Annotation[] synthesized = (Annotation[]) Array.newInstance(annotations.getClass().componentType(), annotations.length);\r\n    for (int i = 0; i < annotations.length; i++) {\r\n        synthesized[i] = synthesizeAnnotation(annotations[i], annotatedElement);\r\n    }\r\n    return synthesized;\r\n}\n/**\r\n * Determine if the supplied {@link Annotation} has been <em>synthesized</em>\r\n * by Spring (i.e. wrapped in a dynamic proxy) with additional functionality\r\n * such as attribute alias handling.\r\n * @param annotation the annotation to check\r\n * @return {@code true} if the supplied annotation is a synthesized annotation\r\n * @since 5.3.23\r\n */\r\npublic static boolean isSynthesizedAnnotation(@Nullable Annotation annotation) {\r\n    try {\r\n        return (annotation != null && Proxy.isProxyClass(annotation.getClass()) && Proxy.getInvocationHandler(annotation) instanceof SynthesizedMergedAnnotationInvocationHandler);\r\n    } catch (SecurityException ex) {\r\n        // Security settings disallow reflective access to the InvocationHandler:\r\n        // assume the annotation has not been synthesized by Spring.\r\n        return false;\r\n    }\r\n}\n/**\r\n * Clear the internal annotation metadata cache.\r\n * @since 4.3.15\r\n */\r\npublic static void clearCache() {\r\n    AnnotationTypeMappings.clearCache();\r\n    AnnotationsScanner.clearCache();\r\n    AttributeMethods.cache.clear();\r\n    RepeatableContainers.cache.clear();\r\n    OrderUtils.orderCache.clear();\r\n}\n/**\r\n * Internal holder used to wrap default values.\r\n */\r\nprivate static class DefaultValueHolder {\r\n\r\n    final Object defaultValue;\r\n\r\n    public DefaultValueHolder(Object defaultValue) {\r\n        this.defaultValue = defaultValue;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"*\" + this.defaultValue;\r\n    }\r\n}",
    "comment": "\n * General utility methods for working with annotations, handling meta-annotations,\n * bridge methods (which the compiler generates for generic declarations) as well\n * as super methods (for optional <em>annotation inheritance</em>).\n *\n * <p>Note that most of the features of this class are not provided by the\n * JDK's introspection facilities themselves.\n *\n * <p>As a general rule for runtime-retained application annotations (for example, for\n * transaction control, authorization, or service exposure), always use the\n * lookup methods on this class (for example, {@link #findAnnotation(Method, Class)} or\n * {@link #getAnnotation(Method, Class)}) instead of the plain annotation lookup\n * methods in the JDK. You can still explicitly choose between a <em>get</em>\n * lookup on the given class level only ({@link #getAnnotation(Method, Class)})\n * and a <em>find</em> lookup in the entire inheritance hierarchy of the given\n * method ({@link #findAnnotation(Method, Class)}).\n *\n * <h3>Terminology</h3>\n * The terms <em>directly present</em>, <em>indirectly present</em>, and\n * <em>present</em> have the same meanings as defined in the class-level\n * javadoc for {@link AnnotatedElement} (in Java 8).\n *\n * <p>An annotation is <em>meta-present</em> on an element if the annotation\n * is declared as a meta-annotation on some other annotation which is\n * <em>present</em> on the element. Annotation {@code A} is <em>meta-present</em>\n * on another annotation if {@code A} is either <em>directly present</em> or\n * <em>meta-present</em> on the other annotation.\n *\n * <h3>Meta-annotation Support</h3>\n * <p>Most {@code find*()} methods and some {@code get*()} methods in this class\n * provide support for finding annotations used as meta-annotations. Consult the\n * javadoc for each method in this class for details. For fine-grained support for\n * meta-annotations with <em>attribute overrides</em> in <em>composed annotations</em>,\n * consider using {@link AnnotatedElementUtils}'s more specific methods instead.\n *\n * <h3>Attribute Aliases</h3>\n * <p>All public methods in this class that return annotations, arrays of\n * annotations, or {@link AnnotationAttributes} transparently support attribute\n * aliases configured via {@link AliasFor @AliasFor}. Consult the various\n * {@code synthesizeAnnotation*(..)} methods for details.\n *\n * <h3>Search Scope</h3>\n * <p>The search algorithms used by methods in this class stop searching for\n * an annotation once the first annotation of the specified type has been\n * found. As a consequence, additional annotations of the specified type will\n * be silently ignored.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Mark Fisher\n * @author Chris Beams\n * @author Phillip Webb\n * @author Oleg Zhurakousky\n * @since 2.0\n * @see AliasFor\n * @see AnnotationAttributes\n * @see AnnotatedElementUtils\n * @see BridgeMethodResolver\n * @see java.lang.reflect.AnnotatedElement#getAnnotations()\n * @see java.lang.reflect.AnnotatedElement#getAnnotation(Class)\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotations()\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isCandidateClass(Class<?>,Collection<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class is a candidate for carrying one of the specified\r\n * annotations (at type, method or field level).\r\n * @param clazz the class to introspect\r\n * @param annotationTypes the searchable annotation types\r\n * @return {@code false} if the class is known to have no such annotations at any level;\r\n * {@code true} otherwise. Callers will usually perform full method/field introspection\r\n * if {@code true} is being returned here.\r\n * @since 5.2\r\n * @see #isCandidateClass(Class, Class)\r\n * @see #isCandidateClass(Class, String)\r\n */\r\npublic static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {\r\n    for (Class<? extends Annotation> annotationType : annotationTypes) {\r\n        if (isCandidateClass(clazz, annotationType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the given class is a candidate for carrying one of the specified\n\t * annotations (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationTypes the searchable annotation types\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t * @see #isCandidateClass(Class, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isCandidateClass(Class<?>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class is a candidate for carrying the specified annotation\r\n * (at type, method or field level).\r\n * @param clazz the class to introspect\r\n * @param annotationType the searchable annotation type\r\n * @return {@code false} if the class is known to have no such annotations at any level;\r\n * {@code true} otherwise. Callers will usually perform full method/field introspection\r\n * if {@code true} is being returned here.\r\n * @since 5.2\r\n * @see #isCandidateClass(Class, String)\r\n */\r\npublic static boolean isCandidateClass(Class<?> clazz, @Nullable Class<? extends Annotation> annotationType) {\r\n    return (annotationType != null && isCandidateClass(clazz, annotationType.getName()));\r\n}",
    "comment": "\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationType the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isCandidateClass(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class is a candidate for carrying the specified annotation\r\n * (at type, method or field level).\r\n * @param clazz the class to introspect\r\n * @param annotationName the fully-qualified name of the searchable annotation type\r\n * @return {@code false} if the class is known to have no such annotations at any level;\r\n * {@code true} otherwise. Callers will usually perform full method/field introspection\r\n * if {@code true} is being returned here.\r\n * @since 5.2\r\n * @see #isCandidateClass(Class, Class)\r\n */\r\npublic static boolean isCandidateClass(Class<?> clazz, String annotationName) {\r\n    if (annotationName.startsWith(\"java.\")) {\r\n        return true;\r\n    }\r\n    if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Determine whether the given class is a candidate for carrying the specified annotation\n\t * (at type, method or field level).\n\t * @param clazz the class to introspect\n\t * @param annotationName the fully-qualified name of the searchable annotation type\n\t * @return {@code false} if the class is known to have no such annotations at any level;\n\t * {@code true} otherwise. Callers will usually perform full method/field introspection\n\t * if {@code true} is being returned here.\n\t * @since 5.2\n\t * @see #isCandidateClass(Class, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotation(Annotation,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get a single {@link Annotation} of {@code annotationType} from the supplied\r\n * annotation: either the given annotation itself or a direct meta-annotation\r\n * thereof.\r\n * <p>Note that this method supports only a single level of meta-annotations.\r\n * For support for arbitrary levels of meta-annotations, use one of the\r\n * {@code find*()} methods instead.\r\n * @param annotation the Annotation to check\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 4.0\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (annotationType.isInstance(annotation)) {\r\n        return synthesizeAnnotation((A) annotation, annotationType);\r\n    }\r\n    // Shortcut: no searchable annotations to be found on plain Java classes and core Spring types...\r\n    if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {\r\n        return null;\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotation, new Annotation[] { annotation }, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\r\n}",
    "comment": "\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * annotation: either the given annotation itself or a direct meta-annotation\n\t * thereof.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use one of the\n\t * {@code find*()} methods instead.\n\t * @param annotation the Annotation to check\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 4.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotation(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get a single {@link Annotation} of {@code annotationType} from the supplied\r\n * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\r\n * <em>meta-present</em> on the {@code AnnotatedElement}.\r\n * <p>Note that this method supports only a single level of meta-annotations.\r\n * For support for arbitrary levels of meta-annotations, use\r\n * {@link #findAnnotation(AnnotatedElement, Class)} instead.\r\n * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\r\n * @param annotationType the annotation type to look for, both locally and as a meta-annotation\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @since 3.1\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {\r\n        return annotatedElement.getAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none()).get(annotationType).withNonMergedAttributes().synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);\r\n}",
    "comment": "\n\t * Get a single {@link Annotation} of {@code annotationType} from the supplied\n\t * {@link AnnotatedElement}, where the annotation is either <em>present</em> or\n\t * <em>meta-present</em> on the {@code AnnotatedElement}.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(AnnotatedElement, Class)} instead.\n\t * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation\n\t * @param annotationType the annotation type to look for, both locally and as a meta-annotation\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @since 3.1\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#isSingleLevelPresent(MergedAnnotation<A>)",
    "entityType": "method",
    "code": "private static <A extends Annotation> boolean isSingleLevelPresent(MergedAnnotation<A> mergedAnnotation) {\r\n    int distance = mergedAnnotation.getDistance();\r\n    return (distance == 0 || distance == 1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotation(Method,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get a single {@link Annotation} of {@code annotationType} from the\r\n * supplied {@link Method}, where the annotation is either <em>present</em>\r\n * or <em>meta-present</em> on the method.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Note that this method supports only a single level of meta-annotations.\r\n * For support for arbitrary levels of meta-annotations, use\r\n * {@link #findAnnotation(Method, Class)} instead.\r\n * @param method the method to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the first matching annotation, or {@code null} if not found\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\r\n * @see #getAnnotation(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {\r\n    Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);\r\n    return getAnnotation((AnnotatedElement) resolvedMethod, annotationType);\r\n}",
    "comment": "\n\t * Get a single {@link Annotation} of {@code annotationType} from the\n\t * supplied {@link Method}, where the annotation is either <em>present</em>\n\t * or <em>meta-present</em> on the method.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Note that this method supports only a single level of meta-annotations.\n\t * For support for arbitrary levels of meta-annotations, use\n\t * {@link #findAnnotation(Method, Class)} instead.\n\t * @param method the method to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the first matching annotation, or {@code null} if not found\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see #getAnnotation(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * Get all {@link Annotation Annotations} that are <em>present</em> on the\r\n * supplied {@link AnnotatedElement}.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\r\n * @return the annotations found, an empty array, or {@code null} if not\r\n * resolvable (for example, because nested Class values in annotation attributes\r\n * failed to resolve at runtime)\r\n * @since 4.0.8\r\n * @see AnnotatedElement#getAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static Annotation @Nullable [] getAnnotations(AnnotatedElement annotatedElement) {\r\n    try {\r\n        return synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);\r\n    } catch (Throwable ex) {\r\n        handleIntrospectionFailure(annotatedElement, ex);\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Get all {@link Annotation Annotations} that are <em>present</em> on the\n\t * supplied {@link AnnotatedElement}.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * @param annotatedElement the Method, Constructor or Field to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (for example, because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @since 4.0.8\n\t * @see AnnotatedElement#getAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getAnnotations(Method)",
    "entityType": "method",
    "code": "/**\r\n * Get all {@link Annotation Annotations} that are <em>present</em> on the\r\n * supplied {@link Method}.\r\n * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\r\n * <p>Meta-annotations will <em>not</em> be searched.\r\n * @param method the Method to retrieve annotations from\r\n * @return the annotations found, an empty array, or {@code null} if not\r\n * resolvable (for example, because nested Class values in annotation attributes\r\n * failed to resolve at runtime)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\r\n * @see AnnotatedElement#getAnnotations()\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static Annotation @Nullable [] getAnnotations(Method method) {\r\n    try {\r\n        return synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);\r\n    } catch (Throwable ex) {\r\n        handleIntrospectionFailure(method, ex);\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Get all {@link Annotation Annotations} that are <em>present</em> on the\n\t * supplied {@link Method}.\n\t * <p>Correctly handles bridge {@link Method Methods} generated by the compiler.\n\t * <p>Meta-annotations will <em>not</em> be searched.\n\t * @param method the Method to retrieve annotations from\n\t * @return the annotations found, an empty array, or {@code null} if not\n\t * resolvable (for example, because nested Class values in annotation attributes\n\t * failed to resolve at runtime)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)\n\t * @see AnnotatedElement#getAnnotations()\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\r\n * {@code annotationType} from the supplied {@link AnnotatedElement}, where\r\n * such annotations are either <em>present</em>, <em>indirectly present</em>,\r\n * or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\r\n * with support for automatic detection of a <em>container annotation</em>\r\n * declared via @{@link java.lang.annotation.Repeatable} (when running on\r\n * Java 8 or higher) and with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    return getRepeatableAnnotations(annotatedElement, annotationType, null);\r\n}",
    "comment": "\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\r\n * {@code annotationType} from the supplied {@link AnnotatedElement}, where\r\n * such annotations are either <em>present</em>, <em>indirectly present</em>,\r\n * or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\r\n * with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @param containerAnnotationType the type of the container that holds\r\n * the annotations; may be {@code null} if a container is not supported\r\n * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\r\n * when running on Java 8 or higher\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\r\n    RepeatableContainers repeatableContainers = (containerAnnotationType != null ? RepeatableContainers.of(annotationType, containerAnnotationType) : RepeatableContainers.standardRepeatables());\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers).stream(annotationType).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Get the <em>repeatable</em> {@linkplain Annotation annotations} of\n\t * {@code annotationType} from the supplied {@link AnnotatedElement}, where\n\t * such annotations are either <em>present</em>, <em>indirectly present</em>,\n\t * or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\r\n * of {@code annotationType} from the supplied {@link AnnotatedElement},\r\n * where such annotations are either <em>directly present</em>,\r\n * <em>indirectly present</em>, or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\r\n * with support for automatic detection of a <em>container annotation</em>\r\n * declared via @{@link java.lang.annotation.Repeatable} (when running on\r\n * Java 8 or higher) and with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType) {\r\n    return getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);\r\n}",
    "comment": "\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with support for automatic detection of a <em>container annotation</em>\n\t * declared via @{@link java.lang.annotation.Repeatable} (when running on\n\t * Java 8 or higher) and with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationUtils#getDeclaredRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\r\n * of {@code annotationType} from the supplied {@link AnnotatedElement},\r\n * where such annotations are either <em>directly present</em>,\r\n * <em>indirectly present</em>, or <em>meta-present</em> on the element.\r\n * <p>This method mimics the functionality of Java 8's\r\n * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\r\n * with additional support for meta-annotations.\r\n * <p>Handles both single annotations and annotations nested within a\r\n * <em>container annotation</em>.\r\n * <p>Correctly handles <em>bridge methods</em> generated by the\r\n * compiler if the supplied element is a {@link Method}.\r\n * <p>Meta-annotations will be searched if the annotation is not\r\n * <em>present</em> on the supplied element.\r\n * @param annotatedElement the element to look for annotations on\r\n * @param annotationType the annotation type to look for\r\n * @param containerAnnotationType the type of the container that holds\r\n * the annotations; may be {@code null} if a container is not supported\r\n * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\r\n * when running on Java 8 or higher\r\n * @return the annotations found or an empty set (never {@code null})\r\n * @since 4.2\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\r\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\r\n * @see java.lang.annotation.Repeatable\r\n * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\r\n * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\r\n */\r\n@Deprecated\r\npublic static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement, Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {\r\n    RepeatableContainers repeatableContainers = containerAnnotationType != null ? RepeatableContainers.of(annotationType, containerAnnotationType) : RepeatableContainers.standardRepeatables();\r\n    return MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers).stream(annotationType).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}\n\t * of {@code annotationType} from the supplied {@link AnnotatedElement},\n\t * where such annotations are either <em>directly present</em>,\n\t * <em>indirectly present</em>, or <em>meta-present</em> on the element.\n\t * <p>This method mimics the functionality of Java 8's\n\t * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}\n\t * with additional support for meta-annotations.\n\t * <p>Handles both single annotations and annotations nested within a\n\t * <em>container annotation</em>.\n\t * <p>Correctly handles <em>bridge methods</em> generated by the\n\t * compiler if the supplied element is a {@link Method}.\n\t * <p>Meta-annotations will be searched if the annotation is not\n\t * <em>present</em> on the supplied element.\n\t * @param annotatedElement the element to look for annotations on\n\t * @param annotationType the annotation type to look for\n\t * @param containerAnnotationType the type of the container that holds\n\t * the annotations; may be {@code null} if a container is not supported\n\t * or if it should be looked up via @{@link java.lang.annotation.Repeatable}\n\t * when running on Java 8 or higher\n\t * @return the annotations found or an empty set (never {@code null})\n\t * @since 4.2\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)\n\t * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod\n\t * @see java.lang.annotation.Repeatable\n\t * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType\n\t * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API\n\t "
  }
]