[
  {
    "entityId": "org.springframework.core.io.ClassPathResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying class path locations and\r\n * associated class loaders.\r\n * @see #getPath()\r\n * @see #getClassLoader()\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ClassPathResource that && this.absolutePath.equals(that.absolutePath) && ObjectUtils.nullSafeEquals(getClassLoader(), that.getClassLoader())));\r\n}",
    "comment": "\n\t * This implementation compares the underlying class path locations and\n\t * associated class loaders.\n\t * @see #getPath()\n\t * @see #getClassLoader()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code of the underlying class path location.\r\n * @see #getPath()\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.absolutePath.hashCode();\r\n}",
    "comment": "\n\t * This implementation returns the hash code of the underlying class path location.\n\t * @see #getPath()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassRelativeResourceLoader",
    "entityType": "class",
    "code": "private final Class<?> clazz;\n/**\r\n * Create a new ClassRelativeResourceLoader for the given class.\r\n * @param clazz the class to load resources through\r\n */\r\npublic ClassRelativeResourceLoader(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    this.clazz = clazz;\r\n    setClassLoader(clazz.getClassLoader());\r\n}\n@Override\r\nprotected Resource getResourceByPath(String path) {\r\n    return new ClassRelativeContextResource(path, this.clazz);\r\n}\n/**\r\n * ClassPathResource that explicitly expresses a context-relative path\r\n * through implementing the ContextResource interface.\r\n */\r\nprivate static class ClassRelativeContextResource extends ClassPathResource implements ContextResource {\r\n\r\n    private final Class<?> clazz;\r\n\r\n    public ClassRelativeContextResource(String path, Class<?> clazz) {\r\n        super(path, clazz);\r\n        this.clazz = clazz;\r\n    }\r\n\r\n    @Override\r\n    public String getPathWithinContext() {\r\n        return getPath();\r\n    }\r\n\r\n    @Override\r\n    public Resource createRelative(String relativePath) {\r\n        String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);\r\n        return new ClassRelativeContextResource(pathToUse, this.clazz);\r\n    }\r\n}",
    "comment": "\n * {@link ResourceLoader} implementation that interprets plain resource paths\n * as relative to a given {@code java.lang.Class}.\n *\n * @author Juergen Hoeller\n * @since 3.0\n * @see Class#getResource(String)\n * @see ClassPathResource#ClassPathResource(String, Class)\n "
  },
  {
    "entityId": "org.springframework.core.io.ClassRelativeResourceLoader#getResourceByPath(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected Resource getResourceByPath(String path) {\r\n    return new ClassRelativeContextResource(path, this.clazz);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ClassRelativeContextResource",
    "entityType": "class",
    "code": "private final Class<?> clazz;\npublic ClassRelativeContextResource(String path, Class<?> clazz) {\r\n    super(path, clazz);\r\n    this.clazz = clazz;\r\n}\n@Override\r\npublic String getPathWithinContext() {\r\n    return getPath();\r\n}\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);\r\n    return new ClassRelativeContextResource(pathToUse, this.clazz);\r\n}",
    "comment": "\n\t * ClassPathResource that explicitly expresses a context-relative path\n\t * through implementing the ContextResource interface.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassRelativeContextResource#getPathWithinContext()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPathWithinContext() {\r\n    return getPath();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ClassRelativeContextResource#createRelative(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);\r\n    return new ClassRelativeContextResource(pathToUse, this.clazz);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ContextResource",
    "entityType": "class",
    "code": "/**\r\n * Return the path within the enclosing 'context'.\r\n * <p>This is typically path relative to a context-specific root directory,\r\n * for example, a ServletContext root or a PortletContext root.\r\n */\r\nString getPathWithinContext();",
    "comment": "\n * Extended interface for a resource that is loaded from an enclosing\n * 'context', for example, from a {@link jakarta.servlet.ServletContext} but also\n * from plain classpath paths or relative file system paths (specified\n * without an explicit prefix, hence applying relative to the local\n * {@link ResourceLoader}'s context).\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see org.springframework.web.context.support.ServletContextResource\n "
  },
  {
    "entityId": "org.springframework.core.io.ContextResource#getPathWithinContext()",
    "entityType": "method",
    "code": "/**\r\n * Return the path within the enclosing 'context'.\r\n * <p>This is typically path relative to a context-specific root directory,\r\n * for example, a ServletContext root or a PortletContext root.\r\n */\r\nString getPathWithinContext();",
    "comment": "\n\t * Return the path within the enclosing 'context'.\n\t * <p>This is typically path relative to a context-specific root directory,\n\t * for example, a ServletContext root or a PortletContext root.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader",
    "entityType": "class",
    "code": "@Nullable\r\nprivate ClassLoader classLoader;\nprivate final Set<ProtocolResolver> protocolResolvers = new LinkedHashSet<>(4);\nprivate final Map<Class<?>, Map<Resource, ?>> resourceCaches = new ConcurrentHashMap<>(4);\n/**\r\n * Create a new DefaultResourceLoader.\r\n * <p>ClassLoader access will happen using the thread context class loader\r\n * at the time of actual resource access (since 5.3). For more control, pass\r\n * a specific ClassLoader to {@link #DefaultResourceLoader(ClassLoader)}.\r\n * @see java.lang.Thread#getContextClassLoader()\r\n */\r\npublic DefaultResourceLoader() {\r\n}\n/**\r\n * Create a new DefaultResourceLoader.\r\n * @param classLoader the ClassLoader to load class path resources with, or {@code null}\r\n * for using the thread context class loader at the time of actual resource access\r\n */\r\npublic DefaultResourceLoader(@Nullable ClassLoader classLoader) {\r\n    this.classLoader = classLoader;\r\n}\n/**\r\n * Specify the ClassLoader to load class path resources with, or {@code null}\r\n * for using the thread context class loader at the time of actual resource access.\r\n * <p>The default is that ClassLoader access will happen using the thread context\r\n * class loader at the time of actual resource access (since 5.3).\r\n */\r\npublic void setClassLoader(@Nullable ClassLoader classLoader) {\r\n    this.classLoader = classLoader;\r\n}\n/**\r\n * Return the ClassLoader to load class path resources with.\r\n * <p>Will get passed to ClassPathResource's constructor for all\r\n * ClassPathResource objects created by this resource loader.\r\n * @see ClassPathResource\r\n */\r\n@Override\r\n@Nullable\r\npublic ClassLoader getClassLoader() {\r\n    return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\r\n}\n/**\r\n * Register the given resolver with this resource loader, allowing for\r\n * additional protocols to be handled.\r\n * <p>Any such resolver will be invoked ahead of this loader's standard\r\n * resolution rules. It may therefore also override any default rules.\r\n * @since 4.3\r\n * @see #getProtocolResolvers()\r\n */\r\npublic void addProtocolResolver(ProtocolResolver resolver) {\r\n    Assert.notNull(resolver, \"ProtocolResolver must not be null\");\r\n    this.protocolResolvers.add(resolver);\r\n}\n/**\r\n * Return the collection of currently registered protocol resolvers,\r\n * allowing for introspection as well as modification.\r\n * @since 4.3\r\n * @see #addProtocolResolver(ProtocolResolver)\r\n */\r\npublic Collection<ProtocolResolver> getProtocolResolvers() {\r\n    return this.protocolResolvers;\r\n}\n/**\r\n * Obtain a cache for the given value type, keyed by {@link Resource}.\r\n * @param valueType the value type, for example, an ASM {@code MetadataReader}\r\n * @return the cache {@link Map}, shared at the {@code ResourceLoader} level\r\n * @since 5.0\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> Map<Resource, T> getResourceCache(Class<T> valueType) {\r\n    return (Map<Resource, T>) this.resourceCaches.computeIfAbsent(valueType, key -> new ConcurrentHashMap<>());\r\n}\n/**\r\n * Clear all resource caches in this resource loader.\r\n * @since 5.0\r\n * @see #getResourceCache\r\n */\r\npublic void clearResourceCaches() {\r\n    this.resourceCaches.clear();\r\n}\n@Override\r\npublic Resource getResource(String location) {\r\n    Assert.notNull(location, \"Location must not be null\");\r\n    for (ProtocolResolver protocolResolver : getProtocolResolvers()) {\r\n        Resource resource = protocolResolver.resolve(location, this);\r\n        if (resource != null) {\r\n            return resource;\r\n        }\r\n    }\r\n    if (location.startsWith(\"/\")) {\r\n        return getResourceByPath(location);\r\n    } else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\r\n    } else {\r\n        try {\r\n            // Try to parse the location as a URL...\r\n            URL url = ResourceUtils.toURL(location);\r\n            return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));\r\n        } catch (MalformedURLException ex) {\r\n            // No URL -> resolve as resource path.\r\n            return getResourceByPath(location);\r\n        }\r\n    }\r\n}\n/**\r\n * Return a Resource handle for the resource at the given path.\r\n * <p>The default implementation supports class path locations. This should\r\n * be appropriate for standalone implementations but can be overridden,\r\n * for example, for implementations targeted at a Servlet container.\r\n * @param path the path to the resource\r\n * @return the corresponding Resource handle\r\n * @see ClassPathResource\r\n * @see org.springframework.context.support.FileSystemXmlApplicationContext#getResourceByPath\r\n * @see org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath\r\n */\r\nprotected Resource getResourceByPath(String path) {\r\n    return new ClassPathContextResource(path, getClassLoader());\r\n}\n/**\r\n * ClassPathResource that explicitly expresses a context-relative path\r\n * through implementing the ContextResource interface.\r\n */\r\nprotected static class ClassPathContextResource extends ClassPathResource implements ContextResource {\r\n\r\n    public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) {\r\n        super(path, classLoader);\r\n    }\r\n\r\n    @Override\r\n    public String getPathWithinContext() {\r\n        return getPath();\r\n    }\r\n\r\n    @Override\r\n    public Resource createRelative(String relativePath) {\r\n        String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);\r\n        return new ClassPathContextResource(pathToUse, getClassLoader());\r\n    }\r\n}",
    "comment": "\n * Default implementation of the {@link ResourceLoader} interface.\n *\n * <p>Used by {@link ResourceEditor}, and serves as base class for\n * {@link org.springframework.context.support.AbstractApplicationContext}.\n * Can also be used standalone.\n *\n * <p>Will return a {@link UrlResource} if the location value is a URL,\n * and a {@link ClassPathResource} if it is a non-URL path or a\n * \"classpath:\" pseudo-URL.\n *\n * @author Juergen Hoeller\n * @since 10.03.2004\n * @see FileSystemResourceLoader\n * @see org.springframework.context.support.ClassPathXmlApplicationContext\n "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#setClassLoader(ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Specify the ClassLoader to load class path resources with, or {@code null}\r\n * for using the thread context class loader at the time of actual resource access.\r\n * <p>The default is that ClassLoader access will happen using the thread context\r\n * class loader at the time of actual resource access (since 5.3).\r\n */\r\npublic void setClassLoader(@Nullable ClassLoader classLoader) {\r\n    this.classLoader = classLoader;\r\n}",
    "comment": "\n\t * Specify the ClassLoader to load class path resources with, or {@code null}\n\t * for using the thread context class loader at the time of actual resource access.\n\t * <p>The default is that ClassLoader access will happen using the thread context\n\t * class loader at the time of actual resource access (since 5.3).\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#getClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the ClassLoader to load class path resources with.\r\n * <p>Will get passed to ClassPathResource's constructor for all\r\n * ClassPathResource objects created by this resource loader.\r\n * @see ClassPathResource\r\n */\r\n@Override\r\n@Nullable\r\npublic ClassLoader getClassLoader() {\r\n    return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\r\n}",
    "comment": "\n\t * Return the ClassLoader to load class path resources with.\n\t * <p>Will get passed to ClassPathResource's constructor for all\n\t * ClassPathResource objects created by this resource loader.\n\t * @see ClassPathResource\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#addProtocolResolver(ProtocolResolver)",
    "entityType": "method",
    "code": "/**\r\n * Register the given resolver with this resource loader, allowing for\r\n * additional protocols to be handled.\r\n * <p>Any such resolver will be invoked ahead of this loader's standard\r\n * resolution rules. It may therefore also override any default rules.\r\n * @since 4.3\r\n * @see #getProtocolResolvers()\r\n */\r\npublic void addProtocolResolver(ProtocolResolver resolver) {\r\n    Assert.notNull(resolver, \"ProtocolResolver must not be null\");\r\n    this.protocolResolvers.add(resolver);\r\n}",
    "comment": "\n\t * Register the given resolver with this resource loader, allowing for\n\t * additional protocols to be handled.\n\t * <p>Any such resolver will be invoked ahead of this loader's standard\n\t * resolution rules. It may therefore also override any default rules.\n\t * @since 4.3\n\t * @see #getProtocolResolvers()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#getProtocolResolvers()",
    "entityType": "method",
    "code": "/**\r\n * Return the collection of currently registered protocol resolvers,\r\n * allowing for introspection as well as modification.\r\n * @since 4.3\r\n * @see #addProtocolResolver(ProtocolResolver)\r\n */\r\npublic Collection<ProtocolResolver> getProtocolResolvers() {\r\n    return this.protocolResolvers;\r\n}",
    "comment": "\n\t * Return the collection of currently registered protocol resolvers,\n\t * allowing for introspection as well as modification.\n\t * @since 4.3\n\t * @see #addProtocolResolver(ProtocolResolver)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#getResourceCache(Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Obtain a cache for the given value type, keyed by {@link Resource}.\r\n * @param valueType the value type, for example, an ASM {@code MetadataReader}\r\n * @return the cache {@link Map}, shared at the {@code ResourceLoader} level\r\n * @since 5.0\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> Map<Resource, T> getResourceCache(Class<T> valueType) {\r\n    return (Map<Resource, T>) this.resourceCaches.computeIfAbsent(valueType, key -> new ConcurrentHashMap<>());\r\n}",
    "comment": "\n\t * Obtain a cache for the given value type, keyed by {@link Resource}.\n\t * @param valueType the value type, for example, an ASM {@code MetadataReader}\n\t * @return the cache {@link Map}, shared at the {@code ResourceLoader} level\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#clearResourceCaches()",
    "entityType": "method",
    "code": "/**\r\n * Clear all resource caches in this resource loader.\r\n * @since 5.0\r\n * @see #getResourceCache\r\n */\r\npublic void clearResourceCaches() {\r\n    this.resourceCaches.clear();\r\n}",
    "comment": "\n\t * Clear all resource caches in this resource loader.\n\t * @since 5.0\n\t * @see #getResourceCache\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#getResource(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource getResource(String location) {\r\n    Assert.notNull(location, \"Location must not be null\");\r\n    for (ProtocolResolver protocolResolver : getProtocolResolvers()) {\r\n        Resource resource = protocolResolver.resolve(location, this);\r\n        if (resource != null) {\r\n            return resource;\r\n        }\r\n    }\r\n    if (location.startsWith(\"/\")) {\r\n        return getResourceByPath(location);\r\n    } else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\r\n    } else {\r\n        try {\r\n            // Try to parse the location as a URL...\r\n            URL url = ResourceUtils.toURL(location);\r\n            return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));\r\n        } catch (MalformedURLException ex) {\r\n            // No URL -> resolve as resource path.\r\n            return getResourceByPath(location);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.DefaultResourceLoader#getResourceByPath(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a Resource handle for the resource at the given path.\r\n * <p>The default implementation supports class path locations. This should\r\n * be appropriate for standalone implementations but can be overridden,\r\n * for example, for implementations targeted at a Servlet container.\r\n * @param path the path to the resource\r\n * @return the corresponding Resource handle\r\n * @see ClassPathResource\r\n * @see org.springframework.context.support.FileSystemXmlApplicationContext#getResourceByPath\r\n * @see org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath\r\n */\r\nprotected Resource getResourceByPath(String path) {\r\n    return new ClassPathContextResource(path, getClassLoader());\r\n}",
    "comment": "\n\t * Return a Resource handle for the resource at the given path.\n\t * <p>The default implementation supports class path locations. This should\n\t * be appropriate for standalone implementations but can be overridden,\n\t * for example, for implementations targeted at a Servlet container.\n\t * @param path the path to the resource\n\t * @return the corresponding Resource handle\n\t * @see ClassPathResource\n\t * @see org.springframework.context.support.FileSystemXmlApplicationContext#getResourceByPath\n\t * @see org.springframework.web.context.support.XmlWebApplicationContext#getResourceByPath\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathContextResource",
    "entityType": "class",
    "code": "public ClassPathContextResource(String path, @Nullable ClassLoader classLoader) {\r\n    super(path, classLoader);\r\n}\n@Override\r\npublic String getPathWithinContext() {\r\n    return getPath();\r\n}\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);\r\n    return new ClassPathContextResource(pathToUse, getClassLoader());\r\n}",
    "comment": "\n\t * ClassPathResource that explicitly expresses a context-relative path\n\t * through implementing the ContextResource interface.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathContextResource#getPathWithinContext()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPathWithinContext() {\r\n    return getPath();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ClassPathContextResource#createRelative(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(getPath(), relativePath);\r\n    return new ClassPathContextResource(pathToUse, getClassLoader());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource",
    "entityType": "class",
    "code": "private final String description;\n/**\r\n * Create a new DescriptiveResource.\r\n * @param description the resource description\r\n */\r\npublic DescriptiveResource(@Nullable String description) {\r\n    this.description = (description != null ? description : \"\");\r\n}\n@Override\r\npublic boolean exists() {\r\n    return false;\r\n}\n@Override\r\npublic boolean isReadable() {\r\n    return false;\r\n}\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not point to a readable resource\");\r\n}\n@Override\r\npublic String getDescription() {\r\n    return this.description;\r\n}\n/**\r\n * This implementation compares the underlying description String.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof DescriptiveResource that && this.description.equals(that.description)));\r\n}\n/**\r\n * This implementation returns the hash code of the underlying description String.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.description.hashCode();\r\n}",
    "comment": "\n * Simple {@link Resource} implementation that holds a resource description\n * but does not point to an actually readable resource.\n *\n * <p>To be used as placeholder if a {@code Resource} argument is\n * expected by an API but not necessarily used for actual reading.\n *\n * @author Juergen Hoeller\n * @since 1.2.6\n "
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource#exists()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean exists() {\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource#isReadable()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isReadable() {\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource#getInputStream()",
    "entityType": "method",
    "code": "@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not point to a readable resource\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource#getDescription()",
    "entityType": "method",
    "code": "@Override\r\npublic String getDescription() {\r\n    return this.description;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying description String.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof DescriptiveResource that && this.description.equals(that.description)));\r\n}",
    "comment": "\n\t * This implementation compares the underlying description String.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.DescriptiveResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code of the underlying description String.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.description.hashCode();\r\n}",
    "comment": "\n\t * This implementation returns the hash code of the underlying description String.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource",
    "entityType": "class",
    "code": "private final String path;\n@Nullable\r\nprivate final File file;\nprivate final Path filePath;\n/**\r\n * Create a new {@code FileSystemResource} from a file path.\r\n * <p>Note: When building relative resources via {@link #createRelative},\r\n * it makes a difference whether the specified resource base path here\r\n * ends with a slash or not. In the case of \"C:/dir1/\", relative paths\r\n * will be built underneath that root: for example, relative path \"dir2\" &rarr;\r\n * \"C:/dir1/dir2\". In the case of \"C:/dir1\", relative paths will apply\r\n * at the same directory level: relative path \"dir2\" &rarr; \"C:/dir2\".\r\n * @param path a file path\r\n * @see #FileSystemResource(Path)\r\n */\r\npublic FileSystemResource(String path) {\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    this.path = StringUtils.cleanPath(path);\r\n    this.file = new File(path);\r\n    this.filePath = this.file.toPath();\r\n}\n/**\r\n * Create a new {@code FileSystemResource} from a {@link File} handle.\r\n * <p>Note: When building relative resources via {@link #createRelative},\r\n * the relative path will apply <i>at the same directory level</i>:\r\n * for example, new File(\"C:/dir1\"), relative path \"dir2\" &rarr; \"C:/dir2\"!\r\n * If you prefer to have relative paths built underneath the given root directory,\r\n * use the {@link #FileSystemResource(String) constructor with a file path}\r\n * to append a trailing slash to the root path: \"C:/dir1/\", which indicates\r\n * this directory as root for all relative paths.\r\n * @param file a File handle\r\n * @see #FileSystemResource(Path)\r\n * @see #getFile()\r\n */\r\npublic FileSystemResource(File file) {\r\n    Assert.notNull(file, \"File must not be null\");\r\n    this.path = StringUtils.cleanPath(file.getPath());\r\n    this.file = file;\r\n    this.filePath = file.toPath();\r\n}\n/**\r\n * Create a new {@code FileSystemResource} from a {@link Path} handle,\r\n * performing all file system interactions via NIO.2 instead of {@link File}.\r\n * <p>In contrast to {@link PathResource}, this variant strictly follows the\r\n * general {@link FileSystemResource} conventions, in particular in terms of\r\n * path cleaning and {@link #createRelative(String)} handling.\r\n * <p>Note: When building relative resources via {@link #createRelative},\r\n * the relative path will apply <i>at the same directory level</i>:\r\n * for example, Paths.get(\"C:/dir1\"), relative path \"dir2\" &rarr; \"C:/dir2\"!\r\n * If you prefer to have relative paths built underneath the given root directory,\r\n * use the {@link #FileSystemResource(String) constructor with a file path}\r\n * to append a trailing slash to the root path: \"C:/dir1/\", which indicates\r\n * this directory as root for all relative paths. Alternatively, consider\r\n * using {@link PathResource#PathResource(Path)} for {@code java.nio.path.Path}\r\n * resolution in {@code createRelative}, always nesting relative paths.\r\n * @param filePath a Path handle to a file\r\n * @since 5.1\r\n * @see #FileSystemResource(File)\r\n */\r\npublic FileSystemResource(Path filePath) {\r\n    Assert.notNull(filePath, \"Path must not be null\");\r\n    this.path = StringUtils.cleanPath(filePath.toString());\r\n    this.file = null;\r\n    this.filePath = filePath;\r\n}\n/**\r\n * Create a new {@code FileSystemResource} from a {@link FileSystem} handle,\r\n * locating the specified path.\r\n * <p>This is an alternative to {@link #FileSystemResource(String)},\r\n * performing all file system interactions via NIO.2 instead of {@link File}.\r\n * @param fileSystem the FileSystem to locate the path within\r\n * @param path a file path\r\n * @since 5.1.1\r\n * @see #FileSystemResource(File)\r\n */\r\npublic FileSystemResource(FileSystem fileSystem, String path) {\r\n    Assert.notNull(fileSystem, \"FileSystem must not be null\");\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    this.path = StringUtils.cleanPath(path);\r\n    this.file = null;\r\n    this.filePath = fileSystem.getPath(this.path).normalize();\r\n}\n/**\r\n * Return the file path for this resource.\r\n */\r\npublic final String getPath() {\r\n    return this.path;\r\n}\n/**\r\n * This implementation returns whether the underlying file exists.\r\n * @see java.io.File#exists()\r\n * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return (this.file != null ? this.file.exists() : Files.exists(this.filePath));\r\n}\n/**\r\n * This implementation checks whether the underlying file is marked as readable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.io.File#canRead()\r\n * @see java.io.File#isDirectory()\r\n * @see java.nio.file.Files#isReadable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    return (this.file != null ? this.file.canRead() && !this.file.isDirectory() : Files.isReadable(this.filePath) && !Files.isDirectory(this.filePath));\r\n}\n/**\r\n * This implementation opens an NIO file stream for the underlying file.\r\n * @see java.nio.file.Files#newInputStream(Path, java.nio.file.OpenOption...)\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    try {\r\n        return Files.newInputStream(this.filePath);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n@Override\r\npublic byte[] getContentAsByteArray() throws IOException {\r\n    try {\r\n        return Files.readAllBytes(this.filePath);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n@Override\r\npublic String getContentAsString(Charset charset) throws IOException {\r\n    try {\r\n        return Files.readString(this.filePath, charset);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n/**\r\n * This implementation checks whether the underlying file is marked as writable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.io.File#canWrite()\r\n * @see java.io.File#isDirectory()\r\n * @see java.nio.file.Files#isWritable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isWritable() {\r\n    return (this.file != null ? this.file.canWrite() && !this.file.isDirectory() : Files.isWritable(this.filePath) && !Files.isDirectory(this.filePath));\r\n}\n/**\r\n * This implementation opens a FileOutputStream for the underlying file.\r\n * @see java.nio.file.Files#newOutputStream(Path, java.nio.file.OpenOption...)\r\n */\r\n@Override\r\npublic OutputStream getOutputStream() throws IOException {\r\n    return Files.newOutputStream(this.filePath);\r\n}\n/**\r\n * This implementation returns a URL for the underlying file.\r\n * @see java.io.File#toURI()\r\n * @see java.nio.file.Path#toUri()\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    return (this.file != null ? this.file.toURI().toURL() : this.filePath.toUri().toURL());\r\n}\n/**\r\n * This implementation returns a URI for the underlying file.\r\n * @see java.io.File#toURI()\r\n * @see java.nio.file.Path#toUri()\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    if (this.file != null) {\r\n        return this.file.toURI();\r\n    } else {\r\n        URI uri = this.filePath.toUri();\r\n        // Normalize URI? See https://github.com/spring-projects/spring-framework/issues/29275\r\n        String scheme = uri.getScheme();\r\n        if (ResourceUtils.URL_PROTOCOL_FILE.equals(scheme)) {\r\n            try {\r\n                uri = new URI(scheme, uri.getPath(), null);\r\n            } catch (URISyntaxException ex) {\r\n                throw new IOException(\"Failed to normalize URI: \" + uri, ex);\r\n            }\r\n        }\r\n        return uri;\r\n    }\r\n}\n/**\r\n * This implementation always indicates a file.\r\n */\r\n@Override\r\npublic boolean isFile() {\r\n    return true;\r\n}\n/**\r\n * This implementation returns the underlying File reference.\r\n */\r\n@Override\r\npublic File getFile() {\r\n    return (this.file != null ? this.file : this.filePath.toFile());\r\n}\n/**\r\n * This implementation opens a FileChannel for the underlying file.\r\n * @see java.nio.channels.FileChannel\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    try {\r\n        return FileChannel.open(this.filePath, StandardOpenOption.READ);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n/**\r\n * This implementation opens a FileChannel for the underlying file.\r\n * @see java.nio.channels.FileChannel\r\n */\r\n@Override\r\npublic WritableByteChannel writableChannel() throws IOException {\r\n    return FileChannel.open(this.filePath, StandardOpenOption.WRITE);\r\n}\n/**\r\n * This implementation returns the underlying File/Path length.\r\n */\r\n@Override\r\npublic long contentLength() throws IOException {\r\n    if (this.file != null) {\r\n        long length = this.file.length();\r\n        if (length == 0L && !this.file.exists()) {\r\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its content length\");\r\n        }\r\n        return length;\r\n    } else {\r\n        try {\r\n            return Files.size(this.filePath);\r\n        } catch (NoSuchFileException ex) {\r\n            throw new FileNotFoundException(ex.getMessage());\r\n        }\r\n    }\r\n}\n/**\r\n * This implementation returns the underlying File/Path last-modified time.\r\n */\r\n@Override\r\npublic long lastModified() throws IOException {\r\n    if (this.file != null) {\r\n        return super.lastModified();\r\n    } else {\r\n        try {\r\n            return Files.getLastModifiedTime(this.filePath).toMillis();\r\n        } catch (NoSuchFileException ex) {\r\n            throw new FileNotFoundException(ex.getMessage());\r\n        }\r\n    }\r\n}\n/**\r\n * This implementation creates a FileSystemResource, applying the given path\r\n * relative to the path of the underlying file of this resource descriptor.\r\n * @see org.springframework.util.StringUtils#applyRelativePath(String, String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return (this.file != null ? new FileSystemResource(pathToUse) : new FileSystemResource(this.filePath.getFileSystem(), pathToUse));\r\n}\n/**\r\n * This implementation returns the name of the file.\r\n * @see java.io.File#getName()\r\n * @see java.nio.file.Path#getFileName()\r\n */\r\n@Override\r\npublic String getFilename() {\r\n    return (this.file != null ? this.file.getName() : this.filePath.getFileName().toString());\r\n}\n/**\r\n * This implementation returns a description that includes the absolute\r\n * path of the file.\r\n * @see java.io.File#getAbsolutePath()\r\n * @see java.nio.file.Path#toAbsolutePath()\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"file [\" + (this.file != null ? this.file.getAbsolutePath() : this.filePath.toAbsolutePath()) + \"]\";\r\n}\n/**\r\n * This implementation compares the underlying file paths.\r\n * @see #getPath()\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof FileSystemResource that && this.path.equals(that.path)));\r\n}\n/**\r\n * This implementation returns the hash code of the underlying file path.\r\n * @see #getPath()\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.path.hashCode();\r\n}",
    "comment": "\n * {@link Resource} implementation for {@code java.io.File} and\n * {@code java.nio.file.Path} handles with a file system target.\n * Supports resolution as a {@code File} and also as a {@code URL}.\n * Implements the extended {@link WritableResource} interface.\n *\n * <p>Note: This {@link Resource} implementation uses NIO.2 API for read/write\n * interactions and may be constructed with a {@link java.nio.file.Path} handle\n * in which case it will perform all file system interactions via NIO.2, only\n * resorting to {@link File} on {@link #getFile()}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n * @see #FileSystemResource(String)\n * @see #FileSystemResource(File)\n * @see #FileSystemResource(Path)\n * @see java.io.File\n * @see java.nio.file.Files\n "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getPath()",
    "entityType": "method",
    "code": "/**\r\n * Return the file path for this resource.\r\n */\r\npublic final String getPath() {\r\n    return this.path;\r\n}",
    "comment": "\n\t * Return the file path for this resource.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#exists()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns whether the underlying file exists.\r\n * @see java.io.File#exists()\r\n * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return (this.file != null ? this.file.exists() : Files.exists(this.filePath));\r\n}",
    "comment": "\n\t * This implementation returns whether the underlying file exists.\n\t * @see java.io.File#exists()\n\t * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#isReadable()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks whether the underlying file is marked as readable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.io.File#canRead()\r\n * @see java.io.File#isDirectory()\r\n * @see java.nio.file.Files#isReadable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    return (this.file != null ? this.file.canRead() && !this.file.isDirectory() : Files.isReadable(this.filePath) && !Files.isDirectory(this.filePath));\r\n}",
    "comment": "\n\t * This implementation checks whether the underlying file is marked as readable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.io.File#canRead()\n\t * @see java.io.File#isDirectory()\n\t * @see java.nio.file.Files#isReadable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens an NIO file stream for the underlying file.\r\n * @see java.nio.file.Files#newInputStream(Path, java.nio.file.OpenOption...)\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    try {\r\n        return Files.newInputStream(this.filePath);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": "\n\t * This implementation opens an NIO file stream for the underlying file.\n\t * @see java.nio.file.Files#newInputStream(Path, java.nio.file.OpenOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getContentAsByteArray()",
    "entityType": "method",
    "code": "@Override\r\npublic byte[] getContentAsByteArray() throws IOException {\r\n    try {\r\n        return Files.readAllBytes(this.filePath);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getContentAsString(Charset)",
    "entityType": "method",
    "code": "@Override\r\npublic String getContentAsString(Charset charset) throws IOException {\r\n    try {\r\n        return Files.readString(this.filePath, charset);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#isWritable()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks whether the underlying file is marked as writable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.io.File#canWrite()\r\n * @see java.io.File#isDirectory()\r\n * @see java.nio.file.Files#isWritable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isWritable() {\r\n    return (this.file != null ? this.file.canWrite() && !this.file.isDirectory() : Files.isWritable(this.filePath) && !Files.isDirectory(this.filePath));\r\n}",
    "comment": "\n\t * This implementation checks whether the underlying file is marked as writable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.io.File#canWrite()\n\t * @see java.io.File#isDirectory()\n\t * @see java.nio.file.Files#isWritable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getOutputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens a FileOutputStream for the underlying file.\r\n * @see java.nio.file.Files#newOutputStream(Path, java.nio.file.OpenOption...)\r\n */\r\n@Override\r\npublic OutputStream getOutputStream() throws IOException {\r\n    return Files.newOutputStream(this.filePath);\r\n}",
    "comment": "\n\t * This implementation opens a FileOutputStream for the underlying file.\n\t * @see java.nio.file.Files#newOutputStream(Path, java.nio.file.OpenOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getURL()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a URL for the underlying file.\r\n * @see java.io.File#toURI()\r\n * @see java.nio.file.Path#toUri()\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    return (this.file != null ? this.file.toURI().toURL() : this.filePath.toUri().toURL());\r\n}",
    "comment": "\n\t * This implementation returns a URL for the underlying file.\n\t * @see java.io.File#toURI()\n\t * @see java.nio.file.Path#toUri()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getURI()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a URI for the underlying file.\r\n * @see java.io.File#toURI()\r\n * @see java.nio.file.Path#toUri()\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    if (this.file != null) {\r\n        return this.file.toURI();\r\n    } else {\r\n        URI uri = this.filePath.toUri();\r\n        // Normalize URI? See https://github.com/spring-projects/spring-framework/issues/29275\r\n        String scheme = uri.getScheme();\r\n        if (ResourceUtils.URL_PROTOCOL_FILE.equals(scheme)) {\r\n            try {\r\n                uri = new URI(scheme, uri.getPath(), null);\r\n            } catch (URISyntaxException ex) {\r\n                throw new IOException(\"Failed to normalize URI: \" + uri, ex);\r\n            }\r\n        }\r\n        return uri;\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns a URI for the underlying file.\n\t * @see java.io.File#toURI()\n\t * @see java.nio.file.Path#toUri()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#isFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always indicates a file.\r\n */\r\n@Override\r\npublic boolean isFile() {\r\n    return true;\r\n}",
    "comment": "\n\t * This implementation always indicates a file.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying File reference.\r\n */\r\n@Override\r\npublic File getFile() {\r\n    return (this.file != null ? this.file : this.filePath.toFile());\r\n}",
    "comment": "\n\t * This implementation returns the underlying File reference.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#readableChannel()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens a FileChannel for the underlying file.\r\n * @see java.nio.channels.FileChannel\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    try {\r\n        return FileChannel.open(this.filePath, StandardOpenOption.READ);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": "\n\t * This implementation opens a FileChannel for the underlying file.\n\t * @see java.nio.channels.FileChannel\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#writableChannel()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens a FileChannel for the underlying file.\r\n * @see java.nio.channels.FileChannel\r\n */\r\n@Override\r\npublic WritableByteChannel writableChannel() throws IOException {\r\n    return FileChannel.open(this.filePath, StandardOpenOption.WRITE);\r\n}",
    "comment": "\n\t * This implementation opens a FileChannel for the underlying file.\n\t * @see java.nio.channels.FileChannel\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#contentLength()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying File/Path length.\r\n */\r\n@Override\r\npublic long contentLength() throws IOException {\r\n    if (this.file != null) {\r\n        long length = this.file.length();\r\n        if (length == 0L && !this.file.exists()) {\r\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for checking its content length\");\r\n        }\r\n        return length;\r\n    } else {\r\n        try {\r\n            return Files.size(this.filePath);\r\n        } catch (NoSuchFileException ex) {\r\n            throw new FileNotFoundException(ex.getMessage());\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns the underlying File/Path length.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#lastModified()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying File/Path last-modified time.\r\n */\r\n@Override\r\npublic long lastModified() throws IOException {\r\n    if (this.file != null) {\r\n        return super.lastModified();\r\n    } else {\r\n        try {\r\n            return Files.getLastModifiedTime(this.filePath).toMillis();\r\n        } catch (NoSuchFileException ex) {\r\n            throw new FileNotFoundException(ex.getMessage());\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns the underlying File/Path last-modified time.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#createRelative(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation creates a FileSystemResource, applying the given path\r\n * relative to the path of the underlying file of this resource descriptor.\r\n * @see org.springframework.util.StringUtils#applyRelativePath(String, String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return (this.file != null ? new FileSystemResource(pathToUse) : new FileSystemResource(this.filePath.getFileSystem(), pathToUse));\r\n}",
    "comment": "\n\t * This implementation creates a FileSystemResource, applying the given path\n\t * relative to the path of the underlying file of this resource descriptor.\n\t * @see org.springframework.util.StringUtils#applyRelativePath(String, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getFilename()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the name of the file.\r\n * @see java.io.File#getName()\r\n * @see java.nio.file.Path#getFileName()\r\n */\r\n@Override\r\npublic String getFilename() {\r\n    return (this.file != null ? this.file.getName() : this.filePath.getFileName().toString());\r\n}",
    "comment": "\n\t * This implementation returns the name of the file.\n\t * @see java.io.File#getName()\n\t * @see java.nio.file.Path#getFileName()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#getDescription()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a description that includes the absolute\r\n * path of the file.\r\n * @see java.io.File#getAbsolutePath()\r\n * @see java.nio.file.Path#toAbsolutePath()\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"file [\" + (this.file != null ? this.file.getAbsolutePath() : this.filePath.toAbsolutePath()) + \"]\";\r\n}",
    "comment": "\n\t * This implementation returns a description that includes the absolute\n\t * path of the file.\n\t * @see java.io.File#getAbsolutePath()\n\t * @see java.nio.file.Path#toAbsolutePath()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying file paths.\r\n * @see #getPath()\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof FileSystemResource that && this.path.equals(that.path)));\r\n}",
    "comment": "\n\t * This implementation compares the underlying file paths.\n\t * @see #getPath()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code of the underlying file path.\r\n * @see #getPath()\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.path.hashCode();\r\n}",
    "comment": "\n\t * This implementation returns the hash code of the underlying file path.\n\t * @see #getPath()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResourceLoader",
    "entityType": "class",
    "code": "/**\r\n * Resolve resource paths as file system paths.\r\n * <p>Note: Even if a given path starts with a slash, it will get\r\n * interpreted as relative to the current VM working directory.\r\n * @param path the path to the resource\r\n * @return the corresponding Resource handle\r\n * @see FileSystemResource\r\n * @see org.springframework.web.context.support.ServletContextResourceLoader#getResourceByPath\r\n */\r\n@Override\r\nprotected Resource getResourceByPath(String path) {\r\n    if (path.startsWith(\"/\")) {\r\n        path = path.substring(1);\r\n    }\r\n    return new FileSystemContextResource(path);\r\n}\n/**\r\n * FileSystemResource that explicitly expresses a context-relative path\r\n * through implementing the ContextResource interface.\r\n */\r\nprivate static class FileSystemContextResource extends FileSystemResource implements ContextResource {\r\n\r\n    public FileSystemContextResource(String path) {\r\n        super(path);\r\n    }\r\n\r\n    @Override\r\n    public String getPathWithinContext() {\r\n        return getPath();\r\n    }\r\n}",
    "comment": "\n * {@link ResourceLoader} implementation that resolves plain paths as\n * file system resources rather than as class path resources\n * (the latter is {@link DefaultResourceLoader}'s default strategy).\n *\n * <p><b>NOTE:</b> Plain paths will always be interpreted as relative\n * to the current VM working directory, even if they start with a slash.\n * (This is consistent with the semantics in a Servlet container.)\n * <b>Use an explicit \"file:\" prefix to enforce an absolute file path.</b>\n *\n * <p>{@link org.springframework.context.support.FileSystemXmlApplicationContext}\n * is a full-fledged ApplicationContext implementation that provides\n * the same resource path resolution strategy.\n *\n * @author Juergen Hoeller\n * @since 1.1.3\n * @see DefaultResourceLoader\n * @see org.springframework.context.support.FileSystemXmlApplicationContext\n "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemResourceLoader#getResourceByPath(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve resource paths as file system paths.\r\n * <p>Note: Even if a given path starts with a slash, it will get\r\n * interpreted as relative to the current VM working directory.\r\n * @param path the path to the resource\r\n * @return the corresponding Resource handle\r\n * @see FileSystemResource\r\n * @see org.springframework.web.context.support.ServletContextResourceLoader#getResourceByPath\r\n */\r\n@Override\r\nprotected Resource getResourceByPath(String path) {\r\n    if (path.startsWith(\"/\")) {\r\n        path = path.substring(1);\r\n    }\r\n    return new FileSystemContextResource(path);\r\n}",
    "comment": "\n\t * Resolve resource paths as file system paths.\n\t * <p>Note: Even if a given path starts with a slash, it will get\n\t * interpreted as relative to the current VM working directory.\n\t * @param path the path to the resource\n\t * @return the corresponding Resource handle\n\t * @see FileSystemResource\n\t * @see org.springframework.web.context.support.ServletContextResourceLoader#getResourceByPath\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemContextResource",
    "entityType": "class",
    "code": "public FileSystemContextResource(String path) {\r\n    super(path);\r\n}\n@Override\r\npublic String getPathWithinContext() {\r\n    return getPath();\r\n}",
    "comment": "\n\t * FileSystemResource that explicitly expresses a context-relative path\n\t * through implementing the ContextResource interface.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.FileSystemContextResource#getPathWithinContext()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPathWithinContext() {\r\n    return getPath();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileUrlResource",
    "entityType": "class",
    "code": "@Nullable\r\nprivate volatile File file;\n/**\r\n * Create a new {@code FileUrlResource} based on the given URL object.\r\n * <p>Note that this does not enforce \"file\" as URL protocol. If a protocol\r\n * is known to be resolvable to a file, it is acceptable for this purpose.\r\n * @param url a URL\r\n * @see ResourceUtils#isFileURL(URL)\r\n * @see #getFile()\r\n */\r\npublic FileUrlResource(URL url) {\r\n    super(url);\r\n}\n/**\r\n * Create a new {@code FileUrlResource} based on the given file location,\r\n * using the URL protocol \"file\".\r\n * <p>The given parts will automatically get encoded if necessary.\r\n * @param location the location (i.e. the file path within that protocol)\r\n * @throws MalformedURLException if the given URL specification is not valid\r\n * @see UrlResource#UrlResource(String, String)\r\n * @see ResourceUtils#URL_PROTOCOL_FILE\r\n */\r\npublic FileUrlResource(String location) throws MalformedURLException {\r\n    super(ResourceUtils.URL_PROTOCOL_FILE, location);\r\n}\n@Override\r\npublic File getFile() throws IOException {\r\n    File file = this.file;\r\n    if (file != null) {\r\n        return file;\r\n    }\r\n    file = super.getFile();\r\n    this.file = file;\r\n    return file;\r\n}\n@Override\r\npublic boolean isWritable() {\r\n    try {\r\n        File file = getFile();\r\n        return (file.canWrite() && !file.isDirectory());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\n@Override\r\npublic OutputStream getOutputStream() throws IOException {\r\n    return Files.newOutputStream(getFile().toPath());\r\n}\n@Override\r\npublic WritableByteChannel writableChannel() throws IOException {\r\n    return FileChannel.open(getFile().toPath(), StandardOpenOption.WRITE);\r\n}\n@Override\r\npublic Resource createRelative(String relativePath) throws MalformedURLException {\r\n    return new FileUrlResource(createRelativeURL(relativePath));\r\n}",
    "comment": "\n * Subclass of {@link UrlResource} which assumes file resolution, to the degree\n * of implementing the {@link WritableResource} interface for it. This resource\n * variant also caches resolved {@link File} handles from {@link #getFile()}.\n *\n * <p>This is the class resolved by {@link DefaultResourceLoader} for a \"file:...\"\n * URL location, allowing a downcast to {@link WritableResource} for it.\n *\n * <p>Alternatively, for direct construction from a {@link java.io.File} handle\n * or NIO {@link java.nio.file.Path}, consider using {@link FileSystemResource}.\n *\n * @author Juergen Hoeller\n * @since 5.0.2\n "
  },
  {
    "entityId": "org.springframework.core.io.FileUrlResource#getFile()",
    "entityType": "method",
    "code": "@Override\r\npublic File getFile() throws IOException {\r\n    File file = this.file;\r\n    if (file != null) {\r\n        return file;\r\n    }\r\n    file = super.getFile();\r\n    this.file = file;\r\n    return file;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileUrlResource#isWritable()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isWritable() {\r\n    try {\r\n        File file = getFile();\r\n        return (file.canWrite() && !file.isDirectory());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileUrlResource#getOutputStream()",
    "entityType": "method",
    "code": "@Override\r\npublic OutputStream getOutputStream() throws IOException {\r\n    return Files.newOutputStream(getFile().toPath());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileUrlResource#writableChannel()",
    "entityType": "method",
    "code": "@Override\r\npublic WritableByteChannel writableChannel() throws IOException {\r\n    return FileChannel.open(getFile().toPath(), StandardOpenOption.WRITE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.FileUrlResource#createRelative(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource createRelative(String relativePath) throws MalformedURLException {\r\n    return new FileUrlResource(createRelativeURL(relativePath));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource",
    "entityType": "class",
    "code": "private final InputStreamSource inputStreamSource;\nprivate final String description;\nprivate final Object equality;\nprivate boolean read = false;\n/**\r\n * Create a new {@code InputStreamResource} with a lazy {@code InputStream}\r\n * for single use.\r\n * @param inputStreamSource an on-demand source for a single-use InputStream\r\n * @since 6.1.7\r\n */\r\npublic InputStreamResource(InputStreamSource inputStreamSource) {\r\n    this(inputStreamSource, \"resource loaded from InputStreamSource\");\r\n}\n/**\r\n * Create a new {@code InputStreamResource} with a lazy {@code InputStream}\r\n * for single use.\r\n * @param inputStreamSource an on-demand source for a single-use InputStream\r\n * @param description where the InputStream comes from\r\n * @since 6.1.7\r\n */\r\npublic InputStreamResource(InputStreamSource inputStreamSource, @Nullable String description) {\r\n    Assert.notNull(inputStreamSource, \"InputStreamSource must not be null\");\r\n    this.inputStreamSource = inputStreamSource;\r\n    this.description = (description != null ? description : \"\");\r\n    this.equality = inputStreamSource;\r\n}\n/**\r\n * Create a new {@code InputStreamResource} for an existing {@code InputStream}.\r\n * <p>Consider retrieving the InputStream on demand if possible, reducing its\r\n * lifetime and reliably opening it and closing it through regular\r\n * {@link InputStreamSource#getInputStream()} usage.\r\n * @param inputStream the InputStream to use\r\n * @see #InputStreamResource(InputStreamSource)\r\n */\r\npublic InputStreamResource(InputStream inputStream) {\r\n    this(inputStream, \"resource loaded through InputStream\");\r\n}\n/**\r\n * Create a new {@code InputStreamResource} for an existing {@code InputStream}.\r\n * @param inputStream the InputStream to use\r\n * @param description where the InputStream comes from\r\n * @see #InputStreamResource(InputStreamSource, String)\r\n */\r\npublic InputStreamResource(InputStream inputStream, @Nullable String description) {\r\n    Assert.notNull(inputStream, \"InputStream must not be null\");\r\n    this.inputStreamSource = () -> inputStream;\r\n    this.description = (description != null ? description : \"\");\r\n    this.equality = inputStream;\r\n}\n/**\r\n * This implementation always returns {@code true}.\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return true;\r\n}\n/**\r\n * This implementation always returns {@code true}.\r\n */\r\n@Override\r\npublic boolean isOpen() {\r\n    return true;\r\n}\n/**\r\n * This implementation throws IllegalStateException if attempting to\r\n * read the underlying stream multiple times.\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException, IllegalStateException {\r\n    if (this.read) {\r\n        throw new IllegalStateException(\"InputStream has already been read (possibly for early content length \" + \"determination) - do not use InputStreamResource if a stream needs to be read multiple times\");\r\n    }\r\n    this.read = true;\r\n    return this.inputStreamSource.getInputStream();\r\n}\n/**\r\n * This implementation returns a description that includes the passed-in\r\n * description, if any.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"InputStream resource [\" + this.description + \"]\";\r\n}\n/**\r\n * This implementation compares the underlying InputStream.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof InputStreamResource that && this.equality.equals(that.equality)));\r\n}\n/**\r\n * This implementation returns the hash code of the underlying InputStream.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.equality.hashCode();\r\n}",
    "comment": "\n * {@link Resource} implementation for a given {@link InputStream} or a given\n * {@link InputStreamSource} (which can be supplied as a lambda expression)\n * for a lazy {@link InputStream} on demand.\n *\n * <p>Should only be used if no other specific {@code Resource} implementation\n * is applicable. In particular, prefer {@link ByteArrayResource} or any of the\n * file-based {@code Resource} implementations if possible. If you need to obtain\n * a custom stream multiple times, use a custom {@link AbstractResource} subclass\n * with a corresponding {@code getInputStream()} implementation.\n *\n * <p>In contrast to other {@code Resource} implementations, this is a descriptor\n * for an <i>already opened</i> resource - therefore returning {@code true} from\n * {@link #isOpen()}. Do not use an {@code InputStreamResource} if you need to keep\n * the resource descriptor somewhere, or if you need to read from a stream multiple\n * times. This also applies when constructed with an {@code InputStreamSource}\n * which lazily obtains the stream but only allows for single access as well.\n *\n * <p><b>NOTE: This class does not provide an independent {@link #contentLength()}\n * implementation: Any such call will consume the given {@code InputStream}!</b>\n * Consider overriding {@code #contentLength()} with a custom implementation if\n * possible. For any other purpose, it is not recommended to extend from this\n * class; this is particularly true when used with Spring's web resource rendering\n * which specifically skips {@code #contentLength()} for this exact class only.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n * @see ByteArrayResource\n * @see ClassPathResource\n * @see FileSystemResource\n * @see UrlResource\n "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource#exists()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code true}.\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return true;\r\n}",
    "comment": "\n\t * This implementation always returns {@code true}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource#isOpen()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code true}.\r\n */\r\n@Override\r\npublic boolean isOpen() {\r\n    return true;\r\n}",
    "comment": "\n\t * This implementation always returns {@code true}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws IllegalStateException if attempting to\r\n * read the underlying stream multiple times.\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException, IllegalStateException {\r\n    if (this.read) {\r\n        throw new IllegalStateException(\"InputStream has already been read (possibly for early content length \" + \"determination) - do not use InputStreamResource if a stream needs to be read multiple times\");\r\n    }\r\n    this.read = true;\r\n    return this.inputStreamSource.getInputStream();\r\n}",
    "comment": "\n\t * This implementation throws IllegalStateException if attempting to\n\t * read the underlying stream multiple times.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource#getDescription()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a description that includes the passed-in\r\n * description, if any.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"InputStream resource [\" + this.description + \"]\";\r\n}",
    "comment": "\n\t * This implementation returns a description that includes the passed-in\n\t * description, if any.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying InputStream.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof InputStreamResource that && this.equality.equals(that.equality)));\r\n}",
    "comment": "\n\t * This implementation compares the underlying InputStream.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code of the underlying InputStream.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.equality.hashCode();\r\n}",
    "comment": "\n\t * This implementation returns the hash code of the underlying InputStream.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamSource",
    "entityType": "class",
    "code": "/**\r\n * Return an {@link InputStream} for the content of an underlying resource.\r\n * <p>It is usually expected that every such call creates a <i>fresh</i> stream.\r\n * <p>This requirement is particularly important when you consider an API such\r\n * as JavaMail, which needs to be able to read the stream multiple times when\r\n * creating mail attachments. For such a use case, it is <i>required</i>\r\n * that each {@code getInputStream()} call returns a fresh stream.\r\n * @return the input stream for the underlying resource (must not be {@code null})\r\n * @throws java.io.FileNotFoundException if the underlying resource does not exist\r\n * @throws IOException if the content stream could not be opened\r\n * @see Resource#isReadable()\r\n * @see Resource#isOpen()\r\n */\r\nInputStream getInputStream() throws IOException;",
    "comment": "\n * Simple interface for objects that are sources for an {@link InputStream}.\n *\n * <p>This is the base interface for Spring's more extensive {@link Resource} interface.\n *\n * <p>For single-use streams, {@link InputStreamResource} can be used for any\n * given {@code InputStream}. Spring's {@link ByteArrayResource} or any\n * file-based {@code Resource} implementation can be used as a concrete\n * instance, allowing one to read the underlying content stream multiple times.\n * This makes this interface useful as an abstract content source for mail\n * attachments, for example.\n *\n * @author Juergen Hoeller\n * @since 20.01.2004\n * @see java.io.InputStream\n * @see Resource\n * @see InputStreamResource\n * @see ByteArrayResource\n "
  },
  {
    "entityId": "org.springframework.core.io.InputStreamSource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * Return an {@link InputStream} for the content of an underlying resource.\r\n * <p>It is usually expected that every such call creates a <i>fresh</i> stream.\r\n * <p>This requirement is particularly important when you consider an API such\r\n * as JavaMail, which needs to be able to read the stream multiple times when\r\n * creating mail attachments. For such a use case, it is <i>required</i>\r\n * that each {@code getInputStream()} call returns a fresh stream.\r\n * @return the input stream for the underlying resource (must not be {@code null})\r\n * @throws java.io.FileNotFoundException if the underlying resource does not exist\r\n * @throws IOException if the content stream could not be opened\r\n * @see Resource#isReadable()\r\n * @see Resource#isOpen()\r\n */\r\nInputStream getInputStream() throws IOException;",
    "comment": "\n\t * Return an {@link InputStream} for the content of an underlying resource.\n\t * <p>It is usually expected that every such call creates a <i>fresh</i> stream.\n\t * <p>This requirement is particularly important when you consider an API such\n\t * as JavaMail, which needs to be able to read the stream multiple times when\n\t * creating mail attachments. For such a use case, it is <i>required</i>\n\t * that each {@code getInputStream()} call returns a fresh stream.\n\t * @return the input stream for the underlying resource (must not be {@code null})\n\t * @throws java.io.FileNotFoundException if the underlying resource does not exist\n\t * @throws IOException if the content stream could not be opened\n\t * @see Resource#isReadable()\n\t * @see Resource#isOpen()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource",
    "entityType": "class",
    "code": "private final Module module;\nprivate final String path;\n/**\r\n * Create a new {@code ModuleResource} for the given {@link Module}\r\n * and the given resource path.\r\n * @param module the runtime module to search within\r\n * @param path the resource path within the module\r\n */\r\npublic ModuleResource(Module module, String path) {\r\n    Assert.notNull(module, \"Module must not be null\");\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    this.module = module;\r\n    this.path = path;\r\n}\n/**\r\n * Return the {@link Module} for this resource.\r\n */\r\npublic final Module getModule() {\r\n    return this.module;\r\n}\n/**\r\n * Return the path for this resource.\r\n */\r\npublic final String getPath() {\r\n    return this.path;\r\n}\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    InputStream is = this.module.getResourceAsStream(this.path);\r\n    if (is == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\r\n    }\r\n    return is;\r\n}\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return new ModuleResource(this.module, pathToUse);\r\n}\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    return StringUtils.getFilename(this.path);\r\n}\n@Override\r\npublic String getDescription() {\r\n    return \"module resource [\" + this.path + \"]\" + (this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\r\n}\n@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    return (this == obj || (obj instanceof ModuleResource that && this.module.equals(that.module) && this.path.equals(that.path)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.module.hashCode() * 31 + this.path.hashCode();\r\n}",
    "comment": "\n * {@link Resource} implementation for {@link java.lang.Module} resolution,\n * performing {@link #getInputStream()} access via {@link Module#getResourceAsStream}.\n *\n * <p>Alternatively, consider accessing resources in a module path layout via\n * {@link ClassPathResource} for exported resources, or specifically relative to\n * a {@code Class} via {@link ClassPathResource#ClassPathResource(String, Class)}\n * for local resolution within the containing module of that specific class.\n * In common scenarios, module resources will simply be transparently visible as\n * classpath resources and therefore do not need any special treatment at all.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 6.1\n * @see Module#getResourceAsStream\n * @see ClassPathResource\n "
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#getModule()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link Module} for this resource.\r\n */\r\npublic final Module getModule() {\r\n    return this.module;\r\n}",
    "comment": "\n\t * Return the {@link Module} for this resource.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#getPath()",
    "entityType": "method",
    "code": "/**\r\n * Return the path for this resource.\r\n */\r\npublic final String getPath() {\r\n    return this.path;\r\n}",
    "comment": "\n\t * Return the path for this resource.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#getInputStream()",
    "entityType": "method",
    "code": "@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    InputStream is = this.module.getResourceAsStream(this.path);\r\n    if (is == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\r\n    }\r\n    return is;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#createRelative(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return new ModuleResource(this.module, pathToUse);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#getFilename()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    return StringUtils.getFilename(this.path);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#getDescription()",
    "entityType": "method",
    "code": "@Override\r\npublic String getDescription() {\r\n    return \"module resource [\" + this.path + \"]\" + (this.module.isNamed() ? \" from module [\" + this.module.getName() + \"]\" : \"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    return (this == obj || (obj instanceof ModuleResource that && this.module.equals(that.module) && this.path.equals(that.path)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ModuleResource#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.module.hashCode() * 31 + this.path.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.PathResource",
    "entityType": "class",
    "code": "private final Path path;\n/**\r\n * Create a new {@code PathResource} from a {@link Path} handle.\r\n * <p>Note: Unlike {@link FileSystemResource}, when building relative resources\r\n * via {@link #createRelative}, the relative path will be built <i>underneath</i>\r\n * the given root: for example, Paths.get(\"C:/dir1/\"), relative path \"dir2\" &rarr; \"C:/dir1/dir2\"!\r\n * @param path a Path handle\r\n */\r\npublic PathResource(Path path) {\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    this.path = path.normalize();\r\n}\n/**\r\n * Create a new {@code PathResource} from a path string.\r\n * <p>Note: Unlike {@link FileSystemResource}, when building relative resources\r\n * via {@link #createRelative}, the relative path will be built <i>underneath</i>\r\n * the given root: for example, Paths.get(\"C:/dir1/\"), relative path \"dir2\" &rarr; \"C:/dir1/dir2\"!\r\n * @param path a path\r\n * @see java.nio.file.Paths#get(String, String...)\r\n */\r\npublic PathResource(String path) {\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    this.path = Paths.get(path).normalize();\r\n}\n/**\r\n * Create a new {@code PathResource} from a {@link URI}.\r\n * <p>Note: Unlike {@link FileSystemResource}, when building relative resources\r\n * via {@link #createRelative}, the relative path will be built <i>underneath</i>\r\n * the given root: for example, Paths.get(\"C:/dir1/\"), relative path \"dir2\" &rarr; \"C:/dir1/dir2\"!\r\n * @param uri a path URI\r\n * @see java.nio.file.Paths#get(URI)\r\n */\r\npublic PathResource(URI uri) {\r\n    Assert.notNull(uri, \"URI must not be null\");\r\n    this.path = Paths.get(uri).normalize();\r\n}\n/**\r\n * Return the file path for this resource.\r\n */\r\npublic final String getPath() {\r\n    return this.path.toString();\r\n}\n/**\r\n * This implementation returns whether the underlying file exists.\r\n * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return Files.exists(this.path);\r\n}\n/**\r\n * This implementation checks whether the underlying file is marked as readable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.nio.file.Files#isReadable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    return (Files.isReadable(this.path) && !Files.isDirectory(this.path));\r\n}\n/**\r\n * This implementation opens an {@link InputStream} for the underlying file.\r\n * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    if (!exists()) {\r\n        throw new FileNotFoundException(getPath() + \" (no such file or directory)\");\r\n    }\r\n    if (Files.isDirectory(this.path)) {\r\n        throw new FileNotFoundException(getPath() + \" (is a directory)\");\r\n    }\r\n    return Files.newInputStream(this.path);\r\n}\n@Override\r\npublic byte[] getContentAsByteArray() throws IOException {\r\n    try {\r\n        return Files.readAllBytes(this.path);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n@Override\r\npublic String getContentAsString(Charset charset) throws IOException {\r\n    try {\r\n        return Files.readString(this.path, charset);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n/**\r\n * This implementation checks whether the underlying file is marked as writable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.nio.file.Files#isWritable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isWritable() {\r\n    return (Files.isWritable(this.path) && !Files.isDirectory(this.path));\r\n}\n/**\r\n * This implementation opens an {@link OutputStream} for the underlying file.\r\n * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)\r\n */\r\n@Override\r\npublic OutputStream getOutputStream() throws IOException {\r\n    if (Files.isDirectory(this.path)) {\r\n        throw new FileNotFoundException(getPath() + \" (is a directory)\");\r\n    }\r\n    return Files.newOutputStream(this.path);\r\n}\n/**\r\n * This implementation returns a {@link URL} for the underlying file.\r\n * @see java.nio.file.Path#toUri()\r\n * @see java.net.URI#toURL()\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    return this.path.toUri().toURL();\r\n}\n/**\r\n * This implementation returns a {@link URI} for the underlying file.\r\n * @see java.nio.file.Path#toUri()\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    return this.path.toUri();\r\n}\n/**\r\n * This implementation always indicates a file.\r\n */\r\n@Override\r\npublic boolean isFile() {\r\n    return true;\r\n}\n/**\r\n * This implementation returns the underlying {@link File} reference.\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    try {\r\n        return this.path.toFile();\r\n    } catch (UnsupportedOperationException ex) {\r\n        // Only paths on the default file system can be converted to a File:\r\n        // Do exception translation for cases where conversion is not possible.\r\n        throw new FileNotFoundException(this.path + \" cannot be resolved to absolute file path\");\r\n    }\r\n}\n/**\r\n * This implementation opens a {@link ReadableByteChannel} for the underlying file.\r\n * @see Files#newByteChannel(Path, OpenOption...)\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    try {\r\n        return Files.newByteChannel(this.path, StandardOpenOption.READ);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}\n/**\r\n * This implementation opens a {@link WritableByteChannel} for the underlying file.\r\n * @see Files#newByteChannel(Path, OpenOption...)\r\n */\r\n@Override\r\npublic WritableByteChannel writableChannel() throws IOException {\r\n    return Files.newByteChannel(this.path, StandardOpenOption.WRITE);\r\n}\n/**\r\n * This implementation returns the underlying file's length.\r\n */\r\n@Override\r\npublic long contentLength() throws IOException {\r\n    return Files.size(this.path);\r\n}\n/**\r\n * This implementation returns the underlying file's timestamp.\r\n * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic long lastModified() throws IOException {\r\n    // We can not use the superclass method since it uses conversion to a File and\r\n    // only a Path on the default file system can be converted to a File...\r\n    return Files.getLastModifiedTime(this.path).toMillis();\r\n}\n/**\r\n * This implementation creates a {@link PathResource}, applying the given path\r\n * relative to the path of the underlying file of this resource descriptor.\r\n * @see java.nio.file.Path#resolve(String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    return new PathResource(this.path.resolve(relativePath));\r\n}\n/**\r\n * This implementation returns the name of the file.\r\n * @see java.nio.file.Path#getFileName()\r\n */\r\n@Override\r\npublic String getFilename() {\r\n    return this.path.getFileName().toString();\r\n}\n@Override\r\npublic String getDescription() {\r\n    return \"path [\" + this.path.toAbsolutePath() + \"]\";\r\n}\n/**\r\n * This implementation compares the underlying {@link Path} references.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof PathResource that && this.path.equals(that.path)));\r\n}\n/**\r\n * This implementation returns the hash code of the underlying {@link Path} reference.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.path.hashCode();\r\n}",
    "comment": "\n * {@link Resource} implementation for {@link java.nio.file.Path} handles,\n * performing all operations and transformations via the {@code Path} API.\n * Supports resolution as a {@link File} and also as a {@link URL}.\n * Implements the extended {@link WritableResource} interface.\n *\n * <p>Note: As of 5.1, {@link java.nio.file.Path} support is also available\n * in {@link FileSystemResource#FileSystemResource(Path) FileSystemResource},\n * applying Spring's standard String-based path transformations but\n * performing all operations via the {@link java.nio.file.Files} API.\n * This {@code PathResource} is effectively a pure {@code java.nio.path.Path}\n * based alternative with different {@code createRelative} behavior.\n *\n * @author Philippe Marschall\n * @author Juergen Hoeller\n * @since 4.0\n * @see java.nio.file.Path\n * @see java.nio.file.Files\n * @see FileSystemResource\n * @deprecated since 7.0 in favor of {@link FileSystemResource}\n "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getPath()",
    "entityType": "method",
    "code": "/**\r\n * Return the file path for this resource.\r\n */\r\npublic final String getPath() {\r\n    return this.path.toString();\r\n}",
    "comment": "\n\t * Return the file path for this resource.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#exists()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns whether the underlying file exists.\r\n * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return Files.exists(this.path);\r\n}",
    "comment": "\n\t * This implementation returns whether the underlying file exists.\n\t * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#isReadable()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks whether the underlying file is marked as readable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.nio.file.Files#isReadable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    return (Files.isReadable(this.path) && !Files.isDirectory(this.path));\r\n}",
    "comment": "\n\t * This implementation checks whether the underlying file is marked as readable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.nio.file.Files#isReadable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens an {@link InputStream} for the underlying file.\r\n * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    if (!exists()) {\r\n        throw new FileNotFoundException(getPath() + \" (no such file or directory)\");\r\n    }\r\n    if (Files.isDirectory(this.path)) {\r\n        throw new FileNotFoundException(getPath() + \" (is a directory)\");\r\n    }\r\n    return Files.newInputStream(this.path);\r\n}",
    "comment": "\n\t * This implementation opens an {@link InputStream} for the underlying file.\n\t * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getContentAsByteArray()",
    "entityType": "method",
    "code": "@Override\r\npublic byte[] getContentAsByteArray() throws IOException {\r\n    try {\r\n        return Files.readAllBytes(this.path);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getContentAsString(Charset)",
    "entityType": "method",
    "code": "@Override\r\npublic String getContentAsString(Charset charset) throws IOException {\r\n    try {\r\n        return Files.readString(this.path, charset);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.PathResource#isWritable()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks whether the underlying file is marked as writable\r\n * (and corresponds to an actual file with content, not to a directory).\r\n * @see java.nio.file.Files#isWritable(Path)\r\n * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic boolean isWritable() {\r\n    return (Files.isWritable(this.path) && !Files.isDirectory(this.path));\r\n}",
    "comment": "\n\t * This implementation checks whether the underlying file is marked as writable\n\t * (and corresponds to an actual file with content, not to a directory).\n\t * @see java.nio.file.Files#isWritable(Path)\n\t * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getOutputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens an {@link OutputStream} for the underlying file.\r\n * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)\r\n */\r\n@Override\r\npublic OutputStream getOutputStream() throws IOException {\r\n    if (Files.isDirectory(this.path)) {\r\n        throw new FileNotFoundException(getPath() + \" (is a directory)\");\r\n    }\r\n    return Files.newOutputStream(this.path);\r\n}",
    "comment": "\n\t * This implementation opens an {@link OutputStream} for the underlying file.\n\t * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getURL()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a {@link URL} for the underlying file.\r\n * @see java.nio.file.Path#toUri()\r\n * @see java.net.URI#toURL()\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    return this.path.toUri().toURL();\r\n}",
    "comment": "\n\t * This implementation returns a {@link URL} for the underlying file.\n\t * @see java.nio.file.Path#toUri()\n\t * @see java.net.URI#toURL()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getURI()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a {@link URI} for the underlying file.\r\n * @see java.nio.file.Path#toUri()\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    return this.path.toUri();\r\n}",
    "comment": "\n\t * This implementation returns a {@link URI} for the underlying file.\n\t * @see java.nio.file.Path#toUri()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#isFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always indicates a file.\r\n */\r\n@Override\r\npublic boolean isFile() {\r\n    return true;\r\n}",
    "comment": "\n\t * This implementation always indicates a file.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying {@link File} reference.\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    try {\r\n        return this.path.toFile();\r\n    } catch (UnsupportedOperationException ex) {\r\n        // Only paths on the default file system can be converted to a File:\r\n        // Do exception translation for cases where conversion is not possible.\r\n        throw new FileNotFoundException(this.path + \" cannot be resolved to absolute file path\");\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns the underlying {@link File} reference.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#readableChannel()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens a {@link ReadableByteChannel} for the underlying file.\r\n * @see Files#newByteChannel(Path, OpenOption...)\r\n */\r\n@Override\r\npublic ReadableByteChannel readableChannel() throws IOException {\r\n    try {\r\n        return Files.newByteChannel(this.path, StandardOpenOption.READ);\r\n    } catch (NoSuchFileException ex) {\r\n        throw new FileNotFoundException(ex.getMessage());\r\n    }\r\n}",
    "comment": "\n\t * This implementation opens a {@link ReadableByteChannel} for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#writableChannel()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens a {@link WritableByteChannel} for the underlying file.\r\n * @see Files#newByteChannel(Path, OpenOption...)\r\n */\r\n@Override\r\npublic WritableByteChannel writableChannel() throws IOException {\r\n    return Files.newByteChannel(this.path, StandardOpenOption.WRITE);\r\n}",
    "comment": "\n\t * This implementation opens a {@link WritableByteChannel} for the underlying file.\n\t * @see Files#newByteChannel(Path, OpenOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#contentLength()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying file's length.\r\n */\r\n@Override\r\npublic long contentLength() throws IOException {\r\n    return Files.size(this.path);\r\n}",
    "comment": "\n\t * This implementation returns the underlying file's length.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#lastModified()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying file's timestamp.\r\n * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)\r\n */\r\n@Override\r\npublic long lastModified() throws IOException {\r\n    // We can not use the superclass method since it uses conversion to a File and\r\n    // only a Path on the default file system can be converted to a File...\r\n    return Files.getLastModifiedTime(this.path).toMillis();\r\n}",
    "comment": "\n\t * This implementation returns the underlying file's timestamp.\n\t * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#createRelative(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation creates a {@link PathResource}, applying the given path\r\n * relative to the path of the underlying file of this resource descriptor.\r\n * @see java.nio.file.Path#resolve(String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    return new PathResource(this.path.resolve(relativePath));\r\n}",
    "comment": "\n\t * This implementation creates a {@link PathResource}, applying the given path\n\t * relative to the path of the underlying file of this resource descriptor.\n\t * @see java.nio.file.Path#resolve(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getFilename()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the name of the file.\r\n * @see java.nio.file.Path#getFileName()\r\n */\r\n@Override\r\npublic String getFilename() {\r\n    return this.path.getFileName().toString();\r\n}",
    "comment": "\n\t * This implementation returns the name of the file.\n\t * @see java.nio.file.Path#getFileName()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#getDescription()",
    "entityType": "method",
    "code": "@Override\r\npublic String getDescription() {\r\n    return \"path [\" + this.path.toAbsolutePath() + \"]\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.PathResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying {@link Path} references.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof PathResource that && this.path.equals(that.path)));\r\n}",
    "comment": "\n\t * This implementation compares the underlying {@link Path} references.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.PathResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code of the underlying {@link Path} reference.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.path.hashCode();\r\n}",
    "comment": "\n\t * This implementation returns the hash code of the underlying {@link Path} reference.\n\t "
  }
]