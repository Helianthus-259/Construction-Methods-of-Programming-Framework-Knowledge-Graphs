[
  {
    "entityId": "org.springframework.util.FilteredMap#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    return new FilteredSet<>(this.delegate.entrySet(), entry -> this.filter.test(entry.getKey()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    int size = 0;\r\n    for (K k : keySet()) {\r\n        if (this.filter.test(k)) {\r\n            size++;\r\n        }\r\n    }\r\n    return size;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean containsKey(Object key) {\r\n    if (this.delegate.containsKey(key)) {\r\n        return this.filter.test((K) key);\r\n    } else {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic V get(Object key) {\r\n    V value = this.delegate.get(key);\r\n    if (value != null && this.filter.test((K) key)) {\r\n        return value;\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#put(K,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V put(K key, V value) {\r\n    V oldValue = this.delegate.put(key, value);\r\n    if (oldValue != null && this.filter.test(key)) {\r\n        return oldValue;\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic V remove(Object key) {\r\n    V oldValue = this.delegate.remove(key);\r\n    if (oldValue != null && this.filter.test((K) key)) {\r\n        return oldValue;\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.delegate.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap#keySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<K> keySet() {\r\n    return new FilteredSet<>(this.delegate.keySet(), this.filter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredSet",
    "entityType": "class",
    "code": "public FilteredSet(Set<E> delegate, Predicate<E> filter) {\r\n    super(delegate, filter);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Set<?> otherSet && size() == otherSet.size()) {\r\n        try {\r\n            return containsAll(otherSet);\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic int hashCode() {\r\n    int hashCode = 0;\r\n    for (E obj : this) {\r\n        if (obj != null) {\r\n            hashCode += obj.hashCode();\r\n        }\r\n    }\r\n    return hashCode;\r\n}",
    "comment": "\n * Set that filters out values that do not match a predicate.\n * This type is used by {@link CompositeMap}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <E> the type of elements maintained by this set\n "
  },
  {
    "entityId": "org.springframework.util.FilteredSet#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Set<?> otherSet && size() == otherSet.size()) {\r\n        try {\r\n            return containsAll(otherSet);\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredSet#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    int hashCode = 0;\r\n    for (E obj : this) {\r\n        if (obj != null) {\r\n            hashCode += obj.hashCode();\r\n        }\r\n    }\r\n    return hashCode;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Supplier<? extends @Nullable T> instanceSupplier;\n@Nullable\r\nprivate final Supplier<? extends @Nullable T> defaultSupplier;\n@Nullable\r\nprivate volatile T singletonInstance;\n/**\r\n * Guards access to write operations on the {@code singletonInstance} field.\r\n */\r\nprivate final Lock writeLock = new ReentrantLock();\n/**\r\n * Build a {@code SingletonSupplier} with the given singleton instance\r\n * and a default supplier for the case when the instance is {@code null}.\r\n * @param instance the singleton instance (potentially {@code null})\r\n * @param defaultSupplier the default supplier as a fallback\r\n */\r\npublic SingletonSupplier(@Nullable T instance, Supplier<? extends @Nullable T> defaultSupplier) {\r\n    this.instanceSupplier = null;\r\n    this.defaultSupplier = defaultSupplier;\r\n    this.singletonInstance = instance;\r\n}\n/**\r\n * Build a {@code SingletonSupplier} with the given instance supplier\r\n * and a default supplier for the case when the instance is {@code null}.\r\n * @param instanceSupplier the immediate instance supplier\r\n * @param defaultSupplier the default supplier as a fallback\r\n */\r\npublic SingletonSupplier(@Nullable Supplier<? extends @Nullable T> instanceSupplier, Supplier<? extends @Nullable T> defaultSupplier) {\r\n    this.instanceSupplier = instanceSupplier;\r\n    this.defaultSupplier = defaultSupplier;\r\n}\nprivate SingletonSupplier(Supplier<? extends @Nullable T> supplier) {\r\n    this.instanceSupplier = supplier;\r\n    this.defaultSupplier = null;\r\n}\nprivate SingletonSupplier(@Nullable T singletonInstance) {\r\n    this.instanceSupplier = null;\r\n    this.defaultSupplier = null;\r\n    this.singletonInstance = singletonInstance;\r\n}\n/**\r\n * Get the shared singleton instance for this supplier.\r\n * @return the singleton instance (or {@code null} if none)\r\n */\r\n@Override\r\n@Nullable\r\npublic T get() {\r\n    T instance = this.singletonInstance;\r\n    if (instance == null) {\r\n        this.writeLock.lock();\r\n        try {\r\n            instance = this.singletonInstance;\r\n            if (instance == null) {\r\n                if (this.instanceSupplier != null) {\r\n                    instance = this.instanceSupplier.get();\r\n                }\r\n                if (instance == null && this.defaultSupplier != null) {\r\n                    instance = this.defaultSupplier.get();\r\n                }\r\n                this.singletonInstance = instance;\r\n            }\r\n        } finally {\r\n            this.writeLock.unlock();\r\n        }\r\n    }\r\n    return instance;\r\n}\n/**\r\n * Obtain the shared singleton instance for this supplier.\r\n * @return the singleton instance (never {@code null})\r\n * @throws IllegalStateException in case of no instance\r\n */\r\npublic T obtain() {\r\n    T instance = get();\r\n    Assert.state(instance != null, \"No instance from Supplier\");\r\n    return instance;\r\n}\n/**\r\n * Build a {@code SingletonSupplier} with the given singleton instance.\r\n * @param instance the singleton instance (never {@code null})\r\n * @return the singleton supplier (never {@code null})\r\n */\r\npublic static <T> SingletonSupplier<T> of(T instance) {\r\n    return new SingletonSupplier<>(instance);\r\n}\n/**\r\n * Build a {@code SingletonSupplier} with the given singleton instance.\r\n * @param instance the singleton instance (potentially {@code null})\r\n * @return the singleton supplier, or {@code null} if the instance was {@code null}\r\n */\r\n@Contract(\"null -> null; !null -> !null\")\r\n@Nullable\r\npublic static <T> SingletonSupplier<T> ofNullable(@Nullable T instance) {\r\n    return (instance != null ? new SingletonSupplier<>(instance) : null);\r\n}\n/**\r\n * Build a {@code SingletonSupplier} with the given supplier.\r\n * @param supplier the instance supplier (never {@code null})\r\n * @return the singleton supplier (never {@code null})\r\n */\r\npublic static <T> SingletonSupplier<T> of(Supplier<T> supplier) {\r\n    return new SingletonSupplier<>(supplier);\r\n}\n/**\r\n * Build a {@code SingletonSupplier} with the given supplier.\r\n * @param supplier the instance supplier (potentially {@code null})\r\n * @return the singleton supplier, or {@code null} if the instance supplier was {@code null}\r\n */\r\n@Contract(\"null -> null; !null -> !null\")\r\n@Nullable\r\npublic static <T> SingletonSupplier<T> ofNullable(@Nullable Supplier<? extends @Nullable T> supplier) {\r\n    return (supplier != null ? new SingletonSupplier<>(supplier) : null);\r\n}",
    "comment": "\n * A {@link java.util.function.Supplier} decorator that caches a singleton result and\n * makes it available from {@link #get()} (nullable) and {@link #obtain()} (null-safe).\n *\n * <p>A {@code SingletonSupplier} can be constructed via {@code of} factory methods\n * or via constructors that provide a default supplier as a fallback. This is\n * particularly useful for method reference suppliers, falling back to a default\n * supplier for a method that returned {@code null} and caching the result.\n *\n * @author Juergen Hoeller\n * @author Yanming Zhou\n * @since 5.1\n * @param <T> the type of results supplied by this supplier\n "
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier#get()",
    "entityType": "method",
    "code": "/**\r\n * Get the shared singleton instance for this supplier.\r\n * @return the singleton instance (or {@code null} if none)\r\n */\r\n@Override\r\n@Nullable\r\npublic T get() {\r\n    T instance = this.singletonInstance;\r\n    if (instance == null) {\r\n        this.writeLock.lock();\r\n        try {\r\n            instance = this.singletonInstance;\r\n            if (instance == null) {\r\n                if (this.instanceSupplier != null) {\r\n                    instance = this.instanceSupplier.get();\r\n                }\r\n                if (instance == null && this.defaultSupplier != null) {\r\n                    instance = this.defaultSupplier.get();\r\n                }\r\n                this.singletonInstance = instance;\r\n            }\r\n        } finally {\r\n            this.writeLock.unlock();\r\n        }\r\n    }\r\n    return instance;\r\n}",
    "comment": "\n\t * Get the shared singleton instance for this supplier.\n\t * @return the singleton instance (or {@code null} if none)\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier#obtain()",
    "entityType": "method",
    "code": "/**\r\n * Obtain the shared singleton instance for this supplier.\r\n * @return the singleton instance (never {@code null})\r\n * @throws IllegalStateException in case of no instance\r\n */\r\npublic T obtain() {\r\n    T instance = get();\r\n    Assert.state(instance != null, \"No instance from Supplier\");\r\n    return instance;\r\n}",
    "comment": "\n\t * Obtain the shared singleton instance for this supplier.\n\t * @return the singleton instance (never {@code null})\n\t * @throws IllegalStateException in case of no instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier#of(T)",
    "entityType": "method",
    "code": "/**\r\n * Build a {@code SingletonSupplier} with the given singleton instance.\r\n * @param instance the singleton instance (never {@code null})\r\n * @return the singleton supplier (never {@code null})\r\n */\r\npublic static <T> SingletonSupplier<T> of(T instance) {\r\n    return new SingletonSupplier<>(instance);\r\n}",
    "comment": "\n\t * Build a {@code SingletonSupplier} with the given singleton instance.\n\t * @param instance the singleton instance (never {@code null})\n\t * @return the singleton supplier (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
    "entityType": "method",
    "code": "/**\r\n * Build a {@code SingletonSupplier} with the given singleton instance.\r\n * @param instance the singleton instance (potentially {@code null})\r\n * @return the singleton supplier, or {@code null} if the instance was {@code null}\r\n */\r\n@Contract(\"null -> null; !null -> !null\")\r\n@Nullable\r\npublic static <T> SingletonSupplier<T> ofNullable(@Nullable T instance) {\r\n    return (instance != null ? new SingletonSupplier<>(instance) : null);\r\n}",
    "comment": "\n\t * Build a {@code SingletonSupplier} with the given singleton instance.\n\t * @param instance the singleton instance (potentially {@code null})\n\t * @return the singleton supplier, or {@code null} if the instance was {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier#of(Supplier<T>)",
    "entityType": "method",
    "code": "/**\r\n * Build a {@code SingletonSupplier} with the given supplier.\r\n * @param supplier the instance supplier (never {@code null})\r\n * @return the singleton supplier (never {@code null})\r\n */\r\npublic static <T> SingletonSupplier<T> of(Supplier<T> supplier) {\r\n    return new SingletonSupplier<>(supplier);\r\n}",
    "comment": "\n\t * Build a {@code SingletonSupplier} with the given supplier.\n\t * @param supplier the instance supplier (never {@code null})\n\t * @return the singleton supplier (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
    "entityType": "method",
    "code": "/**\r\n * Build a {@code SingletonSupplier} with the given supplier.\r\n * @param supplier the instance supplier (potentially {@code null})\r\n * @return the singleton supplier, or {@code null} if the instance supplier was {@code null}\r\n */\r\n@Contract(\"null -> null; !null -> !null\")\r\n@Nullable\r\npublic static <T> SingletonSupplier<T> ofNullable(@Nullable Supplier<? extends @Nullable T> supplier) {\r\n    return (supplier != null ? new SingletonSupplier<>(supplier) : null);\r\n}",
    "comment": "\n\t * Build a {@code SingletonSupplier} with the given supplier.\n\t * @param supplier the instance supplier (potentially {@code null})\n\t * @return the singleton supplier, or {@code null} if the instance supplier was {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SupplierUtils",
    "entityType": "class",
    "code": "/**\r\n * Resolve the given {@code Supplier}, getting its result or immediately\r\n * returning {@code null} if the supplier itself was {@code null}.\r\n * @param supplier the supplier to resolve\r\n * @return the supplier's result, or {@code null} if none\r\n */\r\n@Contract(\"null -> null; !null -> !null\")\r\n@Nullable\r\npublic static <T> T resolve(@Nullable Supplier<T> supplier) {\r\n    return (supplier != null ? supplier.get() : null);\r\n}\n/**\r\n * Resolve a given {@code Supplier}, getting its result or immediately\r\n * returning the given Object as-is if not a {@code Supplier}.\r\n * @param candidate the candidate to resolve (potentially a {@code Supplier})\r\n * @return a supplier's result or the given Object as-is\r\n * @since 6.1.4\r\n */\r\n@Nullable\r\npublic static Object resolve(@Nullable Object candidate) {\r\n    return (candidate instanceof Supplier<?> supplier ? supplier.get() : candidate);\r\n}",
    "comment": "\n * Convenience utilities for {@link java.util.function.Supplier} handling.\n *\n * @author Juergen Hoeller\n * @since 5.1\n * @see SingletonSupplier\n "
  },
  {
    "entityId": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given {@code Supplier}, getting its result or immediately\r\n * returning {@code null} if the supplier itself was {@code null}.\r\n * @param supplier the supplier to resolve\r\n * @return the supplier's result, or {@code null} if none\r\n */\r\n@Contract(\"null -> null; !null -> !null\")\r\n@Nullable\r\npublic static <T> T resolve(@Nullable Supplier<T> supplier) {\r\n    return (supplier != null ? supplier.get() : null);\r\n}",
    "comment": "\n\t * Resolve the given {@code Supplier}, getting its result or immediately\n\t * returning {@code null} if the supplier itself was {@code null}.\n\t * @param supplier the supplier to resolve\n\t * @return the supplier's result, or {@code null} if none\n\t "
  },
  {
    "entityId": "org.springframework.util.function.SupplierUtils#resolve(Object)",
    "entityType": "method",
    "code": "/**\r\n * Resolve a given {@code Supplier}, getting its result or immediately\r\n * returning the given Object as-is if not a {@code Supplier}.\r\n * @param candidate the candidate to resolve (potentially a {@code Supplier})\r\n * @return a supplier's result or the given Object as-is\r\n * @since 6.1.4\r\n */\r\n@Nullable\r\npublic static Object resolve(@Nullable Object candidate) {\r\n    return (candidate instanceof Supplier<?> supplier ? supplier.get() : candidate);\r\n}",
    "comment": "\n\t * Resolve a given {@code Supplier}, getting its result or immediately\n\t * returning the given Object as-is if not a {@code Supplier}.\n\t * @param candidate the candidate to resolve (potentially a {@code Supplier})\n\t * @return a supplier's result or the given Object as-is\n\t * @since 6.1.4\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction",
    "entityType": "class",
    "code": "/**\r\n * Applies this function to the given argument, possibly throwing a checked\r\n * exception.\r\n * @param t the first function argument\r\n * @param u the second function argument\r\n * @return the function result\r\n * @throws Exception on error\r\n */\r\nR applyWithException(T t, U u) throws Exception;\n/**\r\n * Default {@link BiFunction#apply(Object, Object)} that wraps any thrown\r\n * checked exceptions (by default in a {@link RuntimeException}).\r\n * @param t the first function argument\r\n * @param u the second function argument\r\n * @return the function result\r\n * @see java.util.function.BiFunction#apply(Object, Object)\r\n */\r\n@Override\r\ndefault R apply(T t, U u) {\r\n    return apply(t, u, RuntimeException::new);\r\n}\n/**\r\n * Applies this function to the given argument, wrapping any thrown checked\r\n * exceptions using the given {@code exceptionWrapper}.\r\n * @param t the first function argument\r\n * @param u the second function argument\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return a result\r\n */\r\ndefault R apply(T t, U u, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        return applyWithException(t, u);\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}\n/**\r\n * Return a new {@link ThrowingBiFunction} where the\r\n * {@link #apply(Object, Object)} method wraps any thrown checked exceptions\r\n * using the given {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingBiFunction} instance\r\n */\r\ndefault ThrowingBiFunction<T, U, R> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingBiFunction<>() {\r\n\r\n        @Override\r\n        public R applyWithException(T t, U u) throws Exception {\r\n            return ThrowingBiFunction.this.applyWithException(t, u);\r\n        }\r\n\r\n        @Override\r\n        public R apply(T t, U u) {\r\n            return apply(t, u, exceptionWrapper);\r\n        }\r\n    };\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingBiFunction} where the {@link #apply(Object, Object)}\r\n * method wraps any checked exception thrown by the supplied lambda expression\r\n * or method reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link BiFunction}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of the first argument to the function\r\n * @param <U> the type of the second argument to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, U, R> ThrowingBiFunction<T, U, R> of(ThrowingBiFunction<T, U, R> function) {\r\n    return function;\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingBiFunction} where the {@link #apply(Object, Object)}\r\n * method wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link BiFunction}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of the first argument to the function\r\n * @param <U> the type of the second argument to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, U, R> ThrowingBiFunction<T, U, R> of(ThrowingBiFunction<T, U, R> function, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return function.throwing(exceptionWrapper);\r\n}",
    "comment": "\n * A {@link BiFunction} that allows invocation of code that throws a checked\n * exception.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n * @param <T> the type of the first argument to the function\n * @param <U> the type of the second argument to the function\n * @param <R> the type of the result of the function\n "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
    "entityType": "method",
    "code": "/**\r\n * Applies this function to the given argument, possibly throwing a checked\r\n * exception.\r\n * @param t the first function argument\r\n * @param u the second function argument\r\n * @return the function result\r\n * @throws Exception on error\r\n */\r\nR applyWithException(T t, U u) throws Exception;",
    "comment": "\n\t * Applies this function to the given argument, possibly throwing a checked\n\t * exception.\n\t * @param t the first function argument\n\t * @param u the second function argument\n\t * @return the function result\n\t * @throws Exception on error\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
    "entityType": "method",
    "code": "/**\r\n * Default {@link BiFunction#apply(Object, Object)} that wraps any thrown\r\n * checked exceptions (by default in a {@link RuntimeException}).\r\n * @param t the first function argument\r\n * @param u the second function argument\r\n * @return the function result\r\n * @see java.util.function.BiFunction#apply(Object, Object)\r\n */\r\n@Override\r\ndefault R apply(T t, U u) {\r\n    return apply(t, u, RuntimeException::new);\r\n}",
    "comment": "\n\t * Default {@link BiFunction#apply(Object, Object)} that wraps any thrown\n\t * checked exceptions (by default in a {@link RuntimeException}).\n\t * @param t the first function argument\n\t * @param u the second function argument\n\t * @return the function result\n\t * @see java.util.function.BiFunction#apply(Object, Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Applies this function to the given argument, wrapping any thrown checked\r\n * exceptions using the given {@code exceptionWrapper}.\r\n * @param t the first function argument\r\n * @param u the second function argument\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return a result\r\n */\r\ndefault R apply(T t, U u, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        return applyWithException(t, u);\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": "\n\t * Applies this function to the given argument, wrapping any thrown checked\n\t * exceptions using the given {@code exceptionWrapper}.\n\t * @param t the first function argument\n\t * @param u the second function argument\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return a result\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Return a new {@link ThrowingBiFunction} where the\r\n * {@link #apply(Object, Object)} method wraps any thrown checked exceptions\r\n * using the given {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingBiFunction} instance\r\n */\r\ndefault ThrowingBiFunction<T, U, R> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingBiFunction<>() {\r\n\r\n        @Override\r\n        public R applyWithException(T t, U u) throws Exception {\r\n            return ThrowingBiFunction.this.applyWithException(t, u);\r\n        }\r\n\r\n        @Override\r\n        public R apply(T t, U u) {\r\n            return apply(t, u, exceptionWrapper);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Return a new {@link ThrowingBiFunction} where the\n\t * {@link #apply(Object, Object)} method wraps any thrown checked exceptions\n\t * using the given {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return the replacement {@link ThrowingBiFunction} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingBiFunction} where the {@link #apply(Object, Object)}\r\n * method wraps any checked exception thrown by the supplied lambda expression\r\n * or method reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link BiFunction}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of the first argument to the function\r\n * @param <U> the type of the second argument to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, U, R> ThrowingBiFunction<T, U, R> of(ThrowingBiFunction<T, U, R> function) {\r\n    return function;\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingBiFunction} where the {@link #apply(Object, Object)}\n\t * method wraps any checked exception thrown by the supplied lambda expression\n\t * or method reference.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link BiFunction}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException));\n\t * </pre>\n\t * @param <T> the type of the first argument to the function\n\t * @param <U> the type of the second argument to the function\n\t * @param <R> the type of the result of the function\n\t * @param function the source function\n\t * @return a new {@link ThrowingFunction} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingBiFunction} where the {@link #apply(Object, Object)}\r\n * method wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link BiFunction}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of the first argument to the function\r\n * @param <U> the type of the second argument to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, U, R> ThrowingBiFunction<T, U, R> of(ThrowingBiFunction<T, U, R> function, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return function.throwing(exceptionWrapper);\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingBiFunction} where the {@link #apply(Object, Object)}\n\t * method wraps any thrown checked exceptions using the given\n\t * {@code exceptionWrapper}.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link BiFunction}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\n\t * </pre>\n\t * @param <T> the type of the first argument to the function\n\t * @param <U> the type of the second argument to the function\n\t * @param <R> the type of the result of the function\n\t * @param function the source function\n\t * @param exceptionWrapper the exception wrapper to use\n\t * @return a new {@link ThrowingFunction} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer",
    "entityType": "class",
    "code": "/**\r\n * Performs this operation on the given argument, possibly throwing a\r\n * checked exception.\r\n * @param t the input argument\r\n * @throws Exception on error\r\n */\r\nvoid acceptWithException(T t) throws Exception;\n/**\r\n * Default {@link Consumer#accept(Object)} that wraps any thrown checked\r\n * exceptions (by default in a {@link RuntimeException}).\r\n * @see java.util.function.Consumer#accept(Object)\r\n */\r\n@Override\r\ndefault void accept(T t) {\r\n    accept(t, RuntimeException::new);\r\n}\n/**\r\n * Performs this operation on the given argument, wrapping any thrown\r\n * checked exceptions using the given {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n */\r\ndefault void accept(T t, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        acceptWithException(t);\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}\n/**\r\n * Return a new {@link ThrowingConsumer} where the {@link #accept(Object)}\r\n * method wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingConsumer} instance\r\n */\r\ndefault ThrowingConsumer<T> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingConsumer<>() {\r\n\r\n        @Override\r\n        public void acceptWithException(T t) throws Exception {\r\n            ThrowingConsumer.this.acceptWithException(t);\r\n        }\r\n\r\n        @Override\r\n        public void accept(T t) {\r\n            accept(t, exceptionWrapper);\r\n        }\r\n    };\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingConsumer} where the {@link #accept(Object)} method wraps\r\n * any checked exception thrown by the supplied lambda expression or method\r\n * reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Consumer}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * list.forEach(ThrowingConsumer.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of the input to the operation\r\n * @param consumer the source consumer\r\n * @return a new {@link ThrowingConsumer} instance\r\n */\r\nstatic <T> ThrowingConsumer<T> of(ThrowingConsumer<T> consumer) {\r\n    return consumer;\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingConsumer} where the {@link #accept(Object)} method wraps\r\n * any thrown checked exceptions using the given {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Consumer}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * list.forEach(ThrowingConsumer.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of the input to the operation\r\n * @param consumer the source consumer\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingConsumer} instance\r\n */\r\nstatic <T> ThrowingConsumer<T> of(ThrowingConsumer<T> consumer, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return consumer.throwing(exceptionWrapper);\r\n}",
    "comment": "\n * A {@link Consumer} that allows invocation of code that throws a checked\n * exception.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n * @param <T> the type of the input to the operation\n "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
    "entityType": "method",
    "code": "/**\r\n * Performs this operation on the given argument, possibly throwing a\r\n * checked exception.\r\n * @param t the input argument\r\n * @throws Exception on error\r\n */\r\nvoid acceptWithException(T t) throws Exception;",
    "comment": "\n\t * Performs this operation on the given argument, possibly throwing a\n\t * checked exception.\n\t * @param t the input argument\n\t * @throws Exception on error\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer#accept(T)",
    "entityType": "method",
    "code": "/**\r\n * Default {@link Consumer#accept(Object)} that wraps any thrown checked\r\n * exceptions (by default in a {@link RuntimeException}).\r\n * @see java.util.function.Consumer#accept(Object)\r\n */\r\n@Override\r\ndefault void accept(T t) {\r\n    accept(t, RuntimeException::new);\r\n}",
    "comment": "\n\t * Default {@link Consumer#accept(Object)} that wraps any thrown checked\n\t * exceptions (by default in a {@link RuntimeException}).\n\t * @see java.util.function.Consumer#accept(Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Performs this operation on the given argument, wrapping any thrown\r\n * checked exceptions using the given {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n */\r\ndefault void accept(T t, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        acceptWithException(t);\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": "\n\t * Performs this operation on the given argument, wrapping any thrown\n\t * checked exceptions using the given {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Return a new {@link ThrowingConsumer} where the {@link #accept(Object)}\r\n * method wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingConsumer} instance\r\n */\r\ndefault ThrowingConsumer<T> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingConsumer<>() {\r\n\r\n        @Override\r\n        public void acceptWithException(T t) throws Exception {\r\n            ThrowingConsumer.this.acceptWithException(t);\r\n        }\r\n\r\n        @Override\r\n        public void accept(T t) {\r\n            accept(t, exceptionWrapper);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Return a new {@link ThrowingConsumer} where the {@link #accept(Object)}\n\t * method wraps any thrown checked exceptions using the given\n\t * {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return the replacement {@link ThrowingConsumer} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingConsumer} where the {@link #accept(Object)} method wraps\r\n * any checked exception thrown by the supplied lambda expression or method\r\n * reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Consumer}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * list.forEach(ThrowingConsumer.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of the input to the operation\r\n * @param consumer the source consumer\r\n * @return a new {@link ThrowingConsumer} instance\r\n */\r\nstatic <T> ThrowingConsumer<T> of(ThrowingConsumer<T> consumer) {\r\n    return consumer;\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingConsumer} where the {@link #accept(Object)} method wraps\n\t * any checked exception thrown by the supplied lambda expression or method\n\t * reference.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link Consumer}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * list.forEach(ThrowingConsumer.of(Example::methodThatCanThrowCheckedException));\n\t * </pre>\n\t * @param <T> the type of the input to the operation\n\t * @param consumer the source consumer\n\t * @return a new {@link ThrowingConsumer} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingConsumer} where the {@link #accept(Object)} method wraps\r\n * any thrown checked exceptions using the given {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Consumer}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * list.forEach(ThrowingConsumer.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of the input to the operation\r\n * @param consumer the source consumer\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingConsumer} instance\r\n */\r\nstatic <T> ThrowingConsumer<T> of(ThrowingConsumer<T> consumer, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return consumer.throwing(exceptionWrapper);\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingConsumer} where the {@link #accept(Object)} method wraps\n\t * any thrown checked exceptions using the given {@code exceptionWrapper}.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link Consumer}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * list.forEach(ThrowingConsumer.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\n\t * </pre>\n\t * @param <T> the type of the input to the operation\n\t * @param consumer the source consumer\n\t * @param exceptionWrapper the exception wrapper to use\n\t * @return a new {@link ThrowingConsumer} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction",
    "entityType": "class",
    "code": "/**\r\n * Applies this function to the given argument, possibly throwing a checked\r\n * exception.\r\n * @param t the function argument\r\n * @return the function result\r\n * @throws Exception on error\r\n */\r\nR applyWithException(T t) throws Exception;\n/**\r\n * Default {@link Function#apply(Object)} that wraps any thrown checked\r\n * exceptions (by default in a {@link RuntimeException}).\r\n * @see java.util.function.Function#apply(java.lang.Object)\r\n */\r\n@Override\r\ndefault R apply(T t) {\r\n    return apply(t, RuntimeException::new);\r\n}\n/**\r\n * Applies this function to the given argument, wrapping any thrown checked\r\n * exceptions using the given {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return a result\r\n */\r\ndefault R apply(T t, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        return applyWithException(t);\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}\n/**\r\n * Return a new {@link ThrowingFunction} where the {@link #apply(Object)}\r\n * method wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingFunction} instance\r\n */\r\ndefault ThrowingFunction<T, R> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingFunction<>() {\r\n\r\n        @Override\r\n        public R applyWithException(T t) throws Exception {\r\n            return ThrowingFunction.this.applyWithException(t);\r\n        }\r\n\r\n        @Override\r\n        public R apply(T t) {\r\n            return apply(t, exceptionWrapper);\r\n        }\r\n    };\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingFunction} where the {@link #apply(Object)} method wraps\r\n * any checked exception thrown by the supplied lambda expression or method\r\n * reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Function}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of the input to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, R> ThrowingFunction<T, R> of(ThrowingFunction<T, R> function) {\r\n    return function;\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingFunction} where the {@link #apply(Object)} method wraps\r\n * any thrown checked exceptions using the given {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Function}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of the input to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, R> ThrowingFunction<T, R> of(ThrowingFunction<T, R> function, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return function.throwing(exceptionWrapper);\r\n}",
    "comment": "\n * A {@link Function} that allows invocation of code that throws a checked\n * exception.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n * @param <T> the type of the input to the function\n * @param <R> the type of the result of the function\n "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
    "entityType": "method",
    "code": "/**\r\n * Applies this function to the given argument, possibly throwing a checked\r\n * exception.\r\n * @param t the function argument\r\n * @return the function result\r\n * @throws Exception on error\r\n */\r\nR applyWithException(T t) throws Exception;",
    "comment": "\n\t * Applies this function to the given argument, possibly throwing a checked\n\t * exception.\n\t * @param t the function argument\n\t * @return the function result\n\t * @throws Exception on error\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction#apply(T)",
    "entityType": "method",
    "code": "/**\r\n * Default {@link Function#apply(Object)} that wraps any thrown checked\r\n * exceptions (by default in a {@link RuntimeException}).\r\n * @see java.util.function.Function#apply(java.lang.Object)\r\n */\r\n@Override\r\ndefault R apply(T t) {\r\n    return apply(t, RuntimeException::new);\r\n}",
    "comment": "\n\t * Default {@link Function#apply(Object)} that wraps any thrown checked\n\t * exceptions (by default in a {@link RuntimeException}).\n\t * @see java.util.function.Function#apply(java.lang.Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Applies this function to the given argument, wrapping any thrown checked\r\n * exceptions using the given {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return a result\r\n */\r\ndefault R apply(T t, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        return applyWithException(t);\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": "\n\t * Applies this function to the given argument, wrapping any thrown checked\n\t * exceptions using the given {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return a result\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Return a new {@link ThrowingFunction} where the {@link #apply(Object)}\r\n * method wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingFunction} instance\r\n */\r\ndefault ThrowingFunction<T, R> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingFunction<>() {\r\n\r\n        @Override\r\n        public R applyWithException(T t) throws Exception {\r\n            return ThrowingFunction.this.applyWithException(t);\r\n        }\r\n\r\n        @Override\r\n        public R apply(T t) {\r\n            return apply(t, exceptionWrapper);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Return a new {@link ThrowingFunction} where the {@link #apply(Object)}\n\t * method wraps any thrown checked exceptions using the given\n\t * {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return the replacement {@link ThrowingFunction} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingFunction} where the {@link #apply(Object)} method wraps\r\n * any checked exception thrown by the supplied lambda expression or method\r\n * reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Function}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of the input to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, R> ThrowingFunction<T, R> of(ThrowingFunction<T, R> function) {\r\n    return function;\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingFunction} where the {@link #apply(Object)} method wraps\n\t * any checked exception thrown by the supplied lambda expression or method\n\t * reference.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link Function}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException));\n\t * </pre>\n\t * @param <T> the type of the input to the function\n\t * @param <R> the type of the result of the function\n\t * @param function the source function\n\t * @return a new {@link ThrowingFunction} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingFunction} where the {@link #apply(Object)} method wraps\r\n * any thrown checked exceptions using the given {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Function}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of the input to the function\r\n * @param <R> the type of the result of the function\r\n * @param function the source function\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingFunction} instance\r\n */\r\nstatic <T, R> ThrowingFunction<T, R> of(ThrowingFunction<T, R> function, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return function.throwing(exceptionWrapper);\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingFunction} where the {@link #apply(Object)} method wraps\n\t * any thrown checked exceptions using the given {@code exceptionWrapper}.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link Function}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\n\t * </pre>\n\t * @param <T> the type of the input to the function\n\t * @param <R> the type of the result of the function\n\t * @param function the source function\n\t * @param exceptionWrapper the exception wrapper to use\n\t * @return a new {@link ThrowingFunction} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier",
    "entityType": "class",
    "code": "/**\r\n * Gets a result, possibly throwing a checked exception.\r\n * @return a result\r\n * @throws Exception on error\r\n */\r\nT getWithException() throws Exception;\n/**\r\n * Default {@link Supplier#get()} that wraps any thrown checked exceptions\r\n * (by default in a {@link RuntimeException}).\r\n * @see java.util.function.Supplier#get()\r\n */\r\n@Override\r\ndefault T get() {\r\n    return get(RuntimeException::new);\r\n}\n/**\r\n * Gets a result, wrapping any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return a result\r\n */\r\ndefault T get(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        return getWithException();\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}\n/**\r\n * Return a new {@link ThrowingSupplier} where the {@link #get()} method\r\n * wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingSupplier} instance\r\n */\r\ndefault ThrowingSupplier<T> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingSupplier<>() {\r\n\r\n        @Override\r\n        public T getWithException() throws Exception {\r\n            return ThrowingSupplier.this.getWithException();\r\n        }\r\n\r\n        @Override\r\n        public T get() {\r\n            return get(exceptionWrapper);\r\n        }\r\n    };\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingSupplier} where the {@link #get()} method wraps any checked\r\n * exception thrown by the supplied lambda expression or method reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Supplier}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of results supplied by this supplier\r\n * @param supplier the source supplier\r\n * @return a new {@link ThrowingSupplier} instance\r\n */\r\nstatic <T> ThrowingSupplier<T> of(ThrowingSupplier<T> supplier) {\r\n    return supplier;\r\n}\n/**\r\n * Lambda friendly convenience method that can be used to create\r\n * {@link ThrowingSupplier} where the {@link #get()} method wraps any\r\n * thrown checked exceptions using the given {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Supplier}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of results supplied by this supplier\r\n * @param supplier the source supplier\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingSupplier} instance\r\n */\r\nstatic <T> ThrowingSupplier<T> of(ThrowingSupplier<T> supplier, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return supplier.throwing(exceptionWrapper);\r\n}",
    "comment": "\n * A {@link Supplier} that allows invocation of code that throws a checked exception.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n * @param <T> the type of results supplied by this supplier\n "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier#getWithException()",
    "entityType": "method",
    "code": "/**\r\n * Gets a result, possibly throwing a checked exception.\r\n * @return a result\r\n * @throws Exception on error\r\n */\r\nT getWithException() throws Exception;",
    "comment": "\n\t * Gets a result, possibly throwing a checked exception.\n\t * @return a result\n\t * @throws Exception on error\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier#get()",
    "entityType": "method",
    "code": "/**\r\n * Default {@link Supplier#get()} that wraps any thrown checked exceptions\r\n * (by default in a {@link RuntimeException}).\r\n * @see java.util.function.Supplier#get()\r\n */\r\n@Override\r\ndefault T get() {\r\n    return get(RuntimeException::new);\r\n}",
    "comment": "\n\t * Default {@link Supplier#get()} that wraps any thrown checked exceptions\n\t * (by default in a {@link RuntimeException}).\n\t * @see java.util.function.Supplier#get()\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Gets a result, wrapping any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return a result\r\n */\r\ndefault T get(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    try {\r\n        return getWithException();\r\n    } catch (RuntimeException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        throw exceptionWrapper.apply(ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": "\n\t * Gets a result, wrapping any thrown checked exceptions using the given\n\t * {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return a result\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Return a new {@link ThrowingSupplier} where the {@link #get()} method\r\n * wraps any thrown checked exceptions using the given\r\n * {@code exceptionWrapper}.\r\n * @param exceptionWrapper {@link BiFunction} that wraps the given message\r\n * and checked exception into a runtime exception\r\n * @return the replacement {@link ThrowingSupplier} instance\r\n */\r\ndefault ThrowingSupplier<T> throwing(BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return new ThrowingSupplier<>() {\r\n\r\n        @Override\r\n        public T getWithException() throws Exception {\r\n            return ThrowingSupplier.this.getWithException();\r\n        }\r\n\r\n        @Override\r\n        public T get() {\r\n            return get(exceptionWrapper);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Return a new {@link ThrowingSupplier} where the {@link #get()} method\n\t * wraps any thrown checked exceptions using the given\n\t * {@code exceptionWrapper}.\n\t * @param exceptionWrapper {@link BiFunction} that wraps the given message\n\t * and checked exception into a runtime exception\n\t * @return the replacement {@link ThrowingSupplier} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create a\r\n * {@link ThrowingSupplier} where the {@link #get()} method wraps any checked\r\n * exception thrown by the supplied lambda expression or method reference.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Supplier}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException));\r\n * </pre>\r\n * @param <T> the type of results supplied by this supplier\r\n * @param supplier the source supplier\r\n * @return a new {@link ThrowingSupplier} instance\r\n */\r\nstatic <T> ThrowingSupplier<T> of(ThrowingSupplier<T> supplier) {\r\n    return supplier;\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create a\n\t * {@link ThrowingSupplier} where the {@link #get()} method wraps any checked\n\t * exception thrown by the supplied lambda expression or method reference.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link Supplier}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException));\n\t * </pre>\n\t * @param <T> the type of results supplied by this supplier\n\t * @param supplier the source supplier\n\t * @return a new {@link ThrowingSupplier} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Lambda friendly convenience method that can be used to create\r\n * {@link ThrowingSupplier} where the {@link #get()} method wraps any\r\n * thrown checked exceptions using the given {@code exceptionWrapper}.\r\n * <p>This method can be especially useful when working with method references.\r\n * It allows you to easily convert a method that throws a checked exception\r\n * into an instance compatible with a regular {@link Supplier}.\r\n * <p>For example:\r\n * <pre class=\"code\">\r\n * optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\r\n * </pre>\r\n * @param <T> the type of results supplied by this supplier\r\n * @param supplier the source supplier\r\n * @param exceptionWrapper the exception wrapper to use\r\n * @return a new {@link ThrowingSupplier} instance\r\n */\r\nstatic <T> ThrowingSupplier<T> of(ThrowingSupplier<T> supplier, BiFunction<String, Exception, RuntimeException> exceptionWrapper) {\r\n    return supplier.throwing(exceptionWrapper);\r\n}",
    "comment": "\n\t * Lambda friendly convenience method that can be used to create\n\t * {@link ThrowingSupplier} where the {@link #get()} method wraps any\n\t * thrown checked exceptions using the given {@code exceptionWrapper}.\n\t * <p>This method can be especially useful when working with method references.\n\t * It allows you to easily convert a method that throws a checked exception\n\t * into an instance compatible with a regular {@link Supplier}.\n\t * <p>For example:\n\t * <pre class=\"code\">\n\t * optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));\n\t * </pre>\n\t * @param <T> the type of results supplied by this supplier\n\t * @param supplier the source supplier\n\t * @param exceptionWrapper the exception wrapper to use\n\t * @return a new {@link ThrowingSupplier} instance\n\t "
  },
  {
    "entityId": "org.springframework.util.IdGenerator",
    "entityType": "class",
    "code": "/**\r\n * Generate a new identifier.\r\n * @return the generated identifier\r\n */\r\nUUID generateId();",
    "comment": "\n * Contract for generating universally unique identifiers ({@link UUID UUIDs}).\n *\n * @author Rossen Stoyanchev\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.util.IdGenerator#generateId()",
    "entityType": "method",
    "code": "/**\r\n * Generate a new identifier.\r\n * @return the generated identifier\r\n */\r\nUUID generateId();",
    "comment": "\n\t * Generate a new identifier.\n\t * @return the generated identifier\n\t "
  },
  {
    "entityId": "org.springframework.util.InstanceFilter",
    "entityType": "class",
    "code": "private final Collection<? extends T> includes;\nprivate final Collection<? extends T> excludes;\nprivate final boolean matchIfEmpty;\n/**\r\n * Create a new instance based on includes/excludes collections.\r\n * <p>A particular element will match if it \"matches\" the one of the element in the\r\n * includes list and  does not match one of the element in the excludes list.\r\n * <p>Subclasses may redefine what matching means. By default, an element match with\r\n * another if it is equals according to {@link Object#equals(Object)}\r\n * <p>If both collections are empty, {@code matchIfEmpty} defines if\r\n * an element matches or not.\r\n * @param includes the collection of includes\r\n * @param excludes the collection of excludes\r\n * @param matchIfEmpty the matching result if both the includes and the excludes\r\n * collections are empty\r\n */\r\npublic InstanceFilter(@Nullable Collection<? extends T> includes, @Nullable Collection<? extends T> excludes, boolean matchIfEmpty) {\r\n    this.includes = (includes != null ? includes : Collections.emptyList());\r\n    this.excludes = (excludes != null ? excludes : Collections.emptyList());\r\n    this.matchIfEmpty = matchIfEmpty;\r\n}\n/**\r\n * Determine if the specified {@code instance} matches this filter.\r\n */\r\npublic boolean match(T instance) {\r\n    Assert.notNull(instance, \"Instance to match must not be null\");\r\n    boolean includesSet = !this.includes.isEmpty();\r\n    boolean excludesSet = !this.excludes.isEmpty();\r\n    if (!includesSet && !excludesSet) {\r\n        return this.matchIfEmpty;\r\n    }\r\n    boolean matchIncludes = match(instance, this.includes);\r\n    boolean matchExcludes = match(instance, this.excludes);\r\n    if (!includesSet) {\r\n        return !matchExcludes;\r\n    }\r\n    if (!excludesSet) {\r\n        return matchIncludes;\r\n    }\r\n    return matchIncludes && !matchExcludes;\r\n}\n/**\r\n * Determine if the specified {@code instance} is equal to the\r\n * specified {@code candidate}.\r\n * @param instance the instance to handle\r\n * @param candidate a candidate defined by this filter\r\n * @return {@code true} if the instance matches the candidate\r\n */\r\nprotected boolean match(T instance, T candidate) {\r\n    return instance.equals(candidate);\r\n}\n/**\r\n * Determine if the specified {@code instance} matches one of the candidates.\r\n * <p>If the candidates collection is {@code null}, returns {@code false}.\r\n * @param instance the instance to check\r\n * @param candidates a list of candidates\r\n * @return {@code true} if the instance match or the candidates collection is null\r\n */\r\nprotected boolean match(T instance, Collection<? extends T> candidates) {\r\n    for (T candidate : candidates) {\r\n        if (match(instance, candidate)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(getClass().getSimpleName());\r\n    sb.append(\": includes=\").append(this.includes);\r\n    sb.append(\", excludes=\").append(this.excludes);\r\n    sb.append(\", matchIfEmpty=\").append(this.matchIfEmpty);\r\n    return sb.toString();\r\n}",
    "comment": "\n * A simple instance filter that checks if a given instance match based on\n * a collection of includes and excludes element.\n *\n * <p>Subclasses may want to override {@link #match(Object, Object)} to provide\n * a custom matching algorithm.\n *\n * @author Stephane Nicoll\n * @since 4.1\n * @param <T> the instance type\n "
  },
  {
    "entityId": "org.springframework.util.InstanceFilter#match(T)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified {@code instance} matches this filter.\r\n */\r\npublic boolean match(T instance) {\r\n    Assert.notNull(instance, \"Instance to match must not be null\");\r\n    boolean includesSet = !this.includes.isEmpty();\r\n    boolean excludesSet = !this.excludes.isEmpty();\r\n    if (!includesSet && !excludesSet) {\r\n        return this.matchIfEmpty;\r\n    }\r\n    boolean matchIncludes = match(instance, this.includes);\r\n    boolean matchExcludes = match(instance, this.excludes);\r\n    if (!includesSet) {\r\n        return !matchExcludes;\r\n    }\r\n    if (!excludesSet) {\r\n        return matchIncludes;\r\n    }\r\n    return matchIncludes && !matchExcludes;\r\n}",
    "comment": "\n\t * Determine if the specified {@code instance} matches this filter.\n\t "
  },
  {
    "entityId": "org.springframework.util.InstanceFilter#match(T,T)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified {@code instance} is equal to the\r\n * specified {@code candidate}.\r\n * @param instance the instance to handle\r\n * @param candidate a candidate defined by this filter\r\n * @return {@code true} if the instance matches the candidate\r\n */\r\nprotected boolean match(T instance, T candidate) {\r\n    return instance.equals(candidate);\r\n}",
    "comment": "\n\t * Determine if the specified {@code instance} is equal to the\n\t * specified {@code candidate}.\n\t * @param instance the instance to handle\n\t * @param candidate a candidate defined by this filter\n\t * @return {@code true} if the instance matches the candidate\n\t "
  },
  {
    "entityId": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified {@code instance} matches one of the candidates.\r\n * <p>If the candidates collection is {@code null}, returns {@code false}.\r\n * @param instance the instance to check\r\n * @param candidates a list of candidates\r\n * @return {@code true} if the instance match or the candidates collection is null\r\n */\r\nprotected boolean match(T instance, Collection<? extends T> candidates) {\r\n    for (T candidate : candidates) {\r\n        if (match(instance, candidate)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine if the specified {@code instance} matches one of the candidates.\n\t * <p>If the candidates collection is {@code null}, returns {@code false}.\n\t * @param instance the instance to check\n\t * @param candidates a list of candidates\n\t * @return {@code true} if the instance match or the candidates collection is null\n\t "
  },
  {
    "entityId": "org.springframework.util.InstanceFilter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(getClass().getSimpleName());\r\n    sb.append(\": includes=\").append(this.includes);\r\n    sb.append(\", excludes=\").append(this.excludes);\r\n    sb.append(\", matchIfEmpty=\").append(this.matchIfEmpty);\r\n    return sb.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.InvalidMimeTypeException",
    "entityType": "class",
    "code": "private final String mimeType;\n/**\r\n * Create a new InvalidContentTypeException for the given content type.\r\n * @param mimeType the offending media type\r\n * @param message a detail message indicating the invalid part\r\n */\r\npublic InvalidMimeTypeException(String mimeType, @Nullable String message) {\r\n    super(message == null ? \"Invalid mime type \\\"\" + mimeType + \"\\\"\" : \"Invalid mime type \\\"\" + mimeType + \"\\\": \" + message);\r\n    this.mimeType = mimeType;\r\n}\n/**\r\n * Return the offending content type.\r\n */\r\npublic String getMimeType() {\r\n    return this.mimeType;\r\n}",
    "comment": "\n * Exception thrown from {@link MimeTypeUtils#parseMimeType(String)} in case of\n * encountering an invalid content type specification String.\n *\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.util.InvalidMimeTypeException#getMimeType()",
    "entityType": "method",
    "code": "/**\r\n * Return the offending content type.\r\n */\r\npublic String getMimeType() {\r\n    return this.mimeType;\r\n}",
    "comment": "\n\t * Return the offending content type.\n\t "
  },
  {
    "entityId": "org.springframework.util.JdkIdGenerator",
    "entityType": "class",
    "code": "@Override\r\npublic UUID generateId() {\r\n    return UUID.randomUUID();\r\n}",
    "comment": "\n * An {@link IdGenerator} that calls {@link java.util.UUID#randomUUID()}.\n *\n * @author Rossen Stoyanchev\n * @since 4.1.5\n "
  },
  {
    "entityId": "org.springframework.util.JdkIdGenerator#generateId()",
    "entityType": "method",
    "code": "@Override\r\npublic UUID generateId() {\r\n    return UUID.randomUUID();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap",
    "entityType": "class",
    "code": "private final LinkedHashMap<String, V> targetMap;\nprivate final HashMap<String, String> caseInsensitiveKeys;\nprivate final Locale locale;\n@Nullable\r\nprivate transient volatile Set<String> keySet;\n@Nullable\r\nprivate transient volatile Collection<V> values;\n@Nullable\r\nprivate transient volatile Set<Entry<String, V>> entrySet;\n/**\r\n * Create a new LinkedCaseInsensitiveMap that stores case-insensitive keys\r\n * according to the default Locale (by default in lower case).\r\n * @see #convertKey(String)\r\n */\r\npublic LinkedCaseInsensitiveMap() {\r\n    this((Locale) null);\r\n}\n/**\r\n * Create a new LinkedCaseInsensitiveMap that stores case-insensitive keys\r\n * according to the given Locale (in lower case).\r\n * @param locale the Locale to use for case-insensitive key conversion\r\n * @see #convertKey(String)\r\n */\r\npublic LinkedCaseInsensitiveMap(@Nullable Locale locale) {\r\n    // equivalent to LinkedHashMap's initial capacity of 16\r\n    this(12, locale);\r\n}\n/**\r\n * Create a new LinkedCaseInsensitiveMap that wraps a {@link LinkedHashMap}\r\n * with an initial capacity that can accommodate the specified number of\r\n * elements without any immediate resize/rehash operations to be expected,\r\n * storing case-insensitive keys according to the default Locale (in lower case).\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @see CollectionUtils#newHashMap(int)\r\n * @see #convertKey(String)\r\n */\r\npublic LinkedCaseInsensitiveMap(int expectedSize) {\r\n    this(expectedSize, null);\r\n}\n/**\r\n * Create a new LinkedCaseInsensitiveMap that wraps a {@link LinkedHashMap}\r\n * with an initial capacity that can accommodate the specified number of\r\n * elements without any immediate resize/rehash operations to be expected,\r\n * storing case-insensitive keys according to the given Locale (in lower case).\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @param locale the Locale to use for case-insensitive key conversion\r\n * @see CollectionUtils#newHashMap(int)\r\n * @see #convertKey(String)\r\n */\r\npublic LinkedCaseInsensitiveMap(int expectedSize, @Nullable Locale locale) {\r\n    this.targetMap = new LinkedHashMap<>((int) (expectedSize / CollectionUtils.DEFAULT_LOAD_FACTOR), CollectionUtils.DEFAULT_LOAD_FACTOR) {\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n            return LinkedCaseInsensitiveMap.this.containsKey(key);\r\n        }\r\n\r\n        @Override\r\n        protected boolean removeEldestEntry(Map.Entry<String, V> eldest) {\r\n            boolean doRemove = LinkedCaseInsensitiveMap.this.removeEldestEntry(eldest);\r\n            if (doRemove) {\r\n                removeCaseInsensitiveKey(eldest.getKey());\r\n            }\r\n            return doRemove;\r\n        }\r\n    };\r\n    this.caseInsensitiveKeys = CollectionUtils.newHashMap(expectedSize);\r\n    this.locale = (locale != null ? locale : Locale.getDefault());\r\n}\n/**\r\n * Copy constructor.\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprivate LinkedCaseInsensitiveMap(LinkedCaseInsensitiveMap<V> other) {\r\n    this.targetMap = (LinkedHashMap<String, V>) other.targetMap.clone();\r\n    this.caseInsensitiveKeys = (HashMap<String, String>) other.caseInsensitiveKeys.clone();\r\n    this.locale = other.locale;\r\n}\n// Implementation of java.util.Map\r\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}\n@Override\r\npublic boolean containsKey(Object key) {\r\n    return (key instanceof String string && this.caseInsensitiveKeys.containsKey(convertKey(string)));\r\n}\n@Override\r\npublic boolean containsValue(Object value) {\r\n    return this.targetMap.containsValue(value);\r\n}\n@Override\r\n@Nullable\r\npublic V get(Object key) {\r\n    if (key instanceof String string) {\r\n        String caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey(string));\r\n        if (caseInsensitiveKey != null) {\r\n            return this.targetMap.get(caseInsensitiveKey);\r\n        }\r\n    }\r\n    return null;\r\n}\n@Override\r\n@Nullable\r\npublic V getOrDefault(Object key, V defaultValue) {\r\n    if (key instanceof String string) {\r\n        String caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey(string));\r\n        if (caseInsensitiveKey != null) {\r\n            return this.targetMap.get(caseInsensitiveKey);\r\n        }\r\n    }\r\n    return defaultValue;\r\n}\n@Override\r\n@Nullable\r\npublic V put(String key, @Nullable V value) {\r\n    String oldKey = this.caseInsensitiveKeys.put(convertKey(key), key);\r\n    V oldKeyValue = null;\r\n    if (oldKey != null && !oldKey.equals(key)) {\r\n        oldKeyValue = this.targetMap.remove(oldKey);\r\n    }\r\n    V oldValue = this.targetMap.put(key, value);\r\n    return (oldKeyValue != null ? oldKeyValue : oldValue);\r\n}\n@Override\r\npublic void putAll(Map<? extends String, ? extends V> map) {\r\n    if (map.isEmpty()) {\r\n        return;\r\n    }\r\n    map.forEach(this::put);\r\n}\n@Override\r\n@Nullable\r\npublic V putIfAbsent(String key, @Nullable V value) {\r\n    String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\r\n    if (oldKey != null) {\r\n        V oldKeyValue = this.targetMap.get(oldKey);\r\n        if (oldKeyValue != null) {\r\n            return oldKeyValue;\r\n        } else {\r\n            key = oldKey;\r\n        }\r\n    }\r\n    return this.targetMap.putIfAbsent(key, value);\r\n}\n@Override\r\n@Nullable\r\npublic V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction) {\r\n    String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\r\n    if (oldKey != null) {\r\n        V oldKeyValue = this.targetMap.get(oldKey);\r\n        if (oldKeyValue != null) {\r\n            return oldKeyValue;\r\n        } else {\r\n            key = oldKey;\r\n        }\r\n    }\r\n    return this.targetMap.computeIfAbsent(key, mappingFunction);\r\n}\n@Override\r\n@Nullable\r\npublic V remove(Object key) {\r\n    if (key instanceof String string) {\r\n        String caseInsensitiveKey = removeCaseInsensitiveKey(string);\r\n        if (caseInsensitiveKey != null) {\r\n            return this.targetMap.remove(caseInsensitiveKey);\r\n        }\r\n    }\r\n    return null;\r\n}\n@Override\r\npublic void clear() {\r\n    this.caseInsensitiveKeys.clear();\r\n    this.targetMap.clear();\r\n}\n@Override\r\npublic Set<String> keySet() {\r\n    Set<String> keySet = this.keySet;\r\n    if (keySet == null) {\r\n        keySet = new KeySet(this.targetMap.keySet());\r\n        this.keySet = keySet;\r\n    }\r\n    return keySet;\r\n}\n@Override\r\npublic Collection<V> values() {\r\n    Collection<V> values = this.values;\r\n    if (values == null) {\r\n        values = new Values(this.targetMap.values());\r\n        this.values = values;\r\n    }\r\n    return values;\r\n}\n@Override\r\npublic Set<Entry<String, V>> entrySet() {\r\n    Set<Entry<String, V>> entrySet = this.entrySet;\r\n    if (entrySet == null) {\r\n        entrySet = new EntrySet(this.targetMap.entrySet());\r\n        this.entrySet = entrySet;\r\n    }\r\n    return entrySet;\r\n}\n@Override\r\npublic void forEach(BiConsumer<? super String, ? super V> action) {\r\n    this.targetMap.forEach(action);\r\n}\n@Override\r\npublic LinkedCaseInsensitiveMap<V> clone() {\r\n    return new LinkedCaseInsensitiveMap<>(this);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || this.targetMap.equals(other));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}\n// Specific to LinkedCaseInsensitiveMap\r\n/**\r\n * Return the locale used by this {@code LinkedCaseInsensitiveMap}.\r\n * Used for case-insensitive key conversion.\r\n * @since 4.3.10\r\n * @see #LinkedCaseInsensitiveMap(Locale)\r\n * @see #convertKey(String)\r\n */\r\npublic Locale getLocale() {\r\n    return this.locale;\r\n}\n/**\r\n * Convert the given key to a case-insensitive key.\r\n * <p>The default implementation converts the key\r\n * to lower-case according to this Map's Locale.\r\n * @param key the user-specified key\r\n * @return the key to use for storing\r\n * @see String#toLowerCase(Locale)\r\n */\r\nprotected String convertKey(String key) {\r\n    return key.toLowerCase(getLocale());\r\n}\n/**\r\n * Determine whether this map should remove the given eldest entry.\r\n * @param eldest the candidate entry\r\n * @return {@code true} for removing it, {@code false} for keeping it\r\n * @see LinkedHashMap#removeEldestEntry\r\n */\r\nprotected boolean removeEldestEntry(Map.Entry<String, V> eldest) {\r\n    return false;\r\n}\n@Nullable\r\nprivate String removeCaseInsensitiveKey(String key) {\r\n    return this.caseInsensitiveKeys.remove(convertKey(key));\r\n}\nprivate class KeySet extends AbstractSet<String> {\r\n\r\n    private final Set<String> delegate;\r\n\r\n    KeySet(Set<String> delegate) {\r\n        this.delegate = delegate;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return this.delegate.size();\r\n    }\r\n\r\n    @Override\r\n    public boolean contains(Object o) {\r\n        return this.delegate.contains(o);\r\n    }\r\n\r\n    @Override\r\n    public Iterator<String> iterator() {\r\n        return new KeySetIterator();\r\n    }\r\n\r\n    @Override\r\n    public boolean remove(Object o) {\r\n        return LinkedCaseInsensitiveMap.this.remove(o) != null;\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        LinkedCaseInsensitiveMap.this.clear();\r\n    }\r\n\r\n    @Override\r\n    public Spliterator<String> spliterator() {\r\n        return this.delegate.spliterator();\r\n    }\r\n\r\n    @Override\r\n    public void forEach(Consumer<? super String> action) {\r\n        this.delegate.forEach(action);\r\n    }\r\n}\nprivate class Values extends AbstractCollection<V> {\r\n\r\n    private final Collection<V> delegate;\r\n\r\n    Values(Collection<V> delegate) {\r\n        this.delegate = delegate;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return this.delegate.size();\r\n    }\r\n\r\n    @Override\r\n    public boolean contains(Object o) {\r\n        return this.delegate.contains(o);\r\n    }\r\n\r\n    @Override\r\n    public Iterator<V> iterator() {\r\n        return new ValuesIterator();\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        LinkedCaseInsensitiveMap.this.clear();\r\n    }\r\n\r\n    @Override\r\n    public Spliterator<V> spliterator() {\r\n        return this.delegate.spliterator();\r\n    }\r\n\r\n    @Override\r\n    public void forEach(Consumer<? super V> action) {\r\n        this.delegate.forEach(action);\r\n    }\r\n}\nprivate class EntrySet extends AbstractSet<Entry<String, V>> {\r\n\r\n    private final Set<Entry<String, V>> delegate;\r\n\r\n    public EntrySet(Set<Entry<String, V>> delegate) {\r\n        this.delegate = delegate;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return this.delegate.size();\r\n    }\r\n\r\n    @Override\r\n    public boolean contains(Object o) {\r\n        return this.delegate.contains(o);\r\n    }\r\n\r\n    @Override\r\n    public Iterator<Entry<String, V>> iterator() {\r\n        return new EntrySetIterator();\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"unchecked\")\r\n    public boolean remove(Object o) {\r\n        if (this.delegate.remove(o)) {\r\n            removeCaseInsensitiveKey(((Map.Entry<String, V>) o).getKey());\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        this.delegate.clear();\r\n        caseInsensitiveKeys.clear();\r\n    }\r\n\r\n    @Override\r\n    public Spliterator<Entry<String, V>> spliterator() {\r\n        return this.delegate.spliterator();\r\n    }\r\n\r\n    @Override\r\n    public void forEach(Consumer<? super Entry<String, V>> action) {\r\n        this.delegate.forEach(action);\r\n    }\r\n}\nprivate abstract class EntryIterator<T> implements Iterator<T> {\r\n\r\n    private final Iterator<Entry<String, V>> delegate;\r\n\r\n    @Nullable\r\n    private Entry<String, V> last;\r\n\r\n    public EntryIterator() {\r\n        this.delegate = targetMap.entrySet().iterator();\r\n    }\r\n\r\n    protected Entry<String, V> nextEntry() {\r\n        Entry<String, V> entry = this.delegate.next();\r\n        this.last = entry;\r\n        return entry;\r\n    }\r\n\r\n    @Override\r\n    public boolean hasNext() {\r\n        return this.delegate.hasNext();\r\n    }\r\n\r\n    @Override\r\n    public void remove() {\r\n        this.delegate.remove();\r\n        if (this.last != null) {\r\n            removeCaseInsensitiveKey(this.last.getKey());\r\n            this.last = null;\r\n        }\r\n    }\r\n}\nprivate class KeySetIterator extends EntryIterator<String> {\r\n\r\n    @Override\r\n    public String next() {\r\n        return nextEntry().getKey();\r\n    }\r\n}\nprivate class ValuesIterator extends EntryIterator<V> {\r\n\r\n    @Override\r\n    public V next() {\r\n        return nextEntry().getValue();\r\n    }\r\n}\nprivate class EntrySetIterator extends EntryIterator<Entry<String, V>> {\r\n\r\n    @Override\r\n    public Entry<String, V> next() {\r\n        return nextEntry();\r\n    }\r\n}",
    "comment": "\n * {@link LinkedHashMap} variant that stores String keys in a case-insensitive\n * manner, for example for key-based access in a results table.\n *\n * <p>Preserves the original order as well as the original casing of keys,\n * while allowing for contains, get and remove calls with any case of key.\n *\n * <p>Does <i>not</i> support {@code null} keys.\n *\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 3.0\n * @param <V> the value type\n "
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#size()",
    "entityType": "method",
    "code": "// Implementation of java.util.Map\r\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return (key instanceof String string && this.caseInsensitiveKeys.containsKey(convertKey(string)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#containsValue(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsValue(Object value) {\r\n    return this.targetMap.containsValue(value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V get(Object key) {\r\n    if (key instanceof String string) {\r\n        String caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey(string));\r\n        if (caseInsensitiveKey != null) {\r\n            return this.targetMap.get(caseInsensitiveKey);\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#getOrDefault(Object,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V getOrDefault(Object key, V defaultValue) {\r\n    if (key instanceof String string) {\r\n        String caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey(string));\r\n        if (caseInsensitiveKey != null) {\r\n            return this.targetMap.get(caseInsensitiveKey);\r\n        }\r\n    }\r\n    return defaultValue;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V put(String key, @Nullable V value) {\r\n    String oldKey = this.caseInsensitiveKeys.put(convertKey(key), key);\r\n    V oldKeyValue = null;\r\n    if (oldKey != null && !oldKey.equals(key)) {\r\n        oldKeyValue = this.targetMap.remove(oldKey);\r\n    }\r\n    V oldValue = this.targetMap.put(key, value);\r\n    return (oldKeyValue != null ? oldKeyValue : oldValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#putAll(Map<? extends String,? extends V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void putAll(Map<? extends String, ? extends V> map) {\r\n    if (map.isEmpty()) {\r\n        return;\r\n    }\r\n    map.forEach(this::put);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#putIfAbsent(String,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V putIfAbsent(String key, @Nullable V value) {\r\n    String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\r\n    if (oldKey != null) {\r\n        V oldKeyValue = this.targetMap.get(oldKey);\r\n        if (oldKeyValue != null) {\r\n            return oldKeyValue;\r\n        } else {\r\n            key = oldKey;\r\n        }\r\n    }\r\n    return this.targetMap.putIfAbsent(key, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#computeIfAbsent(String,Function<? super String,? extends V>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction) {\r\n    String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);\r\n    if (oldKey != null) {\r\n        V oldKeyValue = this.targetMap.get(oldKey);\r\n        if (oldKeyValue != null) {\r\n            return oldKeyValue;\r\n        } else {\r\n            key = oldKey;\r\n        }\r\n    }\r\n    return this.targetMap.computeIfAbsent(key, mappingFunction);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V remove(Object key) {\r\n    if (key instanceof String string) {\r\n        String caseInsensitiveKey = removeCaseInsensitiveKey(string);\r\n        if (caseInsensitiveKey != null) {\r\n            return this.targetMap.remove(caseInsensitiveKey);\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.caseInsensitiveKeys.clear();\r\n    this.targetMap.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#keySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<String> keySet() {\r\n    Set<String> keySet = this.keySet;\r\n    if (keySet == null) {\r\n        keySet = new KeySet(this.targetMap.keySet());\r\n        this.keySet = keySet;\r\n    }\r\n    return keySet;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#values()",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<V> values() {\r\n    Collection<V> values = this.values;\r\n    if (values == null) {\r\n        values = new Values(this.targetMap.values());\r\n        this.values = values;\r\n    }\r\n    return values;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Entry<String, V>> entrySet() {\r\n    Set<Entry<String, V>> entrySet = this.entrySet;\r\n    if (entrySet == null) {\r\n        entrySet = new EntrySet(this.targetMap.entrySet());\r\n        this.entrySet = entrySet;\r\n    }\r\n    return entrySet;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#forEach(BiConsumer<? super String,? super V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(BiConsumer<? super String, ? super V> action) {\r\n    this.targetMap.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#clone()",
    "entityType": "method",
    "code": "@Override\r\npublic LinkedCaseInsensitiveMap<V> clone() {\r\n    return new LinkedCaseInsensitiveMap<>(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || this.targetMap.equals(other));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#getLocale()",
    "entityType": "method",
    "code": "// Specific to LinkedCaseInsensitiveMap\r\n/**\r\n * Return the locale used by this {@code LinkedCaseInsensitiveMap}.\r\n * Used for case-insensitive key conversion.\r\n * @since 4.3.10\r\n * @see #LinkedCaseInsensitiveMap(Locale)\r\n * @see #convertKey(String)\r\n */\r\npublic Locale getLocale() {\r\n    return this.locale;\r\n}",
    "comment": "\n\t * Return the locale used by this {@code LinkedCaseInsensitiveMap}.\n\t * Used for case-insensitive key conversion.\n\t * @since 4.3.10\n\t * @see #LinkedCaseInsensitiveMap(Locale)\n\t * @see #convertKey(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given key to a case-insensitive key.\r\n * <p>The default implementation converts the key\r\n * to lower-case according to this Map's Locale.\r\n * @param key the user-specified key\r\n * @return the key to use for storing\r\n * @see String#toLowerCase(Locale)\r\n */\r\nprotected String convertKey(String key) {\r\n    return key.toLowerCase(getLocale());\r\n}",
    "comment": "\n\t * Convert the given key to a case-insensitive key.\n\t * <p>The default implementation converts the key\n\t * to lower-case according to this Map's Locale.\n\t * @param key the user-specified key\n\t * @return the key to use for storing\n\t * @see String#toLowerCase(Locale)\n\t "
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this map should remove the given eldest entry.\r\n * @param eldest the candidate entry\r\n * @return {@code true} for removing it, {@code false} for keeping it\r\n * @see LinkedHashMap#removeEldestEntry\r\n */\r\nprotected boolean removeEldestEntry(Map.Entry<String, V> eldest) {\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether this map should remove the given eldest entry.\n\t * @param eldest the candidate entry\n\t * @return {@code true} for removing it, {@code false} for keeping it\n\t * @see LinkedHashMap#removeEldestEntry\n\t "
  },
  {
    "entityId": "org.springframework.util.LinkedCaseInsensitiveMap#removeCaseInsensitiveKey(String)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate String removeCaseInsensitiveKey(String key) {\r\n    return this.caseInsensitiveKeys.remove(convertKey(key));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet",
    "entityType": "class",
    "code": "private final Set<String> delegate;\nKeySet(Set<String> delegate) {\r\n    this.delegate = delegate;\r\n}\n@Override\r\npublic int size() {\r\n    return this.delegate.size();\r\n}\n@Override\r\npublic boolean contains(Object o) {\r\n    return this.delegate.contains(o);\r\n}\n@Override\r\npublic Iterator<String> iterator() {\r\n    return new KeySetIterator();\r\n}\n@Override\r\npublic boolean remove(Object o) {\r\n    return LinkedCaseInsensitiveMap.this.remove(o) != null;\r\n}\n@Override\r\npublic void clear() {\r\n    LinkedCaseInsensitiveMap.this.clear();\r\n}\n@Override\r\npublic Spliterator<String> spliterator() {\r\n    return this.delegate.spliterator();\r\n}\n@Override\r\npublic void forEach(Consumer<? super String> action) {\r\n    this.delegate.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.delegate.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(Object o) {\r\n    return this.delegate.contains(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<String> iterator() {\r\n    return new KeySetIterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean remove(Object o) {\r\n    return LinkedCaseInsensitiveMap.this.remove(o) != null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    LinkedCaseInsensitiveMap.this.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<String> spliterator() {\r\n    return this.delegate.spliterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySet#forEach(Consumer<? super String>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(Consumer<? super String> action) {\r\n    this.delegate.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values",
    "entityType": "class",
    "code": "private final Collection<V> delegate;\nValues(Collection<V> delegate) {\r\n    this.delegate = delegate;\r\n}\n@Override\r\npublic int size() {\r\n    return this.delegate.size();\r\n}\n@Override\r\npublic boolean contains(Object o) {\r\n    return this.delegate.contains(o);\r\n}\n@Override\r\npublic Iterator<V> iterator() {\r\n    return new ValuesIterator();\r\n}\n@Override\r\npublic void clear() {\r\n    LinkedCaseInsensitiveMap.this.clear();\r\n}\n@Override\r\npublic Spliterator<V> spliterator() {\r\n    return this.delegate.spliterator();\r\n}\n@Override\r\npublic void forEach(Consumer<? super V> action) {\r\n    this.delegate.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.delegate.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(Object o) {\r\n    return this.delegate.contains(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<V> iterator() {\r\n    return new ValuesIterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    LinkedCaseInsensitiveMap.this.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<V> spliterator() {\r\n    return this.delegate.spliterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Values#forEach(Consumer<? super V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(Consumer<? super V> action) {\r\n    this.delegate.forEach(action);\r\n}",
    "comment": ""
  }
]