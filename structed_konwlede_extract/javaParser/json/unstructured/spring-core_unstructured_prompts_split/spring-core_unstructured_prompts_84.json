[
  {
    "entityId": "org.springframework.util.ResizableByteArrayOutputStream",
    "entityType": "class",
    "code": "private static final int DEFAULT_INITIAL_CAPACITY = 256;\n/**\r\n * Create a new <code>ResizableByteArrayOutputStream</code>\r\n * with the default initial capacity of 256 bytes.\r\n */\r\npublic ResizableByteArrayOutputStream() {\r\n    super(DEFAULT_INITIAL_CAPACITY);\r\n}\n/**\r\n * Create a new <code>ResizableByteArrayOutputStream</code>\r\n * with the specified initial capacity.\r\n * @param initialCapacity the initial buffer size in bytes\r\n */\r\npublic ResizableByteArrayOutputStream(int initialCapacity) {\r\n    super(initialCapacity);\r\n}\n/**\r\n * Resize the internal buffer size to a specified capacity.\r\n * @param targetCapacity the desired size of the buffer\r\n * @throws IllegalArgumentException if the given capacity is smaller than\r\n * the actual size of the content stored in the buffer already\r\n * @see ResizableByteArrayOutputStream#size()\r\n */\r\npublic synchronized void resize(int targetCapacity) {\r\n    Assert.isTrue(targetCapacity >= this.count, \"New capacity must not be smaller than current size\");\r\n    byte[] resizedBuffer = new byte[targetCapacity];\r\n    System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);\r\n    this.buf = resizedBuffer;\r\n}\n/**\r\n * Grow the internal buffer size.\r\n * @param additionalCapacity the number of bytes to add to the current buffer size\r\n * @see ResizableByteArrayOutputStream#size()\r\n */\r\npublic synchronized void grow(int additionalCapacity) {\r\n    Assert.isTrue(additionalCapacity >= 0, \"Additional capacity must be 0 or higher\");\r\n    if (this.count + additionalCapacity > this.buf.length) {\r\n        int newCapacity = Math.max(this.buf.length * 2, this.count + additionalCapacity);\r\n        resize(newCapacity);\r\n    }\r\n}\n/**\r\n * Return the current size of this stream's internal buffer.\r\n */\r\npublic synchronized int capacity() {\r\n    return this.buf.length;\r\n}",
    "comment": "\n * An extension of {@link java.io.ByteArrayOutputStream} that:\n * <ul>\n * <li>has public {@link org.springframework.util.ResizableByteArrayOutputStream#grow(int)}\n * and {@link org.springframework.util.ResizableByteArrayOutputStream#resize(int)} methods\n * to get more control over the size of the internal buffer</li>\n * <li>has a higher initial capacity (256) by default</li>\n * </ul>\n *\n * <p>As of 4.2, this class has been superseded by {@link FastByteArrayOutputStream}\n * for Spring's internal use where no assignability to {@link ByteArrayOutputStream}\n * is needed (since {@link FastByteArrayOutputStream} is more efficient with buffer\n * resize management but doesn't extend the standard {@link ByteArrayOutputStream}).\n *\n * @author Brian Clozel\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see #resize\n * @see FastByteArrayOutputStream\n "
  },
  {
    "entityId": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
    "entityType": "method",
    "code": "/**\r\n * Resize the internal buffer size to a specified capacity.\r\n * @param targetCapacity the desired size of the buffer\r\n * @throws IllegalArgumentException if the given capacity is smaller than\r\n * the actual size of the content stored in the buffer already\r\n * @see ResizableByteArrayOutputStream#size()\r\n */\r\npublic synchronized void resize(int targetCapacity) {\r\n    Assert.isTrue(targetCapacity >= this.count, \"New capacity must not be smaller than current size\");\r\n    byte[] resizedBuffer = new byte[targetCapacity];\r\n    System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);\r\n    this.buf = resizedBuffer;\r\n}",
    "comment": "\n\t * Resize the internal buffer size to a specified capacity.\n\t * @param targetCapacity the desired size of the buffer\n\t * @throws IllegalArgumentException if the given capacity is smaller than\n\t * the actual size of the content stored in the buffer already\n\t * @see ResizableByteArrayOutputStream#size()\n\t "
  },
  {
    "entityId": "org.springframework.util.ResizableByteArrayOutputStream#grow(int)",
    "entityType": "method",
    "code": "/**\r\n * Grow the internal buffer size.\r\n * @param additionalCapacity the number of bytes to add to the current buffer size\r\n * @see ResizableByteArrayOutputStream#size()\r\n */\r\npublic synchronized void grow(int additionalCapacity) {\r\n    Assert.isTrue(additionalCapacity >= 0, \"Additional capacity must be 0 or higher\");\r\n    if (this.count + additionalCapacity > this.buf.length) {\r\n        int newCapacity = Math.max(this.buf.length * 2, this.count + additionalCapacity);\r\n        resize(newCapacity);\r\n    }\r\n}",
    "comment": "\n\t * Grow the internal buffer size.\n\t * @param additionalCapacity the number of bytes to add to the current buffer size\n\t * @see ResizableByteArrayOutputStream#size()\n\t "
  },
  {
    "entityId": "org.springframework.util.ResizableByteArrayOutputStream#capacity()",
    "entityType": "method",
    "code": "/**\r\n * Return the current size of this stream's internal buffer.\r\n */\r\npublic synchronized int capacity() {\r\n    return this.buf.length;\r\n}",
    "comment": "\n\t * Return the current size of this stream's internal buffer.\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils",
    "entityType": "class",
    "code": "/**\r\n * Pseudo URL prefix for loading from the class path: \"classpath:\".\r\n */\r\npublic static final String CLASSPATH_URL_PREFIX = \"classpath:\";\n/**\r\n * URL prefix for loading from the file system: \"file:\".\r\n */\r\npublic static final String FILE_URL_PREFIX = \"file:\";\n/**\r\n * URL prefix for loading from a jar file: \"jar:\".\r\n */\r\npublic static final String JAR_URL_PREFIX = \"jar:\";\n/**\r\n * URL prefix for loading from a war file on Tomcat: \"war:\".\r\n */\r\npublic static final String WAR_URL_PREFIX = \"war:\";\n/**\r\n * URL protocol for a file in the file system: \"file\".\r\n */\r\npublic static final String URL_PROTOCOL_FILE = \"file\";\n/**\r\n * URL protocol for an entry from a jar file: \"jar\".\r\n */\r\npublic static final String URL_PROTOCOL_JAR = \"jar\";\n/**\r\n * URL protocol for an entry from a war file: \"war\".\r\n */\r\npublic static final String URL_PROTOCOL_WAR = \"war\";\n/**\r\n * URL protocol for an entry from a zip file: \"zip\".\r\n */\r\npublic static final String URL_PROTOCOL_ZIP = \"zip\";\n/**\r\n * URL protocol for an entry from a WebSphere jar file: \"wsjar\".\r\n */\r\npublic static final String URL_PROTOCOL_WSJAR = \"wsjar\";\n/**\r\n * URL protocol for an entry from a JBoss jar file: \"vfszip\".\r\n */\r\npublic static final String URL_PROTOCOL_VFSZIP = \"vfszip\";\n/**\r\n * URL protocol for a JBoss file system resource: \"vfsfile\".\r\n */\r\npublic static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";\n/**\r\n * URL protocol for a general JBoss VFS resource: \"vfs\".\r\n */\r\npublic static final String URL_PROTOCOL_VFS = \"vfs\";\n/**\r\n * File extension for a regular jar file: \".jar\".\r\n */\r\npublic static final String JAR_FILE_EXTENSION = \".jar\";\n/**\r\n * Separator between JAR URL and file path within the JAR: \"!/\".\r\n */\r\npublic static final String JAR_URL_SEPARATOR = \"!/\";\n/**\r\n * Special separator between WAR URL and jar part on Tomcat.\r\n */\r\npublic static final String WAR_URL_SEPARATOR = \"*/\";\n/**\r\n * Return whether the given resource location is a URL:\r\n * either a special \"classpath\" pseudo URL or a standard URL.\r\n * @param resourceLocation the location String to check\r\n * @return whether the location qualifies as a URL\r\n * @see #CLASSPATH_URL_PREFIX\r\n * @see java.net.URL\r\n * @see #toURL(String)\r\n */\r\npublic static boolean isUrl(@Nullable String resourceLocation) {\r\n    if (resourceLocation == null) {\r\n        return false;\r\n    }\r\n    if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        return true;\r\n    }\r\n    try {\r\n        toURL(resourceLocation);\r\n        return true;\r\n    } catch (MalformedURLException ex) {\r\n        return false;\r\n    }\r\n}\n/**\r\n * Resolve the given resource location to a {@code java.net.URL}.\r\n * <p>Does not check whether the URL actually exists; simply returns\r\n * the URL that the given location would correspond to.\r\n * @param resourceLocation the resource location to resolve: either a\r\n * \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\r\n * @return a corresponding URL object\r\n * @throws FileNotFoundException if the resource cannot be resolved to a URL\r\n * @see #toURL(String)\r\n */\r\npublic static URL getURL(String resourceLocation) throws FileNotFoundException {\r\n    Assert.notNull(resourceLocation, \"Resource location must not be null\");\r\n    if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n        ClassLoader cl = ClassUtils.getDefaultClassLoader();\r\n        URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));\r\n        if (url == null) {\r\n            String description = \"class path resource [\" + path + \"]\";\r\n            throw new FileNotFoundException(description + \" cannot be resolved to URL because it does not exist\");\r\n        }\r\n        return url;\r\n    }\r\n    try {\r\n        // try URL\r\n        return toURL(resourceLocation);\r\n    } catch (MalformedURLException ex) {\r\n        // no URL -> treat as file path\r\n        try {\r\n            return new File(resourceLocation).toURI().toURL();\r\n        } catch (MalformedURLException ex2) {\r\n            throw new FileNotFoundException(\"Resource location [\" + resourceLocation + \"] is neither a URL not a well-formed file path\");\r\n        }\r\n    }\r\n}\n/**\r\n * Resolve the given resource location to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * <p>Does not check whether the file actually exists; simply returns\r\n * the File that the given location would correspond to.\r\n * @param resourceLocation the resource location to resolve: either a\r\n * \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the resource cannot be resolved to\r\n * a file in the file system\r\n * @see #getFile(URL)\r\n */\r\npublic static File getFile(String resourceLocation) throws FileNotFoundException {\r\n    Assert.notNull(resourceLocation, \"Resource location must not be null\");\r\n    if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n        String description = \"class path resource [\" + path + \"]\";\r\n        ClassLoader cl = ClassUtils.getDefaultClassLoader();\r\n        URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));\r\n        if (url == null) {\r\n            throw new FileNotFoundException(description + \" cannot be resolved to absolute file path because it does not exist\");\r\n        }\r\n        return getFile(url, description);\r\n    }\r\n    try {\r\n        // try URL\r\n        return getFile(toURL(resourceLocation));\r\n    } catch (MalformedURLException ex) {\r\n        // no URL -> treat as file path\r\n        return new File(resourceLocation);\r\n    }\r\n}\n/**\r\n * Resolve the given resource URL to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUrl the resource URL to resolve\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n * @see #getFile(URL, String)\r\n */\r\npublic static File getFile(URL resourceUrl) throws FileNotFoundException {\r\n    return getFile(resourceUrl, \"URL\");\r\n}\n/**\r\n * Resolve the given resource URL to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUrl the resource URL to resolve\r\n * @param description a description of the original resource that\r\n * the URL was created for (for example, a class path location)\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n */\r\npublic static File getFile(URL resourceUrl, String description) throws FileNotFoundException {\r\n    Assert.notNull(resourceUrl, \"Resource URL must not be null\");\r\n    if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {\r\n        throw new FileNotFoundException(description + \" cannot be resolved to absolute file path \" + \"because it does not reside in the file system: \" + resourceUrl);\r\n    }\r\n    try {\r\n        // URI decoding for special characters such as spaces.\r\n        return new File(toURI(resourceUrl).getSchemeSpecificPart());\r\n    } catch (URISyntaxException ex) {\r\n        // Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n        return new File(resourceUrl.getFile());\r\n    }\r\n}\n/**\r\n * Resolve the given resource URI to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUri the resource URI to resolve\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n * @since 2.5\r\n * @see #getFile(URI, String)\r\n */\r\npublic static File getFile(URI resourceUri) throws FileNotFoundException {\r\n    return getFile(resourceUri, \"URI\");\r\n}\n/**\r\n * Resolve the given resource URI to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUri the resource URI to resolve\r\n * @param description a description of the original resource that\r\n * the URI was created for (for example, a class path location)\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n * @since 2.5\r\n */\r\npublic static File getFile(URI resourceUri, String description) throws FileNotFoundException {\r\n    Assert.notNull(resourceUri, \"Resource URI must not be null\");\r\n    if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {\r\n        throw new FileNotFoundException(description + \" cannot be resolved to absolute file path \" + \"because it does not reside in the file system: \" + resourceUri);\r\n    }\r\n    return new File(resourceUri.getSchemeSpecificPart());\r\n}\n/**\r\n * Determine whether the given URL points to a resource in the file system,\r\n * i.e. has protocol \"file\", \"vfsfile\" or \"vfs\".\r\n * @param url the URL to check\r\n * @return whether the URL has been identified as a file system URL\r\n * @see #isJarURL(URL)\r\n */\r\npublic static boolean isFileURL(URL url) {\r\n    String protocol = url.getProtocol();\r\n    return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol) || URL_PROTOCOL_VFS.equals(protocol));\r\n}\n/**\r\n * Determine whether the given URL points to a resource in a jar file\r\n * &mdash; for example, whether the URL has protocol \"jar\", \"war, \"zip\",\r\n * \"vfszip\", or \"wsjar\".\r\n * @param url the URL to check\r\n * @return whether the URL has been identified as a JAR URL\r\n * @see #isJarFileURL(URL)\r\n */\r\npublic static boolean isJarURL(URL url) {\r\n    String protocol = url.getProtocol();\r\n    return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_WAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol));\r\n}\n/**\r\n * Determine whether the given URL points to a jar file itself,\r\n * that is, has protocol \"file\" and ends with the \".jar\" extension.\r\n * @param url the URL to check\r\n * @return whether the URL has been identified as a JAR file URL\r\n * @since 4.1\r\n * @see #extractJarFileURL(URL)\r\n */\r\npublic static boolean isJarFileURL(URL url) {\r\n    return (URL_PROTOCOL_FILE.equals(url.getProtocol()) && url.getPath().toLowerCase(Locale.ROOT).endsWith(JAR_FILE_EXTENSION));\r\n}\n/**\r\n * Extract the URL for the actual jar file from the given URL\r\n * (which may point to a resource in a jar file or to a jar file itself).\r\n * @param jarUrl the original URL\r\n * @return the URL for the actual jar file\r\n * @throws MalformedURLException if no valid jar file URL could be extracted\r\n * @see #extractArchiveURL(URL)\r\n */\r\npublic static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {\r\n    String urlFile = jarUrl.getFile();\r\n    int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);\r\n    if (separatorIndex != -1) {\r\n        String jarFile = urlFile.substring(0, separatorIndex);\r\n        try {\r\n            return toURL(jarFile);\r\n        } catch (MalformedURLException ex) {\r\n            // Probably no protocol in original jar URL, like \"jar:C:/mypath/myjar.jar\".\r\n            // This usually indicates that the jar file resides in the file system.\r\n            if (!jarFile.startsWith(\"/\")) {\r\n                jarFile = \"/\" + jarFile;\r\n            }\r\n            return toURL(FILE_URL_PREFIX + jarFile);\r\n        }\r\n    } else {\r\n        return jarUrl;\r\n    }\r\n}\n/**\r\n * Extract the URL for the outermost archive from the given jar/war URL\r\n * (which may point to a resource in a jar file or to a jar file itself).\r\n * <p>In the case of a jar file nested within a war file, this will return\r\n * a URL to the war file since that is the one resolvable in the file system.\r\n * @param jarUrl the original URL\r\n * @return the URL for the actual jar file\r\n * @throws MalformedURLException if no valid jar file URL could be extracted\r\n * @since 4.1.8\r\n * @see #extractJarFileURL(URL)\r\n */\r\npublic static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {\r\n    String urlFile = jarUrl.getFile();\r\n    int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);\r\n    if (endIndex != -1) {\r\n        // Tomcat's \"war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt\"\r\n        String warFile = urlFile.substring(0, endIndex);\r\n        if (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {\r\n            return toURL(warFile);\r\n        }\r\n        int startIndex = warFile.indexOf(WAR_URL_PREFIX);\r\n        if (startIndex != -1) {\r\n            return toURL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));\r\n        }\r\n    }\r\n    // Regular \"jar:file:...myjar.jar!/myentry.txt\"\r\n    return extractJarFileURL(jarUrl);\r\n}\n/**\r\n * Create a URI instance for the given URL,\r\n * replacing spaces with \"%20\" URI encoding first.\r\n * @param url the URL to convert into a URI instance\r\n * @return the URI instance\r\n * @throws URISyntaxException if the URL wasn't a valid URI\r\n * @see java.net.URL#toURI()\r\n * @see #toURI(String)\r\n */\r\npublic static URI toURI(URL url) throws URISyntaxException {\r\n    return toURI(url.toString());\r\n}\n/**\r\n * Create a URI instance for the given location String,\r\n * replacing spaces with \"%20\" URI encoding first.\r\n * @param location the location String to convert into a URI instance\r\n * @return the URI instance\r\n * @throws URISyntaxException if the location wasn't a valid URI\r\n * @see #toURI(URL)\r\n */\r\npublic static URI toURI(String location) throws URISyntaxException {\r\n    return new URI(StringUtils.replace(location, \" \", \"%20\"));\r\n}\n/**\r\n * Create a clean URL instance for the given location String,\r\n * going through URI construction and then URL conversion.\r\n * @param location the location String to convert into a URL instance\r\n * @return the URL instance\r\n * @throws MalformedURLException if the location wasn't a valid URL\r\n * @since 6.0\r\n * @see java.net.URI#toURL()\r\n * @see #toURI(String)\r\n */\r\n// on JDK 20 (deprecated URL constructor)\r\n@SuppressWarnings(\"deprecation\")\r\npublic static URL toURL(String location) throws MalformedURLException {\r\n    try {\r\n        // Prefer URI construction with toURL conversion (as of 6.1)\r\n        return toURI(StringUtils.cleanPath(location)).toURL();\r\n    } catch (URISyntaxException | IllegalArgumentException ex) {\r\n        // Lenient fallback to deprecated URL constructor,\r\n        // e.g. for decoded location Strings with percent characters.\r\n        return new URL(location);\r\n    }\r\n}\n/**\r\n * Create a clean URL instance for the given root URL and relative path,\r\n * going through URI construction and then URL conversion.\r\n * @param root the root URL to start from\r\n * @param relativePath the relative path to apply\r\n * @return the relative URL instance\r\n * @throws MalformedURLException if the end result is not a valid URL\r\n * @since 6.0\r\n * @see #toURL(String)\r\n * @see StringUtils#applyRelativePath\r\n */\r\n// on JDK 20 (deprecated URL constructor)\r\n@SuppressWarnings(\"deprecation\")\r\npublic static URL toRelativeURL(URL root, String relativePath) throws MalformedURLException {\r\n    // # can appear in filenames, java.net.URL should not treat it as a fragment\r\n    relativePath = StringUtils.replace(relativePath, \"#\", \"%23\");\r\n    // Retain original URL instance, potentially including custom URLStreamHandler.\r\n    return new URL(root, StringUtils.cleanPath(StringUtils.applyRelativePath(root.toString(), relativePath)));\r\n}\n/**\r\n * Set the {@link URLConnection#setUseCaches \"useCaches\"} flag on the\r\n * given connection, preferring {@code false} but leaving the flag at\r\n * its JVM default value for jar resources (typically {@code true}).\r\n * @param con the URLConnection to set the flag on\r\n * @see URLConnection#setUseCaches\r\n */\r\npublic static void useCachesIfNecessary(URLConnection con) {\r\n    if (!(con instanceof JarURLConnection)) {\r\n        con.setUseCaches(false);\r\n    }\r\n}",
    "comment": "\n * Utility methods for resolving resource locations to files in the\n * file system. Mainly for internal use within the framework.\n *\n * <p>Consider using Spring's Resource abstraction in the core package\n * for handling all kinds of file resources in a uniform manner.\n * {@link org.springframework.core.io.ResourceLoader}'s {@code getResource()}\n * method can resolve any location to a {@link org.springframework.core.io.Resource}\n * object, which in turn allows one to obtain a {@code java.io.File} in the\n * file system through its {@code getFile()} method.\n *\n * @author Juergen Hoeller\n * @since 1.1.5\n * @see org.springframework.core.io.Resource\n * @see org.springframework.core.io.ClassPathResource\n * @see org.springframework.core.io.FileSystemResource\n * @see org.springframework.core.io.UrlResource\n * @see org.springframework.core.io.ResourceLoader\n "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#isUrl(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the given resource location is a URL:\r\n * either a special \"classpath\" pseudo URL or a standard URL.\r\n * @param resourceLocation the location String to check\r\n * @return whether the location qualifies as a URL\r\n * @see #CLASSPATH_URL_PREFIX\r\n * @see java.net.URL\r\n * @see #toURL(String)\r\n */\r\npublic static boolean isUrl(@Nullable String resourceLocation) {\r\n    if (resourceLocation == null) {\r\n        return false;\r\n    }\r\n    if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        return true;\r\n    }\r\n    try {\r\n        toURL(resourceLocation);\r\n        return true;\r\n    } catch (MalformedURLException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Return whether the given resource location is a URL:\n\t * either a special \"classpath\" pseudo URL or a standard URL.\n\t * @param resourceLocation the location String to check\n\t * @return whether the location qualifies as a URL\n\t * @see #CLASSPATH_URL_PREFIX\n\t * @see java.net.URL\n\t * @see #toURL(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#getURL(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given resource location to a {@code java.net.URL}.\r\n * <p>Does not check whether the URL actually exists; simply returns\r\n * the URL that the given location would correspond to.\r\n * @param resourceLocation the resource location to resolve: either a\r\n * \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\r\n * @return a corresponding URL object\r\n * @throws FileNotFoundException if the resource cannot be resolved to a URL\r\n * @see #toURL(String)\r\n */\r\npublic static URL getURL(String resourceLocation) throws FileNotFoundException {\r\n    Assert.notNull(resourceLocation, \"Resource location must not be null\");\r\n    if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n        ClassLoader cl = ClassUtils.getDefaultClassLoader();\r\n        URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));\r\n        if (url == null) {\r\n            String description = \"class path resource [\" + path + \"]\";\r\n            throw new FileNotFoundException(description + \" cannot be resolved to URL because it does not exist\");\r\n        }\r\n        return url;\r\n    }\r\n    try {\r\n        // try URL\r\n        return toURL(resourceLocation);\r\n    } catch (MalformedURLException ex) {\r\n        // no URL -> treat as file path\r\n        try {\r\n            return new File(resourceLocation).toURI().toURL();\r\n        } catch (MalformedURLException ex2) {\r\n            throw new FileNotFoundException(\"Resource location [\" + resourceLocation + \"] is neither a URL not a well-formed file path\");\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Resolve the given resource location to a {@code java.net.URL}.\n\t * <p>Does not check whether the URL actually exists; simply returns\n\t * the URL that the given location would correspond to.\n\t * @param resourceLocation the resource location to resolve: either a\n\t * \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\n\t * @return a corresponding URL object\n\t * @throws FileNotFoundException if the resource cannot be resolved to a URL\n\t * @see #toURL(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#getFile(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given resource location to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * <p>Does not check whether the file actually exists; simply returns\r\n * the File that the given location would correspond to.\r\n * @param resourceLocation the resource location to resolve: either a\r\n * \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the resource cannot be resolved to\r\n * a file in the file system\r\n * @see #getFile(URL)\r\n */\r\npublic static File getFile(String resourceLocation) throws FileNotFoundException {\r\n    Assert.notNull(resourceLocation, \"Resource location must not be null\");\r\n    if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {\r\n        String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());\r\n        String description = \"class path resource [\" + path + \"]\";\r\n        ClassLoader cl = ClassUtils.getDefaultClassLoader();\r\n        URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));\r\n        if (url == null) {\r\n            throw new FileNotFoundException(description + \" cannot be resolved to absolute file path because it does not exist\");\r\n        }\r\n        return getFile(url, description);\r\n    }\r\n    try {\r\n        // try URL\r\n        return getFile(toURL(resourceLocation));\r\n    } catch (MalformedURLException ex) {\r\n        // no URL -> treat as file path\r\n        return new File(resourceLocation);\r\n    }\r\n}",
    "comment": "\n\t * Resolve the given resource location to a {@code java.io.File},\n\t * i.e. to a file in the file system.\n\t * <p>Does not check whether the file actually exists; simply returns\n\t * the File that the given location would correspond to.\n\t * @param resourceLocation the resource location to resolve: either a\n\t * \"classpath:\" pseudo URL, a \"file:\" URL, or a plain file path\n\t * @return a corresponding File object\n\t * @throws FileNotFoundException if the resource cannot be resolved to\n\t * a file in the file system\n\t * @see #getFile(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#getFile(URL)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given resource URL to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUrl the resource URL to resolve\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n * @see #getFile(URL, String)\r\n */\r\npublic static File getFile(URL resourceUrl) throws FileNotFoundException {\r\n    return getFile(resourceUrl, \"URL\");\r\n}",
    "comment": "\n\t * Resolve the given resource URL to a {@code java.io.File},\n\t * i.e. to a file in the file system.\n\t * @param resourceUrl the resource URL to resolve\n\t * @return a corresponding File object\n\t * @throws FileNotFoundException if the URL cannot be resolved to\n\t * a file in the file system\n\t * @see #getFile(URL, String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#getFile(URL,String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given resource URL to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUrl the resource URL to resolve\r\n * @param description a description of the original resource that\r\n * the URL was created for (for example, a class path location)\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n */\r\npublic static File getFile(URL resourceUrl, String description) throws FileNotFoundException {\r\n    Assert.notNull(resourceUrl, \"Resource URL must not be null\");\r\n    if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {\r\n        throw new FileNotFoundException(description + \" cannot be resolved to absolute file path \" + \"because it does not reside in the file system: \" + resourceUrl);\r\n    }\r\n    try {\r\n        // URI decoding for special characters such as spaces.\r\n        return new File(toURI(resourceUrl).getSchemeSpecificPart());\r\n    } catch (URISyntaxException ex) {\r\n        // Fallback for URLs that are not valid URIs (should hardly ever happen).\r\n        return new File(resourceUrl.getFile());\r\n    }\r\n}",
    "comment": "\n\t * Resolve the given resource URL to a {@code java.io.File},\n\t * i.e. to a file in the file system.\n\t * @param resourceUrl the resource URL to resolve\n\t * @param description a description of the original resource that\n\t * the URL was created for (for example, a class path location)\n\t * @return a corresponding File object\n\t * @throws FileNotFoundException if the URL cannot be resolved to\n\t * a file in the file system\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#getFile(URI)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given resource URI to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUri the resource URI to resolve\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n * @since 2.5\r\n * @see #getFile(URI, String)\r\n */\r\npublic static File getFile(URI resourceUri) throws FileNotFoundException {\r\n    return getFile(resourceUri, \"URI\");\r\n}",
    "comment": "\n\t * Resolve the given resource URI to a {@code java.io.File},\n\t * i.e. to a file in the file system.\n\t * @param resourceUri the resource URI to resolve\n\t * @return a corresponding File object\n\t * @throws FileNotFoundException if the URL cannot be resolved to\n\t * a file in the file system\n\t * @since 2.5\n\t * @see #getFile(URI, String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#getFile(URI,String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given resource URI to a {@code java.io.File},\r\n * i.e. to a file in the file system.\r\n * @param resourceUri the resource URI to resolve\r\n * @param description a description of the original resource that\r\n * the URI was created for (for example, a class path location)\r\n * @return a corresponding File object\r\n * @throws FileNotFoundException if the URL cannot be resolved to\r\n * a file in the file system\r\n * @since 2.5\r\n */\r\npublic static File getFile(URI resourceUri, String description) throws FileNotFoundException {\r\n    Assert.notNull(resourceUri, \"Resource URI must not be null\");\r\n    if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {\r\n        throw new FileNotFoundException(description + \" cannot be resolved to absolute file path \" + \"because it does not reside in the file system: \" + resourceUri);\r\n    }\r\n    return new File(resourceUri.getSchemeSpecificPart());\r\n}",
    "comment": "\n\t * Resolve the given resource URI to a {@code java.io.File},\n\t * i.e. to a file in the file system.\n\t * @param resourceUri the resource URI to resolve\n\t * @param description a description of the original resource that\n\t * the URI was created for (for example, a class path location)\n\t * @return a corresponding File object\n\t * @throws FileNotFoundException if the URL cannot be resolved to\n\t * a file in the file system\n\t * @since 2.5\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#isFileURL(URL)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given URL points to a resource in the file system,\r\n * i.e. has protocol \"file\", \"vfsfile\" or \"vfs\".\r\n * @param url the URL to check\r\n * @return whether the URL has been identified as a file system URL\r\n * @see #isJarURL(URL)\r\n */\r\npublic static boolean isFileURL(URL url) {\r\n    String protocol = url.getProtocol();\r\n    return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol) || URL_PROTOCOL_VFS.equals(protocol));\r\n}",
    "comment": "\n\t * Determine whether the given URL points to a resource in the file system,\n\t * i.e. has protocol \"file\", \"vfsfile\" or \"vfs\".\n\t * @param url the URL to check\n\t * @return whether the URL has been identified as a file system URL\n\t * @see #isJarURL(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#isJarURL(URL)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given URL points to a resource in a jar file\r\n * &mdash; for example, whether the URL has protocol \"jar\", \"war, \"zip\",\r\n * \"vfszip\", or \"wsjar\".\r\n * @param url the URL to check\r\n * @return whether the URL has been identified as a JAR URL\r\n * @see #isJarFileURL(URL)\r\n */\r\npublic static boolean isJarURL(URL url) {\r\n    String protocol = url.getProtocol();\r\n    return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_WAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol));\r\n}",
    "comment": "\n\t * Determine whether the given URL points to a resource in a jar file\n\t * &mdash; for example, whether the URL has protocol \"jar\", \"war, \"zip\",\n\t * \"vfszip\", or \"wsjar\".\n\t * @param url the URL to check\n\t * @return whether the URL has been identified as a JAR URL\n\t * @see #isJarFileURL(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#isJarFileURL(URL)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given URL points to a jar file itself,\r\n * that is, has protocol \"file\" and ends with the \".jar\" extension.\r\n * @param url the URL to check\r\n * @return whether the URL has been identified as a JAR file URL\r\n * @since 4.1\r\n * @see #extractJarFileURL(URL)\r\n */\r\npublic static boolean isJarFileURL(URL url) {\r\n    return (URL_PROTOCOL_FILE.equals(url.getProtocol()) && url.getPath().toLowerCase(Locale.ROOT).endsWith(JAR_FILE_EXTENSION));\r\n}",
    "comment": "\n\t * Determine whether the given URL points to a jar file itself,\n\t * that is, has protocol \"file\" and ends with the \".jar\" extension.\n\t * @param url the URL to check\n\t * @return whether the URL has been identified as a JAR file URL\n\t * @since 4.1\n\t * @see #extractJarFileURL(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
    "entityType": "method",
    "code": "/**\r\n * Extract the URL for the actual jar file from the given URL\r\n * (which may point to a resource in a jar file or to a jar file itself).\r\n * @param jarUrl the original URL\r\n * @return the URL for the actual jar file\r\n * @throws MalformedURLException if no valid jar file URL could be extracted\r\n * @see #extractArchiveURL(URL)\r\n */\r\npublic static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {\r\n    String urlFile = jarUrl.getFile();\r\n    int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);\r\n    if (separatorIndex != -1) {\r\n        String jarFile = urlFile.substring(0, separatorIndex);\r\n        try {\r\n            return toURL(jarFile);\r\n        } catch (MalformedURLException ex) {\r\n            // Probably no protocol in original jar URL, like \"jar:C:/mypath/myjar.jar\".\r\n            // This usually indicates that the jar file resides in the file system.\r\n            if (!jarFile.startsWith(\"/\")) {\r\n                jarFile = \"/\" + jarFile;\r\n            }\r\n            return toURL(FILE_URL_PREFIX + jarFile);\r\n        }\r\n    } else {\r\n        return jarUrl;\r\n    }\r\n}",
    "comment": "\n\t * Extract the URL for the actual jar file from the given URL\n\t * (which may point to a resource in a jar file or to a jar file itself).\n\t * @param jarUrl the original URL\n\t * @return the URL for the actual jar file\n\t * @throws MalformedURLException if no valid jar file URL could be extracted\n\t * @see #extractArchiveURL(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
    "entityType": "method",
    "code": "/**\r\n * Extract the URL for the outermost archive from the given jar/war URL\r\n * (which may point to a resource in a jar file or to a jar file itself).\r\n * <p>In the case of a jar file nested within a war file, this will return\r\n * a URL to the war file since that is the one resolvable in the file system.\r\n * @param jarUrl the original URL\r\n * @return the URL for the actual jar file\r\n * @throws MalformedURLException if no valid jar file URL could be extracted\r\n * @since 4.1.8\r\n * @see #extractJarFileURL(URL)\r\n */\r\npublic static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {\r\n    String urlFile = jarUrl.getFile();\r\n    int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);\r\n    if (endIndex != -1) {\r\n        // Tomcat's \"war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt\"\r\n        String warFile = urlFile.substring(0, endIndex);\r\n        if (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {\r\n            return toURL(warFile);\r\n        }\r\n        int startIndex = warFile.indexOf(WAR_URL_PREFIX);\r\n        if (startIndex != -1) {\r\n            return toURL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));\r\n        }\r\n    }\r\n    // Regular \"jar:file:...myjar.jar!/myentry.txt\"\r\n    return extractJarFileURL(jarUrl);\r\n}",
    "comment": "\n\t * Extract the URL for the outermost archive from the given jar/war URL\n\t * (which may point to a resource in a jar file or to a jar file itself).\n\t * <p>In the case of a jar file nested within a war file, this will return\n\t * a URL to the war file since that is the one resolvable in the file system.\n\t * @param jarUrl the original URL\n\t * @return the URL for the actual jar file\n\t * @throws MalformedURLException if no valid jar file URL could be extracted\n\t * @since 4.1.8\n\t * @see #extractJarFileURL(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#toURI(URL)",
    "entityType": "method",
    "code": "/**\r\n * Create a URI instance for the given URL,\r\n * replacing spaces with \"%20\" URI encoding first.\r\n * @param url the URL to convert into a URI instance\r\n * @return the URI instance\r\n * @throws URISyntaxException if the URL wasn't a valid URI\r\n * @see java.net.URL#toURI()\r\n * @see #toURI(String)\r\n */\r\npublic static URI toURI(URL url) throws URISyntaxException {\r\n    return toURI(url.toString());\r\n}",
    "comment": "\n\t * Create a URI instance for the given URL,\n\t * replacing spaces with \"%20\" URI encoding first.\n\t * @param url the URL to convert into a URI instance\n\t * @return the URI instance\n\t * @throws URISyntaxException if the URL wasn't a valid URI\n\t * @see java.net.URL#toURI()\n\t * @see #toURI(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#toURI(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a URI instance for the given location String,\r\n * replacing spaces with \"%20\" URI encoding first.\r\n * @param location the location String to convert into a URI instance\r\n * @return the URI instance\r\n * @throws URISyntaxException if the location wasn't a valid URI\r\n * @see #toURI(URL)\r\n */\r\npublic static URI toURI(String location) throws URISyntaxException {\r\n    return new URI(StringUtils.replace(location, \" \", \"%20\"));\r\n}",
    "comment": "\n\t * Create a URI instance for the given location String,\n\t * replacing spaces with \"%20\" URI encoding first.\n\t * @param location the location String to convert into a URI instance\n\t * @return the URI instance\n\t * @throws URISyntaxException if the location wasn't a valid URI\n\t * @see #toURI(URL)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#toURL(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a clean URL instance for the given location String,\r\n * going through URI construction and then URL conversion.\r\n * @param location the location String to convert into a URL instance\r\n * @return the URL instance\r\n * @throws MalformedURLException if the location wasn't a valid URL\r\n * @since 6.0\r\n * @see java.net.URI#toURL()\r\n * @see #toURI(String)\r\n */\r\n// on JDK 20 (deprecated URL constructor)\r\n@SuppressWarnings(\"deprecation\")\r\npublic static URL toURL(String location) throws MalformedURLException {\r\n    try {\r\n        // Prefer URI construction with toURL conversion (as of 6.1)\r\n        return toURI(StringUtils.cleanPath(location)).toURL();\r\n    } catch (URISyntaxException | IllegalArgumentException ex) {\r\n        // Lenient fallback to deprecated URL constructor,\r\n        // e.g. for decoded location Strings with percent characters.\r\n        return new URL(location);\r\n    }\r\n}",
    "comment": "\n\t * Create a clean URL instance for the given location String,\n\t * going through URI construction and then URL conversion.\n\t * @param location the location String to convert into a URL instance\n\t * @return the URL instance\n\t * @throws MalformedURLException if the location wasn't a valid URL\n\t * @since 6.0\n\t * @see java.net.URI#toURL()\n\t * @see #toURI(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
    "entityType": "method",
    "code": "/**\r\n * Create a clean URL instance for the given root URL and relative path,\r\n * going through URI construction and then URL conversion.\r\n * @param root the root URL to start from\r\n * @param relativePath the relative path to apply\r\n * @return the relative URL instance\r\n * @throws MalformedURLException if the end result is not a valid URL\r\n * @since 6.0\r\n * @see #toURL(String)\r\n * @see StringUtils#applyRelativePath\r\n */\r\n// on JDK 20 (deprecated URL constructor)\r\n@SuppressWarnings(\"deprecation\")\r\npublic static URL toRelativeURL(URL root, String relativePath) throws MalformedURLException {\r\n    // # can appear in filenames, java.net.URL should not treat it as a fragment\r\n    relativePath = StringUtils.replace(relativePath, \"#\", \"%23\");\r\n    // Retain original URL instance, potentially including custom URLStreamHandler.\r\n    return new URL(root, StringUtils.cleanPath(StringUtils.applyRelativePath(root.toString(), relativePath)));\r\n}",
    "comment": "\n\t * Create a clean URL instance for the given root URL and relative path,\n\t * going through URI construction and then URL conversion.\n\t * @param root the root URL to start from\n\t * @param relativePath the relative path to apply\n\t * @return the relative URL instance\n\t * @throws MalformedURLException if the end result is not a valid URL\n\t * @since 6.0\n\t * @see #toURL(String)\n\t * @see StringUtils#applyRelativePath\n\t "
  },
  {
    "entityId": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
    "entityType": "method",
    "code": "/**\r\n * Set the {@link URLConnection#setUseCaches \"useCaches\"} flag on the\r\n * given connection, preferring {@code false} but leaving the flag at\r\n * its JVM default value for jar resources (typically {@code true}).\r\n * @param con the URLConnection to set the flag on\r\n * @see URLConnection#setUseCaches\r\n */\r\npublic static void useCachesIfNecessary(URLConnection con) {\r\n    if (!(con instanceof JarURLConnection)) {\r\n        con.setUseCaches(false);\r\n    }\r\n}",
    "comment": "\n\t * Set the {@link URLConnection#setUseCaches \"useCaches\"} flag on the\n\t * given connection, preferring {@code false} but leaving the flag at\n\t * its JVM default value for jar resources (typically {@code true}).\n\t * @param con the URLConnection to set the flag on\n\t * @see URLConnection#setUseCaches\n\t "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher",
    "entityType": "class",
    "code": "/**\r\n * Return a parsed representation of the given route.\r\n * @param routeValue the route to parse\r\n * @return the parsed representation of the route\r\n */\r\nRoute parseRoute(String routeValue);\n/**\r\n * Whether the given {@code route} contains pattern syntax which requires\r\n * the {@link #match(String, Route)} method, or if it is a regular String\r\n * that could be compared directly to others.\r\n * @param route the route to check\r\n * @return {@code true} if the given {@code route} represents a pattern\r\n */\r\nboolean isPattern(String route);\n/**\r\n * Combines two patterns into a single pattern.\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException when the two patterns cannot be combined\r\n */\r\nString combine(String pattern1, String pattern2);\n/**\r\n * Match the given route against the given pattern.\r\n * @param pattern the pattern to try to match\r\n * @param route the route to test against\r\n * @return {@code true} if there is a match, {@code false} otherwise\r\n */\r\nboolean match(String pattern, Route route);\n/**\r\n * Match the pattern to the route and extract template variables.\r\n * @param pattern the pattern, possibly containing templates variables\r\n * @param route the route to extract template variables from\r\n * @return a map with template variables and values\r\n */\r\n@Nullable\r\nMap<String, String> matchAndExtract(String pattern, Route route);\n/**\r\n * Given a route, return a {@link Comparator} suitable for sorting patterns\r\n * in order of explicitness for that route, so that more specific patterns\r\n * come before more generic ones.\r\n * @param route the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\nComparator<String> getPatternComparator(Route route);\n/**\r\n * A parsed representation of a route.\r\n */\r\ninterface Route {\r\n\r\n    /**\r\n     * The original route value.\r\n     */\r\n    String value();\r\n}",
    "comment": "\n * Contract for matching routes to patterns.\n *\n * <p>Equivalent to {@link PathMatcher}, but enables use of parsed representations\n * of routes and patterns for efficiency reasons in scenarios where routes from\n * incoming messages are continuously matched against a large number of message\n * handler patterns.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n * @see PathMatcher\n "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher#parseRoute(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a parsed representation of the given route.\r\n * @param routeValue the route to parse\r\n * @return the parsed representation of the route\r\n */\r\nRoute parseRoute(String routeValue);",
    "comment": "\n\t * Return a parsed representation of the given route.\n\t * @param routeValue the route to parse\n\t * @return the parsed representation of the route\n\t "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher#isPattern(String)",
    "entityType": "method",
    "code": "/**\r\n * Whether the given {@code route} contains pattern syntax which requires\r\n * the {@link #match(String, Route)} method, or if it is a regular String\r\n * that could be compared directly to others.\r\n * @param route the route to check\r\n * @return {@code true} if the given {@code route} represents a pattern\r\n */\r\nboolean isPattern(String route);",
    "comment": "\n\t * Whether the given {@code route} contains pattern syntax which requires\n\t * the {@link #match(String, Route)} method, or if it is a regular String\n\t * that could be compared directly to others.\n\t * @param route the route to check\n\t * @return {@code true} if the given {@code route} represents a pattern\n\t "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher#combine(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Combines two patterns into a single pattern.\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException when the two patterns cannot be combined\r\n */\r\nString combine(String pattern1, String pattern2);",
    "comment": "\n\t * Combines two patterns into a single pattern.\n\t * @param pattern1 the first pattern\n\t * @param pattern2 the second pattern\n\t * @return the combination of the two patterns\n\t * @throws IllegalArgumentException when the two patterns cannot be combined\n\t "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher#match(String,Route)",
    "entityType": "method",
    "code": "/**\r\n * Match the given route against the given pattern.\r\n * @param pattern the pattern to try to match\r\n * @param route the route to test against\r\n * @return {@code true} if there is a match, {@code false} otherwise\r\n */\r\nboolean match(String pattern, Route route);",
    "comment": "\n\t * Match the given route against the given pattern.\n\t * @param pattern the pattern to try to match\n\t * @param route the route to test against\n\t * @return {@code true} if there is a match, {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
    "entityType": "method",
    "code": "/**\r\n * Match the pattern to the route and extract template variables.\r\n * @param pattern the pattern, possibly containing templates variables\r\n * @param route the route to extract template variables from\r\n * @return a map with template variables and values\r\n */\r\n@Nullable\r\nMap<String, String> matchAndExtract(String pattern, Route route);",
    "comment": "\n\t * Match the pattern to the route and extract template variables.\n\t * @param pattern the pattern, possibly containing templates variables\n\t * @param route the route to extract template variables from\n\t * @return a map with template variables and values\n\t "
  },
  {
    "entityId": "org.springframework.util.RouteMatcher#getPatternComparator(Route)",
    "entityType": "method",
    "code": "/**\r\n * Given a route, return a {@link Comparator} suitable for sorting patterns\r\n * in order of explicitness for that route, so that more specific patterns\r\n * come before more generic ones.\r\n * @param route the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\nComparator<String> getPatternComparator(Route route);",
    "comment": "\n\t * Given a route, return a {@link Comparator} suitable for sorting patterns\n\t * in order of explicitness for that route, so that more specific patterns\n\t * come before more generic ones.\n\t * @param route the full path to use for comparison\n\t * @return a comparator capable of sorting patterns in order of explicitness\n\t "
  },
  {
    "entityId": "org.springframework.util.Route",
    "entityType": "class",
    "code": "/**\r\n * The original route value.\r\n */\r\nString value();",
    "comment": "\n\t * A parsed representation of a route.\n \t "
  },
  {
    "entityId": "org.springframework.util.Route#value()",
    "entityType": "method",
    "code": "/**\r\n * The original route value.\r\n */\r\nString value();",
    "comment": "\n\t\t * The original route value.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.SerializationUtils",
    "entityType": "class",
    "code": "/**\r\n * Serialize the given object to a byte array.\r\n * @param object the object to serialize\r\n * @return an array of bytes representing the object in a portable fashion\r\n */\r\npublic static byte @Nullable [] serialize(@Nullable Object object) {\r\n    if (object == null) {\r\n        return null;\r\n    }\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(object);\r\n        oos.flush();\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Failed to serialize object of type: \" + object.getClass(), ex);\r\n    }\r\n    return baos.toByteArray();\r\n}\n/**\r\n * Deserialize the byte array into an object.\r\n * @param bytes a serialized object\r\n * @return the result of deserializing the bytes\r\n * @deprecated This utility uses Java Object Serialization, which allows\r\n * arbitrary code to be run and is known for being the source of many Remote\r\n * Code Execution (RCE) vulnerabilities.\r\n * <p>Prefer the use of an external tool (that serializes to JSON, XML, or\r\n * any other format) which is regularly checked and updated for not allowing RCE.\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Object deserialize(byte @Nullable [] bytes) {\r\n    if (bytes == null) {\r\n        return null;\r\n    }\r\n    try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {\r\n        return ois.readObject();\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Failed to deserialize object\", ex);\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new IllegalStateException(\"Failed to deserialize object type\", ex);\r\n    }\r\n}\n/**\r\n * Clone the given object using Java Object Serialization.\r\n * @param object the object to clone\r\n * @param <T> the type of the object to clone\r\n * @return a clone (deep-copy) of the given object\r\n * @since 6.0\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Serializable> T clone(T object) {\r\n    Object result = SerializationUtils.deserialize(SerializationUtils.serialize(object));\r\n    Assert.state(result != null, \"Deserialized object must not be null\");\r\n    return (T) result;\r\n}",
    "comment": "\n * Static utilities for serialization and deserialization using\n * <a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/\"\n * target=\"_blank\">Java Object Serialization</a>.\n *\n * <p><strong>WARNING</strong>: These utilities should be used with caution. See\n * <a href=\"https://www.oracle.com/java/technologies/javase/seccodeguide.html#8\"\n * target=\"_blank\">Secure Coding Guidelines for the Java Programming Language</a>\n * for details.\n *\n * @author Dave Syer\n * @author Loc Ledoyen\n * @author Sam Brannen\n * @since 3.0.5\n "
  },
  {
    "entityId": "org.springframework.util.SerializationUtils#serialize(Object)",
    "entityType": "method",
    "code": "/**\r\n * Serialize the given object to a byte array.\r\n * @param object the object to serialize\r\n * @return an array of bytes representing the object in a portable fashion\r\n */\r\npublic static byte @Nullable [] serialize(@Nullable Object object) {\r\n    if (object == null) {\r\n        return null;\r\n    }\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(object);\r\n        oos.flush();\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Failed to serialize object of type: \" + object.getClass(), ex);\r\n    }\r\n    return baos.toByteArray();\r\n}",
    "comment": "\n\t * Serialize the given object to a byte array.\n\t * @param object the object to serialize\n\t * @return an array of bytes representing the object in a portable fashion\n\t "
  },
  {
    "entityId": "org.springframework.util.SerializationUtils#deserialize(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Deserialize the byte array into an object.\r\n * @param bytes a serialized object\r\n * @return the result of deserializing the bytes\r\n * @deprecated This utility uses Java Object Serialization, which allows\r\n * arbitrary code to be run and is known for being the source of many Remote\r\n * Code Execution (RCE) vulnerabilities.\r\n * <p>Prefer the use of an external tool (that serializes to JSON, XML, or\r\n * any other format) which is regularly checked and updated for not allowing RCE.\r\n */\r\n@Deprecated\r\n@Nullable\r\npublic static Object deserialize(byte @Nullable [] bytes) {\r\n    if (bytes == null) {\r\n        return null;\r\n    }\r\n    try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {\r\n        return ois.readObject();\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Failed to deserialize object\", ex);\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new IllegalStateException(\"Failed to deserialize object type\", ex);\r\n    }\r\n}",
    "comment": "\n\t * Deserialize the byte array into an object.\n\t * @param bytes a serialized object\n\t * @return the result of deserializing the bytes\n\t * @deprecated This utility uses Java Object Serialization, which allows\n\t * arbitrary code to be run and is known for being the source of many Remote\n\t * Code Execution (RCE) vulnerabilities.\n\t * <p>Prefer the use of an external tool (that serializes to JSON, XML, or\n\t * any other format) which is regularly checked and updated for not allowing RCE.\n\t "
  },
  {
    "entityId": "org.springframework.util.SerializationUtils#clone(T)",
    "entityType": "method",
    "code": "/**\r\n * Clone the given object using Java Object Serialization.\r\n * @param object the object to clone\r\n * @param <T> the type of the object to clone\r\n * @return a clone (deep-copy) of the given object\r\n * @since 6.0\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Serializable> T clone(T object) {\r\n    Object result = SerializationUtils.deserialize(SerializationUtils.serialize(object));\r\n    Assert.state(result != null, \"Deserialized object must not be null\");\r\n    return (T) result;\r\n}",
    "comment": "\n\t * Clone the given object using Java Object Serialization.\n\t * @param object the object to clone\n\t * @param <T> the type of the object to clone\n\t * @return a clone (deep-copy) of the given object\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.util.SimpleIdGenerator",
    "entityType": "class",
    "code": "private final AtomicLong leastSigBits = new AtomicLong();\n@Override\r\npublic UUID generateId() {\r\n    return new UUID(0, this.leastSigBits.incrementAndGet());\r\n}",
    "comment": "\n * A simple {@link IdGenerator} that starts at 1, increments up to\n * {@link Long#MAX_VALUE}, and then rolls over.\n *\n * @author Rossen Stoyanchev\n * @since 4.1.5\n "
  },
  {
    "entityId": "org.springframework.util.SimpleIdGenerator#generateId()",
    "entityType": "method",
    "code": "@Override\r\npublic UUID generateId() {\r\n    return new UUID(0, this.leastSigBits.incrementAndGet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher",
    "entityType": "class",
    "code": "private final PathMatcher pathMatcher;\n/**\r\n * Create a new {@code SimpleRouteMatcher} for the given\r\n * {@link PathMatcher} delegate.\r\n */\r\npublic SimpleRouteMatcher(PathMatcher pathMatcher) {\r\n    Assert.notNull(pathMatcher, \"PathMatcher is required\");\r\n    this.pathMatcher = pathMatcher;\r\n}\n/**\r\n * Return the underlying {@link PathMatcher} delegate.\r\n */\r\npublic PathMatcher getPathMatcher() {\r\n    return this.pathMatcher;\r\n}\n@Override\r\npublic Route parseRoute(String route) {\r\n    return new DefaultRoute(route);\r\n}\n@Override\r\npublic boolean isPattern(String route) {\r\n    return this.pathMatcher.isPattern(route);\r\n}\n@Override\r\npublic String combine(String pattern1, String pattern2) {\r\n    return this.pathMatcher.combine(pattern1, pattern2);\r\n}\n@Override\r\npublic boolean match(String pattern, Route route) {\r\n    return this.pathMatcher.match(pattern, route.value());\r\n}\n@Override\r\n@Nullable\r\npublic Map<String, String> matchAndExtract(String pattern, Route route) {\r\n    if (!match(pattern, route)) {\r\n        return null;\r\n    }\r\n    return this.pathMatcher.extractUriTemplateVariables(pattern, route.value());\r\n}\n@Override\r\npublic Comparator<String> getPatternComparator(Route route) {\r\n    return this.pathMatcher.getPatternComparator(route.value());\r\n}\nprivate static class DefaultRoute implements Route {\r\n\r\n    private final String path;\r\n\r\n    DefaultRoute(String path) {\r\n        this.path = path;\r\n    }\r\n\r\n    @Override\r\n    public String value() {\r\n        return this.path;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return value();\r\n    }\r\n}",
    "comment": "\n * {@code RouteMatcher} that delegates to a {@link PathMatcher}.\n *\n * <p><strong>Note:</strong> This implementation is not efficient since\n * {@code PathMatcher} treats paths and patterns as Strings. For more optimized\n * performance use the {@code PathPatternRouteMatcher} from {@code spring-web}\n * which enables use of parsed routes and patterns.\n *\n * @author Rossen Stoyanchev\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#getPathMatcher()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying {@link PathMatcher} delegate.\r\n */\r\npublic PathMatcher getPathMatcher() {\r\n    return this.pathMatcher;\r\n}",
    "comment": "\n\t * Return the underlying {@link PathMatcher} delegate.\n\t "
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#parseRoute(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Route parseRoute(String route) {\r\n    return new DefaultRoute(route);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#isPattern(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isPattern(String route) {\r\n    return this.pathMatcher.isPattern(route);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#combine(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic String combine(String pattern1, String pattern2) {\r\n    return this.pathMatcher.combine(pattern1, pattern2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#match(String,Route)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean match(String pattern, Route route) {\r\n    return this.pathMatcher.match(pattern, route.value());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#matchAndExtract(String,Route)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Map<String, String> matchAndExtract(String pattern, Route route) {\r\n    if (!match(pattern, route)) {\r\n        return null;\r\n    }\r\n    return this.pathMatcher.extractUriTemplateVariables(pattern, route.value());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimpleRouteMatcher#getPatternComparator(Route)",
    "entityType": "method",
    "code": "@Override\r\npublic Comparator<String> getPatternComparator(Route route) {\r\n    return this.pathMatcher.getPatternComparator(route.value());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultRoute",
    "entityType": "class",
    "code": "private final String path;\nDefaultRoute(String path) {\r\n    this.path = path;\r\n}\n@Override\r\npublic String value() {\r\n    return this.path;\r\n}\n@Override\r\npublic String toString() {\r\n    return value();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultRoute#value()",
    "entityType": "method",
    "code": "@Override\r\npublic String value() {\r\n    return this.path;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultRoute#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return value();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter",
    "entityType": "class",
    "code": "private final Map<K, V> targetMap;\n@Nullable\r\nprivate transient Collection<List<V>> values;\n@Nullable\r\nprivate transient Set<Entry<K, List<V>>> entries;\n/**\r\n * Wrap the given target {@link Map} as a {@link MultiValueMap} adapter.\r\n * @param targetMap the plain target {@code Map}\r\n */\r\npublic SingleToMultiValueMapAdapter(Map<K, V> targetMap) {\r\n    Assert.notNull(targetMap, \"'targetMap' must not be null\");\r\n    this.targetMap = targetMap;\r\n}\n// MultiValueMap implementation\r\n@Override\r\n@Nullable\r\npublic V getFirst(K key) {\r\n    return this.targetMap.get(key);\r\n}\n@Override\r\npublic void add(K key, @Nullable V value) {\r\n    if (!this.targetMap.containsKey(key)) {\r\n        this.targetMap.put(key, value);\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\r\n    }\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void addAll(K key, List<? extends V> values) {\r\n    if (!this.targetMap.containsKey(key)) {\r\n        put(key, (List<V>) values);\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\r\n    }\r\n}\n@Override\r\npublic void addAll(MultiValueMap<K, V> values) {\r\n    values.forEach(this::addAll);\r\n}\n@Override\r\npublic void set(K key, @Nullable V value) {\r\n    this.targetMap.put(key, value);\r\n}\n@Override\r\npublic void setAll(Map<K, V> values) {\r\n    this.targetMap.putAll(values);\r\n}\n@Override\r\npublic Map<K, V> toSingleValueMap() {\r\n    return Collections.unmodifiableMap(this.targetMap);\r\n}\n// Map implementation\r\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}\n@Override\r\npublic boolean containsKey(Object key) {\r\n    return this.targetMap.containsKey(key);\r\n}\n@Override\r\npublic boolean containsValue(@Nullable Object value) {\r\n    Iterator<Entry<K, List<V>>> i = entrySet().iterator();\r\n    if (value == null) {\r\n        while (i.hasNext()) {\r\n            Entry<K, List<V>> e = i.next();\r\n            if (e.getValue() == null || e.getValue().isEmpty()) {\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        while (i.hasNext()) {\r\n            Entry<K, List<V>> e = i.next();\r\n            if (value.equals(e.getValue())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\n@Nullable\r\npublic List<V> get(Object key) {\r\n    V value = this.targetMap.get(key);\r\n    return (value != null) ? Collections.singletonList(value) : null;\r\n}\n@Override\r\n@Nullable\r\npublic List<V> put(K key, List<V> values) {\r\n    if (values.isEmpty()) {\r\n        V result = this.targetMap.put(key, null);\r\n        return (result != null) ? Collections.singletonList(result) : null;\r\n    } else if (values.size() == 1) {\r\n        V result = this.targetMap.put(key, values.get(0));\r\n        return (result != null) ? Collections.singletonList(result) : null;\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic List<V> remove(Object key) {\r\n    V result = this.targetMap.remove(key);\r\n    return (result != null) ? Collections.singletonList(result) : null;\r\n}\n@Override\r\npublic void putAll(Map<? extends K, ? extends List<V>> map) {\r\n    for (Entry<? extends K, ? extends List<V>> entry : map.entrySet()) {\r\n        put(entry.getKey(), entry.getValue());\r\n    }\r\n}\n@Override\r\npublic void clear() {\r\n    this.targetMap.clear();\r\n}\n@Override\r\npublic Set<K> keySet() {\r\n    return this.targetMap.keySet();\r\n}\n@Override\r\npublic Collection<List<V>> values() {\r\n    Collection<List<V>> values = this.values;\r\n    if (values == null) {\r\n        Collection<V> targetValues = this.targetMap.values();\r\n        values = new AbstractCollection<>() {\r\n\r\n            @Override\r\n            public Iterator<List<V>> iterator() {\r\n                Iterator<V> targetIterator = targetValues.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public List<V> next() {\r\n                        return Collections.singletonList(targetIterator.next());\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetValues.size();\r\n            }\r\n        };\r\n        this.values = values;\r\n    }\r\n    return values;\r\n}\n@Override\r\npublic Set<Entry<K, List<V>>> entrySet() {\r\n    Set<Entry<K, List<V>>> entries = this.entries;\r\n    if (entries == null) {\r\n        Set<Entry<K, V>> targetEntries = this.targetMap.entrySet();\r\n        entries = new AbstractSet<>() {\r\n\r\n            @Override\r\n            public Iterator<Entry<K, List<V>>> iterator() {\r\n                Iterator<Entry<K, V>> targetIterator = targetEntries.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public Entry<K, List<V>> next() {\r\n                        Entry<K, V> entry = targetIterator.next();\r\n                        return new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), Collections.singletonList(entry.getValue()));\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetEntries.size();\r\n            }\r\n        };\r\n        this.entries = entries;\r\n    }\r\n    return entries;\r\n}\n@Override\r\npublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\r\n    this.targetMap.forEach((k, v) -> action.accept(k, Collections.singletonList(v)));\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Map<?, ?> otherMap && size() == otherMap.size()) {\r\n        try {\r\n            for (Entry<K, List<V>> e : entrySet()) {\r\n                K key = e.getKey();\r\n                List<V> values = e.getValue();\r\n                if (values == null) {\r\n                    if (otherMap.get(key) != null || !otherMap.containsKey(key)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!values.equals(otherMap.get(key))) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": "\n * Adapts a given {@link MultiValueMap} to the {@link Map} contract. The\n * difference with {@link MultiValueMapAdapter} is that this class delegates to\n * a {@code Map<K, V>}, whereas {@link MultiValueMapAdapter} needs a\n * {@code Map<K, List<V>>}. {@link MultiToSingleValueMapAdapter} adapts in the\n * opposite direction as this class.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <K> the key type\n * @param <V> the value element type\n "
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#getFirst(K)",
    "entityType": "method",
    "code": "// MultiValueMap implementation\r\n@Override\r\n@Nullable\r\npublic V getFirst(K key) {\r\n    return this.targetMap.get(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
    "entityType": "method",
    "code": "@Override\r\npublic void add(K key, @Nullable V value) {\r\n    if (!this.targetMap.containsKey(key)) {\r\n        this.targetMap.put(key, value);\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void addAll(K key, List<? extends V> values) {\r\n    if (!this.targetMap.containsKey(key)) {\r\n        put(key, (List<V>) values);\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void addAll(MultiValueMap<K, V> values) {\r\n    values.forEach(this::addAll);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#set(K,V)",
    "entityType": "method",
    "code": "@Override\r\npublic void set(K key, @Nullable V value) {\r\n    this.targetMap.put(key, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#setAll(Map<K,V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void setAll(Map<K, V> values) {\r\n    this.targetMap.putAll(values);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#toSingleValueMap()",
    "entityType": "method",
    "code": "@Override\r\npublic Map<K, V> toSingleValueMap() {\r\n    return Collections.unmodifiableMap(this.targetMap);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#size()",
    "entityType": "method",
    "code": "// Map implementation\r\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return this.targetMap.containsKey(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsValue(@Nullable Object value) {\r\n    Iterator<Entry<K, List<V>>> i = entrySet().iterator();\r\n    if (value == null) {\r\n        while (i.hasNext()) {\r\n            Entry<K, List<V>> e = i.next();\r\n            if (e.getValue() == null || e.getValue().isEmpty()) {\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        while (i.hasNext()) {\r\n            Entry<K, List<V>> e = i.next();\r\n            if (value.equals(e.getValue())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> get(Object key) {\r\n    V value = this.targetMap.get(key);\r\n    return (value != null) ? Collections.singletonList(value) : null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#put(K,List<V>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> put(K key, List<V> values) {\r\n    if (values.isEmpty()) {\r\n        V result = this.targetMap.put(key, null);\r\n        return (result != null) ? Collections.singletonList(result) : null;\r\n    } else if (values.size() == 1) {\r\n        V result = this.targetMap.put(key, values.get(0));\r\n        return (result != null) ? Collections.singletonList(result) : null;\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> remove(Object key) {\r\n    V result = this.targetMap.remove(key);\r\n    return (result != null) ? Collections.singletonList(result) : null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void putAll(Map<? extends K, ? extends List<V>> map) {\r\n    for (Entry<? extends K, ? extends List<V>> entry : map.entrySet()) {\r\n        put(entry.getKey(), entry.getValue());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.targetMap.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#keySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<K> keySet() {\r\n    return this.targetMap.keySet();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#values()",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<List<V>> values() {\r\n    Collection<List<V>> values = this.values;\r\n    if (values == null) {\r\n        Collection<V> targetValues = this.targetMap.values();\r\n        values = new AbstractCollection<>() {\r\n\r\n            @Override\r\n            public Iterator<List<V>> iterator() {\r\n                Iterator<V> targetIterator = targetValues.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public List<V> next() {\r\n                        return Collections.singletonList(targetIterator.next());\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetValues.size();\r\n            }\r\n        };\r\n        this.values = values;\r\n    }\r\n    return values;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Entry<K, List<V>>> entrySet() {\r\n    Set<Entry<K, List<V>>> entries = this.entries;\r\n    if (entries == null) {\r\n        Set<Entry<K, V>> targetEntries = this.targetMap.entrySet();\r\n        entries = new AbstractSet<>() {\r\n\r\n            @Override\r\n            public Iterator<Entry<K, List<V>>> iterator() {\r\n                Iterator<Entry<K, V>> targetIterator = targetEntries.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public Entry<K, List<V>> next() {\r\n                        Entry<K, V> entry = targetIterator.next();\r\n                        return new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), Collections.singletonList(entry.getValue()));\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetEntries.size();\r\n            }\r\n        };\r\n        this.entries = entries;\r\n    }\r\n    return entries;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\r\n    this.targetMap.forEach((k, v) -> action.accept(k, Collections.singletonList(v)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Map<?, ?> otherMap && size() == otherMap.size()) {\r\n        try {\r\n            for (Entry<K, List<V>> e : entrySet()) {\r\n                K key = e.getKey();\r\n                List<V> values = e.getValue();\r\n                if (values == null) {\r\n                    if (otherMap.get(key) != null || !otherMap.containsKey(key)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!values.equals(otherMap.get(key))) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StopWatch",
    "entityType": "class",
    "code": "/**\r\n * Identifier of this {@code StopWatch}.\r\n * <p>Handy when we have output from multiple stop watches and need to\r\n * distinguish between them in log or console output.\r\n */\r\nprivate final String id;\n@Nullable\r\nprivate List<TaskInfo> taskList = new ArrayList<>(1);\n/**\r\n * Start time of the current task.\r\n */\r\nprivate long startTimeNanos;\n/**\r\n * Name of the current task.\r\n */\r\n@Nullable\r\nprivate String currentTaskName;\n@Nullable\r\nprivate TaskInfo lastTaskInfo;\nprivate int taskCount;\n/**\r\n * Total running time.\r\n */\r\nprivate long totalTimeNanos;\n/**\r\n * Construct a new {@code StopWatch}.\r\n * <p>Does not start any task.\r\n */\r\npublic StopWatch() {\r\n    this(\"\");\r\n}\n/**\r\n * Construct a new {@code StopWatch} with the given id.\r\n * <p>The id is handy when we have output from multiple stop watches and need\r\n * to distinguish between them.\r\n * <p>Does not start any task.\r\n * @param id identifier for this stop watch\r\n */\r\npublic StopWatch(String id) {\r\n    this.id = id;\r\n}\n/**\r\n * Get the id of this {@code StopWatch}, as specified on construction.\r\n * @return the id (empty String by default)\r\n * @since 4.2.2\r\n * @see #StopWatch(String)\r\n */\r\npublic String getId() {\r\n    return this.id;\r\n}\n/**\r\n * Configure whether the {@link TaskInfo} array is built over time.\r\n * <p>Set this to {@code false} when using a {@code StopWatch} for millions of\r\n * tasks; otherwise, the {@code TaskInfo} structure will consume excessive memory.\r\n * <p>Default is {@code true}.\r\n */\r\npublic void setKeepTaskList(boolean keepTaskList) {\r\n    this.taskList = (keepTaskList ? new ArrayList<>() : null);\r\n}\n/**\r\n * Start an unnamed task.\r\n * <p>The results are undefined if {@link #stop()} or timing methods are\r\n * called without invoking this method first.\r\n * @see #start(String)\r\n * @see #stop()\r\n */\r\npublic void start() throws IllegalStateException {\r\n    start(\"\");\r\n}\n/**\r\n * Start a named task.\r\n * <p>The results are undefined if {@link #stop()} or timing methods are\r\n * called without invoking this method first.\r\n * @param taskName the name of the task to start\r\n * @see #start()\r\n * @see #stop()\r\n */\r\npublic void start(String taskName) throws IllegalStateException {\r\n    if (this.currentTaskName != null) {\r\n        throw new IllegalStateException(\"Can't start StopWatch: it's already running\");\r\n    }\r\n    this.currentTaskName = taskName;\r\n    this.startTimeNanos = System.nanoTime();\r\n}\n/**\r\n * Stop the current task.\r\n * <p>The results are undefined if timing methods are called without invoking\r\n * at least one pair of {@code start()} / {@code stop()} methods.\r\n * @see #start()\r\n * @see #start(String)\r\n */\r\npublic void stop() throws IllegalStateException {\r\n    if (this.currentTaskName == null) {\r\n        throw new IllegalStateException(\"Can't stop StopWatch: it's not running\");\r\n    }\r\n    long lastTime = System.nanoTime() - this.startTimeNanos;\r\n    this.totalTimeNanos += lastTime;\r\n    this.lastTaskInfo = new TaskInfo(this.currentTaskName, lastTime);\r\n    if (this.taskList != null) {\r\n        this.taskList.add(this.lastTaskInfo);\r\n    }\r\n    ++this.taskCount;\r\n    this.currentTaskName = null;\r\n}\n/**\r\n * Determine whether this {@code StopWatch} is currently running.\r\n * @see #currentTaskName()\r\n */\r\npublic boolean isRunning() {\r\n    return (this.currentTaskName != null);\r\n}\n/**\r\n * Get the name of the currently running task, if any.\r\n * @since 4.2.2\r\n * @see #isRunning()\r\n */\r\n@Nullable\r\npublic String currentTaskName() {\r\n    return this.currentTaskName;\r\n}\n/**\r\n * Get the last task as a {@link TaskInfo} object.\r\n * @throws IllegalStateException if no tasks have run yet\r\n * @since 6.1\r\n */\r\npublic TaskInfo lastTaskInfo() throws IllegalStateException {\r\n    Assert.state(this.lastTaskInfo != null, \"No tasks run\");\r\n    return this.lastTaskInfo;\r\n}\n/**\r\n * Get the last task as a {@link TaskInfo} object.\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic TaskInfo getLastTaskInfo() throws IllegalStateException {\r\n    return lastTaskInfo();\r\n}\n/**\r\n * Get the name of the last task.\r\n * @see TaskInfo#getTaskName()\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic String getLastTaskName() throws IllegalStateException {\r\n    return lastTaskInfo().getTaskName();\r\n}\n/**\r\n * Get the time taken by the last task in nanoseconds.\r\n * @since 5.2\r\n * @see TaskInfo#getTimeNanos()\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic long getLastTaskTimeNanos() throws IllegalStateException {\r\n    return lastTaskInfo().getTimeNanos();\r\n}\n/**\r\n * Get the time taken by the last task in milliseconds.\r\n * @see TaskInfo#getTimeMillis()\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic long getLastTaskTimeMillis() throws IllegalStateException {\r\n    return lastTaskInfo().getTimeMillis();\r\n}\n/**\r\n * Get an array of the data for tasks performed.\r\n * @see #setKeepTaskList\r\n */\r\npublic TaskInfo[] getTaskInfo() {\r\n    if (this.taskList == null) {\r\n        throw new UnsupportedOperationException(\"Task info is not being kept!\");\r\n    }\r\n    return this.taskList.toArray(new TaskInfo[0]);\r\n}\n/**\r\n * Get the number of tasks timed.\r\n */\r\npublic int getTaskCount() {\r\n    return this.taskCount;\r\n}\n/**\r\n * Get the total time for all tasks in nanoseconds.\r\n * @since 5.2\r\n * @see #getTotalTime(TimeUnit)\r\n */\r\npublic long getTotalTimeNanos() {\r\n    return this.totalTimeNanos;\r\n}\n/**\r\n * Get the total time for all tasks in milliseconds.\r\n * @see #getTotalTime(TimeUnit)\r\n */\r\npublic long getTotalTimeMillis() {\r\n    return TimeUnit.NANOSECONDS.toMillis(this.totalTimeNanos);\r\n}\n/**\r\n * Get the total time for all tasks in seconds.\r\n * @see #getTotalTime(TimeUnit)\r\n */\r\npublic double getTotalTimeSeconds() {\r\n    return getTotalTime(TimeUnit.SECONDS);\r\n}\n/**\r\n * Get the total time for all tasks in the requested time unit\r\n * (with decimal points in nanosecond precision).\r\n * @param timeUnit the unit to use\r\n * @since 6.1\r\n * @see #getTotalTimeNanos()\r\n * @see #getTotalTimeMillis()\r\n * @see #getTotalTimeSeconds()\r\n */\r\npublic double getTotalTime(TimeUnit timeUnit) {\r\n    return (double) this.totalTimeNanos / TimeUnit.NANOSECONDS.convert(1, timeUnit);\r\n}\n/**\r\n * Generate a table describing all tasks performed in seconds\r\n * (with decimal points in nanosecond precision).\r\n * <p>For custom reporting, call {@link #getTaskInfo()} and use the data directly.\r\n * @see #prettyPrint(TimeUnit)\r\n * @see #getTotalTimeSeconds()\r\n * @see TaskInfo#getTimeSeconds()\r\n */\r\npublic String prettyPrint() {\r\n    return prettyPrint(TimeUnit.SECONDS);\r\n}\n/**\r\n * Generate a table describing all tasks performed in the requested time unit\r\n * (with decimal points in nanosecond precision).\r\n * <p>For custom reporting, call {@link #getTaskInfo()} and use the data directly.\r\n * @param timeUnit the unit to use for rendering total time and task time\r\n * @since 6.1\r\n * @see #prettyPrint()\r\n * @see #getTotalTime(TimeUnit)\r\n * @see TaskInfo#getTime(TimeUnit)\r\n */\r\npublic String prettyPrint(TimeUnit timeUnit) {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);\r\n    nf.setMaximumFractionDigits(9);\r\n    nf.setGroupingUsed(false);\r\n    NumberFormat pf = NumberFormat.getPercentInstance(Locale.ENGLISH);\r\n    pf.setMinimumIntegerDigits(2);\r\n    pf.setGroupingUsed(false);\r\n    StringBuilder sb = new StringBuilder(128);\r\n    sb.append(\"StopWatch '\").append(getId()).append(\"': \");\r\n    String total = (timeUnit == TimeUnit.NANOSECONDS ? nf.format(getTotalTimeNanos()) : nf.format(getTotalTime(timeUnit)));\r\n    sb.append(total).append(\" \").append(timeUnit.name().toLowerCase(Locale.ENGLISH));\r\n    int width = Math.max(sb.length(), 40);\r\n    sb.append(\"\\n\");\r\n    if (this.taskList != null) {\r\n        String line = \"-\".repeat(width) + \"\\n\";\r\n        String unitName = timeUnit.name();\r\n        unitName = unitName.charAt(0) + unitName.substring(1).toLowerCase(Locale.ENGLISH);\r\n        unitName = String.format(\"%-12s\", unitName);\r\n        sb.append(line);\r\n        sb.append(unitName).append(\"  %       Task name\\n\");\r\n        sb.append(line);\r\n        int digits = total.indexOf('.');\r\n        if (digits < 0) {\r\n            digits = total.length();\r\n        }\r\n        nf.setMinimumIntegerDigits(digits);\r\n        nf.setMaximumFractionDigits(10 - digits);\r\n        for (TaskInfo task : this.taskList) {\r\n            sb.append(String.format(\"%-14s\", (timeUnit == TimeUnit.NANOSECONDS ? nf.format(task.getTimeNanos()) : nf.format(task.getTime(timeUnit)))));\r\n            sb.append(String.format(\"%-8s\", pf.format(task.getTimeSeconds() / getTotalTimeSeconds())));\r\n            sb.append(task.getTaskName()).append('\\n');\r\n        }\r\n    } else {\r\n        sb.append(\"No task info kept\");\r\n    }\r\n    return sb.toString();\r\n}\n/**\r\n * Get a short description of the total running time in seconds.\r\n * @see #prettyPrint()\r\n * @see #prettyPrint(TimeUnit)\r\n */\r\npublic String shortSummary() {\r\n    return \"StopWatch '\" + getId() + \"': \" + getTotalTimeSeconds() + \" seconds\";\r\n}\n/**\r\n * Generate an informative string describing all tasks performed in seconds.\r\n * @see #prettyPrint()\r\n * @see #prettyPrint(TimeUnit)\r\n */\r\n@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(shortSummary());\r\n    if (this.taskList != null) {\r\n        for (TaskInfo task : this.taskList) {\r\n            sb.append(\"; [\").append(task.getTaskName()).append(\"] took \").append(task.getTimeSeconds()).append(\" seconds\");\r\n            long percent = Math.round(100.0 * task.getTimeSeconds() / getTotalTimeSeconds());\r\n            sb.append(\" = \").append(percent).append('%');\r\n        }\r\n    } else {\r\n        sb.append(\"; no task info kept\");\r\n    }\r\n    return sb.toString();\r\n}\n/**\r\n * Nested class to hold data about one task executed within the {@code StopWatch}.\r\n */\r\npublic static final class TaskInfo {\r\n\r\n    private final String taskName;\r\n\r\n    private final long timeNanos;\r\n\r\n    TaskInfo(String taskName, long timeNanos) {\r\n        this.taskName = taskName;\r\n        this.timeNanos = timeNanos;\r\n    }\r\n\r\n    /**\r\n     * Get the name of this task.\r\n     */\r\n    public String getTaskName() {\r\n        return this.taskName;\r\n    }\r\n\r\n    /**\r\n     * Get the time this task took in nanoseconds.\r\n     * @since 5.2\r\n     * @see #getTime(TimeUnit)\r\n     */\r\n    public long getTimeNanos() {\r\n        return this.timeNanos;\r\n    }\r\n\r\n    /**\r\n     * Get the time this task took in milliseconds.\r\n     * @see #getTime(TimeUnit)\r\n     */\r\n    public long getTimeMillis() {\r\n        return TimeUnit.NANOSECONDS.toMillis(this.timeNanos);\r\n    }\r\n\r\n    /**\r\n     * Get the time this task took in seconds.\r\n     * @see #getTime(TimeUnit)\r\n     */\r\n    public double getTimeSeconds() {\r\n        return getTime(TimeUnit.SECONDS);\r\n    }\r\n\r\n    /**\r\n     * Get the time this task took in the requested time unit\r\n     * (with decimal points in nanosecond precision).\r\n     * @param timeUnit the unit to use\r\n     * @since 6.1\r\n     * @see #getTimeNanos()\r\n     * @see #getTimeMillis()\r\n     * @see #getTimeSeconds()\r\n     */\r\n    public double getTime(TimeUnit timeUnit) {\r\n        return (double) this.timeNanos / TimeUnit.NANOSECONDS.convert(1, timeUnit);\r\n    }\r\n}",
    "comment": "\n * Simple stop watch, allowing for timing of a number of tasks, exposing total\n * running time and running time for each named task.\n *\n * <p>Conceals use of {@link System#nanoTime()}, improving the readability of\n * application code and reducing the likelihood of calculation errors.\n *\n * <p>Note that this object is not designed to be thread-safe and does not use\n * synchronization.\n *\n * <p>This class is normally used to verify performance during proof-of-concept\n * work and in development, rather than as part of production applications.\n *\n * <p>Running time is tracked and reported in nanoseconds. As of Spring Framework\n * 6.1, the default time unit for String renderings is seconds with decimal points\n * in nanosecond precision. Custom renderings with specific time units can be\n * requested through {@link #prettyPrint(TimeUnit)}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since May 2, 2001\n * @see #start()\n * @see #stop()\n * @see #shortSummary()\n * @see #prettyPrint()\n "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getId()",
    "entityType": "method",
    "code": "/**\r\n * Get the id of this {@code StopWatch}, as specified on construction.\r\n * @return the id (empty String by default)\r\n * @since 4.2.2\r\n * @see #StopWatch(String)\r\n */\r\npublic String getId() {\r\n    return this.id;\r\n}",
    "comment": "\n\t * Get the id of this {@code StopWatch}, as specified on construction.\n\t * @return the id (empty String by default)\n\t * @since 4.2.2\n\t * @see #StopWatch(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Configure whether the {@link TaskInfo} array is built over time.\r\n * <p>Set this to {@code false} when using a {@code StopWatch} for millions of\r\n * tasks; otherwise, the {@code TaskInfo} structure will consume excessive memory.\r\n * <p>Default is {@code true}.\r\n */\r\npublic void setKeepTaskList(boolean keepTaskList) {\r\n    this.taskList = (keepTaskList ? new ArrayList<>() : null);\r\n}",
    "comment": "\n\t * Configure whether the {@link TaskInfo} array is built over time.\n\t * <p>Set this to {@code false} when using a {@code StopWatch} for millions of\n\t * tasks; otherwise, the {@code TaskInfo} structure will consume excessive memory.\n\t * <p>Default is {@code true}.\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#start()",
    "entityType": "method",
    "code": "/**\r\n * Start an unnamed task.\r\n * <p>The results are undefined if {@link #stop()} or timing methods are\r\n * called without invoking this method first.\r\n * @see #start(String)\r\n * @see #stop()\r\n */\r\npublic void start() throws IllegalStateException {\r\n    start(\"\");\r\n}",
    "comment": "\n\t * Start an unnamed task.\n\t * <p>The results are undefined if {@link #stop()} or timing methods are\n\t * called without invoking this method first.\n\t * @see #start(String)\n\t * @see #stop()\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#start(String)",
    "entityType": "method",
    "code": "/**\r\n * Start a named task.\r\n * <p>The results are undefined if {@link #stop()} or timing methods are\r\n * called without invoking this method first.\r\n * @param taskName the name of the task to start\r\n * @see #start()\r\n * @see #stop()\r\n */\r\npublic void start(String taskName) throws IllegalStateException {\r\n    if (this.currentTaskName != null) {\r\n        throw new IllegalStateException(\"Can't start StopWatch: it's already running\");\r\n    }\r\n    this.currentTaskName = taskName;\r\n    this.startTimeNanos = System.nanoTime();\r\n}",
    "comment": "\n\t * Start a named task.\n\t * <p>The results are undefined if {@link #stop()} or timing methods are\n\t * called without invoking this method first.\n\t * @param taskName the name of the task to start\n\t * @see #start()\n\t * @see #stop()\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#stop()",
    "entityType": "method",
    "code": "/**\r\n * Stop the current task.\r\n * <p>The results are undefined if timing methods are called without invoking\r\n * at least one pair of {@code start()} / {@code stop()} methods.\r\n * @see #start()\r\n * @see #start(String)\r\n */\r\npublic void stop() throws IllegalStateException {\r\n    if (this.currentTaskName == null) {\r\n        throw new IllegalStateException(\"Can't stop StopWatch: it's not running\");\r\n    }\r\n    long lastTime = System.nanoTime() - this.startTimeNanos;\r\n    this.totalTimeNanos += lastTime;\r\n    this.lastTaskInfo = new TaskInfo(this.currentTaskName, lastTime);\r\n    if (this.taskList != null) {\r\n        this.taskList.add(this.lastTaskInfo);\r\n    }\r\n    ++this.taskCount;\r\n    this.currentTaskName = null;\r\n}",
    "comment": "\n\t * Stop the current task.\n\t * <p>The results are undefined if timing methods are called without invoking\n\t * at least one pair of {@code start()} / {@code stop()} methods.\n\t * @see #start()\n\t * @see #start(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#isRunning()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this {@code StopWatch} is currently running.\r\n * @see #currentTaskName()\r\n */\r\npublic boolean isRunning() {\r\n    return (this.currentTaskName != null);\r\n}",
    "comment": "\n\t * Determine whether this {@code StopWatch} is currently running.\n\t * @see #currentTaskName()\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#currentTaskName()",
    "entityType": "method",
    "code": "/**\r\n * Get the name of the currently running task, if any.\r\n * @since 4.2.2\r\n * @see #isRunning()\r\n */\r\n@Nullable\r\npublic String currentTaskName() {\r\n    return this.currentTaskName;\r\n}",
    "comment": "\n\t * Get the name of the currently running task, if any.\n\t * @since 4.2.2\n\t * @see #isRunning()\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#lastTaskInfo()",
    "entityType": "method",
    "code": "/**\r\n * Get the last task as a {@link TaskInfo} object.\r\n * @throws IllegalStateException if no tasks have run yet\r\n * @since 6.1\r\n */\r\npublic TaskInfo lastTaskInfo() throws IllegalStateException {\r\n    Assert.state(this.lastTaskInfo != null, \"No tasks run\");\r\n    return this.lastTaskInfo;\r\n}",
    "comment": "\n\t * Get the last task as a {@link TaskInfo} object.\n\t * @throws IllegalStateException if no tasks have run yet\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getLastTaskInfo()",
    "entityType": "method",
    "code": "/**\r\n * Get the last task as a {@link TaskInfo} object.\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic TaskInfo getLastTaskInfo() throws IllegalStateException {\r\n    return lastTaskInfo();\r\n}",
    "comment": "\n\t * Get the last task as a {@link TaskInfo} object.\n\t * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getLastTaskName()",
    "entityType": "method",
    "code": "/**\r\n * Get the name of the last task.\r\n * @see TaskInfo#getTaskName()\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic String getLastTaskName() throws IllegalStateException {\r\n    return lastTaskInfo().getTaskName();\r\n}",
    "comment": "\n\t * Get the name of the last task.\n\t * @see TaskInfo#getTaskName()\n\t * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
    "entityType": "method",
    "code": "/**\r\n * Get the time taken by the last task in nanoseconds.\r\n * @since 5.2\r\n * @see TaskInfo#getTimeNanos()\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic long getLastTaskTimeNanos() throws IllegalStateException {\r\n    return lastTaskInfo().getTimeNanos();\r\n}",
    "comment": "\n\t * Get the time taken by the last task in nanoseconds.\n\t * @since 5.2\n\t * @see TaskInfo#getTimeNanos()\n\t * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
    "entityType": "method",
    "code": "/**\r\n * Get the time taken by the last task in milliseconds.\r\n * @see TaskInfo#getTimeMillis()\r\n * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic long getLastTaskTimeMillis() throws IllegalStateException {\r\n    return lastTaskInfo().getTimeMillis();\r\n}",
    "comment": "\n\t * Get the time taken by the last task in milliseconds.\n\t * @see TaskInfo#getTimeMillis()\n\t * @deprecated as of 6.1, in favor of {@link #lastTaskInfo()}\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getTaskInfo()",
    "entityType": "method",
    "code": "/**\r\n * Get an array of the data for tasks performed.\r\n * @see #setKeepTaskList\r\n */\r\npublic TaskInfo[] getTaskInfo() {\r\n    if (this.taskList == null) {\r\n        throw new UnsupportedOperationException(\"Task info is not being kept!\");\r\n    }\r\n    return this.taskList.toArray(new TaskInfo[0]);\r\n}",
    "comment": "\n\t * Get an array of the data for tasks performed.\n\t * @see #setKeepTaskList\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getTaskCount()",
    "entityType": "method",
    "code": "/**\r\n * Get the number of tasks timed.\r\n */\r\npublic int getTaskCount() {\r\n    return this.taskCount;\r\n}",
    "comment": "\n\t * Get the number of tasks timed.\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getTotalTimeNanos()",
    "entityType": "method",
    "code": "/**\r\n * Get the total time for all tasks in nanoseconds.\r\n * @since 5.2\r\n * @see #getTotalTime(TimeUnit)\r\n */\r\npublic long getTotalTimeNanos() {\r\n    return this.totalTimeNanos;\r\n}",
    "comment": "\n\t * Get the total time for all tasks in nanoseconds.\n\t * @since 5.2\n\t * @see #getTotalTime(TimeUnit)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getTotalTimeMillis()",
    "entityType": "method",
    "code": "/**\r\n * Get the total time for all tasks in milliseconds.\r\n * @see #getTotalTime(TimeUnit)\r\n */\r\npublic long getTotalTimeMillis() {\r\n    return TimeUnit.NANOSECONDS.toMillis(this.totalTimeNanos);\r\n}",
    "comment": "\n\t * Get the total time for all tasks in milliseconds.\n\t * @see #getTotalTime(TimeUnit)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getTotalTimeSeconds()",
    "entityType": "method",
    "code": "/**\r\n * Get the total time for all tasks in seconds.\r\n * @see #getTotalTime(TimeUnit)\r\n */\r\npublic double getTotalTimeSeconds() {\r\n    return getTotalTime(TimeUnit.SECONDS);\r\n}",
    "comment": "\n\t * Get the total time for all tasks in seconds.\n\t * @see #getTotalTime(TimeUnit)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
    "entityType": "method",
    "code": "/**\r\n * Get the total time for all tasks in the requested time unit\r\n * (with decimal points in nanosecond precision).\r\n * @param timeUnit the unit to use\r\n * @since 6.1\r\n * @see #getTotalTimeNanos()\r\n * @see #getTotalTimeMillis()\r\n * @see #getTotalTimeSeconds()\r\n */\r\npublic double getTotalTime(TimeUnit timeUnit) {\r\n    return (double) this.totalTimeNanos / TimeUnit.NANOSECONDS.convert(1, timeUnit);\r\n}",
    "comment": "\n\t * Get the total time for all tasks in the requested time unit\n\t * (with decimal points in nanosecond precision).\n\t * @param timeUnit the unit to use\n\t * @since 6.1\n\t * @see #getTotalTimeNanos()\n\t * @see #getTotalTimeMillis()\n\t * @see #getTotalTimeSeconds()\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#prettyPrint()",
    "entityType": "method",
    "code": "/**\r\n * Generate a table describing all tasks performed in seconds\r\n * (with decimal points in nanosecond precision).\r\n * <p>For custom reporting, call {@link #getTaskInfo()} and use the data directly.\r\n * @see #prettyPrint(TimeUnit)\r\n * @see #getTotalTimeSeconds()\r\n * @see TaskInfo#getTimeSeconds()\r\n */\r\npublic String prettyPrint() {\r\n    return prettyPrint(TimeUnit.SECONDS);\r\n}",
    "comment": "\n\t * Generate a table describing all tasks performed in seconds\n\t * (with decimal points in nanosecond precision).\n\t * <p>For custom reporting, call {@link #getTaskInfo()} and use the data directly.\n\t * @see #prettyPrint(TimeUnit)\n\t * @see #getTotalTimeSeconds()\n\t * @see TaskInfo#getTimeSeconds()\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
    "entityType": "method",
    "code": "/**\r\n * Generate a table describing all tasks performed in the requested time unit\r\n * (with decimal points in nanosecond precision).\r\n * <p>For custom reporting, call {@link #getTaskInfo()} and use the data directly.\r\n * @param timeUnit the unit to use for rendering total time and task time\r\n * @since 6.1\r\n * @see #prettyPrint()\r\n * @see #getTotalTime(TimeUnit)\r\n * @see TaskInfo#getTime(TimeUnit)\r\n */\r\npublic String prettyPrint(TimeUnit timeUnit) {\r\n    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);\r\n    nf.setMaximumFractionDigits(9);\r\n    nf.setGroupingUsed(false);\r\n    NumberFormat pf = NumberFormat.getPercentInstance(Locale.ENGLISH);\r\n    pf.setMinimumIntegerDigits(2);\r\n    pf.setGroupingUsed(false);\r\n    StringBuilder sb = new StringBuilder(128);\r\n    sb.append(\"StopWatch '\").append(getId()).append(\"': \");\r\n    String total = (timeUnit == TimeUnit.NANOSECONDS ? nf.format(getTotalTimeNanos()) : nf.format(getTotalTime(timeUnit)));\r\n    sb.append(total).append(\" \").append(timeUnit.name().toLowerCase(Locale.ENGLISH));\r\n    int width = Math.max(sb.length(), 40);\r\n    sb.append(\"\\n\");\r\n    if (this.taskList != null) {\r\n        String line = \"-\".repeat(width) + \"\\n\";\r\n        String unitName = timeUnit.name();\r\n        unitName = unitName.charAt(0) + unitName.substring(1).toLowerCase(Locale.ENGLISH);\r\n        unitName = String.format(\"%-12s\", unitName);\r\n        sb.append(line);\r\n        sb.append(unitName).append(\"  %       Task name\\n\");\r\n        sb.append(line);\r\n        int digits = total.indexOf('.');\r\n        if (digits < 0) {\r\n            digits = total.length();\r\n        }\r\n        nf.setMinimumIntegerDigits(digits);\r\n        nf.setMaximumFractionDigits(10 - digits);\r\n        for (TaskInfo task : this.taskList) {\r\n            sb.append(String.format(\"%-14s\", (timeUnit == TimeUnit.NANOSECONDS ? nf.format(task.getTimeNanos()) : nf.format(task.getTime(timeUnit)))));\r\n            sb.append(String.format(\"%-8s\", pf.format(task.getTimeSeconds() / getTotalTimeSeconds())));\r\n            sb.append(task.getTaskName()).append('\\n');\r\n        }\r\n    } else {\r\n        sb.append(\"No task info kept\");\r\n    }\r\n    return sb.toString();\r\n}",
    "comment": "\n\t * Generate a table describing all tasks performed in the requested time unit\n\t * (with decimal points in nanosecond precision).\n\t * <p>For custom reporting, call {@link #getTaskInfo()} and use the data directly.\n\t * @param timeUnit the unit to use for rendering total time and task time\n\t * @since 6.1\n\t * @see #prettyPrint()\n\t * @see #getTotalTime(TimeUnit)\n\t * @see TaskInfo#getTime(TimeUnit)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#shortSummary()",
    "entityType": "method",
    "code": "/**\r\n * Get a short description of the total running time in seconds.\r\n * @see #prettyPrint()\r\n * @see #prettyPrint(TimeUnit)\r\n */\r\npublic String shortSummary() {\r\n    return \"StopWatch '\" + getId() + \"': \" + getTotalTimeSeconds() + \" seconds\";\r\n}",
    "comment": "\n\t * Get a short description of the total running time in seconds.\n\t * @see #prettyPrint()\n\t * @see #prettyPrint(TimeUnit)\n\t "
  },
  {
    "entityId": "org.springframework.util.StopWatch#toString()",
    "entityType": "method",
    "code": "/**\r\n * Generate an informative string describing all tasks performed in seconds.\r\n * @see #prettyPrint()\r\n * @see #prettyPrint(TimeUnit)\r\n */\r\n@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(shortSummary());\r\n    if (this.taskList != null) {\r\n        for (TaskInfo task : this.taskList) {\r\n            sb.append(\"; [\").append(task.getTaskName()).append(\"] took \").append(task.getTimeSeconds()).append(\" seconds\");\r\n            long percent = Math.round(100.0 * task.getTimeSeconds() / getTotalTimeSeconds());\r\n            sb.append(\" = \").append(percent).append('%');\r\n        }\r\n    } else {\r\n        sb.append(\"; no task info kept\");\r\n    }\r\n    return sb.toString();\r\n}",
    "comment": "\n\t * Generate an informative string describing all tasks performed in seconds.\n\t * @see #prettyPrint()\n\t * @see #prettyPrint(TimeUnit)\n\t "
  },
  {
    "entityId": "org.springframework.util.TaskInfo",
    "entityType": "class",
    "code": "private final String taskName;\nprivate final long timeNanos;\nTaskInfo(String taskName, long timeNanos) {\r\n    this.taskName = taskName;\r\n    this.timeNanos = timeNanos;\r\n}\n/**\r\n * Get the name of this task.\r\n */\r\npublic String getTaskName() {\r\n    return this.taskName;\r\n}\n/**\r\n * Get the time this task took in nanoseconds.\r\n * @since 5.2\r\n * @see #getTime(TimeUnit)\r\n */\r\npublic long getTimeNanos() {\r\n    return this.timeNanos;\r\n}\n/**\r\n * Get the time this task took in milliseconds.\r\n * @see #getTime(TimeUnit)\r\n */\r\npublic long getTimeMillis() {\r\n    return TimeUnit.NANOSECONDS.toMillis(this.timeNanos);\r\n}\n/**\r\n * Get the time this task took in seconds.\r\n * @see #getTime(TimeUnit)\r\n */\r\npublic double getTimeSeconds() {\r\n    return getTime(TimeUnit.SECONDS);\r\n}\n/**\r\n * Get the time this task took in the requested time unit\r\n * (with decimal points in nanosecond precision).\r\n * @param timeUnit the unit to use\r\n * @since 6.1\r\n * @see #getTimeNanos()\r\n * @see #getTimeMillis()\r\n * @see #getTimeSeconds()\r\n */\r\npublic double getTime(TimeUnit timeUnit) {\r\n    return (double) this.timeNanos / TimeUnit.NANOSECONDS.convert(1, timeUnit);\r\n}",
    "comment": "\n\t * Nested class to hold data about one task executed within the {@code StopWatch}.\n\t "
  },
  {
    "entityId": "org.springframework.util.TaskInfo#getTaskName()",
    "entityType": "method",
    "code": "/**\r\n * Get the name of this task.\r\n */\r\npublic String getTaskName() {\r\n    return this.taskName;\r\n}",
    "comment": "\n\t\t * Get the name of this task.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.TaskInfo#getTimeNanos()",
    "entityType": "method",
    "code": "/**\r\n * Get the time this task took in nanoseconds.\r\n * @since 5.2\r\n * @see #getTime(TimeUnit)\r\n */\r\npublic long getTimeNanos() {\r\n    return this.timeNanos;\r\n}",
    "comment": "\n\t\t * Get the time this task took in nanoseconds.\n\t\t * @since 5.2\n\t\t * @see #getTime(TimeUnit)\n\t\t "
  },
  {
    "entityId": "org.springframework.util.TaskInfo#getTimeMillis()",
    "entityType": "method",
    "code": "/**\r\n * Get the time this task took in milliseconds.\r\n * @see #getTime(TimeUnit)\r\n */\r\npublic long getTimeMillis() {\r\n    return TimeUnit.NANOSECONDS.toMillis(this.timeNanos);\r\n}",
    "comment": "\n\t\t * Get the time this task took in milliseconds.\n\t\t * @see #getTime(TimeUnit)\n\t\t "
  },
  {
    "entityId": "org.springframework.util.TaskInfo#getTimeSeconds()",
    "entityType": "method",
    "code": "/**\r\n * Get the time this task took in seconds.\r\n * @see #getTime(TimeUnit)\r\n */\r\npublic double getTimeSeconds() {\r\n    return getTime(TimeUnit.SECONDS);\r\n}",
    "comment": "\n\t\t * Get the time this task took in seconds.\n\t\t * @see #getTime(TimeUnit)\n\t\t "
  }
]