[
  {
    "entityId": "org.springframework.util.StringUtilsTests#startsWithIgnoreCase()",
    "entityType": "method",
    "code": "@Test\r\nvoid startsWithIgnoreCase() {\r\n    String prefix = \"fOo\";\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foo\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"Foo\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foobar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foobarbar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"Foobar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"FoobarBar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foObar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"FOObar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"fOobar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(null, prefix)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"fOobar\", null)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"b\", prefix)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"barfoo\", prefix)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"barfoobar\", prefix)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#endsWithIgnoreCase()",
    "entityType": "method",
    "code": "@Test\r\nvoid endsWithIgnoreCase() {\r\n    String suffix = \"fOo\";\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"foo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"Foo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barbarfoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barFoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barBarFoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfoO\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barFOO\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfOo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(null, suffix)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfOo\", null)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"b\", suffix)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"foobar\", suffix)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfoobar\", suffix)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#substringMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid substringMatch() {\r\n    assertThat(StringUtils.substringMatch(\"foo\", 0, \"foo\")).isTrue();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 1, \"oo\")).isTrue();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"o\")).isTrue();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 0, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 1, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 3, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 1, \"Oo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"Oo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 3, \"Oo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"O\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 3, \"O\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#countOccurrencesOf()",
    "entityType": "method",
    "code": "@Test\r\nvoid countOccurrencesOf() {\r\n    assertThat(StringUtils.countOccurrencesOf(null, null)).as(\"nullx2 = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(\"s\", null)).as(\"null string = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(null, \"s\")).as(\"null substring = 0\").isEqualTo(0);\r\n    String s = \"erowoiueoiur\";\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"WERWER\")).as(\"not found = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"x\")).as(\"not found char = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \" \")).as(\"not found ws = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"\")).as(\"not found empty string = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"e\")).as(\"found char=2\").isEqualTo(2);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"oi\")).as(\"found substring=2\").isEqualTo(2);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"oiu\")).as(\"found substring=2\").isEqualTo(2);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"oiur\")).as(\"found substring=3\").isEqualTo(1);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"r\")).as(\"test last\").isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#replace()",
    "entityType": "method",
    "code": "@Test\r\nvoid replace() {\r\n    String inString = \"a6AazAaa77abaa\";\r\n    String oldPattern = \"aa\";\r\n    String newPattern = \"foo\";\r\n    // Simple replace\r\n    String s = StringUtils.replace(inString, oldPattern, newPattern);\r\n    assertThat(s).as(\"Replace 1 worked\").isEqualTo(\"a6AazAfoo77abfoo\");\r\n    // Non match: no change\r\n    s = StringUtils.replace(inString, \"qwoeiruqopwieurpoqwieur\", newPattern);\r\n    assertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\r\n    // Null new pattern: should ignore\r\n    s = StringUtils.replace(inString, oldPattern, null);\r\n    assertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\r\n    // Null old pattern: should ignore\r\n    s = StringUtils.replace(inString, null, newPattern);\r\n    assertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delete()",
    "entityType": "method",
    "code": "@Test\r\nvoid delete() {\r\n    String inString = \"The quick brown fox jumped over the lazy dog\";\r\n    String noThe = StringUtils.delete(inString, \"the\");\r\n    assertThat(noThe).as(\"Result has no the [\" + noThe + \"]\").isEqualTo(\"The quick brown fox jumped over  lazy dog\");\r\n    String nohe = StringUtils.delete(inString, \"he\");\r\n    assertThat(nohe).as(\"Result has no he [\" + nohe + \"]\").isEqualTo(\"T quick brown fox jumped over t lazy dog\");\r\n    String nosp = StringUtils.delete(inString, \" \");\r\n    assertThat(nosp).as(\"Result has no spaces\").isEqualTo(\"Thequickbrownfoxjumpedoverthelazydog\");\r\n    String killEnd = StringUtils.delete(inString, \"dog\");\r\n    assertThat(killEnd).as(\"Result has no dog\").isEqualTo(\"The quick brown fox jumped over the lazy \");\r\n    String mismatch = StringUtils.delete(inString, \"dxxcxcxog\");\r\n    assertThat(mismatch).as(\"Result is unchanged\").isEqualTo(inString);\r\n    String nochange = StringUtils.delete(inString, \"\");\r\n    assertThat(nochange).as(\"Result is unchanged\").isEqualTo(inString);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#deleteAny()",
    "entityType": "method",
    "code": "@Test\r\nvoid deleteAny() {\r\n    String inString = \"Able was I ere I saw Elba\";\r\n    String res = StringUtils.deleteAny(inString, \"I\");\r\n    assertThat(res).as(\"Result has no 'I'\").isEqualTo(\"Able was  ere  saw Elba\");\r\n    res = StringUtils.deleteAny(inString, \"AeEba!\");\r\n    assertThat(res).as(\"Result has no 'AeEba!'\").isEqualTo(\"l ws I r I sw l\");\r\n    res = StringUtils.deleteAny(inString, \"#@$#$^\");\r\n    assertThat(res).as(\"Result is unchanged\").isEqualTo(inString);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#deleteAnyWhitespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid deleteAnyWhitespace() {\r\n    String whitespace = \"This is\\n\\n\\n    \\t   a messagy string with whitespace\\n\";\r\n    assertThat(whitespace).as(\"Has CR\").contains(\"\\n\");\r\n    assertThat(whitespace).as(\"Has tab\").contains(\"\\t\");\r\n    assertThat(whitespace).as(\"Has space\").contains(\" \");\r\n    String cleaned = StringUtils.deleteAny(whitespace, \"\\n\\t \");\r\n    assertThat(cleaned).as(\"Has no CR\").doesNotContain(\"\\n\");\r\n    assertThat(cleaned).as(\"Has no tab\").doesNotContain(\"\\t\");\r\n    assertThat(cleaned).as(\"Has no space\").doesNotContain(\" \");\r\n    assertThat(cleaned.length()).as(\"Still has chars\").isGreaterThan(10);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#quote()",
    "entityType": "method",
    "code": "@Test\r\nvoid quote() {\r\n    assertThat(StringUtils.quote(\"myString\")).isEqualTo(\"'myString'\");\r\n    assertThat(StringUtils.quote(\"\")).isEqualTo(\"''\");\r\n    assertThat(StringUtils.quote(null)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#quoteIfString()",
    "entityType": "method",
    "code": "@Test\r\nvoid quoteIfString() {\r\n    assertThat(StringUtils.quoteIfString(\"myString\")).isEqualTo(\"'myString'\");\r\n    assertThat(StringUtils.quoteIfString(\"\")).isEqualTo(\"''\");\r\n    assertThat(StringUtils.quoteIfString(5)).isEqualTo(5);\r\n    assertThat(StringUtils.quoteIfString(null)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#unqualify()",
    "entityType": "method",
    "code": "@Test\r\nvoid unqualify() {\r\n    String qualified = \"i.am.not.unqualified\";\r\n    assertThat(StringUtils.unqualify(qualified)).isEqualTo(\"unqualified\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#capitalize()",
    "entityType": "method",
    "code": "@Test\r\nvoid capitalize() {\r\n    String capitalized = \"i am not capitalized\";\r\n    assertThat(StringUtils.capitalize(capitalized)).isEqualTo(\"I am not capitalized\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#uncapitalize()",
    "entityType": "method",
    "code": "@Test\r\nvoid uncapitalize() {\r\n    String capitalized = \"I am capitalized\";\r\n    assertThat(StringUtils.uncapitalize(capitalized)).isEqualTo(\"i am capitalized\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#getFilename()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFilename() {\r\n    assertThat(StringUtils.getFilename(null)).isNull();\r\n    assertThat(StringUtils.getFilename(\"\")).isEmpty();\r\n    assertThat(StringUtils.getFilename(\"myfile\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.getFilename(\"mypath/myfile\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.getFilename(\"myfile.\")).isEqualTo(\"myfile.\");\r\n    assertThat(StringUtils.getFilename(\"mypath/myfile.\")).isEqualTo(\"myfile.\");\r\n    assertThat(StringUtils.getFilename(\"myfile.txt\")).isEqualTo(\"myfile.txt\");\r\n    assertThat(StringUtils.getFilename(\"mypath/myfile.txt\")).isEqualTo(\"myfile.txt\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#getFilenameExtension()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFilenameExtension() {\r\n    assertThat(StringUtils.getFilenameExtension(null)).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"myfile\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"myPath/myfile\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"/home/user/.m2/settings/myfile\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"myfile.\")).isEmpty();\r\n    assertThat(StringUtils.getFilenameExtension(\"myPath/myfile.\")).isEmpty();\r\n    assertThat(StringUtils.getFilenameExtension(\"myfile.txt\")).isEqualTo(\"txt\");\r\n    assertThat(StringUtils.getFilenameExtension(\"mypath/myfile.txt\")).isEqualTo(\"txt\");\r\n    assertThat(StringUtils.getFilenameExtension(\"/home/user/.m2/settings/myfile.txt\")).isEqualTo(\"txt\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#stripFilenameExtension()",
    "entityType": "method",
    "code": "@Test\r\nvoid stripFilenameExtension() {\r\n    assertThat(StringUtils.stripFilenameExtension(\"\")).isEmpty();\r\n    assertThat(StringUtils.stripFilenameExtension(\"myfile\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"myfile.\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"myfile.txt\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"mypath/myfile.\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"mypath/myfile.txt\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile.\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile.txt\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#cleanPath()",
    "entityType": "method",
    "code": "@Test\r\nvoid cleanPath() {\r\n    assertThat(StringUtils.cleanPath(\"mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath\\\\myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/../mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/myfile/../../mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"../mypath/../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/../../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"/../mypath/myfile\")).isEqualTo(\"/../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"/a/:b/../../mypath/myfile\")).isEqualTo(\"/mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"/\")).isEqualTo(\"/\");\r\n    assertThat(StringUtils.cleanPath(\"/mypath/../\")).isEqualTo(\"/\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/..\")).isEmpty();\r\n    assertThat(StringUtils.cleanPath(\"mypath/../.\")).isEmpty();\r\n    assertThat(StringUtils.cleanPath(\"mypath/../\")).isEqualTo(\"./\");\r\n    assertThat(StringUtils.cleanPath(\"././\")).isEqualTo(\"./\");\r\n    assertThat(StringUtils.cleanPath(\"./\")).isEqualTo(\"./\");\r\n    assertThat(StringUtils.cleanPath(\"../\")).isEqualTo(\"../\");\r\n    assertThat(StringUtils.cleanPath(\"./../\")).isEqualTo(\"../\");\r\n    assertThat(StringUtils.cleanPath(\".././\")).isEqualTo(\"../\");\r\n    assertThat(StringUtils.cleanPath(\"file:/\")).isEqualTo(\"file:/\");\r\n    assertThat(StringUtils.cleanPath(\"file:/mypath/../\")).isEqualTo(\"file:/\");\r\n    assertThat(StringUtils.cleanPath(\"file:mypath/..\")).isEqualTo(\"file:\");\r\n    assertThat(StringUtils.cleanPath(\"file:mypath/../.\")).isEqualTo(\"file:\");\r\n    assertThat(StringUtils.cleanPath(\"file:mypath/../\")).isEqualTo(\"file:./\");\r\n    assertThat(StringUtils.cleanPath(\"file:././\")).isEqualTo(\"file:./\");\r\n    assertThat(StringUtils.cleanPath(\"file:./\")).isEqualTo(\"file:./\");\r\n    assertThat(StringUtils.cleanPath(\"file:../\")).isEqualTo(\"file:../\");\r\n    assertThat(StringUtils.cleanPath(\"file:./../\")).isEqualTo(\"file:../\");\r\n    assertThat(StringUtils.cleanPath(\"file:.././\")).isEqualTo(\"file:../\");\r\n    assertThat(StringUtils.cleanPath(\"file:/mypath/spring.factories\")).isEqualTo(\"file:/mypath/spring.factories\");\r\n    assertThat(StringUtils.cleanPath(\"file:///c:/some/../path/the%20file.txt\")).isEqualTo(\"file:///c:/path/the%20file.txt\");\r\n    assertThat(StringUtils.cleanPath(\"jar:file:///c:\\\\some\\\\..\\\\path\\\\.\\\\the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\r\n    assertThat(StringUtils.cleanPath(\"jar:file:///c:/some/../path/./the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\r\n    assertThat(StringUtils.cleanPath(\"jar:file:///c:\\\\\\\\some\\\\\\\\..\\\\\\\\path\\\\\\\\.\\\\\\\\the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#pathEquals()",
    "entityType": "method",
    "code": "@Test\r\nvoid pathEquals() {\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for the same strings\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\dummy2\\\\dummy3\")).as(\"Must be true for the same win strings\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for one top path on 1\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\..\\\\dummy2\\\\dummy3\")).as(\"Must be true for one win top path on 2\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/bin/../dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for two top paths on 1\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\..\\\\dummy2\\\\bin\\\\..\\\\dummy3\")).as(\"Must be true for two win top paths on 2\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/tmp/../../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for double top paths on 1\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dum/dum/../../dummy2/dummy3\")).as(\"Must be true for double top paths on 2 with similarity\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"./dummy1/dummy2/dummy3\", \"dummy1/dum/./dum/../../dummy2/dummy3\")).as(\"Must be true for current paths\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"./dummy1/dummy2/dummy3\", \"/dummy1/dum/./dum/../../dummy2/dummy3\")).as(\"Must be false for relative/absolute paths\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dummy4/dummy3\")).as(\"Must be false for different strings\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/tmp/../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be false for one false path on 1\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\tmp\\\\..\\\\dummy2\\\\dummy3\")).as(\"Must be false for one false win top path on 2\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/dummy3\", \"/dummy1/dummy2/dummy4\")).as(\"Must be false for top path on 1 + difference\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#concatenateStringArrays()",
    "entityType": "method",
    "code": "@Test\r\nvoid concatenateStringArrays() {\r\n    String[] input1 = new String[] { \"myString2\" };\r\n    String[] input2 = new String[] { \"myString1\", \"myString2\" };\r\n    String[] result = StringUtils.concatenateStringArrays(input1, input2);\r\n    assertThat(result).hasSize(3);\r\n    assertThat(result[0]).isEqualTo(\"myString2\");\r\n    assertThat(result[1]).isEqualTo(\"myString1\");\r\n    assertThat(result[2]).isEqualTo(\"myString2\");\r\n    assertThat(StringUtils.concatenateStringArrays(input1, null)).isEqualTo(input1);\r\n    assertThat(StringUtils.concatenateStringArrays(null, input2)).isEqualTo(input2);\r\n    assertThat(StringUtils.concatenateStringArrays(null, null)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#sortStringArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid sortStringArray() {\r\n    String[] input = new String[] { \"myString2\" };\r\n    input = StringUtils.addStringToArray(input, \"myString1\");\r\n    assertThat(input[0]).isEqualTo(\"myString2\");\r\n    assertThat(input[1]).isEqualTo(\"myString1\");\r\n    StringUtils.sortStringArray(input);\r\n    assertThat(input[0]).isEqualTo(\"myString1\");\r\n    assertThat(input[1]).isEqualTo(\"myString2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimArrayElements()",
    "entityType": "method",
    "code": "@Test\r\nvoid trimArrayElements() {\r\n    assertThat(StringUtils.trimArrayElements(null)).isNull();\r\n    assertThat(StringUtils.trimArrayElements(new String[] ;)).isEmpty();\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"\", \" \", \"  \", \"   \" })).containsExactly(\"\", \"\", \"\", \"\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"\\n\", \"\\t \", \"\\n\\t\" })).containsExactly(\"\", \"\", \"\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"a\", \"b\", \"c\" })).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"  a  \", \"  b b \", \"  cc  \" })).containsExactly(\"a\", \"b b\", \"cc\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"  a  \", \"b\", \"  c  \" })).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { null, \"  a  \", null })).containsExactly(null, \"a\", null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#removeDuplicateStrings()",
    "entityType": "method",
    "code": "@Test\r\nvoid removeDuplicateStrings() {\r\n    String[] input = new String[] { \"myString2\", \"myString1\", \"myString2\" };\r\n    input = StringUtils.removeDuplicateStrings(input);\r\n    assertThat(input[0]).isEqualTo(\"myString2\");\r\n    assertThat(input[1]).isEqualTo(\"myString1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#splitArrayElementsIntoProperties()",
    "entityType": "method",
    "code": "@Test\r\nvoid splitArrayElementsIntoProperties() {\r\n    String[] input = new String[] { \"key1=value1 \", \"key2 =\\\"value2\\\"\" };\r\n    Properties result = StringUtils.splitArrayElementsIntoProperties(input, \"=\");\r\n    assertThat(result.getProperty(\"key1\")).isEqualTo(\"value1\");\r\n    assertThat(result.getProperty(\"key2\")).isEqualTo(\"\\\"value2\\\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#splitArrayElementsIntoPropertiesAndDeletedChars()",
    "entityType": "method",
    "code": "@Test\r\nvoid splitArrayElementsIntoPropertiesAndDeletedChars() {\r\n    String[] input = new String[] { \"key1=value1 \", \"key2 =\\\"value2\\\"\" };\r\n    Properties result = StringUtils.splitArrayElementsIntoProperties(input, \"=\", \"\\\"\");\r\n    assertThat(result.getProperty(\"key1\")).isEqualTo(\"value1\");\r\n    assertThat(result.getProperty(\"key2\")).isEqualTo(\"value2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#tokenizeToStringArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid tokenizeToStringArray() {\r\n    String[] sa = StringUtils.tokenizeToStringArray(\"a,b , ,c\", \",\");\r\n    assertThat(sa).hasSize(3);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].equals(\"b\") && sa[2].equals(\"c\")).as(\"components are correct\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#tokenizeToStringArrayWithNotIgnoreEmptyTokens()",
    "entityType": "method",
    "code": "@Test\r\nvoid tokenizeToStringArrayWithNotIgnoreEmptyTokens() {\r\n    String[] sa = StringUtils.tokenizeToStringArray(\"a,b , ,c\", \",\", true, false);\r\n    assertThat(sa).hasSize(4);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].equals(\"b\") && sa[2].isEmpty() && sa[3].equals(\"c\")).as(\"components are correct\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#tokenizeToStringArrayWithNotTrimTokens()",
    "entityType": "method",
    "code": "@Test\r\nvoid tokenizeToStringArrayWithNotTrimTokens() {\r\n    String[] sa = StringUtils.tokenizeToStringArray(\"a,b ,c\", \",\", false, true);\r\n    assertThat(sa).hasSize(3);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].equals(\"b \") && sa[2].equals(\"c\")).as(\"components are correct\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#commaDelimitedListToStringArrayWithNullProducesEmptyArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid commaDelimitedListToStringArrayWithNullProducesEmptyArray() {\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(null);\r\n    assertThat(sa).as(\"String array isn't null with null input\").isNotNull();\r\n    assertThat(sa.length).as(\"String array length == 0 with null input\").isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#commaDelimitedListToStringArrayWithEmptyStringProducesEmptyArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid commaDelimitedListToStringArrayWithEmptyStringProducesEmptyArray() {\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(\"\");\r\n    assertThat(sa).as(\"String array isn't null with null input\").isNotNull();\r\n    assertThat(sa.length).as(\"String array length == 0 with null input\").isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delimitedListToStringArrayWithComma()",
    "entityType": "method",
    "code": "@Test\r\nvoid delimitedListToStringArrayWithComma() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b\", \",\");\r\n    assertThat(sa).hasSize(2);\r\n    assertThat(sa[0]).isEqualTo(\"a\");\r\n    assertThat(sa[1]).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delimitedListToStringArrayWithSemicolon()",
    "entityType": "method",
    "code": "@Test\r\nvoid delimitedListToStringArrayWithSemicolon() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a;b\", \";\");\r\n    assertThat(sa).hasSize(2);\r\n    assertThat(sa[0]).isEqualTo(\"a\");\r\n    assertThat(sa[1]).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delimitedListToStringArrayWithEmptyDelimiter()",
    "entityType": "method",
    "code": "@Test\r\nvoid delimitedListToStringArrayWithEmptyDelimiter() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b\", \"\");\r\n    assertThat(sa).hasSize(3);\r\n    assertThat(sa[0]).isEqualTo(\"a\");\r\n    assertThat(sa[1]).isEqualTo(\",\");\r\n    assertThat(sa[2]).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delimitedListToStringArrayWithNullDelimiter()",
    "entityType": "method",
    "code": "@Test\r\nvoid delimitedListToStringArrayWithNullDelimiter() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b\", null);\r\n    assertThat(sa).hasSize(1);\r\n    assertThat(sa[0]).isEqualTo(\"a,b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delimitedListToStringArrayWithCharacterToDelete()",
    "entityType": "method",
    "code": "@Test\r\nvoid delimitedListToStringArrayWithCharacterToDelete() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b,c\", \",\", \"a\");\r\n    assertThat(sa).containsExactly(\"\", \"b\", \"c\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#delimitedListToStringArrayWithCharacterToDeleteEqualsToDelimiter()",
    "entityType": "method",
    "code": "@Test\r\nvoid delimitedListToStringArrayWithCharacterToDeleteEqualsToDelimiter() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b,c\", \",\", \",\");\r\n    assertThat(sa).containsExactly(\"a\", \"b\", \"c\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#commaDelimitedListToStringArrayMatchWords()",
    "entityType": "method",
    "code": "@Test\r\nvoid commaDelimitedListToStringArrayMatchWords() {\r\n    // Could read these from files\r\n    String[] sa = new String[] { \"foo\", \"bar\", \"big\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n    doTestStringArrayReverseTransformationMatches(sa);\r\n    sa = new String[] { \"a\", \"b\", \"c\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n    doTestStringArrayReverseTransformationMatches(sa);\r\n    // Test same words\r\n    sa = new String[] { \"AA\", \"AA\", \"AA\", \"AA\", \"AA\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n    doTestStringArrayReverseTransformationMatches(sa);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#doTestStringArrayReverseTransformationMatches(String[])",
    "entityType": "method",
    "code": "private void doTestStringArrayReverseTransformationMatches(String[] sa) {\r\n    String[] reverse = StringUtils.commaDelimitedListToStringArray(StringUtils.arrayToCommaDelimitedString(sa));\r\n    assertThat(Arrays.asList(reverse)).as(\"Reverse transformation is equal\").isEqualTo(Arrays.asList(sa));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#commaDelimitedListToStringArraySingleString()",
    "entityType": "method",
    "code": "@Test\r\nvoid commaDelimitedListToStringArraySingleString() {\r\n    // Could read these from files\r\n    String s = \"woeirqupoiewuropqiewuorpqiwueopriquwopeiurqopwieur\";\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(s);\r\n    assertThat(sa.length).as(\"Found one String with no delimiters\").isEqualTo(1);\r\n    assertThat(sa[0]).as(\"Single array entry matches input String with no delimiters\").isEqualTo(s);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#commaDelimitedListToStringArrayWithOtherPunctuation()",
    "entityType": "method",
    "code": "@Test\r\nvoid commaDelimitedListToStringArrayWithOtherPunctuation() {\r\n    // Could read these from files\r\n    String[] sa = new String[] { \"xcvwert4456346&*.\", \"///\", \".!\", \".\", \";\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassTooLargeException",
    "entityType": "class",
    "code": "private static final long serialVersionUID = 160715609518896765L;\nprivate final String className;\nprivate final int constantPoolCount;\n/**\r\n * Constructs a new {@link ClassTooLargeException}.\r\n *\r\n * @param className the internal name of the class (see {@link\r\n *     org.objectweb.asm.Type#getInternalName()}).\r\n * @param constantPoolCount the number of constant pool items of the class.\r\n */\r\npublic ClassTooLargeException(final String className, final int constantPoolCount) {\r\n    super(\"Class too large: \" + className);\r\n    this.className = className;\r\n    this.constantPoolCount = constantPoolCount;\r\n}\n/**\r\n * Returns the internal name of the class (see {@link org.objectweb.asm.Type#getInternalName()}).\r\n *\r\n * @return the internal name of the class.\r\n */\r\npublic String getClassName() {\r\n    return className;\r\n}\n/**\r\n * Returns the number of constant pool items of the class.\r\n *\r\n * @return the number of constant pool items of the class.\r\n */\r\npublic int getConstantPoolCount() {\r\n    return constantPoolCount;\r\n}",
    "comment": "\n * Exception thrown when the constant pool of a class produced by a {@link ClassWriter} is too\n * large.\n *\n * @author Jason Zaugg\n "
  },
  {
    "entityId": "org.springframework.asm.ClassTooLargeException#getClassName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the class (see {@link org.objectweb.asm.Type#getInternalName()}).\r\n *\r\n * @return the internal name of the class.\r\n */\r\npublic String getClassName() {\r\n    return className;\r\n}",
    "comment": "\n   * Returns the internal name of the class (see {@link org.objectweb.asm.Type#getInternalName()}).\n   *\n   * @return the internal name of the class.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassTooLargeException#getConstantPoolCount()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of constant pool items of the class.\r\n *\r\n * @return the number of constant pool items of the class.\r\n */\r\npublic int getConstantPoolCount() {\r\n    return constantPoolCount;\r\n}",
    "comment": "\n   * Returns the number of constant pool items of the class.\n   *\n   * @return the number of constant pool items of the class.\n   "
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#commaDelimitedListToStringArrayEmptyStrings()",
    "entityType": "method",
    "code": "/**\r\n * We expect to see the empty Strings in the output.\r\n */\r\n@Test\r\nvoid commaDelimitedListToStringArrayEmptyStrings() {\r\n    // Could read these from files\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(\"a,,b\");\r\n    assertThat(sa.length).as(\"a,,b produces array length 3\").isEqualTo(3);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].isEmpty() && sa[2].equals(\"b\")).as(\"components are correct\").isTrue();\r\n    sa = new String[] { \"\", \"\", \"a\", \"\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n}",
    "comment": "\n\t * We expect to see the empty Strings in the output.\n\t "
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#doTestCommaDelimitedListToStringArrayLegalMatch(String[])",
    "entityType": "method",
    "code": "private void doTestCommaDelimitedListToStringArrayLegalMatch(String[] components) {\r\n    String sb = String.join(String.valueOf(','), components);\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(sb);\r\n    assertThat(sa).as(\"String array isn't null with legal match\").isNotNull();\r\n    assertThat(sa.length).as(\"String array length is correct with legal match\").isEqualTo(components.length);\r\n    assertThat(Arrays.equals(sa, components)).as(\"Output equals input\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleStringSunnyDay()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseLocaleStringSunnyDay() {\r\n    Locale expectedLocale = Locale.UK;\r\n    Locale locale = StringUtils.parseLocaleString(expectedLocale.toString());\r\n    assertThat(locale).as(\"When given a bona-fide Locale string, must not return null.\").isNotNull();\r\n    assertThat(locale).isEqualTo(expectedLocale);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleStringWithEmptyLocaleStringYieldsNullLocale()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseLocaleStringWithEmptyLocaleStringYieldsNullLocale() {\r\n    Locale locale = StringUtils.parseLocaleString(\"\");\r\n    assertThat(locale).as(\"When given an empty Locale string, must return null.\").isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithMultiSpecialCharactersInVariant()",
    "entityType": "method",
    "code": "// SPR-8637\r\n@Test\r\nvoid parseLocaleWithMultiSpecialCharactersInVariant() {\r\n    String variant = \"proper-northern\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithMultiValuedVariant()",
    "entityType": "method",
    "code": "// SPR-3671\r\n@Test\r\nvoid parseLocaleWithMultiValuedVariant() {\r\n    String variant = \"proper_northern\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithMultiValuedVariantUsingSpacesAsSeparators()",
    "entityType": "method",
    "code": "// SPR-3671\r\n@Test\r\nvoid parseLocaleWithMultiValuedVariantUsingSpacesAsSeparators() {\r\n    String variant = \"proper northern\";\r\n    String localeString = \"en GB \" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithMultiValuedVariantUsingMixtureOfUnderscoresAndSpacesAsSeparators()",
    "entityType": "method",
    "code": "// SPR-3671\r\n@Test\r\nvoid parseLocaleWithMultiValuedVariantUsingMixtureOfUnderscoresAndSpacesAsSeparators() {\r\n    String variant = \"proper northern\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithInvalidCharacters()",
    "entityType": "method",
    "code": "// SPR-7779\r\n@Test\r\nvoid parseLocaleWithInvalidCharacters() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> StringUtils.parseLocaleString(\"%0D%0AContent-length:30%0D%0A%0D%0A%3Cscript%3Ealert%28123%29%3C/script%3E\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithSameLowercaseTokenForLanguageAndCountry()",
    "entityType": "method",
    "code": "// SPR-9420\r\n@Test\r\nvoid parseLocaleWithSameLowercaseTokenForLanguageAndCountry() {\r\n    assertThat(StringUtils.parseLocaleString(\"tr_tr\").toString()).isEqualTo(\"tr_TR\");\r\n    assertThat(StringUtils.parseLocaleString(\"bg_bg_vnt\").toString()).isEqualTo(\"bg_BG_vnt\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleWithVariantContainingCountryCode()",
    "entityType": "method",
    "code": "// SPR-11806\r\n@Test\r\nvoid parseLocaleWithVariantContainingCountryCode() {\r\n    String variant = \"GBtest\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Variant containing country code not extracted correctly\").isEqualTo(variant);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseJava7Variant()",
    "entityType": "method",
    "code": "// SPR-14718, SPR-7598\r\n@Test\r\nvoid parseJava7Variant() {\r\n    assertThat(StringUtils.parseLocaleString(\"sr__#LATN\").toString()).isEqualTo(\"sr__#LATN\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#availableLocalesWithLocaleString()",
    "entityType": "method",
    "code": "// SPR-16651\r\n@Test\r\nvoid availableLocalesWithLocaleString() {\r\n    for (Locale locale : Locale.getAvailableLocales()) {\r\n        Locale parsedLocale = StringUtils.parseLocaleString(locale.toString());\r\n        if (parsedLocale == null) {\r\n            assertThat(locale.getLanguage()).isEmpty();\r\n        } else {\r\n            assertThat(locale.toString()).isEqualTo(parsedLocale.toString());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#availableLocalesWithLanguageTag()",
    "entityType": "method",
    "code": "// SPR-16651\r\n@Test\r\nvoid availableLocalesWithLanguageTag() {\r\n    for (Locale locale : Locale.getAvailableLocales()) {\r\n        Locale parsedLocale = StringUtils.parseLocale(locale.toLanguageTag());\r\n        if (parsedLocale == null) {\r\n            assertThat(locale.getLanguage()).isEmpty();\r\n        } else {\r\n            assertThat(locale.toLanguageTag()).isEqualTo(parsedLocale.toLanguageTag());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#invalidLocaleWithLocaleString()",
    "entityType": "method",
    "code": "@Test\r\nvoid invalidLocaleWithLocaleString() {\r\n    assertThat(StringUtils.parseLocaleString(\"invalid\")).isEqualTo(new Locale(\"invalid\"));\r\n    assertThat(StringUtils.parseLocaleString(\"invalidvalue\")).isEqualTo(new Locale(\"invalidvalue\"));\r\n    assertThat(StringUtils.parseLocaleString(\"invalidvalue_foo\")).isEqualTo(new Locale(\"invalidvalue\", \"foo\"));\r\n    assertThat(StringUtils.parseLocaleString(\"\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#invalidLocaleWithLanguageTag()",
    "entityType": "method",
    "code": "@Test\r\nvoid invalidLocaleWithLanguageTag() {\r\n    assertThat(StringUtils.parseLocale(\"invalid\")).isEqualTo(new Locale(\"invalid\"));\r\n    assertThat(StringUtils.parseLocale(\"invalidvalue\")).isEqualTo(new Locale(\"invalidvalue\"));\r\n    assertThat(StringUtils.parseLocale(\"invalidvalue_foo\")).isEqualTo(new Locale(\"invalidvalue\", \"foo\"));\r\n    assertThat(StringUtils.parseLocale(\"\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#parseLocaleStringWithEmptyCountryAndVariant()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseLocaleStringWithEmptyCountryAndVariant() {\r\n    assertThat(StringUtils.parseLocale(\"be__TARASK\").toString()).isEqualTo(\"be__TARASK\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#split()",
    "entityType": "method",
    "code": "@Test\r\nvoid split() {\r\n    assertThat(StringUtils.split(\"Hello, world\", \",\")).containsExactly(\"Hello\", \" world\");\r\n    assertThat(StringUtils.split(\",Hello world\", \",\")).containsExactly(\"\", \"Hello world\");\r\n    assertThat(StringUtils.split(\"Hello world,\", \",\")).containsExactly(\"Hello world\", \"\");\r\n    assertThat(StringUtils.split(\"Hello, world,\", \",\")).containsExactly(\"Hello\", \" world,\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#splitWithEmptyStringOrNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid splitWithEmptyStringOrNull() {\r\n    assertThat(StringUtils.split(\"Hello, world\", \"\")).isNull();\r\n    assertThat(StringUtils.split(\"\", \",\")).isNull();\r\n    assertThat(StringUtils.split(null, \",\")).isNull();\r\n    assertThat(StringUtils.split(\"Hello, world\", null)).isNull();\r\n    assertThat(StringUtils.split(null, null)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#collectionToDelimitedStringWithNullValuesShouldNotFail()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectionToDelimitedStringWithNullValuesShouldNotFail() {\r\n    assertThat(StringUtils.collectionToCommaDelimitedString(Collections.singletonList(null))).isEqualTo(\"null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#truncatePreconditions()",
    "entityType": "method",
    "code": "@Test\r\nvoid truncatePreconditions() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> StringUtils.truncate(\"foo\", 0)).withMessage(\"Truncation threshold must be a positive number: 0\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> StringUtils.truncate(\"foo\", -99)).withMessage(\"Truncation threshold must be a positive number: -99\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#truncate(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@CsvSource(delimiterString = \"-->\", textBlock = \"\"\"\r\n    ''                  --> ''\r\n    aardvark            --> aardvark\r\n    aardvark12          --> aardvark12\r\n    aardvark123         --> aardvark12 (truncated)...\r\n    aardvark, bird, cat --> aardvark,  (truncated)...\r\n    \"\"\")\r\nvoid truncate(String text, String truncated) {\r\n    assertThat(StringUtils.truncate(text, 10)).isEqualTo(truncated);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid replaceFromSystemProperty() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}\n@Test\r\nvoid replaceFromSystemPropertyWithDefault() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:foo}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}\n@Test\r\nvoid replaceFromSystemPropertyWithExpressionDefault() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:#{foo.bar}}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}\n@Test\r\nvoid replaceFromSystemPropertyWithExpressionContainingDefault() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:Y#{foo.bar}X}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}\n@Test\r\nvoid replaceWithDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:foo}\");\r\n    assertThat(resolved).isEqualTo(\"foo\");\r\n}\n@Test\r\nvoid replaceWithExpressionDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:#{foo.bar}}\");\r\n    assertThat(resolved).isEqualTo(\"#{foo.bar}\");\r\n}\n@Test\r\nvoid replaceWithExpressionContainingDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:Y#{foo.bar}X}\");\r\n    assertThat(resolved).isEqualTo(\"Y#{foo.bar}X\");\r\n}\n@Test\r\nvoid replaceWithNoDefault() {\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\"));\r\n}\n@Test\r\nvoid replaceWithNoDefaultIgnored() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\", true);\r\n    assertThat(resolved).isEqualTo(\"${test.prop}\");\r\n}\n@Test\r\nvoid replaceWithEmptyDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:}\");\r\n    assertThat(resolved).isEmpty();\r\n}\n@Test\r\nvoid recursiveFromSystemProperty() {\r\n    System.setProperty(\"test.prop\", \"foo=${bar}\");\r\n    System.setProperty(\"bar\", \"baz\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\");\r\n        assertThat(resolved).isEqualTo(\"foo=baz\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n        System.clearProperty(\"bar\");\r\n    }\r\n}\n@Test\r\nvoid replaceFromEnv() {\r\n    Map<String, String> env = System.getenv();\r\n    if (env.containsKey(\"PATH\")) {\r\n        String text = \"${PATH}\";\r\n        assertThat(SystemPropertyUtils.resolvePlaceholders(text)).isEqualTo(env.get(\"PATH\"));\r\n    }\r\n}",
    "comment": "\n * @author Rob Harrop\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceFromSystemProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceFromSystemProperty() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceFromSystemPropertyWithDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceFromSystemPropertyWithDefault() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:foo}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceFromSystemPropertyWithExpressionDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceFromSystemPropertyWithExpressionDefault() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:#{foo.bar}}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceFromSystemPropertyWithExpressionContainingDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceFromSystemPropertyWithExpressionContainingDefault() {\r\n    System.setProperty(\"test.prop\", \"bar\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:Y#{foo.bar}X}\");\r\n        assertThat(resolved).isEqualTo(\"bar\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceWithDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceWithDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:foo}\");\r\n    assertThat(resolved).isEqualTo(\"foo\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceWithExpressionDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceWithExpressionDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:#{foo.bar}}\");\r\n    assertThat(resolved).isEqualTo(\"#{foo.bar}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceWithExpressionContainingDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceWithExpressionContainingDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:Y#{foo.bar}X}\");\r\n    assertThat(resolved).isEqualTo(\"Y#{foo.bar}X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceWithNoDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceWithNoDefault() {\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceWithNoDefaultIgnored()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceWithNoDefaultIgnored() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\", true);\r\n    assertThat(resolved).isEqualTo(\"${test.prop}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceWithEmptyDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceWithEmptyDefault() {\r\n    String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop:}\");\r\n    assertThat(resolved).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#recursiveFromSystemProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid recursiveFromSystemProperty() {\r\n    System.setProperty(\"test.prop\", \"foo=${bar}\");\r\n    System.setProperty(\"bar\", \"baz\");\r\n    try {\r\n        String resolved = SystemPropertyUtils.resolvePlaceholders(\"${test.prop}\");\r\n        assertThat(resolved).isEqualTo(\"foo=baz\");\r\n    } finally {\r\n        System.clearProperty(\"test.prop\");\r\n        System.clearProperty(\"bar\");\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SystemPropertyUtilsTests#replaceFromEnv()",
    "entityType": "method",
    "code": "@Test\r\nvoid replaceFromEnv() {\r\n    Map<String, String> env = System.getenv();\r\n    if (env.containsKey(\"PATH\")) {\r\n        String text = \"${PATH}\";\r\n        assertThat(SystemPropertyUtils.resolvePlaceholders(text)).isEqualTo(env.get(\"PATH\"));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor",
    "entityType": "class",
    "code": "/**\r\n * The ASM API version implemented by this visitor. The value of this field must be one of the\r\n * {@code ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected final int api;\n/**\r\n * The class visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n */\r\nprotected ClassVisitor cv;\n/**\r\n * Constructs a new {@link ClassVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected ClassVisitor(final int api) {\r\n    this(api, null);\r\n}\n/**\r\n * Constructs a new {@link ClassVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n * @param classVisitor the class visitor to which this visitor must delegate method calls. May be\r\n *     null.\r\n */\r\nprotected ClassVisitor(final int api, final ClassVisitor classVisitor) {\r\n    if (api != Opcodes.ASM9 && api != Opcodes.ASM8 && api != Opcodes.ASM7 && api != Opcodes.ASM6 && api != Opcodes.ASM5 && api != Opcodes.ASM4 && api != Opcodes.ASM10_EXPERIMENTAL) {\r\n        throw new IllegalArgumentException(\"Unsupported api \" + api);\r\n    }\r\n    // SPRING PATCH: no preview mode check for ASM experimental\r\n    this.api = api;\r\n    this.cv = classVisitor;\r\n}\n/**\r\n * The class visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the class visitor to which this visitor must delegate method calls, or {@literal null}.\r\n */\r\npublic ClassVisitor getDelegate() {\r\n    return cv;\r\n}\n/**\r\n * Visits the header of the class.\r\n *\r\n * @param version the class version. The minor version is stored in the 16 most significant bits,\r\n *     and the major version in the 16 least significant bits.\r\n * @param access the class's access flags (see {@link Opcodes}). This parameter also indicates if\r\n *     the class is deprecated {@link Opcodes#ACC_DEPRECATED} or a record {@link\r\n *     Opcodes#ACC_RECORD}.\r\n * @param name the internal name of the class (see {@link Type#getInternalName()}).\r\n * @param signature the signature of this class. May be {@literal null} if the class is not a\r\n *     generic one, and does not extend or implement generic classes or interfaces.\r\n * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).\r\n *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the\r\n *     {@link Object} class.\r\n * @param interfaces the internal names of the class's interfaces (see {@link\r\n *     Type#getInternalName()}). May be {@literal null}.\r\n */\r\npublic void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\r\n    if (api < Opcodes.ASM8 && (access & Opcodes.ACC_RECORD) != 0) {\r\n        throw new UnsupportedOperationException(\"Records requires ASM8\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visit(version, access, name, signature, superName, interfaces);\r\n    }\r\n}\n/**\r\n * Visits the source of the class.\r\n *\r\n * @param source the name of the source file from which the class was compiled. May be {@literal\r\n *     null}.\r\n * @param debug additional debug information to compute the correspondence between source and\r\n *     compiled elements of the class. May be {@literal null}.\r\n */\r\npublic void visitSource(final String source, final String debug) {\r\n    if (cv != null) {\r\n        cv.visitSource(source, debug);\r\n    }\r\n}\n/**\r\n * Visit the module corresponding to the class.\r\n *\r\n * @param name the fully qualified name (using dots) of the module.\r\n * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\r\n *     ACC_MANDATED}.\r\n * @param version the module version, or {@literal null}.\r\n * @return a visitor to visit the module values, or {@literal null} if this visitor is not\r\n *     interested in visiting this module.\r\n */\r\npublic ModuleVisitor visitModule(final String name, final int access, final String version) {\r\n    if (api < Opcodes.ASM6) {\r\n        throw new UnsupportedOperationException(\"Module requires ASM6\");\r\n    }\r\n    if (cv != null) {\r\n        return cv.visitModule(name, access, version);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits the nest host class of the class. A nest is a set of classes of the same package that\r\n * share access to their private members. One of these classes, called the host, lists the other\r\n * members of the nest, which in turn should link to the host of their nest. This method must be\r\n * called only once and only if the visited class is a non-host member of a nest. A class is\r\n * implicitly its own nest, so it's invalid to call this method with the visited class name as\r\n * argument.\r\n *\r\n * @param nestHost the internal name of the host class of the nest (see {@link\r\n *     Type#getInternalName()}).\r\n */\r\npublic void visitNestHost(final String nestHost) {\r\n    if (api < Opcodes.ASM7) {\r\n        throw new UnsupportedOperationException(\"NestHost requires ASM7\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visitNestHost(nestHost);\r\n    }\r\n}\n/**\r\n * Visits the enclosing class of the class. This method must be called only if this class is a\r\n * local or anonymous class. See the JVMS 4.7.7 section for more details.\r\n *\r\n * @param owner internal name of the enclosing class of the class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the name of the method that contains the class, or {@literal null} if the class is\r\n *     not enclosed in a method or constructor of its enclosing class (for example, if it is enclosed in\r\n *     an instance initializer, static initializer, instance variable initializer, or class\r\n *     variable initializer).\r\n * @param descriptor the descriptor of the method that contains the class, or {@literal null} if\r\n *     the class is not enclosed in a method or constructor of its enclosing class (for example, if it is\r\n *     enclosed in an instance initializer, static initializer, instance variable initializer, or\r\n *     class variable initializer).\r\n */\r\npublic void visitOuterClass(final String owner, final String name, final String descriptor) {\r\n    if (cv != null) {\r\n        cv.visitOuterClass(owner, name, descriptor);\r\n    }\r\n}\n/**\r\n * Visits an annotation of the class.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (cv != null) {\r\n        return cv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits an annotation on a type in the class signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\r\n *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\r\n *     {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(\"TypeAnnotation requires ASM5\");\r\n    }\r\n    if (cv != null) {\r\n        return cv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a non standard attribute of the class.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (cv != null) {\r\n        cv.visitAttribute(attribute);\r\n    }\r\n}\n/**\r\n * Visits a member of the nest. A nest is a set of classes of the same package that share access\r\n * to their private members. One of these classes, called the host, lists the other members of the\r\n * nest, which in turn should link to the host of their nest. This method must be called only if\r\n * the visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\r\n * it's invalid to call this method with the visited class name as argument.\r\n *\r\n * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\r\n */\r\npublic void visitNestMember(final String nestMember) {\r\n    if (api < Opcodes.ASM7) {\r\n        throw new UnsupportedOperationException(\"NestMember requires ASM7\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visitNestMember(nestMember);\r\n    }\r\n}\n/**\r\n * Visits a permitted subclasses. A permitted subclass is one of the allowed subclasses of the\r\n * current class.\r\n *\r\n * @param permittedSubclass the internal name of a permitted subclass (see {@link\r\n *     Type#getInternalName()}).\r\n */\r\npublic void visitPermittedSubclass(final String permittedSubclass) {\r\n    if (api < Opcodes.ASM9) {\r\n        throw new UnsupportedOperationException(\"PermittedSubclasses requires ASM9\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visitPermittedSubclass(permittedSubclass);\r\n    }\r\n}\n/**\r\n * Visits information about an inner class. This inner class is not necessarily a member of the\r\n * class being visited. More precisely, every class or interface C which is referenced by this\r\n * class and which is not a package member must be visited with this method. This class must\r\n * reference its nested class or interface members, and its enclosing class, if any. See the JVMS\r\n * 4.7.6 section for more details.\r\n *\r\n * @param name the internal name of C (see {@link Type#getInternalName()}).\r\n * @param outerName the internal name of the class or interface C is a member of (see {@link\r\n *     Type#getInternalName()}). Must be {@literal null} if C is not the member of a class or\r\n *     interface (for example, for local or anonymous classes).\r\n * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\r\n * @param access the access flags of C originally declared in the source code from which this\r\n *     class was compiled.\r\n */\r\npublic void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\r\n    if (cv != null) {\r\n        cv.visitInnerClass(name, outerName, innerName, access);\r\n    }\r\n}\n/**\r\n * Visits a record component of the class.\r\n *\r\n * @param name the record component name.\r\n * @param descriptor the record component descriptor (see {@link Type}).\r\n * @param signature the record component signature. May be {@literal null} if the record component\r\n *     type does not use generic types.\r\n * @return a visitor to visit this record component annotations and attributes, or {@literal null}\r\n *     if this class visitor is not interested in visiting these annotations and attributes.\r\n */\r\npublic RecordComponentVisitor visitRecordComponent(final String name, final String descriptor, final String signature) {\r\n    if (api < Opcodes.ASM8) {\r\n        throw new UnsupportedOperationException(\"Record requires ASM8\");\r\n    }\r\n    if (cv != null) {\r\n        return cv.visitRecordComponent(name, descriptor, signature);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a field of the class.\r\n *\r\n * @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\r\n *     the field is synthetic and/or deprecated.\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor (see {@link Type}).\r\n * @param signature the field's signature. May be {@literal null} if the field's type does not use\r\n *     generic types.\r\n * @param value the field's initial value. This parameter, which may be {@literal null} if the\r\n *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\r\n *     Long}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\r\n *     or {@code String} fields respectively). <i>This parameter is only used for static\r\n *     fields</i>. Its value is ignored for non static fields, which must be initialized through\r\n *     bytecode instructions in constructors or methods.\r\n * @return a visitor to visit field annotations and attributes, or {@literal null} if this class\r\n *     visitor is not interested in visiting these annotations and attributes.\r\n */\r\npublic FieldVisitor visitField(final int access, final String name, final String descriptor, final String signature, final Object value) {\r\n    if (cv != null) {\r\n        return cv.visitField(access, name, descriptor, signature, value);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a method of the class. This method <i>must</i> return a new {@link MethodVisitor}\r\n * instance (or {@literal null}) each time it is called, i.e., it should not return a previously\r\n * returned visitor.\r\n *\r\n * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if\r\n *     the method is synthetic and/or deprecated.\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param signature the method's signature. May be {@literal null} if the method parameters,\r\n *     return type and exceptions do not use generic types.\r\n * @param exceptions the internal names of the method's exception classes (see {@link\r\n *     Type#getInternalName()}). May be {@literal null}.\r\n * @return an object to visit the byte code of the method, or {@literal null} if this class\r\n *     visitor is not interested in visiting the code of this method.\r\n */\r\npublic MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {\r\n    if (cv != null) {\r\n        return cv.visitMethod(access, name, descriptor, signature, exceptions);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits the end of the class. This method, which is the last one to be called, is used to inform\r\n * the visitor that all the fields and methods of the class have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (cv != null) {\r\n        cv.visitEnd();\r\n    }\r\n}",
    "comment": "\n * A visitor to visit a Java class. The methods of this class must be called in the following order:\n * {@code visit} [ {@code visitSource} ] [ {@code visitModule} ][ {@code visitNestHost} ][ {@code\n * visitOuterClass} ] ( {@code visitAnnotation} | {@code visitTypeAnnotation} | {@code\n * visitAttribute} )* ( {@code visitNestMember} | [ {@code * visitPermittedSubclass} ] | {@code\n * visitInnerClass} | {@code visitRecordComponent} | {@code visitField} | {@code visitMethod} )*\n * {@code visitEnd}.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#getDelegate()",
    "entityType": "method",
    "code": "/**\r\n * The class visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the class visitor to which this visitor must delegate method calls, or {@literal null}.\r\n */\r\npublic ClassVisitor getDelegate() {\r\n    return cv;\r\n}",
    "comment": "\n   * The class visitor to which this visitor must delegate method calls. May be {@literal null}.\n   *\n   * @return the class visitor to which this visitor must delegate method calls, or {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visit(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "/**\r\n * Visits the header of the class.\r\n *\r\n * @param version the class version. The minor version is stored in the 16 most significant bits,\r\n *     and the major version in the 16 least significant bits.\r\n * @param access the class's access flags (see {@link Opcodes}). This parameter also indicates if\r\n *     the class is deprecated {@link Opcodes#ACC_DEPRECATED} or a record {@link\r\n *     Opcodes#ACC_RECORD}.\r\n * @param name the internal name of the class (see {@link Type#getInternalName()}).\r\n * @param signature the signature of this class. May be {@literal null} if the class is not a\r\n *     generic one, and does not extend or implement generic classes or interfaces.\r\n * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).\r\n *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the\r\n *     {@link Object} class.\r\n * @param interfaces the internal names of the class's interfaces (see {@link\r\n *     Type#getInternalName()}). May be {@literal null}.\r\n */\r\npublic void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {\r\n    if (api < Opcodes.ASM8 && (access & Opcodes.ACC_RECORD) != 0) {\r\n        throw new UnsupportedOperationException(\"Records requires ASM8\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visit(version, access, name, signature, superName, interfaces);\r\n    }\r\n}",
    "comment": "\n   * Visits the header of the class.\n   *\n   * @param version the class version. The minor version is stored in the 16 most significant bits,\n   *     and the major version in the 16 least significant bits.\n   * @param access the class's access flags (see {@link Opcodes}). This parameter also indicates if\n   *     the class is deprecated {@link Opcodes#ACC_DEPRECATED} or a record {@link\n   *     Opcodes#ACC_RECORD}.\n   * @param name the internal name of the class (see {@link Type#getInternalName()}).\n   * @param signature the signature of this class. May be {@literal null} if the class is not a\n   *     generic one, and does not extend or implement generic classes or interfaces.\n   * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).\n   *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the\n   *     {@link Object} class.\n   * @param interfaces the internal names of the class's interfaces (see {@link\n   *     Type#getInternalName()}). May be {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitSource(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits the source of the class.\r\n *\r\n * @param source the name of the source file from which the class was compiled. May be {@literal\r\n *     null}.\r\n * @param debug additional debug information to compute the correspondence between source and\r\n *     compiled elements of the class. May be {@literal null}.\r\n */\r\npublic void visitSource(final String source, final String debug) {\r\n    if (cv != null) {\r\n        cv.visitSource(source, debug);\r\n    }\r\n}",
    "comment": "\n   * Visits the source of the class.\n   *\n   * @param source the name of the source file from which the class was compiled. May be {@literal\n   *     null}.\n   * @param debug additional debug information to compute the correspondence between source and\n   *     compiled elements of the class. May be {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitModule(String,int,String)",
    "entityType": "method",
    "code": "/**\r\n * Visit the module corresponding to the class.\r\n *\r\n * @param name the fully qualified name (using dots) of the module.\r\n * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\r\n *     ACC_MANDATED}.\r\n * @param version the module version, or {@literal null}.\r\n * @return a visitor to visit the module values, or {@literal null} if this visitor is not\r\n *     interested in visiting this module.\r\n */\r\npublic ModuleVisitor visitModule(final String name, final int access, final String version) {\r\n    if (api < Opcodes.ASM6) {\r\n        throw new UnsupportedOperationException(\"Module requires ASM6\");\r\n    }\r\n    if (cv != null) {\r\n        return cv.visitModule(name, access, version);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visit the module corresponding to the class.\n   *\n   * @param name the fully qualified name (using dots) of the module.\n   * @param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\n   *     ACC_MANDATED}.\n   * @param version the module version, or {@literal null}.\n   * @return a visitor to visit the module values, or {@literal null} if this visitor is not\n   *     interested in visiting this module.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitNestHost(String)",
    "entityType": "method",
    "code": "/**\r\n * Visits the nest host class of the class. A nest is a set of classes of the same package that\r\n * share access to their private members. One of these classes, called the host, lists the other\r\n * members of the nest, which in turn should link to the host of their nest. This method must be\r\n * called only once and only if the visited class is a non-host member of a nest. A class is\r\n * implicitly its own nest, so it's invalid to call this method with the visited class name as\r\n * argument.\r\n *\r\n * @param nestHost the internal name of the host class of the nest (see {@link\r\n *     Type#getInternalName()}).\r\n */\r\npublic void visitNestHost(final String nestHost) {\r\n    if (api < Opcodes.ASM7) {\r\n        throw new UnsupportedOperationException(\"NestHost requires ASM7\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visitNestHost(nestHost);\r\n    }\r\n}",
    "comment": "\n   * Visits the nest host class of the class. A nest is a set of classes of the same package that\n   * share access to their private members. One of these classes, called the host, lists the other\n   * members of the nest, which in turn should link to the host of their nest. This method must be\n   * called only once and only if the visited class is a non-host member of a nest. A class is\n   * implicitly its own nest, so it's invalid to call this method with the visited class name as\n   * argument.\n   *\n   * @param nestHost the internal name of the host class of the nest (see {@link\n   *     Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitOuterClass(String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits the enclosing class of the class. This method must be called only if this class is a\r\n * local or anonymous class. See the JVMS 4.7.7 section for more details.\r\n *\r\n * @param owner internal name of the enclosing class of the class (see {@link\r\n *     Type#getInternalName()}).\r\n * @param name the name of the method that contains the class, or {@literal null} if the class is\r\n *     not enclosed in a method or constructor of its enclosing class (for example, if it is enclosed in\r\n *     an instance initializer, static initializer, instance variable initializer, or class\r\n *     variable initializer).\r\n * @param descriptor the descriptor of the method that contains the class, or {@literal null} if\r\n *     the class is not enclosed in a method or constructor of its enclosing class (for example, if it is\r\n *     enclosed in an instance initializer, static initializer, instance variable initializer, or\r\n *     class variable initializer).\r\n */\r\npublic void visitOuterClass(final String owner, final String name, final String descriptor) {\r\n    if (cv != null) {\r\n        cv.visitOuterClass(owner, name, descriptor);\r\n    }\r\n}",
    "comment": "\n   * Visits the enclosing class of the class. This method must be called only if this class is a\n   * local or anonymous class. See the JVMS 4.7.7 section for more details.\n   *\n   * @param owner internal name of the enclosing class of the class (see {@link\n   *     Type#getInternalName()}).\n   * @param name the name of the method that contains the class, or {@literal null} if the class is\n   *     not enclosed in a method or constructor of its enclosing class (for example, if it is enclosed in\n   *     an instance initializer, static initializer, instance variable initializer, or class\n   *     variable initializer).\n   * @param descriptor the descriptor of the method that contains the class, or {@literal null} if\n   *     the class is not enclosed in a method or constructor of its enclosing class (for example, if it is\n   *     enclosed in an instance initializer, static initializer, instance variable initializer, or\n   *     class variable initializer).\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation of the class.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (cv != null) {\r\n        return cv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation of the class.\n   *\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on a type in the class signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\r\n *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\r\n *     {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(\"TypeAnnotation requires ASM5\");\r\n    }\r\n    if (cv != null) {\r\n        return cv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on a type in the class signature.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\n   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\n   *     {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "/**\r\n * Visits a non standard attribute of the class.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (cv != null) {\r\n        cv.visitAttribute(attribute);\r\n    }\r\n}",
    "comment": "\n   * Visits a non standard attribute of the class.\n   *\n   * @param attribute an attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitNestMember(String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a member of the nest. A nest is a set of classes of the same package that share access\r\n * to their private members. One of these classes, called the host, lists the other members of the\r\n * nest, which in turn should link to the host of their nest. This method must be called only if\r\n * the visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\r\n * it's invalid to call this method with the visited class name as argument.\r\n *\r\n * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\r\n */\r\npublic void visitNestMember(final String nestMember) {\r\n    if (api < Opcodes.ASM7) {\r\n        throw new UnsupportedOperationException(\"NestMember requires ASM7\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visitNestMember(nestMember);\r\n    }\r\n}",
    "comment": "\n   * Visits a member of the nest. A nest is a set of classes of the same package that share access\n   * to their private members. One of these classes, called the host, lists the other members of the\n   * nest, which in turn should link to the host of their nest. This method must be called only if\n   * the visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\n   * it's invalid to call this method with the visited class name as argument.\n   *\n   * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitPermittedSubclass(String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a permitted subclasses. A permitted subclass is one of the allowed subclasses of the\r\n * current class.\r\n *\r\n * @param permittedSubclass the internal name of a permitted subclass (see {@link\r\n *     Type#getInternalName()}).\r\n */\r\npublic void visitPermittedSubclass(final String permittedSubclass) {\r\n    if (api < Opcodes.ASM9) {\r\n        throw new UnsupportedOperationException(\"PermittedSubclasses requires ASM9\");\r\n    }\r\n    if (cv != null) {\r\n        cv.visitPermittedSubclass(permittedSubclass);\r\n    }\r\n}",
    "comment": "\n   * Visits a permitted subclasses. A permitted subclass is one of the allowed subclasses of the\n   * current class.\n   *\n   * @param permittedSubclass the internal name of a permitted subclass (see {@link\n   *     Type#getInternalName()}).\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitInnerClass(String,String,String,int)",
    "entityType": "method",
    "code": "/**\r\n * Visits information about an inner class. This inner class is not necessarily a member of the\r\n * class being visited. More precisely, every class or interface C which is referenced by this\r\n * class and which is not a package member must be visited with this method. This class must\r\n * reference its nested class or interface members, and its enclosing class, if any. See the JVMS\r\n * 4.7.6 section for more details.\r\n *\r\n * @param name the internal name of C (see {@link Type#getInternalName()}).\r\n * @param outerName the internal name of the class or interface C is a member of (see {@link\r\n *     Type#getInternalName()}). Must be {@literal null} if C is not the member of a class or\r\n *     interface (for example, for local or anonymous classes).\r\n * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\r\n * @param access the access flags of C originally declared in the source code from which this\r\n *     class was compiled.\r\n */\r\npublic void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\r\n    if (cv != null) {\r\n        cv.visitInnerClass(name, outerName, innerName, access);\r\n    }\r\n}",
    "comment": "\n   * Visits information about an inner class. This inner class is not necessarily a member of the\n   * class being visited. More precisely, every class or interface C which is referenced by this\n   * class and which is not a package member must be visited with this method. This class must\n   * reference its nested class or interface members, and its enclosing class, if any. See the JVMS\n   * 4.7.6 section for more details.\n   *\n   * @param name the internal name of C (see {@link Type#getInternalName()}).\n   * @param outerName the internal name of the class or interface C is a member of (see {@link\n   *     Type#getInternalName()}). Must be {@literal null} if C is not the member of a class or\n   *     interface (for example, for local or anonymous classes).\n   * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\n   * @param access the access flags of C originally declared in the source code from which this\n   *     class was compiled.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitRecordComponent(String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a record component of the class.\r\n *\r\n * @param name the record component name.\r\n * @param descriptor the record component descriptor (see {@link Type}).\r\n * @param signature the record component signature. May be {@literal null} if the record component\r\n *     type does not use generic types.\r\n * @return a visitor to visit this record component annotations and attributes, or {@literal null}\r\n *     if this class visitor is not interested in visiting these annotations and attributes.\r\n */\r\npublic RecordComponentVisitor visitRecordComponent(final String name, final String descriptor, final String signature) {\r\n    if (api < Opcodes.ASM8) {\r\n        throw new UnsupportedOperationException(\"Record requires ASM8\");\r\n    }\r\n    if (cv != null) {\r\n        return cv.visitRecordComponent(name, descriptor, signature);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits a record component of the class.\n   *\n   * @param name the record component name.\n   * @param descriptor the record component descriptor (see {@link Type}).\n   * @param signature the record component signature. May be {@literal null} if the record component\n   *     type does not use generic types.\n   * @return a visitor to visit this record component annotations and attributes, or {@literal null}\n   *     if this class visitor is not interested in visiting these annotations and attributes.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitField(int,String,String,String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Visits a field of the class.\r\n *\r\n * @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\r\n *     the field is synthetic and/or deprecated.\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor (see {@link Type}).\r\n * @param signature the field's signature. May be {@literal null} if the field's type does not use\r\n *     generic types.\r\n * @param value the field's initial value. This parameter, which may be {@literal null} if the\r\n *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\r\n *     Long}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\r\n *     or {@code String} fields respectively). <i>This parameter is only used for static\r\n *     fields</i>. Its value is ignored for non static fields, which must be initialized through\r\n *     bytecode instructions in constructors or methods.\r\n * @return a visitor to visit field annotations and attributes, or {@literal null} if this class\r\n *     visitor is not interested in visiting these annotations and attributes.\r\n */\r\npublic FieldVisitor visitField(final int access, final String name, final String descriptor, final String signature, final Object value) {\r\n    if (cv != null) {\r\n        return cv.visitField(access, name, descriptor, signature, value);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits a field of the class.\n   *\n   * @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\n   *     the field is synthetic and/or deprecated.\n   * @param name the field's name.\n   * @param descriptor the field's descriptor (see {@link Type}).\n   * @param signature the field's signature. May be {@literal null} if the field's type does not use\n   *     generic types.\n   * @param value the field's initial value. This parameter, which may be {@literal null} if the\n   *     field does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\n   *     Long}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\n   *     or {@code String} fields respectively). <i>This parameter is only used for static\n   *     fields</i>. Its value is ignored for non static fields, which must be initialized through\n   *     bytecode instructions in constructors or methods.\n   * @return a visitor to visit field annotations and attributes, or {@literal null} if this class\n   *     visitor is not interested in visiting these annotations and attributes.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitMethod(int,String,String,String,String[])",
    "entityType": "method",
    "code": "/**\r\n * Visits a method of the class. This method <i>must</i> return a new {@link MethodVisitor}\r\n * instance (or {@literal null}) each time it is called, i.e., it should not return a previously\r\n * returned visitor.\r\n *\r\n * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if\r\n *     the method is synthetic and/or deprecated.\r\n * @param name the method's name.\r\n * @param descriptor the method's descriptor (see {@link Type}).\r\n * @param signature the method's signature. May be {@literal null} if the method parameters,\r\n *     return type and exceptions do not use generic types.\r\n * @param exceptions the internal names of the method's exception classes (see {@link\r\n *     Type#getInternalName()}). May be {@literal null}.\r\n * @return an object to visit the byte code of the method, or {@literal null} if this class\r\n *     visitor is not interested in visiting the code of this method.\r\n */\r\npublic MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {\r\n    if (cv != null) {\r\n        return cv.visitMethod(access, name, descriptor, signature, exceptions);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits a method of the class. This method <i>must</i> return a new {@link MethodVisitor}\n   * instance (or {@literal null}) each time it is called, i.e., it should not return a previously\n   * returned visitor.\n   *\n   * @param access the method's access flags (see {@link Opcodes}). This parameter also indicates if\n   *     the method is synthetic and/or deprecated.\n   * @param name the method's name.\n   * @param descriptor the method's descriptor (see {@link Type}).\n   * @param signature the method's signature. May be {@literal null} if the method parameters,\n   *     return type and exceptions do not use generic types.\n   * @param exceptions the internal names of the method's exception classes (see {@link\n   *     Type#getInternalName()}). May be {@literal null}.\n   * @return an object to visit the byte code of the method, or {@literal null} if this class\n   *     visitor is not interested in visiting the code of this method.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassVisitor#visitEnd()",
    "entityType": "method",
    "code": "/**\r\n * Visits the end of the class. This method, which is the last one to be called, is used to inform\r\n * the visitor that all the fields and methods of the class have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (cv != null) {\r\n        cv.visitEnd();\r\n    }\r\n}",
    "comment": "\n   * Visits the end of the class. This method, which is the last one to be called, is used to inform\n   * the visitor that all the fields and methods of the class have been visited.\n   "
  },
  {
    "entityId": "org.springframework.util.TypeUtilsTests",
    "entityType": "class",
    "code": "public static Object object;\npublic static String string;\npublic static Integer number;\npublic static List<Object> objects;\npublic static List<String> strings;\npublic static List<? extends Object> openObjects;\npublic static List<? extends Number> openNumbers;\npublic static List<? super Object> storableObjectList;\npublic static List<Number>[] array;\npublic static List<? extends Number>[] openArray;\n@Test\r\nvoid withClasses() {\r\n    assertThat(TypeUtils.isAssignable(Object.class, Object.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, String.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(String.class, Object.class)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(List.class, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, LinkedList.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, Collection.class)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(List.class, HashSet.class)).isFalse();\r\n}\n@Test\r\nvoid withParameterizedTypes() throws Exception {\r\n    Type objectsType = getClass().getField(\"objects\").getGenericType();\r\n    Type openObjectsType = getClass().getField(\"openObjects\").getGenericType();\r\n    Type stringsType = getClass().getField(\"strings\").getGenericType();\r\n    assertThat(TypeUtils.isAssignable(Object.class, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, openObjectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, openObjectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(objectsType, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(stringsType, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(objectsType, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, openObjectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(stringsType, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(stringsType, objectsType)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(objectsType, stringsType)).isFalse();\r\n}\n@Test\r\nvoid withWildcardTypes() throws Exception {\r\n    ParameterizedType openObjectsType = (ParameterizedType) getClass().getField(\"openObjects\").getGenericType();\r\n    ParameterizedType openNumbersType = (ParameterizedType) getClass().getField(\"openNumbers\").getGenericType();\r\n    Type storableObjectListType = getClass().getField(\"storableObjectList\").getGenericType();\r\n    Type objectType = getClass().getField(\"object\").getGenericType();\r\n    Type numberType = getClass().getField(\"number\").getGenericType();\r\n    Type stringType = getClass().getField(\"string\").getGenericType();\r\n    // '?'\r\n    Type openWildcard = openObjectsType.getActualTypeArguments()[0];\r\n    // '? extends number'\r\n    Type openNumbersWildcard = openNumbersType.getActualTypeArguments()[0];\r\n    assertThat(TypeUtils.isAssignable(openWildcard, objectType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openNumbersWildcard, numberType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openNumbersWildcard, stringType)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(storableObjectListType, openObjectsType)).isFalse();\r\n}\n@Test\r\nvoid withGenericArrayTypes() throws Exception {\r\n    Type arrayType = getClass().getField(\"array\").getGenericType();\r\n    Type openArrayType = getClass().getField(\"openArray\").getGenericType();\r\n    assertThat(TypeUtils.isAssignable(Object.class, arrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, openArrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List[].class, arrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List[].class, openArrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(arrayType, List[].class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openArrayType, List[].class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(arrayType, arrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openArrayType, openArrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openArrayType, arrayType)).isTrue();\r\n}",
    "comment": "\n * Tests for {@link TypeUtils}.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n "
  },
  {
    "entityId": "org.springframework.util.TypeUtilsTests#withClasses()",
    "entityType": "method",
    "code": "@Test\r\nvoid withClasses() {\r\n    assertThat(TypeUtils.isAssignable(Object.class, Object.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, String.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(String.class, Object.class)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(List.class, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, LinkedList.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, Collection.class)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(List.class, HashSet.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TypeUtilsTests#withParameterizedTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid withParameterizedTypes() throws Exception {\r\n    Type objectsType = getClass().getField(\"objects\").getGenericType();\r\n    Type openObjectsType = getClass().getField(\"openObjects\").getGenericType();\r\n    Type stringsType = getClass().getField(\"strings\").getGenericType();\r\n    assertThat(TypeUtils.isAssignable(Object.class, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, openObjectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, openObjectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List.class, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(objectsType, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(stringsType, List.class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(objectsType, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, openObjectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(stringsType, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, objectsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openObjectsType, stringsType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(stringsType, objectsType)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(objectsType, stringsType)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TypeUtilsTests#withWildcardTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid withWildcardTypes() throws Exception {\r\n    ParameterizedType openObjectsType = (ParameterizedType) getClass().getField(\"openObjects\").getGenericType();\r\n    ParameterizedType openNumbersType = (ParameterizedType) getClass().getField(\"openNumbers\").getGenericType();\r\n    Type storableObjectListType = getClass().getField(\"storableObjectList\").getGenericType();\r\n    Type objectType = getClass().getField(\"object\").getGenericType();\r\n    Type numberType = getClass().getField(\"number\").getGenericType();\r\n    Type stringType = getClass().getField(\"string\").getGenericType();\r\n    // '?'\r\n    Type openWildcard = openObjectsType.getActualTypeArguments()[0];\r\n    // '? extends number'\r\n    Type openNumbersWildcard = openNumbersType.getActualTypeArguments()[0];\r\n    assertThat(TypeUtils.isAssignable(openWildcard, objectType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openNumbersWildcard, numberType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openNumbersWildcard, stringType)).isFalse();\r\n    assertThat(TypeUtils.isAssignable(storableObjectListType, openObjectsType)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TypeUtilsTests#withGenericArrayTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid withGenericArrayTypes() throws Exception {\r\n    Type arrayType = getClass().getField(\"array\").getGenericType();\r\n    Type openArrayType = getClass().getField(\"openArray\").getGenericType();\r\n    assertThat(TypeUtils.isAssignable(Object.class, arrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(Object.class, openArrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List[].class, arrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(List[].class, openArrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(arrayType, List[].class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openArrayType, List[].class)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(arrayType, arrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openArrayType, openArrayType)).isTrue();\r\n    assertThat(TypeUtils.isAssignable(openArrayType, arrayType)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.unit.DataSizeTests",
    "entityType": "class",
    "code": "@Test\r\nvoid ofBytesToBytes() {\r\n    assertThat(DataSize.ofBytes(1024).toBytes()).isEqualTo(1024);\r\n}\n@Test\r\nvoid ofBytesToKilobytes() {\r\n    assertThat(DataSize.ofBytes(1024).toKilobytes()).isEqualTo(1);\r\n}\n@Test\r\nvoid ofKilobytesToKilobytes() {\r\n    assertThat(DataSize.ofKilobytes(1024).toKilobytes()).isEqualTo(1024);\r\n}\n@Test\r\nvoid ofKilobytesToMegabytes() {\r\n    assertThat(DataSize.ofKilobytes(1024).toMegabytes()).isEqualTo(1);\r\n}\n@Test\r\nvoid ofMegabytesToMegabytes() {\r\n    assertThat(DataSize.ofMegabytes(1024).toMegabytes()).isEqualTo(1024);\r\n}\n@Test\r\nvoid ofMegabytesToGigabytes() {\r\n    assertThat(DataSize.ofMegabytes(2048).toGigabytes()).isEqualTo(2);\r\n}\n@Test\r\nvoid ofGigabytesToGigabytes() {\r\n    assertThat(DataSize.ofGigabytes(4096).toGigabytes()).isEqualTo(4096);\r\n}\n@Test\r\nvoid ofGigabytesToTerabytes() {\r\n    assertThat(DataSize.ofGigabytes(4096).toTerabytes()).isEqualTo(4);\r\n}\n@Test\r\nvoid ofTerabytesToGigabytes() {\r\n    assertThat(DataSize.ofTerabytes(1).toGigabytes()).isEqualTo(1024);\r\n}\n@Test\r\nvoid ofWithBytesUnit() {\r\n    assertThat(DataSize.of(10, DataUnit.BYTES)).isEqualTo(DataSize.ofBytes(10));\r\n}\n@Test\r\nvoid ofWithKilobytesUnit() {\r\n    assertThat(DataSize.of(20, DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(20));\r\n}\n@Test\r\nvoid ofWithMegabytesUnit() {\r\n    assertThat(DataSize.of(30, DataUnit.MEGABYTES)).isEqualTo(DataSize.ofMegabytes(30));\r\n}\n@Test\r\nvoid ofWithGigabytesUnit() {\r\n    assertThat(DataSize.of(40, DataUnit.GIGABYTES)).isEqualTo(DataSize.ofGigabytes(40));\r\n}\n@Test\r\nvoid ofWithTerabytesUnit() {\r\n    assertThat(DataSize.of(50, DataUnit.TERABYTES)).isEqualTo(DataSize.ofTerabytes(50));\r\n}\n@Test\r\nvoid parseWithDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"1024\")).isEqualTo(DataSize.ofKilobytes(1));\r\n}\n@Test\r\nvoid parseNegativeNumberWithDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"-1\")).isEqualTo(DataSize.ofBytes(-1));\r\n}\n@Test\r\nvoid parseWithNullDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"1024\", null)).isEqualTo(DataSize.ofKilobytes(1));\r\n}\n@Test\r\nvoid parseNegativeNumberWithNullDefaultUnitUsesBytes() {\r\n    assertThat(DataSize.parse(\"-1024\", null)).isEqualTo(DataSize.ofKilobytes(-1));\r\n}\n@Test\r\nvoid parseWithCustomDefaultUnit() {\r\n    assertThat(DataSize.parse(\"1\", DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(1));\r\n}\n@Test\r\nvoid parseNegativeNumberWithCustomDefaultUnit() {\r\n    assertThat(DataSize.parse(\"-1\", DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(-1));\r\n}\n@ParameterizedTest(name = \"[{index}] text = ''{0}''\")\r\n@ValueSource(strings = { \"1024B\", \"1024 B\", \"1024B   \", \"   1024B\", \" 1024B \", \"\\t1024   B\\t\" })\r\nvoid parseWithBytes(CharSequence text) {\r\n    assertThat(DataSize.parse(text)).isEqualTo(DataSize.ofKilobytes(1));\r\n}\n@Test\r\nvoid parseWithNegativeBytes() {\r\n    assertThat(DataSize.parse(\"-1024B\")).isEqualTo(DataSize.ofKilobytes(-1));\r\n}\n@Test\r\nvoid parseWithPositiveBytes() {\r\n    assertThat(DataSize.parse(\"+1024B\")).isEqualTo(DataSize.ofKilobytes(1));\r\n}\n@Test\r\nvoid parseWithKilobytes() {\r\n    assertThat(DataSize.parse(\"1KB\")).isEqualTo(DataSize.ofBytes(1024));\r\n}\n@Test\r\nvoid parseWithNegativeKilobytes() {\r\n    assertThat(DataSize.parse(\"-1KB\")).isEqualTo(DataSize.ofBytes(-1024));\r\n}\n@Test\r\nvoid parseWithMegabytes() {\r\n    assertThat(DataSize.parse(\"4MB\")).isEqualTo(DataSize.ofMegabytes(4));\r\n}\n@Test\r\nvoid parseWithNegativeMegabytes() {\r\n    assertThat(DataSize.parse(\"-4MB\")).isEqualTo(DataSize.ofMegabytes(-4));\r\n}\n@Test\r\nvoid parseWithGigabytes() {\r\n    assertThat(DataSize.parse(\"1GB\")).isEqualTo(DataSize.ofMegabytes(1024));\r\n}\n@Test\r\nvoid parseWithNegativeGigabytes() {\r\n    assertThat(DataSize.parse(\"-1GB\")).isEqualTo(DataSize.ofMegabytes(-1024));\r\n}\n@Test\r\nvoid parseWithTerabytes() {\r\n    assertThat(DataSize.parse(\"1TB\")).isEqualTo(DataSize.ofTerabytes(1));\r\n}\n@Test\r\nvoid parseWithNegativeTerabytes() {\r\n    assertThat(DataSize.parse(\"-1TB\")).isEqualTo(DataSize.ofTerabytes(-1));\r\n}\n@Test\r\nvoid isNegativeWithPositive() {\r\n    assertThat(DataSize.ofBytes(50).isNegative()).isFalse();\r\n}\n@Test\r\nvoid isNegativeWithZero() {\r\n    assertThat(DataSize.ofBytes(0).isNegative()).isFalse();\r\n}\n@Test\r\nvoid isNegativeWithNegative() {\r\n    assertThat(DataSize.ofBytes(-1).isNegative()).isTrue();\r\n}\n@Test\r\nvoid toStringUsesBytes() {\r\n    assertThat(DataSize.ofKilobytes(1).toString()).isEqualTo(\"1024B\");\r\n}\n@Test\r\nvoid toStringWithNegativeBytes() {\r\n    assertThat(DataSize.ofKilobytes(-1).toString()).isEqualTo(\"-1024B\");\r\n}\n@Test\r\nvoid parseWithUnsupportedUnit() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> DataSize.parse(\"3WB\")).withMessage(\"'3WB' is not a valid data size\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> DataSize.parse(\"3 WB\")).withMessage(\"'3 WB' is not a valid data size\");\r\n}",
    "comment": "\n * Tests for {@link DataSize}.\n *\n * @author Stephane Nicoll\n * @author Sam Brannen\n "
  }
]