[
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#wrongComponentTypeRequirements(Exception)",
    "entityType": "method",
    "code": "private void wrongComponentTypeRequirements(Exception ex) {\r\n    assertThat(ex).hasMessageStartingWith(\"Container type\").hasMessageContaining(ContainerWithArrayValueAttributeButWrongComponentType.class.getName(), \"must declare a 'value' attribute for an array of type\", InvalidRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsRepeatableAnnotationTests#assertThatAnnotationConfigurationException()",
    "entityType": "method",
    "code": "private static ThrowableTypeAssert<AnnotationConfigurationException> assertThatAnnotationConfigurationException() {\r\n    return assertThatExceptionOfType(AnnotationConfigurationException.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedContainerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.NoninheritedRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubNoninheritedRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithRepeatedMetaAnnotationsClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatablesWithContainerWithMultipleAttributesTestCase",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests",
    "entityType": "class",
    "code": "/**\r\n * Subset (and duplication) of other tests in {@link MergedAnnotationsTests}\r\n * that verify behavior of the fluent {@link Search} API.\r\n * @since 6.0\r\n */\r\n@Nested\r\nclass FluentSearchApiTests {\r\n\r\n    @Test\r\n    void preconditions() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.search(null)).withMessage(\"SearchStrategy must not be null\");\r\n        Search search = MergedAnnotations.search(SearchStrategy.SUPERCLASS);\r\n        assertThatIllegalArgumentException().isThrownBy(() -> search.withEnclosingClasses(null)).withMessage(\"Predicate must not be null\");\r\n        assertThatIllegalStateException().isThrownBy(() -> search.withEnclosingClasses(Search.always)).withMessage(\"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\r\n        assertThatIllegalArgumentException().isThrownBy(() -> search.withAnnotationFilter(null)).withMessage(\"AnnotationFilter must not be null\");\r\n        assertThatIllegalArgumentException().isThrownBy(() -> search.withRepeatableContainers(null)).withMessage(\"RepeatableContainers must not be null\");\r\n        assertThatIllegalArgumentException().isThrownBy(() -> search.from(null)).withMessage(\"AnnotatedElement must not be null\");\r\n    }\r\n\r\n    @Test\r\n    void searchFromClassWithDefaultAnnotationFilterAndDefaultRepeatableContainers() {\r\n        Stream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT).from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\r\n    }\r\n\r\n    @Test\r\n    void searchFromClassWithCustomAnnotationFilter() {\r\n        Stream<Class<?>> classes = MergedAnnotations.search(SearchStrategy.DIRECT).withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\")).from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Transactional.class, Component.class);\r\n    }\r\n\r\n    @Test\r\n    void searchFromClassWithCustomRepeatableContainers() {\r\n        assertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\r\n        RepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\r\n        MergedAnnotations annotations = MergedAnnotations.search(SearchStrategy.DIRECT).withRepeatableContainers(containers).from(HierarchyClass.class);\r\n        assertThat(annotations.stream(TestConfiguration.class)).map(annotation -> annotation.getString(\"location\")).containsExactly(\"A\", \"B\");\r\n        assertThat(annotations.stream(TestConfiguration.class)).map(annotation -> annotation.getString(\"value\")).containsExactly(\"A\", \"B\");\r\n    }\r\n\r\n    /**\r\n     * @since 6.0\r\n     */\r\n    @Test\r\n    void searchFromNonAnnotatedInnerClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\r\n        Class<?> testCase = AnnotatedClass.NonAnnotatedInnerClass.class;\r\n        Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\r\n        assertThat(search.from(testCase).stream()).isEmpty();\r\n        assertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\r\n        assertThat(search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream()).isEmpty();\r\n        Stream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n        classes = search.withEnclosingClasses(Search.always).from(testCase).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n        classes = search.withEnclosingClasses(ClassUtils::isInnerClass).withRepeatableContainers(RepeatableContainers.none()).withAnnotationFilter(annotationName -> annotationName.endsWith(\"Indexed\")).from(testCase).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Component.class);\r\n    }\r\n\r\n    /**\r\n     * @since 6.0\r\n     */\r\n    @Test\r\n    void searchFromNonAnnotatedStaticNestedClassWithAnnotatedEnclosingClassWithEnclosingClassPredicates() {\r\n        Class<?> testCase = AnnotatedClass.NonAnnotatedStaticNestedClass.class;\r\n        Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY);\r\n        assertThat(search.from(testCase).stream()).isEmpty();\r\n        assertThat(search.withEnclosingClasses(Search.never).from(testCase).stream()).isEmpty();\r\n        assertThat(search.withEnclosingClasses(ClassUtils::isInnerClass).from(testCase).stream()).isEmpty();\r\n        Stream<Class<?>> classes = search.withEnclosingClasses(ClassUtils::isStaticClass).from(testCase).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n        classes = search.withEnclosingClasses(Search.always).from(testCase).stream().map(MergedAnnotation::getType);\r\n        assertThat(classes).containsExactly(Component.class, Indexed.class);\r\n    }\r\n}\n@Nested\r\nclass ConventionBasedAnnotationAttributeOverrideTests {\r\n\r\n    @Test\r\n    void getWithInheritedAnnotationsAttributesWithConventionBasedComposedAnnotation() {\r\n        MergedAnnotation<?> annotation = MergedAnnotations.from(ConventionBasedComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n        assertThat(annotation.isPresent()).isTrue();\r\n        assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\r\n        assertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\r\n    }\r\n\r\n    @Test\r\n    void getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation1() {\r\n        // SPR-13554: convention mapping mixed with AliasFor annotations\r\n        // xmlConfigFiles can be used because it has an AliasFor annotation\r\n        MergedAnnotation<?> annotation = MergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n        assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"explicitDeclaration\");\r\n        assertThat(annotation.getStringArray(\"value\")).containsExactly(\"explicitDeclaration\");\r\n    }\r\n\r\n    @Test\r\n    void getWithInheritedAnnotationsFromHalfConventionBasedAndHalfAliasedComposedAnnotation2() {\r\n        // SPR-13554: convention mapping mixed with AliasFor annotations\r\n        // locations doesn't apply because it has no AliasFor annotation\r\n        MergedAnnotation<?> annotation = MergedAnnotations.from(HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n        assertThat(annotation.getStringArray(\"locations\")).isEmpty();\r\n        assertThat(annotation.getStringArray(\"value\")).isEmpty();\r\n    }\r\n\r\n    @Test\r\n    void getWithInheritedAnnotationsFromInvalidConventionBasedComposedAnnotation() {\r\n        assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotations.from(InvalidConventionBasedComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class));\r\n    }\r\n\r\n    @Test\r\n    void getWithTypeHierarchyWithSingleElementOverridingAnArrayViaConvention() {\r\n        testGetWithTypeHierarchy(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n    }\r\n\r\n    @Test\r\n    void getWithTypeHierarchyWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\r\n        MergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class, SearchStrategy.TYPE_HIERARCHY).get(ContextConfiguration.class);\r\n        assertThat(annotation.getStringArray(\"locations\")).isEmpty();\r\n        assertThat(annotation.getStringArray(\"value\")).isEmpty();\r\n        assertThat(annotation.getClassArray(\"classes\")).containsExactly(Number.class);\r\n    }\r\n\r\n    @Test\r\n    void getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaConvention() throws Exception {\r\n        testGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\r\n    }\r\n}\n@Test\r\nvoid fromPreconditions() {\r\n    SearchStrategy strategy = SearchStrategy.DIRECT;\r\n    RepeatableContainers containers = RepeatableContainers.standardRepeatables();\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN)).withMessage(\"RepeatableContainers must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null)).withMessage(\"AnnotationFilter must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN)).withMessage(\"RepeatableContainers must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null)).withMessage(\"AnnotationFilter must not be null\");\r\n}\n@Test\r\nvoid streamWhenFromNonAnnotatedClass() {\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\r\n}\n@Test\r\nvoid streamWhenFromClassWithMetaDepth1() {\r\n    Stream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\r\n}\n@Test\r\nvoid streamWhenFromClassWithMetaDepth2() {\r\n    Stream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class);\r\n}\n@Test\r\nvoid isPresentWhenFromNonAnnotatedClass() {\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\r\n}\n@Test\r\nvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\r\n    assertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\r\n}\n@Test\r\nvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n}\n@Test\r\nvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n    assertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\r\n}\n@Test\r\nvoid isPresentWhenFromClassWithMetaDepth0() {\r\n    assertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\r\n}\n@Test\r\nvoid isPresentWhenFromSubclassWithMetaDepth0() {\r\n    assertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\r\n}\n@Test\r\nvoid isPresentWhenFromClassWithMetaDepth1() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n}\n@Test\r\nvoid isPresentWhenFromClassWithMetaDepth2() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n    assertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\r\n}\n@Test\r\nvoid getParent() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    assertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType()).isEqualTo(ComposedTransactionalComponent.class);\r\n}\n@Test\r\nvoid getRootWhenNotDirect() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    MergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\r\n    assertThat(annotation.getDistance()).isGreaterThan(0);\r\n    assertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\r\n}\n@Test\r\nvoid getRootWhenDirect() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    MergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\r\n    assertThat(annotation.getDistance()).isEqualTo(0);\r\n    assertThat(annotation.getRoot()).isSameAs(annotation);\r\n}\n@Test\r\nvoid getMetaTypes() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class).get(TransactionalComponent.class);\r\n    assertThat(annotation.getMetaTypes()).containsExactly(ComposedTransactionalComponent.class, TransactionalComponent.class);\r\n}\n@Test\r\nvoid collectMultiValueMapFromNonAnnotatedClass() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).isEmpty();\r\n}\n@Test\r\nvoid collectMultiValueMapFromClassWithLocalAnnotation() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\r\n}\n@Test\r\nvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(SubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\r\n}\n@Test\r\nvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(SubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\r\n}\n@Test\r\nvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(SubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\r\n}\n/**\r\n * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\r\n * the algorithm is accidentally picking up shadowed annotations of the same\r\n * type within the class hierarchy. Such undesirable behavior would cause\r\n * the logic in\r\n * {@code org.springframework.context.annotation.ProfileCondition} to fail.\r\n */\r\n@Test\r\nvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(DerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\r\n}\n/**\r\n * Note: this functionality is required by\r\n * {@code org.springframework.context.annotation.ProfileCondition}.\r\n */\r\n@Test\r\nvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(TxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(TxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(DerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isTrue();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isFalse();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isFalse();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n}\n@Test\r\nvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(AliasedComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n}\n@Test\r\nvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(AliasedValueComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ImplicitAliasesContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\r\n    assertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\r\n    testGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\r\n    testGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\r\n    testGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\r\n    testGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\r\n    testGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    testGetWithInherited(SingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\r\n    testGetWithInherited(TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    testGetWithInherited(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\r\n}\nprivate void testGetWithInherited(Class<?> element, String... expected) {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\r\n    assertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\r\n    assertThat(annotation.getClassArray(\"classes\")).isEmpty();\r\n}\n@Test\r\nvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}\n@Test\r\nvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n// gh-31803\r\n@Test\r\nvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\r\n    Method method = Hello2Impl.class.getMethod(\"method\");\r\n    long count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY).from(method).stream(TestAnnotation1.class).count();\r\n    assertThat(count).isEqualTo(1);\r\n}\n@Test\r\nvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n@Test\r\nvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromBridgeMethod() {\r\n    List<Method> methods = new ArrayList<>();\r\n    ReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\r\n        if (\"getFor\".equals(method.getName())) {\r\n            methods.add(method);\r\n        }\r\n    });\r\n    Method bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ? methods.get(0) : methods.get(1);\r\n    Method bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ? methods.get(1) : methods.get(0);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\r\n    MergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(AliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\r\n    AliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\r\n    String qualifier = \"aliasForQualifier\";\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\r\n    assertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\r\n    assertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\r\n    assertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\r\n}\n// gh-23767\r\n@Test\r\nvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\r\n    MergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(ComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\r\n}\n// gh-23767\r\n@Test\r\nvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\r\n    MergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(MetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\r\n    assertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\r\n    MergedAnnotation<?> annotation = testGetWithTypeHierarchy(TestComponentScanClass.class, \"com.example.app.test\");\r\n    MergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(Arrays.stream(excludeFilters).map(filter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\r\n    testGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    testGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n}\nprivate MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\r\n    assertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\r\n    return annotation;\r\n}\n@Test\r\nvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(AliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\r\n    MergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\r\n    assertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n    assertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n    MergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\r\n    assertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\r\n    assertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\r\n}\n@Test\r\nvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\r\n    testGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\r\n    testGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\r\n}\nprivate void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY).get(RequestMapping.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\r\n    assertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\r\n}\n@Test\r\nvoid getDirectWithJavaxAnnotationType() {\r\n    assertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class).getString(\"name\")).isEqualTo(\"x\");\r\n}\n@Test\r\nvoid streamInheritedFromClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class)).isEmpty();\r\n}\n@Test\r\nvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(Transactional.class)).hasSize(1);\r\n}\n@Test\r\nvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"annotatedOnLeaf\");\r\n    assertThat(method.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(1);\r\n}\n@Test\r\nvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\r\n    assertThat(method.getAnnotation(Component.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Component.class).getDistance()).isEqualTo(2);\r\n}\n@Test\r\nvoid getWithAnnotationOnRoot() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"annotatedOnRoot\");\r\n    assertThat(method.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(1);\r\n}\n@Test\r\nvoid getFromMethodWithOnRootButOverridden() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithNotAnnotated() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"notAnnotated\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(-1);\r\n}\n@Test\r\nvoid getFromMethodWithBridgeMethod() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\r\n    assertThat(method.isBridge()).isTrue();\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n    // As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\r\n    // annotation on its 'bridged' method [1]; however, the Eclipse compiler does\r\n    // not support this [2]. Thus, we effectively ignore the following\r\n    // assertion if the test is currently executing within the Eclipse IDE.\r\n    //\r\n    // [1] https://bugs.openjdk.java.net/browse/JDK-6695379\r\n    // [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\r\n    //\r\n    if (!IdeUtils.runningInEclipse()) {\r\n        assertThat(method.getAnnotation(Transactional.class)).isNotNull();\r\n    }\r\n    assertThat(MergedAnnotations.from(method).get(Transactional.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithBridgedMethod() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\r\n    assertThat(method.isBridge()).isFalse();\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n    assertThat(method.getAnnotation(Transactional.class)).isNotNull();\r\n    assertThat(MergedAnnotations.from(method).get(Transactional.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n// SPR-16060\r\n@Test\r\nvoid getFromMethodWithGenericInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n// SPR-17146\r\n@Test\r\nvoid getFromMethodWithGenericSuperclass() throws Exception {\r\n    Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWithInterfaceOnSuper() throws Exception {\r\n    Method method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\r\n    Method method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}\n@Test\r\nvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isTrue();\r\n}\n@Test\r\nvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedMetaAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}\n@Test\r\nvoid getDirectFromClassWithAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    // TransactionalClass is NOT annotated or meta-annotated with @Component\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(TransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}\n@Test\r\nvoid getDirectFromClassWithMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaCycleAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}\n@Test\r\nvoid getDirectFromClassWithInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}\n@Test\r\nvoid getDirectFromClassWithSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n@Test\r\nvoid getDirectFromClassWithSubSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}\n@Test\r\nvoid getDirectFromClassWithNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}\n@Test\r\nvoid getDirectFromClassWithSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}\n@Test\r\nvoid getDirectFromClassWithSubSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}\n@Test\r\nvoid getSuperClassForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isNull();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isNull();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Transactional.class).getSource()).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but we should still find it on classes.\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isNull();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class, SearchStrategy.SUPERCLASS).get(Order.class).getSource()).isEqualTo(NonInheritedAnnotationClass.class);\r\n}\n@Test\r\nvoid getSuperClassSourceForTypesWithSingleCandidateType() {\r\n    // no class-level annotation\r\n    List<Class<? extends Annotation>> transactionalCandidateList = Collections.singletonList(Transactional.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class, transactionalCandidateList)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class, transactionalCandidateList)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class, transactionalCandidateList)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class, transactionalCandidateList)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class, transactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class, transactionalCandidateList)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but should still find it on classes.\r\n    List<Class<? extends Annotation>> orderCandidateList = Collections.singletonList(Order.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class, orderCandidateList)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class, orderCandidateList)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class, orderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class, orderCandidateList)).isEqualTo(NonInheritedAnnotationClass.class);\r\n}\n@Test\r\nvoid getSuperClassSourceForTypesWithMultipleCandidateTypes() {\r\n    List<Class<? extends Annotation>> candidates = List.of(Transactional.class, Order.class);\r\n    // no class-level annotation\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedInterface.class, candidates)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonAnnotatedClass.class, candidates)).isNull();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationInterface.class, candidates)).isEqualTo(InheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationInterface.class, candidates)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(InheritedAnnotationClass.class, candidates)).isEqualTo(InheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubInheritedAnnotationClass.class, candidates)).isEqualTo(InheritedAnnotationClass.class);\r\n    // non-inherited class-level annotation; note: @Order is not inherited,\r\n    // but findAnnotationDeclaringClassForTypes() should still find it on\r\n    // classes.\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationInterface.class, candidates)).isEqualTo(NonInheritedAnnotationInterface.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationInterface.class, candidates)).isNull();\r\n    assertThat(getSuperClassSourceWithTypeIn(NonInheritedAnnotationClass.class, candidates)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubNonInheritedAnnotationClass.class, candidates)).isEqualTo(NonInheritedAnnotationClass.class);\r\n    // class hierarchy mixed with @Transactional and @Order declarations\r\n    assertThat(getSuperClassSourceWithTypeIn(TransactionalClass.class, candidates)).isEqualTo(TransactionalClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(TransactionalAndOrderedClass.class, candidates)).isEqualTo(TransactionalAndOrderedClass.class);\r\n    assertThat(getSuperClassSourceWithTypeIn(SubTransactionalAndOrderedClass.class, candidates)).isEqualTo(TransactionalAndOrderedClass.class);\r\n}\nprivate Object getSuperClassSourceWithTypeIn(Class<?> clazz, List<Class<? extends Annotation>> annotationTypes) {\r\n    return MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent)).map(MergedAnnotation::getSource).findFirst().orElse(null);\r\n}\n@Test\r\nvoid isDirectlyPresentForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).get(Transactional.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class).isDirectlyPresent(Transactional.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class).get(Transactional.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class).isDirectlyPresent(Transactional.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).get(Transactional.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class).isDirectlyPresent(Transactional.class)).isFalse();\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).get(Order.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class).isDirectlyPresent(Order.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).get(Order.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class).isDirectlyPresent(Order.class)).isFalse();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).get(Order.class).isDirectlyPresent()).isTrue();\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class).isDirectlyPresent(Order.class)).isTrue();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).get(Order.class).isDirectlyPresent()).isFalse();\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class).isDirectlyPresent(Order.class)).isFalse();\r\n}\n@Test\r\nvoid getAggregateIndexForAllScenarios() {\r\n    // no class-level annotation\r\n    assertThat(MergedAnnotations.from(NonAnnotatedInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(-1);\r\n    // inherited class-level annotation; note: @Transactional is inherited\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(0);\r\n    // Since we're not traversing interface hierarchies the following,\r\n    // though perhaps counterintuitive, must be false:\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(InheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(SubInheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class).getAggregateIndex()).isEqualTo(1);\r\n    // non-inherited class-level annotation; note: @Order is not inherited\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(NonInheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(SubNonInheritedAnnotationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class).getAggregateIndex()).isEqualTo(-1);\r\n}\n@Test\r\nvoid getDirectWithoutAttributeAliases() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(WebController.class).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"webController\");\r\n}\n@Test\r\nvoid getDirectWithNestedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ComponentScanClass.class).get(ComponentScan.class);\r\n    MergedAnnotation<Filter>[] filters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(Arrays.stream(filters).map(filter -> filter.getString(\"pattern\"))).containsExactly(\"*Foo\", \"*Bar\");\r\n}\n@Test\r\nvoid getDirectWithAttributeAliases1() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\r\n    assertThat(annotation.getString(\"name\")).isEqualTo(\"foo\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\r\n    assertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\r\n}\n@Test\r\nvoid getDirectWithAttributeAliases2() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method).get(RequestMapping.class);\r\n    assertThat(annotation.getString(\"name\")).isEqualTo(\"bar\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\r\n    assertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\r\n}\n@Test\r\nvoid getDirectWithAttributeAliasesWithDifferentValues() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithDifferentPathAndValueAttributes\");\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotations.from(method).get(RequestMapping.class)).withMessageContaining(\"attribute 'path' and its alias 'value'\").withMessageContaining(\"values of [{/test}] and [{/enigma}]\");\r\n}\n@Test\r\nvoid getValueFromAnnotation() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getInt(\"value\")).isEqualTo(1);\r\n}\n@Test\r\nvoid getValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation annotation = declaredAnnotations[0];\r\n    MergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\r\n    assertThat(mergedAnnotation.getType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(mergedAnnotation.synthesize().annotationType().getSimpleName()).isEqualTo(\"NonPublicAnnotation\");\r\n    assertThat(mergedAnnotation.getInt(\"value\")).isEqualTo(42);\r\n}\n@Test\r\nvoid getDefaultValueFromAnnotation() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\r\n    MergedAnnotation<Order> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\r\n}\n@Test\r\nvoid getDefaultValueFromNonPublicAnnotation() {\r\n    Annotation[] declaredAnnotations = NonPublicAnnotatedClass.class.getDeclaredAnnotations();\r\n    assertThat(declaredAnnotations).hasSize(1);\r\n    Annotation declaredAnnotation = declaredAnnotations[0];\r\n    MergedAnnotation<?> annotation = MergedAnnotation.from(declaredAnnotation);\r\n    assertThat(annotation.getType().getName()).isEqualTo(\"org.springframework.core.annotation.subpackage.NonPublicAnnotation\");\r\n    assertThat(annotation.getDefaultValue(\"value\")).contains(-1);\r\n}\n@Test\r\nvoid getDefaultValueFromAnnotationType() {\r\n    MergedAnnotation<?> annotation = MergedAnnotation.of(Order.class);\r\n    assertThat(annotation.getDefaultValue(\"value\")).contains(Ordered.LOWEST_PRECEDENCE);\r\n}\n@Test\r\nvoid streamRepeatableDeclaredOnMethod() throws Exception {\r\n    Method method = InterfaceWithRepeated.class.getMethod(\"foo\");\r\n    Stream<MergedAnnotation<MyRepeatable>> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(MyRepeatable.class);\r\n    Stream<String> values = annotations.map(annotation -> annotation.getString(\"value\"));\r\n    assertThat(values).containsExactly(\"A\", \"B\", \"C\", \"meta1\");\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid streamRepeatableDeclaredOnClassWithAttributeAliases() {\r\n    assertThat(MergedAnnotations.from(HierarchyClass.class).stream(TestConfiguration.class)).isEmpty();\r\n    RepeatableContainers containers = RepeatableContainers.of(TestConfiguration.class, Hierarchy.class);\r\n    MergedAnnotations annotations = MergedAnnotations.from(HierarchyClass.class, SearchStrategy.DIRECT, containers, AnnotationFilter.NONE);\r\n    assertThat(annotations.stream(TestConfiguration.class).map(annotation -> annotation.getString(\"location\"))).containsExactly(\"A\", \"B\");\r\n    assertThat(annotations.stream(TestConfiguration.class).map(annotation -> annotation.getString(\"value\"))).containsExactly(\"A\", \"B\");\r\n}\n@Test\r\nvoid streamRepeatableDeclaredOnClass() {\r\n    Class<?> element = MyRepeatableClass.class;\r\n    String[] expectedValuesJava = { \"A\", \"B\", \"C\" };\r\n    String[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}\n@Test\r\nvoid streamRepeatableDeclaredOnSuperclass() {\r\n    Class<?> element = SubMyRepeatableClass.class;\r\n    String[] expectedValuesJava = { \"A\", \"B\", \"C\" };\r\n    String[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}\n@Test\r\nvoid streamRepeatableDeclaredOnClassAndSuperclass() {\r\n    Class<?> element = SubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    String[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\r\n    String[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}\n@Test\r\nvoid streamRepeatableDeclaredOnMultipleSuperclasses() {\r\n    Class<?> element = SubSubMyRepeatableWithAdditionalLocalDeclarationsClass.class;\r\n    String[] expectedValuesJava = { \"X\", \"Y\", \"Z\" };\r\n    String[] expectedValuesSpring = { \"X\", \"Y\", \"Z\", \"meta2\" };\r\n    testRepeatables(SearchStrategy.SUPERCLASS, element, expectedValuesJava, expectedValuesSpring);\r\n}\n@Test\r\nvoid streamDirectRepeatablesDeclaredOnClass() {\r\n    Class<?> element = MyRepeatableClass.class;\r\n    String[] expectedValuesJava = { \"A\", \"B\", \"C\" };\r\n    String[] expectedValuesSpring = { \"A\", \"B\", \"C\", \"meta1\" };\r\n    testRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\r\n}\n@Test\r\nvoid streamDirectRepeatablesDeclaredOnSuperclass() {\r\n    Class<?> element = SubMyRepeatableClass.class;\r\n    String[] expectedValuesJava = ;;\r\n    String[] expectedValuesSpring = ;;\r\n    testRepeatables(SearchStrategy.DIRECT, element, expectedValuesJava, expectedValuesSpring);\r\n}\nprivate void testRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expectedValuesJava, String[] expectedValuesSpring) {\r\n    testJavaRepeatables(searchStrategy, element, expectedValuesJava);\r\n    testExplicitRepeatables(searchStrategy, element, expectedValuesSpring);\r\n    testStandardRepeatables(searchStrategy, element, expectedValuesSpring);\r\n}\nprivate void testJavaRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\r\n    MyRepeatable[] annotations = searchStrategy == SearchStrategy.DIRECT ? element.getDeclaredAnnotationsByType(MyRepeatable.class) : element.getAnnotationsByType(MyRepeatable.class);\r\n    assertThat(Arrays.stream(annotations).map(MyRepeatable::value)).containsExactly(expected);\r\n}\nprivate void testExplicitRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\r\n    MergedAnnotations annotations = MergedAnnotations.from(element, searchStrategy, RepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class), AnnotationFilter.PLAIN);\r\n    Stream<String> values = annotations.stream(MyRepeatable.class).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(annotation -> annotation.getString(\"value\"));\r\n    assertThat(values).containsExactly(expected);\r\n}\nprivate void testStandardRepeatables(SearchStrategy searchStrategy, Class<?> element, String[] expected) {\r\n    Stream<String> values = MergedAnnotations.from(element, searchStrategy).stream(MyRepeatable.class).filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex)).map(annotation -> annotation.getString(\"value\"));\r\n    assertThat(values).containsExactly(expected);\r\n}\n@Test\r\nvoid synthesizeWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Component synthesizedComponent = MergedAnnotation.from(component).synthesize();\r\n    assertThat(synthesizedComponent).isNotNull();\r\n    assertThat(synthesizedComponent).isEqualTo(component);\r\n    assertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\r\n}\n/**\r\n * @since 6.0\r\n */\r\n@Test\r\nvoid synthesizedAnnotationShouldReuseJdkProxyClass() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    RequestMapping jdkRequestMapping = method.getAnnotation(RequestMapping.class);\r\n    assertThat(jdkRequestMapping).isNotNull();\r\n    assertThat(jdkRequestMapping.value()).containsExactly(\"/test\");\r\n    assertThat(jdkRequestMapping.path()).containsExactly(\"\");\r\n    RequestMapping synthesizedRequestMapping = MergedAnnotation.from(jdkRequestMapping).synthesize();\r\n    assertSynthesized(synthesizedRequestMapping);\r\n    assertThat(synthesizedRequestMapping.value()).containsExactly(\"/test\");\r\n    assertThat(synthesizedRequestMapping.path()).containsExactly(\"/test\");\r\n    assertThat(jdkRequestMapping.getClass()).isSameAs(synthesizedRequestMapping.getClass());\r\n}\n@Test\r\nvoid synthesizeAlreadySynthesized() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    RequestMapping webMapping = method.getAnnotation(RequestMapping.class);\r\n    assertThat(webMapping).isNotNull();\r\n    RequestMapping synthesizedWebMapping = MergedAnnotation.from(webMapping).synthesize();\r\n    RequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping).synthesize();\r\n    assertSynthesized(synthesizedWebMapping);\r\n    assertSynthesized(synthesizedAgainWebMapping);\r\n    assertThat(synthesizedWebMapping).isEqualTo(synthesizedAgainWebMapping);\r\n    assertThat(synthesizedWebMapping).isSameAs(synthesizedAgainWebMapping);\r\n    assertThat(synthesizedWebMapping.name()).isEqualTo(\"foo\");\r\n    assertThat(synthesizedWebMapping.path()).containsExactly(\"/test\");\r\n    assertThat(synthesizedWebMapping.value()).containsExactly(\"/test\");\r\n}\n@Test\r\nvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotations() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"getId\");\r\n    Id id = method.getAnnotation(Id.class);\r\n    assertThat(id).isNotNull();\r\n    Id synthesizedId = MergedAnnotation.from(id).synthesize();\r\n    assertThat(id).isEqualTo(synthesizedId);\r\n    // It doesn't make sense to synthesize @Id since it declares zero attributes.\r\n    assertNotSynthesized(synthesizedId);\r\n    assertThat(id).isSameAs(synthesizedId);\r\n    GeneratedValue generatedValue = method.getAnnotation(GeneratedValue.class);\r\n    assertThat(generatedValue).isNotNull();\r\n    GeneratedValue synthesizedGeneratedValue = MergedAnnotation.from(generatedValue).synthesize();\r\n    assertThat(generatedValue).isEqualTo(synthesizedGeneratedValue);\r\n    // It doesn't make sense to synthesize @GeneratedValue since it declares zero attributes with aliases.\r\n    assertNotSynthesized(synthesizedGeneratedValue);\r\n    assertThat(generatedValue).isSameAs(synthesizedGeneratedValue);\r\n}\n// gh-28716\r\n@Test\r\nvoid synthesizeWhenUsingMergedAnnotationsFromApi() {\r\n    Field directlyAnnotatedField = ReflectionUtils.findField(DomainType.class, \"directlyAnnotated\");\r\n    MergedAnnotations mergedAnnotations = MergedAnnotations.from(directlyAnnotatedField);\r\n    RootAnnotation rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\r\n    assertThat(rootAnnotation.flag()).isFalse();\r\n    assertNotSynthesized(rootAnnotation);\r\n    Field metaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaAnnotated\");\r\n    mergedAnnotations = MergedAnnotations.from(metaAnnotatedField);\r\n    rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\r\n    assertThat(rootAnnotation.flag()).isTrue();\r\n    assertSynthesized(rootAnnotation);\r\n    Field metaMetaAnnotatedField = ReflectionUtils.findField(DomainType.class, \"metaMetaAnnotated\");\r\n    mergedAnnotations = MergedAnnotations.from(metaMetaAnnotatedField);\r\n    rootAnnotation = mergedAnnotations.get(RootAnnotation.class).synthesize();\r\n    assertThat(rootAnnotation.flag()).isTrue();\r\n    assertSynthesized(rootAnnotation);\r\n}\n// gh-28704\r\n@Test\r\nvoid synthesizeShouldNotSynthesizeNonsynthesizableAnnotationsWhenUsingMergedAnnotationsFromApi() {\r\n    MergedAnnotations mergedAnnotations = MergedAnnotations.from(SecurityConfig.class);\r\n    EnableWebSecurity enableWebSecurity = mergedAnnotations.get(EnableWebSecurity.class).synthesize();\r\n    assertNotSynthesized(enableWebSecurity);\r\n    EnableGlobalAuthentication enableGlobalAuthentication = mergedAnnotations.get(EnableGlobalAuthentication.class).synthesize();\r\n    assertNotSynthesized(enableGlobalAuthentication);\r\n}\n/**\r\n * If an attempt is made to synthesize an annotation from an annotation instance\r\n * that has already been synthesized, the original synthesized annotation should\r\n * ideally be returned as-is without creating a new proxy instance with the same\r\n * values.\r\n */\r\n@Test\r\nvoid synthesizeShouldNotResynthesizeAlreadySynthesizedAnnotations() throws Exception {\r\n    Method method = WebController.class.getMethod(\"handleMappedWithValueAttribute\");\r\n    RequestMapping webMapping = method.getAnnotation(RequestMapping.class);\r\n    assertThat(webMapping).isNotNull();\r\n    MergedAnnotation<RequestMapping> mergedAnnotation1 = MergedAnnotation.from(webMapping);\r\n    RequestMapping synthesizedWebMapping1 = mergedAnnotation1.synthesize();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMapping).synthesize();\r\n    assertSynthesized(synthesizedWebMapping1);\r\n    assertSynthesized(synthesizedWebMapping2);\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\r\n    // Synthesizing an annotation from a different MergedAnnotation results in a different synthesized annotation instance.\r\n    assertThat(synthesizedWebMapping1).isNotSameAs(synthesizedWebMapping2);\r\n    // Synthesizing an annotation from the same MergedAnnotation results in the same synthesized annotation instance.\r\n    assertThat(synthesizedWebMapping1).isSameAs(mergedAnnotation1.synthesize());\r\n    RequestMapping synthesizedAgainWebMapping = MergedAnnotation.from(synthesizedWebMapping1).synthesize();\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedAgainWebMapping);\r\n    // Synthesizing an already synthesized annotation results in the original synthesized annotation instance.\r\n    assertThat(synthesizedWebMapping1).isSameAs(synthesizedAgainWebMapping);\r\n}\n@Test\r\nvoid synthesizeWhenAliasForIsMissingAttributeDeclaration() {\r\n    AliasForWithMissingAttributeDeclaration annotation = AliasForWithMissingAttributeDeclarationClass.class.getAnnotation(AliasForWithMissingAttributeDeclaration.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\").withMessageContaining(AliasForWithMissingAttributeDeclaration.class.getName()).withMessageContaining(\"points to itself\");\r\n}\n@Test\r\nvoid synthesizeWhenAliasForHasDuplicateAttributeDeclaration() {\r\n    AliasForWithDuplicateAttributeDeclaration annotation = AliasForWithDuplicateAttributeDeclarationClass.class.getAnnotation(AliasForWithDuplicateAttributeDeclaration.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"In @AliasFor declared on attribute 'foo' in annotation\").withMessageContaining(AliasForWithDuplicateAttributeDeclaration.class.getName()).withMessageContaining(\"attribute 'attribute' and its alias 'value' are present with values of 'baz' and 'bar'\");\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasForNonexistentAttribute() {\r\n    AliasForNonexistentAttribute annotation = AliasForNonexistentAttributeClass.class.getAnnotation(AliasForNonexistentAttribute.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"@AliasFor declaration on attribute 'foo' in annotation\").withMessageContaining(AliasForNonexistentAttribute.class.getName()).withMessageContaining(\"declares an alias for 'bar' which is not present\");\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasWithMirroredAliasForWrongAttribute() {\r\n    AliasForWithMirroredAliasForWrongAttribute annotation = AliasForWithMirroredAliasForWrongAttributeClass.class.getAnnotation(AliasForWithMirroredAliasForWrongAttribute.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessage(\"@AliasFor declaration on attribute 'bar' in annotation [\" + AliasForWithMirroredAliasForWrongAttribute.class.getName() + \"] declares an alias for 'quux' which is not present.\");\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasForAttributeOfDifferentType() {\r\n    AliasForAttributeOfDifferentType annotation = AliasForAttributeOfDifferentTypeClass.class.getAnnotation(AliasForAttributeOfDifferentType.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"Misconfigured aliases\").withMessageContaining(AliasForAttributeOfDifferentType.class.getName()).withMessageContaining(\"attribute 'foo'\").withMessageContaining(\"attribute 'bar'\").withMessageContaining(\"same return type\");\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasForWithMissingDefaultValues() {\r\n    AliasForWithMissingDefaultValues annotation = AliasForWithMissingDefaultValuesClass.class.getAnnotation(AliasForWithMissingDefaultValues.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"Misconfigured aliases\").withMessageContaining(AliasForWithMissingDefaultValues.class.getName()).withMessageContaining(\"attribute 'foo' in annotation\").withMessageContaining(\"attribute 'bar' in annotation\").withMessageContaining(\"default values\");\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasForAttributeWithDifferentDefaultValue() {\r\n    AliasForAttributeWithDifferentDefaultValue annotation = AliasForAttributeWithDifferentDefaultValueClass.class.getAnnotation(AliasForAttributeWithDifferentDefaultValue.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"Misconfigured aliases\").withMessageContaining(AliasForAttributeWithDifferentDefaultValue.class.getName()).withMessageContaining(\"attribute 'foo' in annotation\").withMessageContaining(\"attribute 'bar' in annotation\").withMessageContaining(\"same default value\");\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasForMetaAnnotationThatIsNotMetaPresent() {\r\n    AliasedComposedTestConfigurationNotMetaPresent annotation = AliasedComposedTestConfigurationNotMetaPresentClass.class.getAnnotation(AliasedComposedTestConfigurationNotMetaPresent.class);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(annotation)).withMessageStartingWith(\"@AliasFor declaration on attribute 'xmlConfigFile' in annotation\").withMessageContaining(AliasedComposedTestConfigurationNotMetaPresent.class.getName()).withMessageContaining(\"declares an alias for attribute 'location' in annotation\").withMessageContaining(TestConfiguration.class.getName()).withMessageContaining(\"not meta-present\");\r\n}\n@Test\r\nvoid synthesizeWithImplicitAliases() {\r\n    testSynthesisWithImplicitAliases(ValueImplicitAliasesTestConfigurationClass.class, \"value\");\r\n    testSynthesisWithImplicitAliases(Location1ImplicitAliasesTestConfigurationClass.class, \"location1\");\r\n    testSynthesisWithImplicitAliases(XmlImplicitAliasesTestConfigurationClass.class, \"xmlFile\");\r\n    testSynthesisWithImplicitAliases(GroovyImplicitAliasesSimpleTestConfigurationClass.class, \"groovyScript\");\r\n}\nprivate void testSynthesisWithImplicitAliases(Class<?> clazz, String expected) {\r\n    ImplicitAliasesTestConfiguration config = clazz.getAnnotation(ImplicitAliasesTestConfiguration.class);\r\n    assertThat(config).isNotNull();\r\n    ImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.value()).isEqualTo(expected);\r\n    assertThat(synthesized.location1()).isEqualTo(expected);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(expected);\r\n    assertThat(synthesized.groovyScript()).isEqualTo(expected);\r\n}\n@Test\r\nvoid synthesizeWithImplicitAliasesWithImpliedAliasNamesOmitted() {\r\n    testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class, \"value\");\r\n    testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class, \"location\");\r\n    testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass.class, \"xmlFile\");\r\n}\nprivate void testSynthesisWithImplicitAliasesWithImpliedAliasNamesOmitted(Class<?> clazz, String expected) {\r\n    ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration config = clazz.getAnnotation(ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class);\r\n    assertThat(config).isNotNull();\r\n    ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.value()).isEqualTo(expected);\r\n    assertThat(synthesized.location()).isEqualTo(expected);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(expected);\r\n}\n@Test\r\nvoid synthesizeWithImplicitAliasesForAliasPair() {\r\n    ImplicitAliasesForAliasPairTestConfiguration config = ImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(ImplicitAliasesForAliasPairTestConfiguration.class);\r\n    ImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.groovyScript()).isEqualTo(\"test.xml\");\r\n}\n@Test\r\nvoid synthesizeWithTransitiveImplicitAliases() {\r\n    TransitiveImplicitAliasesTestConfiguration config = TransitiveImplicitAliasesTestConfigurationClass.class.getAnnotation(TransitiveImplicitAliasesTestConfiguration.class);\r\n    TransitiveImplicitAliasesTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.xml()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\r\n}\n@Test\r\nvoid synthesizeWithTransitiveImplicitAliasesForAliasPair() {\r\n    TransitiveImplicitAliasesForAliasPairTestConfiguration config = TransitiveImplicitAliasesForAliasPairTestConfigurationClass.class.getAnnotation(TransitiveImplicitAliasesForAliasPairTestConfiguration.class);\r\n    TransitiveImplicitAliasesForAliasPairTestConfiguration synthesized = MergedAnnotation.from(config).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized.xml()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.groovy()).isEqualTo(\"test.xml\");\r\n}\n@Test\r\nvoid synthesizeWithImplicitAliasesWithMissingDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass.class;\r\n    Class<ImplicitAliasesWithMissingDefaultValuesTestConfiguration> annotationType = ImplicitAliasesWithMissingDefaultValuesTestConfiguration.class;\r\n    ImplicitAliasesWithMissingDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(clazz, config)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"default values\");\r\n}\n@Test\r\nvoid synthesizeWithImplicitAliasesWithDifferentDefaultValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass.class;\r\n    Class<ImplicitAliasesWithDifferentDefaultValuesTestConfiguration> annotationType = ImplicitAliasesWithDifferentDefaultValuesTestConfiguration.class;\r\n    ImplicitAliasesWithDifferentDefaultValuesTestConfiguration config = clazz.getAnnotation(annotationType);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(clazz, config)).withMessageStartingWith(\"Misconfigured aliases:\").withMessageContaining(\"attribute 'location1' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"attribute 'location2' in annotation [\" + annotationType.getName() + \"]\").withMessageContaining(\"same default value\");\r\n}\n@Test\r\nvoid synthesizeWithImplicitAliasesWithDuplicateValues() {\r\n    Class<?> clazz = ImplicitAliasesWithDuplicateValuesTestConfigurationClass.class;\r\n    Class<ImplicitAliasesWithDuplicateValuesTestConfiguration> annotationType = ImplicitAliasesWithDuplicateValuesTestConfiguration.class;\r\n    ImplicitAliasesWithDuplicateValuesTestConfiguration config = clazz.getAnnotation(annotationType);\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(clazz, config)).withMessageStartingWith(\"Different @AliasFor mirror values for annotation\").withMessageContaining(annotationType.getName()).withMessageContaining(\"declared on class\").withMessageContaining(clazz.getName()).withMessageContaining(\"are declared with values of\");\r\n}\n@Test\r\nvoid synthesizeFromMapWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Map<String, Object> map = Collections.singletonMap(\"value\", \"webController\");\r\n    MergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\r\n    Component synthesizedComponent = annotation.synthesize();\r\n    assertSynthesized(synthesizedComponent);\r\n    assertThat(synthesizedComponent.value()).isEqualTo(\"webController\");\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeFromMapWithNestedMap() {\r\n    ComponentScanSingleFilter componentScan = ComponentScanSingleFilterClass.class.getAnnotation(ComponentScanSingleFilter.class);\r\n    assertThat(componentScan).isNotNull();\r\n    assertThat(componentScan.value().pattern()).isEqualTo(\"*Foo\");\r\n    Map<String, Object> map = MergedAnnotation.from(componentScan).asMap(annotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\r\n    Map<String, Object> filterMap = (Map<String, Object>) map.get(\"value\");\r\n    assertThat(filterMap.get(\"pattern\")).isEqualTo(\"*Foo\");\r\n    filterMap.put(\"pattern\", \"newFoo\");\r\n    filterMap.put(\"enigma\", 42);\r\n    MergedAnnotation<ComponentScanSingleFilter> annotation = MergedAnnotation.of(ComponentScanSingleFilter.class, map);\r\n    ComponentScanSingleFilter synthesizedComponentScan = annotation.synthesize();\r\n    assertSynthesized(synthesizedComponentScan);\r\n    assertThat(synthesizedComponentScan.value().pattern()).isEqualTo(\"newFoo\");\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeFromMapWithNestedArrayOfMaps() {\r\n    ComponentScan componentScan = ComponentScanClass.class.getAnnotation(ComponentScan.class);\r\n    assertThat(componentScan).isNotNull();\r\n    Map<String, Object> map = MergedAnnotation.from(componentScan).asMap(annotation -> new LinkedHashMap<>(), Adapt.ANNOTATION_TO_MAP);\r\n    Map<String, Object>[] filters = (Map[]) map.get(\"excludeFilters\");\r\n    List<String> patterns = Arrays.stream(filters).map(m -> (String) m.get(\"pattern\")).toList();\r\n    assertThat(patterns).containsExactly(\"*Foo\", \"*Bar\");\r\n    filters[0].put(\"pattern\", \"newFoo\");\r\n    filters[0].put(\"enigma\", 42);\r\n    filters[1].put(\"pattern\", \"newBar\");\r\n    filters[1].put(\"enigma\", 42);\r\n    MergedAnnotation<ComponentScan> annotation = MergedAnnotation.of(ComponentScan.class, map);\r\n    ComponentScan synthesizedComponentScan = annotation.synthesize();\r\n    assertSynthesized(synthesizedComponentScan);\r\n    assertThat(Arrays.stream(synthesizedComponentScan.excludeFilters()).map(Filter::pattern)).containsExactly(\"newFoo\", \"newBar\");\r\n}\n@Test\r\nvoid synthesizeFromDefaultsWithoutAttributeAliases() {\r\n    MergedAnnotation<AnnotationWithDefaults> annotation = MergedAnnotation.of(AnnotationWithDefaults.class);\r\n    AnnotationWithDefaults synthesized = annotation.synthesize();\r\n    assertThat(synthesized.text()).isEqualTo(\"enigma\");\r\n    assertThat(synthesized.predicate()).isTrue();\r\n    assertThat(synthesized.characters()).containsExactly('a', 'b', 'c');\r\n}\n@Test\r\nvoid synthesizeFromDefaultsWithAttributeAliases() {\r\n    MergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class);\r\n    TestConfiguration synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEmpty();\r\n    assertThat(synthesized.location()).isEmpty();\r\n}\n@Test\r\nvoid synthesizeWhenAttributeAliasesWithDifferentValues() {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> MergedAnnotation.from(TestConfigurationMismatch.class.getAnnotation(TestConfiguration.class)).synthesize());\r\n}\n@Test\r\nvoid synthesizeFromMapWithMinimalAttributesWithAttributeAliases() {\r\n    Map<String, Object> map = Collections.singletonMap(\"location\", \"test.xml\");\r\n    MergedAnnotation<TestConfiguration> annotation = MergedAnnotation.of(TestConfiguration.class, map);\r\n    TestConfiguration synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEqualTo(\"test.xml\");\r\n    assertThat(synthesized.location()).isEqualTo(\"test.xml\");\r\n}\n@Test\r\nvoid synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements() {\r\n    synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Collections.singletonMap(\"value\", \"/foo\"));\r\n    synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Collections.singletonMap(\"path\", \"/foo\"));\r\n}\nprivate void synthesizeFromMapWithAttributeAliasesThatOverrideArraysWithSingleElements(Map<String, Object> map) {\r\n    MergedAnnotation<GetMapping> annotation = MergedAnnotation.of(GetMapping.class, map);\r\n    GetMapping synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEqualTo(\"/foo\");\r\n    assertThat(synthesized.path()).isEqualTo(\"/foo\");\r\n}\n@Test\r\nvoid synthesizeFromMapWithImplicitAttributeAliases() {\r\n    testSynthesisFromMapWithImplicitAliases(\"value\");\r\n    testSynthesisFromMapWithImplicitAliases(\"location1\");\r\n    testSynthesisFromMapWithImplicitAliases(\"location2\");\r\n    testSynthesisFromMapWithImplicitAliases(\"location3\");\r\n    testSynthesisFromMapWithImplicitAliases(\"xmlFile\");\r\n    testSynthesisFromMapWithImplicitAliases(\"groovyScript\");\r\n}\nprivate void testSynthesisFromMapWithImplicitAliases(String attributeNameAndValue) {\r\n    Map<String, Object> map = Collections.singletonMap(attributeNameAndValue, attributeNameAndValue);\r\n    MergedAnnotation<ImplicitAliasesTestConfiguration> annotation = MergedAnnotation.of(ImplicitAliasesTestConfiguration.class, map);\r\n    ImplicitAliasesTestConfiguration synthesized = annotation.synthesize();\r\n    assertThat(synthesized.value()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.location1()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.location2()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.xmlFile()).isEqualTo(attributeNameAndValue);\r\n    assertThat(synthesized.groovyScript()).isEqualTo(attributeNameAndValue);\r\n}\n@Test\r\nvoid synthesizeFromMapWithMissingAttributeValue() {\r\n    testMissingTextAttribute(Collections.emptyMap());\r\n}\n@Test\r\nvoid synthesizeFromMapWithNullAttributeValue() {\r\n    Map<String, Object> map = Collections.singletonMap(\"text\", null);\r\n    assertThat(map).containsKey(\"text\");\r\n    testMissingTextAttribute(map);\r\n}\nprivate void testMissingTextAttribute(Map<String, Object> attributes) {\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(() -> MergedAnnotation.of(AnnotationWithoutDefaults.class, attributes).synthesize().text()).withMessage(\"No value found for attribute named 'text' in merged annotation \" + AnnotationWithoutDefaults.class.getCanonicalName());\r\n}\n@Test\r\nvoid synthesizeFromMapWithAttributeOfIncorrectType() {\r\n    Map<String, Object> map = Collections.singletonMap(\"value\", 42L);\r\n    MergedAnnotation<Component> annotation = MergedAnnotation.of(Component.class, map);\r\n    assertThatIllegalStateException().isThrownBy(() -> annotation.synthesize().value()).withMessage(\"Attribute 'value' in annotation \" + \"org.springframework.core.testfixture.stereotype.Component should be \" + \"compatible with java.lang.String but a java.lang.Long value was returned\");\r\n}\n@Test\r\nvoid synthesizeFromAnnotationAttributesWithoutAttributeAliases() {\r\n    Component component = WebController.class.getAnnotation(Component.class);\r\n    assertThat(component).isNotNull();\r\n    Map<String, Object> attributes = MergedAnnotation.from(component).asMap();\r\n    Component synthesized = MergedAnnotation.of(Component.class, attributes).synthesize();\r\n    assertSynthesized(synthesized);\r\n    assertThat(synthesized).isEqualTo(component);\r\n}\n@Test\r\nvoid toStringForSynthesizedAnnotations() throws Exception {\r\n    Method methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    RequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithAliases).isNotNull();\r\n    Method methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\r\n    RequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\r\n    assertThat(methodWithPathAndValue).isNotNull();\r\n    RequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\r\n    assertThat(webMappingWithAliases.toString()).isNotEqualTo(synthesizedWebMapping1.toString());\r\n    // The unsynthesized annotation for handleMappedWithSamePathAndValueAttributes()\r\n    // should produce almost the same toString() results as synthesized annotations for\r\n    // handleMappedWithPathAttribute() on Java 9 or higher; however, due to multiple changes\r\n    // in the JDK's toString() implementation for annotations in JDK 9, 14, and 19,\r\n    // we do not test the JDK implementation.\r\n    // assertToStringForWebMappingWithPathAndValue(webMappingWithPathAndValue);\r\n    assertToStringForWebMappingWithPathAndValue(synthesizedWebMapping1);\r\n    assertToStringForWebMappingWithPathAndValue(synthesizedWebMapping2);\r\n}\nprivate void assertToStringForWebMappingWithPathAndValue(RequestMapping webMapping) {\r\n    assertThat(webMapping.toString()).startsWith(\"@org.springframework.core.annotation.MergedAnnotationsTests.RequestMapping(\").contains(// Strings\r\n    \"value={\\\"/test\\\"}\", \"path={\\\"/test\\\"}\", \"name=\\\"bar\\\"\", // Characters\r\n    \"ch='X'\", \"chars={'X'}\", // Enums\r\n    \"method={GET, POST}\", // Classes\r\n    \"clazz=org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod.class\", \"classes={int[][].class, org.springframework.core.annotation.MergedAnnotationsTests.RequestMethod[].class}\", // Bytes\r\n    \"byteValue=(byte) 0xFF\", \"bytes={(byte) 0xFF}\", // Shorts\r\n    \"shortValue=9876\", \"shorts={9876}\", // Longs\r\n    \"longValue=42L\", \"longs={42L}\", // Floats\r\n    \"floatValue=3.14f\", \"floats={3.14f}\", // Doubles\r\n    \"doubleValue=99.999d\", \"doubles={99.999d}\").endsWith(\")\");\r\n}\n@Test\r\nvoid equalsForSynthesizedAnnotations() throws Exception {\r\n    Method methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    RequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithAliases).isNotNull();\r\n    Method methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\r\n    RequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithPathAndValue).isNotNull();\r\n    RequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\r\n    // Equality amongst standard annotations\r\n    assertThat(webMappingWithAliases).isEqualTo(webMappingWithAliases);\r\n    assertThat(webMappingWithPathAndValue).isEqualTo(webMappingWithPathAndValue);\r\n    // Inequality amongst standard annotations\r\n    assertThat(webMappingWithAliases).isNotEqualTo(webMappingWithPathAndValue);\r\n    assertThat(webMappingWithPathAndValue).isNotEqualTo(webMappingWithAliases);\r\n    // Equality amongst synthesized annotations\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping1);\r\n    assertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping2);\r\n    assertThat(synthesizedWebMapping1).isEqualTo(synthesizedWebMapping2);\r\n    assertThat(synthesizedWebMapping2).isEqualTo(synthesizedWebMapping1);\r\n    // Equality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1).isEqualTo(webMappingWithPathAndValue);\r\n    assertThat(webMappingWithPathAndValue).isEqualTo(synthesizedWebMapping1);\r\n    // Inequality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1).isNotEqualTo(webMappingWithAliases);\r\n    assertThat(webMappingWithAliases).isNotEqualTo(synthesizedWebMapping1);\r\n}\n@Test\r\nvoid hashCodeForSynthesizedAnnotations() throws Exception {\r\n    Method methodWithPath = WebController.class.getMethod(\"handleMappedWithPathAttribute\");\r\n    RequestMapping webMappingWithAliases = methodWithPath.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithAliases).isNotNull();\r\n    Method methodWithPathAndValue = WebController.class.getMethod(\"handleMappedWithSamePathAndValueAttributes\");\r\n    RequestMapping webMappingWithPathAndValue = methodWithPathAndValue.getAnnotation(RequestMapping.class);\r\n    assertThat(webMappingWithPathAndValue).isNotNull();\r\n    RequestMapping synthesizedWebMapping1 = MergedAnnotation.from(webMappingWithAliases).synthesize();\r\n    assertThat(synthesizedWebMapping1).isNotNull();\r\n    RequestMapping synthesizedWebMapping2 = MergedAnnotation.from(webMappingWithPathAndValue).synthesize();\r\n    assertThat(synthesizedWebMapping2).isNotNull();\r\n    // Equality amongst standard annotations\r\n    assertThat(webMappingWithAliases.hashCode()).isEqualTo(webMappingWithAliases.hashCode());\r\n    assertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\r\n    // Inequality amongst standard annotations\r\n    assertThat(webMappingWithAliases.hashCode()).isNotEqualTo(webMappingWithPathAndValue.hashCode());\r\n    assertThat(webMappingWithPathAndValue.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\r\n    // Equality amongst synthesized annotations\r\n    assertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\r\n    assertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\r\n    assertThat(synthesizedWebMapping1.hashCode()).isEqualTo(synthesizedWebMapping2.hashCode());\r\n    assertThat(synthesizedWebMapping2.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\r\n    // Equality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1.hashCode()).isEqualTo(webMappingWithPathAndValue.hashCode());\r\n    assertThat(webMappingWithPathAndValue.hashCode()).isEqualTo(synthesizedWebMapping1.hashCode());\r\n    // Inequality between standard and synthesized annotations\r\n    assertThat(synthesizedWebMapping1.hashCode()).isNotEqualTo(webMappingWithAliases.hashCode());\r\n    assertThat(webMappingWithAliases.hashCode()).isNotEqualTo(synthesizedWebMapping1.hashCode());\r\n}\n/**\r\n * Fully reflection-based test that verifies support for synthesizing\r\n * annotations across packages with non-public visibility of user types\r\n * (for example, a non-public annotation that uses {@code @AliasFor}).\r\n */\r\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid synthesizeNonPublicWithAttributeAliasesFromDifferentPackage() throws Exception {\r\n    Class<?> type = ClassUtils.forName(\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotatedClass\", null);\r\n    Class<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(\"org.springframework.core.annotation.subpackage.NonPublicAliasedAnnotation\", null);\r\n    Annotation annotation = type.getAnnotation(annotationType);\r\n    assertThat(annotation).isNotNull();\r\n    MergedAnnotation<Annotation> mergedAnnotation = MergedAnnotation.from(annotation);\r\n    Annotation synthesizedAnnotation = mergedAnnotation.synthesize();\r\n    assertSynthesized(synthesizedAnnotation);\r\n    assertThat(mergedAnnotation.getString(\"name\")).isEqualTo(\"test\");\r\n    assertThat(mergedAnnotation.getString(\"path\")).isEqualTo(\"/test\");\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"/test\");\r\n}\n@Test\r\nvoid synthesizeWithArrayOfAnnotations() {\r\n    Hierarchy hierarchy = HierarchyClass.class.getAnnotation(Hierarchy.class);\r\n    assertThat(hierarchy).isNotNull();\r\n    Hierarchy synthesizedHierarchy = MergedAnnotation.from(hierarchy).synthesize();\r\n    assertSynthesized(synthesizedHierarchy);\r\n    TestConfiguration[] configs = synthesizedHierarchy.value();\r\n    assertThat(configs).isNotNull();\r\n    assertThat(configs).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n    assertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\r\n    assertThat(configs).extracting(TestConfiguration::location).containsExactly(\"A\", \"B\");\r\n    TestConfiguration contextConfig = TestConfigurationClass.class.getAnnotation(TestConfiguration.class);\r\n    assertThat(contextConfig).isNotNull();\r\n    // Alter array returned from synthesized annotation\r\n    configs[0] = contextConfig;\r\n    assertThat(configs).extracting(TestConfiguration::value).containsExactly(\"simple.xml\", \"B\");\r\n    // Re-retrieve the array from the synthesized annotation\r\n    configs = synthesizedHierarchy.value();\r\n    assertThat(configs).extracting(TestConfiguration::value).containsExactly(\"A\", \"B\");\r\n}\n@Test\r\nvoid synthesizeWithArrayOfChars() {\r\n    CharsContainer charsContainer = GroupOfCharsClass.class.getAnnotation(CharsContainer.class);\r\n    assertThat(charsContainer).isNotNull();\r\n    CharsContainer synthesizedCharsContainer = MergedAnnotation.from(charsContainer).synthesize();\r\n    assertSynthesized(synthesizedCharsContainer);\r\n    char[] chars = synthesizedCharsContainer.chars();\r\n    assertThat(chars).containsExactly('x', 'y', 'z');\r\n    // Alter array returned from synthesized annotation\r\n    chars[0] = '?';\r\n    // Re-retrieve the array from the synthesized annotation\r\n    chars = synthesizedCharsContainer.chars();\r\n    assertThat(chars).containsExactly('x', 'y', 'z');\r\n}\n@Test\r\nvoid getValueWhenHasDefaultOverride() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideClass.class).get(DefaultOverrideRoot.class);\r\n    assertThat(annotation.getString(\"text\")).isEqualTo(\"metameta\");\r\n}\n// gh-22654\r\n@Test\r\nvoid getValueWhenHasDefaultOverrideWithImplicitAlias() {\r\n    MergedAnnotation<?> annotation1 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass1.class).get(DefaultOverrideRoot.class);\r\n    assertThat(annotation1.getString(\"text\")).isEqualTo(\"alias-meta-1\");\r\n    MergedAnnotation<?> annotation2 = MergedAnnotations.from(DefaultOverrideImplicitAliasMetaClass2.class).get(DefaultOverrideRoot.class);\r\n    assertThat(annotation2.getString(\"text\")).isEqualTo(\"alias-meta-2\");\r\n}\n// gh-22654\r\n@Test\r\nvoid getValueWhenHasDefaultOverrideWithExplicitAlias() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(DefaultOverrideExplicitAliasRootMetaMetaClass.class).get(DefaultOverrideExplicitAliasRoot.class);\r\n    assertThat(annotation.getString(\"text\")).isEqualTo(\"meta\");\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta\");\r\n}\n// gh-22703\r\n@Test\r\nvoid getValueWhenThreeDeepMetaWithValue() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ValueAttributeMetaMetaClass.class).get(ValueAttribute.class);\r\n    assertThat(annotation.getStringArray(MergedAnnotation.VALUE)).containsExactly(\"FromValueAttributeMeta\");\r\n}\n@Test\r\nvoid asAnnotationAttributesReturnsPopulatedAnnotationAttributes() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SpringApplicationConfigurationClass.class).get(SpringApplicationConfiguration.class);\r\n    AnnotationAttributes attributes = annotation.asAnnotationAttributes(Adapt.CLASS_TO_STRING);\r\n    assertThat(attributes).containsEntry(\"classes\", new String[] { Number.class.getName() });\r\n    assertThat(attributes.annotationType()).isEqualTo(SpringApplicationConfiguration.class);\r\n}\n// @formatter:off\r\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface Transactional {\r\n\r\n    String value() default \"\";\r\n\r\n    String qualifier() default \"transactionManager\";\r\n\r\n    boolean readOnly() default false;\r\n}\n@Transactional\r\n@Component\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransactionalComponent {\r\n}\n@TransactionalComponent\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComposedTransactionalComponent {\r\n}\nstatic class NonAnnotatedClass {\r\n}\n@Component\r\nstatic class AnnotatedClass {\r\n\r\n    class NonAnnotatedInnerClass {\r\n    }\r\n\r\n    static class NonAnnotatedStaticNestedClass {\r\n    }\r\n}\ninterface NonAnnotatedInterface {\r\n}\n@TransactionalComponent\r\nstatic class TransactionalComponentClass {\r\n}\nstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\r\n}\n@ComposedTransactionalComponent\r\nstatic class ComposedTransactionalComponentClass {\r\n}\n@AliasedTransactionalComponent\r\nstatic class AliasedTransactionalComponentClass {\r\n}\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface AliasedTransactional {\r\n\r\n    @AliasFor(attribute = \"qualifier\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(attribute = \"value\")\r\n    String qualifier() default \"\";\r\n}\n@Transactional(qualifier = \"composed1\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@Inherited\r\n@interface InheritedComposed {\r\n}\n@Transactional(qualifier = \"composed2\", readOnly = true)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@interface Composed {\r\n}\n@Transactional\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TxComposedWithOverride {\r\n\r\n    String qualifier() default \"txMgr\";\r\n}\n@Transactional(\"TxInheritedComposed\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TxInheritedComposed {\r\n}\n@Transactional(\"TxComposed\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TxComposed {\r\n}\n@AliasedTransactional(value = \"aliasForQualifier\")\r\n@Component\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedTransactionalComponent {\r\n}\n@AliasedTransactional\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MyAliasedTransactional {\r\n\r\n    @AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\r\n    String value() default \"defaultTransactionManager\";\r\n}\n@MyAliasedTransactional(\"anotherTransactionManager\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@interface ComposedMyAliasedTransactional {\r\n}\n@ComposedMyAliasedTransactional\r\nstatic class ComposedTransactionalClass {\r\n}\n@AliasedTransactional(\"meta\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaAliasedTransactional {\r\n}\n@MetaAliasedTransactional\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaMetaAliasedTransactional {\r\n}\n@MetaMetaAliasedTransactional\r\nstatic class MetaMetaAliasedTransactionalClass {\r\n}\n@TxComposedWithOverride\r\n// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\r\n@Transactional(qualifier = \"localTxMgr\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@interface MetaAndLocalTxConfig {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestPropertySource {\r\n\r\n    @AliasFor(\"locations\")\r\n    String[] value() default {};\r\n\r\n    @AliasFor(\"value\")\r\n    String[] locations() default {};\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ContextConfiguration {\r\n\r\n    @AliasFor(attribute = \"locations\")\r\n    String[] value() default {};\r\n\r\n    @AliasFor(attribute = \"value\")\r\n    String[] locations() default {};\r\n\r\n    Class<?>[] classes() default {};\r\n}\n@ContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ConventionBasedComposedContextConfiguration {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfiguration.class)\r\n    String[] locations() default {};\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfiguration.class)\r\n    Class<?>[] classes() default {};\r\n}\n@ContextConfiguration(value = \"duplicateDeclaration\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface InvalidConventionBasedComposedContextConfiguration {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfiguration.class)\r\n    String[] locations();\r\n}\n/**\r\n * This hybrid approach for annotation attribute overrides with transitive implicit\r\n * aliases is unsupported. See SPR-13554 for details.\r\n */\r\n@ContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface HalfConventionBasedAndHalfAliasedComposedContextConfiguration {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfiguration.class)\r\n    String[] locations() default {};\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles() default {};\r\n}\n@ContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedContextConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles();\r\n}\n@ContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedValueComposedContextConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"value\")\r\n    String[] locations();\r\n}\n@ContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesContextConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] groovyScripts() default {};\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] xmlFiles() default {};\r\n\r\n    // intentionally omitted: attribute = \"locations\"\r\n    @AliasFor(annotation = ContextConfiguration.class)\r\n    String[] locations() default {};\r\n\r\n    // intentionally omitted: attribute = \"locations\" (SPR-14069)\r\n    @AliasFor(annotation = ContextConfiguration.class)\r\n    String[] value() default {};\r\n}\n@ImplicitAliasesContextConfiguration(xmlFiles = { \"A.xml\", \"B.xml\" })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComposedImplicitAliasesContextConfiguration {\r\n}\n@ImplicitAliasesContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesContextConfiguration {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\r\n    String[] xml() default {};\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\r\n    String[] groovy() default {};\r\n}\n@ImplicitAliasesContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SingleLocationTransitiveImplicitAliasesContextConfiguration {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"xmlFiles\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\r\n    String groovy() default \"\";\r\n}\n@ImplicitAliasesContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] xml() default {};\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\r\n    String[] groovy() default {};\r\n}\n@ImplicitAliasesContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfiguration.class, attribute = \"groovyScripts\")\r\n    String groovy() default \"\";\r\n}\n/**\r\n * Although the configuration declares an explicit value for 'value' and requires a\r\n * value for the aliased 'locations', this does not result in an error since\r\n * 'locations' effectively shadows the 'value' attribute (which cannot be set via the\r\n * composed annotation anyway). If 'value' were not shadowed, such a declaration would\r\n * not make sense.\r\n */\r\n@ContextConfiguration(value = \"duplicateDeclaration\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ShadowedAliasComposedContextConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles();\r\n}\n@ContextConfiguration(locations = \"shadowed.xml\")\r\n@TestPropertySource(locations = \"test.properties\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedContextConfigurationAndTestPropertySource {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles() default \"default.xml\";\r\n}\n@ContextConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SpringApplicationConfiguration {\r\n\r\n    @AliasFor(annotation = ContextConfiguration.class, attribute = \"locations\")\r\n    String[] locations() default {};\r\n\r\n    // Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\r\n    @AliasFor(\"value\")\r\n    Class<?>[] classes() default {};\r\n\r\n    // Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfiguration.class, attribute = \"classes\")\r\n    @AliasFor(\"classes\")\r\n    Class<?>[] value() default {};\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComponentScan {\r\n\r\n    @AliasFor(\"basePackages\")\r\n    String[] value() default {};\r\n\r\n    @AliasFor(\"value\")\r\n    String[] basePackages() default {};\r\n\r\n    Filter[] excludeFilters() default {};\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({})\r\n@interface Filter {\r\n\r\n    String pattern();\r\n}\n@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\") })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestComponentScan {\r\n\r\n    @AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\r\n    String[] packages();\r\n}\n@ComponentScan\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ConventionBasedSinglePackageComponentScan {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ComponentScan.class)\r\n    String basePackages();\r\n}\n@ComponentScan\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForBasedSinglePackageComponentScan {\r\n\r\n    @AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\r\n    String pkg();\r\n}\n@Transactional\r\nstatic class ClassWithInheritedAnnotation {\r\n}\n@Composed\r\nstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\r\n}\nstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\r\n}\n@InheritedComposed\r\nstatic class ClassWithInheritedComposedAnnotation {\r\n}\n@Composed\r\nstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\r\n}\nstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\r\n}\n@MetaAndLocalTxConfig\r\nstatic class MetaAndLocalTxConfigClass {\r\n}\n@Transactional(\"TxConfig\")\r\nstatic class TxConfig {\r\n}\n@Transactional(\"DerivedTxConfig\")\r\nstatic class DerivedTxConfig extends TxConfig {\r\n}\n@TxInheritedComposed\r\n@TxComposed\r\nstatic class TxFromMultipleComposedAnnotations {\r\n}\n@Transactional\r\ninterface InterfaceWithInheritedAnnotation {\r\n\r\n    @Order\r\n    void handleFromInterface();\r\n}\nabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\r\n\r\n    @Transactional\r\n    public abstract void handle();\r\n\r\n    @Transactional\r\n    public void handleParameterized(T t) {\r\n    }\r\n}\nstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\r\n\r\n    @Override\r\n    public void handle() {\r\n    }\r\n\r\n    @Override\r\n    public void handleParameterized(String s) {\r\n    }\r\n\r\n    @Override\r\n    public void handleFromInterface() {\r\n    }\r\n}\npublic interface GenericParameter<T> {\r\n\r\n    T getFor(Class<T> cls);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class StringGenericParameter implements GenericParameter<String> {\r\n\r\n    @Order\r\n    @Override\r\n    public String getFor(Class<String> cls) {\r\n        return \"foo\";\r\n    }\r\n\r\n    public String getFor(Integer integer) {\r\n        return \"foo\";\r\n    }\r\n}\n@Transactional\r\npublic interface InheritedAnnotationInterface {\r\n}\npublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\r\n}\npublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\r\n}\n@Order\r\npublic interface NonInheritedAnnotationInterface {\r\n}\npublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\r\n}\npublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\r\n}\n@ConventionBasedComposedContextConfiguration(locations = \"explicitDeclaration\")\r\nstatic class ConventionBasedComposedContextConfigurationClass {\r\n}\n@InvalidConventionBasedComposedContextConfiguration(locations = \"requiredLocationsDeclaration\")\r\nstatic class InvalidConventionBasedComposedContextConfigurationClass {\r\n}\n@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(xmlConfigFiles = \"explicitDeclaration\")\r\nstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass1 {\r\n}\n@HalfConventionBasedAndHalfAliasedComposedContextConfiguration(locations = \"explicitDeclaration\")\r\nstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigurationClass2 {\r\n}\n@AliasedComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\r\nstatic class AliasedComposedContextConfigurationClass {\r\n}\n@AliasedValueComposedContextConfiguration(locations = \"test.xml\")\r\nstatic class AliasedValueComposedContextConfigurationClass {\r\n}\n@ImplicitAliasesContextConfiguration(\"foo.xml\")\r\nstatic class ImplicitAliasesContextConfigurationClass1 {\r\n}\n@ImplicitAliasesContextConfiguration(locations = \"bar.xml\")\r\nstatic class ImplicitAliasesContextConfigurationClass2 {\r\n}\n@ImplicitAliasesContextConfiguration(xmlFiles = \"baz.xml\")\r\nstatic class ImplicitAliasesContextConfigurationClass3 {\r\n}\n@TransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\r\nstatic class TransitiveImplicitAliasesContextConfigurationClass {\r\n}\n@SingleLocationTransitiveImplicitAliasesContextConfiguration(groovy = \"test.groovy\")\r\nstatic class SingleLocationTransitiveImplicitAliasesContextConfigurationClass {\r\n}\n@TransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\r\nstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\r\n}\n@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfiguration(xml = \"test.xml\")\r\nstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass {\r\n}\n@ComposedImplicitAliasesContextConfiguration\r\nstatic class ComposedImplicitAliasesContextConfigurationClass {\r\n}\n@ShadowedAliasComposedContextConfiguration(xmlConfigFiles = \"test.xml\")\r\nstatic class ShadowedAliasComposedContextConfigurationClass {\r\n}\n@AliasedComposedContextConfigurationAndTestPropertySource(xmlConfigFiles = \"test.xml\")\r\nstatic class AliasedComposedContextConfigurationAndTestPropertySourceClass {\r\n}\n@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\r\nstatic class ComponentScanWithBasePackagesAndValueAliasClass {\r\n}\n@TestComponentScan(packages = \"com.example.app.test\")\r\nstatic class TestComponentScanClass {\r\n}\n@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\r\nstatic class ConventionBasedSinglePackageComponentScanClass {\r\n}\n@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\r\nstatic class AliasForBasedSinglePackageComponentScanClass {\r\n}\n@SpringApplicationConfiguration(Number.class)\r\nstatic class SpringApplicationConfigurationClass {\r\n}\n@Resource(name = \"x\")\r\nstatic class ResourceHolder {\r\n}\ninterface TransactionalService {\r\n\r\n    @Transactional\r\n    void doIt();\r\n}\nclass TransactionalServiceImpl implements TransactionalService {\r\n\r\n    @Override\r\n    public void doIt() {\r\n    }\r\n}\n@Component(\"meta1\")\r\n@Order\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface Meta1 {\r\n}\n@Component(\"meta2\")\r\n@Transactional(readOnly = true)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface Meta2 {\r\n}\n@Meta2\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaMeta {\r\n}\n@MetaMeta\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaMetaMeta {\r\n}\n@MetaCycle3\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaCycle1 {\r\n}\n@MetaCycle1\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaCycle2 {\r\n}\n@MetaCycle2\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MetaCycle3 {\r\n}\n@Meta1\r\ninterface InterfaceWithMetaAnnotation {\r\n}\n@Meta2\r\nstatic class ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface implements InterfaceWithMetaAnnotation {\r\n}\n@Meta1\r\nstatic class ClassWithInheritedMetaAnnotation {\r\n}\n@Meta2\r\nstatic class SubClassWithInheritedMetaAnnotation extends ClassWithInheritedMetaAnnotation {\r\n}\nstatic class SubSubClassWithInheritedMetaAnnotation extends SubClassWithInheritedMetaAnnotation {\r\n}\n@MetaMeta\r\nstatic class MetaMetaAnnotatedClass {\r\n}\n@MetaMetaMeta\r\nstatic class MetaMetaMetaAnnotatedClass {\r\n}\n@MetaCycle3\r\nstatic class MetaCycleAnnotatedClass {\r\n}\ninterface AnnotatedInterface {\r\n\r\n    @Order(0)\r\n    void fromInterfaceImplementedByRoot();\r\n}\ninterface NullableAnnotatedInterface {\r\n\r\n    @Nullable\r\n    String fromInterfaceImplementedByRoot();\r\n}\nstatic class Root implements AnnotatedInterface {\r\n\r\n    @Order(27)\r\n    public void annotatedOnRoot() {\r\n    }\r\n\r\n    @Meta1\r\n    public void metaAnnotatedOnRoot() {\r\n    }\r\n\r\n    public void overrideToAnnotate() {\r\n    }\r\n\r\n    @Order(27)\r\n    public void overrideWithoutNewAnnotation() {\r\n    }\r\n\r\n    public void notAnnotated() {\r\n    }\r\n\r\n    @Override\r\n    public void fromInterfaceImplementedByRoot() {\r\n    }\r\n}\npublic static class Leaf extends Root {\r\n\r\n    @Order(25)\r\n    public void annotatedOnLeaf() {\r\n    }\r\n\r\n    @Meta1\r\n    public void metaAnnotatedOnLeaf() {\r\n    }\r\n\r\n    @MetaMeta\r\n    public void metaMetaAnnotatedOnLeaf() {\r\n    }\r\n\r\n    @Override\r\n    @Order(1)\r\n    public void overrideToAnnotate() {\r\n    }\r\n\r\n    @Override\r\n    public void overrideWithoutNewAnnotation() {\r\n    }\r\n}\npublic abstract static class SimpleGeneric<T> {\r\n\r\n    @Order(1)\r\n    public abstract void something(T arg);\r\n}\npublic static class TransactionalStringGeneric extends SimpleGeneric<String> {\r\n\r\n    @Override\r\n    @Transactional\r\n    public void something(final String arg) {\r\n    }\r\n}\n@Transactional\r\npublic static class InheritedAnnotationClass {\r\n}\npublic static class SubInheritedAnnotationClass extends InheritedAnnotationClass {\r\n}\n@Order\r\npublic static class NonInheritedAnnotationClass {\r\n}\npublic static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {\r\n}\n@Transactional\r\npublic static class TransactionalClass {\r\n}\n@Order\r\npublic static class TransactionalAndOrderedClass extends TransactionalClass {\r\n}\npublic static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {\r\n}\npublic interface InterfaceWithAnnotatedMethod {\r\n\r\n    @Order\r\n    void foo();\r\n}\npublic static class ImplementsInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\r\n\r\n    @Override\r\n    public void foo() {\r\n    }\r\n}\npublic static class SubOfImplementsInterfaceWithAnnotatedMethod extends ImplementsInterfaceWithAnnotatedMethod {\r\n\r\n    @Override\r\n    public void foo() {\r\n    }\r\n}\npublic abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {\r\n}\npublic static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod extends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {\r\n\r\n    @Override\r\n    public void foo() {\r\n    }\r\n}\npublic interface InterfaceWithGenericAnnotatedMethod<T> {\r\n\r\n    @Order\r\n    void foo(T t);\r\n}\npublic static class ImplementsInterfaceWithGenericAnnotatedMethod implements InterfaceWithGenericAnnotatedMethod<String> {\r\n\r\n    @Override\r\n    public void foo(String t) {\r\n    }\r\n}\npublic abstract static class BaseClassWithGenericAnnotatedMethod<T> {\r\n\r\n    @Order\r\n    abstract void foo(T t);\r\n}\npublic static class ExtendsBaseClassWithGenericAnnotatedMethod extends BaseClassWithGenericAnnotatedMethod<String> {\r\n\r\n    @Override\r\n    public void foo(String t) {\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface MyRepeatableContainer {\r\n\r\n    MyRepeatable[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@Repeatable(MyRepeatableContainer.class)\r\n@interface MyRepeatable {\r\n\r\n    String value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@MyRepeatable(\"meta1\")\r\n@interface MyRepeatableMeta1 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@MyRepeatable(\"meta2\")\r\n@interface MyRepeatableMeta2 {\r\n}\ninterface InterfaceWithRepeated {\r\n\r\n    @MyRepeatable(\"A\")\r\n    @MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\r\n    @MyRepeatableMeta1\r\n    void foo();\r\n}\n@MyRepeatable(\"A\")\r\n@MyRepeatableContainer({ @MyRepeatable(\"B\"), @MyRepeatable(\"C\") })\r\n@MyRepeatableMeta1\r\nstatic class MyRepeatableClass {\r\n}\nstatic class SubMyRepeatableClass extends MyRepeatableClass {\r\n}\n@MyRepeatable(\"X\")\r\n@MyRepeatableContainer({ @MyRepeatable(\"Y\"), @MyRepeatable(\"Z\") })\r\n@MyRepeatableMeta2\r\nstatic class SubMyRepeatableWithAdditionalLocalDeclarationsClass extends MyRepeatableClass {\r\n}\nstatic class SubSubMyRepeatableWithAdditionalLocalDeclarationsClass extends SubMyRepeatableWithAdditionalLocalDeclarationsClass {\r\n}\nenum RequestMethod {\r\n\r\n    GET, POST;\r\n\r\n    /**\r\n     * custom override to verify annotation toString() implementations.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        return \"method: \" + name().toLowerCase();\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface RequestMapping {\r\n\r\n    String name();\r\n\r\n    @AliasFor(\"path\")\r\n    String[] value() default \"\";\r\n\r\n    @AliasFor(attribute = \"value\")\r\n    String[] path() default \"\";\r\n\r\n    RequestMethod[] method() default {};\r\n\r\n    // ---------------------------------------------------------------------\r\n    // All remaining attributes declare default values that are used solely\r\n    // for the purpose of testing the toString() implementations for annotations.\r\n    Class<?> clazz() default RequestMethod.class;\r\n\r\n    Class<?>[] classes() default { int[][].class, RequestMethod[].class };\r\n\r\n    char ch() default 'X';\r\n\r\n    char[] chars() default { 'X' };\r\n\r\n    byte byteValue() default (byte) 0xFF;\r\n\r\n    byte[] bytes() default { (byte) 0xFF };\r\n\r\n    short shortValue() default 9876;\r\n\r\n    short[] shorts() default { 9876 };\r\n\r\n    long longValue() default 42L;\r\n\r\n    long[] longs() default { 42L };\r\n\r\n    float floatValue() default 3.14F;\r\n\r\n    float[] floats() default { 3.14F };\r\n\r\n    double doubleValue() default 99.999D;\r\n\r\n    double[] doubles() default { 99.999D };\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@RequestMapping(method = RequestMethod.GET, name = \"\")\r\n@interface GetMapping {\r\n\r\n    @AliasFor(annotation = RequestMapping.class)\r\n    String value() default \"\";\r\n\r\n    @AliasFor(annotation = RequestMapping.class)\r\n    String path() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@RequestMapping(method = RequestMethod.POST, name = \"\")\r\n@interface PostMapping {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = RequestMapping.class)\r\n    String path() default \"\";\r\n}\n@Component(\"webController\")\r\nstatic class WebController {\r\n\r\n    @RequestMapping(value = \"/test\", name = \"foo\")\r\n    public void handleMappedWithValueAttribute() {\r\n    }\r\n\r\n    @RequestMapping(path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\r\n    public void handleMappedWithPathAttribute() {\r\n    }\r\n\r\n    @GetMapping(\"/test\")\r\n    public void getMappedWithValueAttribute() {\r\n    }\r\n\r\n    @GetMapping(path = \"/test\")\r\n    public void getMappedWithPathAttribute() {\r\n    }\r\n\r\n    @PostMapping(path = \"/test\")\r\n    public void postMappedWithPathAttribute() {\r\n    }\r\n\r\n    @RequestMapping(value = \"/test\", path = \"/test\", name = \"bar\", method = { RequestMethod.GET, RequestMethod.POST })\r\n    public void handleMappedWithSamePathAndValueAttributes() {\r\n    }\r\n\r\n    @RequestMapping(value = \"/enigma\", path = \"/test\", name = \"baz\")\r\n    public void handleMappedWithDifferentPathAndValueAttributes() {\r\n    }\r\n}\n/**\r\n * Mimics jakarta.persistence.Id\r\n */\r\n@Retention(RUNTIME)\r\n@interface Id {\r\n}\n/**\r\n * Mimics jakarta.persistence.GeneratedValue\r\n */\r\n@Retention(RUNTIME)\r\n@interface GeneratedValue {\r\n\r\n    String strategy();\r\n}\n@Id\r\n@GeneratedValue(strategy = \"AUTO\")\r\nprivate Long getId() {\r\n    return 42L;\r\n}\n/**\r\n * Mimics org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication\r\n */\r\n@Retention(RUNTIME)\r\n@interface EnableGlobalAuthentication {\r\n}\n/**\r\n * Mimics org.springframework.security.config.annotation.web.configuration.EnableWebSecurity\r\n */\r\n@Retention(RUNTIME)\r\n@EnableGlobalAuthentication\r\n@interface EnableWebSecurity {\r\n}\n@EnableWebSecurity\r\nstatic class SecurityConfig {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\r\n@interface RootAnnotation {\r\n\r\n    String value() default \"\";\r\n\r\n    boolean flag() default false;\r\n}\n@RootAnnotation\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE })\r\n@interface ComposedRootAnnotation {\r\n\r\n    @AliasFor(annotation = RootAnnotation.class, attribute = \"flag\")\r\n    boolean enabled() default true;\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.FIELD)\r\n@ComposedRootAnnotation\r\n@interface DoublyComposedRootAnnotation {\r\n}\nclass DomainType {\r\n\r\n    @RootAnnotation\r\n    Object directlyAnnotated;\r\n\r\n    @ComposedRootAnnotation\r\n    Object metaAnnotated;\r\n\r\n    @DoublyComposedRootAnnotation\r\n    Object metaMetaAnnotated;\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestConfiguration {\r\n\r\n    @AliasFor(\"location\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(\"value\")\r\n    String location() default \"\";\r\n\r\n    Class<?> configClass() default Object.class;\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface Hierarchy {\r\n\r\n    TestConfiguration[] value();\r\n}\n@Hierarchy({ @TestConfiguration(\"A\"), @TestConfiguration(location = \"B\") })\r\nstatic class HierarchyClass {\r\n}\n@TestConfiguration(\"simple.xml\")\r\nstatic class TestConfigurationClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface CharsContainer {\r\n\r\n    @AliasFor(attribute = \"chars\")\r\n    char[] value() default {};\r\n\r\n    @AliasFor(attribute = \"value\")\r\n    char[] chars() default {};\r\n}\n@CharsContainer(chars = { 'x', 'y', 'z' })\r\nstatic class GroupOfCharsClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithMissingAttributeDeclaration {\r\n\r\n    @AliasFor\r\n    String foo() default \"\";\r\n}\n@AliasForWithMissingAttributeDeclaration\r\nstatic class AliasForWithMissingAttributeDeclarationClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithDuplicateAttributeDeclaration {\r\n\r\n    @AliasFor(value = \"bar\", attribute = \"baz\")\r\n    String foo() default \"\";\r\n}\n@AliasForWithDuplicateAttributeDeclaration\r\nstatic class AliasForWithDuplicateAttributeDeclarationClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForNonexistentAttribute {\r\n\r\n    @AliasFor(\"bar\")\r\n    String foo() default \"\";\r\n}\n@AliasForNonexistentAttribute\r\nstatic class AliasForNonexistentAttributeClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithoutMirroredAliasFor {\r\n\r\n    @AliasFor(\"bar\")\r\n    String foo() default \"\";\r\n\r\n    String bar() default \"\";\r\n}\n@AliasForWithoutMirroredAliasFor\r\nstatic class AliasForWithoutMirroredAliasForClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithMirroredAliasForWrongAttribute {\r\n\r\n    @AliasFor(attribute = \"bar\")\r\n    String[] foo() default \"\";\r\n\r\n    @AliasFor(attribute = \"quux\")\r\n    String[] bar() default \"\";\r\n}\n@AliasForWithMirroredAliasForWrongAttribute\r\nstatic class AliasForWithMirroredAliasForWrongAttributeClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForAttributeOfDifferentType {\r\n\r\n    @AliasFor(\"bar\")\r\n    String[] foo() default \"\";\r\n\r\n    @AliasFor(\"foo\")\r\n    boolean bar() default true;\r\n}\n@AliasForAttributeOfDifferentType\r\nstatic class AliasForAttributeOfDifferentTypeClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForWithMissingDefaultValues {\r\n\r\n    @AliasFor(attribute = \"bar\")\r\n    String foo();\r\n\r\n    @AliasFor(attribute = \"foo\")\r\n    String bar();\r\n}\n@AliasForWithMissingDefaultValues(foo = \"foo\", bar = \"bar\")\r\nstatic class AliasForWithMissingDefaultValuesClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForAttributeWithDifferentDefaultValue {\r\n\r\n    @AliasFor(\"bar\")\r\n    String foo() default \"X\";\r\n\r\n    @AliasFor(\"foo\")\r\n    String bar() default \"Z\";\r\n}\n@AliasForAttributeWithDifferentDefaultValue\r\nstatic class AliasForAttributeWithDifferentDefaultValueClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedTestConfigurationNotMetaPresent {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String xmlConfigFile();\r\n}\n@AliasedComposedTestConfigurationNotMetaPresent(xmlConfigFile = \"test.xml\")\r\nstatic class AliasedComposedTestConfigurationNotMetaPresentClass {\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String xmlConfigFile();\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface ImplicitAliasesTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String xmlFile() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String groovyScript() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location1() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location2() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location3() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"configClass\")\r\n    Class<?> configClass() default Object.class;\r\n\r\n    String nonAliasedAttribute() default \"\";\r\n}\n@ImplicitAliasesTestConfiguration(groovyScript = \"groovyScript\")\r\nstatic class GroovyImplicitAliasesSimpleTestConfigurationClass {\r\n}\n@ImplicitAliasesTestConfiguration(xmlFile = \"xmlFile\")\r\nstatic class XmlImplicitAliasesTestConfigurationClass {\r\n}\n@ImplicitAliasesTestConfiguration(\"value\")\r\nstatic class ValueImplicitAliasesTestConfigurationClass {\r\n}\n@ImplicitAliasesTestConfiguration(location1 = \"location1\")\r\nstatic class Location1ImplicitAliasesTestConfigurationClass {\r\n}\n@ImplicitAliasesTestConfiguration(location2 = \"location2\")\r\nstatic class Location2ImplicitAliasesTestConfigurationClass {\r\n}\n@ImplicitAliasesTestConfiguration(location3 = \"location3\")\r\nstatic class Location3ImplicitAliasesTestConfigurationClass {\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class)\r\n    String value() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class)\r\n    String location() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String xmlFile() default \"\";\r\n}\n@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"xmlFile\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration.class, attribute = \"location\")\r\n    String groovy() default \"\";\r\n}\n@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(\"value\")\r\nstatic class ValueImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\r\n}\n@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(location = \"location\")\r\nstatic class LocationsImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\r\n}\n@ImplicitAliasesWithImpliedAliasNamesOmittedTestConfiguration(xmlFile = \"xmlFile\")\r\nstatic class XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedTestConfigurationClass {\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithMissingDefaultValuesTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location1();\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location2();\r\n}\n@ImplicitAliasesWithMissingDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\r\nstatic class ImplicitAliasesWithMissingDefaultValuesTestConfigurationClass {\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithDifferentDefaultValuesTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location1() default \"foo\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location2() default \"bar\";\r\n}\n@ImplicitAliasesWithDifferentDefaultValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\r\nstatic class ImplicitAliasesWithDifferentDefaultValuesTestConfigurationClass {\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesWithDuplicateValuesTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location1() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String location2() default \"\";\r\n}\n@ImplicitAliasesWithDuplicateValuesTestConfiguration(location1 = \"1\", location2 = \"2\")\r\nstatic class ImplicitAliasesWithDuplicateValuesTestConfigurationClass {\r\n}\n@TestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesForAliasPairTestConfiguration {\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, attribute = \"location\")\r\n    String xmlFile() default \"\";\r\n\r\n    @AliasFor(annotation = TestConfiguration.class, value = \"value\")\r\n    String groovyScript() default \"\";\r\n}\n@ImplicitAliasesForAliasPairTestConfiguration(xmlFile = \"test.xml\")\r\nstatic class ImplicitAliasesForAliasPairTestConfigurationClass {\r\n}\n@ImplicitAliasesTestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesTestConfiguration {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"xmlFile\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesTestConfiguration.class, attribute = \"groovyScript\")\r\n    String groovy() default \"\";\r\n}\n@TransitiveImplicitAliasesTestConfiguration(xml = \"test.xml\")\r\nstatic class TransitiveImplicitAliasesTestConfigurationClass {\r\n}\n@ImplicitAliasesForAliasPairTestConfiguration\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesForAliasPairTestConfiguration {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"xmlFile\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesForAliasPairTestConfiguration.class, attribute = \"groovyScript\")\r\n    String groovy() default \"\";\r\n}\n@TransitiveImplicitAliasesForAliasPairTestConfiguration(xml = \"test.xml\")\r\nstatic class TransitiveImplicitAliasesForAliasPairTestConfigurationClass {\r\n}\n@ComponentScan(excludeFilters = { @Filter(pattern = \"*Foo\"), @Filter(pattern = \"*Bar\") })\r\nstatic class ComponentScanClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComponentScanSingleFilter {\r\n\r\n    Filter value();\r\n}\n@ComponentScanSingleFilter(@Filter(pattern = \"*Foo\"))\r\nstatic class ComponentScanSingleFilterClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AnnotationWithDefaults {\r\n\r\n    String text() default \"enigma\";\r\n\r\n    boolean predicate() default true;\r\n\r\n    char[] characters() default { 'a', 'b', 'c' };\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AnnotationWithoutDefaults {\r\n\r\n    String text();\r\n}\n@TestConfiguration(value = \"foo\", location = \"bar\")\r\ninterface TestConfigurationMismatch {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface DefaultOverrideRoot {\r\n\r\n    String text() default \"root\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideRoot\r\n@interface DefaultOverrideMeta {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideMeta\r\n@interface DefaultOverrideMetaMeta {\r\n\r\n    String text() default \"metameta\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideMetaMeta\r\n@interface DefaultOverrideMetaMetaMeta {\r\n}\n@DefaultOverrideMetaMetaMeta\r\nstatic class DefaultOverrideClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideRoot\r\n@interface DefaultOverrideImplicitAlias {\r\n\r\n    @AliasFor(annotation = DefaultOverrideRoot.class, attribute = \"text\")\r\n    String text1() default \"alias\";\r\n\r\n    @AliasFor(annotation = DefaultOverrideRoot.class, attribute = \"text\")\r\n    String text2() default \"alias\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideImplicitAlias(text1 = \"alias-meta-1\")\r\n@interface DefaultOverrideAliasImplicitMeta1 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideImplicitAlias(text2 = \"alias-meta-2\")\r\n@interface DefaultOverrideImplicitAliasMeta2 {\r\n}\n@DefaultOverrideAliasImplicitMeta1\r\nstatic class DefaultOverrideImplicitAliasMetaClass1 {\r\n}\n@DefaultOverrideImplicitAliasMeta2\r\nstatic class DefaultOverrideImplicitAliasMetaClass2 {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface DefaultOverrideExplicitAliasRoot {\r\n\r\n    @AliasFor(\"value\")\r\n    String text() default \"\";\r\n\r\n    @AliasFor(\"text\")\r\n    String value() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideExplicitAliasRoot(\"meta\")\r\n@interface DefaultOverrideExplicitAliasRootMeta {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@DefaultOverrideExplicitAliasRootMeta\r\n@interface DefaultOverrideExplicitAliasRootMetaMeta {\r\n}\n@DefaultOverrideExplicitAliasRootMetaMeta\r\nstatic class DefaultOverrideExplicitAliasRootMetaMetaClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ValueAttribute {\r\n\r\n    String[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@ValueAttribute(\"FromValueAttributeMeta\")\r\n@interface ValueAttributeMeta {\r\n\r\n    String[] value() default {};\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\r\n@interface ValueAttributeMetaMeta {\r\n}\n@ValueAttributeMetaMeta\r\nstatic class ValueAttributeMetaMetaClass {\r\n}\n// @formatter:on\r\nstatic void assertSynthesized(Annotation annotation) {\r\n    assertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isTrue();\r\n}\nstatic void assertNotSynthesized(Annotation annotation) {\r\n    assertThat(AnnotationUtils.isSynthesizedAnnotation(annotation)).as(\"synthesized annotation\").isFalse();\r\n}",
    "comment": "\n * Tests for {@link MergedAnnotations} and {@link MergedAnnotation}. These tests\n * cover common usage scenarios and were mainly ported from the original\n * {@code AnnotationUtils} and {@code AnnotatedElementUtils} tests.\n *\n * @author Phillip Webb\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Chris Beams\n * @author Oleg Zhurakousky\n * @author Rossen Stoyanchev\n * @see MergedAnnotationsRepeatableAnnotationTests\n * @see MergedAnnotationClassLoaderTests\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#fromPreconditions()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromPreconditions() {\r\n    SearchStrategy strategy = SearchStrategy.DIRECT;\r\n    RepeatableContainers containers = RepeatableContainers.standardRepeatables();\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, null, AnnotationFilter.PLAIN)).withMessage(\"RepeatableContainers must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), strategy, containers, null)).withMessage(\"AnnotationFilter must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], null, AnnotationFilter.PLAIN)).withMessage(\"RepeatableContainers must not be null\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotations.from(getClass(), new Annotation[0], containers, null)).withMessage(\"AnnotationFilter must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamWhenFromNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamWhenFromNonAnnotatedClass() {\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).stream(TransactionalComponent.class)).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamWhenFromClassWithMetaDepth1()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamWhenFromClassWithMetaDepth1() {\r\n    Stream<Class<?>> classes = MergedAnnotations.from(TransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(Transactional.class, Component.class, Indexed.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamWhenFromClassWithMetaDepth2()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamWhenFromClassWithMetaDepth2() {\r\n    Stream<Class<?>> classes = MergedAnnotations.from(ComposedTransactionalComponent.class).stream().map(MergedAnnotation::getType);\r\n    assertThat(classes).containsExactly(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromNonAnnotatedClass() {\r\n    assertThat(MergedAnnotations.from(NonAnnotatedClass.class).isPresent(Transactional.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromAnnotationClassWithMetaDepth0()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromAnnotationClassWithMetaDepth0() {\r\n    assertThat(MergedAnnotations.from(TransactionalComponent.class).isPresent(TransactionalComponent.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromAnnotationClassWithMetaDepth1()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromAnnotationClassWithMetaDepth1() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(TransactionalComponent.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromAnnotationClassWithMetaDepth2()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromAnnotationClassWithMetaDepth2() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponent.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n    assertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromClassWithMetaDepth0()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromClassWithMetaDepth0() {\r\n    assertThat(MergedAnnotations.from(TransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromSubclassWithMetaDepth0()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromSubclassWithMetaDepth0() {\r\n    assertThat(MergedAnnotations.from(SubTransactionalComponentClass.class).isPresent(TransactionalComponent.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromClassWithMetaDepth1()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromClassWithMetaDepth1() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(TransactionalComponentClass.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#isPresentWhenFromClassWithMetaDepth2()",
    "entityType": "method",
    "code": "@Test\r\nvoid isPresentWhenFromClassWithMetaDepth2() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    assertThat(annotations.isPresent(Transactional.class)).isTrue();\r\n    assertThat(annotations.isPresent(Component.class)).isTrue();\r\n    assertThat(annotations.isPresent(ComposedTransactionalComponent.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getParent()",
    "entityType": "method",
    "code": "@Test\r\nvoid getParent() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    assertThat(annotations.get(TransactionalComponent.class).getMetaSource().getType()).isEqualTo(ComposedTransactionalComponent.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getRootWhenNotDirect()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRootWhenNotDirect() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    MergedAnnotation<?> annotation = annotations.get(TransactionalComponent.class);\r\n    assertThat(annotation.getDistance()).isGreaterThan(0);\r\n    assertThat(annotation.getRoot().getType()).isEqualTo(ComposedTransactionalComponent.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getRootWhenDirect()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRootWhenDirect() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(ComposedTransactionalComponentClass.class);\r\n    MergedAnnotation<?> annotation = annotations.get(ComposedTransactionalComponent.class);\r\n    assertThat(annotation.getDistance()).isEqualTo(0);\r\n    assertThat(annotation.getRoot()).isSameAs(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getMetaTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMetaTypes() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ComposedTransactionalComponentClass.class).get(TransactionalComponent.class);\r\n    assertThat(annotation.getMetaTypes()).containsExactly(ComposedTransactionalComponent.class, TransactionalComponent.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFromNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectMultiValueMapFromNonAnnotatedClass() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(NonAnnotatedClass.class).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFromClassWithLocalAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectMultiValueMapFromClassWithLocalAnnotation() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(TxConfig.class).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"value\", List.of(\"TxConfig\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectMultiValueMapFromClassWithLocalComposedAnnotationAndInheritedAnnotation() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(SubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"qualifier\", List.of(\"composed2\", \"transactionManager\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectMultiValueMapFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(SubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"qualifier\", List.of(\"transactionManager\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectMultiValueMapFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(SubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"qualifier\", List.of(\"composed1\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass()",
    "entityType": "method",
    "code": "/**\r\n * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\r\n * the algorithm is accidentally picking up shadowed annotations of the same\r\n * type within the class hierarchy. Such undesirable behavior would cause\r\n * the logic in\r\n * {@code org.springframework.context.annotation.ProfileCondition} to fail.\r\n */\r\n@Test\r\nvoid collectMultiValueMapFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(DerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"value\", List.of(\"DerivedTxConfig\")));\r\n}",
    "comment": "\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause\n\t * the logic in\n\t * {@code org.springframework.context.annotation.ProfileCondition} to fail.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#collectMultiValueMapFromClassWithMultipleComposedAnnotations()",
    "entityType": "method",
    "code": "/**\r\n * Note: this functionality is required by\r\n * {@code org.springframework.context.annotation.ProfileCondition}.\r\n */\r\n@Test\r\nvoid collectMultiValueMapFromClassWithMultipleComposedAnnotations() {\r\n    MultiValueMap<String, Object> map = MergedAnnotations.from(TxFromMultipleComposedAnnotations.class, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class).collect(MergedAnnotationCollectors.toMultiValueMap());\r\n    assertThat(map).contains(entry(\"value\", List.of(\"TxInheritedComposed\", \"TxComposed\")));\r\n}",
    "comment": "\n\t * Note: this functionality is required by\n\t * {@code org.springframework.context.annotation.ProfileCondition}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromClassWithLocalAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromClassWithLocalAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(TxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"TxConfig\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(DerivedTxConfig.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"DerivedTxConfig\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaCycleAnnotatedClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFavorsLocalComposedAnnotationOverInheritedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedComposedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromInterfaceImplementedBySuperclass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ConcreteClassWithInheritedAnnotation.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.INHERITED_ANNOTATIONS).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#withInheritedAnnotationsFromAliasedComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid withInheritedAnnotationsFromAliasedComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(AliasedComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#withInheritedAnnotationsFromAliasedValueComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid withInheritedAnnotationsFromAliasedValueComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(AliasedValueComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ComposedImplicitAliasesContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ImplicitAliasesContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"groovyScripts\")).containsExactly(\"A.xml\", \"B.xml\");\r\n    assertThat(annotation.getStringArray(\"xmlFiles\")).containsExactly(\"A.xml\", \"B.xml\");\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"A.xml\", \"B.xml\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"A.xml\", \"B.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromAliasedValueComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromAliasedValueComposedAnnotation() {\r\n    testGetWithInherited(AliasedValueComposedContextConfigurationClass.class, \"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromImplicitAliasesForSameAttributeInComposedAnnotation() {\r\n    testGetWithInherited(ImplicitAliasesContextConfigurationClass1.class, \"foo.xml\");\r\n    testGetWithInherited(ImplicitAliasesContextConfigurationClass2.class, \"bar.xml\");\r\n    testGetWithInherited(ImplicitAliasesContextConfigurationClass3.class, \"baz.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromTransitiveImplicitAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliases() {\r\n    testGetWithInherited(TransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    testGetWithInherited(SingleLocationTransitiveImplicitAliasesContextConfigurationClass.class, \"test.groovy\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevel() {\r\n    testGetWithInherited(TransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    testGetWithInherited(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigurationClass.class, \"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testGetWithInherited(Class<?>,String)",
    "entityType": "method",
    "code": "private void testGetWithInherited(Class<?> element, String... expected) {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).isEqualTo(expected);\r\n    assertThat(annotation.getStringArray(\"value\")).isEqualTo(expected);\r\n    assertThat(annotation.getClassArray(\"classes\")).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithInheritedAnnotationsFromShadowedAliasComposedAnnotation() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ShadowedAliasComposedContextConfigurationClass.class, SearchStrategy.INHERITED_ANNOTATIONS).get(ContextConfiguration.class);\r\n    assertThat(annotation.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(InheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromSubSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromSubSubInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(NonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromSubSubNonInheritedAnnotationInterface() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubNonInheritedAnnotationInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyInheritedFromInterfaceMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyInheritedFromInterfaceMethod() throws Exception {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamWithTypeHierarchyInheritedFromSuperInterfaceMethod()",
    "entityType": "method",
    "code": "// gh-31803\r\n@Test\r\nvoid streamWithTypeHierarchyInheritedFromSuperInterfaceMethod() throws Exception {\r\n    Method method = Hello2Impl.class.getMethod(\"method\");\r\n    long count = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY).from(method).stream(TestAnnotation1.class).count();\r\n    assertThat(count).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyInheritedFromAbstractMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyInheritedFromAbstractMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyInheritedFromBridgedMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyInheritedFromBridgedMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromBridgeMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromBridgeMethod() {\r\n    List<Method> methods = new ArrayList<>();\r\n    ReflectionUtils.doWithLocalMethods(StringGenericParameter.class, method -> {\r\n        if (\"getFor\".equals(method.getName())) {\r\n            methods.add(method);\r\n        }\r\n    });\r\n    Method bridgeMethod = methods.get(0).getReturnType().equals(Object.class) ? methods.get(0) : methods.get(1);\r\n    Method bridgedMethod = methods.get(0).getReturnType().equals(Object.class) ? methods.get(1) : methods.get(0);\r\n    assertThat(bridgeMethod.isBridge()).isTrue();\r\n    assertThat(bridgedMethod.isBridge()).isFalse();\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(bridgeMethod, SearchStrategy.TYPE_HIERARCHY).get(Order.class);\r\n    assertThat(annotation.isPresent()).isTrue();\r\n    assertThat(annotation.getAggregateIndex()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromClassWithMetaAndLocalTxConfig() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaAndLocalTxConfigClass.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getString(\"qualifier\")).isEqualTo(\"localTxMgr\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromClassWithAttributeAliasesInTargetAnnotation() {\r\n    MergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(AliasedTransactionalComponentClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\r\n    AliasedTransactional synthesizedAnnotation = mergedAnnotation.synthesize();\r\n    String qualifier = \"aliasForQualifier\";\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(qualifier);\r\n    assertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(qualifier);\r\n    assertThat(synthesizedAnnotation.value()).isEqualTo(qualifier);\r\n    assertThat(synthesizedAnnotation.qualifier()).isEqualTo(qualifier);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation()",
    "entityType": "method",
    "code": "// gh-23767\r\n@Test\r\nvoid getWithTypeHierarchyFromClassWithComposedMetaTransactionalAnnotation() {\r\n    MergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(ComposedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"anotherTransactionManager\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional()",
    "entityType": "method",
    "code": "// gh-23767\r\n@Test\r\nvoid getWithTypeHierarchyFromClassWithMetaMetaAliasedTransactional() {\r\n    MergedAnnotation<AliasedTransactional> mergedAnnotation = MergedAnnotations.from(MetaMetaAliasedTransactionalClass.class, SearchStrategy.TYPE_HIERARCHY).get(AliasedTransactional.class);\r\n    assertThat(mergedAnnotation.getString(\"value\")).isEqualTo(\"meta\");\r\n    assertThat(mergedAnnotation.getString(\"qualifier\")).isEqualTo(\"meta\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\r\n    MergedAnnotation<?> annotation = testGetWithTypeHierarchy(TestComponentScanClass.class, \"com.example.app.test\");\r\n    MergedAnnotation<Filter>[] excludeFilters = annotation.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(Arrays.stream(excludeFilters).map(filter -> filter.getString(\"pattern\"))).containsExactly(\"*Test\", \"*Tests\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyFromClassWithBothAttributesOfAnAliasPairDeclared() {\r\n    testGetWithTypeHierarchy(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    testGetWithTypeHierarchy(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testGetWithTypeHierarchy(Class<?>,String)",
    "entityType": "method",
    "code": "private MergedAnnotation<?> testGetWithTypeHierarchy(Class<?> element, String... expected) {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY).get(ComponentScan.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(expected);\r\n    assertThat(annotation.getStringArray(\"basePackages\")).containsExactly(expected);\r\n    return annotation;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyWhenMultipleMetaAnnotationsHaveClashingAttributeNames() {\r\n    MergedAnnotations annotations = MergedAnnotations.from(AliasedComposedContextConfigurationAndTestPropertySourceClass.class, SearchStrategy.TYPE_HIERARCHY);\r\n    MergedAnnotation<?> contextConfig = annotations.get(ContextConfiguration.class);\r\n    assertThat(contextConfig.getStringArray(\"locations\")).containsExactly(\"test.xml\");\r\n    assertThat(contextConfig.getStringArray(\"value\")).containsExactly(\"test.xml\");\r\n    MergedAnnotation<?> testPropSource = annotations.get(TestPropertySource.class);\r\n    assertThat(testPropSource.getStringArray(\"locations\")).containsExactly(\"test.properties\");\r\n    assertThat(testPropSource.getStringArray(\"value\")).containsExactly(\"test.properties\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithTypeHierarchyOnMethodWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\r\n    testGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\r\n    testGetWithTypeHierarchyWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#testGetWithTypeHierarchyWebMapping(AnnotatedElement)",
    "entityType": "method",
    "code": "private void testGetWithTypeHierarchyWebMapping(AnnotatedElement element) {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY).get(RequestMapping.class);\r\n    assertThat(annotation.getStringArray(\"value\")).containsExactly(\"/test\");\r\n    assertThat(annotation.getStringArray(\"path\")).containsExactly(\"/test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectWithJavaxAnnotationType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectWithJavaxAnnotationType() {\r\n    assertThat(MergedAnnotations.from(ResourceHolder.class).get(Resource.class).getString(\"name\")).isEqualTo(\"x\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamInheritedFromClassWithInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamInheritedFromClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.INHERITED_ANNOTATIONS).stream(Transactional.class)).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#streamTypeHierarchyFromClassWithInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamTypeHierarchyFromClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(Transactional.class)).hasSize(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithMethodAnnotationOnLeaf()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithMethodAnnotationOnLeaf() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"annotatedOnLeaf\");\r\n    assertThat(method.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithAnnotationOnMethodInInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithAnnotationOnMethodInInterface() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"fromInterfaceImplementedByRoot\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithMetaAnnotationOnLeaf()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithMetaAnnotationOnLeaf() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"metaAnnotatedOnLeaf\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithMetaMetaAnnotationOnLeaf()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithMetaMetaAnnotationOnLeaf() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"metaMetaAnnotatedOnLeaf\");\r\n    assertThat(method.getAnnotation(Component.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Component.class).getDistance()).isEqualTo(2);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Component.class).getDistance()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getWithAnnotationOnRoot()",
    "entityType": "method",
    "code": "@Test\r\nvoid getWithAnnotationOnRoot() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"annotatedOnRoot\");\r\n    assertThat(method.getAnnotation(Order.class)).isNotNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithMetaAnnotationOnRoot()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithMetaAnnotationOnRoot() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"metaAnnotatedOnRoot\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithOnRootButOverridden()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithOnRootButOverridden() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"overrideWithoutNewAnnotation\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithNotAnnotated()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithNotAnnotated() throws Exception {\r\n    Method method = Leaf.class.getMethod(\"notAnnotated\");\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(-1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithBridgeMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithBridgeMethod() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", Object.class);\r\n    assertThat(method.isBridge()).isTrue();\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n    // As of JDK 8, invoking getAnnotation() on a bridge method actually finds an\r\n    // annotation on its 'bridged' method [1]; however, the Eclipse compiler does\r\n    // not support this [2]. Thus, we effectively ignore the following\r\n    // assertion if the test is currently executing within the Eclipse IDE.\r\n    //\r\n    // [1] https://bugs.openjdk.java.net/browse/JDK-6695379\r\n    // [2] https://bugs.eclipse.org/bugs/show_bug.cgi?id=495396\r\n    //\r\n    if (!IdeUtils.runningInEclipse()) {\r\n        assertThat(method.getAnnotation(Transactional.class)).isNotNull();\r\n    }\r\n    assertThat(MergedAnnotations.from(method).get(Transactional.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithBridgedMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithBridgedMethod() throws Exception {\r\n    Method method = TransactionalStringGeneric.class.getMethod(\"something\", String.class);\r\n    assertThat(method.isBridge()).isFalse();\r\n    assertThat(method.getAnnotation(Order.class)).isNull();\r\n    assertThat(MergedAnnotations.from(method).get(Order.class).getDistance()).isEqualTo(-1);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n    assertThat(method.getAnnotation(Transactional.class)).isNotNull();\r\n    assertThat(MergedAnnotations.from(method).get(Transactional.class).getDistance()).isEqualTo(0);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithGenericInterface()",
    "entityType": "method",
    "code": "// SPR-16060\r\n@Test\r\nvoid getFromMethodWithGenericInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithGenericSuperclass()",
    "entityType": "method",
    "code": "// SPR-17146\r\n@Test\r\nvoid getFromMethodWithGenericSuperclass() throws Exception {\r\n    Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWithInterfaceOnSuper()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWithInterfaceOnSuper() throws Exception {\r\n    Method method = SubOfImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFromMethodWhenInterfaceWhenSuperDoesNotImplementMethod() throws Exception {\r\n    Method method = SubOfAbstractImplementsInterfaceWithAnnotatedMethod.class.getMethod(\"foo\");\r\n    assertThat(MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).get(Order.class).getDistance()).isEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverAnnotationsOnInterfaces() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(ClassWithLocalMetaAnnotationAndMetaAnnotatedInterface.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Transactional.class);\r\n    assertThat(annotation.getBoolean(\"readOnly\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassFavorsMoreLocallyDeclaredComposedAnnotationsOverInheritedComposedAnnotations() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(SubSubClassWithInheritedMetaAnnotation.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassgetDirectFromClassMetaMetaAnnotatedClass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsTests#getDirectFromClassWithMetaMetaMetaAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDirectFromClassWithMetaMetaMetaAnnotatedClass() {\r\n    MergedAnnotation<?> annotation = MergedAnnotations.from(MetaMetaMetaAnnotatedClass.class, SearchStrategy.TYPE_HIERARCHY).get(Component.class);\r\n    assertThat(annotation.getString(\"value\")).isEqualTo(\"meta2\");\r\n}",
    "comment": ""
  }
]