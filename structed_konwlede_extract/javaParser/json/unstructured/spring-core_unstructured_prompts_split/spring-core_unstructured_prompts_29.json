[
  {
    "entityId": "org.springframework.asm.MethodWriter#visitInsnAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitInsnAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastCodeRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8), typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastCodeRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, (typeRef & 0xFF0000FF) | (lastBytecodeOffset << 8), typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\r\n    Handler newHandler = new Handler(start, end, handler, type != null ? symbolTable.addConstantClass(type).index : 0, type);\r\n    if (firstHandler == null) {\r\n        firstHandler = newHandler;\r\n    } else {\r\n        lastHandler.nextHandler = newHandler;\r\n    }\r\n    lastHandler = newHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitTryCatchAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitTryCatchAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastCodeRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastCodeRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastCodeRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitLocalVariable(String,String,String,Label,Label,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLocalVariable(final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) {\r\n    if (signature != null) {\r\n        if (localVariableTypeTable == null) {\r\n            localVariableTypeTable = new ByteVector();\r\n        }\r\n        ++localVariableTypeTableLength;\r\n        localVariableTypeTable.putShort(start.bytecodeOffset).putShort(end.bytecodeOffset - start.bytecodeOffset).putShort(symbolTable.addConstantUtf8(name)).putShort(symbolTable.addConstantUtf8(signature)).putShort(index);\r\n    }\r\n    if (localVariableTable == null) {\r\n        localVariableTable = new ByteVector();\r\n    }\r\n    ++localVariableTableLength;\r\n    localVariableTable.putShort(start.bytecodeOffset).putShort(end.bytecodeOffset - start.bytecodeOffset).putShort(symbolTable.addConstantUtf8(name)).putShort(symbolTable.addConstantUtf8(descriptor)).putShort(index);\r\n    if (compute != COMPUTE_NOTHING) {\r\n        char firstDescChar = descriptor.charAt(0);\r\n        int currentMaxLocals = index + (firstDescChar == 'J' || firstDescChar == 'D' ? 2 : 1);\r\n        if (currentMaxLocals > maxLocals) {\r\n            maxLocals = currentMaxLocals;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitLocalVariableAnnotation(final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) {\r\n    // Create a ByteVector to hold a 'type_annotation' JVMS structure.\r\n    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.\r\n    ByteVector typeAnnotation = new ByteVector();\r\n    // Write target_type, target_info, and target_path.\r\n    typeAnnotation.putByte(typeRef >>> 24).putShort(start.length);\r\n    for (int i = 0; i < start.length; ++i) {\r\n        typeAnnotation.putShort(start[i].bytecodeOffset).putShort(end[i].bytecodeOffset - start[i].bytecodeOffset).putShort(index[i]);\r\n    }\r\n    TypePath.put(typePath, typeAnnotation);\r\n    // Write type_index and reserve space for num_element_value_pairs.\r\n    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);\r\n    if (visible) {\r\n        return lastCodeRuntimeVisibleTypeAnnotation = new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n        true, typeAnnotation, lastCodeRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastCodeRuntimeInvisibleTypeAnnotation = new AnnotationWriter(symbolTable, /* useNamedValues= */\r\n        true, typeAnnotation, lastCodeRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitLineNumber(int,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitLineNumber(final int line, final Label start) {\r\n    if (lineNumberTable == null) {\r\n        lineNumberTable = new ByteVector();\r\n    }\r\n    ++lineNumberTableLength;\r\n    lineNumberTable.putShort(start.bytecodeOffset);\r\n    lineNumberTable.putShort(line);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitMaxs(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMaxs(final int maxStack, final int maxLocals) {\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        computeAllFrames();\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n        computeMaxStackAndLocal();\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {\r\n        this.maxStack = maxRelativeStackSize;\r\n    } else {\r\n        this.maxStack = maxStack;\r\n        this.maxLocals = maxLocals;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#computeAllFrames()",
    "entityType": "method",
    "code": "/**\r\n * Computes all the stack map frames of the method, from scratch.\r\n */\r\nprivate void computeAllFrames() {\r\n    // Complete the control flow graph with exception handler blocks.\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        String catchTypeDescriptor = handler.catchTypeDescriptor == null ? \"java/lang/Throwable\" : handler.catchTypeDescriptor;\r\n        int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);\r\n        // Mark handlerBlock as an exception handler.\r\n        Label handlerBlock = handler.handlerPc.getCanonicalInstance();\r\n        handlerBlock.flags |= Label.FLAG_JUMP_TARGET;\r\n        // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\r\n        Label handlerRangeBlock = handler.startPc.getCanonicalInstance();\r\n        Label handlerRangeEnd = handler.endPc.getCanonicalInstance();\r\n        while (handlerRangeBlock != handlerRangeEnd) {\r\n            handlerRangeBlock.outgoingEdges = new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);\r\n            handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\r\n        }\r\n        handler = handler.nextHandler;\r\n    }\r\n    // Create and visit the first (implicit) frame.\r\n    Frame firstFrame = firstBasicBlock.frame;\r\n    firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);\r\n    firstFrame.accept(this);\r\n    // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks\r\n    // whose stack map frame has changed) and, while there are blocks to process, remove one from\r\n    // the list and update the stack map frames of its successor blocks in the control flow graph\r\n    // (which might change them, in which case these blocks must be processed too, and are thus\r\n    // added to the list of blocks to process). Also compute the maximum stack size of the method,\r\n    // as a by-product.\r\n    Label listOfBlocksToProcess = firstBasicBlock;\r\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\r\n    int maxStackSize = 0;\r\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\r\n        // Remove a basic block from the list of blocks to process.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        basicBlock.nextListElement = null;\r\n        // By definition, basicBlock is reachable.\r\n        basicBlock.flags |= Label.FLAG_REACHABLE;\r\n        // Update the (absolute) maximum stack size.\r\n        int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;\r\n        if (maxBlockStackSize > maxStackSize) {\r\n            maxStackSize = maxBlockStackSize;\r\n        }\r\n        // Update the successor blocks of basicBlock in the control flow graph.\r\n        Edge outgoingEdge = basicBlock.outgoingEdges;\r\n        while (outgoingEdge != null) {\r\n            Label successorBlock = outgoingEdge.successor.getCanonicalInstance();\r\n            boolean successorBlockChanged = basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);\r\n            if (successorBlockChanged && successorBlock.nextListElement == null) {\r\n                // If successorBlock has changed it must be processed. Thus, if it is not already in the\r\n                // list of blocks to process, add it to this list.\r\n                successorBlock.nextListElement = listOfBlocksToProcess;\r\n                listOfBlocksToProcess = successorBlock;\r\n            }\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n    }\r\n    // Loop over all the basic blocks and visit the stack map frames that must be stored in the\r\n    // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from\r\n    // exception handler ranges.\r\n    Label basicBlock = firstBasicBlock;\r\n    while (basicBlock != null) {\r\n        if ((basicBlock.flags & (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {\r\n            basicBlock.frame.accept(this);\r\n        }\r\n        if ((basicBlock.flags & Label.FLAG_REACHABLE) == 0) {\r\n            // Find the start and end bytecode offsets of this unreachable block.\r\n            Label nextBasicBlock = basicBlock.nextBasicBlock;\r\n            int startOffset = basicBlock.bytecodeOffset;\r\n            int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;\r\n            if (endOffset >= startOffset) {\r\n                // Replace its instructions with NOP ... NOP ATHROW.\r\n                for (int i = startOffset; i < endOffset; ++i) {\r\n                    code.data[i] = Opcodes.NOP;\r\n                }\r\n                code.data[endOffset] = (byte) Opcodes.ATHROW;\r\n                // Emit a frame for this unreachable block, with no local and a Throwable on the stack\r\n                // (so that the ATHROW could consume this Throwable if it were reachable).\r\n                int frameIndex = visitFrameStart(startOffset, /* numLocal = */\r\n                0, /* numStack = */\r\n                1);\r\n                currentFrame[frameIndex] = Frame.getAbstractTypeFromInternalName(symbolTable, \"java/lang/Throwable\");\r\n                visitFrameEnd();\r\n                // Remove this unreachable basic block from the exception handler ranges.\r\n                firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);\r\n                // The maximum stack size is now at least one, because of the Throwable declared above.\r\n                maxStackSize = Math.max(maxStackSize, 1);\r\n            }\r\n        }\r\n        basicBlock = basicBlock.nextBasicBlock;\r\n    }\r\n    this.maxStack = maxStackSize;\r\n}",
    "comment": " Computes all the stack map frames of the method, from scratch. "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#computeMaxStackAndLocal()",
    "entityType": "method",
    "code": "/**\r\n * Computes the maximum stack size of the method.\r\n */\r\nprivate void computeMaxStackAndLocal() {\r\n    // Complete the control flow graph with exception handler blocks.\r\n    Handler handler = firstHandler;\r\n    while (handler != null) {\r\n        Label handlerBlock = handler.handlerPc;\r\n        Label handlerRangeBlock = handler.startPc;\r\n        Label handlerRangeEnd = handler.endPc;\r\n        // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\r\n        while (handlerRangeBlock != handlerRangeEnd) {\r\n            if ((handlerRangeBlock.flags & Label.FLAG_SUBROUTINE_CALLER) == 0) {\r\n                handlerRangeBlock.outgoingEdges = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);\r\n            } else {\r\n                // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing\r\n                // edges to preserve the hypothesis about JSR block successors order (see\r\n                // {@link #visitJumpInsn}).\r\n                handlerRangeBlock.outgoingEdges.nextEdge.nextEdge = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);\r\n            }\r\n            handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\r\n        }\r\n        handler = handler.nextHandler;\r\n    }\r\n    // Complete the control flow graph with the successor blocks of subroutines, if needed.\r\n    if (hasSubroutines) {\r\n        // First step: find the subroutines. This step determines, for each basic block, to which\r\n        // subroutine(s) it belongs. Start with the main \"subroutine\":\r\n        short numSubroutines = 1;\r\n        firstBasicBlock.markSubroutine(numSubroutines);\r\n        // Then, mark the subroutines called by the main subroutine, then the subroutines called by\r\n        // those called by the main subroutine, etc.\r\n        for (short currentSubroutine = 1; currentSubroutine <= numSubroutines; ++currentSubroutine) {\r\n            Label basicBlock = firstBasicBlock;\r\n            while (basicBlock != null) {\r\n                if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && basicBlock.subroutineId == currentSubroutine) {\r\n                    Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;\r\n                    if (jsrTarget.subroutineId == 0) {\r\n                        // If this subroutine has not been marked yet, find its basic blocks.\r\n                        jsrTarget.markSubroutine(++numSubroutines);\r\n                    }\r\n                }\r\n                basicBlock = basicBlock.nextBasicBlock;\r\n            }\r\n        }\r\n        // Second step: find the successors in the control flow graph of each subroutine basic block\r\n        // 'r' ending with a RET instruction. These successors are the virtual successors of the basic\r\n        // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.\r\n        Label basicBlock = firstBasicBlock;\r\n        while (basicBlock != null) {\r\n            if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\r\n                // By construction, jsr targets are stored in the second outgoing edge of basic blocks\r\n                // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).\r\n                Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;\r\n                subroutine.addSubroutineRetSuccessors(basicBlock);\r\n            }\r\n            basicBlock = basicBlock.nextBasicBlock;\r\n        }\r\n    }\r\n    // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks\r\n    // whose input stack size has changed) and, while there are blocks to process, remove one\r\n    // from the list, update the input stack size of its successor blocks in the control flow\r\n    // graph, and add these blocks to the list of blocks to process (if not already done).\r\n    Label listOfBlocksToProcess = firstBasicBlock;\r\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\r\n    int maxStackSize = maxStack;\r\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\r\n        // Remove a basic block from the list of blocks to process. Note that we don't reset\r\n        // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already\r\n        // processed basic blocks.\r\n        Label basicBlock = listOfBlocksToProcess;\r\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\r\n        // Compute the (absolute) input stack size and maximum stack size of this block.\r\n        int inputStackTop = basicBlock.inputStackSize;\r\n        int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;\r\n        // Update the absolute maximum stack size of the method.\r\n        if (maxBlockStackSize > maxStackSize) {\r\n            maxStackSize = maxBlockStackSize;\r\n        }\r\n        // Update the input stack size of the successor blocks of basicBlock in the control flow\r\n        // graph, and add these blocks to the list of blocks to process, if not already done.\r\n        Edge outgoingEdge = basicBlock.outgoingEdges;\r\n        if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\r\n            // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual\r\n            // edges which lead to the instruction just after the jsr, and do not correspond to a\r\n            // possible execution path (see {@link #visitJumpInsn} and\r\n            // {@link Label#FLAG_SUBROUTINE_CALLER}).\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n        while (outgoingEdge != null) {\r\n            Label successorBlock = outgoingEdge.successor;\r\n            if (successorBlock.nextListElement == null) {\r\n                successorBlock.inputStackSize = (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);\r\n                successorBlock.nextListElement = listOfBlocksToProcess;\r\n                listOfBlocksToProcess = successorBlock;\r\n            }\r\n            outgoingEdge = outgoingEdge.nextEdge;\r\n        }\r\n    }\r\n    this.maxStack = maxStackSize;\r\n}",
    "comment": " Computes the maximum stack size of the method. "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#addSuccessorToCurrentBasicBlock(int,Label)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods: control flow analysis algorithm\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\r\n *\r\n * @param info information about the control flow edge to be added.\r\n * @param successor the successor block to be added to the current basic block.\r\n */\r\nprivate void addSuccessorToCurrentBasicBlock(final int info, final Label successor) {\r\n    currentBasicBlock.outgoingEdges = new Edge(info, successor, currentBasicBlock.outgoingEdges);\r\n}",
    "comment": "\n   * Adds a successor to {@link #currentBasicBlock} in the control flow graph.\n   *\n   * @param info information about the control flow edge to be added.\n   * @param successor the successor block to be added to the current basic block.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
    "entityType": "method",
    "code": "/**\r\n * Ends the current basic block. This method must be used in the case where the current basic\r\n * block does not have any successor.\r\n *\r\n * <p>WARNING: this method must be called after the currently visited instruction has been put in\r\n * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\r\n * block after the current instruction).\r\n */\r\nprivate void endCurrentBasicBlockWithNoSuccessor() {\r\n    if (compute == COMPUTE_ALL_FRAMES) {\r\n        Label nextBasicBlock = new Label();\r\n        nextBasicBlock.frame = new Frame(nextBasicBlock);\r\n        nextBasicBlock.resolve(code.data, stackMapTableEntries, code.length);\r\n        lastBasicBlock.nextBasicBlock = nextBasicBlock;\r\n        lastBasicBlock = nextBasicBlock;\r\n        currentBasicBlock = null;\r\n    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n        currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\r\n        currentBasicBlock = null;\r\n    }\r\n}",
    "comment": "\n   * Ends the current basic block. This method must be used in the case where the current basic\n   * block does not have any successor.\n   *\n   * <p>WARNING: this method must be called after the currently visited instruction has been put in\n   * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic\n   * block after the current instruction).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods: stack map frames\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\r\n *\r\n * @param offset the bytecode offset of the instruction to which the frame corresponds.\r\n * @param numLocal the number of local variables in the frame.\r\n * @param numStack the number of stack elements in the frame.\r\n * @return the index of the next element to be written in this frame.\r\n */\r\nint visitFrameStart(final int offset, final int numLocal, final int numStack) {\r\n    int frameLength = 3 + numLocal + numStack;\r\n    if (currentFrame == null || currentFrame.length < frameLength) {\r\n        currentFrame = new int[frameLength];\r\n    }\r\n    currentFrame[0] = offset;\r\n    currentFrame[1] = numLocal;\r\n    currentFrame[2] = numStack;\r\n    return 3;\r\n}",
    "comment": "\n   * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.\n   *\n   * @param offset the bytecode offset of the instruction to which the frame corresponds.\n   * @param numLocal the number of local variables in the frame.\n   * @param numStack the number of stack elements in the frame.\n   * @return the index of the next element to be written in this frame.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Sets an abstract type in {@link #currentFrame}.\r\n *\r\n * @param frameIndex the index of the element to be set in {@link #currentFrame}.\r\n * @param abstractType an abstract type.\r\n */\r\nvoid visitAbstractType(final int frameIndex, final int abstractType) {\r\n    currentFrame[frameIndex] = abstractType;\r\n}",
    "comment": "\n   * Sets an abstract type in {@link #currentFrame}.\n   *\n   * @param frameIndex the index of the element to be set in {@link #currentFrame}.\n   * @param abstractType an abstract type.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#visitFrameEnd()",
    "entityType": "method",
    "code": "/**\r\n * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\r\n * updating the StackMapTable number_of_entries (except if the current frame is the first one,\r\n * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\r\n */\r\nvoid visitFrameEnd() {\r\n    if (previousFrame != null) {\r\n        if (stackMapTableEntries == null) {\r\n            stackMapTableEntries = new ByteVector();\r\n        }\r\n        putFrame();\r\n        ++stackMapTableNumberOfEntries;\r\n    }\r\n    previousFrame = currentFrame;\r\n    currentFrame = null;\r\n}",
    "comment": "\n   * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by\n   * updating the StackMapTable number_of_entries (except if the current frame is the first one,\n   * which is implicit in StackMapTable). Then resets {@link #currentFrame} to {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#putFrame()",
    "entityType": "method",
    "code": "/**\r\n * Compresses and writes {@link #currentFrame} in a new StackMapTable entry.\r\n */\r\nprivate void putFrame() {\r\n    final int numLocal = currentFrame[1];\r\n    final int numStack = currentFrame[2];\r\n    if (symbolTable.getMajorVersion() < Opcodes.V1_6) {\r\n        // Generate a StackMap attribute entry, which are always uncompressed.\r\n        stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);\r\n        putAbstractTypes(3, 3 + numLocal);\r\n        stackMapTableEntries.putShort(numStack);\r\n        putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\r\n        return;\r\n    }\r\n    final int offsetDelta = stackMapTableNumberOfEntries == 0 ? currentFrame[0] : currentFrame[0] - previousFrame[0] - 1;\r\n    final int previousNumlocal = previousFrame[1];\r\n    final int numLocalDelta = numLocal - previousNumlocal;\r\n    int type = Frame.FULL_FRAME;\r\n    if (numStack == 0) {\r\n        switch(numLocalDelta) {\r\n            case -3:\r\n            case -2:\r\n            case -1:\r\n                type = Frame.CHOP_FRAME;\r\n                break;\r\n            case 0:\r\n                type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;\r\n                break;\r\n            case 1:\r\n            case 2:\r\n            case 3:\r\n                type = Frame.APPEND_FRAME;\r\n                break;\r\n            default:\r\n                // Keep the FULL_FRAME type.\r\n                break;\r\n        }\r\n    } else if (numLocalDelta == 0 && numStack == 1) {\r\n        type = offsetDelta < 63 ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\r\n    }\r\n    if (type != Frame.FULL_FRAME) {\r\n        // Verify if locals are the same as in the previous frame.\r\n        int frameIndex = 3;\r\n        for (int i = 0; i < previousNumlocal && i < numLocal; i++) {\r\n            if (currentFrame[frameIndex] != previousFrame[frameIndex]) {\r\n                type = Frame.FULL_FRAME;\r\n                break;\r\n            }\r\n            frameIndex++;\r\n        }\r\n    }\r\n    switch(type) {\r\n        case Frame.SAME_FRAME:\r\n            stackMapTableEntries.putByte(offsetDelta);\r\n            break;\r\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);\r\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\r\n            break;\r\n        case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\r\n            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(offsetDelta);\r\n            putAbstractTypes(3 + numLocal, 4 + numLocal);\r\n            break;\r\n        case Frame.SAME_FRAME_EXTENDED:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);\r\n            break;\r\n        case Frame.CHOP_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\r\n            break;\r\n        case Frame.APPEND_FRAME:\r\n            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta).putShort(offsetDelta);\r\n            putAbstractTypes(3 + previousNumlocal, 3 + numLocal);\r\n            break;\r\n        case Frame.FULL_FRAME:\r\n        default:\r\n            stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);\r\n            putAbstractTypes(3, 3 + numLocal);\r\n            stackMapTableEntries.putShort(numStack);\r\n            putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);\r\n            break;\r\n    }\r\n}",
    "comment": " Compresses and writes {@link #currentFrame} in a new StackMapTable entry. "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\r\n * JVMS verification_type_info format used in StackMapTable attributes.\r\n *\r\n * @param start index of the first type in {@link #currentFrame} to write.\r\n * @param end index of last type in {@link #currentFrame} to write (exclusive).\r\n */\r\nprivate void putAbstractTypes(final int start, final int end) {\r\n    for (int i = start; i < end; ++i) {\r\n        Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);\r\n    }\r\n}",
    "comment": "\n   * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the\n   * JVMS verification_type_info format used in StackMapTable attributes.\n   *\n   * @param start index of the first type in {@link #currentFrame} to write.\n   * @param end index of last type in {@link #currentFrame} to write (exclusive).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#putFrameType(Object)",
    "entityType": "method",
    "code": "/**\r\n * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS\r\n * verification_type_info format used in StackMapTable attributes.\r\n *\r\n * @param type a frame element type described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\r\n *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\r\n *     a NEW instruction (for uninitialized types).\r\n */\r\nprivate void putFrameType(final Object type) {\r\n    if (type instanceof Integer) {\r\n        stackMapTableEntries.putByte(((Integer) type).intValue());\r\n    } else if (type instanceof String) {\r\n        stackMapTableEntries.putByte(Frame.ITEM_OBJECT).putShort(symbolTable.addConstantClass((String) type).index);\r\n    } else {\r\n        stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);\r\n        ((Label) type).put(stackMapTableEntries);\r\n    }\r\n}",
    "comment": "\n   * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS\n   * verification_type_info format used in StackMapTable attributes.\n   *\n   * @param type a frame element type described using the same format as in {@link\n   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\n   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\n   *     a NEW instruction (for uninitialized types).\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns whether the attributes of this method can be copied from the attributes of the given\r\n * method (assuming there is no method visitor between the given ClassReader and this\r\n * MethodWriter). This method should only be called just after this MethodWriter has been created,\r\n * and before any content is visited. It returns true if the attributes corresponding to the\r\n * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic\r\n * attribute) are the same as the corresponding attributes in the given method.\r\n *\r\n * @param source the source ClassReader from which the attributes of this method might be copied.\r\n * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes\r\n *     of this method might be copied contains a Synthetic attribute.\r\n * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes\r\n *     of this method might be copied contains a Deprecated attribute.\r\n * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which\r\n *     the attributes of this method might be copied.\r\n * @param signatureIndex the constant pool index contained in the Signature attribute of the\r\n *     method_info JVMS structure from which the attributes of this method might be copied, or 0.\r\n * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info\r\n *     JVMS structure from which the attributes of this method might be copied, or 0.\r\n * @return whether the attributes of this method can be copied from the attributes of the\r\n *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'\r\n *     + 'methodInfoLength'.\r\n */\r\nboolean canCopyMethodAttributes(final ClassReader source, final boolean hasSyntheticAttribute, final boolean hasDeprecatedAttribute, final int descriptorIndex, final int signatureIndex, final int exceptionsOffset) {\r\n    // If the method descriptor has changed, with more locals than the max_locals field of the\r\n    // original Code attribute, if any, then the original method attributes can't be copied. A\r\n    // conservative check on the descriptor changes alone ensures this (being more precise is not\r\n    // worth the additional complexity, because these cases should be rare -- if a transform changes\r\n    // a method descriptor, most of the time it needs to change the method's code too).\r\n    if (source != symbolTable.getSource() || descriptorIndex != this.descriptorIndex || signatureIndex != this.signatureIndex || hasDeprecatedAttribute != ((accessFlags & Opcodes.ACC_DEPRECATED) != 0)) {\r\n        return false;\r\n    }\r\n    boolean needSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5 && (accessFlags & Opcodes.ACC_SYNTHETIC) != 0;\r\n    if (hasSyntheticAttribute != needSyntheticAttribute) {\r\n        return false;\r\n    }\r\n    if (exceptionsOffset == 0) {\r\n        if (numberOfExceptions != 0) {\r\n            return false;\r\n        }\r\n    } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {\r\n        int currentExceptionOffset = exceptionsOffset + 2;\r\n        for (int i = 0; i < numberOfExceptions; ++i) {\r\n            if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {\r\n                return false;\r\n            }\r\n            currentExceptionOffset += 2;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n   * Returns whether the attributes of this method can be copied from the attributes of the given\n   * method (assuming there is no method visitor between the given ClassReader and this\n   * MethodWriter). This method should only be called just after this MethodWriter has been created,\n   * and before any content is visited. It returns true if the attributes corresponding to the\n   * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic\n   * attribute) are the same as the corresponding attributes in the given method.\n   *\n   * @param source the source ClassReader from which the attributes of this method might be copied.\n   * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes\n   *     of this method might be copied contains a Synthetic attribute.\n   * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes\n   *     of this method might be copied contains a Deprecated attribute.\n   * @param descriptorIndex the descriptor_index field of the method_info JVMS structure from which\n   *     the attributes of this method might be copied.\n   * @param signatureIndex the constant pool index contained in the Signature attribute of the\n   *     method_info JVMS structure from which the attributes of this method might be copied, or 0.\n   * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info\n   *     JVMS structure from which the attributes of this method might be copied, or 0.\n   * @return whether the attributes of this method can be copied from the attributes of the\n   *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'\n   *     + 'methodInfoLength'.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Sets the source from which the attributes of this method will be copied.\r\n *\r\n * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS\r\n *     structure from which the attributes of this method will be copied.\r\n * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS\r\n *     structure from which the attributes of this method will be copied.\r\n */\r\nvoid setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {\r\n    // Don't copy the attributes yet, instead store their location in the source class reader so\r\n    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes\r\n    // of the method_info JVMS structure.\r\n    this.sourceOffset = methodInfoOffset + 6;\r\n    this.sourceLength = methodInfoLength - 6;\r\n}",
    "comment": "\n   * Sets the source from which the attributes of this method will be copied.\n   *\n   * @param methodInfoOffset the offset in 'symbolTable.getSource()' of the method_info JVMS\n   *     structure from which the attributes of this method will be copied.\n   * @param methodInfoLength the length in 'symbolTable.getSource()' of the method_info JVMS\n   *     structure from which the attributes of this method will be copied.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\r\n * names of the attributes of this method in the constant pool.\r\n *\r\n * @return the size in bytes of the method_info JVMS structure.\r\n */\r\nint computeMethodInfoSize() {\r\n    // If this method_info must be copied from an existing one, the size computation is trivial.\r\n    if (sourceOffset != 0) {\r\n        // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.\r\n        return 6 + sourceLength;\r\n    }\r\n    // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.\r\n    int size = 8;\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (code.length > 0) {\r\n        if (code.length > 65535) {\r\n            throw new MethodTooLargeException(symbolTable.getClassName(), name, descriptor, code.length);\r\n        }\r\n        symbolTable.addConstantUtf8(Constants.CODE);\r\n        // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,\r\n        // max_locals, code_length and attributes_count, plus the bytecode and the exception table.\r\n        size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);\r\n        if (stackMapTableEntries != null) {\r\n            boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\r\n            symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\");\r\n            // 6 header bytes and 2 bytes for number_of_entries.\r\n            size += 8 + stackMapTableEntries.length;\r\n        }\r\n        if (lineNumberTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);\r\n            // 6 header bytes and 2 bytes for line_number_table_length.\r\n            size += 8 + lineNumberTable.length;\r\n        }\r\n        if (localVariableTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);\r\n            // 6 header bytes and 2 bytes for local_variable_table_length.\r\n            size += 8 + localVariableTable.length;\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);\r\n            // 6 header bytes and 2 bytes for local_variable_type_table_length.\r\n            size += 8 + localVariableTypeTable.length;\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\r\n        }\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        symbolTable.addConstantUtf8(Constants.EXCEPTIONS);\r\n        size += 8 + 2 * numberOfExceptions;\r\n    }\r\n    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount);\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        size += AnnotationWriter.computeParameterAnnotationsSize(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount);\r\n    }\r\n    if (defaultValue != null) {\r\n        symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);\r\n        size += 6 + defaultValue.length;\r\n    }\r\n    if (parameters != null) {\r\n        symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);\r\n        // 6 header bytes and 1 byte for parameters_count.\r\n        size += 7 + parameters.length;\r\n    }\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}",
    "comment": "\n   * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the\n   * names of the attributes of this method in the constant pool.\n   *\n   * @return the size in bytes of the method_info JVMS structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\r\n * given ByteVector.\r\n *\r\n * @param output where the method_info structure must be put.\r\n */\r\nvoid putMethodInfo(final ByteVector output) {\r\n    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\r\n    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\r\n    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\r\n    // If this method_info must be copied from an existing one, copy it now and return early.\r\n    if (sourceOffset != 0) {\r\n        output.putByteArray(symbolTable.getSource().classFileBuffer, sourceOffset, sourceLength);\r\n        return;\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributeCount = 0;\r\n    if (code.length > 0) {\r\n        ++attributeCount;\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        ++attributeCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\r\n        ++attributeCount;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributeCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (defaultValue != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (parameters != null) {\r\n        ++attributeCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributeCount += firstAttribute.getAttributeCount();\r\n    }\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    output.putShort(attributeCount);\r\n    if (code.length > 0) {\r\n        // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and\r\n        // attributes_count, plus the bytecode and the exception table.\r\n        int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);\r\n        int codeAttributeCount = 0;\r\n        if (stackMapTableEntries != null) {\r\n            // 6 header bytes and 2 bytes for number_of_entries.\r\n            size += 8 + stackMapTableEntries.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lineNumberTable != null) {\r\n            // 6 header bytes and 2 bytes for line_number_table_length.\r\n            size += 8 + lineNumberTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (localVariableTable != null) {\r\n            // 6 header bytes and 2 bytes for local_variable_table_length.\r\n            size += 8 + localVariableTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            // 6 header bytes and 2 bytes for local_variable_type_table_length.\r\n            size += 8 + localVariableTypeTable.length;\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\r\n            ++codeAttributeCount;\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            size += lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\r\n            ++codeAttributeCount;\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            size += firstCodeAttribute.computeAttributesSize(symbolTable, code.data, code.length, maxStack, maxLocals);\r\n            codeAttributeCount += firstCodeAttribute.getAttributeCount();\r\n        }\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.CODE)).putInt(size).putShort(maxStack).putShort(maxLocals).putInt(code.length).putByteArray(code.data, 0, code.length);\r\n        Handler.putExceptionTable(firstHandler, output);\r\n        output.putShort(codeAttributeCount);\r\n        if (stackMapTableEntries != null) {\r\n            boolean useStackMapTable = symbolTable.getMajorVersion() >= Opcodes.V1_6;\r\n            output.putShort(symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : \"StackMap\")).putInt(2 + stackMapTableEntries.length).putShort(stackMapTableNumberOfEntries).putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);\r\n        }\r\n        if (lineNumberTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE)).putInt(2 + lineNumberTable.length).putShort(lineNumberTableLength).putByteArray(lineNumberTable.data, 0, lineNumberTable.length);\r\n        }\r\n        if (localVariableTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE)).putInt(2 + localVariableTable.length).putShort(localVariableTableLength).putByteArray(localVariableTable.data, 0, localVariableTable.length);\r\n        }\r\n        if (localVariableTypeTable != null) {\r\n            output.putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE)).putInt(2 + localVariableTypeTable.length).putShort(localVariableTypeTableLength).putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);\r\n        }\r\n        if (lastCodeRuntimeVisibleTypeAnnotation != null) {\r\n            lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);\r\n        }\r\n        if (lastCodeRuntimeInvisibleTypeAnnotation != null) {\r\n            lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);\r\n        }\r\n        if (firstCodeAttribute != null) {\r\n            firstCodeAttribute.putAttributes(symbolTable, code.data, code.length, maxStack, maxLocals, output);\r\n        }\r\n    }\r\n    if (numberOfExceptions > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS)).putInt(2 + 2 * numberOfExceptions).putShort(numberOfExceptions);\r\n        for (int exceptionIndex : exceptionIndexTable) {\r\n            output.putShort(exceptionIndex);\r\n        }\r\n    }\r\n    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (lastRuntimeVisibleParameterAnnotations != null) {\r\n        AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeVisibleParameterAnnotations, visibleAnnotableParameterCount == 0 ? lastRuntimeVisibleParameterAnnotations.length : visibleAnnotableParameterCount, output);\r\n    }\r\n    if (lastRuntimeInvisibleParameterAnnotations != null) {\r\n        AnnotationWriter.putParameterAnnotations(symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS), lastRuntimeInvisibleParameterAnnotations, invisibleAnnotableParameterCount == 0 ? lastRuntimeInvisibleParameterAnnotations.length : invisibleAnnotableParameterCount, output);\r\n    }\r\n    if (defaultValue != null) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT)).putInt(defaultValue.length).putByteArray(defaultValue.data, 0, defaultValue.length);\r\n    }\r\n    if (parameters != null) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS)).putInt(1 + parameters.length).putByte(parametersCount).putByteArray(parameters.data, 0, parameters.length);\r\n    }\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}",
    "comment": "\n   * Puts the content of the method_info JVMS structure generated by this MethodWriter into the\n   * given ByteVector.\n   *\n   * @param output where the method_info structure must be put.\n   "
  },
  {
    "entityId": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
    "entityType": "method",
    "code": "/**\r\n * Collects the attributes of this method into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n    attributePrototypes.addAttributes(firstCodeAttribute);\r\n}",
    "comment": "\n   * Collects the attributes of this method into the given set of attribute prototypes.\n   *\n   * @param attributePrototypes a set of attribute prototypes.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
    "entityType": "class",
    "code": "/**\r\n * The encoder to test.\r\n */\r\nprotected final E encoder;\n/**\r\n * Construct a new {@code AbstractEncoderTestCase} for the given parameters.\r\n * @param encoder the encoder\r\n */\r\nprotected AbstractEncoderTests(E encoder) {\r\n    Assert.notNull(encoder, \"Encoder must not be null\");\r\n    this.encoder = encoder;\r\n}\n/**\r\n * Subclasses should implement this method to test {@link Encoder#canEncode}.\r\n */\r\n@Test\r\nprotected abstract void canEncode() throws Exception;\n/**\r\n * Subclasses should implement this method to test {@link Encoder#encode}, possibly using\r\n * {@link #testEncodeAll} or other helper methods.\r\n */\r\n@Test\r\nprotected abstract void encode() throws Exception;\n/**\r\n * Helper method that tests for a variety of encoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\r\n *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputClass the input class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testEncodeAll(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    testEncodeAll(input, ResolvableType.forClass(inputClass), null, null, stepConsumer);\r\n}\n/**\r\n * Helper method that tests for a variety of decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\r\n *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param <T> the output type\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n */\r\nprotected <T> void testEncodeAll(Publisher<? extends T> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    testEncode(input, inputType, mimeType, hints, stepConsumer);\r\n    testEncodeError(input, inputType, mimeType, hints);\r\n    testEncodeCancel(input, inputType, mimeType, hints);\r\n    testEncodeEmpty(inputType, mimeType, hints);\r\n}\n/**\r\n * Test a standard {@link Encoder#encode encode} scenario.\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputClass the input class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testEncode(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    testEncode(input, ResolvableType.forClass(inputClass), null, null, stepConsumer);\r\n}\n/**\r\n * Test a standard {@link Encoder#encode encode} scenario.\r\n *\r\n * @param <T> the output type\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n */\r\nprotected <T> void testEncode(Publisher<? extends T> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.FirstStep<DataBuffer> step = StepVerifier.create(result);\r\n    stepConsumer.accept(step);\r\n}\n/**\r\n * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.\r\n * This test method will feed the first element of the {@code input} stream to the encoder,\r\n * followed by an {@link InputException}.\r\n * The result is expected to contain one \"normal\" element, followed by the error.\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @see InputException\r\n */\r\nprotected void testEncodeError(Publisher<?> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    input = Flux.concat(Flux.from(input).take(1), Flux.error(new InputException()));\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).expectError(InputException.class).verify();\r\n}\n/**\r\n * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by a cancel signal.\r\n * The result is expected to contain one \"normal\" element.\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testEncodeCancel(Publisher<?> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).thenCancel().verify();\r\n}\n/**\r\n * Test a {@link Encoder#encode encode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testEncodeEmpty(ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<?> input = Flux.empty();\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}\n/**\r\n * Create a result consumer that expects the given bytes.\r\n * @param expected the expected bytes\r\n * @return a consumer that expects the given data buffer to be equal to {@code expected}\r\n */\r\nprotected final Consumer<DataBuffer> expectBytes(byte[] expected) {\r\n    return dataBuffer -> {\r\n        byte[] resultBytes = new byte[dataBuffer.readableByteCount()];\r\n        dataBuffer.read(resultBytes);\r\n        release(dataBuffer);\r\n        assertThat(resultBytes).isEqualTo(expected);\r\n    };\r\n}\n/**\r\n * Create a result consumer that expects the given string, using the UTF-8 encoding.\r\n * @param expected the expected string\r\n * @return a consumer that expects the given data buffer to be equal to {@code expected}\r\n */\r\nprotected Consumer<DataBuffer> expectString(String expected) {\r\n    return dataBuffer -> {\r\n        String actual = dataBuffer.toString(UTF_8);\r\n        release(dataBuffer);\r\n        assertThat(actual).isEqualToNormalizingNewlines(expected);\r\n    };\r\n}\n@SuppressWarnings(\"unchecked\")\r\nprivate <T> Encoder<T> encoder() {\r\n    return (Encoder<T>) this.encoder;\r\n}\n/**\r\n * Exception used in {@link #testEncodeError}.\r\n */\r\n@SuppressWarnings(\"serial\")\r\npublic static class InputException extends RuntimeException {\r\n}",
    "comment": "\n * Abstract base class for {@link Encoder} unit tests. Subclasses need to implement\n * {@link #canEncode()} and {@link #encode()}, possibly using the wide variety of\n * helper methods like {@link #testEncodeAll}.\n *\n * @author Arjen Poutsma\n * @since 5.1.3\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#canEncode()",
    "entityType": "method",
    "code": "/**\r\n * Subclasses should implement this method to test {@link Encoder#canEncode}.\r\n */\r\n@Test\r\nprotected abstract void canEncode() throws Exception;",
    "comment": "\n\t * Subclasses should implement this method to test {@link Encoder#canEncode}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encode()",
    "entityType": "method",
    "code": "/**\r\n * Subclasses should implement this method to test {@link Encoder#encode}, possibly using\r\n * {@link #testEncodeAll} or other helper methods.\r\n */\r\n@Test\r\nprotected abstract void encode() throws Exception;",
    "comment": "\n\t * Subclasses should implement this method to test {@link Encoder#encode}, possibly using\n\t * {@link #testEncodeAll} or other helper methods.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
    "entityType": "method",
    "code": "/**\r\n * Helper method that tests for a variety of encoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\r\n *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputClass the input class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testEncodeAll(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    testEncodeAll(input, ResolvableType.forClass(inputClass), null, null, stepConsumer);\r\n}",
    "comment": "\n\t * Helper method that tests for a variety of encoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\n\t *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputClass the input class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
    "entityType": "method",
    "code": "/**\r\n * Helper method that tests for a variety of decoding scenarios. This method\r\n * invokes:\r\n * <ul>\r\n *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\r\n *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\r\n *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\r\n * </ul>\r\n *\r\n * @param <T> the output type\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n */\r\nprotected <T> void testEncodeAll(Publisher<? extends T> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    testEncode(input, inputType, mimeType, hints, stepConsumer);\r\n    testEncodeError(input, inputType, mimeType, hints);\r\n    testEncodeCancel(input, inputType, mimeType, hints);\r\n    testEncodeEmpty(inputType, mimeType, hints);\r\n}",
    "comment": "\n\t * Helper method that tests for a variety of decoding scenarios. This method\n\t * invokes:\n\t * <ul>\n\t *     <li>{@link #testEncode(Publisher, ResolvableType, MimeType, Map, Consumer)}</li>\n\t *     <li>{@link #testEncodeError(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeCancel(Publisher, ResolvableType, MimeType, Map)}</li>\n\t *     <li>{@link #testEncodeEmpty(ResolvableType, MimeType, Map)}</li>\n\t * </ul>\n\t *\n\t * @param <T> the output type\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
    "entityType": "method",
    "code": "/**\r\n * Test a standard {@link Encoder#encode encode} scenario.\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputClass the input class\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n * @param <T> the output type\r\n */\r\nprotected <T> void testEncode(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    testEncode(input, ResolvableType.forClass(inputClass), null, null, stepConsumer);\r\n}",
    "comment": "\n\t * Test a standard {@link Encoder#encode encode} scenario.\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputClass the input class\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t * @param <T> the output type\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
    "entityType": "method",
    "code": "/**\r\n * Test a standard {@link Encoder#encode encode} scenario.\r\n *\r\n * @param <T> the output type\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\r\n */\r\nprotected <T> void testEncode(Publisher<? extends T> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) {\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.FirstStep<DataBuffer> step = StepVerifier.create(result);\r\n    stepConsumer.accept(step);\r\n}",
    "comment": "\n\t * Test a standard {@link Encoder#encode encode} scenario.\n\t *\n\t * @param <T> the output type\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @param stepConsumer a consumer to {@linkplain StepVerifier verify} the output\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.\r\n * This test method will feed the first element of the {@code input} stream to the encoder,\r\n * followed by an {@link InputException}.\r\n * The result is expected to contain one \"normal\" element, followed by the error.\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n * @see InputException\r\n */\r\nprotected void testEncodeError(Publisher<?> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    input = Flux.concat(Flux.from(input).take(1), Flux.error(new InputException()));\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).expectError(InputException.class).verify();\r\n}",
    "comment": "\n\t * Test a {@link Encoder#encode encode} scenario where the input stream contains an error.\n\t * This test method will feed the first element of the {@code input} stream to the encoder,\n\t * followed by an {@link InputException}.\n\t * The result is expected to contain one \"normal\" element, followed by the error.\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t * @see InputException\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.\r\n * This test method will feed the first element of the {@code input} stream to the decoder,\r\n * followed by a cancel signal.\r\n * The result is expected to contain one \"normal\" element.\r\n *\r\n * @param input the input to be provided to the encoder\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testEncodeCancel(Publisher<?> input, ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).thenCancel().verify();\r\n}",
    "comment": "\n\t * Test a {@link Encoder#encode encode} scenario where the input stream is canceled.\n\t * This test method will feed the first element of the {@code input} stream to the decoder,\n\t * followed by a cancel signal.\n\t * The result is expected to contain one \"normal\" element.\n\t *\n\t * @param input the input to be provided to the encoder\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Test a {@link Encoder#encode encode} scenario where the input stream is empty.\r\n * The output is expected to be empty as well.\r\n *\r\n * @param inputType the input type\r\n * @param mimeType the mime type to use for decoding. May be {@code null}.\r\n * @param hints the hints used for decoding. May be {@code null}.\r\n */\r\nprotected void testEncodeEmpty(ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\r\n    Flux<?> input = Flux.empty();\r\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\r\n    StepVerifier.create(result).verifyComplete();\r\n}",
    "comment": "\n\t * Test a {@link Encoder#encode encode} scenario where the input stream is empty.\n\t * The output is expected to be empty as well.\n\t *\n\t * @param inputType the input type\n\t * @param mimeType the mime type to use for decoding. May be {@code null}.\n\t * @param hints the hints used for decoding. May be {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectBytes(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Create a result consumer that expects the given bytes.\r\n * @param expected the expected bytes\r\n * @return a consumer that expects the given data buffer to be equal to {@code expected}\r\n */\r\nprotected final Consumer<DataBuffer> expectBytes(byte[] expected) {\r\n    return dataBuffer -> {\r\n        byte[] resultBytes = new byte[dataBuffer.readableByteCount()];\r\n        dataBuffer.read(resultBytes);\r\n        release(dataBuffer);\r\n        assertThat(resultBytes).isEqualTo(expected);\r\n    };\r\n}",
    "comment": "\n\t * Create a result consumer that expects the given bytes.\n\t * @param expected the expected bytes\n\t * @return a consumer that expects the given data buffer to be equal to {@code expected}\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectString(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a result consumer that expects the given string, using the UTF-8 encoding.\r\n * @param expected the expected string\r\n * @return a consumer that expects the given data buffer to be equal to {@code expected}\r\n */\r\nprotected Consumer<DataBuffer> expectString(String expected) {\r\n    return dataBuffer -> {\r\n        String actual = dataBuffer.toString(UTF_8);\r\n        release(dataBuffer);\r\n        assertThat(actual).isEqualToNormalizingNewlines(expected);\r\n    };\r\n}",
    "comment": "\n\t * Create a result consumer that expects the given string, using the UTF-8 encoding.\n\t * @param expected the expected string\n\t * @return a consumer that expects the given data buffer to be equal to {@code expected}\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encoder()",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nprivate <T> Encoder<T> encoder() {\r\n    return (Encoder<T>) this.encoder;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.codec.InputException",
    "entityType": "class",
    "code": "",
    "comment": "\n\t * Exception used in {@link #testEncodeError}.\n\t "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor",
    "entityType": "class",
    "code": "/**\r\n * The ASM API version implemented by this visitor. The value of this field must be one of {@link\r\n * Opcodes#ASM6} or {@link Opcodes#ASM7}.\r\n */\r\nprotected final int api;\n/**\r\n * The module visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n */\r\nprotected ModuleVisitor mv;\n/**\r\n * Constructs a new {@link ModuleVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM6}\r\n *     or {@link Opcodes#ASM7}.\r\n */\r\nprotected ModuleVisitor(final int api) {\r\n    this(api, null);\r\n}\n/**\r\n * Constructs a new {@link ModuleVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM6}\r\n *     or {@link Opcodes#ASM7}.\r\n * @param moduleVisitor the module visitor to which this visitor must delegate method calls. May\r\n *     be null.\r\n */\r\nprotected ModuleVisitor(final int api, final ModuleVisitor moduleVisitor) {\r\n    if (api != Opcodes.ASM9 && api != Opcodes.ASM8 && api != Opcodes.ASM7 && api != Opcodes.ASM6 && api != Opcodes.ASM5 && api != Opcodes.ASM4 && api != Opcodes.ASM10_EXPERIMENTAL) {\r\n        throw new IllegalArgumentException(\"Unsupported api \" + api);\r\n    }\r\n    // SPRING PATCH: no preview mode check for ASM experimental\r\n    this.api = api;\r\n    this.mv = moduleVisitor;\r\n}\n/**\r\n * Visit the main class of the current module.\r\n *\r\n * @param mainClass the internal name of the main class of the current module.\r\n */\r\npublic void visitMainClass(final String mainClass) {\r\n    if (mv != null) {\r\n        mv.visitMainClass(mainClass);\r\n    }\r\n}\n/**\r\n * Visit a package of the current module.\r\n *\r\n * @param packaze the internal name of a package.\r\n */\r\npublic void visitPackage(final String packaze) {\r\n    if (mv != null) {\r\n        mv.visitPackage(packaze);\r\n    }\r\n}\n/**\r\n * Visits a dependence of the current module.\r\n *\r\n * @param module the fully qualified name (using dots) of the dependence.\r\n * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code\r\n *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param version the module version at compile time, or {@literal null}.\r\n */\r\npublic void visitRequire(final String module, final int access, final String version) {\r\n    if (mv != null) {\r\n        mv.visitRequire(module, access, version);\r\n    }\r\n}\n/**\r\n * Visit an exported package of the current module.\r\n *\r\n * @param packaze the internal name of the exported package.\r\n * @param access the access flag of the exported package, valid values are among {@code\r\n *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param modules the fully qualified names (using dots) of the modules that can access the public\r\n *     classes of the exported package, or {@literal null}.\r\n */\r\npublic void visitExport(final String packaze, final int access, final String... modules) {\r\n    if (mv != null) {\r\n        mv.visitExport(packaze, access, modules);\r\n    }\r\n}\n/**\r\n * Visit an open package of the current module.\r\n *\r\n * @param packaze the internal name of the opened package.\r\n * @param access the access flag of the opened package, valid values are among {@code\r\n *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param modules the fully qualified names (using dots) of the modules that can use deep\r\n *     reflection to the classes of the open package, or {@literal null}.\r\n */\r\npublic void visitOpen(final String packaze, final int access, final String... modules) {\r\n    if (mv != null) {\r\n        mv.visitOpen(packaze, access, modules);\r\n    }\r\n}\n/**\r\n * Visit a service used by the current module. The name must be the internal name of an interface\r\n * or a class.\r\n *\r\n * @param service the internal name of the service.\r\n */\r\npublic void visitUse(final String service) {\r\n    if (mv != null) {\r\n        mv.visitUse(service);\r\n    }\r\n}\n/**\r\n * Visit an implementation of a service.\r\n *\r\n * @param service the internal name of the service.\r\n * @param providers the internal names of the implementations of the service (there is at least\r\n *     one provider).\r\n */\r\npublic void visitProvide(final String service, final String... providers) {\r\n    if (mv != null) {\r\n        mv.visitProvide(service, providers);\r\n    }\r\n}\n/**\r\n * Visits the end of the module. This method, which is the last one to be called, is used to\r\n * inform the visitor that everything have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}",
    "comment": "\n * A visitor to visit a Java module. The methods of this class must be called in the following\n * order: ( {@code visitMainClass} | ( {@code visitPackage} | {@code visitRequire} | {@code\n * visitExport} | {@code visitOpen} | {@code visitUse} | {@code visitProvide} )* ) {@code visitEnd}.\n *\n * @author Remi Forax\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Visit the main class of the current module.\r\n *\r\n * @param mainClass the internal name of the main class of the current module.\r\n */\r\npublic void visitMainClass(final String mainClass) {\r\n    if (mv != null) {\r\n        mv.visitMainClass(mainClass);\r\n    }\r\n}",
    "comment": "\n   * Visit the main class of the current module.\n   *\n   * @param mainClass the internal name of the main class of the current module.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
    "entityType": "method",
    "code": "/**\r\n * Visit a package of the current module.\r\n *\r\n * @param packaze the internal name of a package.\r\n */\r\npublic void visitPackage(final String packaze) {\r\n    if (mv != null) {\r\n        mv.visitPackage(packaze);\r\n    }\r\n}",
    "comment": "\n   * Visit a package of the current module.\n   *\n   * @param packaze the internal name of a package.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
    "entityType": "method",
    "code": "/**\r\n * Visits a dependence of the current module.\r\n *\r\n * @param module the fully qualified name (using dots) of the dependence.\r\n * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code\r\n *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param version the module version at compile time, or {@literal null}.\r\n */\r\npublic void visitRequire(final String module, final int access, final String version) {\r\n    if (mv != null) {\r\n        mv.visitRequire(module, access, version);\r\n    }\r\n}",
    "comment": "\n   * Visits a dependence of the current module.\n   *\n   * @param module the fully qualified name (using dots) of the dependence.\n   * @param access the access flag of the dependence among {@code ACC_TRANSITIVE}, {@code\n   *     ACC_STATIC_PHASE}, {@code ACC_SYNTHETIC} and {@code ACC_MANDATED}.\n   * @param version the module version at compile time, or {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
    "entityType": "method",
    "code": "/**\r\n * Visit an exported package of the current module.\r\n *\r\n * @param packaze the internal name of the exported package.\r\n * @param access the access flag of the exported package, valid values are among {@code\r\n *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param modules the fully qualified names (using dots) of the modules that can access the public\r\n *     classes of the exported package, or {@literal null}.\r\n */\r\npublic void visitExport(final String packaze, final int access, final String... modules) {\r\n    if (mv != null) {\r\n        mv.visitExport(packaze, access, modules);\r\n    }\r\n}",
    "comment": "\n   * Visit an exported package of the current module.\n   *\n   * @param packaze the internal name of the exported package.\n   * @param access the access flag of the exported package, valid values are among {@code\n   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\n   * @param modules the fully qualified names (using dots) of the modules that can access the public\n   *     classes of the exported package, or {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
    "entityType": "method",
    "code": "/**\r\n * Visit an open package of the current module.\r\n *\r\n * @param packaze the internal name of the opened package.\r\n * @param access the access flag of the opened package, valid values are among {@code\r\n *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\r\n * @param modules the fully qualified names (using dots) of the modules that can use deep\r\n *     reflection to the classes of the open package, or {@literal null}.\r\n */\r\npublic void visitOpen(final String packaze, final int access, final String... modules) {\r\n    if (mv != null) {\r\n        mv.visitOpen(packaze, access, modules);\r\n    }\r\n}",
    "comment": "\n   * Visit an open package of the current module.\n   *\n   * @param packaze the internal name of the opened package.\n   * @param access the access flag of the opened package, valid values are among {@code\n   *     ACC_SYNTHETIC} and {@code ACC_MANDATED}.\n   * @param modules the fully qualified names (using dots) of the modules that can use deep\n   *     reflection to the classes of the open package, or {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitUse(String)",
    "entityType": "method",
    "code": "/**\r\n * Visit a service used by the current module. The name must be the internal name of an interface\r\n * or a class.\r\n *\r\n * @param service the internal name of the service.\r\n */\r\npublic void visitUse(final String service) {\r\n    if (mv != null) {\r\n        mv.visitUse(service);\r\n    }\r\n}",
    "comment": "\n   * Visit a service used by the current module. The name must be the internal name of an interface\n   * or a class.\n   *\n   * @param service the internal name of the service.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Visit an implementation of a service.\r\n *\r\n * @param service the internal name of the service.\r\n * @param providers the internal names of the implementations of the service (there is at least\r\n *     one provider).\r\n */\r\npublic void visitProvide(final String service, final String... providers) {\r\n    if (mv != null) {\r\n        mv.visitProvide(service, providers);\r\n    }\r\n}",
    "comment": "\n   * Visit an implementation of a service.\n   *\n   * @param service the internal name of the service.\n   * @param providers the internal names of the implementations of the service (there is at least\n   *     one provider).\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleVisitor#visitEnd()",
    "entityType": "method",
    "code": "/**\r\n * Visits the end of the module. This method, which is the last one to be called, is used to\r\n * inform the visitor that everything have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}",
    "comment": "\n   * Visits the end of the module. This method, which is the last one to be called, is used to\n   * inform the visitor that everything have been visited.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter",
    "entityType": "class",
    "code": "/**\r\n * Where the constants used in this AnnotationWriter must be stored.\r\n */\r\nprivate final SymbolTable symbolTable;\n/**\r\n * The module_name_index field of the JVMS Module attribute.\r\n */\r\nprivate final int moduleNameIndex;\n/**\r\n * The module_flags field of the JVMS Module attribute.\r\n */\r\nprivate final int moduleFlags;\n/**\r\n * The module_version_index field of the JVMS Module attribute.\r\n */\r\nprivate final int moduleVersionIndex;\n/**\r\n * The requires_count field of the JVMS Module attribute.\r\n */\r\nprivate int requiresCount;\n/**\r\n * The binary content of the 'requires' array of the JVMS Module attribute.\r\n */\r\nprivate final ByteVector requires;\n/**\r\n * The exports_count field of the JVMS Module attribute.\r\n */\r\nprivate int exportsCount;\n/**\r\n * The binary content of the 'exports' array of the JVMS Module attribute.\r\n */\r\nprivate final ByteVector exports;\n/**\r\n * The opens_count field of the JVMS Module attribute.\r\n */\r\nprivate int opensCount;\n/**\r\n * The binary content of the 'opens' array of the JVMS Module attribute.\r\n */\r\nprivate final ByteVector opens;\n/**\r\n * The uses_count field of the JVMS Module attribute.\r\n */\r\nprivate int usesCount;\n/**\r\n * The binary content of the 'uses_index' array of the JVMS Module attribute.\r\n */\r\nprivate final ByteVector usesIndex;\n/**\r\n * The provides_count field of the JVMS Module attribute.\r\n */\r\nprivate int providesCount;\n/**\r\n * The binary content of the 'provides' array of the JVMS Module attribute.\r\n */\r\nprivate final ByteVector provides;\n/**\r\n * The provides_count field of the JVMS ModulePackages attribute.\r\n */\r\nprivate int packageCount;\n/**\r\n * The binary content of the 'package_index' array of the JVMS ModulePackages attribute.\r\n */\r\nprivate final ByteVector packageIndex;\n/**\r\n * The main_class_index field of the JVMS ModuleMainClass attribute, or 0.\r\n */\r\nprivate int mainClassIndex;\nModuleWriter(final SymbolTable symbolTable, final int name, final int access, final int version) {\r\n    super(/* latest api = */\r\n    Opcodes.ASM9);\r\n    this.symbolTable = symbolTable;\r\n    this.moduleNameIndex = name;\r\n    this.moduleFlags = access;\r\n    this.moduleVersionIndex = version;\r\n    this.requires = new ByteVector();\r\n    this.exports = new ByteVector();\r\n    this.opens = new ByteVector();\r\n    this.usesIndex = new ByteVector();\r\n    this.provides = new ByteVector();\r\n    this.packageIndex = new ByteVector();\r\n}\n@Override\r\npublic void visitMainClass(final String mainClass) {\r\n    this.mainClassIndex = symbolTable.addConstantClass(mainClass).index;\r\n}\n@Override\r\npublic void visitPackage(final String packaze) {\r\n    packageIndex.putShort(symbolTable.addConstantPackage(packaze).index);\r\n    packageCount++;\r\n}\n@Override\r\npublic void visitRequire(final String module, final int access, final String version) {\r\n    requires.putShort(symbolTable.addConstantModule(module).index).putShort(access).putShort(version == null ? 0 : symbolTable.addConstantUtf8(version));\r\n    requiresCount++;\r\n}\n@Override\r\npublic void visitExport(final String packaze, final int access, final String... modules) {\r\n    exports.putShort(symbolTable.addConstantPackage(packaze).index).putShort(access);\r\n    if (modules == null) {\r\n        exports.putShort(0);\r\n    } else {\r\n        exports.putShort(modules.length);\r\n        for (String module : modules) {\r\n            exports.putShort(symbolTable.addConstantModule(module).index);\r\n        }\r\n    }\r\n    exportsCount++;\r\n}\n@Override\r\npublic void visitOpen(final String packaze, final int access, final String... modules) {\r\n    opens.putShort(symbolTable.addConstantPackage(packaze).index).putShort(access);\r\n    if (modules == null) {\r\n        opens.putShort(0);\r\n    } else {\r\n        opens.putShort(modules.length);\r\n        for (String module : modules) {\r\n            opens.putShort(symbolTable.addConstantModule(module).index);\r\n        }\r\n    }\r\n    opensCount++;\r\n}\n@Override\r\npublic void visitUse(final String service) {\r\n    usesIndex.putShort(symbolTable.addConstantClass(service).index);\r\n    usesCount++;\r\n}\n@Override\r\npublic void visitProvide(final String service, final String... providers) {\r\n    provides.putShort(symbolTable.addConstantClass(service).index);\r\n    provides.putShort(providers.length);\r\n    for (String provider : providers) {\r\n        provides.putShort(symbolTable.addConstantClass(provider).index);\r\n    }\r\n    providesCount++;\r\n}\n@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}\n/**\r\n * Returns the number of Module, ModulePackages and ModuleMainClass attributes generated by this\r\n * ModuleWriter.\r\n *\r\n * @return the number of Module, ModulePackages and ModuleMainClass attributes (between 1 and 3).\r\n */\r\nint getAttributeCount() {\r\n    return 1 + (packageCount > 0 ? 1 : 0) + (mainClassIndex > 0 ? 1 : 0);\r\n}\n/**\r\n * Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\r\n * ModuleWriter. Also add the names of these attributes in the constant pool.\r\n *\r\n * @return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.\r\n */\r\nint computeAttributesSize() {\r\n    symbolTable.addConstantUtf8(Constants.MODULE);\r\n    // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts.\r\n    int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\r\n    if (packageCount > 0) {\r\n        symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES);\r\n        // 6 attribute header bytes, and 2 bytes for package_count.\r\n        size += 8 + packageIndex.length;\r\n    }\r\n    if (mainClassIndex > 0) {\r\n        symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS);\r\n        // 6 attribute header bytes, and 2 bytes for main_class_index.\r\n        size += 8;\r\n    }\r\n    return size;\r\n}\n/**\r\n * Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\r\n * in the given ByteVector.\r\n *\r\n * @param output where the attributes must be put.\r\n */\r\nvoid putAttributes(final ByteVector output) {\r\n    // 6 bytes for name, flags and version, and 5 * 2 bytes for counts.\r\n    int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\r\n    output.putShort(symbolTable.addConstantUtf8(Constants.MODULE)).putInt(moduleAttributeLength).putShort(moduleNameIndex).putShort(moduleFlags).putShort(moduleVersionIndex).putShort(requiresCount).putByteArray(requires.data, 0, requires.length).putShort(exportsCount).putByteArray(exports.data, 0, exports.length).putShort(opensCount).putByteArray(opens.data, 0, opens.length).putShort(usesCount).putByteArray(usesIndex.data, 0, usesIndex.length).putShort(providesCount).putByteArray(provides.data, 0, provides.length);\r\n    if (packageCount > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)).putInt(2 + packageIndex.length).putShort(packageCount).putByteArray(packageIndex.data, 0, packageIndex.length);\r\n    }\r\n    if (mainClassIndex > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)).putInt(2).putShort(mainClassIndex);\r\n    }\r\n}",
    "comment": "\n * A {@link ModuleVisitor} that generates the corresponding Module, ModulePackages and\n * ModuleMainClass attributes, as defined in the Java Virtual Machine Specification (JVMS).\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25\">JVMS\n *     4.7.25</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.26\">JVMS\n *     4.7.26</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.27\">JVMS\n *     4.7.27</a>\n * @author Remi Forax\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitMainClass(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitMainClass(final String mainClass) {\r\n    this.mainClassIndex = symbolTable.addConstantClass(mainClass).index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitPackage(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitPackage(final String packaze) {\r\n    packageIndex.putShort(symbolTable.addConstantPackage(packaze).index);\r\n    packageCount++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitRequire(String,int,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitRequire(final String module, final int access, final String version) {\r\n    requires.putShort(symbolTable.addConstantModule(module).index).putShort(access).putShort(version == null ? 0 : symbolTable.addConstantUtf8(version));\r\n    requiresCount++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitExport(String,int,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitExport(final String packaze, final int access, final String... modules) {\r\n    exports.putShort(symbolTable.addConstantPackage(packaze).index).putShort(access);\r\n    if (modules == null) {\r\n        exports.putShort(0);\r\n    } else {\r\n        exports.putShort(modules.length);\r\n        for (String module : modules) {\r\n            exports.putShort(symbolTable.addConstantModule(module).index);\r\n        }\r\n    }\r\n    exportsCount++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitOpen(String,int,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitOpen(final String packaze, final int access, final String... modules) {\r\n    opens.putShort(symbolTable.addConstantPackage(packaze).index).putShort(access);\r\n    if (modules == null) {\r\n        opens.putShort(0);\r\n    } else {\r\n        opens.putShort(modules.length);\r\n        for (String module : modules) {\r\n            opens.putShort(symbolTable.addConstantModule(module).index);\r\n        }\r\n    }\r\n    opensCount++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitUse(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitUse(final String service) {\r\n    usesIndex.putShort(symbolTable.addConstantClass(service).index);\r\n    usesCount++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitProvide(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitProvide(final String service, final String... providers) {\r\n    provides.putShort(symbolTable.addConstantClass(service).index);\r\n    provides.putShort(providers.length);\r\n    for (String provider : providers) {\r\n        provides.putShort(symbolTable.addConstantClass(provider).index);\r\n    }\r\n    providesCount++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#getAttributeCount()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of Module, ModulePackages and ModuleMainClass attributes generated by this\r\n * ModuleWriter.\r\n *\r\n * @return the number of Module, ModulePackages and ModuleMainClass attributes (between 1 and 3).\r\n */\r\nint getAttributeCount() {\r\n    return 1 + (packageCount > 0 ? 1 : 0) + (mainClassIndex > 0 ? 1 : 0);\r\n}",
    "comment": "\n   * Returns the number of Module, ModulePackages and ModuleMainClass attributes generated by this\n   * ModuleWriter.\n   *\n   * @return the number of Module, ModulePackages and ModuleMainClass attributes (between 1 and 3).\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\r\n * ModuleWriter. Also add the names of these attributes in the constant pool.\r\n *\r\n * @return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.\r\n */\r\nint computeAttributesSize() {\r\n    symbolTable.addConstantUtf8(Constants.MODULE);\r\n    // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts.\r\n    int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\r\n    if (packageCount > 0) {\r\n        symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES);\r\n        // 6 attribute header bytes, and 2 bytes for package_count.\r\n        size += 8 + packageIndex.length;\r\n    }\r\n    if (mainClassIndex > 0) {\r\n        symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS);\r\n        // 6 attribute header bytes, and 2 bytes for main_class_index.\r\n        size += 8;\r\n    }\r\n    return size;\r\n}",
    "comment": "\n   * Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\n   * ModuleWriter. Also add the names of these attributes in the constant pool.\n   *\n   * @return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.\n   "
  },
  {
    "entityId": "org.springframework.asm.ModuleWriter#putAttributes(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\r\n * in the given ByteVector.\r\n *\r\n * @param output where the attributes must be put.\r\n */\r\nvoid putAttributes(final ByteVector output) {\r\n    // 6 bytes for name, flags and version, and 5 * 2 bytes for counts.\r\n    int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\r\n    output.putShort(symbolTable.addConstantUtf8(Constants.MODULE)).putInt(moduleAttributeLength).putShort(moduleNameIndex).putShort(moduleFlags).putShort(moduleVersionIndex).putShort(requiresCount).putByteArray(requires.data, 0, requires.length).putShort(exportsCount).putByteArray(exports.data, 0, exports.length).putShort(opensCount).putByteArray(opens.data, 0, opens.length).putShort(usesCount).putByteArray(usesIndex.data, 0, usesIndex.length).putShort(providesCount).putByteArray(provides.data, 0, provides.length);\r\n    if (packageCount > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)).putInt(2 + packageIndex.length).putShort(packageCount).putByteArray(packageIndex.data, 0, packageIndex.length);\r\n    }\r\n    if (mainClassIndex > 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)).putInt(2).putShort(mainClassIndex);\r\n    }\r\n}",
    "comment": "\n   * Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\n   * in the given ByteVector.\n   *\n   * @param output where the attributes must be put.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.env.MockPropertySource",
    "entityType": "class",
    "code": "/**\r\n * {@value} is the default name for {@link MockPropertySource} instances not\r\n * otherwise given an explicit name.\r\n * @see #MockPropertySource()\r\n * @see #MockPropertySource(String)\r\n */\r\npublic static final String MOCK_PROPERTIES_PROPERTY_SOURCE_NAME = \"mockProperties\";\n/**\r\n * Create a new {@code MockPropertySource} named {@value #MOCK_PROPERTIES_PROPERTY_SOURCE_NAME}\r\n * that will maintain its own internal {@link Properties} instance.\r\n */\r\npublic MockPropertySource() {\r\n    this(new Properties());\r\n}\n/**\r\n * Create a new {@code MockPropertySource} with the given name that will\r\n * maintain its own internal {@link Properties} instance.\r\n * @param name the {@linkplain #getName() name} of the property source\r\n */\r\npublic MockPropertySource(String name) {\r\n    this(name, new Properties());\r\n}\n/**\r\n * Create a new {@code MockPropertySource} named {@value #MOCK_PROPERTIES_PROPERTY_SOURCE_NAME}\r\n * and backed by the given {@link Properties} object.\r\n * @param properties the properties to use\r\n */\r\npublic MockPropertySource(Properties properties) {\r\n    this(MOCK_PROPERTIES_PROPERTY_SOURCE_NAME, properties);\r\n}\n/**\r\n * Create a new {@code MockPropertySource} with the given name and backed by the given\r\n * {@link Properties} object.\r\n * @param name the {@linkplain #getName() name} of the property source\r\n * @param properties the properties to use\r\n */\r\npublic MockPropertySource(String name, Properties properties) {\r\n    super(name, properties);\r\n}\n/**\r\n * Set the given property on the underlying {@link Properties} object.\r\n */\r\npublic void setProperty(String name, Object value) {\r\n    this.source.put(name, value);\r\n}\n/**\r\n * Convenient synonym for {@link #setProperty} that returns the current instance.\r\n * Useful for method chaining and fluent-style use.\r\n * @return this {@link MockPropertySource} instance\r\n */\r\npublic MockPropertySource withProperty(String name, Object value) {\r\n    setProperty(name, value);\r\n    return this;\r\n}",
    "comment": "\n * Simple {@link PropertySource} implementation for use in testing. Accepts\n * a user-provided {@link Properties} object, or if omitted during construction,\n * the implementation will initialize its own.\n *\n * The {@link #setProperty} and {@link #withProperty} methods are exposed for\n * convenience, for example:\n * <pre class=\"code\">\n * {@code\n *   PropertySource<?> source = new MockPropertySource().withProperty(\"foo\", \"bar\");\n * }\n * </pre>\n *\n * @author Chris Beams\n * @since 3.1\n * @see org.springframework.mock.env.MockEnvironment\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Set the given property on the underlying {@link Properties} object.\r\n */\r\npublic void setProperty(String name, Object value) {\r\n    this.source.put(name, value);\r\n}",
    "comment": "\n\t * Set the given property on the underlying {@link Properties} object.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Convenient synonym for {@link #setProperty} that returns the current instance.\r\n * Useful for method chaining and fluent-style use.\r\n * @return this {@link MockPropertySource} instance\r\n */\r\npublic MockPropertySource withProperty(String name, Object value) {\r\n    setProperty(name, value);\r\n    return this;\r\n}",
    "comment": "\n\t * Convenient synonym for {@link #setProperty} that returns the current instance.\n\t * Useful for method chaining and fluent-style use.\n\t * @return this {@link MockPropertySource} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.ide.IdeUtils",
    "entityType": "class",
    "code": "/**\r\n * Determine if the current code is running in the Eclipse IDE.\r\n */\r\npublic static boolean runningInEclipse() {\r\n    return StackWalker.getInstance().walk(stream -> stream.anyMatch(stackFrame -> stackFrame.getClassName().startsWith(\"org.eclipse.jdt\")));\r\n}",
    "comment": "\n * Test utilities related to IDEs.\n *\n * @author Sam Brannen\n * @since 6.2\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.ide.IdeUtils#runningInEclipse()",
    "entityType": "method",
    "code": "/**\r\n * Determine if the current code is running in the Eclipse IDE.\r\n */\r\npublic static boolean runningInEclipse() {\r\n    return StackWalker.getInstance().walk(stream -> stream.anyMatch(stackFrame -> stackFrame.getClassName().startsWith(\"org.eclipse.jdt\")));\r\n}",
    "comment": "\n\t * Determine if the current code is running in the Eclipse IDE.\n\t "
  },
  {
    "entityId": "org.springframework.asm.Opcodes",
    "entityType": "class",
    "code": "// ASM API versions.\r\nint ASM4 = 4 << 16 | 0 << 8;\nint ASM5 = 5 << 16 | 0 << 8;\nint ASM6 = 6 << 16 | 0 << 8;\nint ASM7 = 7 << 16 | 0 << 8;\nint ASM8 = 8 << 16 | 0 << 8;\nint ASM9 = 9 << 16 | 0 << 8;\n/**\r\n * <i>Experimental, use at your own risk. This field will be renamed when it becomes stable, this\r\n * will break existing code using it. Only code compiled with --enable-preview can use this.</i>\r\n * <p>SPRING PATCH: no preview mode check for ASM 10 experimental, enabling it by default.\r\n */\r\nint ASM10_EXPERIMENTAL = 1 << 24 | 10 << 16 | 0 << 8;\n/*\r\n   * Internal flags used to redirect calls to deprecated methods. For instance, if a visitOldStuff\r\n   * method in API_OLD is deprecated and replaced with visitNewStuff in API_NEW, then the\r\n   * redirection should be done as follows:\r\n   *\r\n   * <pre>\r\n   * public class StuffVisitor {\r\n   *   ...\r\n   *\r\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {\r\n   *     // SOURCE_DEPRECATED means \"a call from a deprecated method using the old 'api' value\".\r\n   *     visitNewStuf(arg | (api &#60; API_NEW ? SOURCE_DEPRECATED : 0), ...);\r\n   *   }\r\n   *\r\n   *   public void visitNewStuff(int argAndSource, ...) {\r\n   *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {\r\n   *       visitOldStuff(argAndSource, ...);\r\n   *     } else {\r\n   *       int arg = argAndSource &#38; ~SOURCE_MASK;\r\n   *       [ do stuff ]\r\n   *     }\r\n   *   }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * <p>If 'api' is equal to API_NEW, there are two cases:\r\n   *\r\n   * <ul>\r\n   *   <li>call visitNewStuff: the redirection test is skipped and 'do stuff' is executed directly.\r\n   *   <li>call visitOldSuff: the source is not set to SOURCE_DEPRECATED before calling\r\n   *       visitNewStuff, but the redirection test is skipped anyway in visitNewStuff, which\r\n   *       directly executes 'do stuff'.\r\n   * </ul>\r\n   *\r\n   * <p>If 'api' is equal to API_OLD, there are two cases:\r\n   *\r\n   * <ul>\r\n   *   <li>call visitOldSuff: the source is set to SOURCE_DEPRECATED before calling visitNewStuff.\r\n   *       Because of this visitNewStuff does not redirect back to visitOldStuff, and instead\r\n   *       executes 'do stuff'.\r\n   *   <li>call visitNewStuff: the call is redirected to visitOldStuff because the source is 0.\r\n   *       visitOldStuff now sets the source to SOURCE_DEPRECATED and calls visitNewStuff back. This\r\n   *       time visitNewStuff does not redirect the call, and instead executes 'do stuff'.\r\n   * </ul>\r\n   *\r\n   * <h1>User subclasses</h1>\r\n   *\r\n   * <p>If a user subclass overrides one of these methods, there are only two cases: either 'api' is\r\n   * API_OLD and visitOldStuff is overridden (and visitNewStuff is not), or 'api' is API_NEW or\r\n   * more, and visitNewStuff is overridden (and visitOldStuff is not). Any other case is a user\r\n   * programming error.\r\n   *\r\n   * <p>If 'api' is equal to API_NEW, the class hierarchy is equivalent to\r\n   *\r\n   * <pre>\r\n   * public class StuffVisitor {\r\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }\r\n   *   public void visitNewStuff(int arg, ...) { [ do stuff ] }\r\n   * }\r\n   * class UserStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitNewStuff(int arg, ...) {\r\n   *     super.visitNewStuff(int arg, ...); // optional\r\n   *     [ do user stuff ]\r\n   *   }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff' and 'do\r\n   * user stuff' will be executed, in this order.\r\n   *\r\n   * <p>If 'api' is equal to API_OLD, the class hierarchy is equivalent to\r\n   *\r\n   * <pre>\r\n   * public class StuffVisitor {\r\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {\r\n   *     visitNewStuff(arg | SOURCE_DEPRECATED, ...);\r\n   *   }\r\n   *   public void visitNewStuff(int argAndSource...) {\r\n   *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {\r\n   *       visitOldStuff(argAndSource, ...);\r\n   *     } else {\r\n   *       int arg = argAndSource &#38; ~SOURCE_MASK;\r\n   *       [ do stuff ]\r\n   *     }\r\n   *   }\r\n   * }\r\n   * class UserStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitOldStuff(int arg, ...) {\r\n   *     super.visitOldStuff(int arg, ...); // optional\r\n   *     [ do user stuff ]\r\n   *   }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * <p>and there are two cases:\r\n   *\r\n   * <ul>\r\n   *   <li>call visitOldStuff: in the call to super.visitOldStuff, the source is set to\r\n   *       SOURCE_DEPRECATED and visitNewStuff is called. Here 'do stuff' is run because the source\r\n   *       was previously set to SOURCE_DEPRECATED, and execution eventually returns to\r\n   *       UserStuffVisitor.visitOldStuff, where 'do user stuff' is run.\r\n   *   <li>call visitNewStuff: the call is redirected to UserStuffVisitor.visitOldStuff because the\r\n   *       source is 0. Execution continues as in the previous case, resulting in 'do stuff' and 'do\r\n   *       user stuff' being executed, in this order.\r\n   * </ul>\r\n   *\r\n   * <h1>ASM subclasses</h1>\r\n   *\r\n   * <p>In ASM packages, subclasses of StuffVisitor can typically be sub classed again by the user,\r\n   * and can be used with API_OLD or API_NEW. Because of this, if such a subclass must override\r\n   * visitNewStuff, it must do so in the following way (and must not override visitOldStuff):\r\n   *\r\n   * <pre>\r\n   * public class AsmStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitNewStuff(int argAndSource, ...) {\r\n   *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {\r\n   *       super.visitNewStuff(argAndSource, ...);\r\n   *       return;\r\n   *     }\r\n   *     super.visitNewStuff(argAndSource, ...); // optional\r\n   *     int arg = argAndSource &#38; ~SOURCE_MASK;\r\n   *     [ do other stuff ]\r\n   *   }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * <p>If a user class extends this with 'api' equal to API_NEW, the class hierarchy is equivalent\r\n   * to\r\n   *\r\n   * <pre>\r\n   * public class StuffVisitor {\r\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }\r\n   *   public void visitNewStuff(int arg, ...) { [ do stuff ] }\r\n   * }\r\n   * public class AsmStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitNewStuff(int arg, ...) {\r\n   *     super.visitNewStuff(arg, ...);\r\n   *     [ do other stuff ]\r\n   *   }\r\n   * }\r\n   * class UserStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitNewStuff(int arg, ...) {\r\n   *     super.visitNewStuff(int arg, ...);\r\n   *     [ do user stuff ]\r\n   *   }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do\r\n   * other stuff' and 'do user stuff' will be executed, in this order. If, on the other hand, a user\r\n   * class extends AsmStuffVisitor with 'api' equal to API_OLD, the class hierarchy is equivalent to\r\n   *\r\n   * <pre>\r\n   * public class StuffVisitor {\r\n   *   &#64;Deprecated public void visitOldStuff(int arg, ...) {\r\n   *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);\r\n   *   }\r\n   *   public void visitNewStuff(int argAndSource, ...) {\r\n   *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {\r\n   *       visitOldStuff(argAndSource, ...);\r\n   *     } else {\r\n   *       int arg = argAndSource &#38; ~SOURCE_MASK;\r\n   *       [ do stuff ]\r\n   *     }\r\n   *   }\r\n   * }\r\n   * public class AsmStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitNewStuff(int argAndSource, ...) {\r\n   *     if ((argAndSource &#38; SOURCE_DEPRECATED) == 0) {\r\n   *       super.visitNewStuff(argAndSource, ...);\r\n   *       return;\r\n   *     }\r\n   *     super.visitNewStuff(argAndSource, ...); // optional\r\n   *     int arg = argAndSource &#38; ~SOURCE_MASK;\r\n   *     [ do other stuff ]\r\n   *   }\r\n   * }\r\n   * class UserStuffVisitor extends StuffVisitor {\r\n   *   &#64;Override public void visitOldStuff(int arg, ...) {\r\n   *     super.visitOldStuff(arg, ...);\r\n   *     [ do user stuff ]\r\n   *   }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * <p>and, here again, whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do other\r\n   * stuff' and 'do user stuff' will be executed, in this order (exercise left to the reader).\r\n   *\r\n   * <h1>Notes</h1>\r\n   *\r\n   * <ul>\r\n   *   <li>the SOURCE_DEPRECATED flag is set only if 'api' is API_OLD, just before calling\r\n   *       visitNewStuff. By hypothesis, this method is not overridden by the user. Therefore, user\r\n   *       classes can never see this flag. Only ASM subclasses must take care of extracting the\r\n   *       actual argument value by clearing the source flags.\r\n   *   <li>because the SOURCE_DEPRECATED flag is immediately cleared in the caller, the caller can\r\n   *       call visitOldStuff or visitNewStuff (in 'do stuff' and 'do user stuff') on a delegate\r\n   *       visitor without any risks (breaking the redirection logic, \"leaking\" the flag, etc).\r\n   *   <li>all the scenarios discussed above are unit tested in MethodVisitorTest.\r\n   * </ul>\r\n   */\r\nint SOURCE_DEPRECATED = 0x100;\nint SOURCE_MASK = SOURCE_DEPRECATED;\n// Java ClassFile versions (the minor version is stored in the 16 most significant bits, and the\r\n// major version in the 16 least significant bits).\r\nint V1_1 = 3 << 16 | 45;\nint V1_2 = 0 << 16 | 46;\nint V1_3 = 0 << 16 | 47;\nint V1_4 = 0 << 16 | 48;\nint V1_5 = 0 << 16 | 49;\nint V1_6 = 0 << 16 | 50;\nint V1_7 = 0 << 16 | 51;\nint V1_8 = 0 << 16 | 52;\nint V9 = 0 << 16 | 53;\nint V10 = 0 << 16 | 54;\nint V11 = 0 << 16 | 55;\nint V12 = 0 << 16 | 56;\nint V13 = 0 << 16 | 57;\nint V14 = 0 << 16 | 58;\nint V15 = 0 << 16 | 59;\nint V16 = 0 << 16 | 60;\nint V17 = 0 << 16 | 61;\nint V18 = 0 << 16 | 62;\nint V19 = 0 << 16 | 63;\nint V20 = 0 << 16 | 64;\nint V21 = 0 << 16 | 65;\nint V22 = 0 << 16 | 66;\nint V23 = 0 << 16 | 67;\nint V24 = 0 << 16 | 68;\n/**\r\n * Version flag indicating that the class is using 'preview' features.\r\n *\r\n * <p>{@code version & V_PREVIEW == V_PREVIEW} tests if a version is flagged with {@code\r\n * V_PREVIEW}.\r\n */\r\nint V_PREVIEW = 0xFFFF0000;\n// Access flags values, defined in\r\n// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.1-200-E.1\r\n// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.5-200-A.1\r\n// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6-200-A.1\r\n// - https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.25\r\n// class, field, method\r\nint ACC_PUBLIC = 0x0001;\n// class, field, method\r\nint ACC_PRIVATE = 0x0002;\n// class, field, method\r\nint ACC_PROTECTED = 0x0004;\n// field, method\r\nint ACC_STATIC = 0x0008;\n// class, field, method, parameter\r\nint ACC_FINAL = 0x0010;\n// class\r\nint ACC_SUPER = 0x0020;\n// method\r\nint ACC_SYNCHRONIZED = 0x0020;\n// module\r\nint ACC_OPEN = 0x0020;\n// module requires\r\nint ACC_TRANSITIVE = 0x0020;\n// field\r\nint ACC_VOLATILE = 0x0040;\n// method\r\nint ACC_BRIDGE = 0x0040;\n// module requires\r\nint ACC_STATIC_PHASE = 0x0040;\n// method\r\nint ACC_VARARGS = 0x0080;\n// field\r\nint ACC_TRANSIENT = 0x0080;\n// method\r\nint ACC_NATIVE = 0x0100;\n// class\r\nint ACC_INTERFACE = 0x0200;\n// class, method\r\nint ACC_ABSTRACT = 0x0400;\n// method\r\nint ACC_STRICT = 0x0800;\n// class, field, method, parameter, module *\r\nint ACC_SYNTHETIC = 0x1000;\n// class\r\nint ACC_ANNOTATION = 0x2000;\n// class(?) field inner\r\nint ACC_ENUM = 0x4000;\n// field, method, parameter, module, module *\r\nint ACC_MANDATED = 0x8000;\n// class\r\nint ACC_MODULE = 0x8000;\n// ASM specific access flags.\r\n// WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard\r\n// access flags, and also to make sure that these flags are automatically filtered out when\r\n// written in class files (because access flags are stored using 16 bits only).\r\n// class\r\nint ACC_RECORD = 0x10000;\n// class, field, method\r\nint ACC_DEPRECATED = 0x20000;\n// Possible values for the type operand of the NEWARRAY instruction.\r\n// See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.newarray.\r\nint T_BOOLEAN = 4;\nint T_CHAR = 5;\nint T_FLOAT = 6;\nint T_DOUBLE = 7;\nint T_BYTE = 8;\nint T_SHORT = 9;\nint T_INT = 10;\nint T_LONG = 11;\n// Possible values for the reference_kind field of CONSTANT_MethodHandle_info structures.\r\n// See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4.8.\r\nint H_GETFIELD = 1;\nint H_GETSTATIC = 2;\nint H_PUTFIELD = 3;\nint H_PUTSTATIC = 4;\nint H_INVOKEVIRTUAL = 5;\nint H_INVOKESTATIC = 6;\nint H_INVOKESPECIAL = 7;\nint H_NEWINVOKESPECIAL = 8;\nint H_INVOKEINTERFACE = 9;\n// ASM specific stack map frame types, used in {@link ClassVisitor#visitFrame}.\r\n/**\r\n * An expanded frame. See {@link ClassReader#EXPAND_FRAMES}.\r\n */\r\nint F_NEW = -1;\n/**\r\n * A compressed frame with complete frame data.\r\n */\r\nint F_FULL = 0;\n/**\r\n * A compressed frame where locals are the same as the locals in the previous frame, except that\r\n * additional 1-3 locals are defined, and with an empty stack.\r\n */\r\nint F_APPEND = 1;\n/**\r\n * A compressed frame where locals are the same as the locals in the previous frame, except that\r\n * the last 1-3 locals are absent and with an empty stack.\r\n */\r\nint F_CHOP = 2;\n/**\r\n * A compressed frame with exactly the same locals as the previous frame and with an empty stack.\r\n */\r\nint F_SAME = 3;\n/**\r\n * A compressed frame with exactly the same locals as the previous frame and with a single value\r\n * on the stack.\r\n */\r\nint F_SAME1 = 4;\n// Standard stack map frame element types, used in {@link ClassVisitor#visitFrame}.\r\nInteger TOP = Frame.ITEM_TOP;\nInteger INTEGER = Frame.ITEM_INTEGER;\nInteger FLOAT = Frame.ITEM_FLOAT;\nInteger DOUBLE = Frame.ITEM_DOUBLE;\nInteger LONG = Frame.ITEM_LONG;\nInteger NULL = Frame.ITEM_NULL;\nInteger UNINITIALIZED_THIS = Frame.ITEM_UNINITIALIZED_THIS;\n// The JVM opcode values (with the MethodVisitor method name used to visit them in comment, and\r\n// where '-' means 'same method name as on the previous line').\r\n// See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html.\r\n// visitInsn\r\nint NOP = 0;\n// -\r\nint ACONST_NULL = 1;\n// -\r\nint ICONST_M1 = 2;\n// -\r\nint ICONST_0 = 3;\n// -\r\nint ICONST_1 = 4;\n// -\r\nint ICONST_2 = 5;\n// -\r\nint ICONST_3 = 6;\n// -\r\nint ICONST_4 = 7;\n// -\r\nint ICONST_5 = 8;\n// -\r\nint LCONST_0 = 9;\n// -\r\nint LCONST_1 = 10;\n// -\r\nint FCONST_0 = 11;\n// -\r\nint FCONST_1 = 12;\n// -\r\nint FCONST_2 = 13;\n// -\r\nint DCONST_0 = 14;\n// -\r\nint DCONST_1 = 15;\n// visitIntInsn\r\nint BIPUSH = 16;\n// -\r\nint SIPUSH = 17;\n// visitLdcInsn\r\nint LDC = 18;\n// visitVarInsn\r\nint ILOAD = 21;\n// -\r\nint LLOAD = 22;\n// -\r\nint FLOAD = 23;\n// -\r\nint DLOAD = 24;\n// -\r\nint ALOAD = 25;\n// visitInsn\r\nint IALOAD = 46;\n// -\r\nint LALOAD = 47;\n// -\r\nint FALOAD = 48;\n// -\r\nint DALOAD = 49;\n// -\r\nint AALOAD = 50;\n// -\r\nint BALOAD = 51;\n// -\r\nint CALOAD = 52;\n// -\r\nint SALOAD = 53;\n// visitVarInsn\r\nint ISTORE = 54;\n// -\r\nint LSTORE = 55;\n// -\r\nint FSTORE = 56;\n// -\r\nint DSTORE = 57;\n// -\r\nint ASTORE = 58;\n// visitInsn\r\nint IASTORE = 79;\n// -\r\nint LASTORE = 80;\n// -\r\nint FASTORE = 81;\n// -\r\nint DASTORE = 82;\n// -\r\nint AASTORE = 83;\n// -\r\nint BASTORE = 84;\n// -\r\nint CASTORE = 85;\n// -\r\nint SASTORE = 86;\n// -\r\nint POP = 87;\n// -\r\nint POP2 = 88;\n// -\r\nint DUP = 89;\n// -\r\nint DUP_X1 = 90;\n// -\r\nint DUP_X2 = 91;\n// -\r\nint DUP2 = 92;\n// -\r\nint DUP2_X1 = 93;\n// -\r\nint DUP2_X2 = 94;\n// -\r\nint SWAP = 95;\n// -\r\nint IADD = 96;\n// -\r\nint LADD = 97;\n// -\r\nint FADD = 98;\n// -\r\nint DADD = 99;\n// -\r\nint ISUB = 100;\n// -\r\nint LSUB = 101;\n// -\r\nint FSUB = 102;\n// -\r\nint DSUB = 103;\n// -\r\nint IMUL = 104;\n// -\r\nint LMUL = 105;\n// -\r\nint FMUL = 106;\n// -\r\nint DMUL = 107;\n// -\r\nint IDIV = 108;\n// -\r\nint LDIV = 109;\n// -\r\nint FDIV = 110;\n// -\r\nint DDIV = 111;\n// -\r\nint IREM = 112;\n// -\r\nint LREM = 113;\n// -\r\nint FREM = 114;\n// -\r\nint DREM = 115;\n// -\r\nint INEG = 116;\n// -\r\nint LNEG = 117;\n// -\r\nint FNEG = 118;\n// -\r\nint DNEG = 119;\n// -\r\nint ISHL = 120;\n// -\r\nint LSHL = 121;\n// -\r\nint ISHR = 122;\n// -\r\nint LSHR = 123;\n// -\r\nint IUSHR = 124;\n// -\r\nint LUSHR = 125;\n// -\r\nint IAND = 126;\n// -\r\nint LAND = 127;\n// -\r\nint IOR = 128;\n// -\r\nint LOR = 129;\n// -\r\nint IXOR = 130;\n// -\r\nint LXOR = 131;\n// visitIincInsn\r\nint IINC = 132;\n// visitInsn\r\nint I2L = 133;\n// -\r\nint I2F = 134;\n// -\r\nint I2D = 135;\n// -\r\nint L2I = 136;\n// -\r\nint L2F = 137;\n// -\r\nint L2D = 138;\n// -\r\nint F2I = 139;\n// -\r\nint F2L = 140;\n// -\r\nint F2D = 141;\n// -\r\nint D2I = 142;\n// -\r\nint D2L = 143;\n// -\r\nint D2F = 144;\n// -\r\nint I2B = 145;\n// -\r\nint I2C = 146;\n// -\r\nint I2S = 147;\n// -\r\nint LCMP = 148;\n// -\r\nint FCMPL = 149;\n// -\r\nint FCMPG = 150;\n// -\r\nint DCMPL = 151;\n// -\r\nint DCMPG = 152;\n// visitJumpInsn\r\nint IFEQ = 153;\n// -\r\nint IFNE = 154;\n// -\r\nint IFLT = 155;\n// -\r\nint IFGE = 156;\n// -\r\nint IFGT = 157;\n// -\r\nint IFLE = 158;\n// -\r\nint IF_ICMPEQ = 159;\n// -\r\nint IF_ICMPNE = 160;\n// -\r\nint IF_ICMPLT = 161;\n// -\r\nint IF_ICMPGE = 162;\n// -\r\nint IF_ICMPGT = 163;\n// -\r\nint IF_ICMPLE = 164;\n// -\r\nint IF_ACMPEQ = 165;\n// -\r\nint IF_ACMPNE = 166;\n// -\r\nint GOTO = 167;\n// -\r\nint JSR = 168;\n// visitVarInsn\r\nint RET = 169;\n// visiTableSwitchInsn\r\nint TABLESWITCH = 170;\n// visitLookupSwitch\r\nint LOOKUPSWITCH = 171;\n// visitInsn\r\nint IRETURN = 172;\n// -\r\nint LRETURN = 173;\n// -\r\nint FRETURN = 174;\n// -\r\nint DRETURN = 175;\n// -\r\nint ARETURN = 176;\n// -\r\nint RETURN = 177;\n// visitFieldInsn\r\nint GETSTATIC = 178;\n// -\r\nint PUTSTATIC = 179;\n// -\r\nint GETFIELD = 180;\n// -\r\nint PUTFIELD = 181;\n// visitMethodInsn\r\nint INVOKEVIRTUAL = 182;\n// -\r\nint INVOKESPECIAL = 183;\n// -\r\nint INVOKESTATIC = 184;\n// -\r\nint INVOKEINTERFACE = 185;\n// visitInvokeDynamicInsn\r\nint INVOKEDYNAMIC = 186;\n// visitTypeInsn\r\nint NEW = 187;\n// visitIntInsn\r\nint NEWARRAY = 188;\n// visitTypeInsn\r\nint ANEWARRAY = 189;\n// visitInsn\r\nint ARRAYLENGTH = 190;\n// -\r\nint ATHROW = 191;\n// visitTypeInsn\r\nint CHECKCAST = 192;\n// -\r\nint INSTANCEOF = 193;\n// visitInsn\r\nint MONITORENTER = 194;\n// -\r\nint MONITOREXIT = 195;\n// visitMultiANewArrayInsn\r\nint MULTIANEWARRAY = 197;\n// visitJumpInsn\r\nint IFNULL = 198;\n// -\r\nint IFNONNULL = 199;",
    "comment": " DontCheck(InterfaceIsType): can't be fixed (for backward binary compatibility)."
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
    "entityType": "class",
    "code": "private static BufferAllocator netty5OnHeapUnpooled;\nprivate static BufferAllocator netty5OffHeapUnpooled;\nprivate static BufferAllocator netty5OffHeapPooled;\nprivate static BufferAllocator netty5OnHeapPooled;\nprivate static UnpooledByteBufAllocator netty4OffHeapUnpooled;\nprivate static UnpooledByteBufAllocator netty4OnHeapUnpooled;\nprivate static PooledByteBufAllocator netty4OffHeapPooled;\nprivate static PooledByteBufAllocator netty4OnHeapPooled;\n@RegisterExtension\r\nAfterEachCallback leakDetector = context -> waitForDataBufferRelease(Duration.ofSeconds(2));\nprotected DataBufferFactory bufferFactory;\nprotected DataBuffer createDataBuffer(int capacity) {\r\n    return this.bufferFactory.allocateBuffer(capacity);\r\n}\nprotected DataBuffer stringBuffer(String value) {\r\n    return byteBuffer(value.getBytes(StandardCharsets.UTF_8));\r\n}\nprotected Mono<DataBuffer> deferStringBuffer(String value) {\r\n    return Mono.defer(() -> Mono.just(stringBuffer(value)));\r\n}\nprotected DataBuffer byteBuffer(byte[] value) {\r\n    DataBuffer buffer = this.bufferFactory.allocateBuffer(value.length);\r\n    buffer.write(value);\r\n    return buffer;\r\n}\nprotected void release(DataBuffer... buffers) {\r\n    Arrays.stream(buffers).forEach(DataBufferUtils::release);\r\n}\nprotected Consumer<DataBuffer> stringConsumer(String expected) {\r\n    return stringConsumer(expected, UTF_8);\r\n}\nprotected Consumer<DataBuffer> stringConsumer(String expected, Charset charset) {\r\n    return dataBuffer -> {\r\n        String value = dataBuffer.toString(charset);\r\n        DataBufferUtils.release(dataBuffer);\r\n        assertThat(value).isEqualTo(expected);\r\n    };\r\n}\n/**\r\n * Wait until allocations are at 0, or the given duration elapses.\r\n */\r\nprivate void waitForDataBufferRelease(Duration duration) throws InterruptedException {\r\n    Instant start = Instant.now();\r\n    while (true) {\r\n        try {\r\n            verifyAllocations();\r\n            break;\r\n        } catch (AssertionError ex) {\r\n            if (Instant.now().isAfter(start.plus(duration))) {\r\n                throw ex;\r\n            }\r\n        }\r\n        Thread.sleep(50);\r\n    }\r\n}\nprivate void verifyAllocations() {\r\n    if (this.bufferFactory instanceof NettyDataBufferFactory) {\r\n        ByteBufAllocator allocator = ((NettyDataBufferFactory) this.bufferFactory).getByteBufAllocator();\r\n        if (allocator instanceof PooledByteBufAllocator) {\r\n            Instant start = Instant.now();\r\n            while (true) {\r\n                PooledByteBufAllocatorMetric metric = ((PooledByteBufAllocator) allocator).metric();\r\n                long total = getAllocations(metric.directArenas()) + getAllocations(metric.heapArenas());\r\n                if (total == 0) {\r\n                    return;\r\n                }\r\n                if (Instant.now().isBefore(start.plus(Duration.ofSeconds(5)))) {\r\n                    try {\r\n                        Thread.sleep(50);\r\n                    } catch (InterruptedException ex) {\r\n                        // ignore\r\n                    }\r\n                    continue;\r\n                }\r\n                assertThat(total).as(\"ByteBuf Leak: \" + total + \" unreleased allocations\").isEqualTo(0);\r\n            }\r\n        }\r\n    }\r\n}\nprivate static long getAllocations(List<PoolArenaMetric> metrics) {\r\n    return metrics.stream().mapToLong(PoolArenaMetric::numActiveAllocations).sum();\r\n}\n@BeforeAll\r\n// PooledByteBufAllocator no longer supports tinyCacheSize.\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void createAllocators() {\r\n    netty4OnHeapUnpooled = new UnpooledByteBufAllocator(false);\r\n    netty4OffHeapUnpooled = new UnpooledByteBufAllocator(true);\r\n    netty4OnHeapPooled = new PooledByteBufAllocator(false, 1, 1, 4096, 4, 0, 0, 0, true);\r\n    netty4OffHeapPooled = new PooledByteBufAllocator(true, 1, 1, 4096, 4, 0, 0, 0, true);\r\n    netty5OnHeapUnpooled = BufferAllocator.onHeapUnpooled();\r\n    netty5OffHeapUnpooled = BufferAllocator.offHeapUnpooled();\r\n    netty5OnHeapPooled = BufferAllocator.onHeapPooled();\r\n    netty5OffHeapPooled = BufferAllocator.offHeapPooled();\r\n}\n@AfterAll\r\nstatic void closeAllocators() {\r\n    netty5OnHeapUnpooled.close();\r\n    netty5OffHeapUnpooled.close();\r\n    netty5OnHeapPooled.close();\r\n    netty5OffHeapPooled.close();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.METHOD)\r\n@ParameterizedTest\r\n@MethodSource(\"org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#dataBufferFactories()\")\r\npublic @interface ParameterizedDataBufferAllocatingTest {\r\n}\npublic static Stream<Arguments> dataBufferFactories() {\r\n    return Stream.of(// Netty 4\r\n    argumentSet(\"NettyDataBufferFactory - UnpooledByteBufAllocator - preferDirect = true\", new NettyDataBufferFactory(netty4OffHeapUnpooled)), argumentSet(\"NettyDataBufferFactory - UnpooledByteBufAllocator - preferDirect = false\", new NettyDataBufferFactory(netty4OnHeapUnpooled)), argumentSet(\"NettyDataBufferFactory - PooledByteBufAllocator - preferDirect = true\", new NettyDataBufferFactory(netty4OffHeapPooled)), argumentSet(\"NettyDataBufferFactory - PooledByteBufAllocator - preferDirect = false\", new NettyDataBufferFactory(netty4OnHeapPooled)), // Netty 5\r\n    argumentSet(\"Netty5DataBufferFactory - BufferAllocator.onHeapUnpooled()\", new Netty5DataBufferFactory(netty5OnHeapUnpooled)), argumentSet(\"Netty5DataBufferFactory - BufferAllocator.offHeapUnpooled()\", new Netty5DataBufferFactory(netty5OffHeapUnpooled)), argumentSet(\"Netty5DataBufferFactory - BufferAllocator.onHeapPooled()\", new Netty5DataBufferFactory(netty5OnHeapPooled)), argumentSet(\"Netty5DataBufferFactory - BufferAllocator.offHeapPooled()\", new Netty5DataBufferFactory(netty5OffHeapPooled)), // Default\r\n    argumentSet(\"DefaultDataBufferFactory - preferDirect = true\", new DefaultDataBufferFactory(true)), argumentSet(\"DefaultDataBufferFactory - preferDirect = false\", new DefaultDataBufferFactory(false)));\r\n}",
    "comment": "\n * Base class for tests that read or write data buffers with an extension to check\n * that allocated buffers have been released.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createDataBuffer(int)",
    "entityType": "method",
    "code": "protected DataBuffer createDataBuffer(int capacity) {\r\n    return this.bufferFactory.allocateBuffer(capacity);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
    "entityType": "method",
    "code": "protected DataBuffer stringBuffer(String value) {\r\n    return byteBuffer(value.getBytes(StandardCharsets.UTF_8));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#deferStringBuffer(String)",
    "entityType": "method",
    "code": "protected Mono<DataBuffer> deferStringBuffer(String value) {\r\n    return Mono.defer(() -> Mono.just(stringBuffer(value)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#byteBuffer(byte[])",
    "entityType": "method",
    "code": "protected DataBuffer byteBuffer(byte[] value) {\r\n    DataBuffer buffer = this.bufferFactory.allocateBuffer(value.length);\r\n    buffer.write(value);\r\n    return buffer;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#release(DataBuffer)",
    "entityType": "method",
    "code": "protected void release(DataBuffer... buffers) {\r\n    Arrays.stream(buffers).forEach(DataBufferUtils::release);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String)",
    "entityType": "method",
    "code": "protected Consumer<DataBuffer> stringConsumer(String expected) {\r\n    return stringConsumer(expected, UTF_8);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String,Charset)",
    "entityType": "method",
    "code": "protected Consumer<DataBuffer> stringConsumer(String expected, Charset charset) {\r\n    return dataBuffer -> {\r\n        String value = dataBuffer.toString(charset);\r\n        DataBufferUtils.release(dataBuffer);\r\n        assertThat(value).isEqualTo(expected);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#waitForDataBufferRelease(Duration)",
    "entityType": "method",
    "code": "/**\r\n * Wait until allocations are at 0, or the given duration elapses.\r\n */\r\nprivate void waitForDataBufferRelease(Duration duration) throws InterruptedException {\r\n    Instant start = Instant.now();\r\n    while (true) {\r\n        try {\r\n            verifyAllocations();\r\n            break;\r\n        } catch (AssertionError ex) {\r\n            if (Instant.now().isAfter(start.plus(duration))) {\r\n                throw ex;\r\n            }\r\n        }\r\n        Thread.sleep(50);\r\n    }\r\n}",
    "comment": "\n\t * Wait until allocations are at 0, or the given duration elapses.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#verifyAllocations()",
    "entityType": "method",
    "code": "private void verifyAllocations() {\r\n    if (this.bufferFactory instanceof NettyDataBufferFactory) {\r\n        ByteBufAllocator allocator = ((NettyDataBufferFactory) this.bufferFactory).getByteBufAllocator();\r\n        if (allocator instanceof PooledByteBufAllocator) {\r\n            Instant start = Instant.now();\r\n            while (true) {\r\n                PooledByteBufAllocatorMetric metric = ((PooledByteBufAllocator) allocator).metric();\r\n                long total = getAllocations(metric.directArenas()) + getAllocations(metric.heapArenas());\r\n                if (total == 0) {\r\n                    return;\r\n                }\r\n                if (Instant.now().isBefore(start.plus(Duration.ofSeconds(5)))) {\r\n                    try {\r\n                        Thread.sleep(50);\r\n                    } catch (InterruptedException ex) {\r\n                        // ignore\r\n                    }\r\n                    continue;\r\n                }\r\n                assertThat(total).as(\"ByteBuf Leak: \" + total + \" unreleased allocations\").isEqualTo(0);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#getAllocations(List<PoolArenaMetric>)",
    "entityType": "method",
    "code": "private static long getAllocations(List<PoolArenaMetric> metrics) {\r\n    return metrics.stream().mapToLong(PoolArenaMetric::numActiveAllocations).sum();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
    "entityType": "method",
    "code": "@BeforeAll\r\n// PooledByteBufAllocator no longer supports tinyCacheSize.\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void createAllocators() {\r\n    netty4OnHeapUnpooled = new UnpooledByteBufAllocator(false);\r\n    netty4OffHeapUnpooled = new UnpooledByteBufAllocator(true);\r\n    netty4OnHeapPooled = new PooledByteBufAllocator(false, 1, 1, 4096, 4, 0, 0, 0, true);\r\n    netty4OffHeapPooled = new PooledByteBufAllocator(true, 1, 1, 4096, 4, 0, 0, 0, true);\r\n    netty5OnHeapUnpooled = BufferAllocator.onHeapUnpooled();\r\n    netty5OffHeapUnpooled = BufferAllocator.offHeapUnpooled();\r\n    netty5OnHeapPooled = BufferAllocator.onHeapPooled();\r\n    netty5OffHeapPooled = BufferAllocator.offHeapPooled();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#closeAllocators()",
    "entityType": "method",
    "code": "@AfterAll\r\nstatic void closeAllocators() {\r\n    netty5OnHeapUnpooled.close();\r\n    netty5OffHeapUnpooled.close();\r\n    netty5OnHeapPooled.close();\r\n    netty5OffHeapPooled.close();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#dataBufferFactories()",
    "entityType": "method",
    "code": "public static Stream<Arguments> dataBufferFactories() {\r\n    return Stream.of(// Netty 4\r\n    argumentSet(\"NettyDataBufferFactory - UnpooledByteBufAllocator - preferDirect = true\", new NettyDataBufferFactory(netty4OffHeapUnpooled)), argumentSet(\"NettyDataBufferFactory - UnpooledByteBufAllocator - preferDirect = false\", new NettyDataBufferFactory(netty4OnHeapUnpooled)), argumentSet(\"NettyDataBufferFactory - PooledByteBufAllocator - preferDirect = true\", new NettyDataBufferFactory(netty4OffHeapPooled)), argumentSet(\"NettyDataBufferFactory - PooledByteBufAllocator - preferDirect = false\", new NettyDataBufferFactory(netty4OnHeapPooled)), // Netty 5\r\n    argumentSet(\"Netty5DataBufferFactory - BufferAllocator.onHeapUnpooled()\", new Netty5DataBufferFactory(netty5OnHeapUnpooled)), argumentSet(\"Netty5DataBufferFactory - BufferAllocator.offHeapUnpooled()\", new Netty5DataBufferFactory(netty5OffHeapUnpooled)), argumentSet(\"Netty5DataBufferFactory - BufferAllocator.onHeapPooled()\", new Netty5DataBufferFactory(netty5OnHeapPooled)), argumentSet(\"Netty5DataBufferFactory - BufferAllocator.offHeapPooled()\", new Netty5DataBufferFactory(netty5OffHeapPooled)), // Default\r\n    argumentSet(\"DefaultDataBufferFactory - preferDirect = true\", new DefaultDataBufferFactory(true)), argumentSet(\"DefaultDataBufferFactory - preferDirect = false\", new DefaultDataBufferFactory(false)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.RecordComponentVisitor",
    "entityType": "class",
    "code": "/**\r\n * The ASM API version implemented by this visitor. The value of this field must be one of {@link\r\n * Opcodes#ASM8} or {@link Opcodes#ASM9}.\r\n */\r\nprotected final int api;\n/**\r\n * The record visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n */\r\nprotected RecordComponentVisitor delegate;\n/**\r\n * Constructs a new {@link RecordComponentVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of {@link Opcodes#ASM8}\r\n *     or {@link Opcodes#ASM9}.\r\n */\r\nprotected RecordComponentVisitor(final int api) {\r\n    this(api, null);\r\n}\n/**\r\n * Constructs a new {@link RecordComponentVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be {@link Opcodes#ASM8}.\r\n * @param recordComponentVisitor the record component visitor to which this visitor must delegate\r\n *     method calls. May be null.\r\n */\r\nprotected RecordComponentVisitor(final int api, final RecordComponentVisitor recordComponentVisitor) {\r\n    if (api != Opcodes.ASM9 && api != Opcodes.ASM8 && api != Opcodes.ASM7 && api != Opcodes.ASM6 && api != Opcodes.ASM5 && api != Opcodes.ASM4 && api != Opcodes.ASM10_EXPERIMENTAL) {\r\n        throw new IllegalArgumentException(\"Unsupported api \" + api);\r\n    }\r\n    // SPRING PATCH: no preview mode check for ASM experimental\r\n    this.api = api;\r\n    this.delegate = recordComponentVisitor;\r\n}\n/**\r\n * The record visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the record visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic RecordComponentVisitor getDelegate() {\r\n    return delegate;\r\n}\n/**\r\n * Visits an annotation of the record component.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (delegate != null) {\r\n        return delegate.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits an annotation on a type in the record component signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\r\n *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\r\n *     {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (delegate != null) {\r\n        return delegate.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a non standard attribute of the record component.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (delegate != null) {\r\n        delegate.visitAttribute(attribute);\r\n    }\r\n}\n/**\r\n * Visits the end of the record component. This method, which is the last one to be called, is\r\n * used to inform the visitor that everything have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (delegate != null) {\r\n        delegate.visitEnd();\r\n    }\r\n}",
    "comment": "\n * A visitor to visit a record component. The methods of this class must be called in the following\n * order: ( {@code visitAnnotation} | {@code visitTypeAnnotation} | {@code visitAttribute} )* {@code\n * visitEnd}.\n *\n * @author Remi Forax\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
    "entityType": "method",
    "code": "/**\r\n * The record visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the record visitor to which this visitor must delegate method calls, or {@literal\r\n *     null}.\r\n */\r\npublic RecordComponentVisitor getDelegate() {\r\n    return delegate;\r\n}",
    "comment": "\n   * The record visitor to which this visitor must delegate method calls. May be {@literal null}.\n   *\n   * @return the record visitor to which this visitor must delegate method calls, or {@literal\n   *     null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation of the record component.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (delegate != null) {\r\n        return delegate.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation of the record component.\n   *\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on a type in the record component signature.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\r\n *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\r\n *     {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (delegate != null) {\r\n        return delegate.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on a type in the record component signature.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\n   *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\n   *     {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentVisitor#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "/**\r\n * Visits a non standard attribute of the record component.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (delegate != null) {\r\n        delegate.visitAttribute(attribute);\r\n    }\r\n}",
    "comment": "\n   * Visits a non standard attribute of the record component.\n   *\n   * @param attribute an attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentVisitor#visitEnd()",
    "entityType": "method",
    "code": "/**\r\n * Visits the end of the record component. This method, which is the last one to be called, is\r\n * used to inform the visitor that everything have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (delegate != null) {\r\n        delegate.visitEnd();\r\n    }\r\n}",
    "comment": "\n   * Visits the end of the record component. This method, which is the last one to be called, is\n   * used to inform the visitor that everything have been visited.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
    "entityType": "class",
    "code": "/**\r\n * The data buffer factory.\r\n */\r\nprotected final LeakAwareDataBufferFactory bufferFactory = new LeakAwareDataBufferFactory();\n/**\r\n * Checks whether any of the data buffers created by {@link #bufferFactory} have not been\r\n * released, throwing an assertion error if so.\r\n */\r\n@AfterEach\r\nfinal void checkForLeaks() {\r\n    this.bufferFactory.checkForLeaks(Duration.ofSeconds(1));\r\n}",
    "comment": "\n * Abstract base class for unit tests that allocate data buffers via a {@link DataBufferFactory}.\n * After each unit test, this base class checks whether all created buffers have been released,\n * throwing an {@link AssertionError} if not.\n *\n * @author Arjen Poutsma\n * @since 5.1.3\n * @see LeakAwareDataBufferFactory\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
    "entityType": "method",
    "code": "/**\r\n * Checks whether any of the data buffers created by {@link #bufferFactory} have not been\r\n * released, throwing an assertion error if so.\r\n */\r\n@AfterEach\r\nfinal void checkForLeaks() {\r\n    this.bufferFactory.checkForLeaks(Duration.ofSeconds(1));\r\n}",
    "comment": "\n\t * Checks whether any of the data buffers created by {@link #bufferFactory} have not been\n\t * released, throwing an assertion error if so.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.DataBufferTestUtils",
    "entityType": "class",
    "code": "/**\r\n * Dump all the bytes in the given data buffer, and returns them as a byte array.\r\n * <p>Note that this method reads the entire buffer into the heap,  which might\r\n * consume a lot of memory.\r\n * @param buffer the data buffer to dump the bytes of\r\n * @return the bytes in the given data buffer\r\n */\r\npublic static byte[] dumpBytes(DataBuffer buffer) {\r\n    Assert.notNull(buffer, \"'buffer' must not be null\");\r\n    byte[] bytes = new byte[buffer.readableByteCount()];\r\n    buffer.read(bytes);\r\n    return bytes;\r\n}",
    "comment": "\n * Utility class for working with {@link DataBuffer}s in tests.\n *\n * <p>Note that this class is in the {@code test} tree of the project:\n * the methods contained herein are not suitable for production code bases.\n *\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.DataBufferTestUtils#dumpBytes(DataBuffer)",
    "entityType": "method",
    "code": "/**\r\n * Dump all the bytes in the given data buffer, and returns them as a byte array.\r\n * <p>Note that this method reads the entire buffer into the heap,  which might\r\n * consume a lot of memory.\r\n * @param buffer the data buffer to dump the bytes of\r\n * @return the bytes in the given data buffer\r\n */\r\npublic static byte[] dumpBytes(DataBuffer buffer) {\r\n    Assert.notNull(buffer, \"'buffer' must not be null\");\r\n    byte[] bytes = new byte[buffer.readableByteCount()];\r\n    buffer.read(bytes);\r\n    return bytes;\r\n}",
    "comment": "\n\t * Dump all the bytes in the given data buffer, and returns them as a byte array.\n\t * <p>Note that this method reads the entire buffer into the heap,  which might\n\t * consume a lot of memory.\n\t * @param buffer the data buffer to dump the bytes of\n\t * @return the bytes in the given data buffer\n\t "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter",
    "entityType": "class",
    "code": "/**\r\n * Where the constants used in this RecordComponentWriter must be stored.\r\n */\r\nprivate final SymbolTable symbolTable;\n// Note: fields are ordered as in the record_component_info structure, and those related to\r\n// attributes are ordered as in Section 4.7 of the JVMS.\r\n/**\r\n * The name_index field of the Record attribute.\r\n */\r\nprivate final int nameIndex;\n/**\r\n * The descriptor_index field of the Record attribute.\r\n */\r\nprivate final int descriptorIndex;\n/**\r\n * The signature_index field of the Signature attribute of this record component, or 0 if there is\r\n * no Signature attribute.\r\n */\r\nprivate int signatureIndex;\n/**\r\n * The last runtime visible annotation of this record component. The previous ones can be accessed\r\n * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleAnnotation;\n/**\r\n * The last runtime invisible annotation of this record component. The previous ones can be\r\n * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleAnnotation;\n/**\r\n * The last runtime visible type annotation of this record component. The previous ones can be\r\n * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleTypeAnnotation;\n/**\r\n * The last runtime invisible type annotation of this record component. The previous ones can be\r\n * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleTypeAnnotation;\n/**\r\n * The first non standard attribute of this record component. The next ones can be accessed with\r\n * the {@link Attribute#nextAttribute} field. May be {@literal null}.\r\n *\r\n * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\r\n * firstAttribute is actually the last attribute visited in {@link #visitAttribute(Attribute)}.\r\n * The {@link #putRecordComponentInfo(ByteVector)} method writes the attributes in the order\r\n * defined by this list, i.e. in the reverse order specified by the user.\r\n */\r\nprivate Attribute firstAttribute;\n/**\r\n * Constructs a new {@link RecordComponentWriter}.\r\n *\r\n * @param symbolTable where the constants used in this RecordComponentWriter must be stored.\r\n * @param name the record component name.\r\n * @param descriptor the record component descriptor (see {@link Type}).\r\n * @param signature the record component signature. May be {@literal null}.\r\n */\r\nRecordComponentWriter(final SymbolTable symbolTable, final String name, final String descriptor, final String signature) {\r\n    super(/* latest api = */\r\n    Opcodes.ASM9);\r\n    this.symbolTable = symbolTable;\r\n    this.nameIndex = symbolTable.addConstantUtf8(name);\r\n    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\r\n    if (signature != null) {\r\n        this.signatureIndex = symbolTable.addConstantUtf8(signature);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Implementation of the FieldVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}\n@Override\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    attribute.nextAttribute = firstAttribute;\r\n    firstAttribute = attribute;\r\n}\n@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the size of the record component JVMS structure generated by this\r\n * RecordComponentWriter. Also adds the names of the attributes of this record component in the\r\n * constant pool.\r\n *\r\n * @return the size in bytes of the record_component_info of the Record attribute.\r\n */\r\nint computeRecordComponentInfoSize() {\r\n    // name_index, descriptor_index and attributes_count fields use 6 bytes.\r\n    int size = 6;\r\n    size += Attribute.computeAttributesSize(symbolTable, 0, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}\n/**\r\n * Puts the content of the record component generated by this RecordComponentWriter into the given\r\n * ByteVector.\r\n *\r\n * @param output where the record_component_info structure must be put.\r\n */\r\nvoid putRecordComponentInfo(final ByteVector output) {\r\n    output.putShort(nameIndex).putShort(descriptorIndex);\r\n    // Compute and put the attributes_count field.\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributesCount = 0;\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n    }\r\n    output.putShort(attributesCount);\r\n    Attribute.putAttributes(symbolTable, 0, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}\n/**\r\n * Collects the attributes of this record component into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Implementation of the FieldVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    attribute.nextAttribute = firstAttribute;\r\n    firstAttribute = attribute;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#computeRecordComponentInfoSize()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the size of the record component JVMS structure generated by this\r\n * RecordComponentWriter. Also adds the names of the attributes of this record component in the\r\n * constant pool.\r\n *\r\n * @return the size in bytes of the record_component_info of the Record attribute.\r\n */\r\nint computeRecordComponentInfoSize() {\r\n    // name_index, descriptor_index and attributes_count fields use 6 bytes.\r\n    int size = 6;\r\n    size += Attribute.computeAttributesSize(symbolTable, 0, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}",
    "comment": "\n   * Returns the size of the record component JVMS structure generated by this\n   * RecordComponentWriter. Also adds the names of the attributes of this record component in the\n   * constant pool.\n   *\n   * @return the size in bytes of the record_component_info of the Record attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the content of the record component generated by this RecordComponentWriter into the given\r\n * ByteVector.\r\n *\r\n * @param output where the record_component_info structure must be put.\r\n */\r\nvoid putRecordComponentInfo(final ByteVector output) {\r\n    output.putShort(nameIndex).putShort(descriptorIndex);\r\n    // Compute and put the attributes_count field.\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributesCount = 0;\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n    }\r\n    output.putShort(attributesCount);\r\n    Attribute.putAttributes(symbolTable, 0, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}",
    "comment": "\n   * Puts the content of the record component generated by this RecordComponentWriter into the given\n   * ByteVector.\n   *\n   * @param output where the record_component_info structure must be put.\n   "
  },
  {
    "entityId": "org.springframework.asm.RecordComponentWriter#collectAttributePrototypes(Attribute.Set)",
    "entityType": "method",
    "code": "/**\r\n * Collects the attributes of this record component into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n}",
    "comment": "\n   * Collects the attributes of this record component into the given set of attribute prototypes.\n   *\n   * @param attributePrototypes a set of attribute prototypes.\n   "
  },
  {
    "entityId": "org.springframework.asm.SpringAsmInfo",
    "entityType": "class",
    "code": "/**\r\n * The ASM compatibility version for Spring's ASM visitor implementations:\r\n * currently {@link Opcodes#ASM10_EXPERIMENTAL}, as of Spring Framework 5.3.\r\n */\r\npublic static final int ASM_VERSION = Opcodes.ASM10_EXPERIMENTAL;",
    "comment": "\n * Utility class exposing constants related to Spring's internal repackaging\n * of the ASM bytecode library: currently based on ASM 9.x plus minor patches.\n *\n * <p>See <a href=\"package-summary.html\">package-level javadocs</a> for more\n * information on {@code org.springframework.asm}.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.2\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
    "entityType": "class",
    "code": "private final AssertionError leakError;\nprivate final LeakAwareDataBufferFactory dataBufferFactory;\nLeakAwareDataBuffer(DataBuffer delegate, LeakAwareDataBufferFactory dataBufferFactory) {\r\n    super(delegate);\r\n    Assert.notNull(dataBufferFactory, \"DataBufferFactory must not be null\");\r\n    this.dataBufferFactory = dataBufferFactory;\r\n    this.leakError = createLeakError(delegate);\r\n}\nprivate static AssertionError createLeakError(DataBuffer delegate) {\r\n    String message = String.format(\"DataBuffer leak detected: {%s} has not been released.%n\" + \"Stack trace of buffer allocation statement follows:\", delegate);\r\n    AssertionError result = new AssertionError(message);\r\n    // remove first four irrelevant stack trace elements\r\n    StackTraceElement[] oldTrace = result.getStackTrace();\r\n    StackTraceElement[] newTrace = new StackTraceElement[oldTrace.length - 4];\r\n    System.arraycopy(oldTrace, 4, newTrace, 0, oldTrace.length - 4);\r\n    result.setStackTrace(newTrace);\r\n    return result;\r\n}\nAssertionError leakError() {\r\n    return this.leakError;\r\n}\n@Override\r\npublic boolean isAllocated() {\r\n    DataBuffer delegate = dataBuffer();\r\n    return delegate instanceof PooledDataBuffer && ((PooledDataBuffer) delegate).isAllocated();\r\n}\n@Override\r\npublic PooledDataBuffer retain() {\r\n    DataBufferUtils.retain(dataBuffer());\r\n    return this;\r\n}\n@Override\r\npublic PooledDataBuffer touch(Object hint) {\r\n    DataBufferUtils.touch(dataBuffer(), hint);\r\n    return this;\r\n}\n@Override\r\npublic boolean release() {\r\n    DataBufferUtils.release(dataBuffer());\r\n    return isAllocated();\r\n}\n@Override\r\npublic LeakAwareDataBufferFactory factory() {\r\n    return this.dataBufferFactory;\r\n}\n@Override\r\npublic String toString() {\r\n    return String.format(\"LeakAwareDataBuffer (%s)\", dataBuffer());\r\n}",
    "comment": "\n * DataBuffer implementation created by {@link LeakAwareDataBufferFactory}.\n *\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#createLeakError(DataBuffer)",
    "entityType": "method",
    "code": "private static AssertionError createLeakError(DataBuffer delegate) {\r\n    String message = String.format(\"DataBuffer leak detected: {%s} has not been released.%n\" + \"Stack trace of buffer allocation statement follows:\", delegate);\r\n    AssertionError result = new AssertionError(message);\r\n    // remove first four irrelevant stack trace elements\r\n    StackTraceElement[] oldTrace = result.getStackTrace();\r\n    StackTraceElement[] newTrace = new StackTraceElement[oldTrace.length - 4];\r\n    System.arraycopy(oldTrace, 4, newTrace, 0, oldTrace.length - 4);\r\n    result.setStackTrace(newTrace);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#leakError()",
    "entityType": "method",
    "code": "AssertionError leakError() {\r\n    return this.leakError;\r\n}",
    "comment": ""
  }
]