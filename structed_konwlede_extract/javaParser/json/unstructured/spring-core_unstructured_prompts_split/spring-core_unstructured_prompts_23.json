[
  {
    "entityId": "org.springframework.util.SerializationUtilsTests#cloneException()",
    "entityType": "method",
    "code": "@Test\r\nvoid cloneException() {\r\n    IllegalArgumentException ex = new IllegalArgumentException(\"foo\");\r\n    assertThat(SerializationUtils.clone(ex)).hasMessage(\"foo\").isNotSameAs(ex);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests",
    "entityType": "class",
    "code": "private Map<String, String> delegate;\nprivate MultiValueMap<String, String> adapter;\n@BeforeEach\r\nvoid setUp() {\r\n    this.delegate = new LinkedHashMap<>();\r\n    this.delegate.put(\"foo\", \"bar\");\r\n    this.delegate.put(\"qux\", \"quux\");\r\n    this.adapter = new SingleToMultiValueMapAdapter<>(this.delegate);\r\n}\n@Test\r\nvoid getFirst() {\r\n    assertThat(this.adapter.getFirst(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(this.adapter.getFirst(\"qux\")).isEqualTo(\"quux\");\r\n    assertThat(this.adapter.getFirst(\"corge\")).isNull();\r\n}\n@Test\r\nvoid add() {\r\n    this.adapter.add(\"corge\", \"grault\");\r\n    assertThat(this.adapter.getFirst(\"corge\")).isEqualTo(\"grault\");\r\n    assertThat(this.delegate.get(\"corge\")).isEqualTo(\"grault\");\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.add(\"foo\", \"garply\"));\r\n}\n@Test\r\nvoid addAll() {\r\n    MultiValueMap<String, String> map = new LinkedMultiValueMap<>();\r\n    map.add(\"corge\", \"grault\");\r\n    this.adapter.addAll(map);\r\n    assertThat(this.adapter.getFirst(\"corge\")).isEqualTo(\"grault\");\r\n    assertThat(this.delegate.get(\"corge\")).isEqualTo(\"grault\");\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.addAll(map));\r\n}\n@Test\r\nvoid set() {\r\n    this.adapter.set(\"foo\", \"baz\");\r\n    assertThat(this.delegate.get(\"foo\")).isEqualTo(\"baz\");\r\n}\n@Test\r\nvoid setAll() {\r\n    this.adapter.setAll(Map.of(\"foo\", \"baz\"));\r\n    assertThat(this.delegate.get(\"foo\")).isEqualTo(\"baz\");\r\n}\n@Test\r\nvoid size() {\r\n    assertThat(this.adapter.size()).isEqualTo(this.delegate.size()).isEqualTo(2);\r\n}\n@Test\r\nvoid isEmpty() {\r\n    assertThat(this.adapter.isEmpty()).isFalse();\r\n    this.adapter = new SingleToMultiValueMapAdapter<>(Collections.emptyMap());\r\n    assertThat(this.adapter.isEmpty()).isTrue();\r\n}\n@Test\r\nvoid containsKey() {\r\n    assertThat(this.adapter.containsKey(\"foo\")).isTrue();\r\n    assertThat(this.adapter.containsKey(\"qux\")).isTrue();\r\n    assertThat(this.adapter.containsKey(\"corge\")).isFalse();\r\n}\n@Test\r\nvoid containsValue() {\r\n    assertThat(this.adapter.containsValue(List.of(\"bar\"))).isTrue();\r\n    assertThat(this.adapter.containsValue(List.of(\"quux\"))).isTrue();\r\n    assertThat(this.adapter.containsValue(List.of(\"corge\"))).isFalse();\r\n}\n@Test\r\nvoid get() {\r\n    assertThat(this.adapter.get(\"foo\")).isEqualTo(List.of(\"bar\"));\r\n    assertThat(this.adapter.get(\"qux\")).isEqualTo(List.of(\"quux\"));\r\n    assertThat(this.adapter.get(\"corge\")).isNull();\r\n}\n@Test\r\nvoid put() {\r\n    assertThat(this.adapter.put(\"foo\", List.of(\"baz\"))).containsExactly(\"bar\");\r\n    assertThat(this.adapter.put(\"qux\", Collections.emptyList())).containsExactly(\"quux\");\r\n    assertThat(this.adapter.put(\"grault\", List.of(\"garply\"))).isNull();\r\n    assertThat(this.delegate).containsExactly(entry(\"foo\", \"baz\"), entry(\"qux\", null), entry(\"grault\", \"garply\"));\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.put(\"foo\", List.of(\"bar\", \"baz\")));\r\n}\n@Test\r\nvoid remove() {\r\n    assertThat(this.adapter.remove(\"foo\")).isEqualTo(List.of(\"bar\"));\r\n    assertThat(this.adapter.containsKey(\"foo\")).isFalse();\r\n    assertThat(this.delegate.containsKey(\"foo\")).isFalse();\r\n}\n@Test\r\nvoid putAll() {\r\n    MultiValueMap<String, String> map = new LinkedMultiValueMap<>();\r\n    map.add(\"foo\", \"baz\");\r\n    map.add(\"qux\", null);\r\n    map.add(\"grault\", \"garply\");\r\n    this.adapter.putAll(map);\r\n    assertThat(this.delegate).containsExactly(entry(\"foo\", \"baz\"), entry(\"qux\", null), entry(\"grault\", \"garply\"));\r\n}\n@Test\r\nvoid clear() {\r\n    this.adapter.clear();\r\n    assertThat(this.adapter).isEmpty();\r\n    assertThat(this.delegate).isEmpty();\r\n}\n@Test\r\nvoid keySet() {\r\n    assertThat(this.adapter.keySet()).containsExactly(\"foo\", \"qux\");\r\n}\n@Test\r\nvoid values() {\r\n    assertThat(this.adapter.values()).containsExactly(List.of(\"bar\"), List.of(\"quux\"));\r\n}\n@Test\r\nvoid entrySet() {\r\n    assertThat(this.adapter.entrySet()).containsExactly(entry(\"foo\", List.of(\"bar\")), entry(\"qux\", List.of(\"quux\")));\r\n}\n@Test\r\nvoid forEach() {\r\n    MultiValueMap<String, String> seen = new LinkedMultiValueMap<>();\r\n    this.adapter.forEach(seen::put);\r\n    assertThat(seen).containsExactly(entry(\"foo\", List.of(\"bar\")), entry(\"qux\", List.of(\"quux\")));\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() {\r\n    this.delegate = new LinkedHashMap<>();\r\n    this.delegate.put(\"foo\", \"bar\");\r\n    this.delegate.put(\"qux\", \"quux\");\r\n    this.adapter = new SingleToMultiValueMapAdapter<>(this.delegate);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#getFirst()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFirst() {\r\n    assertThat(this.adapter.getFirst(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(this.adapter.getFirst(\"qux\")).isEqualTo(\"quux\");\r\n    assertThat(this.adapter.getFirst(\"corge\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
    "entityType": "method",
    "code": "@Test\r\nvoid add() {\r\n    this.adapter.add(\"corge\", \"grault\");\r\n    assertThat(this.adapter.getFirst(\"corge\")).isEqualTo(\"grault\");\r\n    assertThat(this.delegate.get(\"corge\")).isEqualTo(\"grault\");\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.add(\"foo\", \"garply\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#addAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid addAll() {\r\n    MultiValueMap<String, String> map = new LinkedMultiValueMap<>();\r\n    map.add(\"corge\", \"grault\");\r\n    this.adapter.addAll(map);\r\n    assertThat(this.adapter.getFirst(\"corge\")).isEqualTo(\"grault\");\r\n    assertThat(this.delegate.get(\"corge\")).isEqualTo(\"grault\");\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.addAll(map));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#set()",
    "entityType": "method",
    "code": "@Test\r\nvoid set() {\r\n    this.adapter.set(\"foo\", \"baz\");\r\n    assertThat(this.delegate.get(\"foo\")).isEqualTo(\"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#setAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid setAll() {\r\n    this.adapter.setAll(Map.of(\"foo\", \"baz\"));\r\n    assertThat(this.delegate.get(\"foo\")).isEqualTo(\"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() {\r\n    assertThat(this.adapter.size()).isEqualTo(this.delegate.size()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#isEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmpty() {\r\n    assertThat(this.adapter.isEmpty()).isFalse();\r\n    this.adapter = new SingleToMultiValueMapAdapter<>(Collections.emptyMap());\r\n    assertThat(this.adapter.isEmpty()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsKey() {\r\n    assertThat(this.adapter.containsKey(\"foo\")).isTrue();\r\n    assertThat(this.adapter.containsKey(\"qux\")).isTrue();\r\n    assertThat(this.adapter.containsKey(\"corge\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsValue() {\r\n    assertThat(this.adapter.containsValue(List.of(\"bar\"))).isTrue();\r\n    assertThat(this.adapter.containsValue(List.of(\"quux\"))).isTrue();\r\n    assertThat(this.adapter.containsValue(List.of(\"corge\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#get()",
    "entityType": "method",
    "code": "@Test\r\nvoid get() {\r\n    assertThat(this.adapter.get(\"foo\")).isEqualTo(List.of(\"bar\"));\r\n    assertThat(this.adapter.get(\"qux\")).isEqualTo(List.of(\"quux\"));\r\n    assertThat(this.adapter.get(\"corge\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
    "entityType": "method",
    "code": "@Test\r\nvoid put() {\r\n    assertThat(this.adapter.put(\"foo\", List.of(\"baz\"))).containsExactly(\"bar\");\r\n    assertThat(this.adapter.put(\"qux\", Collections.emptyList())).containsExactly(\"quux\");\r\n    assertThat(this.adapter.put(\"grault\", List.of(\"garply\"))).isNull();\r\n    assertThat(this.delegate).containsExactly(entry(\"foo\", \"baz\"), entry(\"qux\", null), entry(\"grault\", \"garply\"));\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.put(\"foo\", List.of(\"bar\", \"baz\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    assertThat(this.adapter.remove(\"foo\")).isEqualTo(List.of(\"bar\"));\r\n    assertThat(this.adapter.containsKey(\"foo\")).isFalse();\r\n    assertThat(this.delegate.containsKey(\"foo\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#putAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid putAll() {\r\n    MultiValueMap<String, String> map = new LinkedMultiValueMap<>();\r\n    map.add(\"foo\", \"baz\");\r\n    map.add(\"qux\", null);\r\n    map.add(\"grault\", \"garply\");\r\n    this.adapter.putAll(map);\r\n    assertThat(this.delegate).containsExactly(entry(\"foo\", \"baz\"), entry(\"qux\", null), entry(\"grault\", \"garply\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#clear()",
    "entityType": "method",
    "code": "@Test\r\nvoid clear() {\r\n    this.adapter.clear();\r\n    assertThat(this.adapter).isEmpty();\r\n    assertThat(this.delegate).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#keySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid keySet() {\r\n    assertThat(this.adapter.keySet()).containsExactly(\"foo\", \"qux\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
    "entityType": "method",
    "code": "@Test\r\nvoid values() {\r\n    assertThat(this.adapter.values()).containsExactly(List.of(\"bar\"), List.of(\"quux\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#entrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid entrySet() {\r\n    assertThat(this.adapter.entrySet()).containsExactly(entry(\"foo\", List.of(\"bar\")), entry(\"qux\", List.of(\"quux\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SingleToMultiValueMapAdapterTests#forEach()",
    "entityType": "method",
    "code": "@Test\r\nvoid forEach() {\r\n    MultiValueMap<String, String> seen = new LinkedMultiValueMap<>();\r\n    this.adapter.forEach(seen::put);\r\n    assertThat(seen).containsExactly(entry(\"foo\", List.of(\"bar\")), entry(\"qux\", List.of(\"quux\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StopWatchTests",
    "entityType": "class",
    "code": "private static final String ID = \"myId\";\nprivate static final String name1 = \"Task 1\";\nprivate static final String name2 = \"Task 2\";\nprivate static final long duration1 = 200;\nprivate static final long duration2 = 100;\n// private static final long fudgeFactor = 100;\r\nprivate final StopWatch stopWatch = new StopWatch(ID);\n@Test\r\nvoid failureToStartBeforeGettingTimings() {\r\n    assertThatIllegalStateException().isThrownBy(stopWatch::lastTaskInfo);\r\n}\n@Test\r\nvoid failureToStartBeforeStop() {\r\n    assertThatIllegalStateException().isThrownBy(stopWatch::stop);\r\n}\n@Test\r\nvoid rejectsStartTwice() {\r\n    stopWatch.start();\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    stopWatch.start();\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThatIllegalStateException().isThrownBy(stopWatch::start);\r\n}\n@Test\r\nvoid validUsage() throws Exception {\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    stopWatch.start(name1);\r\n    Thread.sleep(duration1);\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    /* Flaky StopWatch time assertions...\r\n\t\tassertThat(stopWatch.getLastTaskTimeNanos())\r\n\t\t\t\t.as(\"last task time in nanoseconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration1 - fudgeFactor))\r\n\t\t\t\t.isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration1 + fudgeFactor));\r\n\t\tassertThat(stopWatch.getTotalTimeMillis())\r\n\t\t\t\t.as(\"total time in milliseconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(duration1 - fudgeFactor)\r\n\t\t\t\t.isLessThanOrEqualTo(duration1 + fudgeFactor);\r\n\t\tassertThat(stopWatch.getTotalTimeSeconds())\r\n\t\t\t\t.as(\"total time in seconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo((duration1 - fudgeFactor) / 1000.0)\r\n\t\t\t\t.isLessThanOrEqualTo((duration1 + fudgeFactor) / 1000.0);\r\n\t\t*/\r\n    stopWatch.start(name2);\r\n    Thread.sleep(duration2);\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name2);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    /* Flaky StopWatch time assertions...\r\n\t\tassertThat(stopWatch.getLastTaskTimeNanos())\r\n\t\t\t\t.as(\"last task time in nanoseconds for task #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration2))\r\n\t\t\t\t.isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration2 + fudgeFactor));\r\n\t\tassertThat(stopWatch.getTotalTimeMillis())\r\n\t\t\t\t.as(\"total time in milliseconds for tasks #1 and #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(duration1 + duration2 - fudgeFactor)\r\n\t\t\t\t.isLessThanOrEqualTo(duration1 + duration2 + fudgeFactor);\r\n\t\tassertThat(stopWatch.getTotalTimeSeconds())\r\n\t\t\t\t.as(\"total time in seconds for task #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo((duration1 + duration2 - fudgeFactor) / 1000.0)\r\n\t\t\t\t.isLessThanOrEqualTo((duration1 + duration2 + fudgeFactor) / 1000.0);\r\n\t\t*/\r\n    assertThat(stopWatch.getTaskCount()).isEqualTo(2);\r\n    assertThat(stopWatch.prettyPrint()).contains(name1, name2);\r\n    assertThat(stopWatch.getTaskInfo()).extracting(TaskInfo::getTaskName).containsExactly(name1, name2);\r\n    assertThat(stopWatch.toString()).contains(ID, name1, name2);\r\n    assertThat(stopWatch.getId()).isEqualTo(ID);\r\n}\n@Test\r\nvoid validUsageDoesNotKeepTaskList() throws Exception {\r\n    stopWatch.setKeepTaskList(false);\r\n    stopWatch.start(name1);\r\n    Thread.sleep(duration1);\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);\r\n    stopWatch.stop();\r\n    stopWatch.start(name2);\r\n    Thread.sleep(duration2);\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name2);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.getTaskCount()).isEqualTo(2);\r\n    assertThat(stopWatch.prettyPrint()).contains(\"No task info kept\");\r\n    assertThat(stopWatch.toString()).doesNotContain(name1, name2);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(stopWatch::getTaskInfo).withMessage(\"Task info is not being kept!\");\r\n}",
    "comment": "\n * Tests for {@link StopWatch}.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
    "entityType": "method",
    "code": "@Test\r\nvoid failureToStartBeforeGettingTimings() {\r\n    assertThatIllegalStateException().isThrownBy(stopWatch::lastTaskInfo);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StopWatchTests#failureToStartBeforeStop()",
    "entityType": "method",
    "code": "@Test\r\nvoid failureToStartBeforeStop() {\r\n    assertThatIllegalStateException().isThrownBy(stopWatch::stop);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
    "entityType": "method",
    "code": "@Test\r\nvoid rejectsStartTwice() {\r\n    stopWatch.start();\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    stopWatch.start();\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThatIllegalStateException().isThrownBy(stopWatch::start);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StopWatchTests#validUsage()",
    "entityType": "method",
    "code": "@Test\r\nvoid validUsage() throws Exception {\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    stopWatch.start(name1);\r\n    Thread.sleep(duration1);\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    /* Flaky StopWatch time assertions...\r\n\t\tassertThat(stopWatch.getLastTaskTimeNanos())\r\n\t\t\t\t.as(\"last task time in nanoseconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration1 - fudgeFactor))\r\n\t\t\t\t.isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration1 + fudgeFactor));\r\n\t\tassertThat(stopWatch.getTotalTimeMillis())\r\n\t\t\t\t.as(\"total time in milliseconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(duration1 - fudgeFactor)\r\n\t\t\t\t.isLessThanOrEqualTo(duration1 + fudgeFactor);\r\n\t\tassertThat(stopWatch.getTotalTimeSeconds())\r\n\t\t\t\t.as(\"total time in seconds for task #1\")\r\n\t\t\t\t.isGreaterThanOrEqualTo((duration1 - fudgeFactor) / 1000.0)\r\n\t\t\t\t.isLessThanOrEqualTo((duration1 + fudgeFactor) / 1000.0);\r\n\t\t*/\r\n    stopWatch.start(name2);\r\n    Thread.sleep(duration2);\r\n    assertThat(stopWatch.isRunning()).isTrue();\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name2);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.isRunning()).isFalse();\r\n    /* Flaky StopWatch time assertions...\r\n\t\tassertThat(stopWatch.getLastTaskTimeNanos())\r\n\t\t\t\t.as(\"last task time in nanoseconds for task #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration2))\r\n\t\t\t\t.isLessThanOrEqualTo(TimeUnit.MILLISECONDS.toNanos(duration2 + fudgeFactor));\r\n\t\tassertThat(stopWatch.getTotalTimeMillis())\r\n\t\t\t\t.as(\"total time in milliseconds for tasks #1 and #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo(duration1 + duration2 - fudgeFactor)\r\n\t\t\t\t.isLessThanOrEqualTo(duration1 + duration2 + fudgeFactor);\r\n\t\tassertThat(stopWatch.getTotalTimeSeconds())\r\n\t\t\t\t.as(\"total time in seconds for task #2\")\r\n\t\t\t\t.isGreaterThanOrEqualTo((duration1 + duration2 - fudgeFactor) / 1000.0)\r\n\t\t\t\t.isLessThanOrEqualTo((duration1 + duration2 + fudgeFactor) / 1000.0);\r\n\t\t*/\r\n    assertThat(stopWatch.getTaskCount()).isEqualTo(2);\r\n    assertThat(stopWatch.prettyPrint()).contains(name1, name2);\r\n    assertThat(stopWatch.getTaskInfo()).extracting(TaskInfo::getTaskName).containsExactly(name1, name2);\r\n    assertThat(stopWatch.toString()).contains(ID, name1, name2);\r\n    assertThat(stopWatch.getId()).isEqualTo(ID);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StopWatchTests#validUsageDoesNotKeepTaskList()",
    "entityType": "method",
    "code": "@Test\r\nvoid validUsageDoesNotKeepTaskList() throws Exception {\r\n    stopWatch.setKeepTaskList(false);\r\n    stopWatch.start(name1);\r\n    Thread.sleep(duration1);\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name1);\r\n    stopWatch.stop();\r\n    stopWatch.start(name2);\r\n    Thread.sleep(duration2);\r\n    assertThat(stopWatch.currentTaskName()).isEqualTo(name2);\r\n    stopWatch.stop();\r\n    assertThat(stopWatch.getTaskCount()).isEqualTo(2);\r\n    assertThat(stopWatch.prettyPrint()).contains(\"No task info kept\");\r\n    assertThat(stopWatch.toString()).doesNotContain(name1, name2);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(stopWatch::getTaskInfo).withMessage(\"Task info is not being kept!\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests",
    "entityType": "class",
    "code": "private byte[] bytes = new byte[StreamUtils.BUFFER_SIZE + 10];\nprivate String string = \"\";\n@BeforeEach\r\nvoid setup() {\r\n    new Random().nextBytes(bytes);\r\n    while (string.length() < StreamUtils.BUFFER_SIZE + 10) {\r\n        string += UUID.randomUUID().toString();\r\n    }\r\n}\n@Test\r\nvoid copyToByteArray() throws Exception {\r\n    InputStream inputStream = new ByteArrayInputStream(bytes);\r\n    byte[] actual = StreamUtils.copyToByteArray(inputStream);\r\n    assertThat(actual).isEqualTo(bytes);\r\n}\n@Test\r\nvoid copyToString() throws Exception {\r\n    Charset charset = Charset.defaultCharset();\r\n    InputStream inputStream = new ByteArrayInputStream(string.getBytes(charset));\r\n    String actual = StreamUtils.copyToString(inputStream, charset);\r\n    assertThat(actual).isEqualTo(string);\r\n}\n@Test\r\nvoid copyBytes() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    StreamUtils.copy(bytes, out);\r\n    assertThat(out.toByteArray()).isEqualTo(bytes);\r\n}\n@Test\r\nvoid copyString() throws Exception {\r\n    Charset charset = Charset.defaultCharset();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    StreamUtils.copy(string, charset, out);\r\n    assertThat(out.toByteArray()).isEqualTo(string.getBytes(charset));\r\n}\n@Test\r\nvoid copyStream() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    StreamUtils.copy(new ByteArrayInputStream(bytes), out);\r\n    assertThat(out.toByteArray()).isEqualTo(bytes);\r\n}\n@Test\r\nvoid copyRangeWithinBuffer() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    StreamUtils.copyRange(in, out, 0, 100);\r\n    assertThat(in.available()).isEqualTo(bytes.length - 101);\r\n    assertThat(out.toByteArray()).isEqualTo(Arrays.copyOfRange(bytes, 0, 101));\r\n}\n@Test\r\nvoid copyRangeBeyondBuffer() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    StreamUtils.copyRange(in, out, 0, 8200);\r\n    assertThat(in.available()).isEqualTo(1);\r\n    assertThat(out.toByteArray()).isEqualTo(Arrays.copyOfRange(bytes, 0, 8201));\r\n}\n@Test\r\nvoid copyRangeBeyondAvailable() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    StreamUtils.copyRange(in, out, 0, 8300);\r\n    assertThat(in.available()).isEqualTo(0);\r\n    assertThat(out.toByteArray()).isEqualTo(Arrays.copyOfRange(bytes, 0, 8202));\r\n}\n@Test\r\nvoid nonClosingInputStream() throws Exception {\r\n    InputStream source = mock();\r\n    InputStream nonClosing = StreamUtils.nonClosing(source);\r\n    nonClosing.read();\r\n    nonClosing.read(bytes);\r\n    nonClosing.read(bytes, 1, 2);\r\n    nonClosing.close();\r\n    InOrder ordered = inOrder(source);\r\n    ordered.verify(source).read();\r\n    ordered.verify(source).read(bytes, 0, bytes.length);\r\n    ordered.verify(source).read(bytes, 1, 2);\r\n    ordered.verify(source, never()).close();\r\n}\n@Test\r\nvoid nonClosingOutputStream() throws Exception {\r\n    OutputStream source = mock();\r\n    OutputStream nonClosing = StreamUtils.nonClosing(source);\r\n    nonClosing.write(1);\r\n    nonClosing.write(bytes);\r\n    nonClosing.write(bytes, 1, 2);\r\n    nonClosing.close();\r\n    InOrder ordered = inOrder(source);\r\n    ordered.verify(source).write(1);\r\n    ordered.verify(source).write(bytes, 0, bytes.length);\r\n    ordered.verify(source).write(bytes, 1, 2);\r\n    ordered.verify(source, never()).close();\r\n}",
    "comment": "\n * Tests for {@link StreamUtils}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    new Random().nextBytes(bytes);\r\n    while (string.length() < StreamUtils.BUFFER_SIZE + 10) {\r\n        string += UUID.randomUUID().toString();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyToByteArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyToByteArray() throws Exception {\r\n    InputStream inputStream = new ByteArrayInputStream(bytes);\r\n    byte[] actual = StreamUtils.copyToByteArray(inputStream);\r\n    assertThat(actual).isEqualTo(bytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyToString()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyToString() throws Exception {\r\n    Charset charset = Charset.defaultCharset();\r\n    InputStream inputStream = new ByteArrayInputStream(string.getBytes(charset));\r\n    String actual = StreamUtils.copyToString(inputStream, charset);\r\n    assertThat(actual).isEqualTo(string);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyBytes()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyBytes() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    StreamUtils.copy(bytes, out);\r\n    assertThat(out.toByteArray()).isEqualTo(bytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyString()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyString() throws Exception {\r\n    Charset charset = Charset.defaultCharset();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    StreamUtils.copy(string, charset, out);\r\n    assertThat(out.toByteArray()).isEqualTo(string.getBytes(charset));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyStream()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyStream() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    StreamUtils.copy(new ByteArrayInputStream(bytes), out);\r\n    assertThat(out.toByteArray()).isEqualTo(bytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyRangeWithinBuffer()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyRangeWithinBuffer() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    StreamUtils.copyRange(in, out, 0, 100);\r\n    assertThat(in.available()).isEqualTo(bytes.length - 101);\r\n    assertThat(out.toByteArray()).isEqualTo(Arrays.copyOfRange(bytes, 0, 101));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyRangeBeyondBuffer()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyRangeBeyondBuffer() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    StreamUtils.copyRange(in, out, 0, 8200);\r\n    assertThat(in.available()).isEqualTo(1);\r\n    assertThat(out.toByteArray()).isEqualTo(Arrays.copyOfRange(bytes, 0, 8201));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#copyRangeBeyondAvailable()",
    "entityType": "method",
    "code": "@Test\r\nvoid copyRangeBeyondAvailable() throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    ByteArrayInputStream in = new ByteArrayInputStream(bytes);\r\n    StreamUtils.copyRange(in, out, 0, 8300);\r\n    assertThat(in.available()).isEqualTo(0);\r\n    assertThat(out.toByteArray()).isEqualTo(Arrays.copyOfRange(bytes, 0, 8202));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#nonClosingInputStream()",
    "entityType": "method",
    "code": "@Test\r\nvoid nonClosingInputStream() throws Exception {\r\n    InputStream source = mock();\r\n    InputStream nonClosing = StreamUtils.nonClosing(source);\r\n    nonClosing.read();\r\n    nonClosing.read(bytes);\r\n    nonClosing.read(bytes, 1, 2);\r\n    nonClosing.close();\r\n    InOrder ordered = inOrder(source);\r\n    ordered.verify(source).read();\r\n    ordered.verify(source).read(bytes, 0, bytes.length);\r\n    ordered.verify(source).read(bytes, 1, 2);\r\n    ordered.verify(source, never()).close();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StreamUtilsTests#nonClosingOutputStream()",
    "entityType": "method",
    "code": "@Test\r\nvoid nonClosingOutputStream() throws Exception {\r\n    OutputStream source = mock();\r\n    OutputStream nonClosing = StreamUtils.nonClosing(source);\r\n    nonClosing.write(1);\r\n    nonClosing.write(bytes);\r\n    nonClosing.write(bytes, 1, 2);\r\n    nonClosing.close();\r\n    InOrder ordered = inOrder(source);\r\n    ordered.verify(source).write(1);\r\n    ordered.verify(source).write(bytes, 0, bytes.length);\r\n    ordered.verify(source).write(bytes, 1, 2);\r\n    ordered.verify(source, never()).close();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassReader",
    "entityType": "class",
    "code": "/**\r\n * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed\r\n * nor visited.\r\n */\r\npublic static final int SKIP_CODE = 1;\n/**\r\n * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,\r\n * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set\r\n * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link\r\n * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link\r\n * MethodVisitor#visitParameter} are not called).\r\n */\r\npublic static final int SKIP_DEBUG = 2;\n/**\r\n * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes\r\n * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag\r\n * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames\r\n * that will be ignored and recomputed from scratch.\r\n */\r\npublic static final int SKIP_FRAMES = 4;\n/**\r\n * A flag to expand the stack map frames. By default stack map frames are visited in their\r\n * original format (i.e. \"expanded\" for classes whose version is less than V1_6, and \"compressed\"\r\n * for the other classes). If this flag is set, stack map frames are always visited in expanded\r\n * format (this option adds a decompression/compression step in ClassReader and ClassWriter which\r\n * degrades performance quite a lot).\r\n */\r\npublic static final int EXPAND_FRAMES = 8;\n/**\r\n * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode\r\n * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset\r\n * reserved for it is not sufficient to store the bytecode offset. In this case the jump\r\n * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes\r\n * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing\r\n * such instructions, in order to replace them with standard instructions. In addition, when this\r\n * flag is used, goto_w and jsr_w are <i>not</i> converted into goto and jsr, to make sure that\r\n * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a\r\n * goto_w in ClassWriter cannot occur.\r\n */\r\nstatic final int EXPAND_ASM_INSNS = 256;\n/**\r\n * The maximum size of array to allocate.\r\n */\r\nprivate static final int MAX_BUFFER_SIZE = 1024 * 1024;\n/**\r\n * The size of the temporary byte array used to read class input streams chunk by chunk.\r\n */\r\nprivate static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;\n/**\r\n * A byte array containing the JVMS ClassFile structure to be parsed.\r\n *\r\n * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will\r\n *     eventually be deleted.\r\n */\r\n@Deprecated\r\npublic final byte[] // DontCheck(MemberName): can't be renamed (for backward binary compatibility).\r\nb;\n/**\r\n * The offset in bytes of the ClassFile's access_flags field.\r\n */\r\npublic final int header;\n/**\r\n * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array\r\n * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally\r\n * not needed by class visitors.</i>\r\n *\r\n * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not\r\n * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct\r\n * ClassFile element offsets within this byte array.\r\n */\r\nfinal byte[] classFileBuffer;\n/**\r\n * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's\r\n * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is\r\n * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -\r\n * 1].\r\n */\r\nprivate final int[] cpInfoOffsets;\n/**\r\n * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids\r\n * multiple parsing of a given CONSTANT_Utf8 constant pool item.\r\n */\r\nprivate final String[] constantUtf8Values;\n/**\r\n * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This\r\n * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.\r\n */\r\nprivate final ConstantDynamic[] constantDynamicValues;\n/**\r\n * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array\r\n * (in the BootstrapMethods attribute).\r\n *\r\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\r\n *     4.7.23</a>\r\n */\r\nprivate final int[] bootstrapMethodOffsets;\n/**\r\n * A conservative estimate of the maximum length of the strings contained in the constant pool of\r\n * the class.\r\n */\r\nprivate final int maxStringLength;\n// -----------------------------------------------------------------------------------------------\r\n// Constructors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new {@link ClassReader} object.\r\n *\r\n * @param classFile the JVMS ClassFile structure to be read.\r\n */\r\npublic ClassReader(final byte[] classFile) {\r\n    this(classFile, 0, classFile.length);\r\n}\n/**\r\n * Constructs a new {@link ClassReader} object.\r\n *\r\n * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\r\n * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\r\n * @param classFileLength the length in bytes of the ClassFile to be read.\r\n */\r\npublic ClassReader(final byte[] classFileBuffer, final int classFileOffset, final int classFileLength) {\r\n    // NOPMD(UnusedFormalParameter) used for backward compatibility.\r\n    this(classFileBuffer, classFileOffset, /* checkClassVersion= */\r\n    true);\r\n}\n/**\r\n * Constructs a new {@link ClassReader} object. <i>This internal constructor must not be exposed\r\n * as a public API</i>.\r\n *\r\n * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.\r\n * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.\r\n * @param checkClassVersion whether to check the class version or not.\r\n */\r\n@SuppressWarnings(\"PMD.ConstructorCallsOverridableMethod\")\r\nClassReader(final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {\r\n    this.classFileBuffer = classFileBuffer;\r\n    this.b = classFileBuffer;\r\n    // Check the class' major_version. This field is after the magic and minor_version fields, which\r\n    // use 4 and 2 bytes respectively.\r\n    if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V24) {\r\n        throw new IllegalArgumentException(\"Unsupported class file major version \" + readShort(classFileOffset + 6));\r\n    }\r\n    // Create the constant pool arrays. The constant_pool_count field is after the magic,\r\n    // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.\r\n    int constantPoolCount = readUnsignedShort(classFileOffset + 8);\r\n    cpInfoOffsets = new int[constantPoolCount];\r\n    constantUtf8Values = new String[constantPoolCount];\r\n    // Compute the offset of each constant pool entry, as well as a conservative estimate of the\r\n    // maximum length of the constant pool strings. The first constant pool entry is after the\r\n    // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2\r\n    // bytes respectively.\r\n    int currentCpInfoIndex = 1;\r\n    int currentCpInfoOffset = classFileOffset + 10;\r\n    int currentMaxStringLength = 0;\r\n    boolean hasBootstrapMethods = false;\r\n    boolean hasConstantDynamic = false;\r\n    // The offset of the other entries depend on the total size of all the previous entries.\r\n    while (currentCpInfoIndex < constantPoolCount) {\r\n        cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;\r\n        int cpInfoSize;\r\n        switch(classFileBuffer[currentCpInfoOffset]) {\r\n            case Symbol.CONSTANT_FIELDREF_TAG:\r\n            case Symbol.CONSTANT_METHODREF_TAG:\r\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\r\n            case Symbol.CONSTANT_INTEGER_TAG:\r\n            case Symbol.CONSTANT_FLOAT_TAG:\r\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\r\n                cpInfoSize = 5;\r\n                break;\r\n            case Symbol.CONSTANT_DYNAMIC_TAG:\r\n                cpInfoSize = 5;\r\n                hasBootstrapMethods = true;\r\n                hasConstantDynamic = true;\r\n                break;\r\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\r\n                cpInfoSize = 5;\r\n                hasBootstrapMethods = true;\r\n                break;\r\n            case Symbol.CONSTANT_LONG_TAG:\r\n            case Symbol.CONSTANT_DOUBLE_TAG:\r\n                cpInfoSize = 9;\r\n                currentCpInfoIndex++;\r\n                break;\r\n            case Symbol.CONSTANT_UTF8_TAG:\r\n                cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);\r\n                if (cpInfoSize > currentMaxStringLength) {\r\n                    // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate\r\n                    // of the length in characters of the corresponding string, and is much cheaper to\r\n                    // compute than this exact length.\r\n                    currentMaxStringLength = cpInfoSize;\r\n                }\r\n                break;\r\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n                cpInfoSize = 4;\r\n                break;\r\n            case Symbol.CONSTANT_CLASS_TAG:\r\n            case Symbol.CONSTANT_STRING_TAG:\r\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n            case Symbol.CONSTANT_PACKAGE_TAG:\r\n            case Symbol.CONSTANT_MODULE_TAG:\r\n                cpInfoSize = 3;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n        currentCpInfoOffset += cpInfoSize;\r\n    }\r\n    maxStringLength = currentMaxStringLength;\r\n    // The Classfile's access_flags field is just after the last constant pool entry.\r\n    header = currentCpInfoOffset;\r\n    // Allocate the cache of ConstantDynamic values, if there is at least one.\r\n    constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;\r\n    // Read the BootstrapMethods attribute, if any (only get the offset of each method).\r\n    bootstrapMethodOffsets = hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;\r\n}\n/**\r\n * Constructs a new {@link ClassReader} object.\r\n *\r\n * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input\r\n *     stream must contain nothing more than the ClassFile structure itself. It is read from its\r\n *     current position to its end.\r\n * @throws IOException if a problem occurs during reading.\r\n */\r\npublic ClassReader(final InputStream inputStream) throws IOException {\r\n    this(readStream(inputStream, false));\r\n}\n/**\r\n * Constructs a new {@link ClassReader} object.\r\n *\r\n * @param className the fully qualified name of the class to be read. The ClassFile structure is\r\n *     retrieved with the current class loader's {@link ClassLoader#getSystemResourceAsStream}.\r\n * @throws IOException if an exception occurs during reading.\r\n */\r\npublic ClassReader(final String className) throws IOException {\r\n    this(readStream(ClassLoader.getSystemResourceAsStream(className.replace('.', '/') + \".class\"), true));\r\n}\n/**\r\n * Reads the given input stream and returns its content as a byte array.\r\n *\r\n * @param inputStream an input stream.\r\n * @param close true to close the input stream after reading.\r\n * @return the content of the given input stream.\r\n * @throws IOException if a problem occurs during reading.\r\n */\r\n@SuppressWarnings(\"PMD.UseTryWithResources\")\r\nprivate static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException {\r\n    if (inputStream == null) {\r\n        throw new IOException(\"Class not found\");\r\n    }\r\n    int bufferSize = computeBufferSize(inputStream);\r\n    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\r\n        byte[] data = new byte[bufferSize];\r\n        int bytesRead;\r\n        int readCount = 0;\r\n        while ((bytesRead = inputStream.read(data, 0, bufferSize)) != -1) {\r\n            outputStream.write(data, 0, bytesRead);\r\n            readCount++;\r\n        }\r\n        outputStream.flush();\r\n        if (readCount == 1) {\r\n            // SPRING PATCH: some misbehaving InputStreams return -1 but still write to buffer (gh-27429)\r\n            // return data;\r\n            // END OF PATCH\r\n        }\r\n        return outputStream.toByteArray();\r\n    } finally {\r\n        if (close) {\r\n            inputStream.close();\r\n        }\r\n    }\r\n}\nprivate static int computeBufferSize(final InputStream inputStream) throws IOException {\r\n    int expectedLength = inputStream.available();\r\n    /*\r\n     * Some implementations can return 0 while holding available data (e.g. new\r\n     * FileInputStream(\"/proc/a_file\")). Also in some pathological cases a very small number might\r\n     * be returned, and in this case we use a default size.\r\n     */\r\n    if (expectedLength < 256) {\r\n        return INPUT_STREAM_DATA_CHUNK_SIZE;\r\n    }\r\n    return Math.min(expectedLength, MAX_BUFFER_SIZE);\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Accessors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\r\n * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\r\n *\r\n * @return the class access flags.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic int getAccess() {\r\n    return readUnsignedShort(header);\r\n}\n/**\r\n * Returns the internal name of the class (see {@link Type#getInternalName()}).\r\n *\r\n * @return the internal class name.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic String getClassName() {\r\n    // this_class is just after the access_flags field (using 2 bytes).\r\n    return readClass(header + 2, new char[maxStringLength]);\r\n}\n/**\r\n * Returns the internal name of the super class (see {@link Type#getInternalName()}). For\r\n * interfaces, the super class is {@link Object}.\r\n *\r\n * @return the internal name of the super class, or {@literal null} for {@link Object} class.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic String getSuperName() {\r\n    // super_class is after the access_flags and this_class fields (2 bytes each).\r\n    return readClass(header + 4, new char[maxStringLength]);\r\n}\n/**\r\n * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\r\n *\r\n * @return the internal names of the directly implemented interfaces. Inherited implemented\r\n *     interfaces are not returned.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic String[] getInterfaces() {\r\n    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).\r\n    int currentOffset = header + 6;\r\n    int interfacesCount = readUnsignedShort(currentOffset);\r\n    String[] interfaces = new String[interfacesCount];\r\n    if (interfacesCount > 0) {\r\n        char[] charBuffer = new char[maxStringLength];\r\n        for (int i = 0; i < interfacesCount; ++i) {\r\n            currentOffset += 2;\r\n            interfaces[i] = readClass(currentOffset, charBuffer);\r\n        }\r\n    }\r\n    return interfaces;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Public methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\r\n * {@link ClassReader}.\r\n *\r\n * @param classVisitor the visitor that must visit this class.\r\n * @param parsingOptions the options to use to parse this class. One or more of {@link\r\n *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\r\n */\r\npublic void accept(final ClassVisitor classVisitor, final int parsingOptions) {\r\n    accept(classVisitor, new Attribute[0], parsingOptions);\r\n}\n/**\r\n * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\r\n * {@link ClassReader}.\r\n *\r\n * @param classVisitor the visitor that must visit this class.\r\n * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\r\n *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\r\n *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\r\n *     corrupt it if this value contains references to the constant pool, or has syntactic or\r\n *     semantic links with a class element that has been transformed by a class adapter between\r\n *     the reader and the writer</i>.\r\n * @param parsingOptions the options to use to parse this class. One or more of {@link\r\n *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\r\n */\r\npublic void accept(final ClassVisitor classVisitor, final Attribute[] attributePrototypes, final int parsingOptions) {\r\n    Context context = new Context();\r\n    context.attributePrototypes = attributePrototypes;\r\n    context.parsingOptions = parsingOptions;\r\n    context.charBuffer = new char[maxStringLength];\r\n    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = header;\r\n    int accessFlags = readUnsignedShort(currentOffset);\r\n    String thisClass = readClass(currentOffset + 2, charBuffer);\r\n    String superClass = readClass(currentOffset + 4, charBuffer);\r\n    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\r\n    currentOffset += 8;\r\n    for (int i = 0; i < interfaces.length; ++i) {\r\n        interfaces[i] = readClass(currentOffset, charBuffer);\r\n        currentOffset += 2;\r\n    }\r\n    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The offset of the InnerClasses attribute, or 0.\r\n    int innerClassesOffset = 0;\r\n    // - The offset of the EnclosingMethod attribute, or 0.\r\n    int enclosingMethodOffset = 0;\r\n    // - The string corresponding to the Signature attribute, or null.\r\n    String signature = null;\r\n    // - The string corresponding to the SourceFile attribute, or null.\r\n    String sourceFile = null;\r\n    // - The string corresponding to the SourceDebugExtension attribute, or null.\r\n    String sourceDebugExtension = null;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the Module attribute, or 0.\r\n    int moduleOffset = 0;\r\n    // - The offset of the ModulePackages attribute, or 0.\r\n    int modulePackagesOffset = 0;\r\n    // - The string corresponding to the ModuleMainClass attribute, or null.\r\n    String moduleMainClass = null;\r\n    // - The string corresponding to the NestHost attribute, or null.\r\n    String nestHostClass = null;\r\n    // - The offset of the NestMembers attribute, or 0.\r\n    int nestMembersOffset = 0;\r\n    // - The offset of the PermittedSubclasses attribute, or 0\r\n    int permittedSubclassesOffset = 0;\r\n    // - The offset of the Record attribute, or 0.\r\n    int recordOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int currentAttributeOffset = getFirstAttributeOffset();\r\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentAttributeOffset, charBuffer);\r\n        int attributeLength = readInt(currentAttributeOffset + 2);\r\n        currentAttributeOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.SOURCE_FILE.equals(attributeName)) {\r\n            sourceFile = readUTF8(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.INNER_CLASSES.equals(attributeName)) {\r\n            innerClassesOffset = currentAttributeOffset;\r\n        } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\r\n            enclosingMethodOffset = currentAttributeOffset;\r\n        } else if (Constants.NEST_HOST.equals(attributeName)) {\r\n            nestHostClass = readClass(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\r\n            nestMembersOffset = currentAttributeOffset;\r\n        } else if (Constants.PERMITTED_SUBCLASSES.equals(attributeName)) {\r\n            permittedSubclassesOffset = currentAttributeOffset;\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signature = readUTF8(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\r\n            if (attributeLength > classFileBuffer.length - currentAttributeOffset) {\r\n                throw new IllegalArgumentException();\r\n            }\r\n            sourceDebugExtension = readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.RECORD.equals(attributeName)) {\r\n            recordOffset = currentAttributeOffset;\r\n            accessFlags |= Opcodes.ACC_RECORD;\r\n        } else if (Constants.MODULE.equals(attributeName)) {\r\n            moduleOffset = currentAttributeOffset;\r\n        } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\r\n            moduleMainClass = readClass(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\r\n            modulePackagesOffset = currentAttributeOffset;\r\n        } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            // The BootstrapMethods attribute is read in the constructor.\r\n            Attribute attribute = readAttribute(attributePrototypes, attributeName, currentAttributeOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentAttributeOffset += attributeLength;\r\n    }\r\n    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\r\n    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\r\n    classVisitor.visit(readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\r\n    // Visit the SourceFile and SourceDebugExtenstion attributes.\r\n    if ((parsingOptions & SKIP_DEBUG) == 0 && (sourceFile != null || sourceDebugExtension != null)) {\r\n        classVisitor.visitSource(sourceFile, sourceDebugExtension);\r\n    }\r\n    // Visit the Module, ModulePackages and ModuleMainClass attributes.\r\n    if (moduleOffset != 0) {\r\n        readModuleAttributes(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\r\n    }\r\n    // Visit the NestHost attribute.\r\n    if (nestHostClass != null) {\r\n        classVisitor.visitNestHost(nestHostClass);\r\n    }\r\n    // Visit the EnclosingMethod attribute.\r\n    if (enclosingMethodOffset != 0) {\r\n        String className = readClass(enclosingMethodOffset, charBuffer);\r\n        int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\r\n        String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\r\n        String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\r\n        classVisitor.visitOuterClass(className, name, type);\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        classVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the NestedMembers attribute.\r\n    if (nestMembersOffset != 0) {\r\n        int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\r\n        int currentNestMemberOffset = nestMembersOffset + 2;\r\n        while (numberOfNestMembers-- > 0) {\r\n            classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));\r\n            currentNestMemberOffset += 2;\r\n        }\r\n    }\r\n    // Visit the PermittedSubclasses attribute.\r\n    if (permittedSubclassesOffset != 0) {\r\n        int numberOfPermittedSubclasses = readUnsignedShort(permittedSubclassesOffset);\r\n        int currentPermittedSubclassesOffset = permittedSubclassesOffset + 2;\r\n        while (numberOfPermittedSubclasses-- > 0) {\r\n            classVisitor.visitPermittedSubclass(readClass(currentPermittedSubclassesOffset, charBuffer));\r\n            currentPermittedSubclassesOffset += 2;\r\n        }\r\n    }\r\n    // Visit the InnerClasses attribute.\r\n    if (innerClassesOffset != 0) {\r\n        int numberOfClasses = readUnsignedShort(innerClassesOffset);\r\n        int currentClassesOffset = innerClassesOffset + 2;\r\n        while (numberOfClasses-- > 0) {\r\n            classVisitor.visitInnerClass(readClass(currentClassesOffset, charBuffer), readClass(currentClassesOffset + 2, charBuffer), readUTF8(currentClassesOffset + 4, charBuffer), readUnsignedShort(currentClassesOffset + 6));\r\n            currentClassesOffset += 8;\r\n        }\r\n    }\r\n    // Visit Record components.\r\n    if (recordOffset != 0) {\r\n        int recordComponentsCount = readUnsignedShort(recordOffset);\r\n        recordOffset += 2;\r\n        while (recordComponentsCount-- > 0) {\r\n            recordOffset = readRecordComponent(classVisitor, context, recordOffset);\r\n        }\r\n    }\r\n    // Visit the fields and methods.\r\n    int fieldsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (fieldsCount-- > 0) {\r\n        currentOffset = readField(classVisitor, context, currentOffset);\r\n    }\r\n    int methodsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (methodsCount-- > 0) {\r\n        currentOffset = readMethod(classVisitor, context, currentOffset);\r\n    }\r\n    // Visit the end of the class.\r\n    classVisitor.visitEnd();\r\n}\n// ----------------------------------------------------------------------------------------------\r\n// Methods to parse modules, fields and methods\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\r\n *\r\n * @param classVisitor the current class visitor\r\n * @param context information about the class being parsed.\r\n * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\r\n *     attribute_name_index and attribute_length fields).\r\n * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\r\n *     attribute_info's attribute_name_index and attribute_length fields), or 0.\r\n * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\r\n *     null}.\r\n */\r\nprivate void readModuleAttributes(final ClassVisitor classVisitor, final Context context, final int moduleOffset, final int modulePackagesOffset, final String moduleMainClass) {\r\n    char[] buffer = context.charBuffer;\r\n    // Read the module_name_index, module_flags and module_version_index fields and visit them.\r\n    int currentOffset = moduleOffset;\r\n    String moduleName = readModule(currentOffset, buffer);\r\n    int moduleFlags = readUnsignedShort(currentOffset + 2);\r\n    String moduleVersion = readUTF8(currentOffset + 4, buffer);\r\n    currentOffset += 6;\r\n    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\r\n    if (moduleVisitor == null) {\r\n        return;\r\n    }\r\n    // Visit the ModuleMainClass attribute.\r\n    if (moduleMainClass != null) {\r\n        moduleVisitor.visitMainClass(moduleMainClass);\r\n    }\r\n    // Visit the ModulePackages attribute.\r\n    if (modulePackagesOffset != 0) {\r\n        int packageCount = readUnsignedShort(modulePackagesOffset);\r\n        int currentPackageOffset = modulePackagesOffset + 2;\r\n        while (packageCount-- > 0) {\r\n            moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\r\n            currentPackageOffset += 2;\r\n        }\r\n    }\r\n    // Read the 'requires_count' and 'requires' fields.\r\n    int requiresCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (requiresCount-- > 0) {\r\n        // Read the requires_index, requires_flags and requires_version fields and visit them.\r\n        String requires = readModule(currentOffset, buffer);\r\n        int requiresFlags = readUnsignedShort(currentOffset + 2);\r\n        String requiresVersion = readUTF8(currentOffset + 4, buffer);\r\n        currentOffset += 6;\r\n        moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\r\n    }\r\n    // Read the 'exports_count' and 'exports' fields.\r\n    int exportsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (exportsCount-- > 0) {\r\n        // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields\r\n        // and visit them.\r\n        String exports = readPackage(currentOffset, buffer);\r\n        int exportsFlags = readUnsignedShort(currentOffset + 2);\r\n        int exportsToCount = readUnsignedShort(currentOffset + 4);\r\n        currentOffset += 6;\r\n        String[] exportsTo = null;\r\n        if (exportsToCount != 0) {\r\n            exportsTo = new String[exportsToCount];\r\n            for (int i = 0; i < exportsToCount; ++i) {\r\n                exportsTo[i] = readModule(currentOffset, buffer);\r\n                currentOffset += 2;\r\n            }\r\n        }\r\n        moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\r\n    }\r\n    // Reads the 'opens_count' and 'opens' fields.\r\n    int opensCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (opensCount-- > 0) {\r\n        // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.\r\n        String opens = readPackage(currentOffset, buffer);\r\n        int opensFlags = readUnsignedShort(currentOffset + 2);\r\n        int opensToCount = readUnsignedShort(currentOffset + 4);\r\n        currentOffset += 6;\r\n        String[] opensTo = null;\r\n        if (opensToCount != 0) {\r\n            opensTo = new String[opensToCount];\r\n            for (int i = 0; i < opensToCount; ++i) {\r\n                opensTo[i] = readModule(currentOffset, buffer);\r\n                currentOffset += 2;\r\n            }\r\n        }\r\n        moduleVisitor.visitOpen(opens, opensFlags, opensTo);\r\n    }\r\n    // Read the 'uses_count' and 'uses' fields.\r\n    int usesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (usesCount-- > 0) {\r\n        moduleVisitor.visitUse(readClass(currentOffset, buffer));\r\n        currentOffset += 2;\r\n    }\r\n    // Read the 'provides_count' and 'provides' fields.\r\n    int providesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (providesCount-- > 0) {\r\n        // Read the provides_index, provides_with_count and provides_with_index fields and visit them.\r\n        String provides = readClass(currentOffset, buffer);\r\n        int providesWithCount = readUnsignedShort(currentOffset + 2);\r\n        currentOffset += 4;\r\n        String[] providesWith = new String[providesWithCount];\r\n        for (int i = 0; i < providesWithCount; ++i) {\r\n            providesWith[i] = readClass(currentOffset, buffer);\r\n            currentOffset += 2;\r\n        }\r\n        moduleVisitor.visitProvide(provides, providesWith);\r\n    }\r\n    // Visit the end of the module attributes.\r\n    moduleVisitor.visitEnd();\r\n}\n/**\r\n * Reads a record component and visit it.\r\n *\r\n * @param classVisitor the current class visitor\r\n * @param context information about the class being parsed.\r\n * @param recordComponentOffset the offset of the current record component.\r\n * @return the offset of the first byte following the record component.\r\n */\r\nprivate int readRecordComponent(final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = recordComponentOffset;\r\n    String name = readUTF8(currentOffset, charBuffer);\r\n    String descriptor = readUTF8(currentOffset + 2, charBuffer);\r\n    currentOffset += 4;\r\n    // Read the record component attributes (the variables are ordered as in Section 4.7 of the\r\n    // JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The string corresponding to the Signature attribute, or null.\r\n    String signature = null;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signature = readUTF8(currentOffset, charBuffer);\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(name, descriptor, signature);\r\n    if (recordComponentVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        recordComponentVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the end of the field.\r\n    recordComponentVisitor.visitEnd();\r\n    return currentOffset;\r\n}\n/**\r\n * Reads a JVMS field_info structure and makes the given visitor visit it.\r\n *\r\n * @param classVisitor the visitor that must visit the field.\r\n * @param context information about the class being parsed.\r\n * @param fieldInfoOffset the start offset of the field_info structure.\r\n * @return the offset of the first byte following the field_info structure.\r\n */\r\nprivate int readField(final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    // Read the access_flags, name_index and descriptor_index fields.\r\n    int currentOffset = fieldInfoOffset;\r\n    int accessFlags = readUnsignedShort(currentOffset);\r\n    String name = readUTF8(currentOffset + 2, charBuffer);\r\n    String descriptor = readUTF8(currentOffset + 4, charBuffer);\r\n    currentOffset += 6;\r\n    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The value corresponding to the ConstantValue attribute, or null.\r\n    Object constantValue = null;\r\n    // - The string corresponding to the Signature attribute, or null.\r\n    String signature = null;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.CONSTANT_VALUE.equals(attributeName)) {\r\n            int constantvalueIndex = readUnsignedShort(currentOffset);\r\n            constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signature = readUTF8(currentOffset, charBuffer);\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Visit the field declaration.\r\n    FieldVisitor fieldVisitor = classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);\r\n    if (fieldVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        fieldVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the end of the field.\r\n    fieldVisitor.visitEnd();\r\n    return currentOffset;\r\n}\n/**\r\n * Reads a JVMS method_info structure and makes the given visitor visit it.\r\n *\r\n * @param classVisitor the visitor that must visit the method.\r\n * @param context information about the class being parsed.\r\n * @param methodInfoOffset the start offset of the method_info structure.\r\n * @return the offset of the first byte following the method_info structure.\r\n */\r\nprivate int readMethod(final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    // Read the access_flags, name_index and descriptor_index fields.\r\n    int currentOffset = methodInfoOffset;\r\n    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\r\n    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\r\n    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\r\n    currentOffset += 6;\r\n    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The offset of the Code attribute, or 0.\r\n    int codeOffset = 0;\r\n    // - The offset of the Exceptions attribute, or 0.\r\n    int exceptionsOffset = 0;\r\n    // - The strings corresponding to the Exceptions attribute, or null.\r\n    String[] exceptions = null;\r\n    // - Whether the method has a Synthetic attribute.\r\n    boolean synthetic = false;\r\n    // - The constant pool index contained in the Signature attribute, or 0.\r\n    int signatureIndex = 0;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\r\n    int runtimeVisibleParameterAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\r\n    int runtimeInvisibleParameterAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the AnnotationDefault attribute, or 0.\r\n    int annotationDefaultOffset = 0;\r\n    // - The offset of the MethodParameters attribute, or 0.\r\n    int methodParametersOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.CODE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_CODE) == 0) {\r\n                codeOffset = currentOffset;\r\n            }\r\n        } else if (Constants.EXCEPTIONS.equals(attributeName)) {\r\n            exceptionsOffset = currentOffset;\r\n            exceptions = new String[readUnsignedShort(exceptionsOffset)];\r\n            int currentExceptionOffset = exceptionsOffset + 2;\r\n            for (int i = 0; i < exceptions.length; ++i) {\r\n                exceptions[i] = readClass(currentExceptionOffset, charBuffer);\r\n                currentExceptionOffset += 2;\r\n            }\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signatureIndex = readUnsignedShort(currentOffset);\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\r\n            annotationDefaultOffset = currentOffset;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            synthetic = true;\r\n            context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleParameterAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleParameterAnnotationsOffset = currentOffset;\r\n        } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\r\n            methodParametersOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Visit the method declaration.\r\n    MethodVisitor methodVisitor = classVisitor.visitMethod(context.currentMethodAccessFlags, context.currentMethodName, context.currentMethodDescriptor, signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer), exceptions);\r\n    if (methodVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\r\n    // adapter between the reader and the writer. In this case, it might be possible to copy\r\n    // the method attributes directly into the writer. If so, return early without visiting\r\n    // the content of these attributes.\r\n    if (methodVisitor instanceof MethodWriter) {\r\n        MethodWriter methodWriter = (MethodWriter) methodVisitor;\r\n        if (methodWriter.canCopyMethodAttributes(this, synthetic, (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0, readUnsignedShort(methodInfoOffset + 4), signatureIndex, exceptionsOffset)) {\r\n            methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\r\n            return currentOffset;\r\n        }\r\n    }\r\n    // Visit the MethodParameters attribute.\r\n    if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\r\n        int parametersCount = readByte(methodParametersOffset);\r\n        int currentParameterOffset = methodParametersOffset + 1;\r\n        while (parametersCount-- > 0) {\r\n            // Read the name_index and access_flags fields and visit them.\r\n            methodVisitor.visitParameter(readUTF8(currentParameterOffset, charBuffer), readUnsignedShort(currentParameterOffset + 2));\r\n            currentParameterOffset += 4;\r\n        }\r\n    }\r\n    // Visit the AnnotationDefault attribute.\r\n    if (annotationDefaultOffset != 0) {\r\n        AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\r\n        readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\r\n        if (annotationVisitor != null) {\r\n            annotationVisitor.visitEnd();\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleParameterAnnotations attribute.\r\n    if (runtimeVisibleParameterAnnotationsOffset != 0) {\r\n        readParameterAnnotations(methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible= */\r\n        true);\r\n    }\r\n    // Visit the RuntimeInvisibleParameterAnnotations attribute.\r\n    if (runtimeInvisibleParameterAnnotationsOffset != 0) {\r\n        readParameterAnnotations(methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset, /* visible= */\r\n        false);\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        methodVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the Code attribute.\r\n    if (codeOffset != 0) {\r\n        methodVisitor.visitCode();\r\n        readCode(methodVisitor, context, codeOffset);\r\n    }\r\n    // Visit the end of the method.\r\n    methodVisitor.visitEnd();\r\n    return currentOffset;\r\n}\n// ----------------------------------------------------------------------------------------------\r\n// Methods to parse a Code attribute\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\r\n *\r\n * @param methodVisitor the visitor that must visit the Code attribute.\r\n * @param context information about the class being parsed.\r\n * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\r\n *     its attribute_name_index and attribute_length fields.\r\n */\r\nprivate void readCode(final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\r\n    int currentOffset = codeOffset;\r\n    // Read the max_stack, max_locals and code_length fields.\r\n    final byte[] classBuffer = classFileBuffer;\r\n    final char[] charBuffer = context.charBuffer;\r\n    final int maxStack = readUnsignedShort(currentOffset);\r\n    final int maxLocals = readUnsignedShort(currentOffset + 2);\r\n    final int codeLength = readInt(currentOffset + 4);\r\n    currentOffset += 8;\r\n    if (codeLength > classFileBuffer.length - currentOffset) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    // Read the bytecode 'code' array to create a label for each referenced instruction.\r\n    final int bytecodeStartOffset = currentOffset;\r\n    final int bytecodeEndOffset = currentOffset + codeLength;\r\n    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\r\n    while (currentOffset < bytecodeEndOffset) {\r\n        final int bytecodeOffset = currentOffset - bytecodeStartOffset;\r\n        final int opcode = classBuffer[currentOffset] & 0xFF;\r\n        switch(opcode) {\r\n            case Opcodes.NOP:\r\n            case Opcodes.ACONST_NULL:\r\n            case Opcodes.ICONST_M1:\r\n            case Opcodes.ICONST_0:\r\n            case Opcodes.ICONST_1:\r\n            case Opcodes.ICONST_2:\r\n            case Opcodes.ICONST_3:\r\n            case Opcodes.ICONST_4:\r\n            case Opcodes.ICONST_5:\r\n            case Opcodes.LCONST_0:\r\n            case Opcodes.LCONST_1:\r\n            case Opcodes.FCONST_0:\r\n            case Opcodes.FCONST_1:\r\n            case Opcodes.FCONST_2:\r\n            case Opcodes.DCONST_0:\r\n            case Opcodes.DCONST_1:\r\n            case Opcodes.IALOAD:\r\n            case Opcodes.LALOAD:\r\n            case Opcodes.FALOAD:\r\n            case Opcodes.DALOAD:\r\n            case Opcodes.AALOAD:\r\n            case Opcodes.BALOAD:\r\n            case Opcodes.CALOAD:\r\n            case Opcodes.SALOAD:\r\n            case Opcodes.IASTORE:\r\n            case Opcodes.LASTORE:\r\n            case Opcodes.FASTORE:\r\n            case Opcodes.DASTORE:\r\n            case Opcodes.AASTORE:\r\n            case Opcodes.BASTORE:\r\n            case Opcodes.CASTORE:\r\n            case Opcodes.SASTORE:\r\n            case Opcodes.POP:\r\n            case Opcodes.POP2:\r\n            case Opcodes.DUP:\r\n            case Opcodes.DUP_X1:\r\n            case Opcodes.DUP_X2:\r\n            case Opcodes.DUP2:\r\n            case Opcodes.DUP2_X1:\r\n            case Opcodes.DUP2_X2:\r\n            case Opcodes.SWAP:\r\n            case Opcodes.IADD:\r\n            case Opcodes.LADD:\r\n            case Opcodes.FADD:\r\n            case Opcodes.DADD:\r\n            case Opcodes.ISUB:\r\n            case Opcodes.LSUB:\r\n            case Opcodes.FSUB:\r\n            case Opcodes.DSUB:\r\n            case Opcodes.IMUL:\r\n            case Opcodes.LMUL:\r\n            case Opcodes.FMUL:\r\n            case Opcodes.DMUL:\r\n            case Opcodes.IDIV:\r\n            case Opcodes.LDIV:\r\n            case Opcodes.FDIV:\r\n            case Opcodes.DDIV:\r\n            case Opcodes.IREM:\r\n            case Opcodes.LREM:\r\n            case Opcodes.FREM:\r\n            case Opcodes.DREM:\r\n            case Opcodes.INEG:\r\n            case Opcodes.LNEG:\r\n            case Opcodes.FNEG:\r\n            case Opcodes.DNEG:\r\n            case Opcodes.ISHL:\r\n            case Opcodes.LSHL:\r\n            case Opcodes.ISHR:\r\n            case Opcodes.LSHR:\r\n            case Opcodes.IUSHR:\r\n            case Opcodes.LUSHR:\r\n            case Opcodes.IAND:\r\n            case Opcodes.LAND:\r\n            case Opcodes.IOR:\r\n            case Opcodes.LOR:\r\n            case Opcodes.IXOR:\r\n            case Opcodes.LXOR:\r\n            case Opcodes.I2L:\r\n            case Opcodes.I2F:\r\n            case Opcodes.I2D:\r\n            case Opcodes.L2I:\r\n            case Opcodes.L2F:\r\n            case Opcodes.L2D:\r\n            case Opcodes.F2I:\r\n            case Opcodes.F2L:\r\n            case Opcodes.F2D:\r\n            case Opcodes.D2I:\r\n            case Opcodes.D2L:\r\n            case Opcodes.D2F:\r\n            case Opcodes.I2B:\r\n            case Opcodes.I2C:\r\n            case Opcodes.I2S:\r\n            case Opcodes.LCMP:\r\n            case Opcodes.FCMPL:\r\n            case Opcodes.FCMPG:\r\n            case Opcodes.DCMPL:\r\n            case Opcodes.DCMPG:\r\n            case Opcodes.IRETURN:\r\n            case Opcodes.LRETURN:\r\n            case Opcodes.FRETURN:\r\n            case Opcodes.DRETURN:\r\n            case Opcodes.ARETURN:\r\n            case Opcodes.RETURN:\r\n            case Opcodes.ARRAYLENGTH:\r\n            case Opcodes.ATHROW:\r\n            case Opcodes.MONITORENTER:\r\n            case Opcodes.MONITOREXIT:\r\n            case Constants.ILOAD_0:\r\n            case Constants.ILOAD_1:\r\n            case Constants.ILOAD_2:\r\n            case Constants.ILOAD_3:\r\n            case Constants.LLOAD_0:\r\n            case Constants.LLOAD_1:\r\n            case Constants.LLOAD_2:\r\n            case Constants.LLOAD_3:\r\n            case Constants.FLOAD_0:\r\n            case Constants.FLOAD_1:\r\n            case Constants.FLOAD_2:\r\n            case Constants.FLOAD_3:\r\n            case Constants.DLOAD_0:\r\n            case Constants.DLOAD_1:\r\n            case Constants.DLOAD_2:\r\n            case Constants.DLOAD_3:\r\n            case Constants.ALOAD_0:\r\n            case Constants.ALOAD_1:\r\n            case Constants.ALOAD_2:\r\n            case Constants.ALOAD_3:\r\n            case Constants.ISTORE_0:\r\n            case Constants.ISTORE_1:\r\n            case Constants.ISTORE_2:\r\n            case Constants.ISTORE_3:\r\n            case Constants.LSTORE_0:\r\n            case Constants.LSTORE_1:\r\n            case Constants.LSTORE_2:\r\n            case Constants.LSTORE_3:\r\n            case Constants.FSTORE_0:\r\n            case Constants.FSTORE_1:\r\n            case Constants.FSTORE_2:\r\n            case Constants.FSTORE_3:\r\n            case Constants.DSTORE_0:\r\n            case Constants.DSTORE_1:\r\n            case Constants.DSTORE_2:\r\n            case Constants.DSTORE_3:\r\n            case Constants.ASTORE_0:\r\n            case Constants.ASTORE_1:\r\n            case Constants.ASTORE_2:\r\n            case Constants.ASTORE_3:\r\n                currentOffset += 1;\r\n                break;\r\n            case Opcodes.IFEQ:\r\n            case Opcodes.IFNE:\r\n            case Opcodes.IFLT:\r\n            case Opcodes.IFGE:\r\n            case Opcodes.IFGT:\r\n            case Opcodes.IFLE:\r\n            case Opcodes.IF_ICMPEQ:\r\n            case Opcodes.IF_ICMPNE:\r\n            case Opcodes.IF_ICMPLT:\r\n            case Opcodes.IF_ICMPGE:\r\n            case Opcodes.IF_ICMPGT:\r\n            case Opcodes.IF_ICMPLE:\r\n            case Opcodes.IF_ACMPEQ:\r\n            case Opcodes.IF_ACMPNE:\r\n            case Opcodes.GOTO:\r\n            case Opcodes.JSR:\r\n            case Opcodes.IFNULL:\r\n            case Opcodes.IFNONNULL:\r\n                createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.ASM_IFEQ:\r\n            case Constants.ASM_IFNE:\r\n            case Constants.ASM_IFLT:\r\n            case Constants.ASM_IFGE:\r\n            case Constants.ASM_IFGT:\r\n            case Constants.ASM_IFLE:\r\n            case Constants.ASM_IF_ICMPEQ:\r\n            case Constants.ASM_IF_ICMPNE:\r\n            case Constants.ASM_IF_ICMPLT:\r\n            case Constants.ASM_IF_ICMPGE:\r\n            case Constants.ASM_IF_ICMPGT:\r\n            case Constants.ASM_IF_ICMPLE:\r\n            case Constants.ASM_IF_ACMPEQ:\r\n            case Constants.ASM_IF_ACMPNE:\r\n            case Constants.ASM_GOTO:\r\n            case Constants.ASM_JSR:\r\n            case Constants.ASM_IFNULL:\r\n            case Constants.ASM_IFNONNULL:\r\n                createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.GOTO_W:\r\n            case Constants.JSR_W:\r\n            case Constants.ASM_GOTO_W:\r\n                createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.WIDE:\r\n                switch(classBuffer[currentOffset + 1] & 0xFF) {\r\n                    case Opcodes.ILOAD:\r\n                    case Opcodes.FLOAD:\r\n                    case Opcodes.ALOAD:\r\n                    case Opcodes.LLOAD:\r\n                    case Opcodes.DLOAD:\r\n                    case Opcodes.ISTORE:\r\n                    case Opcodes.FSTORE:\r\n                    case Opcodes.ASTORE:\r\n                    case Opcodes.LSTORE:\r\n                    case Opcodes.DSTORE:\r\n                    case Opcodes.RET:\r\n                        currentOffset += 4;\r\n                        break;\r\n                    case Opcodes.IINC:\r\n                        currentOffset += 6;\r\n                        break;\r\n                    default:\r\n                        throw new IllegalArgumentException();\r\n                }\r\n                break;\r\n            case Opcodes.TABLESWITCH:\r\n                // Skip 0 to 3 padding bytes.\r\n                currentOffset += 4 - (bytecodeOffset & 3);\r\n                // Read the default label and the number of table entries.\r\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\r\n                currentOffset += 12;\r\n                // Read the table labels.\r\n                while (numTableEntries-- > 0) {\r\n                    createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                    currentOffset += 4;\r\n                }\r\n                break;\r\n            case Opcodes.LOOKUPSWITCH:\r\n                // Skip 0 to 3 padding bytes.\r\n                currentOffset += 4 - (bytecodeOffset & 3);\r\n                // Read the default label and the number of switch cases.\r\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                int numSwitchCases = readInt(currentOffset + 4);\r\n                currentOffset += 8;\r\n                // Read the switch labels.\r\n                while (numSwitchCases-- > 0) {\r\n                    createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\r\n                    currentOffset += 8;\r\n                }\r\n                break;\r\n            case Opcodes.ILOAD:\r\n            case Opcodes.LLOAD:\r\n            case Opcodes.FLOAD:\r\n            case Opcodes.DLOAD:\r\n            case Opcodes.ALOAD:\r\n            case Opcodes.ISTORE:\r\n            case Opcodes.LSTORE:\r\n            case Opcodes.FSTORE:\r\n            case Opcodes.DSTORE:\r\n            case Opcodes.ASTORE:\r\n            case Opcodes.RET:\r\n            case Opcodes.BIPUSH:\r\n            case Opcodes.NEWARRAY:\r\n            case Opcodes.LDC:\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.SIPUSH:\r\n            case Constants.LDC_W:\r\n            case Constants.LDC2_W:\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.NEW:\r\n            case Opcodes.ANEWARRAY:\r\n            case Opcodes.CHECKCAST:\r\n            case Opcodes.INSTANCEOF:\r\n            case Opcodes.IINC:\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.INVOKEINTERFACE:\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                currentOffset += 5;\r\n                break;\r\n            case Opcodes.MULTIANEWARRAY:\r\n                currentOffset += 4;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n    }\r\n    // Read the 'exception_table_length' and 'exception_table' field to create a label for each\r\n    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\r\n    int exceptionTableLength = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (exceptionTableLength-- > 0) {\r\n        Label start = createLabel(readUnsignedShort(currentOffset), labels);\r\n        Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\r\n        Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\r\n        String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\r\n        currentOffset += 8;\r\n        methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\r\n    }\r\n    // Read the Code attributes to create a label for each referenced instruction (the variables\r\n    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\r\n    // attribute_name_index and attribute_length fields.\r\n    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\r\n    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\r\n    // updated after each stack_map_frame is read.\r\n    int stackMapFrameOffset = 0;\r\n    // - The end offset of the StackMap[Table] attribute, or 0.\r\n    int stackMapTableEndOffset = 0;\r\n    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\r\n    boolean compressedFrames = true;\r\n    // - The offset of the LocalVariableTable attribute, or 0.\r\n    int localVariableTableOffset = 0;\r\n    // - The offset of the LocalVariableTypeTable attribute, or 0.\r\n    int localVariableTypeTableOffset = 0;\r\n    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\r\n    // attribute, or null.\r\n    int[] visibleTypeAnnotationOffsets = null;\r\n    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\r\n    // attribute, or null.\r\n    int[] invisibleTypeAnnotationOffsets = null;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_DEBUG) == 0) {\r\n                localVariableTableOffset = currentOffset;\r\n                // Parse the attribute to find the corresponding (debug only) labels.\r\n                int currentLocalVariableTableOffset = currentOffset;\r\n                int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\r\n                currentLocalVariableTableOffset += 2;\r\n                while (localVariableTableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentLocalVariableTableOffset);\r\n                    createDebugLabel(startPc, labels);\r\n                    int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\r\n                    createDebugLabel(startPc + length, labels);\r\n                    // Skip the name_index, descriptor_index and index fields (2 bytes each).\r\n                    currentLocalVariableTableOffset += 10;\r\n                }\r\n            }\r\n        } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\r\n            localVariableTypeTableOffset = currentOffset;\r\n            // Here we do not extract the labels corresponding to the attribute content. We assume they\r\n            // are the same or a subset of those of the LocalVariableTable attribute.\r\n        } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_DEBUG) == 0) {\r\n                // Parse the attribute to find the corresponding (debug only) labels.\r\n                int currentLineNumberTableOffset = currentOffset;\r\n                int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\r\n                currentLineNumberTableOffset += 2;\r\n                while (lineNumberTableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentLineNumberTableOffset);\r\n                    int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\r\n                    currentLineNumberTableOffset += 4;\r\n                    createDebugLabel(startPc, labels);\r\n                    labels[startPc].addLineNumber(lineNumber);\r\n                }\r\n            }\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            visibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */\r\n            true);\r\n            // Here we do not extract the labels corresponding to the attribute content. This would\r\n            // require a full parsing of the attribute, which would need to be repeated when parsing\r\n            // the bytecode instructions (see below). Instead, the content of the attribute is read one\r\n            // type annotation at a time (i.e. after a type annotation has been visited, the next type\r\n            // annotation is read), and the labels it contains are also extracted one annotation at a\r\n            // time. This assumes that type annotations are ordered by increasing bytecode offset.\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            invisibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */\r\n            false);\r\n            // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\r\n        } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_FRAMES) == 0) {\r\n                stackMapFrameOffset = currentOffset + 2;\r\n                stackMapTableEndOffset = currentOffset + attributeLength;\r\n            }\r\n            // Here we do not extract the labels corresponding to the attribute content. This would\r\n            // require a full parsing of the attribute, which would need to be repeated when parsing\r\n            // the bytecode instructions (see below). Instead, the content of the attribute is read one\r\n            // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\r\n            // labels it contains are also extracted one frame at a time. Thanks to the ordering of\r\n            // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\r\n            // see an offset smaller than the offset of the current instruction and for which no Label\r\n            // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\r\n            // table without a full decoding (see below).\r\n        } else if (\"StackMap\".equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_FRAMES) == 0) {\r\n                stackMapFrameOffset = currentOffset + 2;\r\n                stackMapTableEndOffset = currentOffset + attributeLength;\r\n                compressedFrames = false;\r\n            }\r\n            // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\r\n            // although this is not guaranteed by the attribute format. This allows an incremental\r\n            // extraction of the labels corresponding to this attribute (see the comment above for the\r\n            // StackMapTable attribute).\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, codeOffset, labels);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Initialize the context fields related to stack map frames, and generate the first\r\n    // (implicit) stack map frame, if needed.\r\n    final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\r\n    if (stackMapFrameOffset != 0) {\r\n        // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\r\n        // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\r\n        // \"offset_delta + 1\" rule in all cases.\r\n        context.currentFrameOffset = -1;\r\n        context.currentFrameType = 0;\r\n        context.currentFrameLocalCount = 0;\r\n        context.currentFrameLocalCountDelta = 0;\r\n        context.currentFrameLocalTypes = new Object[maxLocals];\r\n        context.currentFrameStackCount = 0;\r\n        context.currentFrameStackTypes = new Object[maxStack];\r\n        if (expandFrames) {\r\n            computeImplicitFrame(context);\r\n        }\r\n        // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\r\n        // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\r\n        // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\r\n        // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\r\n        // and the only consequence will be the creation of an unneeded label. This is better than\r\n        // creating a label for each NEW instruction, and faster than fully decoding the whole stack\r\n        // map table.\r\n        for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\r\n            if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\r\n                int potentialBytecodeOffset = readUnsignedShort(offset + 1);\r\n                if (potentialBytecodeOffset >= 0 && potentialBytecodeOffset < codeLength && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF) == Opcodes.NEW) {\r\n                    createLabel(potentialBytecodeOffset, labels);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\r\n        // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\r\n        // does not currently have any frame. These inserted frames must be computed by simulating the\r\n        // effect of the bytecode instructions, one by one, starting from the implicit first frame.\r\n        // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\r\n        // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\r\n        // computed in MethodWriter).\r\n        methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\r\n    }\r\n    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\r\n    // of the type annotations.\r\n    // Index of the next runtime visible type annotation to read (in the\r\n    // visibleTypeAnnotationOffsets array).\r\n    int currentVisibleTypeAnnotationIndex = 0;\r\n    // The bytecode offset of the next runtime visible type annotation to read, or -1.\r\n    int currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\r\n    // Index of the next runtime invisible type annotation to read (in the\r\n    // invisibleTypeAnnotationOffsets array).\r\n    int currentInvisibleTypeAnnotationIndex = 0;\r\n    // The bytecode offset of the next runtime invisible type annotation to read, or -1.\r\n    int currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\r\n    // Whether a F_INSERT stack map frame must be inserted before the current instruction.\r\n    boolean insertFrame = false;\r\n    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\r\n    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\r\n    // instructions).\r\n    final int wideJumpOpcodeDelta = (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\r\n    currentOffset = bytecodeStartOffset;\r\n    while (currentOffset < bytecodeEndOffset) {\r\n        final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\r\n        readBytecodeInstructionOffset(currentBytecodeOffset);\r\n        // Visit the label and the line number(s) for this bytecode offset, if any.\r\n        Label currentLabel = labels[currentBytecodeOffset];\r\n        if (currentLabel != null) {\r\n            currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\r\n        }\r\n        // Visit the stack map frame for this bytecode offset, if any.\r\n        while (stackMapFrameOffset != 0 && (context.currentFrameOffset == currentBytecodeOffset || context.currentFrameOffset == -1)) {\r\n            // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\r\n            // next stack map frame if there is one.\r\n            if (context.currentFrameOffset != -1) {\r\n                if (!compressedFrames || expandFrames) {\r\n                    methodVisitor.visitFrame(Opcodes.F_NEW, context.currentFrameLocalCount, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\r\n                } else {\r\n                    methodVisitor.visitFrame(context.currentFrameType, context.currentFrameLocalCountDelta, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\r\n                }\r\n                // Since there is already a stack map frame for this bytecode offset, there is no need to\r\n                // insert a new one.\r\n                insertFrame = false;\r\n            }\r\n            if (stackMapFrameOffset < stackMapTableEndOffset) {\r\n                stackMapFrameOffset = readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\r\n            } else {\r\n                stackMapFrameOffset = 0;\r\n            }\r\n        }\r\n        // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\r\n        // true during the previous iteration. The actual frame content is computed in MethodWriter.\r\n        if (insertFrame) {\r\n            if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\r\n                methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\r\n            }\r\n            insertFrame = false;\r\n        }\r\n        // Visit the instruction at this bytecode offset.\r\n        int opcode = classBuffer[currentOffset] & 0xFF;\r\n        switch(opcode) {\r\n            case Opcodes.NOP:\r\n            case Opcodes.ACONST_NULL:\r\n            case Opcodes.ICONST_M1:\r\n            case Opcodes.ICONST_0:\r\n            case Opcodes.ICONST_1:\r\n            case Opcodes.ICONST_2:\r\n            case Opcodes.ICONST_3:\r\n            case Opcodes.ICONST_4:\r\n            case Opcodes.ICONST_5:\r\n            case Opcodes.LCONST_0:\r\n            case Opcodes.LCONST_1:\r\n            case Opcodes.FCONST_0:\r\n            case Opcodes.FCONST_1:\r\n            case Opcodes.FCONST_2:\r\n            case Opcodes.DCONST_0:\r\n            case Opcodes.DCONST_1:\r\n            case Opcodes.IALOAD:\r\n            case Opcodes.LALOAD:\r\n            case Opcodes.FALOAD:\r\n            case Opcodes.DALOAD:\r\n            case Opcodes.AALOAD:\r\n            case Opcodes.BALOAD:\r\n            case Opcodes.CALOAD:\r\n            case Opcodes.SALOAD:\r\n            case Opcodes.IASTORE:\r\n            case Opcodes.LASTORE:\r\n            case Opcodes.FASTORE:\r\n            case Opcodes.DASTORE:\r\n            case Opcodes.AASTORE:\r\n            case Opcodes.BASTORE:\r\n            case Opcodes.CASTORE:\r\n            case Opcodes.SASTORE:\r\n            case Opcodes.POP:\r\n            case Opcodes.POP2:\r\n            case Opcodes.DUP:\r\n            case Opcodes.DUP_X1:\r\n            case Opcodes.DUP_X2:\r\n            case Opcodes.DUP2:\r\n            case Opcodes.DUP2_X1:\r\n            case Opcodes.DUP2_X2:\r\n            case Opcodes.SWAP:\r\n            case Opcodes.IADD:\r\n            case Opcodes.LADD:\r\n            case Opcodes.FADD:\r\n            case Opcodes.DADD:\r\n            case Opcodes.ISUB:\r\n            case Opcodes.LSUB:\r\n            case Opcodes.FSUB:\r\n            case Opcodes.DSUB:\r\n            case Opcodes.IMUL:\r\n            case Opcodes.LMUL:\r\n            case Opcodes.FMUL:\r\n            case Opcodes.DMUL:\r\n            case Opcodes.IDIV:\r\n            case Opcodes.LDIV:\r\n            case Opcodes.FDIV:\r\n            case Opcodes.DDIV:\r\n            case Opcodes.IREM:\r\n            case Opcodes.LREM:\r\n            case Opcodes.FREM:\r\n            case Opcodes.DREM:\r\n            case Opcodes.INEG:\r\n            case Opcodes.LNEG:\r\n            case Opcodes.FNEG:\r\n            case Opcodes.DNEG:\r\n            case Opcodes.ISHL:\r\n            case Opcodes.LSHL:\r\n            case Opcodes.ISHR:\r\n            case Opcodes.LSHR:\r\n            case Opcodes.IUSHR:\r\n            case Opcodes.LUSHR:\r\n            case Opcodes.IAND:\r\n            case Opcodes.LAND:\r\n            case Opcodes.IOR:\r\n            case Opcodes.LOR:\r\n            case Opcodes.IXOR:\r\n            case Opcodes.LXOR:\r\n            case Opcodes.I2L:\r\n            case Opcodes.I2F:\r\n            case Opcodes.I2D:\r\n            case Opcodes.L2I:\r\n            case Opcodes.L2F:\r\n            case Opcodes.L2D:\r\n            case Opcodes.F2I:\r\n            case Opcodes.F2L:\r\n            case Opcodes.F2D:\r\n            case Opcodes.D2I:\r\n            case Opcodes.D2L:\r\n            case Opcodes.D2F:\r\n            case Opcodes.I2B:\r\n            case Opcodes.I2C:\r\n            case Opcodes.I2S:\r\n            case Opcodes.LCMP:\r\n            case Opcodes.FCMPL:\r\n            case Opcodes.FCMPG:\r\n            case Opcodes.DCMPL:\r\n            case Opcodes.DCMPG:\r\n            case Opcodes.IRETURN:\r\n            case Opcodes.LRETURN:\r\n            case Opcodes.FRETURN:\r\n            case Opcodes.DRETURN:\r\n            case Opcodes.ARETURN:\r\n            case Opcodes.RETURN:\r\n            case Opcodes.ARRAYLENGTH:\r\n            case Opcodes.ATHROW:\r\n            case Opcodes.MONITORENTER:\r\n            case Opcodes.MONITOREXIT:\r\n                methodVisitor.visitInsn(opcode);\r\n                currentOffset += 1;\r\n                break;\r\n            case Constants.ILOAD_0:\r\n            case Constants.ILOAD_1:\r\n            case Constants.ILOAD_2:\r\n            case Constants.ILOAD_3:\r\n            case Constants.LLOAD_0:\r\n            case Constants.LLOAD_1:\r\n            case Constants.LLOAD_2:\r\n            case Constants.LLOAD_3:\r\n            case Constants.FLOAD_0:\r\n            case Constants.FLOAD_1:\r\n            case Constants.FLOAD_2:\r\n            case Constants.FLOAD_3:\r\n            case Constants.DLOAD_0:\r\n            case Constants.DLOAD_1:\r\n            case Constants.DLOAD_2:\r\n            case Constants.DLOAD_3:\r\n            case Constants.ALOAD_0:\r\n            case Constants.ALOAD_1:\r\n            case Constants.ALOAD_2:\r\n            case Constants.ALOAD_3:\r\n                opcode -= Constants.ILOAD_0;\r\n                methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\r\n                currentOffset += 1;\r\n                break;\r\n            case Constants.ISTORE_0:\r\n            case Constants.ISTORE_1:\r\n            case Constants.ISTORE_2:\r\n            case Constants.ISTORE_3:\r\n            case Constants.LSTORE_0:\r\n            case Constants.LSTORE_1:\r\n            case Constants.LSTORE_2:\r\n            case Constants.LSTORE_3:\r\n            case Constants.FSTORE_0:\r\n            case Constants.FSTORE_1:\r\n            case Constants.FSTORE_2:\r\n            case Constants.FSTORE_3:\r\n            case Constants.DSTORE_0:\r\n            case Constants.DSTORE_1:\r\n            case Constants.DSTORE_2:\r\n            case Constants.DSTORE_3:\r\n            case Constants.ASTORE_0:\r\n            case Constants.ASTORE_1:\r\n            case Constants.ASTORE_2:\r\n            case Constants.ASTORE_3:\r\n                opcode -= Constants.ISTORE_0;\r\n                methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\r\n                currentOffset += 1;\r\n                break;\r\n            case Opcodes.IFEQ:\r\n            case Opcodes.IFNE:\r\n            case Opcodes.IFLT:\r\n            case Opcodes.IFGE:\r\n            case Opcodes.IFGT:\r\n            case Opcodes.IFLE:\r\n            case Opcodes.IF_ICMPEQ:\r\n            case Opcodes.IF_ICMPNE:\r\n            case Opcodes.IF_ICMPLT:\r\n            case Opcodes.IF_ICMPGE:\r\n            case Opcodes.IF_ICMPGT:\r\n            case Opcodes.IF_ICMPLE:\r\n            case Opcodes.IF_ACMPEQ:\r\n            case Opcodes.IF_ACMPNE:\r\n            case Opcodes.GOTO:\r\n            case Opcodes.JSR:\r\n            case Opcodes.IFNULL:\r\n            case Opcodes.IFNONNULL:\r\n                methodVisitor.visitJumpInsn(opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.GOTO_W:\r\n            case Constants.JSR_W:\r\n                methodVisitor.visitJumpInsn(opcode - wideJumpOpcodeDelta, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.ASM_IFEQ:\r\n            case Constants.ASM_IFNE:\r\n            case Constants.ASM_IFLT:\r\n            case Constants.ASM_IFGE:\r\n            case Constants.ASM_IFGT:\r\n            case Constants.ASM_IFLE:\r\n            case Constants.ASM_IF_ICMPEQ:\r\n            case Constants.ASM_IF_ICMPNE:\r\n            case Constants.ASM_IF_ICMPLT:\r\n            case Constants.ASM_IF_ICMPGE:\r\n            case Constants.ASM_IF_ICMPGT:\r\n            case Constants.ASM_IF_ICMPLE:\r\n            case Constants.ASM_IF_ACMPEQ:\r\n            case Constants.ASM_IF_ACMPNE:\r\n            case Constants.ASM_GOTO:\r\n            case Constants.ASM_JSR:\r\n            case Constants.ASM_IFNULL:\r\n            case Constants.ASM_IFNONNULL:\r\n                {\r\n                    // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\r\n                    // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\r\n                    // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\r\n                    // where <L> designates the instruction just after the GOTO_W.\r\n                    // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\r\n                    // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\r\n                    opcode = opcode < Constants.ASM_IFNULL ? opcode - Constants.ASM_OPCODE_DELTA : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\r\n                    Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\r\n                    if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\r\n                        // Replace GOTO with GOTO_W and JSR with JSR_W.\r\n                        methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\r\n                    } else {\r\n                        // Compute the \"opposite\" of opcode. This can be done by flipping the least\r\n                        // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\r\n                        // (with a pre and post offset by 1).\r\n                        opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\r\n                        Label endif = createLabel(currentBytecodeOffset + 3, labels);\r\n                        methodVisitor.visitJumpInsn(opcode, endif);\r\n                        methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\r\n                        // endif designates the instruction just after GOTO_W, and is visited as part of the\r\n                        // next instruction. Since it is a jump target, we need to insert a frame here.\r\n                        insertFrame = true;\r\n                    }\r\n                    currentOffset += 3;\r\n                    break;\r\n                }\r\n            case Constants.ASM_GOTO_W:\r\n                // Replace ASM_GOTO_W with GOTO_W.\r\n                methodVisitor.visitJumpInsn(Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\r\n                // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\r\n                // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\r\n                // here.\r\n                insertFrame = true;\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.WIDE:\r\n                opcode = classBuffer[currentOffset + 1] & 0xFF;\r\n                if (opcode == Opcodes.IINC) {\r\n                    methodVisitor.visitIincInsn(readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\r\n                    currentOffset += 6;\r\n                } else {\r\n                    methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\r\n                    currentOffset += 4;\r\n                }\r\n                break;\r\n            case Opcodes.TABLESWITCH:\r\n                {\r\n                    // Skip 0 to 3 padding bytes.\r\n                    currentOffset += 4 - (currentBytecodeOffset & 3);\r\n                    // Read the instruction.\r\n                    Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                    int low = readInt(currentOffset + 4);\r\n                    int high = readInt(currentOffset + 8);\r\n                    currentOffset += 12;\r\n                    Label[] table = new Label[high - low + 1];\r\n                    for (int i = 0; i < table.length; ++i) {\r\n                        table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                        currentOffset += 4;\r\n                    }\r\n                    methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\r\n                    break;\r\n                }\r\n            case Opcodes.LOOKUPSWITCH:\r\n                {\r\n                    // Skip 0 to 3 padding bytes.\r\n                    currentOffset += 4 - (currentBytecodeOffset & 3);\r\n                    // Read the instruction.\r\n                    Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                    int numPairs = readInt(currentOffset + 4);\r\n                    currentOffset += 8;\r\n                    int[] keys = new int[numPairs];\r\n                    Label[] values = new Label[numPairs];\r\n                    for (int i = 0; i < numPairs; ++i) {\r\n                        keys[i] = readInt(currentOffset);\r\n                        values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\r\n                        currentOffset += 8;\r\n                    }\r\n                    methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\r\n                    break;\r\n                }\r\n            case Opcodes.ILOAD:\r\n            case Opcodes.LLOAD:\r\n            case Opcodes.FLOAD:\r\n            case Opcodes.DLOAD:\r\n            case Opcodes.ALOAD:\r\n            case Opcodes.ISTORE:\r\n            case Opcodes.LSTORE:\r\n            case Opcodes.FSTORE:\r\n            case Opcodes.DSTORE:\r\n            case Opcodes.ASTORE:\r\n            case Opcodes.RET:\r\n                methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.BIPUSH:\r\n            case Opcodes.NEWARRAY:\r\n                methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.SIPUSH:\r\n                methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.LDC:\r\n                methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\r\n                currentOffset += 2;\r\n                break;\r\n            case Constants.LDC_W:\r\n            case Constants.LDC2_W:\r\n                methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.INVOKEINTERFACE:\r\n                {\r\n                    int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\r\n                    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n                    String owner = readClass(cpInfoOffset, charBuffer);\r\n                    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n                    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n                    if (opcode < Opcodes.INVOKEVIRTUAL) {\r\n                        methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\r\n                    } else {\r\n                        boolean isInterface = classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\r\n                        methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\r\n                    }\r\n                    if (opcode == Opcodes.INVOKEINTERFACE) {\r\n                        currentOffset += 5;\r\n                    } else {\r\n                        currentOffset += 3;\r\n                    }\r\n                    break;\r\n                }\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                {\r\n                    int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\r\n                    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n                    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n                    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n                    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\r\n                    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n                    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\r\n                    bootstrapMethodOffset += 4;\r\n                    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\r\n                        bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n                        bootstrapMethodOffset += 2;\r\n                    }\r\n                    methodVisitor.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);\r\n                    currentOffset += 5;\r\n                    break;\r\n                }\r\n            case Opcodes.NEW:\r\n            case Opcodes.ANEWARRAY:\r\n            case Opcodes.CHECKCAST:\r\n            case Opcodes.INSTANCEOF:\r\n                methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.IINC:\r\n                methodVisitor.visitIincInsn(classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.MULTIANEWARRAY:\r\n                methodVisitor.visitMultiANewArrayInsn(readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\r\n                currentOffset += 4;\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n        // Visit the runtime visible instruction annotations, if any.\r\n        while (visibleTypeAnnotationOffsets != null && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\r\n            if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                int currentAnnotationOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n                currentAnnotationOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n                true), currentAnnotationOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n            currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\r\n        }\r\n        // Visit the runtime invisible instruction annotations, if any.\r\n        while (invisibleTypeAnnotationOffsets != null && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\r\n            if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                int currentAnnotationOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n                currentAnnotationOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n                false), currentAnnotationOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n            currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\r\n        }\r\n    }\r\n    if (labels[codeLength] != null) {\r\n        methodVisitor.visitLabel(labels[codeLength]);\r\n    }\r\n    // Visit LocalVariableTable and LocalVariableTypeTable attributes.\r\n    if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\r\n        // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\r\n        int[] typeTable = null;\r\n        if (localVariableTypeTableOffset != 0) {\r\n            typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\r\n            currentOffset = localVariableTypeTableOffset + 2;\r\n            int typeTableIndex = typeTable.length;\r\n            while (typeTableIndex > 0) {\r\n                // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\r\n                typeTable[--typeTableIndex] = currentOffset + 6;\r\n                typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\r\n                typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\r\n                currentOffset += 10;\r\n            }\r\n        }\r\n        int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\r\n        currentOffset = localVariableTableOffset + 2;\r\n        while (localVariableTableLength-- > 0) {\r\n            int startPc = readUnsignedShort(currentOffset);\r\n            int length = readUnsignedShort(currentOffset + 2);\r\n            String name = readUTF8(currentOffset + 4, charBuffer);\r\n            String descriptor = readUTF8(currentOffset + 6, charBuffer);\r\n            int index = readUnsignedShort(currentOffset + 8);\r\n            currentOffset += 10;\r\n            String signature = null;\r\n            if (typeTable != null) {\r\n                for (int i = 0; i < typeTable.length; i += 3) {\r\n                    if (typeTable[i] == startPc && typeTable[i + 1] == index) {\r\n                        signature = readUTF8(typeTable[i + 2], charBuffer);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            methodVisitor.visitLocalVariable(name, descriptor, signature, labels[startPc], labels[startPc + length], index);\r\n        }\r\n    }\r\n    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\r\n    if (visibleTypeAnnotationOffsets != null) {\r\n        for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\r\n            int targetType = readByte(typeAnnotationOffset);\r\n            if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n                currentOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor, /* visible= */\r\n                true), currentOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n        }\r\n    }\r\n    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (invisibleTypeAnnotationOffsets != null) {\r\n        for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\r\n            int targetType = readByte(typeAnnotationOffset);\r\n            if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n                currentOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor, /* visible= */\r\n                false), currentOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        methodVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the max stack and max locals values.\r\n    methodVisitor.visitMaxs(maxStack, maxLocals);\r\n}\n/**\r\n * Handles the bytecode offset of the next instruction to be visited in {@link\r\n * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\r\n * associated label and stack map frame, if any. The default implementation of this method does\r\n * nothing. Subclasses can override this method to store the argument in a mutable field, for\r\n * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\r\n * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\r\n *\r\n * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\r\n */\r\nprotected void readBytecodeInstructionOffset(final int bytecodeOffset) {\r\n    // Do nothing by default.\r\n}\n/**\r\n * Returns the label corresponding to the given bytecode offset. The default implementation of\r\n * this method creates a label for the given offset if it has not been already created.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset. If a label already exists\r\n *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\r\n *     label in this array.\r\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\r\n */\r\nprotected Label readLabel(final int bytecodeOffset, final Label[] labels) {\r\n    // SPRING PATCH: leniently handle offset mismatch\r\n    if (bytecodeOffset >= labels.length) {\r\n        return new Label();\r\n    }\r\n    // END OF PATCH\r\n    if (labels[bytecodeOffset] == null) {\r\n        labels[bytecodeOffset] = new Label();\r\n    }\r\n    return labels[bytecodeOffset];\r\n}\n/**\r\n * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\r\n * offset. The label is created with a call to {@link #readLabel} and its {@link\r\n * Label#FLAG_DEBUG_ONLY} flag is cleared.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset.\r\n * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\r\n */\r\nprivate Label createLabel(final int bytecodeOffset, final Label[] labels) {\r\n    Label label = readLabel(bytecodeOffset, labels);\r\n    label.flags &= ~Label.FLAG_DEBUG_ONLY;\r\n    return label;\r\n}\n/**\r\n * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\r\n * existing label for the given bytecode offset (otherwise does nothing). The label is created\r\n * with a call to {@link #readLabel}.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset.\r\n */\r\nprivate void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\r\n    if (labels[bytecodeOffset] == null) {\r\n        readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\r\n    }\r\n}\n// ----------------------------------------------------------------------------------------------\r\n// Methods to parse annotations, type annotations and parameter annotations\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\r\n * entry it contains, to find the corresponding labels, and to visit the try catch block\r\n * annotations.\r\n *\r\n * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\r\n * @param context information about the class being parsed.\r\n * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\r\n *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\r\n * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\r\n *     false it is a RuntimeInvisibleTypeAnnotations attribute.\r\n * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\r\n *     'annotations' array field.\r\n */\r\nprivate int[] readTypeAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeTypeAnnotationsOffset, final boolean visible) {\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = runtimeTypeAnnotationsOffset;\r\n    // Read the num_annotations field and create an array to store the type_annotation offsets.\r\n    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\r\n    currentOffset += 2;\r\n    // Parse the 'annotations' array field.\r\n    for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\r\n        typeAnnotationsOffsets[i] = currentOffset;\r\n        // Parse the type_annotation's target_type and the target_info fields. The size of the\r\n        // target_info field depends on the value of target_type.\r\n        int targetType = readInt(currentOffset);\r\n        switch(targetType >>> 24) {\r\n            case TypeReference.LOCAL_VARIABLE:\r\n            case TypeReference.RESOURCE_VARIABLE:\r\n                // A localvar_target has a variable size, which depends on the value of their table_length\r\n                // field. It also references bytecode offsets, for which we need labels.\r\n                int tableLength = readUnsignedShort(currentOffset + 1);\r\n                currentOffset += 3;\r\n                while (tableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentOffset);\r\n                    int length = readUnsignedShort(currentOffset + 2);\r\n                    // Skip the index field (2 bytes).\r\n                    currentOffset += 6;\r\n                    createLabel(startPc, context.currentMethodLabels);\r\n                    createLabel(startPc + length, context.currentMethodLabels);\r\n                }\r\n                break;\r\n            case TypeReference.CAST:\r\n            case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n            case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\r\n            case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n            case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\r\n                currentOffset += 4;\r\n                break;\r\n            case TypeReference.CLASS_EXTENDS:\r\n            case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\r\n            case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\r\n            case TypeReference.THROWS:\r\n            case TypeReference.EXCEPTION_PARAMETER:\r\n            case TypeReference.INSTANCEOF:\r\n            case TypeReference.NEW:\r\n            case TypeReference.CONSTRUCTOR_REFERENCE:\r\n            case TypeReference.METHOD_REFERENCE:\r\n                currentOffset += 3;\r\n                break;\r\n            case TypeReference.CLASS_TYPE_PARAMETER:\r\n            case TypeReference.METHOD_TYPE_PARAMETER:\r\n            case TypeReference.METHOD_FORMAL_PARAMETER:\r\n            case TypeReference.FIELD:\r\n            case TypeReference.METHOD_RETURN:\r\n            case TypeReference.METHOD_RECEIVER:\r\n            default:\r\n                // TypeReference type which can't be used in Code attribute, or which is unknown.\r\n                throw new IllegalArgumentException();\r\n        }\r\n        // Parse the rest of the type_annotation structure, starting with the target_path structure\r\n        // (whose size depends on its path_length field).\r\n        int pathLength = readByte(currentOffset);\r\n        if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\r\n            // Parse the target_path structure and create a corresponding TypePath.\r\n            TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\r\n            currentOffset += 1 + 2 * pathLength;\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentOffset = readElementValues(methodVisitor.visitTryCatchAnnotation(targetType & 0xFFFFFF00, path, annotationDescriptor, visible), currentOffset, /* named= */\r\n            true, charBuffer);\r\n        } else {\r\n            // We don't want to visit the other target_type annotations, so we just skip them (which\r\n            // requires some parsing because the element_value_pairs array has a variable size). First,\r\n            // skip the target_path structure:\r\n            currentOffset += 3 + 2 * pathLength;\r\n            // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\r\n            // with a null AnnotationVisitor).\r\n            currentOffset = readElementValues(/* annotationVisitor= */\r\n            null, currentOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    return typeAnnotationsOffsets;\r\n}\n/**\r\n * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\r\n * -1 if there is no such type_annotation of if it does not have a bytecode offset.\r\n *\r\n * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\r\n *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\r\n * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\r\n * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\r\n *     if there is no such type_annotation of if it does not have a bytecode offset.\r\n */\r\nprivate int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\r\n    if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\r\n        return -1;\r\n    }\r\n    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\r\n}\n/**\r\n * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\r\n * and target_path (the result is stored in the given context), and returns the start offset of\r\n * the rest of the type_annotation structure.\r\n *\r\n * @param context information about the class being parsed. This is where the extracted\r\n *     target_type and target_path must be stored.\r\n * @param typeAnnotationOffset the start offset of a type_annotation structure.\r\n * @return the start offset of the rest of the type_annotation structure.\r\n */\r\nprivate int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\r\n    int currentOffset = typeAnnotationOffset;\r\n    // Parse and store the target_type structure.\r\n    int targetType = readInt(typeAnnotationOffset);\r\n    switch(targetType >>> 24) {\r\n        case TypeReference.CLASS_TYPE_PARAMETER:\r\n        case TypeReference.METHOD_TYPE_PARAMETER:\r\n        case TypeReference.METHOD_FORMAL_PARAMETER:\r\n            targetType &= 0xFFFF0000;\r\n            currentOffset += 2;\r\n            break;\r\n        case TypeReference.FIELD:\r\n        case TypeReference.METHOD_RETURN:\r\n        case TypeReference.METHOD_RECEIVER:\r\n            targetType &= 0xFF000000;\r\n            currentOffset += 1;\r\n            break;\r\n        case TypeReference.LOCAL_VARIABLE:\r\n        case TypeReference.RESOURCE_VARIABLE:\r\n            targetType &= 0xFF000000;\r\n            int tableLength = readUnsignedShort(currentOffset + 1);\r\n            currentOffset += 3;\r\n            context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\r\n            context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\r\n            context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\r\n            for (int i = 0; i < tableLength; ++i) {\r\n                int startPc = readUnsignedShort(currentOffset);\r\n                int length = readUnsignedShort(currentOffset + 2);\r\n                int index = readUnsignedShort(currentOffset + 4);\r\n                currentOffset += 6;\r\n                context.currentLocalVariableAnnotationRangeStarts[i] = createLabel(startPc, context.currentMethodLabels);\r\n                context.currentLocalVariableAnnotationRangeEnds[i] = createLabel(startPc + length, context.currentMethodLabels);\r\n                context.currentLocalVariableAnnotationRangeIndices[i] = index;\r\n            }\r\n            break;\r\n        case TypeReference.CAST:\r\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\r\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\r\n            targetType &= 0xFF0000FF;\r\n            currentOffset += 4;\r\n            break;\r\n        case TypeReference.CLASS_EXTENDS:\r\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\r\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\r\n        case TypeReference.THROWS:\r\n        case TypeReference.EXCEPTION_PARAMETER:\r\n            targetType &= 0xFFFFFF00;\r\n            currentOffset += 3;\r\n            break;\r\n        case TypeReference.INSTANCEOF:\r\n        case TypeReference.NEW:\r\n        case TypeReference.CONSTRUCTOR_REFERENCE:\r\n        case TypeReference.METHOD_REFERENCE:\r\n            targetType &= 0xFF000000;\r\n            currentOffset += 3;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    context.currentTypeAnnotationTarget = targetType;\r\n    // Parse and store the target_path structure.\r\n    int pathLength = readByte(currentOffset);\r\n    context.currentTypeAnnotationTargetPath = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\r\n    // Return the start offset of the rest of the type_annotation structure.\r\n    return currentOffset + 1 + 2 * pathLength;\r\n}\n/**\r\n * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\r\n *\r\n * @param methodVisitor the visitor that must visit the parameter annotations.\r\n * @param context information about the class being parsed.\r\n * @param runtimeParameterAnnotationsOffset the start offset of a\r\n *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\r\n *     attribute_name_index and attribute_length fields.\r\n * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\r\n *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\r\n */\r\nprivate void readParameterAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeParameterAnnotationsOffset, final boolean visible) {\r\n    int currentOffset = runtimeParameterAnnotationsOffset;\r\n    int numParameters = classFileBuffer[currentOffset++] & 0xFF;\r\n    methodVisitor.visitAnnotableParameterCount(numParameters, visible);\r\n    char[] charBuffer = context.charBuffer;\r\n    for (int i = 0; i < numParameters; ++i) {\r\n        int numAnnotations = readUnsignedShort(currentOffset);\r\n        currentOffset += 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentOffset = readElementValues(methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible), currentOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n}\n/**\r\n * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\r\n * them. This method can also be used to read the values of the JVMS 'array_value' field of an\r\n * annotation's 'element_value'.\r\n *\r\n * @param annotationVisitor the visitor that must visit the values.\r\n * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\r\n *     field) or of an 'array_value' structure.\r\n * @param named if the annotation values are named or not. This should be true to parse the values\r\n *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\r\n *     annotation's element_value.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\r\n */\r\nprivate int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\r\n    int currentOffset = annotationOffset;\r\n    // Read the num_element_value_pairs field (or num_values field for an array_value).\r\n    int numElementValuePairs = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    if (named) {\r\n        // Parse the element_value_pairs array.\r\n        while (numElementValuePairs-- > 0) {\r\n            String elementName = readUTF8(currentOffset, charBuffer);\r\n            currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\r\n        }\r\n    } else {\r\n        // Parse the array_value array.\r\n        while (numElementValuePairs-- > 0) {\r\n            currentOffset = readElementValue(annotationVisitor, currentOffset, /* elementName= */\r\n            null, charBuffer);\r\n        }\r\n    }\r\n    if (annotationVisitor != null) {\r\n        annotationVisitor.visitEnd();\r\n    }\r\n    return currentOffset;\r\n}\n/**\r\n * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\r\n *\r\n * @param annotationVisitor the visitor that must visit the element_value structure.\r\n * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\r\n *     structure to be read.\r\n * @param elementName the name of the element_value structure to be read, or {@literal null}.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @return the end offset of the JVMS 'element_value' structure.\r\n */\r\nprivate int readElementValue(final AnnotationVisitor annotationVisitor, final int elementValueOffset, final String elementName, final char[] charBuffer) {\r\n    int currentOffset = elementValueOffset;\r\n    if (annotationVisitor == null) {\r\n        switch(classFileBuffer[currentOffset] & 0xFF) {\r\n            case // enum_const_value\r\n            'e':\r\n                return currentOffset + 5;\r\n            case // annotation_value\r\n            '@':\r\n                return readElementValues(null, currentOffset + 3, /* named= */\r\n                true, charBuffer);\r\n            case // array_value\r\n            '[':\r\n                return readElementValues(null, currentOffset + 1, /* named= */\r\n                false, charBuffer);\r\n            default:\r\n                return currentOffset + 3;\r\n        }\r\n    }\r\n    switch(classFileBuffer[currentOffset++] & 0xFF) {\r\n        case // const_value_index, CONSTANT_Integer\r\n        'B':\r\n            annotationVisitor.visit(elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'C':\r\n            annotationVisitor.visit(elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        // const_value_index, CONSTANT_Double\r\n        case 'D':\r\n        // const_value_index, CONSTANT_Float\r\n        case 'F':\r\n        // const_value_index, CONSTANT_Integer\r\n        case 'I':\r\n        case // const_value_index, CONSTANT_Long\r\n        'J':\r\n            annotationVisitor.visit(elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'S':\r\n            annotationVisitor.visit(elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'Z':\r\n            annotationVisitor.visit(elementName, readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Utf8\r\n        's':\r\n            annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\r\n            currentOffset += 2;\r\n            break;\r\n        case // enum_const_value\r\n        'e':\r\n            annotationVisitor.visitEnum(elementName, readUTF8(currentOffset, charBuffer), readUTF8(currentOffset + 2, charBuffer));\r\n            currentOffset += 4;\r\n            break;\r\n        case // class_info\r\n        'c':\r\n            annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\r\n            currentOffset += 2;\r\n            break;\r\n        case // annotation_value\r\n        '@':\r\n            currentOffset = readElementValues(annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)), currentOffset + 2, true, charBuffer);\r\n            break;\r\n        case // array_value\r\n        '[':\r\n            int numValues = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            if (numValues == 0) {\r\n                return readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2, /* named= */\r\n                false, charBuffer);\r\n            }\r\n            switch(classFileBuffer[currentOffset] & 0xFF) {\r\n                case 'B':\r\n                    byte[] byteValues = new byte[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, byteValues);\r\n                    break;\r\n                case 'Z':\r\n                    boolean[] booleanValues = new boolean[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, booleanValues);\r\n                    break;\r\n                case 'S':\r\n                    short[] shortValues = new short[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, shortValues);\r\n                    break;\r\n                case 'C':\r\n                    char[] charValues = new char[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, charValues);\r\n                    break;\r\n                case 'I':\r\n                    int[] intValues = new int[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, intValues);\r\n                    break;\r\n                case 'J':\r\n                    long[] longValues = new long[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, longValues);\r\n                    break;\r\n                case 'F':\r\n                    float[] floatValues = new float[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        floatValues[i] = Float.intBitsToFloat(readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, floatValues);\r\n                    break;\r\n                case 'D':\r\n                    double[] doubleValues = new double[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        doubleValues[i] = Double.longBitsToDouble(readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, doubleValues);\r\n                    break;\r\n                default:\r\n                    currentOffset = readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2, /* named= */\r\n                    false, charBuffer);\r\n                    break;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    return currentOffset;\r\n}\n// ----------------------------------------------------------------------------------------------\r\n// Methods to parse stack map frames\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Computes the implicit frame of the method currently being parsed (as defined in the given\r\n * {@link Context}) and stores it in the given context.\r\n *\r\n * @param context information about the class being parsed.\r\n */\r\nprivate void computeImplicitFrame(final Context context) {\r\n    String methodDescriptor = context.currentMethodDescriptor;\r\n    Object[] locals = context.currentFrameLocalTypes;\r\n    int numLocal = 0;\r\n    if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\r\n        if (\"<init>\".equals(context.currentMethodName)) {\r\n            locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\r\n        } else {\r\n            locals[numLocal++] = readClass(header + 2, context.charBuffer);\r\n        }\r\n    }\r\n    // Parse the method descriptor, one argument type descriptor at each iteration. Start by\r\n    // skipping the first method descriptor character, which is always '('.\r\n    int currentMethodDescritorOffset = 1;\r\n    while (true) {\r\n        int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\r\n        switch(methodDescriptor.charAt(currentMethodDescritorOffset++)) {\r\n            case 'Z':\r\n            case 'C':\r\n            case 'B':\r\n            case 'S':\r\n            case 'I':\r\n                locals[numLocal++] = Opcodes.INTEGER;\r\n                break;\r\n            case 'F':\r\n                locals[numLocal++] = Opcodes.FLOAT;\r\n                break;\r\n            case 'J':\r\n                locals[numLocal++] = Opcodes.LONG;\r\n                break;\r\n            case 'D':\r\n                locals[numLocal++] = Opcodes.DOUBLE;\r\n                break;\r\n            case '[':\r\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\r\n                    ++currentMethodDescritorOffset;\r\n                }\r\n                if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\r\n                    ++currentMethodDescritorOffset;\r\n                    while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\r\n                        ++currentMethodDescritorOffset;\r\n                    }\r\n                }\r\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\r\n                break;\r\n            case 'L':\r\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\r\n                    ++currentMethodDescritorOffset;\r\n                }\r\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\r\n                break;\r\n            default:\r\n                context.currentFrameLocalCount = numLocal;\r\n                return;\r\n        }\r\n    }\r\n}\n/**\r\n * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\r\n * object. This method can also be used to read a full_frame structure, excluding its frame_type\r\n * field (this is used to parse the legacy StackMap attributes).\r\n *\r\n * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\r\n *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\r\n *     (excluding its frame_type field).\r\n * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\r\n *     structure without its frame_type field.\r\n * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\r\n * @param context where the parsed stack map frame must be stored.\r\n * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\r\n */\r\nprivate int readStackMapFrame(final int stackMapFrameOffset, final boolean compressed, final boolean expand, final Context context) {\r\n    int currentOffset = stackMapFrameOffset;\r\n    final char[] charBuffer = context.charBuffer;\r\n    final Label[] labels = context.currentMethodLabels;\r\n    int frameType;\r\n    if (compressed) {\r\n        // Read the frame_type field.\r\n        frameType = classFileBuffer[currentOffset++] & 0xFF;\r\n    } else {\r\n        frameType = Frame.FULL_FRAME;\r\n        context.currentFrameOffset = -1;\r\n    }\r\n    int offsetDelta;\r\n    context.currentFrameLocalCountDelta = 0;\r\n    if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\r\n        offsetDelta = frameType;\r\n        context.currentFrameType = Opcodes.F_SAME;\r\n        context.currentFrameStackCount = 0;\r\n    } else if (frameType < Frame.RESERVED) {\r\n        offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\r\n        currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\r\n        context.currentFrameType = Opcodes.F_SAME1;\r\n        context.currentFrameStackCount = 1;\r\n    } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\r\n        offsetDelta = readUnsignedShort(currentOffset);\r\n        currentOffset += 2;\r\n        if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\r\n            currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\r\n            context.currentFrameType = Opcodes.F_SAME1;\r\n            context.currentFrameStackCount = 1;\r\n        } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\r\n            context.currentFrameType = Opcodes.F_CHOP;\r\n            context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\r\n            context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\r\n            context.currentFrameStackCount = 0;\r\n        } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\r\n            context.currentFrameType = Opcodes.F_SAME;\r\n            context.currentFrameStackCount = 0;\r\n        } else if (frameType < Frame.FULL_FRAME) {\r\n            int local = expand ? context.currentFrameLocalCount : 0;\r\n            for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\r\n            }\r\n            context.currentFrameType = Opcodes.F_APPEND;\r\n            context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\r\n            context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\r\n            context.currentFrameStackCount = 0;\r\n        } else {\r\n            final int numberOfLocals = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            context.currentFrameType = Opcodes.F_FULL;\r\n            context.currentFrameLocalCountDelta = numberOfLocals;\r\n            context.currentFrameLocalCount = numberOfLocals;\r\n            for (int local = 0; local < numberOfLocals; ++local) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\r\n            }\r\n            final int numberOfStackItems = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            context.currentFrameStackCount = numberOfStackItems;\r\n            for (int stack = 0; stack < numberOfStackItems; ++stack) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\r\n            }\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    context.currentFrameOffset += offsetDelta + 1;\r\n    createLabel(context.currentFrameOffset, labels);\r\n    return currentOffset;\r\n}\n/**\r\n * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\r\n * array.\r\n *\r\n * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\r\n *     read.\r\n * @param frame the array where the parsed type must be stored.\r\n * @param index the index in 'frame' where the parsed type must be stored.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @param labels the labels of the method currently being parsed, indexed by their offset. If the\r\n *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\r\n *     stored in this array if it does not already exist.\r\n * @return the end offset of the JVMS 'verification_type_info' structure.\r\n */\r\nprivate int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\r\n    int currentOffset = verificationTypeInfoOffset;\r\n    int tag = classFileBuffer[currentOffset++] & 0xFF;\r\n    switch(tag) {\r\n        case Frame.ITEM_TOP:\r\n            frame[index] = Opcodes.TOP;\r\n            break;\r\n        case Frame.ITEM_INTEGER:\r\n            frame[index] = Opcodes.INTEGER;\r\n            break;\r\n        case Frame.ITEM_FLOAT:\r\n            frame[index] = Opcodes.FLOAT;\r\n            break;\r\n        case Frame.ITEM_DOUBLE:\r\n            frame[index] = Opcodes.DOUBLE;\r\n            break;\r\n        case Frame.ITEM_LONG:\r\n            frame[index] = Opcodes.LONG;\r\n            break;\r\n        case Frame.ITEM_NULL:\r\n            frame[index] = Opcodes.NULL;\r\n            break;\r\n        case Frame.ITEM_UNINITIALIZED_THIS:\r\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\r\n            break;\r\n        case Frame.ITEM_OBJECT:\r\n            frame[index] = readClass(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            break;\r\n        case Frame.ITEM_UNINITIALIZED:\r\n            frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\r\n            currentOffset += 2;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    return currentOffset;\r\n}\n// ----------------------------------------------------------------------------------------------\r\n// Methods to parse attributes\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\r\n * field entry.\r\n *\r\n * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\r\n *     field entry.\r\n */\r\nfinal int getFirstAttributeOffset() {\r\n    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\r\n    // each), as well as the interfaces array field (2 bytes per interface).\r\n    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\r\n    // Read the fields_count field.\r\n    int fieldsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    // Skip the 'fields' array field.\r\n    while (fieldsCount-- > 0) {\r\n        // Invariant: currentOffset is the offset of a field_info structure.\r\n        // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\r\n        // attributes_count field.\r\n        int attributesCount = readUnsignedShort(currentOffset + 6);\r\n        currentOffset += 8;\r\n        // Skip the 'attributes' array field.\r\n        while (attributesCount-- > 0) {\r\n            // Invariant: currentOffset is the offset of an attribute_info structure.\r\n            // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\r\n            // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\r\n            // (yielding the total size of the attribute_info structure).\r\n            currentOffset += 6 + readInt(currentOffset + 2);\r\n        }\r\n    }\r\n    // Skip the methods_count and 'methods' fields, using the same method as above.\r\n    int methodsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (methodsCount-- > 0) {\r\n        int attributesCount = readUnsignedShort(currentOffset + 6);\r\n        currentOffset += 8;\r\n        while (attributesCount-- > 0) {\r\n            currentOffset += 6 + readInt(currentOffset + 2);\r\n        }\r\n    }\r\n    // Skip the ClassFile's attributes_count field.\r\n    return currentOffset + 2;\r\n}\n/**\r\n * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\r\n *\r\n * @param maxStringLength a conservative estimate of the maximum length of the strings contained\r\n *     in the constant pool of the class.\r\n * @return the offsets of the bootstrap methods.\r\n */\r\nprivate int[] readBootstrapMethodsAttribute(final int maxStringLength) {\r\n    char[] charBuffer = new char[maxStringLength];\r\n    int currentAttributeOffset = getFirstAttributeOffset();\r\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentAttributeOffset, charBuffer);\r\n        int attributeLength = readInt(currentAttributeOffset + 2);\r\n        currentAttributeOffset += 6;\r\n        if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            // Read the num_bootstrap_methods field and create an array of this size.\r\n            int[] result = new int[readUnsignedShort(currentAttributeOffset)];\r\n            // Compute and store the offset of each 'bootstrap_methods' array field entry.\r\n            int currentBootstrapMethodOffset = currentAttributeOffset + 2;\r\n            for (int j = 0; j < result.length; ++j) {\r\n                result[j] = currentBootstrapMethodOffset;\r\n                // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\r\n                // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\r\n                currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\r\n            }\r\n            return result;\r\n        }\r\n        currentAttributeOffset += attributeLength;\r\n    }\r\n    throw new IllegalArgumentException();\r\n}\n/**\r\n * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\r\n *\r\n * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\r\n *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\r\n *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\r\n * @param type the type of the attribute.\r\n * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\r\n *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to read strings in the constant pool.\r\n * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\r\n *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a code attribute.\r\n * @return the attribute that has been read.\r\n */\r\nprivate Attribute readAttribute(final Attribute[] attributePrototypes, final String type, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    for (Attribute attributePrototype : attributePrototypes) {\r\n        if (attributePrototype.type.equals(type)) {\r\n            return attributePrototype.read(this, offset, length, charBuffer, codeAttributeOffset, labels);\r\n        }\r\n    }\r\n    return new Attribute(type).read(this, offset, length, null, -1, null);\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods: low level parsing\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the number of entries in the class's constant pool table.\r\n *\r\n * @return the number of entries in the class's constant pool table.\r\n */\r\npublic int getItemCount() {\r\n    return cpInfoOffsets.length;\r\n}\n/**\r\n * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\r\n * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\r\n *     table.\r\n * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\r\n *     structure, plus one.\r\n */\r\npublic int getItem(final int constantPoolEntryIndex) {\r\n    return cpInfoOffsets[constantPoolEntryIndex];\r\n}\n/**\r\n * Returns a conservative estimate of the maximum length of the strings contained in the class's\r\n * constant pool table.\r\n *\r\n * @return a conservative estimate of the maximum length of the strings contained in the class's\r\n *     constant pool table.\r\n */\r\npublic int getMaxStringLength() {\r\n    return maxStringLength;\r\n}\n/**\r\n * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic int readByte(final int offset) {\r\n    return classFileBuffer[offset] & 0xFF;\r\n}\n/**\r\n * Reads several bytes in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the bytes to be read in this {@link ClassReader}.\r\n * @param length the number of bytes to read.\r\n * @return the read bytes.\r\n */\r\npublic byte[] readBytes(final int offset, final int length) {\r\n    byte[] result = new byte[length];\r\n    System.arraycopy(classFileBuffer, offset, result, 0, length);\r\n    return result;\r\n}\n/**\r\n * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\r\n * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start index of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic int readUnsignedShort(final int offset) {\r\n    byte[] classBuffer = classFileBuffer;\r\n    return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);\r\n}\n/**\r\n * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic short readShort(final int offset) {\r\n    byte[] classBuffer = classFileBuffer;\r\n    return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));\r\n}\n/**\r\n * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic int readInt(final int offset) {\r\n    byte[] classBuffer = classFileBuffer;\r\n    return ((classBuffer[offset] & 0xFF) << 24) | ((classBuffer[offset + 1] & 0xFF) << 16) | ((classBuffer[offset + 2] & 0xFF) << 8) | (classBuffer[offset + 3] & 0xFF);\r\n}\n/**\r\n * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic long readLong(final int offset) {\r\n    long l1 = readInt(offset);\r\n    long l0 = readInt(offset + 4) & 0xFFFFFFFFL;\r\n    return (l1 << 32) | l0;\r\n}\n/**\r\n * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\r\n */\r\n// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\r\npublic String readUTF8(final int offset, final char[] charBuffer) {\r\n    int constantPoolEntryIndex = readUnsignedShort(offset);\r\n    if (offset == 0 || constantPoolEntryIndex == 0) {\r\n        return null;\r\n    }\r\n    return readUtf(constantPoolEntryIndex, charBuffer);\r\n}\n/**\r\n * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\r\n *     table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\r\n */\r\nfinal String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    String value = constantUtf8Values[constantPoolEntryIndex];\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    return constantUtf8Values[constantPoolEntryIndex] = readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);\r\n}\n/**\r\n * Reads an UTF8 string in {@link #classFileBuffer}.\r\n *\r\n * @param utfOffset the start offset of the UTF8 string to be read.\r\n * @param utfLength the length of the UTF8 string to be read.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified UTF8 string.\r\n */\r\nprivate String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\r\n    int currentOffset = utfOffset;\r\n    int endOffset = currentOffset + utfLength;\r\n    int strLength = 0;\r\n    byte[] classBuffer = classFileBuffer;\r\n    while (currentOffset < endOffset) {\r\n        int currentByte = classBuffer[currentOffset++];\r\n        if ((currentByte & 0x80) == 0) {\r\n            charBuffer[strLength++] = (char) (currentByte & 0x7F);\r\n        } else if ((currentByte & 0xE0) == 0xC0) {\r\n            charBuffer[strLength++] = (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\r\n        } else {\r\n            charBuffer[strLength++] = (char) (((currentByte & 0xF) << 12) + ((classBuffer[currentOffset++] & 0x3F) << 6) + (classBuffer[currentOffset++] & 0x3F));\r\n        }\r\n    }\r\n    return new String(charBuffer, 0, strLength);\r\n}\n/**\r\n * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\r\n * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\r\n * for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\r\n *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\r\n *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified constant pool entry.\r\n */\r\nprivate String readStringish(final int offset, final char[] charBuffer) {\r\n    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\r\n    // designated by the first two bytes of this cp_info.\r\n    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\r\n}\n/**\r\n * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Class entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Class entry.\r\n */\r\npublic String readClass(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}\n/**\r\n * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Module entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Module entry.\r\n */\r\npublic String readModule(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}\n/**\r\n * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Package entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Package entry.\r\n */\r\npublic String readPackage(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}\n/**\r\n * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\r\n *     pool table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\r\n */\r\nprivate ConstantDynamic readConstantDynamic(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\r\n    if (constantDynamic != null) {\r\n        return constantDynamic;\r\n    }\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\r\n    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\r\n    bootstrapMethodOffset += 4;\r\n    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\r\n        bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n        bootstrapMethodOffset += 2;\r\n    }\r\n    return constantDynamicValues[constantPoolEntryIndex] = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\r\n}\n/**\r\n * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\r\n *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\r\n *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\r\n * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\r\n *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\r\n *     constant pool entry.\r\n */\r\npublic Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    switch(classFileBuffer[cpInfoOffset - 1]) {\r\n        case Symbol.CONSTANT_INTEGER_TAG:\r\n            return readInt(cpInfoOffset);\r\n        case Symbol.CONSTANT_FLOAT_TAG:\r\n            return Float.intBitsToFloat(readInt(cpInfoOffset));\r\n        case Symbol.CONSTANT_LONG_TAG:\r\n            return readLong(cpInfoOffset);\r\n        case Symbol.CONSTANT_DOUBLE_TAG:\r\n            return Double.longBitsToDouble(readLong(cpInfoOffset));\r\n        case Symbol.CONSTANT_CLASS_TAG:\r\n            return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\r\n        case Symbol.CONSTANT_STRING_TAG:\r\n            return readUTF8(cpInfoOffset, charBuffer);\r\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n            return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\r\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n            int referenceKind = readByte(cpInfoOffset);\r\n            int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\r\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\r\n            String owner = readClass(referenceCpInfoOffset, charBuffer);\r\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n            boolean isInterface = classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\r\n            return new Handle(referenceKind, owner, name, descriptor, isInterface);\r\n        case Symbol.CONSTANT_DYNAMIC_TAG:\r\n            return readConstantDynamic(constantPoolEntryIndex, charBuffer);\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "comment": "\n * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java\n * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the\n * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode\n * instruction encountered.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html\">JVMS 4</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Reads the given input stream and returns its content as a byte array.\r\n *\r\n * @param inputStream an input stream.\r\n * @param close true to close the input stream after reading.\r\n * @return the content of the given input stream.\r\n * @throws IOException if a problem occurs during reading.\r\n */\r\n@SuppressWarnings(\"PMD.UseTryWithResources\")\r\nprivate static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException {\r\n    if (inputStream == null) {\r\n        throw new IOException(\"Class not found\");\r\n    }\r\n    int bufferSize = computeBufferSize(inputStream);\r\n    try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {\r\n        byte[] data = new byte[bufferSize];\r\n        int bytesRead;\r\n        int readCount = 0;\r\n        while ((bytesRead = inputStream.read(data, 0, bufferSize)) != -1) {\r\n            outputStream.write(data, 0, bytesRead);\r\n            readCount++;\r\n        }\r\n        outputStream.flush();\r\n        if (readCount == 1) {\r\n            // SPRING PATCH: some misbehaving InputStreams return -1 but still write to buffer (gh-27429)\r\n            // return data;\r\n            // END OF PATCH\r\n        }\r\n        return outputStream.toByteArray();\r\n    } finally {\r\n        if (close) {\r\n            inputStream.close();\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Reads the given input stream and returns its content as a byte array.\n   *\n   * @param inputStream an input stream.\n   * @param close true to close the input stream after reading.\n   * @return the content of the given input stream.\n   * @throws IOException if a problem occurs during reading.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#computeBufferSize(InputStream)",
    "entityType": "method",
    "code": "private static int computeBufferSize(final InputStream inputStream) throws IOException {\r\n    int expectedLength = inputStream.available();\r\n    /*\r\n     * Some implementations can return 0 while holding available data (e.g. new\r\n     * FileInputStream(\"/proc/a_file\")). Also in some pathological cases a very small number might\r\n     * be returned, and in this case we use a default size.\r\n     */\r\n    if (expectedLength < 256) {\r\n        return INPUT_STREAM_DATA_CHUNK_SIZE;\r\n    }\r\n    return Math.min(expectedLength, MAX_BUFFER_SIZE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getAccess()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Accessors\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\r\n * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\r\n *\r\n * @return the class access flags.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic int getAccess() {\r\n    return readUnsignedShort(header);\r\n}",
    "comment": "\n   * Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated\n   * and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.\n   *\n   * @return the class access flags.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getClassName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the class (see {@link Type#getInternalName()}).\r\n *\r\n * @return the internal class name.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic String getClassName() {\r\n    // this_class is just after the access_flags field (using 2 bytes).\r\n    return readClass(header + 2, new char[maxStringLength]);\r\n}",
    "comment": "\n   * Returns the internal name of the class (see {@link Type#getInternalName()}).\n   *\n   * @return the internal class name.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getSuperName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the super class (see {@link Type#getInternalName()}). For\r\n * interfaces, the super class is {@link Object}.\r\n *\r\n * @return the internal name of the super class, or {@literal null} for {@link Object} class.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic String getSuperName() {\r\n    // super_class is after the access_flags and this_class fields (2 bytes each).\r\n    return readClass(header + 4, new char[maxStringLength]);\r\n}",
    "comment": "\n   * Returns the internal name of the super class (see {@link Type#getInternalName()}). For\n   * interfaces, the super class is {@link Object}.\n   *\n   * @return the internal name of the super class, or {@literal null} for {@link Object} class.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getInterfaces()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\r\n *\r\n * @return the internal names of the directly implemented interfaces. Inherited implemented\r\n *     interfaces are not returned.\r\n * @see ClassVisitor#visit(int, int, String, String, String, String[])\r\n */\r\npublic String[] getInterfaces() {\r\n    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).\r\n    int currentOffset = header + 6;\r\n    int interfacesCount = readUnsignedShort(currentOffset);\r\n    String[] interfaces = new String[interfacesCount];\r\n    if (interfacesCount > 0) {\r\n        char[] charBuffer = new char[maxStringLength];\r\n        for (int i = 0; i < interfacesCount; ++i) {\r\n            currentOffset += 2;\r\n            interfaces[i] = readClass(currentOffset, charBuffer);\r\n        }\r\n    }\r\n    return interfaces;\r\n}",
    "comment": "\n   * Returns the internal names of the implemented interfaces (see {@link Type#getInternalName()}).\n   *\n   * @return the internal names of the directly implemented interfaces. Inherited implemented\n   *     interfaces are not returned.\n   * @see ClassVisitor#visit(int, int, String, String, String, String[])\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Public methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\r\n * {@link ClassReader}.\r\n *\r\n * @param classVisitor the visitor that must visit this class.\r\n * @param parsingOptions the options to use to parse this class. One or more of {@link\r\n *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\r\n */\r\npublic void accept(final ClassVisitor classVisitor, final int parsingOptions) {\r\n    accept(classVisitor, new Attribute[0], parsingOptions);\r\n}",
    "comment": "\n   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n   * {@link ClassReader}.\n   *\n   * @param classVisitor the visitor that must visit this class.\n   * @param parsingOptions the options to use to parse this class. One or more of {@link\n   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#accept(ClassVisitor,Attribute[],int)",
    "entityType": "method",
    "code": "/**\r\n * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\r\n * {@link ClassReader}.\r\n *\r\n * @param classVisitor the visitor that must visit this class.\r\n * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\r\n *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\r\n *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\r\n *     corrupt it if this value contains references to the constant pool, or has syntactic or\r\n *     semantic links with a class element that has been transformed by a class adapter between\r\n *     the reader and the writer</i>.\r\n * @param parsingOptions the options to use to parse this class. One or more of {@link\r\n *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\r\n */\r\npublic void accept(final ClassVisitor classVisitor, final Attribute[] attributePrototypes, final int parsingOptions) {\r\n    Context context = new Context();\r\n    context.attributePrototypes = attributePrototypes;\r\n    context.parsingOptions = parsingOptions;\r\n    context.charBuffer = new char[maxStringLength];\r\n    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = header;\r\n    int accessFlags = readUnsignedShort(currentOffset);\r\n    String thisClass = readClass(currentOffset + 2, charBuffer);\r\n    String superClass = readClass(currentOffset + 4, charBuffer);\r\n    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];\r\n    currentOffset += 8;\r\n    for (int i = 0; i < interfaces.length; ++i) {\r\n        interfaces[i] = readClass(currentOffset, charBuffer);\r\n        currentOffset += 2;\r\n    }\r\n    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The offset of the InnerClasses attribute, or 0.\r\n    int innerClassesOffset = 0;\r\n    // - The offset of the EnclosingMethod attribute, or 0.\r\n    int enclosingMethodOffset = 0;\r\n    // - The string corresponding to the Signature attribute, or null.\r\n    String signature = null;\r\n    // - The string corresponding to the SourceFile attribute, or null.\r\n    String sourceFile = null;\r\n    // - The string corresponding to the SourceDebugExtension attribute, or null.\r\n    String sourceDebugExtension = null;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the Module attribute, or 0.\r\n    int moduleOffset = 0;\r\n    // - The offset of the ModulePackages attribute, or 0.\r\n    int modulePackagesOffset = 0;\r\n    // - The string corresponding to the ModuleMainClass attribute, or null.\r\n    String moduleMainClass = null;\r\n    // - The string corresponding to the NestHost attribute, or null.\r\n    String nestHostClass = null;\r\n    // - The offset of the NestMembers attribute, or 0.\r\n    int nestMembersOffset = 0;\r\n    // - The offset of the PermittedSubclasses attribute, or 0\r\n    int permittedSubclassesOffset = 0;\r\n    // - The offset of the Record attribute, or 0.\r\n    int recordOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int currentAttributeOffset = getFirstAttributeOffset();\r\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentAttributeOffset, charBuffer);\r\n        int attributeLength = readInt(currentAttributeOffset + 2);\r\n        currentAttributeOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.SOURCE_FILE.equals(attributeName)) {\r\n            sourceFile = readUTF8(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.INNER_CLASSES.equals(attributeName)) {\r\n            innerClassesOffset = currentAttributeOffset;\r\n        } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {\r\n            enclosingMethodOffset = currentAttributeOffset;\r\n        } else if (Constants.NEST_HOST.equals(attributeName)) {\r\n            nestHostClass = readClass(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.NEST_MEMBERS.equals(attributeName)) {\r\n            nestMembersOffset = currentAttributeOffset;\r\n        } else if (Constants.PERMITTED_SUBCLASSES.equals(attributeName)) {\r\n            permittedSubclassesOffset = currentAttributeOffset;\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signature = readUTF8(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {\r\n            if (attributeLength > classFileBuffer.length - currentAttributeOffset) {\r\n                throw new IllegalArgumentException();\r\n            }\r\n            sourceDebugExtension = readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;\r\n        } else if (Constants.RECORD.equals(attributeName)) {\r\n            recordOffset = currentAttributeOffset;\r\n            accessFlags |= Opcodes.ACC_RECORD;\r\n        } else if (Constants.MODULE.equals(attributeName)) {\r\n            moduleOffset = currentAttributeOffset;\r\n        } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {\r\n            moduleMainClass = readClass(currentAttributeOffset, charBuffer);\r\n        } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {\r\n            modulePackagesOffset = currentAttributeOffset;\r\n        } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            // The BootstrapMethods attribute is read in the constructor.\r\n            Attribute attribute = readAttribute(attributePrototypes, attributeName, currentAttributeOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentAttributeOffset += attributeLength;\r\n    }\r\n    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before\r\n    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).\r\n    classVisitor.visit(readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);\r\n    // Visit the SourceFile and SourceDebugExtenstion attributes.\r\n    if ((parsingOptions & SKIP_DEBUG) == 0 && (sourceFile != null || sourceDebugExtension != null)) {\r\n        classVisitor.visitSource(sourceFile, sourceDebugExtension);\r\n    }\r\n    // Visit the Module, ModulePackages and ModuleMainClass attributes.\r\n    if (moduleOffset != 0) {\r\n        readModuleAttributes(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);\r\n    }\r\n    // Visit the NestHost attribute.\r\n    if (nestHostClass != null) {\r\n        classVisitor.visitNestHost(nestHostClass);\r\n    }\r\n    // Visit the EnclosingMethod attribute.\r\n    if (enclosingMethodOffset != 0) {\r\n        String className = readClass(enclosingMethodOffset, charBuffer);\r\n        int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);\r\n        String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);\r\n        String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);\r\n        classVisitor.visitOuterClass(className, name, type);\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(classVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        classVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the NestedMembers attribute.\r\n    if (nestMembersOffset != 0) {\r\n        int numberOfNestMembers = readUnsignedShort(nestMembersOffset);\r\n        int currentNestMemberOffset = nestMembersOffset + 2;\r\n        while (numberOfNestMembers-- > 0) {\r\n            classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));\r\n            currentNestMemberOffset += 2;\r\n        }\r\n    }\r\n    // Visit the PermittedSubclasses attribute.\r\n    if (permittedSubclassesOffset != 0) {\r\n        int numberOfPermittedSubclasses = readUnsignedShort(permittedSubclassesOffset);\r\n        int currentPermittedSubclassesOffset = permittedSubclassesOffset + 2;\r\n        while (numberOfPermittedSubclasses-- > 0) {\r\n            classVisitor.visitPermittedSubclass(readClass(currentPermittedSubclassesOffset, charBuffer));\r\n            currentPermittedSubclassesOffset += 2;\r\n        }\r\n    }\r\n    // Visit the InnerClasses attribute.\r\n    if (innerClassesOffset != 0) {\r\n        int numberOfClasses = readUnsignedShort(innerClassesOffset);\r\n        int currentClassesOffset = innerClassesOffset + 2;\r\n        while (numberOfClasses-- > 0) {\r\n            classVisitor.visitInnerClass(readClass(currentClassesOffset, charBuffer), readClass(currentClassesOffset + 2, charBuffer), readUTF8(currentClassesOffset + 4, charBuffer), readUnsignedShort(currentClassesOffset + 6));\r\n            currentClassesOffset += 8;\r\n        }\r\n    }\r\n    // Visit Record components.\r\n    if (recordOffset != 0) {\r\n        int recordComponentsCount = readUnsignedShort(recordOffset);\r\n        recordOffset += 2;\r\n        while (recordComponentsCount-- > 0) {\r\n            recordOffset = readRecordComponent(classVisitor, context, recordOffset);\r\n        }\r\n    }\r\n    // Visit the fields and methods.\r\n    int fieldsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (fieldsCount-- > 0) {\r\n        currentOffset = readField(classVisitor, context, currentOffset);\r\n    }\r\n    int methodsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (methodsCount-- > 0) {\r\n        currentOffset = readMethod(classVisitor, context, currentOffset);\r\n    }\r\n    // Visit the end of the class.\r\n    classVisitor.visitEnd();\r\n}",
    "comment": "\n   * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this\n   * {@link ClassReader}.\n   *\n   * @param classVisitor the visitor that must visit this class.\n   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n   *     be parsed: its byte array value will be passed unchanged to the ClassWriter. <i>This may\n   *     corrupt it if this value contains references to the constant pool, or has syntactic or\n   *     semantic links with a class element that has been transformed by a class adapter between\n   *     the reader and the writer</i>.\n   * @param parsingOptions the options to use to parse this class. One or more of {@link\n   *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readModuleAttributes(ClassVisitor,Context,int,int,String)",
    "entityType": "method",
    "code": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse modules, fields and methods\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\r\n *\r\n * @param classVisitor the current class visitor\r\n * @param context information about the class being parsed.\r\n * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\r\n *     attribute_name_index and attribute_length fields).\r\n * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\r\n *     attribute_info's attribute_name_index and attribute_length fields), or 0.\r\n * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\r\n *     null}.\r\n */\r\nprivate void readModuleAttributes(final ClassVisitor classVisitor, final Context context, final int moduleOffset, final int modulePackagesOffset, final String moduleMainClass) {\r\n    char[] buffer = context.charBuffer;\r\n    // Read the module_name_index, module_flags and module_version_index fields and visit them.\r\n    int currentOffset = moduleOffset;\r\n    String moduleName = readModule(currentOffset, buffer);\r\n    int moduleFlags = readUnsignedShort(currentOffset + 2);\r\n    String moduleVersion = readUTF8(currentOffset + 4, buffer);\r\n    currentOffset += 6;\r\n    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);\r\n    if (moduleVisitor == null) {\r\n        return;\r\n    }\r\n    // Visit the ModuleMainClass attribute.\r\n    if (moduleMainClass != null) {\r\n        moduleVisitor.visitMainClass(moduleMainClass);\r\n    }\r\n    // Visit the ModulePackages attribute.\r\n    if (modulePackagesOffset != 0) {\r\n        int packageCount = readUnsignedShort(modulePackagesOffset);\r\n        int currentPackageOffset = modulePackagesOffset + 2;\r\n        while (packageCount-- > 0) {\r\n            moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));\r\n            currentPackageOffset += 2;\r\n        }\r\n    }\r\n    // Read the 'requires_count' and 'requires' fields.\r\n    int requiresCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (requiresCount-- > 0) {\r\n        // Read the requires_index, requires_flags and requires_version fields and visit them.\r\n        String requires = readModule(currentOffset, buffer);\r\n        int requiresFlags = readUnsignedShort(currentOffset + 2);\r\n        String requiresVersion = readUTF8(currentOffset + 4, buffer);\r\n        currentOffset += 6;\r\n        moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);\r\n    }\r\n    // Read the 'exports_count' and 'exports' fields.\r\n    int exportsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (exportsCount-- > 0) {\r\n        // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields\r\n        // and visit them.\r\n        String exports = readPackage(currentOffset, buffer);\r\n        int exportsFlags = readUnsignedShort(currentOffset + 2);\r\n        int exportsToCount = readUnsignedShort(currentOffset + 4);\r\n        currentOffset += 6;\r\n        String[] exportsTo = null;\r\n        if (exportsToCount != 0) {\r\n            exportsTo = new String[exportsToCount];\r\n            for (int i = 0; i < exportsToCount; ++i) {\r\n                exportsTo[i] = readModule(currentOffset, buffer);\r\n                currentOffset += 2;\r\n            }\r\n        }\r\n        moduleVisitor.visitExport(exports, exportsFlags, exportsTo);\r\n    }\r\n    // Reads the 'opens_count' and 'opens' fields.\r\n    int opensCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (opensCount-- > 0) {\r\n        // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.\r\n        String opens = readPackage(currentOffset, buffer);\r\n        int opensFlags = readUnsignedShort(currentOffset + 2);\r\n        int opensToCount = readUnsignedShort(currentOffset + 4);\r\n        currentOffset += 6;\r\n        String[] opensTo = null;\r\n        if (opensToCount != 0) {\r\n            opensTo = new String[opensToCount];\r\n            for (int i = 0; i < opensToCount; ++i) {\r\n                opensTo[i] = readModule(currentOffset, buffer);\r\n                currentOffset += 2;\r\n            }\r\n        }\r\n        moduleVisitor.visitOpen(opens, opensFlags, opensTo);\r\n    }\r\n    // Read the 'uses_count' and 'uses' fields.\r\n    int usesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (usesCount-- > 0) {\r\n        moduleVisitor.visitUse(readClass(currentOffset, buffer));\r\n        currentOffset += 2;\r\n    }\r\n    // Read the 'provides_count' and 'provides' fields.\r\n    int providesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (providesCount-- > 0) {\r\n        // Read the provides_index, provides_with_count and provides_with_index fields and visit them.\r\n        String provides = readClass(currentOffset, buffer);\r\n        int providesWithCount = readUnsignedShort(currentOffset + 2);\r\n        currentOffset += 4;\r\n        String[] providesWith = new String[providesWithCount];\r\n        for (int i = 0; i < providesWithCount; ++i) {\r\n            providesWith[i] = readClass(currentOffset, buffer);\r\n            currentOffset += 2;\r\n        }\r\n        moduleVisitor.visitProvide(provides, providesWith);\r\n    }\r\n    // Visit the end of the module attributes.\r\n    moduleVisitor.visitEnd();\r\n}",
    "comment": "\n   * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.\n   *\n   * @param classVisitor the current class visitor\n   * @param context information about the class being parsed.\n   * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's\n   *     attribute_name_index and attribute_length fields).\n   * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the\n   *     attribute_info's attribute_name_index and attribute_length fields), or 0.\n   * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal\n   *     null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readRecordComponent(ClassVisitor,Context,int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a record component and visit it.\r\n *\r\n * @param classVisitor the current class visitor\r\n * @param context information about the class being parsed.\r\n * @param recordComponentOffset the offset of the current record component.\r\n * @return the offset of the first byte following the record component.\r\n */\r\nprivate int readRecordComponent(final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = recordComponentOffset;\r\n    String name = readUTF8(currentOffset, charBuffer);\r\n    String descriptor = readUTF8(currentOffset + 2, charBuffer);\r\n    currentOffset += 4;\r\n    // Read the record component attributes (the variables are ordered as in Section 4.7 of the\r\n    // JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The string corresponding to the Signature attribute, or null.\r\n    String signature = null;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signature = readUTF8(currentOffset, charBuffer);\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(name, descriptor, signature);\r\n    if (recordComponentVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(recordComponentVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        recordComponentVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the end of the field.\r\n    recordComponentVisitor.visitEnd();\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads a record component and visit it.\n   *\n   * @param classVisitor the current class visitor\n   * @param context information about the class being parsed.\n   * @param recordComponentOffset the offset of the current record component.\n   * @return the offset of the first byte following the record component.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a JVMS field_info structure and makes the given visitor visit it.\r\n *\r\n * @param classVisitor the visitor that must visit the field.\r\n * @param context information about the class being parsed.\r\n * @param fieldInfoOffset the start offset of the field_info structure.\r\n * @return the offset of the first byte following the field_info structure.\r\n */\r\nprivate int readField(final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    // Read the access_flags, name_index and descriptor_index fields.\r\n    int currentOffset = fieldInfoOffset;\r\n    int accessFlags = readUnsignedShort(currentOffset);\r\n    String name = readUTF8(currentOffset + 2, charBuffer);\r\n    String descriptor = readUTF8(currentOffset + 4, charBuffer);\r\n    currentOffset += 6;\r\n    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The value corresponding to the ConstantValue attribute, or null.\r\n    Object constantValue = null;\r\n    // - The string corresponding to the Signature attribute, or null.\r\n    String signature = null;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.CONSTANT_VALUE.equals(attributeName)) {\r\n            int constantvalueIndex = readUnsignedShort(currentOffset);\r\n            constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signature = readUTF8(currentOffset, charBuffer);\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            accessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Visit the field declaration.\r\n    FieldVisitor fieldVisitor = classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);\r\n    if (fieldVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(fieldVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        fieldVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the end of the field.\r\n    fieldVisitor.visitEnd();\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads a JVMS field_info structure and makes the given visitor visit it.\n   *\n   * @param classVisitor the visitor that must visit the field.\n   * @param context information about the class being parsed.\n   * @param fieldInfoOffset the start offset of the field_info structure.\n   * @return the offset of the first byte following the field_info structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a JVMS method_info structure and makes the given visitor visit it.\r\n *\r\n * @param classVisitor the visitor that must visit the method.\r\n * @param context information about the class being parsed.\r\n * @param methodInfoOffset the start offset of the method_info structure.\r\n * @return the offset of the first byte following the method_info structure.\r\n */\r\nprivate int readMethod(final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {\r\n    char[] charBuffer = context.charBuffer;\r\n    // Read the access_flags, name_index and descriptor_index fields.\r\n    int currentOffset = methodInfoOffset;\r\n    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);\r\n    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);\r\n    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);\r\n    currentOffset += 6;\r\n    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).\r\n    // Attribute offsets exclude the attribute_name_index and attribute_length fields.\r\n    // - The offset of the Code attribute, or 0.\r\n    int codeOffset = 0;\r\n    // - The offset of the Exceptions attribute, or 0.\r\n    int exceptionsOffset = 0;\r\n    // - The strings corresponding to the Exceptions attribute, or null.\r\n    String[] exceptions = null;\r\n    // - Whether the method has a Synthetic attribute.\r\n    boolean synthetic = false;\r\n    // - The constant pool index contained in the Signature attribute, or 0.\r\n    int signatureIndex = 0;\r\n    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.\r\n    int runtimeVisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.\r\n    int runtimeInvisibleAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.\r\n    int runtimeVisibleParameterAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.\r\n    int runtimeInvisibleParameterAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.\r\n    int runtimeVisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.\r\n    int runtimeInvisibleTypeAnnotationsOffset = 0;\r\n    // - The offset of the AnnotationDefault attribute, or 0.\r\n    int annotationDefaultOffset = 0;\r\n    // - The offset of the MethodParameters attribute, or 0.\r\n    int methodParametersOffset = 0;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        // The tests are sorted in decreasing frequency order (based on frequencies observed on\r\n        // typical classes).\r\n        if (Constants.CODE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_CODE) == 0) {\r\n                codeOffset = currentOffset;\r\n            }\r\n        } else if (Constants.EXCEPTIONS.equals(attributeName)) {\r\n            exceptionsOffset = currentOffset;\r\n            exceptions = new String[readUnsignedShort(exceptionsOffset)];\r\n            int currentExceptionOffset = exceptionsOffset + 2;\r\n            for (int i = 0; i < exceptions.length; ++i) {\r\n                exceptions[i] = readClass(currentExceptionOffset, charBuffer);\r\n                currentExceptionOffset += 2;\r\n            }\r\n        } else if (Constants.SIGNATURE.equals(attributeName)) {\r\n            signatureIndex = readUnsignedShort(currentOffset);\r\n        } else if (Constants.DEPRECATED.equals(attributeName)) {\r\n            context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;\r\n        } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {\r\n            annotationDefaultOffset = currentOffset;\r\n        } else if (Constants.SYNTHETIC.equals(attributeName)) {\r\n            synthetic = true;\r\n            context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;\r\n        } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleTypeAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeVisibleParameterAnnotationsOffset = currentOffset;\r\n        } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {\r\n            runtimeInvisibleParameterAnnotationsOffset = currentOffset;\r\n        } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {\r\n            methodParametersOffset = currentOffset;\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, -1, null);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Visit the method declaration.\r\n    MethodVisitor methodVisitor = classVisitor.visitMethod(context.currentMethodAccessFlags, context.currentMethodName, context.currentMethodDescriptor, signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer), exceptions);\r\n    if (methodVisitor == null) {\r\n        return currentOffset;\r\n    }\r\n    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method\r\n    // adapter between the reader and the writer. In this case, it might be possible to copy\r\n    // the method attributes directly into the writer. If so, return early without visiting\r\n    // the content of these attributes.\r\n    if (methodVisitor instanceof MethodWriter) {\r\n        MethodWriter methodWriter = (MethodWriter) methodVisitor;\r\n        if (methodWriter.canCopyMethodAttributes(this, synthetic, (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0, readUnsignedShort(methodInfoOffset + 4), signatureIndex, exceptionsOffset)) {\r\n            methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);\r\n            return currentOffset;\r\n        }\r\n    }\r\n    // Visit the MethodParameters attribute.\r\n    if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\r\n        int parametersCount = readByte(methodParametersOffset);\r\n        int currentParameterOffset = methodParametersOffset + 1;\r\n        while (parametersCount-- > 0) {\r\n            // Read the name_index and access_flags fields and visit them.\r\n            methodVisitor.visitParameter(readUTF8(currentParameterOffset, charBuffer), readUnsignedShort(currentParameterOffset + 2));\r\n            currentParameterOffset += 4;\r\n        }\r\n    }\r\n    // Visit the AnnotationDefault attribute.\r\n    if (annotationDefaultOffset != 0) {\r\n        AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();\r\n        readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);\r\n        if (annotationVisitor != null) {\r\n            annotationVisitor.visitEnd();\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleAnnotations attribute.\r\n    if (runtimeVisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleAnnotations attribute.\r\n    if (runtimeInvisibleAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitAnnotation(annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleTypeAnnotations attribute.\r\n    if (runtimeVisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            true), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (runtimeInvisibleTypeAnnotationsOffset != 0) {\r\n        int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);\r\n        int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the target_type, target_info and target_path fields.\r\n            currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n            currentAnnotationOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentAnnotationOffset = readElementValues(methodVisitor.visitTypeAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n            false), currentAnnotationOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    // Visit the RuntimeVisibleParameterAnnotations attribute.\r\n    if (runtimeVisibleParameterAnnotationsOffset != 0) {\r\n        readParameterAnnotations(methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible= */\r\n        true);\r\n    }\r\n    // Visit the RuntimeInvisibleParameterAnnotations attribute.\r\n    if (runtimeInvisibleParameterAnnotationsOffset != 0) {\r\n        readParameterAnnotations(methodVisitor, context, runtimeInvisibleParameterAnnotationsOffset, /* visible= */\r\n        false);\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        methodVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the Code attribute.\r\n    if (codeOffset != 0) {\r\n        methodVisitor.visitCode();\r\n        readCode(methodVisitor, context, codeOffset);\r\n    }\r\n    // Visit the end of the method.\r\n    methodVisitor.visitEnd();\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads a JVMS method_info structure and makes the given visitor visit it.\n   *\n   * @param classVisitor the visitor that must visit the method.\n   * @param context information about the class being parsed.\n   * @param methodInfoOffset the start offset of the method_info structure.\n   * @return the offset of the first byte following the method_info structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readCode(MethodVisitor,Context,int)",
    "entityType": "method",
    "code": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse a Code attribute\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\r\n *\r\n * @param methodVisitor the visitor that must visit the Code attribute.\r\n * @param context information about the class being parsed.\r\n * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\r\n *     its attribute_name_index and attribute_length fields.\r\n */\r\nprivate void readCode(final MethodVisitor methodVisitor, final Context context, final int codeOffset) {\r\n    int currentOffset = codeOffset;\r\n    // Read the max_stack, max_locals and code_length fields.\r\n    final byte[] classBuffer = classFileBuffer;\r\n    final char[] charBuffer = context.charBuffer;\r\n    final int maxStack = readUnsignedShort(currentOffset);\r\n    final int maxLocals = readUnsignedShort(currentOffset + 2);\r\n    final int codeLength = readInt(currentOffset + 4);\r\n    currentOffset += 8;\r\n    if (codeLength > classFileBuffer.length - currentOffset) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    // Read the bytecode 'code' array to create a label for each referenced instruction.\r\n    final int bytecodeStartOffset = currentOffset;\r\n    final int bytecodeEndOffset = currentOffset + codeLength;\r\n    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];\r\n    while (currentOffset < bytecodeEndOffset) {\r\n        final int bytecodeOffset = currentOffset - bytecodeStartOffset;\r\n        final int opcode = classBuffer[currentOffset] & 0xFF;\r\n        switch(opcode) {\r\n            case Opcodes.NOP:\r\n            case Opcodes.ACONST_NULL:\r\n            case Opcodes.ICONST_M1:\r\n            case Opcodes.ICONST_0:\r\n            case Opcodes.ICONST_1:\r\n            case Opcodes.ICONST_2:\r\n            case Opcodes.ICONST_3:\r\n            case Opcodes.ICONST_4:\r\n            case Opcodes.ICONST_5:\r\n            case Opcodes.LCONST_0:\r\n            case Opcodes.LCONST_1:\r\n            case Opcodes.FCONST_0:\r\n            case Opcodes.FCONST_1:\r\n            case Opcodes.FCONST_2:\r\n            case Opcodes.DCONST_0:\r\n            case Opcodes.DCONST_1:\r\n            case Opcodes.IALOAD:\r\n            case Opcodes.LALOAD:\r\n            case Opcodes.FALOAD:\r\n            case Opcodes.DALOAD:\r\n            case Opcodes.AALOAD:\r\n            case Opcodes.BALOAD:\r\n            case Opcodes.CALOAD:\r\n            case Opcodes.SALOAD:\r\n            case Opcodes.IASTORE:\r\n            case Opcodes.LASTORE:\r\n            case Opcodes.FASTORE:\r\n            case Opcodes.DASTORE:\r\n            case Opcodes.AASTORE:\r\n            case Opcodes.BASTORE:\r\n            case Opcodes.CASTORE:\r\n            case Opcodes.SASTORE:\r\n            case Opcodes.POP:\r\n            case Opcodes.POP2:\r\n            case Opcodes.DUP:\r\n            case Opcodes.DUP_X1:\r\n            case Opcodes.DUP_X2:\r\n            case Opcodes.DUP2:\r\n            case Opcodes.DUP2_X1:\r\n            case Opcodes.DUP2_X2:\r\n            case Opcodes.SWAP:\r\n            case Opcodes.IADD:\r\n            case Opcodes.LADD:\r\n            case Opcodes.FADD:\r\n            case Opcodes.DADD:\r\n            case Opcodes.ISUB:\r\n            case Opcodes.LSUB:\r\n            case Opcodes.FSUB:\r\n            case Opcodes.DSUB:\r\n            case Opcodes.IMUL:\r\n            case Opcodes.LMUL:\r\n            case Opcodes.FMUL:\r\n            case Opcodes.DMUL:\r\n            case Opcodes.IDIV:\r\n            case Opcodes.LDIV:\r\n            case Opcodes.FDIV:\r\n            case Opcodes.DDIV:\r\n            case Opcodes.IREM:\r\n            case Opcodes.LREM:\r\n            case Opcodes.FREM:\r\n            case Opcodes.DREM:\r\n            case Opcodes.INEG:\r\n            case Opcodes.LNEG:\r\n            case Opcodes.FNEG:\r\n            case Opcodes.DNEG:\r\n            case Opcodes.ISHL:\r\n            case Opcodes.LSHL:\r\n            case Opcodes.ISHR:\r\n            case Opcodes.LSHR:\r\n            case Opcodes.IUSHR:\r\n            case Opcodes.LUSHR:\r\n            case Opcodes.IAND:\r\n            case Opcodes.LAND:\r\n            case Opcodes.IOR:\r\n            case Opcodes.LOR:\r\n            case Opcodes.IXOR:\r\n            case Opcodes.LXOR:\r\n            case Opcodes.I2L:\r\n            case Opcodes.I2F:\r\n            case Opcodes.I2D:\r\n            case Opcodes.L2I:\r\n            case Opcodes.L2F:\r\n            case Opcodes.L2D:\r\n            case Opcodes.F2I:\r\n            case Opcodes.F2L:\r\n            case Opcodes.F2D:\r\n            case Opcodes.D2I:\r\n            case Opcodes.D2L:\r\n            case Opcodes.D2F:\r\n            case Opcodes.I2B:\r\n            case Opcodes.I2C:\r\n            case Opcodes.I2S:\r\n            case Opcodes.LCMP:\r\n            case Opcodes.FCMPL:\r\n            case Opcodes.FCMPG:\r\n            case Opcodes.DCMPL:\r\n            case Opcodes.DCMPG:\r\n            case Opcodes.IRETURN:\r\n            case Opcodes.LRETURN:\r\n            case Opcodes.FRETURN:\r\n            case Opcodes.DRETURN:\r\n            case Opcodes.ARETURN:\r\n            case Opcodes.RETURN:\r\n            case Opcodes.ARRAYLENGTH:\r\n            case Opcodes.ATHROW:\r\n            case Opcodes.MONITORENTER:\r\n            case Opcodes.MONITOREXIT:\r\n            case Constants.ILOAD_0:\r\n            case Constants.ILOAD_1:\r\n            case Constants.ILOAD_2:\r\n            case Constants.ILOAD_3:\r\n            case Constants.LLOAD_0:\r\n            case Constants.LLOAD_1:\r\n            case Constants.LLOAD_2:\r\n            case Constants.LLOAD_3:\r\n            case Constants.FLOAD_0:\r\n            case Constants.FLOAD_1:\r\n            case Constants.FLOAD_2:\r\n            case Constants.FLOAD_3:\r\n            case Constants.DLOAD_0:\r\n            case Constants.DLOAD_1:\r\n            case Constants.DLOAD_2:\r\n            case Constants.DLOAD_3:\r\n            case Constants.ALOAD_0:\r\n            case Constants.ALOAD_1:\r\n            case Constants.ALOAD_2:\r\n            case Constants.ALOAD_3:\r\n            case Constants.ISTORE_0:\r\n            case Constants.ISTORE_1:\r\n            case Constants.ISTORE_2:\r\n            case Constants.ISTORE_3:\r\n            case Constants.LSTORE_0:\r\n            case Constants.LSTORE_1:\r\n            case Constants.LSTORE_2:\r\n            case Constants.LSTORE_3:\r\n            case Constants.FSTORE_0:\r\n            case Constants.FSTORE_1:\r\n            case Constants.FSTORE_2:\r\n            case Constants.FSTORE_3:\r\n            case Constants.DSTORE_0:\r\n            case Constants.DSTORE_1:\r\n            case Constants.DSTORE_2:\r\n            case Constants.DSTORE_3:\r\n            case Constants.ASTORE_0:\r\n            case Constants.ASTORE_1:\r\n            case Constants.ASTORE_2:\r\n            case Constants.ASTORE_3:\r\n                currentOffset += 1;\r\n                break;\r\n            case Opcodes.IFEQ:\r\n            case Opcodes.IFNE:\r\n            case Opcodes.IFLT:\r\n            case Opcodes.IFGE:\r\n            case Opcodes.IFGT:\r\n            case Opcodes.IFLE:\r\n            case Opcodes.IF_ICMPEQ:\r\n            case Opcodes.IF_ICMPNE:\r\n            case Opcodes.IF_ICMPLT:\r\n            case Opcodes.IF_ICMPGE:\r\n            case Opcodes.IF_ICMPGT:\r\n            case Opcodes.IF_ICMPLE:\r\n            case Opcodes.IF_ACMPEQ:\r\n            case Opcodes.IF_ACMPNE:\r\n            case Opcodes.GOTO:\r\n            case Opcodes.JSR:\r\n            case Opcodes.IFNULL:\r\n            case Opcodes.IFNONNULL:\r\n                createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.ASM_IFEQ:\r\n            case Constants.ASM_IFNE:\r\n            case Constants.ASM_IFLT:\r\n            case Constants.ASM_IFGE:\r\n            case Constants.ASM_IFGT:\r\n            case Constants.ASM_IFLE:\r\n            case Constants.ASM_IF_ICMPEQ:\r\n            case Constants.ASM_IF_ICMPNE:\r\n            case Constants.ASM_IF_ICMPLT:\r\n            case Constants.ASM_IF_ICMPGE:\r\n            case Constants.ASM_IF_ICMPGT:\r\n            case Constants.ASM_IF_ICMPLE:\r\n            case Constants.ASM_IF_ACMPEQ:\r\n            case Constants.ASM_IF_ACMPNE:\r\n            case Constants.ASM_GOTO:\r\n            case Constants.ASM_JSR:\r\n            case Constants.ASM_IFNULL:\r\n            case Constants.ASM_IFNONNULL:\r\n                createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.GOTO_W:\r\n            case Constants.JSR_W:\r\n            case Constants.ASM_GOTO_W:\r\n                createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.WIDE:\r\n                switch(classBuffer[currentOffset + 1] & 0xFF) {\r\n                    case Opcodes.ILOAD:\r\n                    case Opcodes.FLOAD:\r\n                    case Opcodes.ALOAD:\r\n                    case Opcodes.LLOAD:\r\n                    case Opcodes.DLOAD:\r\n                    case Opcodes.ISTORE:\r\n                    case Opcodes.FSTORE:\r\n                    case Opcodes.ASTORE:\r\n                    case Opcodes.LSTORE:\r\n                    case Opcodes.DSTORE:\r\n                    case Opcodes.RET:\r\n                        currentOffset += 4;\r\n                        break;\r\n                    case Opcodes.IINC:\r\n                        currentOffset += 6;\r\n                        break;\r\n                    default:\r\n                        throw new IllegalArgumentException();\r\n                }\r\n                break;\r\n            case Opcodes.TABLESWITCH:\r\n                // Skip 0 to 3 padding bytes.\r\n                currentOffset += 4 - (bytecodeOffset & 3);\r\n                // Read the default label and the number of table entries.\r\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;\r\n                currentOffset += 12;\r\n                // Read the table labels.\r\n                while (numTableEntries-- > 0) {\r\n                    createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                    currentOffset += 4;\r\n                }\r\n                break;\r\n            case Opcodes.LOOKUPSWITCH:\r\n                // Skip 0 to 3 padding bytes.\r\n                currentOffset += 4 - (bytecodeOffset & 3);\r\n                // Read the default label and the number of switch cases.\r\n                createLabel(bytecodeOffset + readInt(currentOffset), labels);\r\n                int numSwitchCases = readInt(currentOffset + 4);\r\n                currentOffset += 8;\r\n                // Read the switch labels.\r\n                while (numSwitchCases-- > 0) {\r\n                    createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);\r\n                    currentOffset += 8;\r\n                }\r\n                break;\r\n            case Opcodes.ILOAD:\r\n            case Opcodes.LLOAD:\r\n            case Opcodes.FLOAD:\r\n            case Opcodes.DLOAD:\r\n            case Opcodes.ALOAD:\r\n            case Opcodes.ISTORE:\r\n            case Opcodes.LSTORE:\r\n            case Opcodes.FSTORE:\r\n            case Opcodes.DSTORE:\r\n            case Opcodes.ASTORE:\r\n            case Opcodes.RET:\r\n            case Opcodes.BIPUSH:\r\n            case Opcodes.NEWARRAY:\r\n            case Opcodes.LDC:\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.SIPUSH:\r\n            case Constants.LDC_W:\r\n            case Constants.LDC2_W:\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.NEW:\r\n            case Opcodes.ANEWARRAY:\r\n            case Opcodes.CHECKCAST:\r\n            case Opcodes.INSTANCEOF:\r\n            case Opcodes.IINC:\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.INVOKEINTERFACE:\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                currentOffset += 5;\r\n                break;\r\n            case Opcodes.MULTIANEWARRAY:\r\n                currentOffset += 4;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n    }\r\n    // Read the 'exception_table_length' and 'exception_table' field to create a label for each\r\n    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.\r\n    int exceptionTableLength = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (exceptionTableLength-- > 0) {\r\n        Label start = createLabel(readUnsignedShort(currentOffset), labels);\r\n        Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);\r\n        Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);\r\n        String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);\r\n        currentOffset += 8;\r\n        methodVisitor.visitTryCatchBlock(start, end, handler, catchType);\r\n    }\r\n    // Read the Code attributes to create a label for each referenced instruction (the variables\r\n    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the\r\n    // attribute_name_index and attribute_length fields.\r\n    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.\r\n    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is\r\n    // updated after each stack_map_frame is read.\r\n    int stackMapFrameOffset = 0;\r\n    // - The end offset of the StackMap[Table] attribute, or 0.\r\n    int stackMapTableEndOffset = 0;\r\n    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.\r\n    boolean compressedFrames = true;\r\n    // - The offset of the LocalVariableTable attribute, or 0.\r\n    int localVariableTableOffset = 0;\r\n    // - The offset of the LocalVariableTypeTable attribute, or 0.\r\n    int localVariableTypeTableOffset = 0;\r\n    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations\r\n    // attribute, or null.\r\n    int[] visibleTypeAnnotationOffsets = null;\r\n    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations\r\n    // attribute, or null.\r\n    int[] invisibleTypeAnnotationOffsets = null;\r\n    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).\r\n    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.\r\n    Attribute attributes = null;\r\n    int attributesCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (attributesCount-- > 0) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentOffset, charBuffer);\r\n        int attributeLength = readInt(currentOffset + 2);\r\n        currentOffset += 6;\r\n        if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_DEBUG) == 0) {\r\n                localVariableTableOffset = currentOffset;\r\n                // Parse the attribute to find the corresponding (debug only) labels.\r\n                int currentLocalVariableTableOffset = currentOffset;\r\n                int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);\r\n                currentLocalVariableTableOffset += 2;\r\n                while (localVariableTableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentLocalVariableTableOffset);\r\n                    createDebugLabel(startPc, labels);\r\n                    int length = readUnsignedShort(currentLocalVariableTableOffset + 2);\r\n                    createDebugLabel(startPc + length, labels);\r\n                    // Skip the name_index, descriptor_index and index fields (2 bytes each).\r\n                    currentLocalVariableTableOffset += 10;\r\n                }\r\n            }\r\n        } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {\r\n            localVariableTypeTableOffset = currentOffset;\r\n            // Here we do not extract the labels corresponding to the attribute content. We assume they\r\n            // are the same or a subset of those of the LocalVariableTable attribute.\r\n        } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_DEBUG) == 0) {\r\n                // Parse the attribute to find the corresponding (debug only) labels.\r\n                int currentLineNumberTableOffset = currentOffset;\r\n                int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);\r\n                currentLineNumberTableOffset += 2;\r\n                while (lineNumberTableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentLineNumberTableOffset);\r\n                    int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);\r\n                    currentLineNumberTableOffset += 4;\r\n                    createDebugLabel(startPc, labels);\r\n                    labels[startPc].addLineNumber(lineNumber);\r\n                }\r\n            }\r\n        } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            visibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */\r\n            true);\r\n            // Here we do not extract the labels corresponding to the attribute content. This would\r\n            // require a full parsing of the attribute, which would need to be repeated when parsing\r\n            // the bytecode instructions (see below). Instead, the content of the attribute is read one\r\n            // type annotation at a time (i.e. after a type annotation has been visited, the next type\r\n            // annotation is read), and the labels it contains are also extracted one annotation at a\r\n            // time. This assumes that type annotations are ordered by increasing bytecode offset.\r\n        } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {\r\n            invisibleTypeAnnotationOffsets = readTypeAnnotations(methodVisitor, context, currentOffset, /* visible= */\r\n            false);\r\n            // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.\r\n        } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_FRAMES) == 0) {\r\n                stackMapFrameOffset = currentOffset + 2;\r\n                stackMapTableEndOffset = currentOffset + attributeLength;\r\n            }\r\n            // Here we do not extract the labels corresponding to the attribute content. This would\r\n            // require a full parsing of the attribute, which would need to be repeated when parsing\r\n            // the bytecode instructions (see below). Instead, the content of the attribute is read one\r\n            // frame at a time (i.e. after a frame has been visited, the next frame is read), and the\r\n            // labels it contains are also extracted one frame at a time. Thanks to the ordering of\r\n            // frames, having only a \"one frame lookahead\" is not a problem, i.e. it is not possible to\r\n            // see an offset smaller than the offset of the current instruction and for which no Label\r\n            // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map\r\n            // table without a full decoding (see below).\r\n        } else if (\"StackMap\".equals(attributeName)) {\r\n            if ((context.parsingOptions & SKIP_FRAMES) == 0) {\r\n                stackMapFrameOffset = currentOffset + 2;\r\n                stackMapTableEndOffset = currentOffset + attributeLength;\r\n                compressedFrames = false;\r\n            }\r\n            // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,\r\n            // although this is not guaranteed by the attribute format. This allows an incremental\r\n            // extraction of the labels corresponding to this attribute (see the comment above for the\r\n            // StackMapTable attribute).\r\n        } else {\r\n            Attribute attribute = readAttribute(context.attributePrototypes, attributeName, currentOffset, attributeLength, charBuffer, codeOffset, labels);\r\n            attribute.nextAttribute = attributes;\r\n            attributes = attribute;\r\n        }\r\n        currentOffset += attributeLength;\r\n    }\r\n    // Initialize the context fields related to stack map frames, and generate the first\r\n    // (implicit) stack map frame, if needed.\r\n    final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;\r\n    if (stackMapFrameOffset != 0) {\r\n        // The bytecode offset of the first explicit frame is not offset_delta + 1 but only\r\n        // offset_delta. Setting the implicit frame offset to -1 allows us to use of the\r\n        // \"offset_delta + 1\" rule in all cases.\r\n        context.currentFrameOffset = -1;\r\n        context.currentFrameType = 0;\r\n        context.currentFrameLocalCount = 0;\r\n        context.currentFrameLocalCountDelta = 0;\r\n        context.currentFrameLocalTypes = new Object[maxLocals];\r\n        context.currentFrameStackCount = 0;\r\n        context.currentFrameStackTypes = new Object[maxStack];\r\n        if (expandFrames) {\r\n            computeImplicitFrame(context);\r\n        }\r\n        // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the\r\n        // stack map table, we look for 3 consecutive bytes that \"look like\" an UNINITIALIZED type\r\n        // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).\r\n        // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,\r\n        // and the only consequence will be the creation of an unneeded label. This is better than\r\n        // creating a label for each NEW instruction, and faster than fully decoding the whole stack\r\n        // map table.\r\n        for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {\r\n            if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {\r\n                int potentialBytecodeOffset = readUnsignedShort(offset + 1);\r\n                if (potentialBytecodeOffset >= 0 && potentialBytecodeOffset < codeLength && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF) == Opcodes.NEW) {\r\n                    createLabel(potentialBytecodeOffset, labels);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {\r\n        // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method\r\n        // does not currently have any frame. These inserted frames must be computed by simulating the\r\n        // effect of the bytecode instructions, one by one, starting from the implicit first frame.\r\n        // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To\r\n        // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is\r\n        // computed in MethodWriter).\r\n        methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);\r\n    }\r\n    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing\r\n    // of the type annotations.\r\n    // Index of the next runtime visible type annotation to read (in the\r\n    // visibleTypeAnnotationOffsets array).\r\n    int currentVisibleTypeAnnotationIndex = 0;\r\n    // The bytecode offset of the next runtime visible type annotation to read, or -1.\r\n    int currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);\r\n    // Index of the next runtime invisible type annotation to read (in the\r\n    // invisibleTypeAnnotationOffsets array).\r\n    int currentInvisibleTypeAnnotationIndex = 0;\r\n    // The bytecode offset of the next runtime invisible type annotation to read, or -1.\r\n    int currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);\r\n    // Whether a F_INSERT stack map frame must be inserted before the current instruction.\r\n    boolean insertFrame = false;\r\n    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr\r\n    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific\r\n    // instructions).\r\n    final int wideJumpOpcodeDelta = (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;\r\n    currentOffset = bytecodeStartOffset;\r\n    while (currentOffset < bytecodeEndOffset) {\r\n        final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;\r\n        readBytecodeInstructionOffset(currentBytecodeOffset);\r\n        // Visit the label and the line number(s) for this bytecode offset, if any.\r\n        Label currentLabel = labels[currentBytecodeOffset];\r\n        if (currentLabel != null) {\r\n            currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);\r\n        }\r\n        // Visit the stack map frame for this bytecode offset, if any.\r\n        while (stackMapFrameOffset != 0 && (context.currentFrameOffset == currentBytecodeOffset || context.currentFrameOffset == -1)) {\r\n            // If there is a stack map frame for this offset, make methodVisitor visit it, and read the\r\n            // next stack map frame if there is one.\r\n            if (context.currentFrameOffset != -1) {\r\n                if (!compressedFrames || expandFrames) {\r\n                    methodVisitor.visitFrame(Opcodes.F_NEW, context.currentFrameLocalCount, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\r\n                } else {\r\n                    methodVisitor.visitFrame(context.currentFrameType, context.currentFrameLocalCountDelta, context.currentFrameLocalTypes, context.currentFrameStackCount, context.currentFrameStackTypes);\r\n                }\r\n                // Since there is already a stack map frame for this bytecode offset, there is no need to\r\n                // insert a new one.\r\n                insertFrame = false;\r\n            }\r\n            if (stackMapFrameOffset < stackMapTableEndOffset) {\r\n                stackMapFrameOffset = readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);\r\n            } else {\r\n                stackMapFrameOffset = 0;\r\n            }\r\n        }\r\n        // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to\r\n        // true during the previous iteration. The actual frame content is computed in MethodWriter.\r\n        if (insertFrame) {\r\n            if ((context.parsingOptions & EXPAND_FRAMES) != 0) {\r\n                methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);\r\n            }\r\n            insertFrame = false;\r\n        }\r\n        // Visit the instruction at this bytecode offset.\r\n        int opcode = classBuffer[currentOffset] & 0xFF;\r\n        switch(opcode) {\r\n            case Opcodes.NOP:\r\n            case Opcodes.ACONST_NULL:\r\n            case Opcodes.ICONST_M1:\r\n            case Opcodes.ICONST_0:\r\n            case Opcodes.ICONST_1:\r\n            case Opcodes.ICONST_2:\r\n            case Opcodes.ICONST_3:\r\n            case Opcodes.ICONST_4:\r\n            case Opcodes.ICONST_5:\r\n            case Opcodes.LCONST_0:\r\n            case Opcodes.LCONST_1:\r\n            case Opcodes.FCONST_0:\r\n            case Opcodes.FCONST_1:\r\n            case Opcodes.FCONST_2:\r\n            case Opcodes.DCONST_0:\r\n            case Opcodes.DCONST_1:\r\n            case Opcodes.IALOAD:\r\n            case Opcodes.LALOAD:\r\n            case Opcodes.FALOAD:\r\n            case Opcodes.DALOAD:\r\n            case Opcodes.AALOAD:\r\n            case Opcodes.BALOAD:\r\n            case Opcodes.CALOAD:\r\n            case Opcodes.SALOAD:\r\n            case Opcodes.IASTORE:\r\n            case Opcodes.LASTORE:\r\n            case Opcodes.FASTORE:\r\n            case Opcodes.DASTORE:\r\n            case Opcodes.AASTORE:\r\n            case Opcodes.BASTORE:\r\n            case Opcodes.CASTORE:\r\n            case Opcodes.SASTORE:\r\n            case Opcodes.POP:\r\n            case Opcodes.POP2:\r\n            case Opcodes.DUP:\r\n            case Opcodes.DUP_X1:\r\n            case Opcodes.DUP_X2:\r\n            case Opcodes.DUP2:\r\n            case Opcodes.DUP2_X1:\r\n            case Opcodes.DUP2_X2:\r\n            case Opcodes.SWAP:\r\n            case Opcodes.IADD:\r\n            case Opcodes.LADD:\r\n            case Opcodes.FADD:\r\n            case Opcodes.DADD:\r\n            case Opcodes.ISUB:\r\n            case Opcodes.LSUB:\r\n            case Opcodes.FSUB:\r\n            case Opcodes.DSUB:\r\n            case Opcodes.IMUL:\r\n            case Opcodes.LMUL:\r\n            case Opcodes.FMUL:\r\n            case Opcodes.DMUL:\r\n            case Opcodes.IDIV:\r\n            case Opcodes.LDIV:\r\n            case Opcodes.FDIV:\r\n            case Opcodes.DDIV:\r\n            case Opcodes.IREM:\r\n            case Opcodes.LREM:\r\n            case Opcodes.FREM:\r\n            case Opcodes.DREM:\r\n            case Opcodes.INEG:\r\n            case Opcodes.LNEG:\r\n            case Opcodes.FNEG:\r\n            case Opcodes.DNEG:\r\n            case Opcodes.ISHL:\r\n            case Opcodes.LSHL:\r\n            case Opcodes.ISHR:\r\n            case Opcodes.LSHR:\r\n            case Opcodes.IUSHR:\r\n            case Opcodes.LUSHR:\r\n            case Opcodes.IAND:\r\n            case Opcodes.LAND:\r\n            case Opcodes.IOR:\r\n            case Opcodes.LOR:\r\n            case Opcodes.IXOR:\r\n            case Opcodes.LXOR:\r\n            case Opcodes.I2L:\r\n            case Opcodes.I2F:\r\n            case Opcodes.I2D:\r\n            case Opcodes.L2I:\r\n            case Opcodes.L2F:\r\n            case Opcodes.L2D:\r\n            case Opcodes.F2I:\r\n            case Opcodes.F2L:\r\n            case Opcodes.F2D:\r\n            case Opcodes.D2I:\r\n            case Opcodes.D2L:\r\n            case Opcodes.D2F:\r\n            case Opcodes.I2B:\r\n            case Opcodes.I2C:\r\n            case Opcodes.I2S:\r\n            case Opcodes.LCMP:\r\n            case Opcodes.FCMPL:\r\n            case Opcodes.FCMPG:\r\n            case Opcodes.DCMPL:\r\n            case Opcodes.DCMPG:\r\n            case Opcodes.IRETURN:\r\n            case Opcodes.LRETURN:\r\n            case Opcodes.FRETURN:\r\n            case Opcodes.DRETURN:\r\n            case Opcodes.ARETURN:\r\n            case Opcodes.RETURN:\r\n            case Opcodes.ARRAYLENGTH:\r\n            case Opcodes.ATHROW:\r\n            case Opcodes.MONITORENTER:\r\n            case Opcodes.MONITOREXIT:\r\n                methodVisitor.visitInsn(opcode);\r\n                currentOffset += 1;\r\n                break;\r\n            case Constants.ILOAD_0:\r\n            case Constants.ILOAD_1:\r\n            case Constants.ILOAD_2:\r\n            case Constants.ILOAD_3:\r\n            case Constants.LLOAD_0:\r\n            case Constants.LLOAD_1:\r\n            case Constants.LLOAD_2:\r\n            case Constants.LLOAD_3:\r\n            case Constants.FLOAD_0:\r\n            case Constants.FLOAD_1:\r\n            case Constants.FLOAD_2:\r\n            case Constants.FLOAD_3:\r\n            case Constants.DLOAD_0:\r\n            case Constants.DLOAD_1:\r\n            case Constants.DLOAD_2:\r\n            case Constants.DLOAD_3:\r\n            case Constants.ALOAD_0:\r\n            case Constants.ALOAD_1:\r\n            case Constants.ALOAD_2:\r\n            case Constants.ALOAD_3:\r\n                opcode -= Constants.ILOAD_0;\r\n                methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\r\n                currentOffset += 1;\r\n                break;\r\n            case Constants.ISTORE_0:\r\n            case Constants.ISTORE_1:\r\n            case Constants.ISTORE_2:\r\n            case Constants.ISTORE_3:\r\n            case Constants.LSTORE_0:\r\n            case Constants.LSTORE_1:\r\n            case Constants.LSTORE_2:\r\n            case Constants.LSTORE_3:\r\n            case Constants.FSTORE_0:\r\n            case Constants.FSTORE_1:\r\n            case Constants.FSTORE_2:\r\n            case Constants.FSTORE_3:\r\n            case Constants.DSTORE_0:\r\n            case Constants.DSTORE_1:\r\n            case Constants.DSTORE_2:\r\n            case Constants.DSTORE_3:\r\n            case Constants.ASTORE_0:\r\n            case Constants.ASTORE_1:\r\n            case Constants.ASTORE_2:\r\n            case Constants.ASTORE_3:\r\n                opcode -= Constants.ISTORE_0;\r\n                methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\r\n                currentOffset += 1;\r\n                break;\r\n            case Opcodes.IFEQ:\r\n            case Opcodes.IFNE:\r\n            case Opcodes.IFLT:\r\n            case Opcodes.IFGE:\r\n            case Opcodes.IFGT:\r\n            case Opcodes.IFLE:\r\n            case Opcodes.IF_ICMPEQ:\r\n            case Opcodes.IF_ICMPNE:\r\n            case Opcodes.IF_ICMPLT:\r\n            case Opcodes.IF_ICMPGE:\r\n            case Opcodes.IF_ICMPGT:\r\n            case Opcodes.IF_ICMPLE:\r\n            case Opcodes.IF_ACMPEQ:\r\n            case Opcodes.IF_ACMPNE:\r\n            case Opcodes.GOTO:\r\n            case Opcodes.JSR:\r\n            case Opcodes.IFNULL:\r\n            case Opcodes.IFNONNULL:\r\n                methodVisitor.visitJumpInsn(opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);\r\n                currentOffset += 3;\r\n                break;\r\n            case Constants.GOTO_W:\r\n            case Constants.JSR_W:\r\n                methodVisitor.visitJumpInsn(opcode - wideJumpOpcodeDelta, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.ASM_IFEQ:\r\n            case Constants.ASM_IFNE:\r\n            case Constants.ASM_IFLT:\r\n            case Constants.ASM_IFGE:\r\n            case Constants.ASM_IFGT:\r\n            case Constants.ASM_IFLE:\r\n            case Constants.ASM_IF_ICMPEQ:\r\n            case Constants.ASM_IF_ICMPNE:\r\n            case Constants.ASM_IF_ICMPLT:\r\n            case Constants.ASM_IF_ICMPGE:\r\n            case Constants.ASM_IF_ICMPGT:\r\n            case Constants.ASM_IF_ICMPLE:\r\n            case Constants.ASM_IF_ACMPEQ:\r\n            case Constants.ASM_IF_ACMPNE:\r\n            case Constants.ASM_GOTO:\r\n            case Constants.ASM_JSR:\r\n            case Constants.ASM_IFNULL:\r\n            case Constants.ASM_IFNONNULL:\r\n                {\r\n                    // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO\r\n                    // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,\r\n                    // where IFNOTxxx is the \"opposite\" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and\r\n                    // where <L> designates the instruction just after the GOTO_W.\r\n                    // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and\r\n                    // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.\r\n                    opcode = opcode < Constants.ASM_IFNULL ? opcode - Constants.ASM_OPCODE_DELTA : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;\r\n                    Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];\r\n                    if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {\r\n                        // Replace GOTO with GOTO_W and JSR with JSR_W.\r\n                        methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);\r\n                    } else {\r\n                        // Compute the \"opposite\" of opcode. This can be done by flipping the least\r\n                        // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ\r\n                        // (with a pre and post offset by 1).\r\n                        opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;\r\n                        Label endif = createLabel(currentBytecodeOffset + 3, labels);\r\n                        methodVisitor.visitJumpInsn(opcode, endif);\r\n                        methodVisitor.visitJumpInsn(Constants.GOTO_W, target);\r\n                        // endif designates the instruction just after GOTO_W, and is visited as part of the\r\n                        // next instruction. Since it is a jump target, we need to insert a frame here.\r\n                        insertFrame = true;\r\n                    }\r\n                    currentOffset += 3;\r\n                    break;\r\n                }\r\n            case Constants.ASM_GOTO_W:\r\n                // Replace ASM_GOTO_W with GOTO_W.\r\n                methodVisitor.visitJumpInsn(Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);\r\n                // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns\r\n                // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame\r\n                // here.\r\n                insertFrame = true;\r\n                currentOffset += 5;\r\n                break;\r\n            case Constants.WIDE:\r\n                opcode = classBuffer[currentOffset + 1] & 0xFF;\r\n                if (opcode == Opcodes.IINC) {\r\n                    methodVisitor.visitIincInsn(readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));\r\n                    currentOffset += 6;\r\n                } else {\r\n                    methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));\r\n                    currentOffset += 4;\r\n                }\r\n                break;\r\n            case Opcodes.TABLESWITCH:\r\n                {\r\n                    // Skip 0 to 3 padding bytes.\r\n                    currentOffset += 4 - (currentBytecodeOffset & 3);\r\n                    // Read the instruction.\r\n                    Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                    int low = readInt(currentOffset + 4);\r\n                    int high = readInt(currentOffset + 8);\r\n                    currentOffset += 12;\r\n                    Label[] table = new Label[high - low + 1];\r\n                    for (int i = 0; i < table.length; ++i) {\r\n                        table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                        currentOffset += 4;\r\n                    }\r\n                    methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);\r\n                    break;\r\n                }\r\n            case Opcodes.LOOKUPSWITCH:\r\n                {\r\n                    // Skip 0 to 3 padding bytes.\r\n                    currentOffset += 4 - (currentBytecodeOffset & 3);\r\n                    // Read the instruction.\r\n                    Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];\r\n                    int numPairs = readInt(currentOffset + 4);\r\n                    currentOffset += 8;\r\n                    int[] keys = new int[numPairs];\r\n                    Label[] values = new Label[numPairs];\r\n                    for (int i = 0; i < numPairs; ++i) {\r\n                        keys[i] = readInt(currentOffset);\r\n                        values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];\r\n                        currentOffset += 8;\r\n                    }\r\n                    methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);\r\n                    break;\r\n                }\r\n            case Opcodes.ILOAD:\r\n            case Opcodes.LLOAD:\r\n            case Opcodes.FLOAD:\r\n            case Opcodes.DLOAD:\r\n            case Opcodes.ALOAD:\r\n            case Opcodes.ISTORE:\r\n            case Opcodes.LSTORE:\r\n            case Opcodes.FSTORE:\r\n            case Opcodes.DSTORE:\r\n            case Opcodes.ASTORE:\r\n            case Opcodes.RET:\r\n                methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.BIPUSH:\r\n            case Opcodes.NEWARRAY:\r\n                methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);\r\n                currentOffset += 2;\r\n                break;\r\n            case Opcodes.SIPUSH:\r\n                methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.LDC:\r\n                methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));\r\n                currentOffset += 2;\r\n                break;\r\n            case Constants.LDC_W:\r\n            case Constants.LDC2_W:\r\n                methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.GETSTATIC:\r\n            case Opcodes.PUTSTATIC:\r\n            case Opcodes.GETFIELD:\r\n            case Opcodes.PUTFIELD:\r\n            case Opcodes.INVOKEVIRTUAL:\r\n            case Opcodes.INVOKESPECIAL:\r\n            case Opcodes.INVOKESTATIC:\r\n            case Opcodes.INVOKEINTERFACE:\r\n                {\r\n                    int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\r\n                    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n                    String owner = readClass(cpInfoOffset, charBuffer);\r\n                    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n                    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n                    if (opcode < Opcodes.INVOKEVIRTUAL) {\r\n                        methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);\r\n                    } else {\r\n                        boolean isInterface = classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\r\n                        methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\r\n                    }\r\n                    if (opcode == Opcodes.INVOKEINTERFACE) {\r\n                        currentOffset += 5;\r\n                    } else {\r\n                        currentOffset += 3;\r\n                    }\r\n                    break;\r\n                }\r\n            case Opcodes.INVOKEDYNAMIC:\r\n                {\r\n                    int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];\r\n                    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n                    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n                    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n                    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\r\n                    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n                    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\r\n                    bootstrapMethodOffset += 4;\r\n                    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\r\n                        bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n                        bootstrapMethodOffset += 2;\r\n                    }\r\n                    methodVisitor.visitInvokeDynamicInsn(name, descriptor, handle, bootstrapMethodArguments);\r\n                    currentOffset += 5;\r\n                    break;\r\n                }\r\n            case Opcodes.NEW:\r\n            case Opcodes.ANEWARRAY:\r\n            case Opcodes.CHECKCAST:\r\n            case Opcodes.INSTANCEOF:\r\n                methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.IINC:\r\n                methodVisitor.visitIincInsn(classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);\r\n                currentOffset += 3;\r\n                break;\r\n            case Opcodes.MULTIANEWARRAY:\r\n                methodVisitor.visitMultiANewArrayInsn(readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);\r\n                currentOffset += 4;\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n        // Visit the runtime visible instruction annotations, if any.\r\n        while (visibleTypeAnnotationOffsets != null && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\r\n            if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                int currentAnnotationOffset = readTypeAnnotationTarget(context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n                currentAnnotationOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n                true), currentAnnotationOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n            currentVisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);\r\n        }\r\n        // Visit the runtime invisible instruction annotations, if any.\r\n        while (invisibleTypeAnnotationOffsets != null && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {\r\n            if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                int currentAnnotationOffset = readTypeAnnotationTarget(context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);\r\n                currentAnnotationOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitInsnAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, annotationDescriptor, /* visible= */\r\n                false), currentAnnotationOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n            currentInvisibleTypeAnnotationBytecodeOffset = getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);\r\n        }\r\n    }\r\n    if (labels[codeLength] != null) {\r\n        methodVisitor.visitLabel(labels[codeLength]);\r\n    }\r\n    // Visit LocalVariableTable and LocalVariableTypeTable attributes.\r\n    if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {\r\n        // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.\r\n        int[] typeTable = null;\r\n        if (localVariableTypeTableOffset != 0) {\r\n            typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];\r\n            currentOffset = localVariableTypeTableOffset + 2;\r\n            int typeTableIndex = typeTable.length;\r\n            while (typeTableIndex > 0) {\r\n                // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.\r\n                typeTable[--typeTableIndex] = currentOffset + 6;\r\n                typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);\r\n                typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);\r\n                currentOffset += 10;\r\n            }\r\n        }\r\n        int localVariableTableLength = readUnsignedShort(localVariableTableOffset);\r\n        currentOffset = localVariableTableOffset + 2;\r\n        while (localVariableTableLength-- > 0) {\r\n            int startPc = readUnsignedShort(currentOffset);\r\n            int length = readUnsignedShort(currentOffset + 2);\r\n            String name = readUTF8(currentOffset + 4, charBuffer);\r\n            String descriptor = readUTF8(currentOffset + 6, charBuffer);\r\n            int index = readUnsignedShort(currentOffset + 8);\r\n            currentOffset += 10;\r\n            String signature = null;\r\n            if (typeTable != null) {\r\n                for (int i = 0; i < typeTable.length; i += 3) {\r\n                    if (typeTable[i] == startPc && typeTable[i + 1] == index) {\r\n                        signature = readUTF8(typeTable[i + 2], charBuffer);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            methodVisitor.visitLocalVariable(name, descriptor, signature, labels[startPc], labels[startPc + length], index);\r\n        }\r\n    }\r\n    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.\r\n    if (visibleTypeAnnotationOffsets != null) {\r\n        for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {\r\n            int targetType = readByte(typeAnnotationOffset);\r\n            if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n                currentOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor, /* visible= */\r\n                true), currentOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n        }\r\n    }\r\n    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.\r\n    if (invisibleTypeAnnotationOffsets != null) {\r\n        for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {\r\n            int targetType = readByte(typeAnnotationOffset);\r\n            if (targetType == TypeReference.LOCAL_VARIABLE || targetType == TypeReference.RESOURCE_VARIABLE) {\r\n                // Parse the target_type, target_info and target_path fields.\r\n                currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);\r\n                // Parse the type_index field.\r\n                String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n                currentOffset += 2;\r\n                // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n                readElementValues(methodVisitor.visitLocalVariableAnnotation(context.currentTypeAnnotationTarget, context.currentTypeAnnotationTargetPath, context.currentLocalVariableAnnotationRangeStarts, context.currentLocalVariableAnnotationRangeEnds, context.currentLocalVariableAnnotationRangeIndices, annotationDescriptor, /* visible= */\r\n                false), currentOffset, /* named= */\r\n                true, charBuffer);\r\n            }\r\n        }\r\n    }\r\n    // Visit the non standard attributes.\r\n    while (attributes != null) {\r\n        // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.\r\n        Attribute nextAttribute = attributes.nextAttribute;\r\n        attributes.nextAttribute = null;\r\n        methodVisitor.visitAttribute(attributes);\r\n        attributes = nextAttribute;\r\n    }\r\n    // Visit the max stack and max locals values.\r\n    methodVisitor.visitMaxs(maxStack, maxLocals);\r\n}",
    "comment": "\n   * Reads a JVMS 'Code' attribute and makes the given visitor visit it.\n   *\n   * @param methodVisitor the visitor that must visit the Code attribute.\n   * @param context information about the class being parsed.\n   * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding\n   *     its attribute_name_index and attribute_length fields.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
    "entityType": "method",
    "code": "/**\r\n * Handles the bytecode offset of the next instruction to be visited in {@link\r\n * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\r\n * associated label and stack map frame, if any. The default implementation of this method does\r\n * nothing. Subclasses can override this method to store the argument in a mutable field, for\r\n * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\r\n * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\r\n *\r\n * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\r\n */\r\nprotected void readBytecodeInstructionOffset(final int bytecodeOffset) {\r\n    // Do nothing by default.\r\n}",
    "comment": "\n   * Handles the bytecode offset of the next instruction to be visited in {@link\n   * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\n   * associated label and stack map frame, if any. The default implementation of this method does\n   * nothing. Subclasses can override this method to store the argument in a mutable field, for\n   * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\n   * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\n   *\n   * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Returns the label corresponding to the given bytecode offset. The default implementation of\r\n * this method creates a label for the given offset if it has not been already created.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset. If a label already exists\r\n *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\r\n *     label in this array.\r\n * @return a non null Label, which must be equal to labels[bytecodeOffset].\r\n */\r\nprotected Label readLabel(final int bytecodeOffset, final Label[] labels) {\r\n    // SPRING PATCH: leniently handle offset mismatch\r\n    if (bytecodeOffset >= labels.length) {\r\n        return new Label();\r\n    }\r\n    // END OF PATCH\r\n    if (labels[bytecodeOffset] == null) {\r\n        labels[bytecodeOffset] = new Label();\r\n    }\r\n    return labels[bytecodeOffset];\r\n}",
    "comment": "\n   * Returns the label corresponding to the given bytecode offset. The default implementation of\n   * this method creates a label for the given offset if it has not been already created.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset. If a label already exists\n   *     for bytecodeOffset this method must not create a new one. Otherwise it must store the new\n   *     label in this array.\n   * @return a non null Label, which must be equal to labels[bytecodeOffset].\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\r\n * offset. The label is created with a call to {@link #readLabel} and its {@link\r\n * Label#FLAG_DEBUG_ONLY} flag is cleared.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset.\r\n * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\r\n */\r\nprivate Label createLabel(final int bytecodeOffset, final Label[] labels) {\r\n    Label label = readLabel(bytecodeOffset, labels);\r\n    label.flags &= ~Label.FLAG_DEBUG_ONLY;\r\n    return label;\r\n}",
    "comment": "\n   * Creates a label without the {@link Label#FLAG_DEBUG_ONLY} flag set, for the given bytecode\n   * offset. The label is created with a call to {@link #readLabel} and its {@link\n   * Label#FLAG_DEBUG_ONLY} flag is cleared.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset.\n   * @return a Label without the {@link Label#FLAG_DEBUG_ONLY} flag set.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#createDebugLabel(int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\r\n * existing label for the given bytecode offset (otherwise does nothing). The label is created\r\n * with a call to {@link #readLabel}.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset.\r\n */\r\nprivate void createDebugLabel(final int bytecodeOffset, final Label[] labels) {\r\n    if (labels[bytecodeOffset] == null) {\r\n        readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;\r\n    }\r\n}",
    "comment": "\n   * Creates a label with the {@link Label#FLAG_DEBUG_ONLY} flag set, if there is no already\n   * existing label for the given bytecode offset (otherwise does nothing). The label is created\n   * with a call to {@link #readLabel}.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
    "entityType": "method",
    "code": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse annotations, type annotations and parameter annotations\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\r\n * entry it contains, to find the corresponding labels, and to visit the try catch block\r\n * annotations.\r\n *\r\n * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\r\n * @param context information about the class being parsed.\r\n * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\r\n *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\r\n * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\r\n *     false it is a RuntimeInvisibleTypeAnnotations attribute.\r\n * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\r\n *     'annotations' array field.\r\n */\r\nprivate int[] readTypeAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeTypeAnnotationsOffset, final boolean visible) {\r\n    char[] charBuffer = context.charBuffer;\r\n    int currentOffset = runtimeTypeAnnotationsOffset;\r\n    // Read the num_annotations field and create an array to store the type_annotation offsets.\r\n    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];\r\n    currentOffset += 2;\r\n    // Parse the 'annotations' array field.\r\n    for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {\r\n        typeAnnotationsOffsets[i] = currentOffset;\r\n        // Parse the type_annotation's target_type and the target_info fields. The size of the\r\n        // target_info field depends on the value of target_type.\r\n        int targetType = readInt(currentOffset);\r\n        switch(targetType >>> 24) {\r\n            case TypeReference.LOCAL_VARIABLE:\r\n            case TypeReference.RESOURCE_VARIABLE:\r\n                // A localvar_target has a variable size, which depends on the value of their table_length\r\n                // field. It also references bytecode offsets, for which we need labels.\r\n                int tableLength = readUnsignedShort(currentOffset + 1);\r\n                currentOffset += 3;\r\n                while (tableLength-- > 0) {\r\n                    int startPc = readUnsignedShort(currentOffset);\r\n                    int length = readUnsignedShort(currentOffset + 2);\r\n                    // Skip the index field (2 bytes).\r\n                    currentOffset += 6;\r\n                    createLabel(startPc, context.currentMethodLabels);\r\n                    createLabel(startPc + length, context.currentMethodLabels);\r\n                }\r\n                break;\r\n            case TypeReference.CAST:\r\n            case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n            case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\r\n            case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n            case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\r\n                currentOffset += 4;\r\n                break;\r\n            case TypeReference.CLASS_EXTENDS:\r\n            case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\r\n            case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\r\n            case TypeReference.THROWS:\r\n            case TypeReference.EXCEPTION_PARAMETER:\r\n            case TypeReference.INSTANCEOF:\r\n            case TypeReference.NEW:\r\n            case TypeReference.CONSTRUCTOR_REFERENCE:\r\n            case TypeReference.METHOD_REFERENCE:\r\n                currentOffset += 3;\r\n                break;\r\n            case TypeReference.CLASS_TYPE_PARAMETER:\r\n            case TypeReference.METHOD_TYPE_PARAMETER:\r\n            case TypeReference.METHOD_FORMAL_PARAMETER:\r\n            case TypeReference.FIELD:\r\n            case TypeReference.METHOD_RETURN:\r\n            case TypeReference.METHOD_RECEIVER:\r\n            default:\r\n                // TypeReference type which can't be used in Code attribute, or which is unknown.\r\n                throw new IllegalArgumentException();\r\n        }\r\n        // Parse the rest of the type_annotation structure, starting with the target_path structure\r\n        // (whose size depends on its path_length field).\r\n        int pathLength = readByte(currentOffset);\r\n        if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {\r\n            // Parse the target_path structure and create a corresponding TypePath.\r\n            TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\r\n            currentOffset += 1 + 2 * pathLength;\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentOffset = readElementValues(methodVisitor.visitTryCatchAnnotation(targetType & 0xFFFFFF00, path, annotationDescriptor, visible), currentOffset, /* named= */\r\n            true, charBuffer);\r\n        } else {\r\n            // We don't want to visit the other target_type annotations, so we just skip them (which\r\n            // requires some parsing because the element_value_pairs array has a variable size). First,\r\n            // skip the target_path structure:\r\n            currentOffset += 3 + 2 * pathLength;\r\n            // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them\r\n            // with a null AnnotationVisitor).\r\n            currentOffset = readElementValues(/* annotationVisitor= */\r\n            null, currentOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n    return typeAnnotationsOffsets;\r\n}",
    "comment": "\n   * Parses a Runtime[In]VisibleTypeAnnotations attribute to find the offset of each type_annotation\n   * entry it contains, to find the corresponding labels, and to visit the try catch block\n   * annotations.\n   *\n   * @param methodVisitor the method visitor to be used to visit the try catch block annotations.\n   * @param context information about the class being parsed.\n   * @param runtimeTypeAnnotationsOffset the start offset of a Runtime[In]VisibleTypeAnnotations\n   *     attribute, excluding the attribute_info's attribute_name_index and attribute_length fields.\n   * @param visible true if the attribute to parse is a RuntimeVisibleTypeAnnotations attribute,\n   *     false it is a RuntimeInvisibleTypeAnnotations attribute.\n   * @return the start offset of each entry of the Runtime[In]VisibleTypeAnnotations_attribute's\n   *     'annotations' array field.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\r\n * -1 if there is no such type_annotation of if it does not have a bytecode offset.\r\n *\r\n * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\r\n *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\r\n * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\r\n * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\r\n *     if there is no such type_annotation of if it does not have a bytecode offset.\r\n */\r\nprivate int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\r\n    if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\r\n        return -1;\r\n    }\r\n    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\r\n}",
    "comment": "\n   * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n   * -1 if there is no such type_annotation of if it does not have a bytecode offset.\n   *\n   * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\n   *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.\n   * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n   * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\n   *     if there is no such type_annotation of if it does not have a bytecode offset.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
    "entityType": "method",
    "code": "/**\r\n * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\r\n * and target_path (the result is stored in the given context), and returns the start offset of\r\n * the rest of the type_annotation structure.\r\n *\r\n * @param context information about the class being parsed. This is where the extracted\r\n *     target_type and target_path must be stored.\r\n * @param typeAnnotationOffset the start offset of a type_annotation structure.\r\n * @return the start offset of the rest of the type_annotation structure.\r\n */\r\nprivate int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {\r\n    int currentOffset = typeAnnotationOffset;\r\n    // Parse and store the target_type structure.\r\n    int targetType = readInt(typeAnnotationOffset);\r\n    switch(targetType >>> 24) {\r\n        case TypeReference.CLASS_TYPE_PARAMETER:\r\n        case TypeReference.METHOD_TYPE_PARAMETER:\r\n        case TypeReference.METHOD_FORMAL_PARAMETER:\r\n            targetType &= 0xFFFF0000;\r\n            currentOffset += 2;\r\n            break;\r\n        case TypeReference.FIELD:\r\n        case TypeReference.METHOD_RETURN:\r\n        case TypeReference.METHOD_RECEIVER:\r\n            targetType &= 0xFF000000;\r\n            currentOffset += 1;\r\n            break;\r\n        case TypeReference.LOCAL_VARIABLE:\r\n        case TypeReference.RESOURCE_VARIABLE:\r\n            targetType &= 0xFF000000;\r\n            int tableLength = readUnsignedShort(currentOffset + 1);\r\n            currentOffset += 3;\r\n            context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];\r\n            context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];\r\n            context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];\r\n            for (int i = 0; i < tableLength; ++i) {\r\n                int startPc = readUnsignedShort(currentOffset);\r\n                int length = readUnsignedShort(currentOffset + 2);\r\n                int index = readUnsignedShort(currentOffset + 4);\r\n                currentOffset += 6;\r\n                context.currentLocalVariableAnnotationRangeStarts[i] = createLabel(startPc, context.currentMethodLabels);\r\n                context.currentLocalVariableAnnotationRangeEnds[i] = createLabel(startPc + length, context.currentMethodLabels);\r\n                context.currentLocalVariableAnnotationRangeIndices[i] = index;\r\n            }\r\n            break;\r\n        case TypeReference.CAST:\r\n        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:\r\n        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:\r\n            targetType &= 0xFF0000FF;\r\n            currentOffset += 4;\r\n            break;\r\n        case TypeReference.CLASS_EXTENDS:\r\n        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:\r\n        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:\r\n        case TypeReference.THROWS:\r\n        case TypeReference.EXCEPTION_PARAMETER:\r\n            targetType &= 0xFFFFFF00;\r\n            currentOffset += 3;\r\n            break;\r\n        case TypeReference.INSTANCEOF:\r\n        case TypeReference.NEW:\r\n        case TypeReference.CONSTRUCTOR_REFERENCE:\r\n        case TypeReference.METHOD_REFERENCE:\r\n            targetType &= 0xFF000000;\r\n            currentOffset += 3;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    context.currentTypeAnnotationTarget = targetType;\r\n    // Parse and store the target_path structure.\r\n    int pathLength = readByte(currentOffset);\r\n    context.currentTypeAnnotationTargetPath = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);\r\n    // Return the start offset of the rest of the type_annotation structure.\r\n    return currentOffset + 1 + 2 * pathLength;\r\n}",
    "comment": "\n   * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info\n   * and target_path (the result is stored in the given context), and returns the start offset of\n   * the rest of the type_annotation structure.\n   *\n   * @param context information about the class being parsed. This is where the extracted\n   *     target_type and target_path must be stored.\n   * @param typeAnnotationOffset the start offset of a type_annotation structure.\n   * @return the start offset of the rest of the type_annotation structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\r\n *\r\n * @param methodVisitor the visitor that must visit the parameter annotations.\r\n * @param context information about the class being parsed.\r\n * @param runtimeParameterAnnotationsOffset the start offset of a\r\n *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\r\n *     attribute_name_index and attribute_length fields.\r\n * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\r\n *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\r\n */\r\nprivate void readParameterAnnotations(final MethodVisitor methodVisitor, final Context context, final int runtimeParameterAnnotationsOffset, final boolean visible) {\r\n    int currentOffset = runtimeParameterAnnotationsOffset;\r\n    int numParameters = classFileBuffer[currentOffset++] & 0xFF;\r\n    methodVisitor.visitAnnotableParameterCount(numParameters, visible);\r\n    char[] charBuffer = context.charBuffer;\r\n    for (int i = 0; i < numParameters; ++i) {\r\n        int numAnnotations = readUnsignedShort(currentOffset);\r\n        currentOffset += 2;\r\n        while (numAnnotations-- > 0) {\r\n            // Parse the type_index field.\r\n            String annotationDescriptor = readUTF8(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            // Parse num_element_value_pairs and element_value_pairs and visit these values.\r\n            currentOffset = readElementValues(methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible), currentOffset, /* named= */\r\n            true, charBuffer);\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.\n   *\n   * @param methodVisitor the visitor that must visit the parameter annotations.\n   * @param context information about the class being parsed.\n   * @param runtimeParameterAnnotationsOffset the start offset of a\n   *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info's\n   *     attribute_name_index and attribute_length fields.\n   * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations\n   *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\r\n * them. This method can also be used to read the values of the JVMS 'array_value' field of an\r\n * annotation's 'element_value'.\r\n *\r\n * @param annotationVisitor the visitor that must visit the values.\r\n * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\r\n *     field) or of an 'array_value' structure.\r\n * @param named if the annotation values are named or not. This should be true to parse the values\r\n *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\r\n *     annotation's element_value.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\r\n */\r\nprivate int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\r\n    int currentOffset = annotationOffset;\r\n    // Read the num_element_value_pairs field (or num_values field for an array_value).\r\n    int numElementValuePairs = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    if (named) {\r\n        // Parse the element_value_pairs array.\r\n        while (numElementValuePairs-- > 0) {\r\n            String elementName = readUTF8(currentOffset, charBuffer);\r\n            currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);\r\n        }\r\n    } else {\r\n        // Parse the array_value array.\r\n        while (numElementValuePairs-- > 0) {\r\n            currentOffset = readElementValue(annotationVisitor, currentOffset, /* elementName= */\r\n            null, charBuffer);\r\n        }\r\n    }\r\n    if (annotationVisitor != null) {\r\n        annotationVisitor.visitEnd();\r\n    }\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\n   * them. This method can also be used to read the values of the JVMS 'array_value' field of an\n   * annotation's 'element_value'.\n   *\n   * @param annotationVisitor the visitor that must visit the values.\n   * @param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\n   *     field) or of an 'array_value' structure.\n   * @param named if the annotation values are named or not. This should be true to parse the values\n   *     of a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\n   *     annotation's element_value.\n   * @param charBuffer the buffer used to read strings in the constant pool.\n   * @return the end offset of the JVMS 'annotation' or 'array_value' structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\r\n *\r\n * @param annotationVisitor the visitor that must visit the element_value structure.\r\n * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\r\n *     structure to be read.\r\n * @param elementName the name of the element_value structure to be read, or {@literal null}.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @return the end offset of the JVMS 'element_value' structure.\r\n */\r\nprivate int readElementValue(final AnnotationVisitor annotationVisitor, final int elementValueOffset, final String elementName, final char[] charBuffer) {\r\n    int currentOffset = elementValueOffset;\r\n    if (annotationVisitor == null) {\r\n        switch(classFileBuffer[currentOffset] & 0xFF) {\r\n            case // enum_const_value\r\n            'e':\r\n                return currentOffset + 5;\r\n            case // annotation_value\r\n            '@':\r\n                return readElementValues(null, currentOffset + 3, /* named= */\r\n                true, charBuffer);\r\n            case // array_value\r\n            '[':\r\n                return readElementValues(null, currentOffset + 1, /* named= */\r\n                false, charBuffer);\r\n            default:\r\n                return currentOffset + 3;\r\n        }\r\n    }\r\n    switch(classFileBuffer[currentOffset++] & 0xFF) {\r\n        case // const_value_index, CONSTANT_Integer\r\n        'B':\r\n            annotationVisitor.visit(elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'C':\r\n            annotationVisitor.visit(elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        // const_value_index, CONSTANT_Double\r\n        case 'D':\r\n        // const_value_index, CONSTANT_Float\r\n        case 'F':\r\n        // const_value_index, CONSTANT_Integer\r\n        case 'I':\r\n        case // const_value_index, CONSTANT_Long\r\n        'J':\r\n            annotationVisitor.visit(elementName, readConst(readUnsignedShort(currentOffset), charBuffer));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'S':\r\n            annotationVisitor.visit(elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Integer\r\n        'Z':\r\n            annotationVisitor.visit(elementName, readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\r\n            currentOffset += 2;\r\n            break;\r\n        case // const_value_index, CONSTANT_Utf8\r\n        's':\r\n            annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));\r\n            currentOffset += 2;\r\n            break;\r\n        case // enum_const_value\r\n        'e':\r\n            annotationVisitor.visitEnum(elementName, readUTF8(currentOffset, charBuffer), readUTF8(currentOffset + 2, charBuffer));\r\n            currentOffset += 4;\r\n            break;\r\n        case // class_info\r\n        'c':\r\n            annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));\r\n            currentOffset += 2;\r\n            break;\r\n        case // annotation_value\r\n        '@':\r\n            currentOffset = readElementValues(annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)), currentOffset + 2, true, charBuffer);\r\n            break;\r\n        case // array_value\r\n        '[':\r\n            int numValues = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            if (numValues == 0) {\r\n                return readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2, /* named= */\r\n                false, charBuffer);\r\n            }\r\n            switch(classFileBuffer[currentOffset] & 0xFF) {\r\n                case 'B':\r\n                    byte[] byteValues = new byte[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, byteValues);\r\n                    break;\r\n                case 'Z':\r\n                    boolean[] booleanValues = new boolean[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, booleanValues);\r\n                    break;\r\n                case 'S':\r\n                    short[] shortValues = new short[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, shortValues);\r\n                    break;\r\n                case 'C':\r\n                    char[] charValues = new char[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, charValues);\r\n                    break;\r\n                case 'I':\r\n                    int[] intValues = new int[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, intValues);\r\n                    break;\r\n                case 'J':\r\n                    long[] longValues = new long[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, longValues);\r\n                    break;\r\n                case 'F':\r\n                    float[] floatValues = new float[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        floatValues[i] = Float.intBitsToFloat(readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, floatValues);\r\n                    break;\r\n                case 'D':\r\n                    double[] doubleValues = new double[numValues];\r\n                    for (int i = 0; i < numValues; i++) {\r\n                        doubleValues[i] = Double.longBitsToDouble(readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));\r\n                        currentOffset += 3;\r\n                    }\r\n                    annotationVisitor.visit(elementName, doubleValues);\r\n                    break;\r\n                default:\r\n                    currentOffset = readElementValues(annotationVisitor.visitArray(elementName), currentOffset - 2, /* named= */\r\n                    false, charBuffer);\r\n                    break;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads a JVMS 'element_value' structure and makes the given visitor visit it.\n   *\n   * @param annotationVisitor the visitor that must visit the element_value structure.\n   * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value\n   *     structure to be read.\n   * @param elementName the name of the element_value structure to be read, or {@literal null}.\n   * @param charBuffer the buffer used to read strings in the constant pool.\n   * @return the end offset of the JVMS 'element_value' structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
    "entityType": "method",
    "code": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse stack map frames\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Computes the implicit frame of the method currently being parsed (as defined in the given\r\n * {@link Context}) and stores it in the given context.\r\n *\r\n * @param context information about the class being parsed.\r\n */\r\nprivate void computeImplicitFrame(final Context context) {\r\n    String methodDescriptor = context.currentMethodDescriptor;\r\n    Object[] locals = context.currentFrameLocalTypes;\r\n    int numLocal = 0;\r\n    if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {\r\n        if (\"<init>\".equals(context.currentMethodName)) {\r\n            locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;\r\n        } else {\r\n            locals[numLocal++] = readClass(header + 2, context.charBuffer);\r\n        }\r\n    }\r\n    // Parse the method descriptor, one argument type descriptor at each iteration. Start by\r\n    // skipping the first method descriptor character, which is always '('.\r\n    int currentMethodDescritorOffset = 1;\r\n    while (true) {\r\n        int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;\r\n        switch(methodDescriptor.charAt(currentMethodDescritorOffset++)) {\r\n            case 'Z':\r\n            case 'C':\r\n            case 'B':\r\n            case 'S':\r\n            case 'I':\r\n                locals[numLocal++] = Opcodes.INTEGER;\r\n                break;\r\n            case 'F':\r\n                locals[numLocal++] = Opcodes.FLOAT;\r\n                break;\r\n            case 'J':\r\n                locals[numLocal++] = Opcodes.LONG;\r\n                break;\r\n            case 'D':\r\n                locals[numLocal++] = Opcodes.DOUBLE;\r\n                break;\r\n            case '[':\r\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {\r\n                    ++currentMethodDescritorOffset;\r\n                }\r\n                if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {\r\n                    ++currentMethodDescritorOffset;\r\n                    while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\r\n                        ++currentMethodDescritorOffset;\r\n                    }\r\n                }\r\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);\r\n                break;\r\n            case 'L':\r\n                while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {\r\n                    ++currentMethodDescritorOffset;\r\n                }\r\n                locals[numLocal++] = methodDescriptor.substring(currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);\r\n                break;\r\n            default:\r\n                context.currentFrameLocalCount = numLocal;\r\n                return;\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Computes the implicit frame of the method currently being parsed (as defined in the given\n   * {@link Context}) and stores it in the given context.\n   *\n   * @param context information about the class being parsed.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
    "entityType": "method",
    "code": "/**\r\n * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\r\n * object. This method can also be used to read a full_frame structure, excluding its frame_type\r\n * field (this is used to parse the legacy StackMap attributes).\r\n *\r\n * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\r\n *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\r\n *     (excluding its frame_type field).\r\n * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\r\n *     structure without its frame_type field.\r\n * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\r\n * @param context where the parsed stack map frame must be stored.\r\n * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\r\n */\r\nprivate int readStackMapFrame(final int stackMapFrameOffset, final boolean compressed, final boolean expand, final Context context) {\r\n    int currentOffset = stackMapFrameOffset;\r\n    final char[] charBuffer = context.charBuffer;\r\n    final Label[] labels = context.currentMethodLabels;\r\n    int frameType;\r\n    if (compressed) {\r\n        // Read the frame_type field.\r\n        frameType = classFileBuffer[currentOffset++] & 0xFF;\r\n    } else {\r\n        frameType = Frame.FULL_FRAME;\r\n        context.currentFrameOffset = -1;\r\n    }\r\n    int offsetDelta;\r\n    context.currentFrameLocalCountDelta = 0;\r\n    if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {\r\n        offsetDelta = frameType;\r\n        context.currentFrameType = Opcodes.F_SAME;\r\n        context.currentFrameStackCount = 0;\r\n    } else if (frameType < Frame.RESERVED) {\r\n        offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;\r\n        currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\r\n        context.currentFrameType = Opcodes.F_SAME1;\r\n        context.currentFrameStackCount = 1;\r\n    } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\r\n        offsetDelta = readUnsignedShort(currentOffset);\r\n        currentOffset += 2;\r\n        if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\r\n            currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);\r\n            context.currentFrameType = Opcodes.F_SAME1;\r\n            context.currentFrameStackCount = 1;\r\n        } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {\r\n            context.currentFrameType = Opcodes.F_CHOP;\r\n            context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;\r\n            context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;\r\n            context.currentFrameStackCount = 0;\r\n        } else if (frameType == Frame.SAME_FRAME_EXTENDED) {\r\n            context.currentFrameType = Opcodes.F_SAME;\r\n            context.currentFrameStackCount = 0;\r\n        } else if (frameType < Frame.FULL_FRAME) {\r\n            int local = expand ? context.currentFrameLocalCount : 0;\r\n            for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);\r\n            }\r\n            context.currentFrameType = Opcodes.F_APPEND;\r\n            context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;\r\n            context.currentFrameLocalCount += context.currentFrameLocalCountDelta;\r\n            context.currentFrameStackCount = 0;\r\n        } else {\r\n            final int numberOfLocals = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            context.currentFrameType = Opcodes.F_FULL;\r\n            context.currentFrameLocalCountDelta = numberOfLocals;\r\n            context.currentFrameLocalCount = numberOfLocals;\r\n            for (int local = 0; local < numberOfLocals; ++local) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);\r\n            }\r\n            final int numberOfStackItems = readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            context.currentFrameStackCount = numberOfStackItems;\r\n            for (int stack = 0; stack < numberOfStackItems; ++stack) {\r\n                currentOffset = readVerificationTypeInfo(currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);\r\n            }\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    context.currentFrameOffset += offsetDelta + 1;\r\n    createLabel(context.currentFrameOffset, labels);\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}\n   * object. This method can also be used to read a full_frame structure, excluding its frame_type\n   * field (this is used to parse the legacy StackMap attributes).\n   *\n   * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the\n   *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure\n   *     (excluding its frame_type field).\n   * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'\n   *     structure without its frame_type field.\n   * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.\n   * @param context where the parsed stack map frame must be stored.\n   * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readVerificationTypeInfo(int,Object[],int,char[],Label[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\r\n * array.\r\n *\r\n * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\r\n *     read.\r\n * @param frame the array where the parsed type must be stored.\r\n * @param index the index in 'frame' where the parsed type must be stored.\r\n * @param charBuffer the buffer used to read strings in the constant pool.\r\n * @param labels the labels of the method currently being parsed, indexed by their offset. If the\r\n *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\r\n *     stored in this array if it does not already exist.\r\n * @return the end offset of the JVMS 'verification_type_info' structure.\r\n */\r\nprivate int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\r\n    int currentOffset = verificationTypeInfoOffset;\r\n    int tag = classFileBuffer[currentOffset++] & 0xFF;\r\n    switch(tag) {\r\n        case Frame.ITEM_TOP:\r\n            frame[index] = Opcodes.TOP;\r\n            break;\r\n        case Frame.ITEM_INTEGER:\r\n            frame[index] = Opcodes.INTEGER;\r\n            break;\r\n        case Frame.ITEM_FLOAT:\r\n            frame[index] = Opcodes.FLOAT;\r\n            break;\r\n        case Frame.ITEM_DOUBLE:\r\n            frame[index] = Opcodes.DOUBLE;\r\n            break;\r\n        case Frame.ITEM_LONG:\r\n            frame[index] = Opcodes.LONG;\r\n            break;\r\n        case Frame.ITEM_NULL:\r\n            frame[index] = Opcodes.NULL;\r\n            break;\r\n        case Frame.ITEM_UNINITIALIZED_THIS:\r\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\r\n            break;\r\n        case Frame.ITEM_OBJECT:\r\n            frame[index] = readClass(currentOffset, charBuffer);\r\n            currentOffset += 2;\r\n            break;\r\n        case Frame.ITEM_UNINITIALIZED:\r\n            frame[index] = createLabel(readUnsignedShort(currentOffset), labels);\r\n            currentOffset += 2;\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n    return currentOffset;\r\n}",
    "comment": "\n   * Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\n   * array.\n   *\n   * @param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\n   *     read.\n   * @param frame the array where the parsed type must be stored.\n   * @param index the index in 'frame' where the parsed type must be stored.\n   * @param charBuffer the buffer used to read strings in the constant pool.\n   * @param labels the labels of the method currently being parsed, indexed by their offset. If the\n   *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\n   *     stored in this array if it does not already exist.\n   * @return the end offset of the JVMS 'verification_type_info' structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
    "entityType": "method",
    "code": "// ----------------------------------------------------------------------------------------------\r\n// Methods to parse attributes\r\n// ----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\r\n * field entry.\r\n *\r\n * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\r\n *     field entry.\r\n */\r\nfinal int getFirstAttributeOffset() {\r\n    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes\r\n    // each), as well as the interfaces array field (2 bytes per interface).\r\n    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;\r\n    // Read the fields_count field.\r\n    int fieldsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    // Skip the 'fields' array field.\r\n    while (fieldsCount-- > 0) {\r\n        // Invariant: currentOffset is the offset of a field_info structure.\r\n        // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the\r\n        // attributes_count field.\r\n        int attributesCount = readUnsignedShort(currentOffset + 6);\r\n        currentOffset += 8;\r\n        // Skip the 'attributes' array field.\r\n        while (attributesCount-- > 0) {\r\n            // Invariant: currentOffset is the offset of an attribute_info structure.\r\n            // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip\r\n            // this many bytes, plus 6 for the attribute_name_index and attribute_length fields\r\n            // (yielding the total size of the attribute_info structure).\r\n            currentOffset += 6 + readInt(currentOffset + 2);\r\n        }\r\n    }\r\n    // Skip the methods_count and 'methods' fields, using the same method as above.\r\n    int methodsCount = readUnsignedShort(currentOffset);\r\n    currentOffset += 2;\r\n    while (methodsCount-- > 0) {\r\n        int attributesCount = readUnsignedShort(currentOffset + 6);\r\n        currentOffset += 8;\r\n        while (attributesCount-- > 0) {\r\n            currentOffset += 6 + readInt(currentOffset + 2);\r\n        }\r\n    }\r\n    // Skip the ClassFile's attributes_count field.\r\n    return currentOffset + 2;\r\n}",
    "comment": "\n   * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n   * field entry.\n   *\n   * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array\n   *     field entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
    "entityType": "method",
    "code": "/**\r\n * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\r\n *\r\n * @param maxStringLength a conservative estimate of the maximum length of the strings contained\r\n *     in the constant pool of the class.\r\n * @return the offsets of the bootstrap methods.\r\n */\r\nprivate int[] readBootstrapMethodsAttribute(final int maxStringLength) {\r\n    char[] charBuffer = new char[maxStringLength];\r\n    int currentAttributeOffset = getFirstAttributeOffset();\r\n    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        // Read the attribute_info's attribute_name and attribute_length fields.\r\n        String attributeName = readUTF8(currentAttributeOffset, charBuffer);\r\n        int attributeLength = readInt(currentAttributeOffset + 2);\r\n        currentAttributeOffset += 6;\r\n        if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            // Read the num_bootstrap_methods field and create an array of this size.\r\n            int[] result = new int[readUnsignedShort(currentAttributeOffset)];\r\n            // Compute and store the offset of each 'bootstrap_methods' array field entry.\r\n            int currentBootstrapMethodOffset = currentAttributeOffset + 2;\r\n            for (int j = 0; j < result.length; ++j) {\r\n                result[j] = currentBootstrapMethodOffset;\r\n                // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),\r\n                // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).\r\n                currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;\r\n            }\r\n            return result;\r\n        }\r\n        currentAttributeOffset += attributeLength;\r\n    }\r\n    throw new IllegalArgumentException();\r\n}",
    "comment": "\n   * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n   *\n   * @param maxStringLength a conservative estimate of the maximum length of the strings contained\n   *     in the constant pool of the class.\n   * @return the offsets of the bootstrap methods.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\r\n *\r\n * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\r\n *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\r\n *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\r\n * @param type the type of the attribute.\r\n * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\r\n *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to read strings in the constant pool.\r\n * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\r\n *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a code attribute.\r\n * @return the attribute that has been read.\r\n */\r\nprivate Attribute readAttribute(final Attribute[] attributePrototypes, final String type, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    for (Attribute attributePrototype : attributePrototypes) {\r\n        if (attributePrototype.type.equals(type)) {\r\n            return attributePrototype.read(this, offset, length, charBuffer, codeAttributeOffset, labels);\r\n        }\r\n    }\r\n    return new Attribute(type).read(this, offset, length, null, -1, null);\r\n}",
    "comment": "\n   * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.\n   *\n   * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of\n   *     the class. Any attribute whose type is not equal to the type of one the prototypes will not\n   *     be parsed: its byte array value will be passed unchanged to the ClassWriter.\n   * @param type the type of the attribute.\n   * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.\n   *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n   * @param charBuffer the buffer to be used to read strings in the constant pool.\n   * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link\n   *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n   *     is not a code attribute.\n   * @return the attribute that has been read.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getItemCount()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods: low level parsing\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the number of entries in the class's constant pool table.\r\n *\r\n * @return the number of entries in the class's constant pool table.\r\n */\r\npublic int getItemCount() {\r\n    return cpInfoOffsets.length;\r\n}",
    "comment": "\n   * Returns the number of entries in the class's constant pool table.\n   *\n   * @return the number of entries in the class's constant pool table.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getItem(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\r\n * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\r\n * and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\r\n *     table.\r\n * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\r\n *     structure, plus one.\r\n */\r\npublic int getItem(final int constantPoolEntryIndex) {\r\n    return cpInfoOffsets[constantPoolEntryIndex];\r\n}",
    "comment": "\n   * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a\n   * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,\n   * and is normally not needed by class generators or adapters.</i>\n   *\n   * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool\n   *     table.\n   * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'\n   *     structure, plus one.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#getMaxStringLength()",
    "entityType": "method",
    "code": "/**\r\n * Returns a conservative estimate of the maximum length of the strings contained in the class's\r\n * constant pool table.\r\n *\r\n * @return a conservative estimate of the maximum length of the strings contained in the class's\r\n *     constant pool table.\r\n */\r\npublic int getMaxStringLength() {\r\n    return maxStringLength;\r\n}",
    "comment": "\n   * Returns a conservative estimate of the maximum length of the strings contained in the class's\n   * constant pool table.\n   *\n   * @return a conservative estimate of the maximum length of the strings contained in the class's\n   *     constant pool table.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readByte(int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic int readByte(final int offset) {\r\n    return classFileBuffer[offset] & 0xFF;\r\n}",
    "comment": "\n   * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readBytes(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Reads several bytes in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the bytes to be read in this {@link ClassReader}.\r\n * @param length the number of bytes to read.\r\n * @return the read bytes.\r\n */\r\npublic byte[] readBytes(final int offset, final int length) {\r\n    byte[] result = new byte[length];\r\n    System.arraycopy(classFileBuffer, offset, result, 0, length);\r\n    return result;\r\n}",
    "comment": "\n   * Reads several bytes in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the bytes to be read in this {@link ClassReader}.\n   * @param length the number of bytes to read.\n   * @return the read bytes.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
    "entityType": "method",
    "code": "/**\r\n * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\r\n * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start index of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic int readUnsignedShort(final int offset) {\r\n    byte[] classBuffer = classFileBuffer;\r\n    return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);\r\n}",
    "comment": "\n   * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for\n   * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start index of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readShort(int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic short readShort(final int offset) {\r\n    byte[] classBuffer = classFileBuffer;\r\n    return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));\r\n}",
    "comment": "\n   * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readInt(int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic int readInt(final int offset) {\r\n    byte[] classBuffer = classFileBuffer;\r\n    return ((classBuffer[offset] & 0xFF) << 24) | ((classBuffer[offset + 1] & 0xFF) << 16) | ((classBuffer[offset + 2] & 0xFF) << 8) | (classBuffer[offset + 3] & 0xFF);\r\n}",
    "comment": "\n   * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readLong(int)",
    "entityType": "method",
    "code": "/**\r\n * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\r\n * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\r\n *\r\n * @param offset the start offset of the value to be read in this {@link ClassReader}.\r\n * @return the read value.\r\n */\r\npublic long readLong(final int offset) {\r\n    long l1 = readInt(offset);\r\n    long l0 = readInt(offset + 4) & 0xFFFFFFFFL;\r\n    return (l1 << 32) | l0;\r\n}",
    "comment": "\n   * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link\n   * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>\n   *\n   * @param offset the start offset of the value to be read in this {@link ClassReader}.\n   * @return the read value.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\r\n */\r\n// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\r\npublic String readUTF8(final int offset, final char[] charBuffer) {\r\n    int constantPoolEntryIndex = readUnsignedShort(offset);\r\n    if (offset == 0 || constantPoolEntryIndex == 0) {\r\n        return null;\r\n    }\r\n    return readUtf(constantPoolEntryIndex, charBuffer);\r\n}",
    "comment": " DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility)."
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readUtf(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\r\n *     table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Utf8 entry.\r\n */\r\nfinal String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    String value = constantUtf8Values[constantPoolEntryIndex];\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    return constantUtf8Values[constantPoolEntryIndex] = readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);\r\n}",
    "comment": "\n   * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.\n   *\n   * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool\n   *     table.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Utf8 entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads an UTF8 string in {@link #classFileBuffer}.\r\n *\r\n * @param utfOffset the start offset of the UTF8 string to be read.\r\n * @param utfLength the length of the UTF8 string to be read.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified UTF8 string.\r\n */\r\nprivate String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\r\n    int currentOffset = utfOffset;\r\n    int endOffset = currentOffset + utfLength;\r\n    int strLength = 0;\r\n    byte[] classBuffer = classFileBuffer;\r\n    while (currentOffset < endOffset) {\r\n        int currentByte = classBuffer[currentOffset++];\r\n        if ((currentByte & 0x80) == 0) {\r\n            charBuffer[strLength++] = (char) (currentByte & 0x7F);\r\n        } else if ((currentByte & 0xE0) == 0xC0) {\r\n            charBuffer[strLength++] = (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\r\n        } else {\r\n            charBuffer[strLength++] = (char) (((currentByte & 0xF) << 12) + ((classBuffer[currentOffset++] & 0x3F) << 6) + (classBuffer[currentOffset++] & 0x3F));\r\n        }\r\n    }\r\n    return new String(charBuffer, 0, strLength);\r\n}",
    "comment": "\n   * Reads an UTF8 string in {@link #classFileBuffer}.\n   *\n   * @param utfOffset the start offset of the UTF8 string to be read.\n   * @param utfLength the length of the UTF8 string to be read.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified UTF8 string.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readStringish(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\r\n * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\r\n * for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\r\n *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\r\n *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified constant pool entry.\r\n */\r\nprivate String readStringish(final int offset, final char[] charBuffer) {\r\n    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\r\n    // designated by the first two bytes of this cp_info.\r\n    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\r\n}",
    "comment": "\n   * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or\n   * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended\n   * for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose\n   *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n   *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified constant pool entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readClass(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Class entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Class entry.\r\n */\r\npublic String readClass(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}",
    "comment": "\n   * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Class entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Class entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readModule(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Module entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Module entry.\r\n */\r\npublic String readModule(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}",
    "comment": "\n   * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Module entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Module entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readPackage(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\r\n *     value is the index of a CONSTANT_Package entry in class's constant pool table.\r\n * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the String corresponding to the specified CONSTANT_Package entry.\r\n */\r\npublic String readPackage(final int offset, final char[] charBuffer) {\r\n    return readStringish(offset, charBuffer);\r\n}",
    "comment": "\n   * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose\n   *     value is the index of a CONSTANT_Package entry in class's constant pool table.\n   * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the String corresponding to the specified CONSTANT_Package entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\r\n *     pool table.\r\n * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\r\n */\r\nprivate ConstantDynamic readConstantDynamic(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];\r\n    if (constantDynamic != null) {\r\n        return constantDynamic;\r\n    }\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];\r\n    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];\r\n    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];\r\n    bootstrapMethodOffset += 4;\r\n    for (int i = 0; i < bootstrapMethodArguments.length; i++) {\r\n        bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);\r\n        bootstrapMethodOffset += 2;\r\n    }\r\n    return constantDynamicValues[constantPoolEntryIndex] = new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);\r\n}",
    "comment": "\n   * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.\n   *\n   * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant\n   *     pool table.\n   * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.\n   "
  },
  {
    "entityId": "org.springframework.asm.ClassReader#readConst(int,char[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\r\n * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\r\n * adapters.</i>\r\n *\r\n * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\r\n *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\r\n *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\r\n * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\r\n *     large. It is not automatically resized.\r\n * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\r\n *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\r\n *     constant pool entry.\r\n */\r\npublic Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {\r\n    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];\r\n    switch(classFileBuffer[cpInfoOffset - 1]) {\r\n        case Symbol.CONSTANT_INTEGER_TAG:\r\n            return readInt(cpInfoOffset);\r\n        case Symbol.CONSTANT_FLOAT_TAG:\r\n            return Float.intBitsToFloat(readInt(cpInfoOffset));\r\n        case Symbol.CONSTANT_LONG_TAG:\r\n            return readLong(cpInfoOffset);\r\n        case Symbol.CONSTANT_DOUBLE_TAG:\r\n            return Double.longBitsToDouble(readLong(cpInfoOffset));\r\n        case Symbol.CONSTANT_CLASS_TAG:\r\n            return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));\r\n        case Symbol.CONSTANT_STRING_TAG:\r\n            return readUTF8(cpInfoOffset, charBuffer);\r\n        case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n            return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));\r\n        case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n            int referenceKind = readByte(cpInfoOffset);\r\n            int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];\r\n            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];\r\n            String owner = readClass(referenceCpInfoOffset, charBuffer);\r\n            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);\r\n            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);\r\n            boolean isInterface = classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;\r\n            return new Handle(referenceKind, owner, name, descriptor, isInterface);\r\n        case Symbol.CONSTANT_DYNAMIC_TAG:\r\n            return readConstantDynamic(constantPoolEntryIndex, charBuffer);\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "comment": "\n   * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is\n   * intended for {@link Attribute} sub classes, and is normally not needed by class generators or\n   * adapters.</i>\n   *\n   * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,\n   *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,\n   *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.\n   * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently\n   *     large. It is not automatically resized.\n   * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},\n   *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified\n   *     constant pool entry.\n   "
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests",
    "entityType": "class",
    "code": "@ParameterizedTest\r\n@ValueSource(strings = { \"text\", \"  text  \", \"  \", \"\\t\", \"\\n text\" })\r\nvoid hasLengthForValidValues(String value) {\r\n    assertThat(StringUtils.hasLength(value)).isTrue();\r\n}\n@ParameterizedTest\r\n@NullAndEmptySource\r\nvoid hasLengthForInvalidValues(String value) {\r\n    assertThat(StringUtils.hasLength(value)).isFalse();\r\n}\n@ParameterizedTest\r\n@ValueSource(strings = { \"text\", \"  text  \", \"\\n text\" })\r\nvoid hasTextForValidValues(String value) {\r\n    assertThat(StringUtils.hasText(value)).isTrue();\r\n}\n@ParameterizedTest\r\n@NullAndEmptySource\r\n@ValueSource(strings = { \"  \", \"\\t\" })\r\nvoid hasTextForInvalidValues(String value) {\r\n    assertThat(StringUtils.hasText(value)).isFalse();\r\n}\n@Test\r\nvoid containsWhitespace() {\r\n    assertThat(StringUtils.containsWhitespace(null)).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\"\")).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\"a\")).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\"abc\")).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\" \")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"\\t\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"\\n\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\" a\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"abc \")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"a b\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"a  b\")).isTrue();\r\n}\n@Test\r\n@Deprecated\r\nvoid trimWhitespace() {\r\n    assertThat(StringUtils.trimWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\" a\")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimWhitespace(\"a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimWhitespace(\" a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimWhitespace(\" a b \")).isEqualTo(\"a b\");\r\n    assertThat(StringUtils.trimWhitespace(\" a b  c \")).isEqualTo(\"a b  c\");\r\n}\n@Test\r\nvoid trimAllWhitespace() {\r\n    assertThat(StringUtils.trimAllWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimAllWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\" a\")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimAllWhitespace(\"a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimAllWhitespace(\" a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimAllWhitespace(\" a b \")).isEqualTo(\"ab\");\r\n    assertThat(StringUtils.trimAllWhitespace(\" a b  c \")).isEqualTo(\"abc\");\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid trimLeadingWhitespace() {\r\n    assertThat(StringUtils.trimLeadingWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a\")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"a \")).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a \")).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a b \")).isEqualTo(\"a b \");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a b  c \")).isEqualTo(\"a b  c \");\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid trimTrailingWhitespace() {\r\n    assertThat(StringUtils.trimTrailingWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a\")).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a \")).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a b \")).isEqualTo(\" a b\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a b  c \")).isEqualTo(\" a b  c\");\r\n}\n@Test\r\nvoid trimLeadingCharacter() {\r\n    assertThat(StringUtils.trimLeadingCharacter(null, ' ')).isNull();\r\n    assertThat(StringUtils.trimLeadingCharacter(\"\", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimLeadingCharacter(\" \", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimLeadingCharacter(\"\\t\", ' ')).isEqualTo(\"\\t\");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a\", ' ')).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimLeadingCharacter(\"a \", ' ')).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a \", ' ')).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a b \", ' ')).isEqualTo(\"a b \");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a b  c \", ' ')).isEqualTo(\"a b  c \");\r\n}\n@Test\r\nvoid trimTrailingCharacter() {\r\n    assertThat(StringUtils.trimTrailingCharacter(null, ' ')).isNull();\r\n    assertThat(StringUtils.trimTrailingCharacter(\"\", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimTrailingCharacter(\" \", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimTrailingCharacter(\"\\t\", ' ')).isEqualTo(\"\\t\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\"a \", ' ')).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a\", ' ')).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a \", ' ')).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a b \", ' ')).isEqualTo(\" a b\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a b  c \", ' ')).isEqualTo(\" a b  c\");\r\n}\n@Test\r\nvoid matchesCharacter() {\r\n    assertThat(StringUtils.matchesCharacter(null, '/')).isFalse();\r\n    assertThat(StringUtils.matchesCharacter(\"/a\", '/')).isFalse();\r\n    assertThat(StringUtils.matchesCharacter(\"a\", '/')).isFalse();\r\n    assertThat(StringUtils.matchesCharacter(\"/\", '/')).isTrue();\r\n}\n@Test\r\nvoid startsWithIgnoreCase() {\r\n    String prefix = \"fOo\";\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foo\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"Foo\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foobar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foobarbar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"Foobar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"FoobarBar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"foObar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"FOObar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"fOobar\", prefix)).isTrue();\r\n    assertThat(StringUtils.startsWithIgnoreCase(null, prefix)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"fOobar\", null)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"b\", prefix)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"barfoo\", prefix)).isFalse();\r\n    assertThat(StringUtils.startsWithIgnoreCase(\"barfoobar\", prefix)).isFalse();\r\n}\n@Test\r\nvoid endsWithIgnoreCase() {\r\n    String suffix = \"fOo\";\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"foo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"Foo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barbarfoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barFoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barBarFoo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfoO\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barFOO\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfOo\", suffix)).isTrue();\r\n    assertThat(StringUtils.endsWithIgnoreCase(null, suffix)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfOo\", null)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"b\", suffix)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"foobar\", suffix)).isFalse();\r\n    assertThat(StringUtils.endsWithIgnoreCase(\"barfoobar\", suffix)).isFalse();\r\n}\n@Test\r\nvoid substringMatch() {\r\n    assertThat(StringUtils.substringMatch(\"foo\", 0, \"foo\")).isTrue();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 1, \"oo\")).isTrue();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"o\")).isTrue();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 0, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 1, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 3, \"fOo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 1, \"Oo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"Oo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 3, \"Oo\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 2, \"O\")).isFalse();\r\n    assertThat(StringUtils.substringMatch(\"foo\", 3, \"O\")).isFalse();\r\n}\n@Test\r\nvoid countOccurrencesOf() {\r\n    assertThat(StringUtils.countOccurrencesOf(null, null)).as(\"nullx2 = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(\"s\", null)).as(\"null string = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(null, \"s\")).as(\"null substring = 0\").isEqualTo(0);\r\n    String s = \"erowoiueoiur\";\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"WERWER\")).as(\"not found = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"x\")).as(\"not found char = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \" \")).as(\"not found ws = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"\")).as(\"not found empty string = 0\").isEqualTo(0);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"e\")).as(\"found char=2\").isEqualTo(2);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"oi\")).as(\"found substring=2\").isEqualTo(2);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"oiu\")).as(\"found substring=2\").isEqualTo(2);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"oiur\")).as(\"found substring=3\").isEqualTo(1);\r\n    assertThat(StringUtils.countOccurrencesOf(s, \"r\")).as(\"test last\").isEqualTo(2);\r\n}\n@Test\r\nvoid replace() {\r\n    String inString = \"a6AazAaa77abaa\";\r\n    String oldPattern = \"aa\";\r\n    String newPattern = \"foo\";\r\n    // Simple replace\r\n    String s = StringUtils.replace(inString, oldPattern, newPattern);\r\n    assertThat(s).as(\"Replace 1 worked\").isEqualTo(\"a6AazAfoo77abfoo\");\r\n    // Non match: no change\r\n    s = StringUtils.replace(inString, \"qwoeiruqopwieurpoqwieur\", newPattern);\r\n    assertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\r\n    // Null new pattern: should ignore\r\n    s = StringUtils.replace(inString, oldPattern, null);\r\n    assertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\r\n    // Null old pattern: should ignore\r\n    s = StringUtils.replace(inString, null, newPattern);\r\n    assertThat(s).as(\"Replace non-matched is returned as-is\").isSameAs(inString);\r\n}\n@Test\r\nvoid delete() {\r\n    String inString = \"The quick brown fox jumped over the lazy dog\";\r\n    String noThe = StringUtils.delete(inString, \"the\");\r\n    assertThat(noThe).as(\"Result has no the [\" + noThe + \"]\").isEqualTo(\"The quick brown fox jumped over  lazy dog\");\r\n    String nohe = StringUtils.delete(inString, \"he\");\r\n    assertThat(nohe).as(\"Result has no he [\" + nohe + \"]\").isEqualTo(\"T quick brown fox jumped over t lazy dog\");\r\n    String nosp = StringUtils.delete(inString, \" \");\r\n    assertThat(nosp).as(\"Result has no spaces\").isEqualTo(\"Thequickbrownfoxjumpedoverthelazydog\");\r\n    String killEnd = StringUtils.delete(inString, \"dog\");\r\n    assertThat(killEnd).as(\"Result has no dog\").isEqualTo(\"The quick brown fox jumped over the lazy \");\r\n    String mismatch = StringUtils.delete(inString, \"dxxcxcxog\");\r\n    assertThat(mismatch).as(\"Result is unchanged\").isEqualTo(inString);\r\n    String nochange = StringUtils.delete(inString, \"\");\r\n    assertThat(nochange).as(\"Result is unchanged\").isEqualTo(inString);\r\n}\n@Test\r\nvoid deleteAny() {\r\n    String inString = \"Able was I ere I saw Elba\";\r\n    String res = StringUtils.deleteAny(inString, \"I\");\r\n    assertThat(res).as(\"Result has no 'I'\").isEqualTo(\"Able was  ere  saw Elba\");\r\n    res = StringUtils.deleteAny(inString, \"AeEba!\");\r\n    assertThat(res).as(\"Result has no 'AeEba!'\").isEqualTo(\"l ws I r I sw l\");\r\n    res = StringUtils.deleteAny(inString, \"#@$#$^\");\r\n    assertThat(res).as(\"Result is unchanged\").isEqualTo(inString);\r\n}\n@Test\r\nvoid deleteAnyWhitespace() {\r\n    String whitespace = \"This is\\n\\n\\n    \\t   a messagy string with whitespace\\n\";\r\n    assertThat(whitespace).as(\"Has CR\").contains(\"\\n\");\r\n    assertThat(whitespace).as(\"Has tab\").contains(\"\\t\");\r\n    assertThat(whitespace).as(\"Has space\").contains(\" \");\r\n    String cleaned = StringUtils.deleteAny(whitespace, \"\\n\\t \");\r\n    assertThat(cleaned).as(\"Has no CR\").doesNotContain(\"\\n\");\r\n    assertThat(cleaned).as(\"Has no tab\").doesNotContain(\"\\t\");\r\n    assertThat(cleaned).as(\"Has no space\").doesNotContain(\" \");\r\n    assertThat(cleaned.length()).as(\"Still has chars\").isGreaterThan(10);\r\n}\n@Test\r\nvoid quote() {\r\n    assertThat(StringUtils.quote(\"myString\")).isEqualTo(\"'myString'\");\r\n    assertThat(StringUtils.quote(\"\")).isEqualTo(\"''\");\r\n    assertThat(StringUtils.quote(null)).isNull();\r\n}\n@Test\r\nvoid quoteIfString() {\r\n    assertThat(StringUtils.quoteIfString(\"myString\")).isEqualTo(\"'myString'\");\r\n    assertThat(StringUtils.quoteIfString(\"\")).isEqualTo(\"''\");\r\n    assertThat(StringUtils.quoteIfString(5)).isEqualTo(5);\r\n    assertThat(StringUtils.quoteIfString(null)).isNull();\r\n}\n@Test\r\nvoid unqualify() {\r\n    String qualified = \"i.am.not.unqualified\";\r\n    assertThat(StringUtils.unqualify(qualified)).isEqualTo(\"unqualified\");\r\n}\n@Test\r\nvoid capitalize() {\r\n    String capitalized = \"i am not capitalized\";\r\n    assertThat(StringUtils.capitalize(capitalized)).isEqualTo(\"I am not capitalized\");\r\n}\n@Test\r\nvoid uncapitalize() {\r\n    String capitalized = \"I am capitalized\";\r\n    assertThat(StringUtils.uncapitalize(capitalized)).isEqualTo(\"i am capitalized\");\r\n}\n@Test\r\nvoid getFilename() {\r\n    assertThat(StringUtils.getFilename(null)).isNull();\r\n    assertThat(StringUtils.getFilename(\"\")).isEmpty();\r\n    assertThat(StringUtils.getFilename(\"myfile\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.getFilename(\"mypath/myfile\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.getFilename(\"myfile.\")).isEqualTo(\"myfile.\");\r\n    assertThat(StringUtils.getFilename(\"mypath/myfile.\")).isEqualTo(\"myfile.\");\r\n    assertThat(StringUtils.getFilename(\"myfile.txt\")).isEqualTo(\"myfile.txt\");\r\n    assertThat(StringUtils.getFilename(\"mypath/myfile.txt\")).isEqualTo(\"myfile.txt\");\r\n}\n@Test\r\nvoid getFilenameExtension() {\r\n    assertThat(StringUtils.getFilenameExtension(null)).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"myfile\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"myPath/myfile\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"/home/user/.m2/settings/myfile\")).isNull();\r\n    assertThat(StringUtils.getFilenameExtension(\"myfile.\")).isEmpty();\r\n    assertThat(StringUtils.getFilenameExtension(\"myPath/myfile.\")).isEmpty();\r\n    assertThat(StringUtils.getFilenameExtension(\"myfile.txt\")).isEqualTo(\"txt\");\r\n    assertThat(StringUtils.getFilenameExtension(\"mypath/myfile.txt\")).isEqualTo(\"txt\");\r\n    assertThat(StringUtils.getFilenameExtension(\"/home/user/.m2/settings/myfile.txt\")).isEqualTo(\"txt\");\r\n}\n@Test\r\nvoid stripFilenameExtension() {\r\n    assertThat(StringUtils.stripFilenameExtension(\"\")).isEmpty();\r\n    assertThat(StringUtils.stripFilenameExtension(\"myfile\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"myfile.\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"myfile.txt\")).isEqualTo(\"myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"mypath/myfile.\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"mypath/myfile.txt\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile.\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\r\n    assertThat(StringUtils.stripFilenameExtension(\"/home/user/.m2/settings/myfile.txt\")).isEqualTo(\"/home/user/.m2/settings/myfile\");\r\n}\n@Test\r\nvoid cleanPath() {\r\n    assertThat(StringUtils.cleanPath(\"mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath\\\\myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/../mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/myfile/../../mypath/myfile\")).isEqualTo(\"mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"../mypath/../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/../../mypath/myfile\")).isEqualTo(\"../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"/../mypath/myfile\")).isEqualTo(\"/../mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"/a/:b/../../mypath/myfile\")).isEqualTo(\"/mypath/myfile\");\r\n    assertThat(StringUtils.cleanPath(\"/\")).isEqualTo(\"/\");\r\n    assertThat(StringUtils.cleanPath(\"/mypath/../\")).isEqualTo(\"/\");\r\n    assertThat(StringUtils.cleanPath(\"mypath/..\")).isEmpty();\r\n    assertThat(StringUtils.cleanPath(\"mypath/../.\")).isEmpty();\r\n    assertThat(StringUtils.cleanPath(\"mypath/../\")).isEqualTo(\"./\");\r\n    assertThat(StringUtils.cleanPath(\"././\")).isEqualTo(\"./\");\r\n    assertThat(StringUtils.cleanPath(\"./\")).isEqualTo(\"./\");\r\n    assertThat(StringUtils.cleanPath(\"../\")).isEqualTo(\"../\");\r\n    assertThat(StringUtils.cleanPath(\"./../\")).isEqualTo(\"../\");\r\n    assertThat(StringUtils.cleanPath(\".././\")).isEqualTo(\"../\");\r\n    assertThat(StringUtils.cleanPath(\"file:/\")).isEqualTo(\"file:/\");\r\n    assertThat(StringUtils.cleanPath(\"file:/mypath/../\")).isEqualTo(\"file:/\");\r\n    assertThat(StringUtils.cleanPath(\"file:mypath/..\")).isEqualTo(\"file:\");\r\n    assertThat(StringUtils.cleanPath(\"file:mypath/../.\")).isEqualTo(\"file:\");\r\n    assertThat(StringUtils.cleanPath(\"file:mypath/../\")).isEqualTo(\"file:./\");\r\n    assertThat(StringUtils.cleanPath(\"file:././\")).isEqualTo(\"file:./\");\r\n    assertThat(StringUtils.cleanPath(\"file:./\")).isEqualTo(\"file:./\");\r\n    assertThat(StringUtils.cleanPath(\"file:../\")).isEqualTo(\"file:../\");\r\n    assertThat(StringUtils.cleanPath(\"file:./../\")).isEqualTo(\"file:../\");\r\n    assertThat(StringUtils.cleanPath(\"file:.././\")).isEqualTo(\"file:../\");\r\n    assertThat(StringUtils.cleanPath(\"file:/mypath/spring.factories\")).isEqualTo(\"file:/mypath/spring.factories\");\r\n    assertThat(StringUtils.cleanPath(\"file:///c:/some/../path/the%20file.txt\")).isEqualTo(\"file:///c:/path/the%20file.txt\");\r\n    assertThat(StringUtils.cleanPath(\"jar:file:///c:\\\\some\\\\..\\\\path\\\\.\\\\the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\r\n    assertThat(StringUtils.cleanPath(\"jar:file:///c:/some/../path/./the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\r\n    assertThat(StringUtils.cleanPath(\"jar:file:///c:\\\\\\\\some\\\\\\\\..\\\\\\\\path\\\\\\\\.\\\\\\\\the%20file.txt\")).isEqualTo(\"jar:file:///c:/path/the%20file.txt\");\r\n}\n@Test\r\nvoid pathEquals() {\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for the same strings\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\dummy2\\\\dummy3\")).as(\"Must be true for the same win strings\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for one top path on 1\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\..\\\\dummy2\\\\dummy3\")).as(\"Must be true for one win top path on 2\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/bin/../dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for two top paths on 1\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\..\\\\dummy2\\\\bin\\\\..\\\\dummy3\")).as(\"Must be true for two win top paths on 2\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/tmp/../../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be true for double top paths on 1\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dum/dum/../../dummy2/dummy3\")).as(\"Must be true for double top paths on 2 with similarity\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"./dummy1/dummy2/dummy3\", \"dummy1/dum/./dum/../../dummy2/dummy3\")).as(\"Must be true for current paths\").isTrue();\r\n    assertThat(StringUtils.pathEquals(\"./dummy1/dummy2/dummy3\", \"/dummy1/dum/./dum/../../dummy2/dummy3\")).as(\"Must be false for relative/absolute paths\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/dummy2/dummy3\", \"/dummy1/dummy4/dummy3\")).as(\"Must be false for different strings\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/tmp/../dummy2/dummy3\", \"/dummy1/dummy2/dummy3\")).as(\"Must be false for one false path on 1\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"C:\\\\dummy1\\\\dummy2\\\\dummy3\", \"C:\\\\dummy1\\\\bin\\\\tmp\\\\..\\\\dummy2\\\\dummy3\")).as(\"Must be false for one false win top path on 2\").isFalse();\r\n    assertThat(StringUtils.pathEquals(\"/dummy1/bin/../dummy2/dummy3\", \"/dummy1/dummy2/dummy4\")).as(\"Must be false for top path on 1 + difference\").isFalse();\r\n}\n@Test\r\nvoid concatenateStringArrays() {\r\n    String[] input1 = new String[] { \"myString2\" };\r\n    String[] input2 = new String[] { \"myString1\", \"myString2\" };\r\n    String[] result = StringUtils.concatenateStringArrays(input1, input2);\r\n    assertThat(result).hasSize(3);\r\n    assertThat(result[0]).isEqualTo(\"myString2\");\r\n    assertThat(result[1]).isEqualTo(\"myString1\");\r\n    assertThat(result[2]).isEqualTo(\"myString2\");\r\n    assertThat(StringUtils.concatenateStringArrays(input1, null)).isEqualTo(input1);\r\n    assertThat(StringUtils.concatenateStringArrays(null, input2)).isEqualTo(input2);\r\n    assertThat(StringUtils.concatenateStringArrays(null, null)).isNull();\r\n}\n@Test\r\nvoid sortStringArray() {\r\n    String[] input = new String[] { \"myString2\" };\r\n    input = StringUtils.addStringToArray(input, \"myString1\");\r\n    assertThat(input[0]).isEqualTo(\"myString2\");\r\n    assertThat(input[1]).isEqualTo(\"myString1\");\r\n    StringUtils.sortStringArray(input);\r\n    assertThat(input[0]).isEqualTo(\"myString1\");\r\n    assertThat(input[1]).isEqualTo(\"myString2\");\r\n}\n@Test\r\nvoid trimArrayElements() {\r\n    assertThat(StringUtils.trimArrayElements(null)).isNull();\r\n    assertThat(StringUtils.trimArrayElements(new String[] ;)).isEmpty();\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"\", \" \", \"  \", \"   \" })).containsExactly(\"\", \"\", \"\", \"\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"\\n\", \"\\t \", \"\\n\\t\" })).containsExactly(\"\", \"\", \"\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"a\", \"b\", \"c\" })).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"  a  \", \"  b b \", \"  cc  \" })).containsExactly(\"a\", \"b b\", \"cc\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { \"  a  \", \"b\", \"  c  \" })).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(StringUtils.trimArrayElements(new String[] { null, \"  a  \", null })).containsExactly(null, \"a\", null);\r\n}\n@Test\r\nvoid removeDuplicateStrings() {\r\n    String[] input = new String[] { \"myString2\", \"myString1\", \"myString2\" };\r\n    input = StringUtils.removeDuplicateStrings(input);\r\n    assertThat(input[0]).isEqualTo(\"myString2\");\r\n    assertThat(input[1]).isEqualTo(\"myString1\");\r\n}\n@Test\r\nvoid splitArrayElementsIntoProperties() {\r\n    String[] input = new String[] { \"key1=value1 \", \"key2 =\\\"value2\\\"\" };\r\n    Properties result = StringUtils.splitArrayElementsIntoProperties(input, \"=\");\r\n    assertThat(result.getProperty(\"key1\")).isEqualTo(\"value1\");\r\n    assertThat(result.getProperty(\"key2\")).isEqualTo(\"\\\"value2\\\"\");\r\n}\n@Test\r\nvoid splitArrayElementsIntoPropertiesAndDeletedChars() {\r\n    String[] input = new String[] { \"key1=value1 \", \"key2 =\\\"value2\\\"\" };\r\n    Properties result = StringUtils.splitArrayElementsIntoProperties(input, \"=\", \"\\\"\");\r\n    assertThat(result.getProperty(\"key1\")).isEqualTo(\"value1\");\r\n    assertThat(result.getProperty(\"key2\")).isEqualTo(\"value2\");\r\n}\n@Test\r\nvoid tokenizeToStringArray() {\r\n    String[] sa = StringUtils.tokenizeToStringArray(\"a,b , ,c\", \",\");\r\n    assertThat(sa).hasSize(3);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].equals(\"b\") && sa[2].equals(\"c\")).as(\"components are correct\").isTrue();\r\n}\n@Test\r\nvoid tokenizeToStringArrayWithNotIgnoreEmptyTokens() {\r\n    String[] sa = StringUtils.tokenizeToStringArray(\"a,b , ,c\", \",\", true, false);\r\n    assertThat(sa).hasSize(4);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].equals(\"b\") && sa[2].isEmpty() && sa[3].equals(\"c\")).as(\"components are correct\").isTrue();\r\n}\n@Test\r\nvoid tokenizeToStringArrayWithNotTrimTokens() {\r\n    String[] sa = StringUtils.tokenizeToStringArray(\"a,b ,c\", \",\", false, true);\r\n    assertThat(sa).hasSize(3);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].equals(\"b \") && sa[2].equals(\"c\")).as(\"components are correct\").isTrue();\r\n}\n@Test\r\nvoid commaDelimitedListToStringArrayWithNullProducesEmptyArray() {\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(null);\r\n    assertThat(sa).as(\"String array isn't null with null input\").isNotNull();\r\n    assertThat(sa.length).as(\"String array length == 0 with null input\").isEqualTo(0);\r\n}\n@Test\r\nvoid commaDelimitedListToStringArrayWithEmptyStringProducesEmptyArray() {\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(\"\");\r\n    assertThat(sa).as(\"String array isn't null with null input\").isNotNull();\r\n    assertThat(sa.length).as(\"String array length == 0 with null input\").isEqualTo(0);\r\n}\n@Test\r\nvoid delimitedListToStringArrayWithComma() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b\", \",\");\r\n    assertThat(sa).hasSize(2);\r\n    assertThat(sa[0]).isEqualTo(\"a\");\r\n    assertThat(sa[1]).isEqualTo(\"b\");\r\n}\n@Test\r\nvoid delimitedListToStringArrayWithSemicolon() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a;b\", \";\");\r\n    assertThat(sa).hasSize(2);\r\n    assertThat(sa[0]).isEqualTo(\"a\");\r\n    assertThat(sa[1]).isEqualTo(\"b\");\r\n}\n@Test\r\nvoid delimitedListToStringArrayWithEmptyDelimiter() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b\", \"\");\r\n    assertThat(sa).hasSize(3);\r\n    assertThat(sa[0]).isEqualTo(\"a\");\r\n    assertThat(sa[1]).isEqualTo(\",\");\r\n    assertThat(sa[2]).isEqualTo(\"b\");\r\n}\n@Test\r\nvoid delimitedListToStringArrayWithNullDelimiter() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b\", null);\r\n    assertThat(sa).hasSize(1);\r\n    assertThat(sa[0]).isEqualTo(\"a,b\");\r\n}\n@Test\r\nvoid delimitedListToStringArrayWithCharacterToDelete() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b,c\", \",\", \"a\");\r\n    assertThat(sa).containsExactly(\"\", \"b\", \"c\");\r\n}\n@Test\r\nvoid delimitedListToStringArrayWithCharacterToDeleteEqualsToDelimiter() {\r\n    String[] sa = StringUtils.delimitedListToStringArray(\"a,b,c\", \",\", \",\");\r\n    assertThat(sa).containsExactly(\"a\", \"b\", \"c\");\r\n}\n@Test\r\nvoid commaDelimitedListToStringArrayMatchWords() {\r\n    // Could read these from files\r\n    String[] sa = new String[] { \"foo\", \"bar\", \"big\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n    doTestStringArrayReverseTransformationMatches(sa);\r\n    sa = new String[] { \"a\", \"b\", \"c\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n    doTestStringArrayReverseTransformationMatches(sa);\r\n    // Test same words\r\n    sa = new String[] { \"AA\", \"AA\", \"AA\", \"AA\", \"AA\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n    doTestStringArrayReverseTransformationMatches(sa);\r\n}\nprivate void doTestStringArrayReverseTransformationMatches(String[] sa) {\r\n    String[] reverse = StringUtils.commaDelimitedListToStringArray(StringUtils.arrayToCommaDelimitedString(sa));\r\n    assertThat(Arrays.asList(reverse)).as(\"Reverse transformation is equal\").isEqualTo(Arrays.asList(sa));\r\n}\n@Test\r\nvoid commaDelimitedListToStringArraySingleString() {\r\n    // Could read these from files\r\n    String s = \"woeirqupoiewuropqiewuorpqiwueopriquwopeiurqopwieur\";\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(s);\r\n    assertThat(sa.length).as(\"Found one String with no delimiters\").isEqualTo(1);\r\n    assertThat(sa[0]).as(\"Single array entry matches input String with no delimiters\").isEqualTo(s);\r\n}\n@Test\r\nvoid commaDelimitedListToStringArrayWithOtherPunctuation() {\r\n    // Could read these from files\r\n    String[] sa = new String[] { \"xcvwert4456346&*.\", \"///\", \".!\", \".\", \";\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n}\n/**\r\n * We expect to see the empty Strings in the output.\r\n */\r\n@Test\r\nvoid commaDelimitedListToStringArrayEmptyStrings() {\r\n    // Could read these from files\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(\"a,,b\");\r\n    assertThat(sa.length).as(\"a,,b produces array length 3\").isEqualTo(3);\r\n    assertThat(sa[0].equals(\"a\") && sa[1].isEmpty() && sa[2].equals(\"b\")).as(\"components are correct\").isTrue();\r\n    sa = new String[] { \"\", \"\", \"a\", \"\" };\r\n    doTestCommaDelimitedListToStringArrayLegalMatch(sa);\r\n}\nprivate void doTestCommaDelimitedListToStringArrayLegalMatch(String[] components) {\r\n    String sb = String.join(String.valueOf(','), components);\r\n    String[] sa = StringUtils.commaDelimitedListToStringArray(sb);\r\n    assertThat(sa).as(\"String array isn't null with legal match\").isNotNull();\r\n    assertThat(sa.length).as(\"String array length is correct with legal match\").isEqualTo(components.length);\r\n    assertThat(Arrays.equals(sa, components)).as(\"Output equals input\").isTrue();\r\n}\n@Test\r\nvoid parseLocaleStringSunnyDay() {\r\n    Locale expectedLocale = Locale.UK;\r\n    Locale locale = StringUtils.parseLocaleString(expectedLocale.toString());\r\n    assertThat(locale).as(\"When given a bona-fide Locale string, must not return null.\").isNotNull();\r\n    assertThat(locale).isEqualTo(expectedLocale);\r\n}\n@Test\r\nvoid parseLocaleStringWithEmptyLocaleStringYieldsNullLocale() {\r\n    Locale locale = StringUtils.parseLocaleString(\"\");\r\n    assertThat(locale).as(\"When given an empty Locale string, must return null.\").isNull();\r\n}\n// SPR-8637\r\n@Test\r\nvoid parseLocaleWithMultiSpecialCharactersInVariant() {\r\n    String variant = \"proper-northern\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}\n// SPR-3671\r\n@Test\r\nvoid parseLocaleWithMultiValuedVariant() {\r\n    String variant = \"proper_northern\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}\n// SPR-3671\r\n@Test\r\nvoid parseLocaleWithMultiValuedVariantUsingSpacesAsSeparators() {\r\n    String variant = \"proper northern\";\r\n    String localeString = \"en GB \" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}\n// SPR-3671\r\n@Test\r\nvoid parseLocaleWithMultiValuedVariantUsingMixtureOfUnderscoresAndSpacesAsSeparators() {\r\n    String variant = \"proper northern\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Multi-valued variant portion of the Locale not extracted correctly.\").isEqualTo(variant);\r\n}\n// SPR-7779\r\n@Test\r\nvoid parseLocaleWithInvalidCharacters() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> StringUtils.parseLocaleString(\"%0D%0AContent-length:30%0D%0A%0D%0A%3Cscript%3Ealert%28123%29%3C/script%3E\"));\r\n}\n// SPR-9420\r\n@Test\r\nvoid parseLocaleWithSameLowercaseTokenForLanguageAndCountry() {\r\n    assertThat(StringUtils.parseLocaleString(\"tr_tr\").toString()).isEqualTo(\"tr_TR\");\r\n    assertThat(StringUtils.parseLocaleString(\"bg_bg_vnt\").toString()).isEqualTo(\"bg_BG_vnt\");\r\n}\n// SPR-11806\r\n@Test\r\nvoid parseLocaleWithVariantContainingCountryCode() {\r\n    String variant = \"GBtest\";\r\n    String localeString = \"en_GB_\" + variant;\r\n    Locale locale = StringUtils.parseLocaleString(localeString);\r\n    assertThat(locale.getVariant()).as(\"Variant containing country code not extracted correctly\").isEqualTo(variant);\r\n}\n// SPR-14718, SPR-7598\r\n@Test\r\nvoid parseJava7Variant() {\r\n    assertThat(StringUtils.parseLocaleString(\"sr__#LATN\").toString()).isEqualTo(\"sr__#LATN\");\r\n}\n// SPR-16651\r\n@Test\r\nvoid availableLocalesWithLocaleString() {\r\n    for (Locale locale : Locale.getAvailableLocales()) {\r\n        Locale parsedLocale = StringUtils.parseLocaleString(locale.toString());\r\n        if (parsedLocale == null) {\r\n            assertThat(locale.getLanguage()).isEmpty();\r\n        } else {\r\n            assertThat(locale.toString()).isEqualTo(parsedLocale.toString());\r\n        }\r\n    }\r\n}\n// SPR-16651\r\n@Test\r\nvoid availableLocalesWithLanguageTag() {\r\n    for (Locale locale : Locale.getAvailableLocales()) {\r\n        Locale parsedLocale = StringUtils.parseLocale(locale.toLanguageTag());\r\n        if (parsedLocale == null) {\r\n            assertThat(locale.getLanguage()).isEmpty();\r\n        } else {\r\n            assertThat(locale.toLanguageTag()).isEqualTo(parsedLocale.toLanguageTag());\r\n        }\r\n    }\r\n}\n@Test\r\nvoid invalidLocaleWithLocaleString() {\r\n    assertThat(StringUtils.parseLocaleString(\"invalid\")).isEqualTo(new Locale(\"invalid\"));\r\n    assertThat(StringUtils.parseLocaleString(\"invalidvalue\")).isEqualTo(new Locale(\"invalidvalue\"));\r\n    assertThat(StringUtils.parseLocaleString(\"invalidvalue_foo\")).isEqualTo(new Locale(\"invalidvalue\", \"foo\"));\r\n    assertThat(StringUtils.parseLocaleString(\"\")).isNull();\r\n}\n@Test\r\nvoid invalidLocaleWithLanguageTag() {\r\n    assertThat(StringUtils.parseLocale(\"invalid\")).isEqualTo(new Locale(\"invalid\"));\r\n    assertThat(StringUtils.parseLocale(\"invalidvalue\")).isEqualTo(new Locale(\"invalidvalue\"));\r\n    assertThat(StringUtils.parseLocale(\"invalidvalue_foo\")).isEqualTo(new Locale(\"invalidvalue\", \"foo\"));\r\n    assertThat(StringUtils.parseLocale(\"\")).isNull();\r\n}\n@Test\r\nvoid parseLocaleStringWithEmptyCountryAndVariant() {\r\n    assertThat(StringUtils.parseLocale(\"be__TARASK\").toString()).isEqualTo(\"be__TARASK\");\r\n}\n@Test\r\nvoid split() {\r\n    assertThat(StringUtils.split(\"Hello, world\", \",\")).containsExactly(\"Hello\", \" world\");\r\n    assertThat(StringUtils.split(\",Hello world\", \",\")).containsExactly(\"\", \"Hello world\");\r\n    assertThat(StringUtils.split(\"Hello world,\", \",\")).containsExactly(\"Hello world\", \"\");\r\n    assertThat(StringUtils.split(\"Hello, world,\", \",\")).containsExactly(\"Hello\", \" world,\");\r\n}\n@Test\r\nvoid splitWithEmptyStringOrNull() {\r\n    assertThat(StringUtils.split(\"Hello, world\", \"\")).isNull();\r\n    assertThat(StringUtils.split(\"\", \",\")).isNull();\r\n    assertThat(StringUtils.split(null, \",\")).isNull();\r\n    assertThat(StringUtils.split(\"Hello, world\", null)).isNull();\r\n    assertThat(StringUtils.split(null, null)).isNull();\r\n}\n@Test\r\nvoid collectionToDelimitedStringWithNullValuesShouldNotFail() {\r\n    assertThat(StringUtils.collectionToCommaDelimitedString(Collections.singletonList(null))).isEqualTo(\"null\");\r\n}\n@Test\r\nvoid truncatePreconditions() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> StringUtils.truncate(\"foo\", 0)).withMessage(\"Truncation threshold must be a positive number: 0\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> StringUtils.truncate(\"foo\", -99)).withMessage(\"Truncation threshold must be a positive number: -99\");\r\n}\n@ParameterizedTest\r\n@CsvSource(delimiterString = \"-->\", textBlock = \"\"\"\r\n    ''                  --> ''\r\n    aardvark            --> aardvark\r\n    aardvark12          --> aardvark12\r\n    aardvark123         --> aardvark12 (truncated)...\r\n    aardvark, bird, cat --> aardvark,  (truncated)...\r\n    \"\"\")\r\nvoid truncate(String text, String truncated) {\r\n    assertThat(StringUtils.truncate(text, 10)).isEqualTo(truncated);\r\n}",
    "comment": "\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rick Evans\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@ValueSource(strings = { \"text\", \"  text  \", \"  \", \"\\t\", \"\\n text\" })\r\nvoid hasLengthForValidValues(String value) {\r\n    assertThat(StringUtils.hasLength(value)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@NullAndEmptySource\r\nvoid hasLengthForInvalidValues(String value) {\r\n    assertThat(StringUtils.hasLength(value)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@ValueSource(strings = { \"text\", \"  text  \", \"\\n text\" })\r\nvoid hasTextForValidValues(String value) {\r\n    assertThat(StringUtils.hasText(value)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#hasTextForInvalidValues(String)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@NullAndEmptySource\r\n@ValueSource(strings = { \"  \", \"\\t\" })\r\nvoid hasTextForInvalidValues(String value) {\r\n    assertThat(StringUtils.hasText(value)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#containsWhitespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsWhitespace() {\r\n    assertThat(StringUtils.containsWhitespace(null)).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\"\")).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\"a\")).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\"abc\")).isFalse();\r\n    assertThat(StringUtils.containsWhitespace(\" \")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"\\t\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"\\n\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\" a\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"abc \")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"a b\")).isTrue();\r\n    assertThat(StringUtils.containsWhitespace(\"a  b\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimWhitespace()",
    "entityType": "method",
    "code": "@Test\r\n@Deprecated\r\nvoid trimWhitespace() {\r\n    assertThat(StringUtils.trimWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimWhitespace(\" a\")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimWhitespace(\"a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimWhitespace(\" a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimWhitespace(\" a b \")).isEqualTo(\"a b\");\r\n    assertThat(StringUtils.trimWhitespace(\" a b  c \")).isEqualTo(\"a b  c\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimAllWhitespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid trimAllWhitespace() {\r\n    assertThat(StringUtils.trimAllWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimAllWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimAllWhitespace(\" a\")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimAllWhitespace(\"a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimAllWhitespace(\" a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimAllWhitespace(\" a b \")).isEqualTo(\"ab\");\r\n    assertThat(StringUtils.trimAllWhitespace(\" a b  c \")).isEqualTo(\"abc\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid trimLeadingWhitespace() {\r\n    assertThat(StringUtils.trimLeadingWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a\")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\"a \")).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a \")).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a b \")).isEqualTo(\"a b \");\r\n    assertThat(StringUtils.trimLeadingWhitespace(\" a b  c \")).isEqualTo(\"a b  c \");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimTrailingWhitespace()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid trimTrailingWhitespace() {\r\n    assertThat(StringUtils.trimTrailingWhitespace(null)).isNull();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" \")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"\\t\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" \\t\\n\")).isEmpty();\r\n    assertThat(StringUtils.trimTrailingWhitespace(\"a \")).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a\")).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a \")).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a b \")).isEqualTo(\" a b\");\r\n    assertThat(StringUtils.trimTrailingWhitespace(\" a b  c \")).isEqualTo(\" a b  c\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimLeadingCharacter()",
    "entityType": "method",
    "code": "@Test\r\nvoid trimLeadingCharacter() {\r\n    assertThat(StringUtils.trimLeadingCharacter(null, ' ')).isNull();\r\n    assertThat(StringUtils.trimLeadingCharacter(\"\", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimLeadingCharacter(\" \", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimLeadingCharacter(\"\\t\", ' ')).isEqualTo(\"\\t\");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a\", ' ')).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimLeadingCharacter(\"a \", ' ')).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a \", ' ')).isEqualTo(\"a \");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a b \", ' ')).isEqualTo(\"a b \");\r\n    assertThat(StringUtils.trimLeadingCharacter(\" a b  c \", ' ')).isEqualTo(\"a b  c \");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#trimTrailingCharacter()",
    "entityType": "method",
    "code": "@Test\r\nvoid trimTrailingCharacter() {\r\n    assertThat(StringUtils.trimTrailingCharacter(null, ' ')).isNull();\r\n    assertThat(StringUtils.trimTrailingCharacter(\"\", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimTrailingCharacter(\" \", ' ')).isEmpty();\r\n    assertThat(StringUtils.trimTrailingCharacter(\"\\t\", ' ')).isEqualTo(\"\\t\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\"a \", ' ')).isEqualTo(\"a\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a\", ' ')).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a \", ' ')).isEqualTo(\" a\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a b \", ' ')).isEqualTo(\" a b\");\r\n    assertThat(StringUtils.trimTrailingCharacter(\" a b  c \", ' ')).isEqualTo(\" a b  c\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.StringUtilsTests#matchesCharacter()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchesCharacter() {\r\n    assertThat(StringUtils.matchesCharacter(null, '/')).isFalse();\r\n    assertThat(StringUtils.matchesCharacter(\"/a\", '/')).isFalse();\r\n    assertThat(StringUtils.matchesCharacter(\"a\", '/')).isFalse();\r\n    assertThat(StringUtils.matchesCharacter(\"/\", '/')).isTrue();\r\n}",
    "comment": ""
  }
]