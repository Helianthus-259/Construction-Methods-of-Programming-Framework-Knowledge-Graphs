[
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#hasMetaAnnotationTypes(AnnotatedElement,String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied {@link AnnotatedElement} is annotated with a\r\n * <em>composed annotation</em> that is meta-annotated with an annotation\r\n * of the specified {@code annotationName}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the\r\n * meta-annotation type to find\r\n * @return {@code true} if a matching meta-annotation is present\r\n * @see #getMetaAnnotationTypes\r\n */\r\npublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\r\n    return getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);\r\n}",
    "comment": "\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with a\n\t * <em>composed annotation</em> that is meta-annotated with an annotation\n\t * of the specified {@code annotationName}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the\n\t * meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @see #getMetaAnnotationTypes\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#isAnnotated(AnnotatedElement,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if an annotation of the specified {@code annotationType}\r\n * is <em>present</em> on the supplied {@link AnnotatedElement} or\r\n * within the annotation hierarchy <em>above</em> the specified element.\r\n * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\r\n * will return a non-null value.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return {@code true} if a matching annotation is present\r\n * @since 4.2.3\r\n * @see #hasAnnotation(AnnotatedElement, Class)\r\n */\r\npublic static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.isAnnotationPresent(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return getAnnotations(element).isPresent(annotationType);\r\n}",
    "comment": "\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>present</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.2.3\n\t * @see #hasAnnotation(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#isAnnotated(AnnotatedElement,String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if an annotation of the specified {@code annotationName} is\r\n * <em>present</em> on the supplied {@link AnnotatedElement} or within the\r\n * annotation hierarchy <em>above</em> the specified element.\r\n * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\r\n * will return a non-null value.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @return {@code true} if a matching annotation is present\r\n */\r\npublic static boolean isAnnotated(AnnotatedElement element, String annotationName) {\r\n    return getAnnotations(element).isPresent(annotationName);\r\n}",
    "comment": "\n\t * Determine if an annotation of the specified {@code annotationName} is\n\t * <em>present</em> on the supplied {@link AnnotatedElement} or within the\n\t * annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotationAttributes(AnnotatedElement,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Get the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    MergedAnnotation<?> mergedAnnotation = getAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, false, false);\r\n}",
    "comment": "\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotationAttributes(AnnotatedElement,String)",
    "entityType": "method",
    "code": "/**\r\n * Get the first annotation of the specified {@code annotationName} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\r\n * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, String annotationName) {\r\n    return getMergedAnnotationAttributes(element, annotationName, false, false);\r\n}",
    "comment": "\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\n\t * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Get the first annotation of the specified {@code annotationName} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>Attributes from lower levels in the annotation hierarchy override attributes\r\n * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\r\n * fully supported, both within a single annotation and within the annotation hierarchy.\r\n * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\r\n * this method will stop searching the annotation hierarchy once the first annotation\r\n * of the specified {@code annotationName} has been found. As a consequence,\r\n * additional annotations of the specified {@code annotationName} will be ignored.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into Strings or to\r\n * preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\r\n * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    MergedAnnotation<?> mergedAnnotation = getAnnotations(element).get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}",
    "comment": "\n\t * Get the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override attributes\n\t * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\n\t * fully supported, both within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\n\t * this method will stop searching the annotation hierarchy once the first annotation\n\t * of the specified {@code annotationName} has been found. As a consequence,\n\t * additional annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\n\t * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMergedAnnotation(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element},\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy, and synthesize\r\n * the result back into an annotation of the specified {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return getAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared()).synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "comment": "\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getAllMergedAnnotations(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get <strong>all</strong> annotations of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 4.3\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String)\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> getAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return getAnnotations(element).stream(annotationType).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Get <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getAllMergedAnnotations(AnnotatedElement,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "/**\r\n * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the\r\n * annotation hierarchy and synthesize the results back into an annotation\r\n * of the corresponding {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationTypes the annotation types to find\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 5.1\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\r\n    return getAnnotations(element).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes)).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>The container type that holds the repeatable annotations will be looked up\r\n * via {@link java.lang.annotation.Repeatable}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @since 4.3\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return getMergedRepeatableAnnotations(element, annotationType, null);\r\n}",
    "comment": "\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\r\n * {@code null}, the search will be restricted to supporting only repeatable\r\n * annotations whose container is the supplied {@code containerType}. This\r\n * prevents the search from finding repeatable annotations declared as\r\n * meta-annotations on other types of repeatable annotations. If you need to\r\n * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\r\n * over this method or alternatively use the {@link MergedAnnotations} API\r\n * directly in conjunction with {@link RepeatableContainers} that are\r\n * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\r\n * multiple repeatable annotation types.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @param containerType the type of the container that holds the annotations;\r\n * may be {@code null} if the container type should be looked up via\r\n * {@link java.lang.annotation.Repeatable}\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @throws AnnotationConfigurationException if the supplied {@code containerType}\r\n * is not a valid container annotation for the supplied {@code annotationType}\r\n * @since 4.3\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\r\n    return getRepeatableAnnotations(element, containerType, annotationType).stream(annotationType).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #getMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getAllAnnotationAttributes(AnnotatedElement,String)",
    "entityType": "method",
    "code": "/**\r\n * Get the annotation attributes of <strong>all</strong> annotations of the specified\r\n * {@code annotationName} in the annotation hierarchy above the supplied\r\n * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\r\n * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\r\n * this method does <em>not</em> support attribute overrides.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\r\n * attributes from all annotations found, or {@code null} if not found\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\npublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName) {\r\n    return getAllAnnotationAttributes(element, annotationName, false, false);\r\n}",
    "comment": "\n\t * Get the annotation attributes of <strong>all</strong> annotations of the specified\n\t * {@code annotationName} in the annotation hierarchy above the supplied\n\t * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getAllAnnotationAttributes(AnnotatedElement,String,boolean,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Get the annotation attributes of <strong>all</strong> annotations of\r\n * the specified {@code annotationName} in the annotation hierarchy above\r\n * the supplied {@link AnnotatedElement} and store the results in a\r\n * {@link MultiValueMap}.\r\n * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\r\n * this method does <em>not</em> support attribute overrides.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into Strings or to\r\n * preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\r\n * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\r\n * attributes from all annotations found, or {@code null} if not found\r\n */\r\npublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {\r\n    Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\r\n    return getAnnotations(element).stream(annotationName).filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));\r\n}",
    "comment": "\n\t * Get the annotation attributes of <strong>all</strong> annotations of\n\t * the specified {@code annotationName} in the annotation hierarchy above\n\t * the supplied {@link AnnotatedElement} and store the results in a\n\t * {@link MultiValueMap}.\n\t * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\n\t * this method does <em>not</em> support attribute overrides.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\n\t * attributes from all annotations found, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#hasAnnotation(AnnotatedElement,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if an annotation of the specified {@code annotationType}\r\n * is <em>available</em> on the supplied {@link AnnotatedElement} or\r\n * within the annotation hierarchy <em>above</em> the specified element.\r\n * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\r\n * will return a non-null value.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return {@code true} if a matching annotation is present\r\n * @since 4.3\r\n * @see #isAnnotated(AnnotatedElement, Class)\r\n */\r\npublic static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.isAnnotationPresent(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return findAnnotations(element).isPresent(annotationType);\r\n}",
    "comment": "\n\t * Determine if an annotation of the specified {@code annotationType}\n\t * is <em>available</em> on the supplied {@link AnnotatedElement} or\n\t * within the annotation hierarchy <em>above</em> the specified element.\n\t * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\n\t * will return a non-null value.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return {@code true} if a matching annotation is present\n\t * @since 4.3\n\t * @see #isAnnotated(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotationAttributes(AnnotatedElement,Class<? extends Annotation>,boolean,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Find the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>Attributes from lower levels in the annotation hierarchy override\r\n * attributes of the same name from higher levels, and\r\n * {@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\r\n * used by this method will stop searching the annotation hierarchy once the\r\n * first annotation of the specified {@code annotationType} has been found.\r\n * As a consequence, additional annotations of the specified\r\n * {@code annotationType} will be ignored.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into\r\n * Strings or to preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\r\n * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    MergedAnnotation<?> mergedAnnotation = findAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}",
    "comment": "\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\n\t * used by this method will stop searching the annotation hierarchy once the\n\t * first annotation of the specified {@code annotationType} has been found.\n\t * As a consequence, additional annotations of the specified\n\t * {@code annotationType} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into\n\t * Strings or to preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotationAttributes(AnnotatedElement,String,boolean,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Find the first annotation of the specified {@code annotationName} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>Attributes from lower levels in the annotation hierarchy override\r\n * attributes of the same name from higher levels, and\r\n * {@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\r\n * algorithm used by this method will stop searching the annotation\r\n * hierarchy once the first annotation of the specified\r\n * {@code annotationName} has been found. As a consequence, additional\r\n * annotations of the specified {@code annotationName} will be ignored.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into Strings or to\r\n * preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\r\n * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    MergedAnnotation<?> mergedAnnotation = findAnnotations(element).get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}",
    "comment": "\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element} and\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy.\n\t * <p>Attributes from lower levels in the annotation hierarchy override\n\t * attributes of the same name from higher levels, and\n\t * {@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\n\t * algorithm used by this method will stop searching the annotation\n\t * hierarchy once the first annotation of the specified\n\t * {@code annotationName} has been found. As a consequence, additional\n\t * annotations of the specified {@code annotationName} will be ignored.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @param classValuesAsString whether to convert Class references into Strings or to\n\t * preserve them as Class references\n\t * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\n\t * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\n\t * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findMergedAnnotation(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Find the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element},\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy, and synthesize\r\n * the result back into an annotation of the specified {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return findAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared()).synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}",
    "comment": "\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above</em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching</em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findAllMergedAnnotations(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Find <strong>all</strong> annotations of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 4.3\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return findAnnotations(element).stream(annotationType).sorted(highAggregateIndexesFirst()).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Find <strong>all</strong> annotations of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #getAllMergedAnnotations(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findAllMergedAnnotations(AnnotatedElement,Set<Class<? extends Annotation>>)",
    "entityType": "method",
    "code": "/**\r\n * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the\r\n * annotation hierarchy and synthesize the results back into an annotation\r\n * of the corresponding {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationTypes the annotation types to find\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 5.1\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\r\n    return findAnnotations(element).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes)).sorted(highAggregateIndexesFirst()).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the\n\t * annotation hierarchy and synthesize the results back into an annotation\n\t * of the corresponding {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationTypes the annotation types to find\n\t * @return the set of all merged, synthesized {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @since 5.1\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findMergedRepeatableAnnotations(AnnotatedElement,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>The container type that holds the repeatable annotations will be looked up\r\n * via {@link java.lang.annotation.Repeatable}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @since 4.3\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return findMergedRepeatableAnnotations(element, annotationType, null);\r\n}",
    "comment": "\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>The container type that holds the repeatable annotations will be looked up\n\t * via {@link java.lang.annotation.Repeatable}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findMergedRepeatableAnnotations(AnnotatedElement,Class<A>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\r\n * {@code null}, the search will be restricted to supporting only repeatable\r\n * annotations whose container is the supplied {@code containerType}. This\r\n * prevents the search from finding repeatable annotations declared as\r\n * meta-annotations on other types of repeatable annotations. If you need to\r\n * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\r\n * over this method or alternatively use the {@link MergedAnnotations} API\r\n * directly in conjunction with {@link RepeatableContainers} that are\r\n * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\r\n * multiple repeatable annotation types.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @param containerType the type of the container that holds the annotations;\r\n * may be {@code null} if the container type should be looked up via\r\n * {@link java.lang.annotation.Repeatable}\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @throws AnnotationConfigurationException if the supplied {@code containerType}\r\n * is not a valid container annotation for the supplied {@code annotationType}\r\n * @since 4.3\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\r\n    return findRepeatableAnnotations(element, containerType, annotationType).stream(annotationType).sorted(highAggregateIndexesFirst()).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}",
    "comment": "\n\t * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\n\t * within the annotation hierarchy <em>above</em> the supplied {@code element};\n\t * and for each annotation found, merge that annotation's attributes with\n\t * <em>matching</em> attributes from annotations in lower levels of the annotation\n\t * hierarchy and synthesize the results back into an annotation of the specified\n\t * {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\n\t * single annotation and within annotation hierarchies.\n\t * <p>This method follows <em>find semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\n\t * {@code null}, the search will be restricted to supporting only repeatable\n\t * annotations whose container is the supplied {@code containerType}. This\n\t * prevents the search from finding repeatable annotations declared as\n\t * meta-annotations on other types of repeatable annotations. If you need to\n\t * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\n\t * over this method or alternatively use the {@link MergedAnnotations} API\n\t * directly in conjunction with {@link RepeatableContainers} that are\n\t * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\n\t * multiple repeatable annotation types.\n\t * @param element the annotated element (never {@code null})\n\t * @param annotationType the annotation type to find (never {@code null})\n\t * @param containerType the type of the container that holds the annotations;\n\t * may be {@code null} if the container type should be looked up via\n\t * {@link java.lang.annotation.Repeatable}\n\t * @return the set of all merged repeatable {@code Annotations} found,\n\t * or an empty set if none were found\n\t * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\n\t * is {@code null}, or if the container type cannot be resolved\n\t * @throws AnnotationConfigurationException if the supplied {@code containerType}\n\t * is not a valid container annotation for the supplied {@code annotationType}\n\t * @since 4.3\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findAllMergedAnnotations(AnnotatedElement, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotations(AnnotatedElement)",
    "entityType": "method",
    "code": "private static MergedAnnotations getAnnotations(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getRepeatableAnnotations(AnnotatedElement,Class<? extends Annotation>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element, @Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\r\n    RepeatableContainers repeatableContainers;\r\n    if (containerType == null) {\r\n        // Invoke RepeatableContainers.of() in order to adhere to the contract of\r\n        // getMergedRepeatableAnnotations() which states that an IllegalArgumentException\r\n        // will be thrown if the container cannot be resolved.\r\n        //\r\n        // In any case, we use standardRepeatables() in order to support repeatable\r\n        // annotations on other types of repeatable annotations (i.e., nested repeatable\r\n        // annotation types).\r\n        //\r\n        // See https://github.com/spring-projects/spring-framework/issues/20279\r\n        RepeatableContainers.of(annotationType, null);\r\n        repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    } else {\r\n        repeatableContainers = RepeatableContainers.of(annotationType, containerType);\r\n    }\r\n    return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findAnnotations(AnnotatedElement)",
    "entityType": "method",
    "code": "private static MergedAnnotations findAnnotations(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#findRepeatableAnnotations(AnnotatedElement,Class<? extends Annotation>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element, @Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\r\n    RepeatableContainers repeatableContainers;\r\n    if (containerType == null) {\r\n        // Invoke RepeatableContainers.of() in order to adhere to the contract of\r\n        // findMergedRepeatableAnnotations() which states that an IllegalArgumentException\r\n        // will be thrown if the container cannot be resolved.\r\n        //\r\n        // In any case, we use standardRepeatables() in order to support repeatable\r\n        // annotations on other types of repeatable annotations (i.e., nested repeatable\r\n        // annotation types).\r\n        //\r\n        // See https://github.com/spring-projects/spring-framework/issues/20279\r\n        RepeatableContainers.of(annotationType, null);\r\n        repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    } else {\r\n        repeatableContainers = RepeatableContainers.of(annotationType, containerType);\r\n    }\r\n    return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#nullIfEmpty(MultiValueMap<String,Object>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {\r\n    return (map.isEmpty() ? null : map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#highAggregateIndexesFirst()",
    "entityType": "method",
    "code": "private static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {\r\n    return Comparator.<MergedAnnotation<A>>comparingInt(MergedAnnotation::getAggregateIndex).reversed();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getAnnotationAttributes(MergedAnnotation<?>,boolean,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    if (!annotation.isPresent()) {\r\n        return null;\r\n    }\r\n    return annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, nestedAnnotationsAsMap));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementForAnnotations",
    "entityType": "class",
    "code": "private final Annotation[] annotations;\nAnnotatedElementForAnnotations(Annotation... annotations) {\r\n    this.annotations = annotations;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <T extends Annotation> T getAnnotation(Class<T> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return (T) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}\n@Override\r\npublic Annotation[] getAnnotations() {\r\n    return this.annotations.clone();\r\n}\n@Override\r\npublic Annotation[] getDeclaredAnnotations() {\r\n    return this.annotations.clone();\r\n}",
    "comment": "\n\t * Adapted {@link AnnotatedElement} that holds specific annotations.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementForAnnotations#getAnnotation(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <T extends Annotation> T getAnnotation(Class<T> annotationClass) {\r\n    for (Annotation annotation : this.annotations) {\r\n        if (annotation.annotationType() == annotationClass) {\r\n            return (T) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementForAnnotations#getAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic Annotation[] getAnnotations() {\r\n    return this.annotations.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementForAnnotations#getDeclaredAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic Annotation[] getDeclaredAnnotations() {\r\n    return this.annotations.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod",
    "entityType": "class",
    "code": "private final Method method;\nprivate final Method bridgedMethod;\nprivate final MethodParameter[] parameters;\n@Nullable\r\nprivate volatile List<Annotation[][]> inheritedParameterAnnotations;\n/**\r\n * Create an instance that wraps the given {@link Method}.\r\n * @param method the {@code Method} handle to wrap\r\n */\r\npublic AnnotatedMethod(Method method) {\r\n    Assert.notNull(method, \"Method is required\");\r\n    this.method = method;\r\n    this.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\r\n    ReflectionUtils.makeAccessible(this.bridgedMethod);\r\n    this.parameters = initMethodParameters();\r\n}\n/**\r\n * Copy constructor for use in subclasses.\r\n */\r\nprotected AnnotatedMethod(AnnotatedMethod annotatedMethod) {\r\n    Assert.notNull(annotatedMethod, \"AnnotatedMethod is required\");\r\n    this.method = annotatedMethod.method;\r\n    this.bridgedMethod = annotatedMethod.bridgedMethod;\r\n    this.parameters = annotatedMethod.parameters;\r\n    this.inheritedParameterAnnotations = annotatedMethod.inheritedParameterAnnotations;\r\n}\n/**\r\n * Return the annotated method.\r\n */\r\npublic final Method getMethod() {\r\n    return this.method;\r\n}\n/**\r\n * If the annotated method is a bridge method, this method returns the bridged\r\n * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\r\n */\r\nprotected final Method getBridgedMethod() {\r\n    return this.bridgedMethod;\r\n}\n/**\r\n * Expose the containing class for method parameters.\r\n * @see MethodParameter#getContainingClass()\r\n */\r\nprotected Class<?> getContainingClass() {\r\n    return this.method.getDeclaringClass();\r\n}\n/**\r\n * Return the method parameters for this {@code AnnotatedMethod}.\r\n */\r\npublic final MethodParameter[] getMethodParameters() {\r\n    return this.parameters;\r\n}\nprivate MethodParameter[] initMethodParameters() {\r\n    int count = this.bridgedMethod.getParameterCount();\r\n    MethodParameter[] result = new MethodParameter[count];\r\n    for (int i = 0; i < count; i++) {\r\n        result[i] = new AnnotatedMethodParameter(i);\r\n    }\r\n    return result;\r\n}\n/**\r\n * Return a {@link MethodParameter} for the declared return type.\r\n */\r\npublic MethodParameter getReturnType() {\r\n    return new AnnotatedMethodParameter(-1);\r\n}\n/**\r\n * Return a {@link MethodParameter} for the actual return value type.\r\n */\r\npublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\r\n    return new ReturnValueMethodParameter(returnValue);\r\n}\n/**\r\n * Return {@code true} if the method's return type is void, {@code false} otherwise.\r\n */\r\npublic boolean isVoid() {\r\n    return (getReturnType().getParameterType() == void.class);\r\n}\n/**\r\n * Return a single annotation on the underlying method, traversing its super methods\r\n * if no annotation can be found on the given method itself.\r\n * <p>Supports <em>merged</em> composed annotations with attribute overrides.\r\n * @param annotationType the annotation type to look for\r\n * @return the annotation, or {@code null} if none found\r\n * @see AnnotatedElementUtils#findMergedAnnotation\r\n */\r\n@Nullable\r\npublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\r\n    return AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType);\r\n}\n/**\r\n * Determine if an annotation of the given type is <em>present</em> or\r\n * <em>meta-present</em> on the method.\r\n * @param annotationType the annotation type to look for\r\n * @see AnnotatedElementUtils#hasAnnotation\r\n */\r\npublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\r\n    return AnnotatedElementUtils.hasAnnotation(this.method, annotationType);\r\n}\nprivate List<Annotation[][]> getInheritedParameterAnnotations() {\r\n    List<Annotation[][]> parameterAnnotations = this.inheritedParameterAnnotations;\r\n    if (parameterAnnotations == null) {\r\n        parameterAnnotations = new ArrayList<>();\r\n        Class<?> clazz = this.method.getDeclaringClass();\r\n        while (clazz != null) {\r\n            for (Class<?> ifc : clazz.getInterfaces()) {\r\n                for (Method candidate : ifc.getMethods()) {\r\n                    if (isOverrideFor(candidate)) {\r\n                        parameterAnnotations.add(candidate.getParameterAnnotations());\r\n                    }\r\n                }\r\n            }\r\n            clazz = clazz.getSuperclass();\r\n            if (clazz == Object.class) {\r\n                clazz = null;\r\n            }\r\n            if (clazz != null) {\r\n                for (Method candidate : clazz.getMethods()) {\r\n                    if (isOverrideFor(candidate)) {\r\n                        parameterAnnotations.add(candidate.getParameterAnnotations());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inheritedParameterAnnotations = parameterAnnotations;\r\n    }\r\n    return parameterAnnotations;\r\n}\nprivate boolean isOverrideFor(Method candidate) {\r\n    if (!candidate.getName().equals(this.method.getName()) || candidate.getParameterCount() != this.method.getParameterCount()) {\r\n        return false;\r\n    }\r\n    Class<?>[] paramTypes = this.method.getParameterTypes();\r\n    if (Arrays.equals(candidate.getParameterTypes(), paramTypes)) {\r\n        return true;\r\n    }\r\n    for (int i = 0; i < paramTypes.length; i++) {\r\n        if (paramTypes[i] != ResolvableType.forMethodParameter(candidate, i, this.method.getDeclaringClass()).resolve()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other != null && getClass() == other.getClass() && this.method.equals(((AnnotatedMethod) other).method)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.method.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.method.toGenericString();\r\n}\n// Support methods for use in subclass variants\r\n@Nullable\r\nprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\r\n    if (!ObjectUtils.isEmpty(providedArgs)) {\r\n        for (Object providedArg : providedArgs) {\r\n            if (parameter.getParameterType().isInstance(providedArg)) {\r\n                return providedArg;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\nprotected static String formatArgumentError(MethodParameter param, String message) {\r\n    return \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" + param.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\r\n}\n/**\r\n * A MethodParameter with AnnotatedMethod-specific behavior.\r\n */\r\nprotected class AnnotatedMethodParameter extends SynthesizingMethodParameter {\r\n\r\n    private volatile Annotation @Nullable [] combinedAnnotations;\r\n\r\n    public AnnotatedMethodParameter(int index) {\r\n        super(AnnotatedMethod.this.getBridgedMethod(), index);\r\n    }\r\n\r\n    protected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\r\n        super(original);\r\n        this.combinedAnnotations = original.combinedAnnotations;\r\n    }\r\n\r\n    @Override\r\n    public Method getMethod() {\r\n        return AnnotatedMethod.this.getBridgedMethod();\r\n    }\r\n\r\n    @Override\r\n    public Class<?> getContainingClass() {\r\n        return AnnotatedMethod.this.getContainingClass();\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\r\n        return AnnotatedMethod.this.getMethodAnnotation(annotationType);\r\n    }\r\n\r\n    @Override\r\n    public <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\r\n        return AnnotatedMethod.this.hasMethodAnnotation(annotationType);\r\n    }\r\n\r\n    @Override\r\n    public Annotation[] getParameterAnnotations() {\r\n        Annotation[] anns = this.combinedAnnotations;\r\n        if (anns == null) {\r\n            anns = super.getParameterAnnotations();\r\n            int index = getParameterIndex();\r\n            if (index >= 0) {\r\n                for (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\r\n                    if (index < ifcAnns.length) {\r\n                        Annotation[] paramAnns = ifcAnns[index];\r\n                        if (paramAnns.length > 0) {\r\n                            List<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\r\n                            merged.addAll(Arrays.asList(anns));\r\n                            for (Annotation paramAnn : paramAnns) {\r\n                                boolean existingType = false;\r\n                                for (Annotation ann : anns) {\r\n                                    if (ann.annotationType() == paramAnn.annotationType()) {\r\n                                        existingType = true;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (!existingType) {\r\n                                    merged.add(adaptAnnotation(paramAnn));\r\n                                }\r\n                            }\r\n                            anns = merged.toArray(new Annotation[0]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.combinedAnnotations = anns;\r\n        }\r\n        return anns;\r\n    }\r\n\r\n    @Override\r\n    public AnnotatedMethodParameter clone() {\r\n        return new AnnotatedMethodParameter(this);\r\n    }\r\n}\n/**\r\n * A MethodParameter for an AnnotatedMethod return type based on an actual return value.\r\n */\r\nprivate class ReturnValueMethodParameter extends AnnotatedMethodParameter {\r\n\r\n    @Nullable\r\n    private final Class<?> returnValueType;\r\n\r\n    public ReturnValueMethodParameter(@Nullable Object returnValue) {\r\n        super(-1);\r\n        this.returnValueType = (returnValue != null ? returnValue.getClass() : null);\r\n    }\r\n\r\n    protected ReturnValueMethodParameter(ReturnValueMethodParameter original) {\r\n        super(original);\r\n        this.returnValueType = original.returnValueType;\r\n    }\r\n\r\n    @Override\r\n    public Class<?> getParameterType() {\r\n        return (this.returnValueType != null ? this.returnValueType : super.getParameterType());\r\n    }\r\n\r\n    @Override\r\n    public ReturnValueMethodParameter clone() {\r\n        return new ReturnValueMethodParameter(this);\r\n    }\r\n}",
    "comment": "\n * A convenient wrapper for a {@link Method} handle, providing deep annotation\n * introspection on methods and method parameters, including the exposure of\n * interface-declared parameter annotations from the concrete target method.\n *\n * @author Juergen Hoeller\n * @since 6.1\n * @see #getMethodAnnotation(Class)\n * @see #getMethodParameters()\n * @see AnnotatedElementUtils\n * @see SynthesizingMethodParameter\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getMethod()",
    "entityType": "method",
    "code": "/**\r\n * Return the annotated method.\r\n */\r\npublic final Method getMethod() {\r\n    return this.method;\r\n}",
    "comment": "\n\t * Return the annotated method.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getBridgedMethod()",
    "entityType": "method",
    "code": "/**\r\n * If the annotated method is a bridge method, this method returns the bridged\r\n * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\r\n */\r\nprotected final Method getBridgedMethod() {\r\n    return this.bridgedMethod;\r\n}",
    "comment": "\n\t * If the annotated method is a bridge method, this method returns the bridged\n\t * (user-defined) method. Otherwise, it returns the same method as {@link #getMethod()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getContainingClass()",
    "entityType": "method",
    "code": "/**\r\n * Expose the containing class for method parameters.\r\n * @see MethodParameter#getContainingClass()\r\n */\r\nprotected Class<?> getContainingClass() {\r\n    return this.method.getDeclaringClass();\r\n}",
    "comment": "\n\t * Expose the containing class for method parameters.\n\t * @see MethodParameter#getContainingClass()\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getMethodParameters()",
    "entityType": "method",
    "code": "/**\r\n * Return the method parameters for this {@code AnnotatedMethod}.\r\n */\r\npublic final MethodParameter[] getMethodParameters() {\r\n    return this.parameters;\r\n}",
    "comment": "\n\t * Return the method parameters for this {@code AnnotatedMethod}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#initMethodParameters()",
    "entityType": "method",
    "code": "private MethodParameter[] initMethodParameters() {\r\n    int count = this.bridgedMethod.getParameterCount();\r\n    MethodParameter[] result = new MethodParameter[count];\r\n    for (int i = 0; i < count; i++) {\r\n        result[i] = new AnnotatedMethodParameter(i);\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getReturnType()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link MethodParameter} for the declared return type.\r\n */\r\npublic MethodParameter getReturnType() {\r\n    return new AnnotatedMethodParameter(-1);\r\n}",
    "comment": "\n\t * Return a {@link MethodParameter} for the declared return type.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getReturnValueType(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link MethodParameter} for the actual return value type.\r\n */\r\npublic MethodParameter getReturnValueType(@Nullable Object returnValue) {\r\n    return new ReturnValueMethodParameter(returnValue);\r\n}",
    "comment": "\n\t * Return a {@link MethodParameter} for the actual return value type.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#isVoid()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the method's return type is void, {@code false} otherwise.\r\n */\r\npublic boolean isVoid() {\r\n    return (getReturnType().getParameterType() == void.class);\r\n}",
    "comment": "\n\t * Return {@code true} if the method's return type is void, {@code false} otherwise.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getMethodAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Return a single annotation on the underlying method, traversing its super methods\r\n * if no annotation can be found on the given method itself.\r\n * <p>Supports <em>merged</em> composed annotations with attribute overrides.\r\n * @param annotationType the annotation type to look for\r\n * @return the annotation, or {@code null} if none found\r\n * @see AnnotatedElementUtils#findMergedAnnotation\r\n */\r\n@Nullable\r\npublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\r\n    return AnnotatedElementUtils.findMergedAnnotation(this.method, annotationType);\r\n}",
    "comment": "\n\t * Return a single annotation on the underlying method, traversing its super methods\n\t * if no annotation can be found on the given method itself.\n\t * <p>Supports <em>merged</em> composed annotations with attribute overrides.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation, or {@code null} if none found\n\t * @see AnnotatedElementUtils#findMergedAnnotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#hasMethodAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if an annotation of the given type is <em>present</em> or\r\n * <em>meta-present</em> on the method.\r\n * @param annotationType the annotation type to look for\r\n * @see AnnotatedElementUtils#hasAnnotation\r\n */\r\npublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\r\n    return AnnotatedElementUtils.hasAnnotation(this.method, annotationType);\r\n}",
    "comment": "\n\t * Determine if an annotation of the given type is <em>present</em> or\n\t * <em>meta-present</em> on the method.\n\t * @param annotationType the annotation type to look for\n\t * @see AnnotatedElementUtils#hasAnnotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#getInheritedParameterAnnotations()",
    "entityType": "method",
    "code": "private List<Annotation[][]> getInheritedParameterAnnotations() {\r\n    List<Annotation[][]> parameterAnnotations = this.inheritedParameterAnnotations;\r\n    if (parameterAnnotations == null) {\r\n        parameterAnnotations = new ArrayList<>();\r\n        Class<?> clazz = this.method.getDeclaringClass();\r\n        while (clazz != null) {\r\n            for (Class<?> ifc : clazz.getInterfaces()) {\r\n                for (Method candidate : ifc.getMethods()) {\r\n                    if (isOverrideFor(candidate)) {\r\n                        parameterAnnotations.add(candidate.getParameterAnnotations());\r\n                    }\r\n                }\r\n            }\r\n            clazz = clazz.getSuperclass();\r\n            if (clazz == Object.class) {\r\n                clazz = null;\r\n            }\r\n            if (clazz != null) {\r\n                for (Method candidate : clazz.getMethods()) {\r\n                    if (isOverrideFor(candidate)) {\r\n                        parameterAnnotations.add(candidate.getParameterAnnotations());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inheritedParameterAnnotations = parameterAnnotations;\r\n    }\r\n    return parameterAnnotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#isOverrideFor(Method)",
    "entityType": "method",
    "code": "private boolean isOverrideFor(Method candidate) {\r\n    if (!candidate.getName().equals(this.method.getName()) || candidate.getParameterCount() != this.method.getParameterCount()) {\r\n        return false;\r\n    }\r\n    Class<?>[] paramTypes = this.method.getParameterTypes();\r\n    if (Arrays.equals(candidate.getParameterTypes(), paramTypes)) {\r\n        return true;\r\n    }\r\n    for (int i = 0; i < paramTypes.length; i++) {\r\n        if (paramTypes[i] != ResolvableType.forMethodParameter(candidate, i, this.method.getDeclaringClass()).resolve()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other != null && getClass() == other.getClass() && this.method.equals(((AnnotatedMethod) other).method)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.method.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.method.toGenericString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#findProvidedArgument(MethodParameter,Object)",
    "entityType": "method",
    "code": "// Support methods for use in subclass variants\r\n@Nullable\r\nprotected static Object findProvidedArgument(MethodParameter parameter, @Nullable Object... providedArgs) {\r\n    if (!ObjectUtils.isEmpty(providedArgs)) {\r\n        for (Object providedArg : providedArgs) {\r\n            if (parameter.getParameterType().isInstance(providedArg)) {\r\n                return providedArg;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethod#formatArgumentError(MethodParameter,String)",
    "entityType": "method",
    "code": "protected static String formatArgumentError(MethodParameter param, String message) {\r\n    return \"Could not resolve parameter [\" + param.getParameterIndex() + \"] in \" + param.getExecutable().toGenericString() + (StringUtils.hasText(message) ? \": \" + message : \"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter",
    "entityType": "class",
    "code": "private volatile Annotation @Nullable [] combinedAnnotations;\npublic AnnotatedMethodParameter(int index) {\r\n    super(AnnotatedMethod.this.getBridgedMethod(), index);\r\n}\nprotected AnnotatedMethodParameter(AnnotatedMethodParameter original) {\r\n    super(original);\r\n    this.combinedAnnotations = original.combinedAnnotations;\r\n}\n@Override\r\npublic Method getMethod() {\r\n    return AnnotatedMethod.this.getBridgedMethod();\r\n}\n@Override\r\npublic Class<?> getContainingClass() {\r\n    return AnnotatedMethod.this.getContainingClass();\r\n}\n@Override\r\n@Nullable\r\npublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\r\n    return AnnotatedMethod.this.getMethodAnnotation(annotationType);\r\n}\n@Override\r\npublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\r\n    return AnnotatedMethod.this.hasMethodAnnotation(annotationType);\r\n}\n@Override\r\npublic Annotation[] getParameterAnnotations() {\r\n    Annotation[] anns = this.combinedAnnotations;\r\n    if (anns == null) {\r\n        anns = super.getParameterAnnotations();\r\n        int index = getParameterIndex();\r\n        if (index >= 0) {\r\n            for (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\r\n                if (index < ifcAnns.length) {\r\n                    Annotation[] paramAnns = ifcAnns[index];\r\n                    if (paramAnns.length > 0) {\r\n                        List<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\r\n                        merged.addAll(Arrays.asList(anns));\r\n                        for (Annotation paramAnn : paramAnns) {\r\n                            boolean existingType = false;\r\n                            for (Annotation ann : anns) {\r\n                                if (ann.annotationType() == paramAnn.annotationType()) {\r\n                                    existingType = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (!existingType) {\r\n                                merged.add(adaptAnnotation(paramAnn));\r\n                            }\r\n                        }\r\n                        anns = merged.toArray(new Annotation[0]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.combinedAnnotations = anns;\r\n    }\r\n    return anns;\r\n}\n@Override\r\npublic AnnotatedMethodParameter clone() {\r\n    return new AnnotatedMethodParameter(this);\r\n}",
    "comment": "\n\t * A MethodParameter with AnnotatedMethod-specific behavior.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter#getMethod()",
    "entityType": "method",
    "code": "@Override\r\npublic Method getMethod() {\r\n    return AnnotatedMethod.this.getBridgedMethod();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter#getContainingClass()",
    "entityType": "method",
    "code": "@Override\r\npublic Class<?> getContainingClass() {\r\n    return AnnotatedMethod.this.getContainingClass();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter#getMethodAnnotation(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic <T extends Annotation> T getMethodAnnotation(Class<T> annotationType) {\r\n    return AnnotatedMethod.this.getMethodAnnotation(annotationType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter#hasMethodAnnotation(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T extends Annotation> boolean hasMethodAnnotation(Class<T> annotationType) {\r\n    return AnnotatedMethod.this.hasMethodAnnotation(annotationType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter#getParameterAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic Annotation[] getParameterAnnotations() {\r\n    Annotation[] anns = this.combinedAnnotations;\r\n    if (anns == null) {\r\n        anns = super.getParameterAnnotations();\r\n        int index = getParameterIndex();\r\n        if (index >= 0) {\r\n            for (Annotation[][] ifcAnns : getInheritedParameterAnnotations()) {\r\n                if (index < ifcAnns.length) {\r\n                    Annotation[] paramAnns = ifcAnns[index];\r\n                    if (paramAnns.length > 0) {\r\n                        List<Annotation> merged = new ArrayList<>(anns.length + paramAnns.length);\r\n                        merged.addAll(Arrays.asList(anns));\r\n                        for (Annotation paramAnn : paramAnns) {\r\n                            boolean existingType = false;\r\n                            for (Annotation ann : anns) {\r\n                                if (ann.annotationType() == paramAnn.annotationType()) {\r\n                                    existingType = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (!existingType) {\r\n                                merged.add(adaptAnnotation(paramAnn));\r\n                            }\r\n                        }\r\n                        anns = merged.toArray(new Annotation[0]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.combinedAnnotations = anns;\r\n    }\r\n    return anns;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedMethodParameter#clone()",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotatedMethodParameter clone() {\r\n    return new AnnotatedMethodParameter(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ReturnValueMethodParameter",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Class<?> returnValueType;\npublic ReturnValueMethodParameter(@Nullable Object returnValue) {\r\n    super(-1);\r\n    this.returnValueType = (returnValue != null ? returnValue.getClass() : null);\r\n}\nprotected ReturnValueMethodParameter(ReturnValueMethodParameter original) {\r\n    super(original);\r\n    this.returnValueType = original.returnValueType;\r\n}\n@Override\r\npublic Class<?> getParameterType() {\r\n    return (this.returnValueType != null ? this.returnValueType : super.getParameterType());\r\n}\n@Override\r\npublic ReturnValueMethodParameter clone() {\r\n    return new ReturnValueMethodParameter(this);\r\n}",
    "comment": "\n\t * A MethodParameter for an AnnotatedMethod return type based on an actual return value.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.ReturnValueMethodParameter#getParameterType()",
    "entityType": "method",
    "code": "@Override\r\npublic Class<?> getParameterType() {\r\n    return (this.returnValueType != null ? this.returnValueType : super.getParameterType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ReturnValueMethodParameter#clone()",
    "entityType": "method",
    "code": "@Override\r\npublic ReturnValueMethodParameter clone() {\r\n    return new ReturnValueMethodParameter(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes",
    "entityType": "class",
    "code": "private static final String UNKNOWN = \"unknown\";\n@Nullable\r\nprivate final Class<? extends Annotation> annotationType;\nfinal String displayName;\nfinal boolean validated;\n/**\r\n * Create a new, empty {@link AnnotationAttributes} instance.\r\n */\r\npublic AnnotationAttributes() {\r\n    this.annotationType = null;\r\n    this.displayName = UNKNOWN;\r\n    this.validated = false;\r\n}\n/**\r\n * Create a new, empty {@link AnnotationAttributes} instance with the\r\n * given initial capacity to optimize performance.\r\n * @param initialCapacity initial size of the underlying map\r\n */\r\npublic AnnotationAttributes(int initialCapacity) {\r\n    super(initialCapacity);\r\n    this.annotationType = null;\r\n    this.displayName = UNKNOWN;\r\n    this.validated = false;\r\n}\n/**\r\n * Create a new {@link AnnotationAttributes} instance, wrapping the provided\r\n * map and all its <em>key-value</em> pairs.\r\n * @param map original source of annotation attribute <em>key-value</em> pairs\r\n * @see #fromMap(Map)\r\n */\r\npublic AnnotationAttributes(Map<String, @Nullable Object> map) {\r\n    super(map);\r\n    this.annotationType = null;\r\n    this.displayName = UNKNOWN;\r\n    this.validated = false;\r\n}\n/**\r\n * Create a new {@link AnnotationAttributes} instance, wrapping the provided\r\n * map and all its <em>key-value</em> pairs.\r\n * @param other original source of annotation attribute <em>key-value</em> pairs\r\n * @see #fromMap(Map)\r\n */\r\npublic AnnotationAttributes(AnnotationAttributes other) {\r\n    super(other);\r\n    this.annotationType = other.annotationType;\r\n    this.displayName = other.displayName;\r\n    this.validated = other.validated;\r\n}\n/**\r\n * Create a new, empty {@link AnnotationAttributes} instance for the\r\n * specified {@code annotationType}.\r\n * @param annotationType the type of annotation represented by this\r\n * {@code AnnotationAttributes} instance; never {@code null}\r\n * @since 4.2\r\n */\r\npublic AnnotationAttributes(Class<? extends Annotation> annotationType) {\r\n    this(annotationType, false);\r\n}\n/**\r\n * Create a possibly already validated new, empty\r\n * {@link AnnotationAttributes} instance for the specified\r\n * {@code annotationType}.\r\n * @param annotationType the type of annotation represented by this\r\n * {@code AnnotationAttributes} instance; never {@code null}\r\n * @param validated if the attributes are considered already validated\r\n * @since 5.2\r\n */\r\nAnnotationAttributes(Class<? extends Annotation> annotationType, boolean validated) {\r\n    Assert.notNull(annotationType, \"'annotationType' must not be null\");\r\n    this.annotationType = annotationType;\r\n    this.displayName = annotationType.getName();\r\n    this.validated = validated;\r\n}\n/**\r\n * Create a new, empty {@link AnnotationAttributes} instance for the\r\n * specified {@code annotationType}.\r\n * @param annotationType the annotation type name represented by this\r\n * {@code AnnotationAttributes} instance; never {@code null}\r\n * @param classLoader the ClassLoader to try to load the annotation type on,\r\n * or {@code null} to just store the annotation type name\r\n * @since 4.3.2\r\n */\r\npublic AnnotationAttributes(String annotationType, @Nullable ClassLoader classLoader) {\r\n    Assert.notNull(annotationType, \"'annotationType' must not be null\");\r\n    this.annotationType = getAnnotationType(annotationType, classLoader);\r\n    this.displayName = annotationType;\r\n    this.validated = false;\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate static Class<? extends Annotation> getAnnotationType(String annotationType, @Nullable ClassLoader classLoader) {\r\n    if (classLoader != null) {\r\n        try {\r\n            return (Class<? extends Annotation>) classLoader.loadClass(annotationType);\r\n        } catch (ClassNotFoundException ex) {\r\n            // Annotation Class not resolvable\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * Get the type of annotation represented by this {@code AnnotationAttributes}.\r\n * @return the annotation type, or {@code null} if unknown\r\n * @since 4.2\r\n */\r\n@Nullable\r\npublic Class<? extends Annotation> annotationType() {\r\n    return this.annotationType;\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as a string.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic String getString(String attributeName) {\r\n    return getRequiredAttribute(attributeName, String.class);\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as an\r\n * array of strings.\r\n * <p>If the value stored under the specified {@code attributeName} is\r\n * a string, it will be wrapped in a single-element array before\r\n * returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic String[] getStringArray(String attributeName) {\r\n    return getRequiredAttribute(attributeName, String[].class);\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as a boolean.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic boolean getBoolean(String attributeName) {\r\n    return getRequiredAttribute(attributeName, Boolean.class);\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as a number.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <N extends Number> N getNumber(String attributeName) {\r\n    return (N) getRequiredAttribute(attributeName, Number.class);\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as an enum.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <E extends Enum<?>> E getEnum(String attributeName) {\r\n    return (E) getRequiredAttribute(attributeName, Enum.class);\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as a class.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> Class<? extends T> getClass(String attributeName) {\r\n    return getRequiredAttribute(attributeName, Class.class);\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName} as an\r\n * array of classes.\r\n * <p>If the value stored under the specified {@code attributeName} is a class,\r\n * it will be wrapped in a single-element array before returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic Class<?>[] getClassArray(String attributeName) {\r\n    return getRequiredAttribute(attributeName, Class[].class);\r\n}\n/**\r\n * Get the {@link AnnotationAttributes} stored under the specified\r\n * {@code attributeName}.\r\n * <p>Note: if you expect an actual annotation, invoke\r\n * {@link #getAnnotation(String, Class)} instead.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the {@code AnnotationAttributes}\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic AnnotationAttributes getAnnotation(String attributeName) {\r\n    return getRequiredAttribute(attributeName, AnnotationAttributes.class);\r\n}\n/**\r\n * Get the annotation of type {@code annotationType} stored under the\r\n * specified {@code attributeName}.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @param annotationType the expected annotation type; never {@code null}\r\n * @return the annotation\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n * @since 4.2\r\n */\r\npublic <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {\r\n    return getRequiredAttribute(attributeName, annotationType);\r\n}\n/**\r\n * Get the array of {@link AnnotationAttributes} stored under the specified\r\n * {@code attributeName}.\r\n * <p>If the value stored under the specified {@code attributeName} is\r\n * an instance of {@code AnnotationAttributes}, it will be wrapped in\r\n * a single-element array before returning it.\r\n * <p>Note: if you expect an actual array of annotations, invoke\r\n * {@link #getAnnotationArray(String, Class)} instead.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the array of {@code AnnotationAttributes}\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic AnnotationAttributes[] getAnnotationArray(String attributeName) {\r\n    return getRequiredAttribute(attributeName, AnnotationAttributes[].class);\r\n}\n/**\r\n * Get the array of type {@code annotationType} stored under the specified\r\n * {@code attributeName}.\r\n * <p>If the value stored under the specified {@code attributeName} is\r\n * an {@code Annotation}, it will be wrapped in a single-element array\r\n * before returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @param annotationType the expected annotation type; never {@code null}\r\n * @return the annotation array\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n * @since 4.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {\r\n    return (A[]) getRequiredAttribute(attributeName, annotationType.arrayType());\r\n}\n/**\r\n * Get the value stored under the specified {@code attributeName},\r\n * ensuring that the value is of the {@code expectedType}.\r\n * <p>If the {@code expectedType} is an array and the value stored\r\n * under the specified {@code attributeName} is a single element of the\r\n * component type of the expected array type, the single element will be\r\n * wrapped in a single-element array of the appropriate type before\r\n * returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @param expectedType the expected type; never {@code null}\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprivate <T> T getRequiredAttribute(String attributeName, Class<T> expectedType) {\r\n    Assert.hasText(attributeName, \"'attributeName' must not be null or empty\");\r\n    Object value = get(attributeName);\r\n    if (value == null) {\r\n        throw new IllegalArgumentException(String.format(\"Attribute '%s' not found in attributes for annotation [%s]\", attributeName, this.displayName));\r\n    }\r\n    if (value instanceof Throwable throwable) {\r\n        throw new IllegalArgumentException(String.format(\"Attribute '%s' for annotation [%s] was not resolvable due to exception [%s]\", attributeName, this.displayName, value), throwable);\r\n    }\r\n    if (!expectedType.isInstance(value) && expectedType.isArray() && expectedType.componentType().isInstance(value)) {\r\n        Object array = Array.newInstance(expectedType.componentType(), 1);\r\n        Array.set(array, 0, value);\r\n        value = array;\r\n    }\r\n    if (!expectedType.isInstance(value)) {\r\n        throw new IllegalArgumentException(String.format(\"Attribute '%s' is of type %s, but %s was expected in attributes for annotation [%s]\", attributeName, value.getClass().getSimpleName(), expectedType.getSimpleName(), this.displayName));\r\n    }\r\n    return (T) value;\r\n}\n@Override\r\npublic String toString() {\r\n    Iterator<Map.Entry<String, @Nullable Object>> entries = entrySet().iterator();\r\n    StringBuilder sb = new StringBuilder(\"{\");\r\n    while (entries.hasNext()) {\r\n        Map.Entry<String, @Nullable Object> entry = entries.next();\r\n        sb.append(entry.getKey());\r\n        sb.append('=');\r\n        sb.append(valueToString(entry.getValue()));\r\n        if (entries.hasNext()) {\r\n            sb.append(\", \");\r\n        }\r\n    }\r\n    sb.append('}');\r\n    return sb.toString();\r\n}\nprivate String valueToString(@Nullable Object value) {\r\n    if (value == this) {\r\n        return \"(this Map)\";\r\n    }\r\n    if (value instanceof Object[] objects) {\r\n        return \"[\" + StringUtils.arrayToDelimitedString(objects, \", \") + \"]\";\r\n    }\r\n    return String.valueOf(value);\r\n}\n/**\r\n * Return an {@link AnnotationAttributes} instance based on the given map.\r\n * <p>If the map is already an {@code AnnotationAttributes} instance, it\r\n * will be cast and returned immediately without creating a new instance.\r\n * Otherwise a new instance will be created by passing the supplied map\r\n * to the {@link #AnnotationAttributes(Map)} constructor.\r\n * @param map original source of annotation attribute <em>key-value</em> pairs\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes fromMap(@Nullable Map<String, @Nullable Object> map) {\r\n    if (map == null) {\r\n        return null;\r\n    }\r\n    if (map instanceof AnnotationAttributes annotationAttributes) {\r\n        return annotationAttributes;\r\n    }\r\n    return new AnnotationAttributes(map);\r\n}",
    "comment": "\n * {@link LinkedHashMap} subclass representing annotation attribute\n * <em>key-value</em> pairs as read by {@link AnnotationUtils},\n * {@link AnnotatedElementUtils}, and Spring's reflection- and ASM-based\n * {@link org.springframework.core.type.AnnotationMetadata} implementations.\n *\n * <p>Provides 'pseudo-reification' to avoid noisy Map generics in the calling\n * code as well as convenience methods for looking up annotation attributes\n * in a type-safe fashion.\n *\n * @author Chris Beams\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 3.1.1\n * @see AnnotationUtils#getAnnotationAttributes\n * @see AnnotatedElementUtils\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getAnnotationType(String,ClassLoader)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate static Class<? extends Annotation> getAnnotationType(String annotationType, @Nullable ClassLoader classLoader) {\r\n    if (classLoader != null) {\r\n        try {\r\n            return (Class<? extends Annotation>) classLoader.loadClass(annotationType);\r\n        } catch (ClassNotFoundException ex) {\r\n            // Annotation Class not resolvable\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#annotationType()",
    "entityType": "method",
    "code": "/**\r\n * Get the type of annotation represented by this {@code AnnotationAttributes}.\r\n * @return the annotation type, or {@code null} if unknown\r\n * @since 4.2\r\n */\r\n@Nullable\r\npublic Class<? extends Annotation> annotationType() {\r\n    return this.annotationType;\r\n}",
    "comment": "\n\t * Get the type of annotation represented by this {@code AnnotationAttributes}.\n\t * @return the annotation type, or {@code null} if unknown\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getString(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as a string.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic String getString(String attributeName) {\r\n    return getRequiredAttribute(attributeName, String.class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as a string.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getStringArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as an\r\n * array of strings.\r\n * <p>If the value stored under the specified {@code attributeName} is\r\n * a string, it will be wrapped in a single-element array before\r\n * returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic String[] getStringArray(String attributeName) {\r\n    return getRequiredAttribute(attributeName, String[].class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as an\n\t * array of strings.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * a string, it will be wrapped in a single-element array before\n\t * returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getBoolean(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as a boolean.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic boolean getBoolean(String attributeName) {\r\n    return getRequiredAttribute(attributeName, Boolean.class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as a boolean.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getNumber(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as a number.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <N extends Number> N getNumber(String attributeName) {\r\n    return (N) getRequiredAttribute(attributeName, Number.class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as a number.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getEnum(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as an enum.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <E extends Enum<?>> E getEnum(String attributeName) {\r\n    return (E) getRequiredAttribute(attributeName, Enum.class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as an enum.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as a class.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> Class<? extends T> getClass(String attributeName) {\r\n    return getRequiredAttribute(attributeName, Class.class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as a class.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getClassArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName} as an\r\n * array of classes.\r\n * <p>If the value stored under the specified {@code attributeName} is a class,\r\n * it will be wrapped in a single-element array before returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic Class<?>[] getClassArray(String attributeName) {\r\n    return getRequiredAttribute(attributeName, Class[].class);\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName} as an\n\t * array of classes.\n\t * <p>If the value stored under the specified {@code attributeName} is a class,\n\t * it will be wrapped in a single-element array before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getAnnotation(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the {@link AnnotationAttributes} stored under the specified\r\n * {@code attributeName}.\r\n * <p>Note: if you expect an actual annotation, invoke\r\n * {@link #getAnnotation(String, Class)} instead.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the {@code AnnotationAttributes}\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic AnnotationAttributes getAnnotation(String attributeName) {\r\n    return getRequiredAttribute(attributeName, AnnotationAttributes.class);\r\n}",
    "comment": "\n\t * Get the {@link AnnotationAttributes} stored under the specified\n\t * {@code attributeName}.\n\t * <p>Note: if you expect an actual annotation, invoke\n\t * {@link #getAnnotation(String, Class)} instead.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the {@code AnnotationAttributes}\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getAnnotation(String,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get the annotation of type {@code annotationType} stored under the\r\n * specified {@code attributeName}.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @param annotationType the expected annotation type; never {@code null}\r\n * @return the annotation\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n * @since 4.2\r\n */\r\npublic <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {\r\n    return getRequiredAttribute(attributeName, annotationType);\r\n}",
    "comment": "\n\t * Get the annotation of type {@code annotationType} stored under the\n\t * specified {@code attributeName}.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getAnnotationArray(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the array of {@link AnnotationAttributes} stored under the specified\r\n * {@code attributeName}.\r\n * <p>If the value stored under the specified {@code attributeName} is\r\n * an instance of {@code AnnotationAttributes}, it will be wrapped in\r\n * a single-element array before returning it.\r\n * <p>Note: if you expect an actual array of annotations, invoke\r\n * {@link #getAnnotationArray(String, Class)} instead.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @return the array of {@code AnnotationAttributes}\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\npublic AnnotationAttributes[] getAnnotationArray(String attributeName) {\r\n    return getRequiredAttribute(attributeName, AnnotationAttributes[].class);\r\n}",
    "comment": "\n\t * Get the array of {@link AnnotationAttributes} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an instance of {@code AnnotationAttributes}, it will be wrapped in\n\t * a single-element array before returning it.\n\t * <p>Note: if you expect an actual array of annotations, invoke\n\t * {@link #getAnnotationArray(String, Class)} instead.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @return the array of {@code AnnotationAttributes}\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getAnnotationArray(String,Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get the array of type {@code annotationType} stored under the specified\r\n * {@code attributeName}.\r\n * <p>If the value stored under the specified {@code attributeName} is\r\n * an {@code Annotation}, it will be wrapped in a single-element array\r\n * before returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @param annotationType the expected annotation type; never {@code null}\r\n * @return the annotation array\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n * @since 4.2\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {\r\n    return (A[]) getRequiredAttribute(attributeName, annotationType.arrayType());\r\n}",
    "comment": "\n\t * Get the array of type {@code annotationType} stored under the specified\n\t * {@code attributeName}.\n\t * <p>If the value stored under the specified {@code attributeName} is\n\t * an {@code Annotation}, it will be wrapped in a single-element array\n\t * before returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param annotationType the expected annotation type; never {@code null}\n\t * @return the annotation array\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#getRequiredAttribute(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get the value stored under the specified {@code attributeName},\r\n * ensuring that the value is of the {@code expectedType}.\r\n * <p>If the {@code expectedType} is an array and the value stored\r\n * under the specified {@code attributeName} is a single element of the\r\n * component type of the expected array type, the single element will be\r\n * wrapped in a single-element array of the appropriate type before\r\n * returning it.\r\n * @param attributeName the name of the attribute to get;\r\n * never {@code null} or empty\r\n * @param expectedType the expected type; never {@code null}\r\n * @return the value\r\n * @throws IllegalArgumentException if the attribute does not exist or\r\n * if it is not of the expected type\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprivate <T> T getRequiredAttribute(String attributeName, Class<T> expectedType) {\r\n    Assert.hasText(attributeName, \"'attributeName' must not be null or empty\");\r\n    Object value = get(attributeName);\r\n    if (value == null) {\r\n        throw new IllegalArgumentException(String.format(\"Attribute '%s' not found in attributes for annotation [%s]\", attributeName, this.displayName));\r\n    }\r\n    if (value instanceof Throwable throwable) {\r\n        throw new IllegalArgumentException(String.format(\"Attribute '%s' for annotation [%s] was not resolvable due to exception [%s]\", attributeName, this.displayName, value), throwable);\r\n    }\r\n    if (!expectedType.isInstance(value) && expectedType.isArray() && expectedType.componentType().isInstance(value)) {\r\n        Object array = Array.newInstance(expectedType.componentType(), 1);\r\n        Array.set(array, 0, value);\r\n        value = array;\r\n    }\r\n    if (!expectedType.isInstance(value)) {\r\n        throw new IllegalArgumentException(String.format(\"Attribute '%s' is of type %s, but %s was expected in attributes for annotation [%s]\", attributeName, value.getClass().getSimpleName(), expectedType.getSimpleName(), this.displayName));\r\n    }\r\n    return (T) value;\r\n}",
    "comment": "\n\t * Get the value stored under the specified {@code attributeName},\n\t * ensuring that the value is of the {@code expectedType}.\n\t * <p>If the {@code expectedType} is an array and the value stored\n\t * under the specified {@code attributeName} is a single element of the\n\t * component type of the expected array type, the single element will be\n\t * wrapped in a single-element array of the appropriate type before\n\t * returning it.\n\t * @param attributeName the name of the attribute to get;\n\t * never {@code null} or empty\n\t * @param expectedType the expected type; never {@code null}\n\t * @return the value\n\t * @throws IllegalArgumentException if the attribute does not exist or\n\t * if it is not of the expected type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    Iterator<Map.Entry<String, @Nullable Object>> entries = entrySet().iterator();\r\n    StringBuilder sb = new StringBuilder(\"{\");\r\n    while (entries.hasNext()) {\r\n        Map.Entry<String, @Nullable Object> entry = entries.next();\r\n        sb.append(entry.getKey());\r\n        sb.append('=');\r\n        sb.append(valueToString(entry.getValue()));\r\n        if (entries.hasNext()) {\r\n            sb.append(\", \");\r\n        }\r\n    }\r\n    sb.append('}');\r\n    return sb.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#valueToString(Object)",
    "entityType": "method",
    "code": "private String valueToString(@Nullable Object value) {\r\n    if (value == this) {\r\n        return \"(this Map)\";\r\n    }\r\n    if (value instanceof Object[] objects) {\r\n        return \"[\" + StringUtils.arrayToDelimitedString(objects, \", \") + \"]\";\r\n    }\r\n    return String.valueOf(value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAttributes#fromMap(Map<String,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Return an {@link AnnotationAttributes} instance based on the given map.\r\n * <p>If the map is already an {@code AnnotationAttributes} instance, it\r\n * will be cast and returned immediately without creating a new instance.\r\n * Otherwise a new instance will be created by passing the supplied map\r\n * to the {@link #AnnotationAttributes(Map)} constructor.\r\n * @param map original source of annotation attribute <em>key-value</em> pairs\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes fromMap(@Nullable Map<String, @Nullable Object> map) {\r\n    if (map == null) {\r\n        return null;\r\n    }\r\n    if (map instanceof AnnotationAttributes annotationAttributes) {\r\n        return annotationAttributes;\r\n    }\r\n    return new AnnotationAttributes(map);\r\n}",
    "comment": "\n\t * Return an {@link AnnotationAttributes} instance based on the given map.\n\t * <p>If the map is already an {@code AnnotationAttributes} instance, it\n\t * will be cast and returned immediately without creating a new instance.\n\t * Otherwise a new instance will be created by passing the supplied map\n\t * to the {@link #AnnotationAttributes(Map)} constructor.\n\t * @param map original source of annotation attribute <em>key-value</em> pairs\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator",
    "entityType": "class",
    "code": "/**\r\n * Shared default instance of {@code AnnotationAwareOrderComparator}.\r\n */\r\npublic static final AnnotationAwareOrderComparator INSTANCE = new AnnotationAwareOrderComparator();\n/**\r\n * This implementation checks for {@link Order @Order} or\r\n * {@link jakarta.annotation.Priority @Priority} on various kinds of\r\n * elements, in addition to the {@link org.springframework.core.Ordered}\r\n * check in the superclass.\r\n */\r\n@Override\r\n@Nullable\r\nprotected Integer findOrder(Object obj) {\r\n    Integer order = super.findOrder(obj);\r\n    if (order != null) {\r\n        return order;\r\n    }\r\n    return findOrderFromAnnotation(obj);\r\n}\n@Nullable\r\nprivate Integer findOrderFromAnnotation(Object obj) {\r\n    AnnotatedElement element = (obj instanceof AnnotatedElement ae ? ae : obj.getClass());\r\n    MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);\r\n    Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);\r\n    if (order == null && obj instanceof DecoratingProxy decoratingProxy) {\r\n        return findOrderFromAnnotation(decoratingProxy.getDecoratedClass());\r\n    }\r\n    return order;\r\n}\n/**\r\n * This implementation retrieves an @{@link jakarta.annotation.Priority}\r\n * value, allowing for additional semantics over the regular @{@link Order}\r\n * annotation: typically, selecting one object over another in case of\r\n * multiple matches but only one object to be returned.\r\n */\r\n@Override\r\n@Nullable\r\npublic Integer getPriority(Object obj) {\r\n    if (obj instanceof Class<?> clazz) {\r\n        return OrderUtils.getPriority(clazz);\r\n    }\r\n    Integer priority = OrderUtils.getPriority(obj.getClass());\r\n    if (priority == null && obj instanceof DecoratingProxy decoratingProxy) {\r\n        return getPriority(decoratingProxy.getDecoratedClass());\r\n    }\r\n    return priority;\r\n}\n/**\r\n * Sort the given list with a default {@link AnnotationAwareOrderComparator}.\r\n * <p>Optimized to skip sorting for lists with size 0 or 1,\r\n * in order to avoid unnecessary array extraction.\r\n * @param list the List to sort\r\n * @see java.util.List#sort(java.util.Comparator)\r\n */\r\npublic static void sort(List<?> list) {\r\n    if (list.size() > 1) {\r\n        list.sort(INSTANCE);\r\n    }\r\n}\n/**\r\n * Sort the given array with a default AnnotationAwareOrderComparator.\r\n * <p>Optimized to skip sorting for lists with size 0 or 1,\r\n * in order to avoid unnecessary array extraction.\r\n * @param array the array to sort\r\n * @see java.util.Arrays#sort(Object[], java.util.Comparator)\r\n */\r\npublic static void sort(Object[] array) {\r\n    if (array.length > 1) {\r\n        Arrays.sort(array, INSTANCE);\r\n    }\r\n}\n/**\r\n * Sort the given array or List with a default AnnotationAwareOrderComparator,\r\n * if necessary. Simply skips sorting when given any other value.\r\n * <p>Optimized to skip sorting for lists with size 0 or 1,\r\n * in order to avoid unnecessary array extraction.\r\n * @param value the array or List to sort\r\n * @see java.util.Arrays#sort(Object[], java.util.Comparator)\r\n */\r\npublic static void sortIfNecessary(Object value) {\r\n    if (value instanceof Object[] objects) {\r\n        sort(objects);\r\n    } else if (value instanceof List<?> list) {\r\n        sort(list);\r\n    }\r\n}",
    "comment": "\n * {@code AnnotationAwareOrderComparator} is an extension of\n * {@link OrderComparator} that supports Spring's\n * {@link org.springframework.core.Ordered} interface as well as the\n * {@link Order @Order} and {@link jakarta.annotation.Priority @Priority}\n * annotations, with an order value provided by an {@code Ordered}\n * instance overriding a statically defined annotation value (if any).\n *\n * <p>Consult the Javadoc for {@link OrderComparator} for details on the\n * sort semantics for non-ordered objects.\n *\n * @author Juergen Hoeller\n * @author Oliver Gierke\n * @author Stephane Nicoll\n * @since 2.0.1\n * @see org.springframework.core.Ordered\n * @see org.springframework.core.annotation.Order\n * @see jakarta.annotation.Priority\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator#findOrder(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks for {@link Order @Order} or\r\n * {@link jakarta.annotation.Priority @Priority} on various kinds of\r\n * elements, in addition to the {@link org.springframework.core.Ordered}\r\n * check in the superclass.\r\n */\r\n@Override\r\n@Nullable\r\nprotected Integer findOrder(Object obj) {\r\n    Integer order = super.findOrder(obj);\r\n    if (order != null) {\r\n        return order;\r\n    }\r\n    return findOrderFromAnnotation(obj);\r\n}",
    "comment": "\n\t * This implementation checks for {@link Order @Order} or\n\t * {@link jakarta.annotation.Priority @Priority} on various kinds of\n\t * elements, in addition to the {@link org.springframework.core.Ordered}\n\t * check in the superclass.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator#findOrderFromAnnotation(Object)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Integer findOrderFromAnnotation(Object obj) {\r\n    AnnotatedElement element = (obj instanceof AnnotatedElement ae ? ae : obj.getClass());\r\n    MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);\r\n    Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);\r\n    if (order == null && obj instanceof DecoratingProxy decoratingProxy) {\r\n        return findOrderFromAnnotation(decoratingProxy.getDecoratedClass());\r\n    }\r\n    return order;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator#getPriority(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation retrieves an @{@link jakarta.annotation.Priority}\r\n * value, allowing for additional semantics over the regular @{@link Order}\r\n * annotation: typically, selecting one object over another in case of\r\n * multiple matches but only one object to be returned.\r\n */\r\n@Override\r\n@Nullable\r\npublic Integer getPriority(Object obj) {\r\n    if (obj instanceof Class<?> clazz) {\r\n        return OrderUtils.getPriority(clazz);\r\n    }\r\n    Integer priority = OrderUtils.getPriority(obj.getClass());\r\n    if (priority == null && obj instanceof DecoratingProxy decoratingProxy) {\r\n        return getPriority(decoratingProxy.getDecoratedClass());\r\n    }\r\n    return priority;\r\n}",
    "comment": "\n\t * This implementation retrieves an @{@link jakarta.annotation.Priority}\n\t * value, allowing for additional semantics over the regular @{@link Order}\n\t * annotation: typically, selecting one object over another in case of\n\t * multiple matches but only one object to be returned.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator#sort(List<?>)",
    "entityType": "method",
    "code": "/**\r\n * Sort the given list with a default {@link AnnotationAwareOrderComparator}.\r\n * <p>Optimized to skip sorting for lists with size 0 or 1,\r\n * in order to avoid unnecessary array extraction.\r\n * @param list the List to sort\r\n * @see java.util.List#sort(java.util.Comparator)\r\n */\r\npublic static void sort(List<?> list) {\r\n    if (list.size() > 1) {\r\n        list.sort(INSTANCE);\r\n    }\r\n}",
    "comment": "\n\t * Sort the given list with a default {@link AnnotationAwareOrderComparator}.\n\t * <p>Optimized to skip sorting for lists with size 0 or 1,\n\t * in order to avoid unnecessary array extraction.\n\t * @param list the List to sort\n\t * @see java.util.List#sort(java.util.Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator#sort(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Sort the given array with a default AnnotationAwareOrderComparator.\r\n * <p>Optimized to skip sorting for lists with size 0 or 1,\r\n * in order to avoid unnecessary array extraction.\r\n * @param array the array to sort\r\n * @see java.util.Arrays#sort(Object[], java.util.Comparator)\r\n */\r\npublic static void sort(Object[] array) {\r\n    if (array.length > 1) {\r\n        Arrays.sort(array, INSTANCE);\r\n    }\r\n}",
    "comment": "\n\t * Sort the given array with a default AnnotationAwareOrderComparator.\n\t * <p>Optimized to skip sorting for lists with size 0 or 1,\n\t * in order to avoid unnecessary array extraction.\n\t * @param array the array to sort\n\t * @see java.util.Arrays#sort(Object[], java.util.Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationAwareOrderComparator#sortIfNecessary(Object)",
    "entityType": "method",
    "code": "/**\r\n * Sort the given array or List with a default AnnotationAwareOrderComparator,\r\n * if necessary. Simply skips sorting when given any other value.\r\n * <p>Optimized to skip sorting for lists with size 0 or 1,\r\n * in order to avoid unnecessary array extraction.\r\n * @param value the array or List to sort\r\n * @see java.util.Arrays#sort(Object[], java.util.Comparator)\r\n */\r\npublic static void sortIfNecessary(Object value) {\r\n    if (value instanceof Object[] objects) {\r\n        sort(objects);\r\n    } else if (value instanceof List<?> list) {\r\n        sort(list);\r\n    }\r\n}",
    "comment": "\n\t * Sort the given array or List with a default AnnotationAwareOrderComparator,\n\t * if necessary. Simply skips sorting when given any other value.\n\t * <p>Optimized to skip sorting for lists with size 0 or 1,\n\t * in order to avoid unnecessary array extraction.\n\t * @param value the array or List to sort\n\t * @see java.util.Arrays#sort(Object[], java.util.Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationConfigurationException",
    "entityType": "class",
    "code": "/**\r\n * Construct a new {@code AnnotationConfigurationException} with the\r\n * supplied message.\r\n * @param message the detail message\r\n */\r\npublic AnnotationConfigurationException(String message) {\r\n    super(message);\r\n}\n/**\r\n * Construct a new {@code AnnotationConfigurationException} with the\r\n * supplied message and cause.\r\n * @param message the detail message\r\n * @param cause the root cause\r\n */\r\npublic AnnotationConfigurationException(String message, Throwable cause) {\r\n    super(message, cause);\r\n}",
    "comment": "\n * Thrown by {@link AnnotationUtils} and <em>synthesized annotations</em>\n * if an annotation is improperly configured.\n *\n * @author Sam Brannen\n * @since 4.2\n * @see AnnotationUtils\n * @see AnnotationUtils#isSynthesizedAnnotation(java.lang.annotation.Annotation)\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationFilter",
    "entityType": "class",
    "code": "/**\r\n * {@link AnnotationFilter} that matches annotations in the\r\n * {@code java.lang} and {@code org.springframework.lang} packages\r\n * and their subpackages.\r\n * <p>This is the default filter in the {@link MergedAnnotations} model.\r\n */\r\nAnnotationFilter PLAIN = packages(\"java.lang\", \"org.springframework.lang\");\n/**\r\n * {@link AnnotationFilter} that matches annotations in the\r\n * {@code java} and {@code javax} packages and their subpackages.\r\n */\r\nAnnotationFilter JAVA = packages(\"java\", \"javax\");\n/**\r\n * {@link AnnotationFilter} that always matches and can be used when no\r\n * relevant annotation types are expected to be present at all.\r\n */\r\nAnnotationFilter ALL = new AnnotationFilter() {\r\n\r\n    @Override\r\n    public boolean matches(Annotation annotation) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(Class<?> type) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(String typeName) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"All annotations filtered\";\r\n    }\r\n};\n/**\r\n * {@link AnnotationFilter} that never matches and can be used when no\r\n * filtering is needed (allowing for any annotation types to be present).\r\n * @see #PLAIN\r\n * @deprecated as of 5.2.6 since the {@link MergedAnnotations} model\r\n * always ignores lang annotations according to the {@link #PLAIN} filter\r\n * (for efficiency reasons)\r\n */\r\n@Deprecated\r\nAnnotationFilter NONE = new AnnotationFilter() {\r\n\r\n    @Override\r\n    public boolean matches(Annotation annotation) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(Class<?> type) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(String typeName) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"No annotation filtering\";\r\n    }\r\n};\n/**\r\n * Test if the given annotation matches the filter.\r\n * @param annotation the annotation to test\r\n * @return {@code true} if the annotation matches\r\n */\r\ndefault boolean matches(Annotation annotation) {\r\n    return matches(annotation.annotationType());\r\n}\n/**\r\n * Test if the given type matches the filter.\r\n * @param type the annotation type to test\r\n * @return {@code true} if the annotation matches\r\n */\r\ndefault boolean matches(Class<?> type) {\r\n    return matches(type.getName());\r\n}\n/**\r\n * Test if the given type name matches the filter.\r\n * @param typeName the fully qualified class name of the annotation type to test\r\n * @return {@code true} if the annotation matches\r\n */\r\nboolean matches(String typeName);\n/**\r\n * Create a new {@link AnnotationFilter} that matches annotations in the\r\n * specified packages.\r\n * @param packages the annotation packages that should match\r\n * @return a new {@link AnnotationFilter} instance\r\n */\r\nstatic AnnotationFilter packages(String... packages) {\r\n    return new PackagesAnnotationFilter(packages);\r\n}",
    "comment": "\n * Callback interface that can be used to filter specific annotation types.\n *\n * <p>Note that the {@link MergedAnnotations} model (which this interface has been\n * designed for) always ignores lang annotations according to the {@link #PLAIN}\n * filter (for efficiency reasons). Any additional filters and even custom filter\n * implementations apply within this boundary and may only narrow further from here.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @since 5.2\n * @see MergedAnnotations\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationFilter#matches(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Test if the given annotation matches the filter.\r\n * @param annotation the annotation to test\r\n * @return {@code true} if the annotation matches\r\n */\r\ndefault boolean matches(Annotation annotation) {\r\n    return matches(annotation.annotationType());\r\n}",
    "comment": "\n\t * Test if the given annotation matches the filter.\n\t * @param annotation the annotation to test\n\t * @return {@code true} if the annotation matches\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationFilter#matches(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Test if the given type matches the filter.\r\n * @param type the annotation type to test\r\n * @return {@code true} if the annotation matches\r\n */\r\ndefault boolean matches(Class<?> type) {\r\n    return matches(type.getName());\r\n}",
    "comment": "\n\t * Test if the given type matches the filter.\n\t * @param type the annotation type to test\n\t * @return {@code true} if the annotation matches\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationFilter#matches(String)",
    "entityType": "method",
    "code": "/**\r\n * Test if the given type name matches the filter.\r\n * @param typeName the fully qualified class name of the annotation type to test\r\n * @return {@code true} if the annotation matches\r\n */\r\nboolean matches(String typeName);",
    "comment": "\n\t * Test if the given type name matches the filter.\n\t * @param typeName the fully qualified class name of the annotation type to test\n\t * @return {@code true} if the annotation matches\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationFilter#packages(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link AnnotationFilter} that matches annotations in the\r\n * specified packages.\r\n * @param packages the annotation packages that should match\r\n * @return a new {@link AnnotationFilter} instance\r\n */\r\nstatic AnnotationFilter packages(String... packages) {\r\n    return new PackagesAnnotationFilter(packages);\r\n}",
    "comment": "\n\t * Create a new {@link AnnotationFilter} that matches annotations in the\n\t * specified packages.\n\t * @param packages the annotation packages that should match\n\t * @return a new {@link AnnotationFilter} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsProcessor",
    "entityType": "class",
    "code": "/**\r\n * Called when an aggregate is about to be processed. This method may return\r\n * a {@code non-null} result to short-circuit any further processing.\r\n * @param context the context information relevant to the processor\r\n * @param aggregateIndex the aggregate index about to be processed\r\n * @return a {@code non-null} result if no further processing is required\r\n */\r\n@Nullable\r\ndefault R doWithAggregate(C context, int aggregateIndex) {\r\n    return null;\r\n}\n/**\r\n * Called when an array of annotations can be processed. This method may\r\n * return a {@code non-null} result to short-circuit any further processing.\r\n * @param context the context information relevant to the processor\r\n * @param aggregateIndex the aggregate index of the provided annotations\r\n * @param source the original source of the annotations, if known\r\n * @param annotations the annotations to process (this array may contain\r\n * {@code null} elements)\r\n * @return a {@code non-null} result if no further processing is required\r\n */\r\n@Nullable\r\nR doWithAnnotations(C context, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations);\n/**\r\n * Get the final result to be returned. By default this method returns\r\n * the last process result.\r\n * @param result the last early exit result, or {@code null} if none\r\n * @return the final result to be returned to the caller\r\n */\r\n@Nullable\r\ndefault R finish(@Nullable R result) {\r\n    return result;\r\n}",
    "comment": "\n * Callback interface used to process annotations.\n *\n * @author Phillip Webb\n * @since 5.2\n * @param <C> the context type\n * @param <R> the result type\n * @see AnnotationsScanner\n * @see TypeMappedAnnotations\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsProcessor#doWithAggregate(C,int)",
    "entityType": "method",
    "code": "/**\r\n * Called when an aggregate is about to be processed. This method may return\r\n * a {@code non-null} result to short-circuit any further processing.\r\n * @param context the context information relevant to the processor\r\n * @param aggregateIndex the aggregate index about to be processed\r\n * @return a {@code non-null} result if no further processing is required\r\n */\r\n@Nullable\r\ndefault R doWithAggregate(C context, int aggregateIndex) {\r\n    return null;\r\n}",
    "comment": "\n\t * Called when an aggregate is about to be processed. This method may return\n\t * a {@code non-null} result to short-circuit any further processing.\n\t * @param context the context information relevant to the processor\n\t * @param aggregateIndex the aggregate index about to be processed\n\t * @return a {@code non-null} result if no further processing is required\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsProcessor#doWithAnnotations(C,int,Object,Annotation[])",
    "entityType": "method",
    "code": "/**\r\n * Called when an array of annotations can be processed. This method may\r\n * return a {@code non-null} result to short-circuit any further processing.\r\n * @param context the context information relevant to the processor\r\n * @param aggregateIndex the aggregate index of the provided annotations\r\n * @param source the original source of the annotations, if known\r\n * @param annotations the annotations to process (this array may contain\r\n * {@code null} elements)\r\n * @return a {@code non-null} result if no further processing is required\r\n */\r\n@Nullable\r\nR doWithAnnotations(C context, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations);",
    "comment": "\n\t * Called when an array of annotations can be processed. This method may\n\t * return a {@code non-null} result to short-circuit any further processing.\n\t * @param context the context information relevant to the processor\n\t * @param aggregateIndex the aggregate index of the provided annotations\n\t * @param source the original source of the annotations, if known\n\t * @param annotations the annotations to process (this array may contain\n\t * {@code null} elements)\n\t * @return a {@code non-null} result if no further processing is required\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsProcessor#finish(R)",
    "entityType": "method",
    "code": "/**\r\n * Get the final result to be returned. By default this method returns\r\n * the last process result.\r\n * @param result the last early exit result, or {@code null} if none\r\n * @return the final result to be returned to the caller\r\n */\r\n@Nullable\r\ndefault R finish(@Nullable R result) {\r\n    return result;\r\n}",
    "comment": "\n\t * Get the final result to be returned. By default this method returns\n\t * the last process result.\n\t * @param result the last early exit result, or {@code null} if none\n\t * @return the final result to be returned to the caller\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner",
    "entityType": "class",
    "code": "@Nullable\r\nprivate static final Annotation[] NO_ANNOTATIONS = {};\nprivate static final Method[] NO_METHODS = {};\nprivate static final Map<AnnotatedElement, Annotation[]> declaredAnnotationCache = new ConcurrentReferenceHashMap<>(256);\nprivate static final Map<Class<?>, @Nullable Method[]> baseTypeMethodsCache = new ConcurrentReferenceHashMap<>(256);\nprivate AnnotationsScanner() {\r\n}\n/**\r\n * Scan the hierarchy of the specified element for relevant annotations and\r\n * call the processor as required.\r\n * @param context an optional context object that will be passed back to the\r\n * processor\r\n * @param source the source element to scan\r\n * @param searchStrategy the search strategy to use\r\n * @param searchEnclosingClass a predicate which evaluates to {@code true}\r\n * if a search should be performed on the enclosing class of the class\r\n * supplied to the predicate\r\n * @param processor the processor that receives the annotations\r\n * @return the result of {@link AnnotationsProcessor#finish(Object)}\r\n */\r\n@Nullable\r\nstatic <C, R> R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\r\n    R result = process(context, source, searchStrategy, searchEnclosingClass, processor);\r\n    return processor.finish(result);\r\n}\n@Nullable\r\nprivate static <C, R> R process(C context, AnnotatedElement source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\r\n    if (source instanceof Class<?> clazz) {\r\n        return processClass(context, clazz, searchStrategy, searchEnclosingClass, processor);\r\n    }\r\n    if (source instanceof Method method) {\r\n        return processMethod(context, method, searchStrategy, processor);\r\n    }\r\n    return processElement(context, source, processor);\r\n}\n@Nullable\r\nprivate static <C, R> R processClass(C context, Class<?> source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\r\n    return switch(searchStrategy) {\r\n        case DIRECT ->\r\n            processElement(context, source, processor);\r\n        case INHERITED_ANNOTATIONS ->\r\n            processClassInheritedAnnotations(context, source, processor);\r\n        case SUPERCLASS ->\r\n            processClassHierarchy(context, source, processor, false, Search.never);\r\n        case TYPE_HIERARCHY ->\r\n            processClassHierarchy(context, source, processor, true, searchEnclosingClass);\r\n    };\r\n}\n@Nullable\r\nprivate static <C, R> R processClassInheritedAnnotations(C context, Class<?> source, AnnotationsProcessor<C, R> processor) {\r\n    try {\r\n        if (isWithoutHierarchy(source, Search.never)) {\r\n            return processElement(context, source, processor);\r\n        }\r\n        @Nullable\r\n        Annotation[] relevant = null;\r\n        int remaining = Integer.MAX_VALUE;\r\n        int aggregateIndex = 0;\r\n        Class<?> root = source;\r\n        while (source != null && source != Object.class && remaining > 0 && !hasPlainJavaAnnotationsOnly(source)) {\r\n            R result = processor.doWithAggregate(context, aggregateIndex);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n            @Nullable\r\n            Annotation[] declaredAnns = getDeclaredAnnotations(source, true);\r\n            if (declaredAnns.length > 0) {\r\n                if (relevant == null) {\r\n                    relevant = root.getAnnotations();\r\n                    remaining = relevant.length;\r\n                }\r\n                for (int i = 0; i < declaredAnns.length; i++) {\r\n                    if (declaredAnns[i] != null) {\r\n                        boolean isRelevant = false;\r\n                        for (int relevantIndex = 0; relevantIndex < relevant.length; relevantIndex++) {\r\n                            //noinspection DataFlowIssue\r\n                            if (relevant[relevantIndex] != null && declaredAnns[i].annotationType() == relevant[relevantIndex].annotationType()) {\r\n                                isRelevant = true;\r\n                                relevant[relevantIndex] = null;\r\n                                remaining--;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!isRelevant) {\r\n                            declaredAnns[i] = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            result = processor.doWithAnnotations(context, aggregateIndex, source, declaredAnns);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n            source = source.getSuperclass();\r\n            aggregateIndex++;\r\n        }\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}\n@Nullable\r\nprivate static <C, R> R processClassHierarchy(C context, Class<?> source, AnnotationsProcessor<C, R> processor, boolean includeInterfaces, Predicate<Class<?>> searchEnclosingClass) {\r\n    return processClassHierarchy(context, new int[] { 0 }, source, processor, includeInterfaces, searchEnclosingClass);\r\n}\n@Nullable\r\nprivate static <C, R> R processClassHierarchy(C context, int[] aggregateIndex, Class<?> source, AnnotationsProcessor<C, R> processor, boolean includeInterfaces, Predicate<Class<?>> searchEnclosingClass) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, aggregateIndex[0]);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        if (hasPlainJavaAnnotationsOnly(source)) {\r\n            return null;\r\n        }\r\n        @Nullable\r\n        Annotation[] annotations = getDeclaredAnnotations(source, false);\r\n        result = processor.doWithAnnotations(context, aggregateIndex[0], source, annotations);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        aggregateIndex[0]++;\r\n        if (includeInterfaces) {\r\n            for (Class<?> interfaceType : source.getInterfaces()) {\r\n                R interfacesResult = processClassHierarchy(context, aggregateIndex, interfaceType, processor, true, searchEnclosingClass);\r\n                if (interfacesResult != null) {\r\n                    return interfacesResult;\r\n                }\r\n            }\r\n        }\r\n        Class<?> superclass = source.getSuperclass();\r\n        if (superclass != Object.class && superclass != null) {\r\n            R superclassResult = processClassHierarchy(context, aggregateIndex, superclass, processor, includeInterfaces, searchEnclosingClass);\r\n            if (superclassResult != null) {\r\n                return superclassResult;\r\n            }\r\n        }\r\n        if (searchEnclosingClass.test(source)) {\r\n            // Since merely attempting to load the enclosing class may result in\r\n            // automatic loading of sibling nested classes that in turn results\r\n            // in an exception such as NoClassDefFoundError, we wrap the following\r\n            // in its own dedicated try-catch block in order not to preemptively\r\n            // halt the annotation scanning process.\r\n            try {\r\n                Class<?> enclosingClass = source.getEnclosingClass();\r\n                if (enclosingClass != null) {\r\n                    R enclosingResult = processClassHierarchy(context, aggregateIndex, enclosingClass, processor, includeInterfaces, searchEnclosingClass);\r\n                    if (enclosingResult != null) {\r\n                        return enclosingResult;\r\n                    }\r\n                }\r\n            } catch (Throwable ex) {\r\n                AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}\n@Nullable\r\nprivate static <C, R> R processMethod(C context, Method source, SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor) {\r\n    return switch(searchStrategy) {\r\n        case DIRECT, INHERITED_ANNOTATIONS ->\r\n            processMethodInheritedAnnotations(context, source, processor);\r\n        case SUPERCLASS ->\r\n            processMethodHierarchy(context, new int[] { 0 }, source.getDeclaringClass(), processor, source, false);\r\n        case TYPE_HIERARCHY ->\r\n            processMethodHierarchy(context, new int[] { 0 }, source.getDeclaringClass(), processor, source, true);\r\n    };\r\n}\n@Nullable\r\nprivate static <C, R> R processMethodInheritedAnnotations(C context, Method source, AnnotationsProcessor<C, R> processor) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, 0);\r\n        return (result != null ? result : processMethodAnnotations(context, 0, source, processor));\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}\n@Nullable\r\nprivate static <C, R> R processMethodHierarchy(C context, int[] aggregateIndex, Class<?> sourceClass, AnnotationsProcessor<C, R> processor, Method rootMethod, boolean includeInterfaces) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, aggregateIndex[0]);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        if (hasPlainJavaAnnotationsOnly(sourceClass)) {\r\n            return null;\r\n        }\r\n        boolean calledProcessor = false;\r\n        if (sourceClass == rootMethod.getDeclaringClass()) {\r\n            result = processMethodAnnotations(context, aggregateIndex[0], rootMethod, processor);\r\n            calledProcessor = true;\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } else {\r\n            for (Method candidateMethod : getBaseTypeMethods(context, sourceClass)) {\r\n                if (candidateMethod != null && isOverride(rootMethod, candidateMethod)) {\r\n                    result = processMethodAnnotations(context, aggregateIndex[0], candidateMethod, processor);\r\n                    calledProcessor = true;\r\n                    if (result != null) {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (Modifier.isPrivate(rootMethod.getModifiers())) {\r\n            return null;\r\n        }\r\n        if (calledProcessor) {\r\n            aggregateIndex[0]++;\r\n        }\r\n        if (includeInterfaces) {\r\n            for (Class<?> interfaceType : sourceClass.getInterfaces()) {\r\n                R interfacesResult = processMethodHierarchy(context, aggregateIndex, interfaceType, processor, rootMethod, true);\r\n                if (interfacesResult != null) {\r\n                    return interfacesResult;\r\n                }\r\n            }\r\n        }\r\n        Class<?> superclass = sourceClass.getSuperclass();\r\n        if (superclass != Object.class && superclass != null) {\r\n            R superclassResult = processMethodHierarchy(context, aggregateIndex, superclass, processor, rootMethod, includeInterfaces);\r\n            if (superclassResult != null) {\r\n                return superclassResult;\r\n            }\r\n        }\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(rootMethod, ex);\r\n    }\r\n    return null;\r\n}\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\nprivate static <C> Method[] getBaseTypeMethods(C context, Class<?> baseType) {\r\n    if (baseType == Object.class || hasPlainJavaAnnotationsOnly(baseType)) {\r\n        return NO_METHODS;\r\n    }\r\n    @Nullable\r\n    Method[] methods = baseTypeMethodsCache.get(baseType);\r\n    if (methods == null) {\r\n        methods = ReflectionUtils.getDeclaredMethods(baseType);\r\n        int cleared = 0;\r\n        for (int i = 0; i < methods.length; i++) {\r\n            //noinspection DataFlowIssue\r\n            if (Modifier.isPrivate(methods[i].getModifiers()) || hasPlainJavaAnnotationsOnly(methods[i]) || getDeclaredAnnotations(methods[i], false).length == 0) {\r\n                methods[i] = null;\r\n                cleared++;\r\n            }\r\n        }\r\n        if (cleared == methods.length) {\r\n            methods = NO_METHODS;\r\n        }\r\n        baseTypeMethodsCache.put(baseType, methods);\r\n    }\r\n    return methods;\r\n}\nprivate static boolean isOverride(Method rootMethod, Method candidateMethod) {\r\n    return (!Modifier.isPrivate(candidateMethod.getModifiers()) && candidateMethod.getName().equals(rootMethod.getName()) && hasSameParameterTypes(rootMethod, candidateMethod));\r\n}\nprivate static boolean hasSameParameterTypes(Method rootMethod, Method candidateMethod) {\r\n    if (candidateMethod.getParameterCount() != rootMethod.getParameterCount()) {\r\n        return false;\r\n    }\r\n    Class<?>[] rootParameterTypes = rootMethod.getParameterTypes();\r\n    Class<?>[] candidateParameterTypes = candidateMethod.getParameterTypes();\r\n    if (Arrays.equals(candidateParameterTypes, rootParameterTypes)) {\r\n        return true;\r\n    }\r\n    return hasSameGenericTypeParameters(rootMethod, candidateMethod, rootParameterTypes);\r\n}\nprivate static boolean hasSameGenericTypeParameters(Method rootMethod, Method candidateMethod, Class<?>[] rootParameterTypes) {\r\n    Class<?> sourceDeclaringClass = rootMethod.getDeclaringClass();\r\n    Class<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();\r\n    if (!candidateDeclaringClass.isAssignableFrom(sourceDeclaringClass)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < rootParameterTypes.length; i++) {\r\n        Class<?> resolvedParameterType = ResolvableType.forMethodParameter(candidateMethod, i, sourceDeclaringClass).resolve();\r\n        if (rootParameterTypes[i] != resolvedParameterType) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Nullable\r\nprivate static <C, R> R processMethodAnnotations(C context, int aggregateIndex, Method source, AnnotationsProcessor<C, R> processor) {\r\n    @Nullable\r\n    Annotation[] annotations = getDeclaredAnnotations(source, false);\r\n    R result = processor.doWithAnnotations(context, aggregateIndex, source, annotations);\r\n    if (result != null) {\r\n        return result;\r\n    }\r\n    Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(source);\r\n    if (bridgedMethod != source) {\r\n        @Nullable\r\n        Annotation[] bridgedAnnotations = getDeclaredAnnotations(bridgedMethod, true);\r\n        for (int i = 0; i < bridgedAnnotations.length; i++) {\r\n            if (ObjectUtils.containsElement(annotations, bridgedAnnotations[i])) {\r\n                bridgedAnnotations[i] = null;\r\n            }\r\n        }\r\n        return processor.doWithAnnotations(context, aggregateIndex, source, bridgedAnnotations);\r\n    }\r\n    return null;\r\n}\n@Nullable\r\nprivate static <C, R> R processElement(C context, AnnotatedElement source, AnnotationsProcessor<C, R> processor) {\r\n    try {\r\n        R result = processor.doWithAggregate(context, 0);\r\n        return (result != null ? result : processor.doWithAnnotations(context, 0, source, getDeclaredAnnotations(source, false)));\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nstatic <A extends Annotation> A getDeclaredAnnotation(AnnotatedElement source, Class<A> annotationType) {\r\n    @Nullable\r\n    Annotation[] annotations = getDeclaredAnnotations(source, false);\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null && annotationType == annotation.annotationType()) {\r\n            return (A) annotation;\r\n        }\r\n    }\r\n    return null;\r\n}\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\n@Nullable\r\nstatic Annotation[] getDeclaredAnnotations(AnnotatedElement source, boolean defensive) {\r\n    boolean cached = false;\r\n    @Nullable\r\n    Annotation[] annotations = declaredAnnotationCache.get(source);\r\n    if (annotations != null) {\r\n        cached = true;\r\n    } else {\r\n        annotations = source.getDeclaredAnnotations();\r\n        if (annotations.length != 0) {\r\n            boolean allIgnored = true;\r\n            for (int i = 0; i < annotations.length; i++) {\r\n                Annotation annotation = annotations[i];\r\n                //noinspection DataFlowIssue\r\n                if (isIgnorable(annotation.annotationType()) || !AttributeMethods.forAnnotationType(annotation.annotationType()).canLoad(annotation)) {\r\n                    annotations[i] = null;\r\n                } else {\r\n                    allIgnored = false;\r\n                }\r\n            }\r\n            annotations = (allIgnored ? NO_ANNOTATIONS : annotations);\r\n            if (source instanceof Class || source instanceof Member) {\r\n                //noinspection NullableProblems\r\n                declaredAnnotationCache.put(source, annotations);\r\n                cached = true;\r\n            }\r\n        }\r\n    }\r\n    if (!defensive || annotations.length == 0 || !cached) {\r\n        return annotations;\r\n    }\r\n    return annotations.clone();\r\n}\nprivate static boolean isIgnorable(Class<?> annotationType) {\r\n    return AnnotationFilter.PLAIN.matches(annotationType);\r\n}\nstatic boolean isKnownEmpty(AnnotatedElement source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass) {\r\n    if (hasPlainJavaAnnotationsOnly(source)) {\r\n        return true;\r\n    }\r\n    if (searchStrategy == SearchStrategy.DIRECT || isWithoutHierarchy(source, searchEnclosingClass)) {\r\n        if (source instanceof Method method && method.isBridge()) {\r\n            return false;\r\n        }\r\n        return getDeclaredAnnotations(source, false).length == 0;\r\n    }\r\n    return false;\r\n}\nstatic boolean hasPlainJavaAnnotationsOnly(@Nullable Object annotatedElement) {\r\n    if (annotatedElement instanceof Class<?> clazz) {\r\n        return hasPlainJavaAnnotationsOnly(clazz);\r\n    } else if (annotatedElement instanceof Member member) {\r\n        return hasPlainJavaAnnotationsOnly(member.getDeclaringClass());\r\n    } else {\r\n        return false;\r\n    }\r\n}\nstatic boolean hasPlainJavaAnnotationsOnly(Class<?> type) {\r\n    return (type.getName().startsWith(\"java.\") || type == Ordered.class);\r\n}\nprivate static boolean isWithoutHierarchy(AnnotatedElement source, Predicate<Class<?>> searchEnclosingClass) {\r\n    if (source == Object.class) {\r\n        return true;\r\n    }\r\n    if (source instanceof Class<?> sourceClass) {\r\n        boolean noSuperTypes = (sourceClass.getSuperclass() == Object.class && sourceClass.getInterfaces().length == 0);\r\n        return (searchEnclosingClass.test(sourceClass) ? noSuperTypes && sourceClass.getEnclosingClass() == null : noSuperTypes);\r\n    }\r\n    if (source instanceof Method sourceMethod) {\r\n        return (Modifier.isPrivate(sourceMethod.getModifiers()) || isWithoutHierarchy(sourceMethod.getDeclaringClass(), searchEnclosingClass));\r\n    }\r\n    return true;\r\n}\nstatic void clearCache() {\r\n    declaredAnnotationCache.clear();\r\n    baseTypeMethodsCache.clear();\r\n}",
    "comment": "\n * Scanner to search for relevant annotations in the annotation hierarchy of an\n * {@link AnnotatedElement}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n * @see AnnotationsProcessor\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#scan(C,AnnotatedElement,SearchStrategy,Predicate<Class<?>>,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "/**\r\n * Scan the hierarchy of the specified element for relevant annotations and\r\n * call the processor as required.\r\n * @param context an optional context object that will be passed back to the\r\n * processor\r\n * @param source the source element to scan\r\n * @param searchStrategy the search strategy to use\r\n * @param searchEnclosingClass a predicate which evaluates to {@code true}\r\n * if a search should be performed on the enclosing class of the class\r\n * supplied to the predicate\r\n * @param processor the processor that receives the annotations\r\n * @return the result of {@link AnnotationsProcessor#finish(Object)}\r\n */\r\n@Nullable\r\nstatic <C, R> R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\r\n    R result = process(context, source, searchStrategy, searchEnclosingClass, processor);\r\n    return processor.finish(result);\r\n}",
    "comment": "\n\t * Scan the hierarchy of the specified element for relevant annotations and\n\t * call the processor as required.\n\t * @param context an optional context object that will be passed back to the\n\t * processor\n\t * @param source the source element to scan\n\t * @param searchStrategy the search strategy to use\n\t * @param searchEnclosingClass a predicate which evaluates to {@code true}\n\t * if a search should be performed on the enclosing class of the class\n\t * supplied to the predicate\n\t * @param processor the processor that receives the annotations\n\t * @return the result of {@link AnnotationsProcessor#finish(Object)}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#process(C,AnnotatedElement,SearchStrategy,Predicate<Class<?>>,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R process(C context, AnnotatedElement source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\r\n    if (source instanceof Class<?> clazz) {\r\n        return processClass(context, clazz, searchStrategy, searchEnclosingClass, processor);\r\n    }\r\n    if (source instanceof Method method) {\r\n        return processMethod(context, method, searchStrategy, processor);\r\n    }\r\n    return processElement(context, source, processor);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processClass(C,Class<?>,SearchStrategy,Predicate<Class<?>>,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processClass(C context, Class<?> source, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, AnnotationsProcessor<C, R> processor) {\r\n    return switch(searchStrategy) {\r\n        case DIRECT ->\r\n            processElement(context, source, processor);\r\n        case INHERITED_ANNOTATIONS ->\r\n            processClassInheritedAnnotations(context, source, processor);\r\n        case SUPERCLASS ->\r\n            processClassHierarchy(context, source, processor, false, Search.never);\r\n        case TYPE_HIERARCHY ->\r\n            processClassHierarchy(context, source, processor, true, searchEnclosingClass);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsScanner#processClassInheritedAnnotations(C,Class<?>,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <C, R> R processClassInheritedAnnotations(C context, Class<?> source, AnnotationsProcessor<C, R> processor) {\r\n    try {\r\n        if (isWithoutHierarchy(source, Search.never)) {\r\n            return processElement(context, source, processor);\r\n        }\r\n        @Nullable\r\n        Annotation[] relevant = null;\r\n        int remaining = Integer.MAX_VALUE;\r\n        int aggregateIndex = 0;\r\n        Class<?> root = source;\r\n        while (source != null && source != Object.class && remaining > 0 && !hasPlainJavaAnnotationsOnly(source)) {\r\n            R result = processor.doWithAggregate(context, aggregateIndex);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n            @Nullable\r\n            Annotation[] declaredAnns = getDeclaredAnnotations(source, true);\r\n            if (declaredAnns.length > 0) {\r\n                if (relevant == null) {\r\n                    relevant = root.getAnnotations();\r\n                    remaining = relevant.length;\r\n                }\r\n                for (int i = 0; i < declaredAnns.length; i++) {\r\n                    if (declaredAnns[i] != null) {\r\n                        boolean isRelevant = false;\r\n                        for (int relevantIndex = 0; relevantIndex < relevant.length; relevantIndex++) {\r\n                            //noinspection DataFlowIssue\r\n                            if (relevant[relevantIndex] != null && declaredAnns[i].annotationType() == relevant[relevantIndex].annotationType()) {\r\n                                isRelevant = true;\r\n                                relevant[relevantIndex] = null;\r\n                                remaining--;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!isRelevant) {\r\n                            declaredAnns[i] = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            result = processor.doWithAnnotations(context, aggregateIndex, source, declaredAnns);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n            source = source.getSuperclass();\r\n            aggregateIndex++;\r\n        }\r\n    } catch (Throwable ex) {\r\n        AnnotationUtils.handleIntrospectionFailure(source, ex);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  }
]