[
  {
    "entityId": "org.springframework.core.ReactiveAdapter",
    "entityType": "class",
    "code": "private final ReactiveTypeDescriptor descriptor;\nprivate final Function<Object, Publisher<?>> toPublisherFunction;\nprivate final Function<Publisher<?>, Object> fromPublisherFunction;\n/**\r\n * Constructor for an adapter with functions to convert the target reactive\r\n * or async type to and from a Reactive Streams Publisher.\r\n * @param descriptor the reactive type descriptor\r\n * @param toPublisherFunction adapter to a Publisher\r\n * @param fromPublisherFunction adapter from a Publisher\r\n */\r\npublic ReactiveAdapter(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toPublisherFunction, Function<Publisher<?>, Object> fromPublisherFunction) {\r\n    Assert.notNull(descriptor, \"'descriptor' is required\");\r\n    Assert.notNull(toPublisherFunction, \"'toPublisherFunction' is required\");\r\n    Assert.notNull(fromPublisherFunction, \"'fromPublisherFunction' is required\");\r\n    this.descriptor = descriptor;\r\n    this.toPublisherFunction = toPublisherFunction;\r\n    this.fromPublisherFunction = fromPublisherFunction;\r\n}\n/**\r\n * Return the descriptor of the reactive type for the adapter.\r\n */\r\npublic ReactiveTypeDescriptor getDescriptor() {\r\n    return this.descriptor;\r\n}\n/**\r\n * Shortcut for {@code getDescriptor().getReactiveType()}.\r\n */\r\npublic Class<?> getReactiveType() {\r\n    return getDescriptor().getReactiveType();\r\n}\n/**\r\n * Shortcut for {@code getDescriptor().isMultiValue()}.\r\n */\r\npublic boolean isMultiValue() {\r\n    return getDescriptor().isMultiValue();\r\n}\n/**\r\n * Shortcut for {@code getDescriptor().isNoValue()}.\r\n */\r\npublic boolean isNoValue() {\r\n    return getDescriptor().isNoValue();\r\n}\n/**\r\n * Shortcut for {@code getDescriptor().supportsEmpty()}.\r\n */\r\npublic boolean supportsEmpty() {\r\n    return getDescriptor().supportsEmpty();\r\n}\n/**\r\n * Adapt the given instance to a Reactive Streams {@code Publisher}.\r\n * @param source the source object to adapt from; if the given object is\r\n * {@code null}, {@link ReactiveTypeDescriptor#getEmptyValue()} is used.\r\n * @return the Publisher representing the adaptation\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> Publisher<T> toPublisher(@Nullable Object source) {\r\n    if (source == null) {\r\n        source = getDescriptor().getEmptyValue();\r\n    }\r\n    return (Publisher<T>) this.toPublisherFunction.apply(source);\r\n}\n/**\r\n * Adapt from the given Reactive Streams Publisher.\r\n * @param publisher the publisher to adapt from\r\n * @return the reactive type instance representing the adapted publisher\r\n */\r\npublic Object fromPublisher(Publisher<?> publisher) {\r\n    return this.fromPublisherFunction.apply(publisher);\r\n}",
    "comment": "\n * Adapter for a Reactive Streams {@link Publisher} to and from an async/reactive\n * type such as {@code CompletableFuture}, RxJava {@code Observable}, and others.\n *\n * <p>An adapter is typically obtained via {@link ReactiveAdapterRegistry}.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#getDescriptor()",
    "entityType": "method",
    "code": "/**\r\n * Return the descriptor of the reactive type for the adapter.\r\n */\r\npublic ReactiveTypeDescriptor getDescriptor() {\r\n    return this.descriptor;\r\n}",
    "comment": "\n\t * Return the descriptor of the reactive type for the adapter.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#getReactiveType()",
    "entityType": "method",
    "code": "/**\r\n * Shortcut for {@code getDescriptor().getReactiveType()}.\r\n */\r\npublic Class<?> getReactiveType() {\r\n    return getDescriptor().getReactiveType();\r\n}",
    "comment": "\n\t * Shortcut for {@code getDescriptor().getReactiveType()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#isMultiValue()",
    "entityType": "method",
    "code": "/**\r\n * Shortcut for {@code getDescriptor().isMultiValue()}.\r\n */\r\npublic boolean isMultiValue() {\r\n    return getDescriptor().isMultiValue();\r\n}",
    "comment": "\n\t * Shortcut for {@code getDescriptor().isMultiValue()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#isNoValue()",
    "entityType": "method",
    "code": "/**\r\n * Shortcut for {@code getDescriptor().isNoValue()}.\r\n */\r\npublic boolean isNoValue() {\r\n    return getDescriptor().isNoValue();\r\n}",
    "comment": "\n\t * Shortcut for {@code getDescriptor().isNoValue()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#supportsEmpty()",
    "entityType": "method",
    "code": "/**\r\n * Shortcut for {@code getDescriptor().supportsEmpty()}.\r\n */\r\npublic boolean supportsEmpty() {\r\n    return getDescriptor().supportsEmpty();\r\n}",
    "comment": "\n\t * Shortcut for {@code getDescriptor().supportsEmpty()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#toPublisher(Object)",
    "entityType": "method",
    "code": "/**\r\n * Adapt the given instance to a Reactive Streams {@code Publisher}.\r\n * @param source the source object to adapt from; if the given object is\r\n * {@code null}, {@link ReactiveTypeDescriptor#getEmptyValue()} is used.\r\n * @return the Publisher representing the adaptation\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> Publisher<T> toPublisher(@Nullable Object source) {\r\n    if (source == null) {\r\n        source = getDescriptor().getEmptyValue();\r\n    }\r\n    return (Publisher<T>) this.toPublisherFunction.apply(source);\r\n}",
    "comment": "\n\t * Adapt the given instance to a Reactive Streams {@code Publisher}.\n\t * @param source the source object to adapt from; if the given object is\n\t * {@code null}, {@link ReactiveTypeDescriptor#getEmptyValue()} is used.\n\t * @return the Publisher representing the adaptation\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapter#fromPublisher(Publisher<?>)",
    "entityType": "method",
    "code": "/**\r\n * Adapt from the given Reactive Streams Publisher.\r\n * @param publisher the publisher to adapt from\r\n * @return the reactive type instance representing the adapted publisher\r\n */\r\npublic Object fromPublisher(Publisher<?> publisher) {\r\n    return this.fromPublisherFunction.apply(publisher);\r\n}",
    "comment": "\n\t * Adapt from the given Reactive Streams Publisher.\n\t * @param publisher the publisher to adapt from\n\t * @return the reactive type instance representing the adapted publisher\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry",
    "entityType": "class",
    "code": "@Nullable\r\nprivate static volatile ReactiveAdapterRegistry sharedInstance;\nprivate static final boolean reactiveStreamsPresent;\nprivate static final boolean reactorPresent;\nprivate static final boolean rxjava3Present;\nprivate static final boolean kotlinCoroutinesPresent;\nprivate static final boolean mutinyPresent;\nstatic {\r\n    ClassLoader classLoader = ReactiveAdapterRegistry.class.getClassLoader();\r\n    reactiveStreamsPresent = ClassUtils.isPresent(\"org.reactivestreams.Publisher\", classLoader);\r\n    reactorPresent = ClassUtils.isPresent(\"reactor.core.publisher.Flux\", classLoader);\r\n    rxjava3Present = ClassUtils.isPresent(\"io.reactivex.rxjava3.core.Flowable\", classLoader);\r\n    kotlinCoroutinesPresent = ClassUtils.isPresent(\"kotlinx.coroutines.reactor.MonoKt\", classLoader);\r\n    mutinyPresent = ClassUtils.isPresent(\"io.smallrye.mutiny.Multi\", classLoader);\r\n}\nprivate final List<ReactiveAdapter> adapters = new ArrayList<>();\n/**\r\n * Create a registry and auto-register default adapters.\r\n * @see #getSharedInstance()\r\n */\r\npublic ReactiveAdapterRegistry() {\r\n    // Defensive guard for the Reactive Streams API itself\r\n    if (!reactiveStreamsPresent) {\r\n        return;\r\n    }\r\n    // Reactor\r\n    if (reactorPresent) {\r\n        new ReactorRegistrar().registerAdapters(this);\r\n    }\r\n    // RxJava\r\n    if (rxjava3Present) {\r\n        new RxJava3Registrar().registerAdapters(this);\r\n    }\r\n    // Kotlin Coroutines\r\n    if (reactorPresent && kotlinCoroutinesPresent) {\r\n        new CoroutinesRegistrar().registerAdapters(this);\r\n    }\r\n    // SmallRye Mutiny\r\n    if (mutinyPresent) {\r\n        new MutinyRegistrar().registerAdapters(this);\r\n    }\r\n    // Simple Flow.Publisher bridge if Reactor is not present\r\n    if (!reactorPresent) {\r\n        new FlowAdaptersRegistrar().registerAdapters(this);\r\n    }\r\n}\n/**\r\n * Register a reactive type along with functions to adapt to and from a\r\n * Reactive Streams {@link Publisher}. The function arguments assume that\r\n * their input is neither {@code null} nor {@link Optional}.\r\n * <p>This variant registers the new adapter after existing adapters.\r\n * It will be matched for the exact reactive type if no earlier adapter was\r\n * registered for the specific type, and it will be matched for assignability\r\n * in a second pass if no earlier adapter had an assignable type before.\r\n * @see #registerReactiveTypeOverride\r\n * @see #getAdapter\r\n */\r\npublic void registerReactiveType(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\r\n    this.adapters.add(buildAdapter(descriptor, toAdapter, fromAdapter));\r\n}\n/**\r\n * Register a reactive type along with functions to adapt to and from a\r\n * Reactive Streams {@link Publisher}. The function arguments assume that\r\n * their input is neither {@code null} nor {@link Optional}.\r\n * <p>This variant registers the new adapter first, effectively overriding\r\n * any previously registered adapters for the same reactive type. This allows\r\n * for overriding existing adapters, in particular default adapters.\r\n * <p>Note that existing adapters for specific types will still match before\r\n * an assignability match with the new adapter. In order to override all\r\n * existing matches, a new reactive type adapter needs to be registered\r\n * for every specific type, not relying on subtype assignability matches.\r\n * @since 5.3.30\r\n * @see #registerReactiveType\r\n * @see #getAdapter\r\n */\r\npublic void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\r\n    this.adapters.add(0, buildAdapter(descriptor, toAdapter, fromAdapter));\r\n}\nprivate ReactiveAdapter buildAdapter(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\r\n    return (reactorPresent ? new ReactorAdapter(descriptor, toAdapter, fromAdapter) : new ReactiveAdapter(descriptor, toAdapter, fromAdapter));\r\n}\n/**\r\n * Return whether the registry has any adapters.\r\n */\r\npublic boolean hasAdapters() {\r\n    return !this.adapters.isEmpty();\r\n}\n/**\r\n * Get the adapter for the given reactive type.\r\n * @return the corresponding adapter, or {@code null} if none available\r\n */\r\n@Nullable\r\npublic ReactiveAdapter getAdapter(Class<?> reactiveType) {\r\n    return getAdapter(reactiveType, null);\r\n}\n/**\r\n * Get the adapter for the given reactive type. Or if a \"source\" object is\r\n * provided, its actual type is used instead.\r\n * @param reactiveType the reactive type\r\n * (may be {@code null} if a concrete source object is given)\r\n * @param source an instance of the reactive type\r\n * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\r\n * @return the corresponding adapter, or {@code null} if none available\r\n */\r\n@Nullable\r\npublic ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\r\n    if (this.adapters.isEmpty()) {\r\n        return null;\r\n    }\r\n    Object sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\r\n    Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    for (ReactiveAdapter adapter : this.adapters) {\r\n        if (adapter.getReactiveType() == clazz) {\r\n            return adapter;\r\n        }\r\n    }\r\n    for (ReactiveAdapter adapter : this.adapters) {\r\n        if (adapter.getReactiveType().isAssignableFrom(clazz)) {\r\n            return adapter;\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * Return a shared default {@code ReactiveAdapterRegistry} instance,\r\n * lazily building it once needed.\r\n * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured\r\n * {@code ReactiveAdapterRegistry} instance for customization purposes.\r\n * This accessor is only meant as a fallback for code paths that want to\r\n * fall back on a default instance if one isn't provided.\r\n * @return the shared {@code ReactiveAdapterRegistry} instance\r\n * @since 5.0.2\r\n */\r\npublic static ReactiveAdapterRegistry getSharedInstance() {\r\n    ReactiveAdapterRegistry registry = sharedInstance;\r\n    if (registry == null) {\r\n        synchronized (ReactiveAdapterRegistry.class) {\r\n            registry = sharedInstance;\r\n            if (registry == null) {\r\n                registry = new ReactiveAdapterRegistry();\r\n                sharedInstance = registry;\r\n            }\r\n        }\r\n    }\r\n    return registry;\r\n}\n/**\r\n * ReactiveAdapter variant that wraps adapted Publishers as {@link Flux} or\r\n * {@link Mono} depending on {@link ReactiveTypeDescriptor#isMultiValue()}.\r\n * This is important in places where only the stream and stream element type\r\n * information is available like encoders and decoders.\r\n */\r\nprivate static class ReactorAdapter extends ReactiveAdapter {\r\n\r\n    ReactorAdapter(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toPublisherFunction, Function<Publisher<?>, Object> fromPublisherFunction) {\r\n        super(descriptor, toPublisherFunction, fromPublisherFunction);\r\n    }\r\n\r\n    @Override\r\n    public <T> Publisher<T> toPublisher(@Nullable Object source) {\r\n        Publisher<T> publisher = super.toPublisher(source);\r\n        return (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));\r\n    }\r\n}\nprivate static class ReactorRegistrar {\r\n\r\n    private static final Flow.Publisher<?> EMPTY_FLOW = JdkFlowAdapter.publisherToFlowPublisher(Flux.empty());\r\n\r\n    void registerAdapters(ReactiveAdapterRegistry registry) {\r\n        // Register Flux and Mono before Publisher...\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty), source -> (Mono<?>) source, Mono::from);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty), source -> (Flux<?>) source, Flux::from);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty), source -> (Publisher<?>) source, source -> source);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.nonDeferredAsyncValue(CompletionStage.class, EmptyCompletableFuture::new), source -> Mono.fromCompletionStage((CompletionStage<?>) source), source -> Mono.from(source).toFuture());\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_FLOW), source -> JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<?>) source), JdkFlowAdapter::publisherToFlowPublisher);\r\n    }\r\n}\nprivate static class EmptyCompletableFuture<T> extends CompletableFuture<T> {\r\n\r\n    EmptyCompletableFuture() {\r\n        complete(null);\r\n    }\r\n}\nprivate static class RxJava3Registrar {\r\n\r\n    void registerAdapters(ReactiveAdapterRegistry registry) {\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.rxjava3.core.Flowable.class, io.reactivex.rxjava3.core.Flowable::empty), source -> (io.reactivex.rxjava3.core.Flowable<?>) source, io.reactivex.rxjava3.core.Flowable::fromPublisher);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.rxjava3.core.Observable.class, io.reactivex.rxjava3.core.Observable::empty), source -> ((io.reactivex.rxjava3.core.Observable<?>) source).toFlowable(io.reactivex.rxjava3.core.BackpressureStrategy.BUFFER), io.reactivex.rxjava3.core.Observable::fromPublisher);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.singleRequiredValue(io.reactivex.rxjava3.core.Single.class), source -> ((io.reactivex.rxjava3.core.Single<?>) source).toFlowable(), io.reactivex.rxjava3.core.Single::fromPublisher);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(io.reactivex.rxjava3.core.Maybe.class, io.reactivex.rxjava3.core.Maybe::empty), source -> ((io.reactivex.rxjava3.core.Maybe<?>) source).toFlowable(), io.reactivex.rxjava3.core.Maybe::fromPublisher);\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.noValue(io.reactivex.rxjava3.core.Completable.class, io.reactivex.rxjava3.core.Completable::complete), source -> ((io.reactivex.rxjava3.core.Completable) source).toFlowable(), io.reactivex.rxjava3.core.Completable::fromPublisher);\r\n    }\r\n}\nprivate static class CoroutinesRegistrar {\r\n\r\n    @SuppressWarnings(\"KotlinInternalInJava\")\r\n    void registerAdapters(ReactiveAdapterRegistry registry) {\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(kotlinx.coroutines.Deferred.class, () -> kotlinx.coroutines.CompletableDeferredKt.CompletableDeferred(null)), source -> CoroutinesUtils.deferredToMono((kotlinx.coroutines.Deferred<?>) source), source -> CoroutinesUtils.monoToDeferred(Mono.from(source)));\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(kotlinx.coroutines.flow.Flow.class, kotlinx.coroutines.flow.FlowKt::emptyFlow), source -> kotlinx.coroutines.reactor.ReactorFlowKt.asFlux((kotlinx.coroutines.flow.Flow<?>) source), kotlinx.coroutines.reactive.ReactiveFlowKt::asFlow);\r\n    }\r\n}\nprivate static class MutinyRegistrar {\r\n\r\n    private static final Method uniToPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.UniConvert.class, \"toPublisher\");\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    void registerAdapters(ReactiveAdapterRegistry registry) {\r\n        ReactiveTypeDescriptor uniDesc = ReactiveTypeDescriptor.singleOptionalValue(io.smallrye.mutiny.Uni.class, () -> io.smallrye.mutiny.Uni.createFrom().nothing());\r\n        ReactiveTypeDescriptor multiDesc = ReactiveTypeDescriptor.multiValue(io.smallrye.mutiny.Multi.class, () -> io.smallrye.mutiny.Multi.createFrom().empty());\r\n        if (Flow.Publisher.class.isAssignableFrom(uniToPublisher.getReturnType())) {\r\n            // Mutiny 2 based on Flow.Publisher\r\n            Method uniPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.UniCreate.class, \"publisher\", Flow.Publisher.class);\r\n            Method multiPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.MultiCreate.class, \"publisher\", Flow.Publisher.class);\r\n            registry.registerReactiveType(uniDesc, uni -> FlowAdapters.toPublisher((Flow.Publisher<Object>) Objects.requireNonNull(ReflectionUtils.invokeMethod(uniToPublisher, ((Uni<?>) uni).convert()))), publisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(uniPublisher, Uni.createFrom(), FlowAdapters.toFlowPublisher(publisher))));\r\n            registry.registerReactiveType(multiDesc, multi -> FlowAdapters.toPublisher((Flow.Publisher<Object>) multi), publisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(multiPublisher, Multi.createFrom(), FlowAdapters.toFlowPublisher(publisher))));\r\n        } else {\r\n            // Mutiny 1 based on Reactive Streams\r\n            registry.registerReactiveType(uniDesc, uni -> ((io.smallrye.mutiny.Uni<?>) uni).convert().toPublisher(), publisher -> io.smallrye.mutiny.Uni.createFrom().publisher(publisher));\r\n            registry.registerReactiveType(multiDesc, multi -> (io.smallrye.mutiny.Multi<?>) multi, publisher -> io.smallrye.mutiny.Multi.createFrom().publisher(publisher));\r\n        }\r\n    }\r\n}\nprivate static class FlowAdaptersRegistrar {\r\n\r\n    private static final Flow.Subscription EMPTY_SUBSCRIPTION = new Flow.Subscription() {\r\n\r\n        @Override\r\n        public void request(long n) {\r\n        }\r\n\r\n        @Override\r\n        public void cancel() {\r\n        }\r\n    };\r\n\r\n    private static final Flow.Publisher<Object> EMPTY_PUBLISHER = subscriber -> {\r\n        subscriber.onSubscribe(EMPTY_SUBSCRIPTION);\r\n        subscriber.onComplete();\r\n    };\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    void registerAdapters(ReactiveAdapterRegistry registry) {\r\n        registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_PUBLISHER), source -> FlowAdapters.toPublisher((Flow.Publisher<Object>) source), source -> FlowAdapters.toFlowPublisher((Publisher<Object>) source));\r\n    }\r\n}\n/**\r\n * {@code BlockHoundIntegration} for spring-core classes.\r\n * Explicitly allows locking within {@link ConcurrentReferenceHashMap}.\r\n * @since 5.2.4\r\n */\r\npublic static class SpringCoreBlockHoundIntegration implements BlockHoundIntegration {\r\n\r\n    @Override\r\n    public void applyTo(BlockHound.Builder builder) {\r\n        // Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\r\n        String segmentClassName = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\r\n        builder.allowBlockingCallsInside(segmentClassName, \"doTask\");\r\n        builder.allowBlockingCallsInside(segmentClassName, \"clear\");\r\n        builder.allowBlockingCallsInside(segmentClassName, \"restructure\");\r\n        String referenceManagerClassName = \"org.springframework.util.ConcurrentReferenceHashMap$ReferenceManager\";\r\n        builder.allowBlockingCallsInside(referenceManagerClassName, \"pollForPurge\");\r\n    }\r\n}",
    "comment": "\n * A registry of adapters to adapt Reactive Streams {@link Publisher} to/from various\n * async/reactive types such as {@code CompletableFuture}, RxJava {@code Flowable}, etc.\n * This is designed to complement Spring's Reactor {@code Mono}/{@code Flux} support while\n * also being usable without Reactor, for example, just for {@code org.reactivestreams} bridging.\n *\n * <p>By default, depending on classpath availability, adapters are registered for Reactor\n * (including {@code CompletableFuture} and {@code Flow.Publisher} adapters), RxJava 3,\n * Kotlin Coroutines' {@code Deferred} (bridged via Reactor) and SmallRye Mutiny 1.x/2.x.\n * If Reactor is not present, a simple {@code Flow.Publisher} bridge will be registered.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Juergen Hoeller\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#registerReactiveType(ReactiveTypeDescriptor,Function<Object,Publisher<?>>,Function<Publisher<?>,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Register a reactive type along with functions to adapt to and from a\r\n * Reactive Streams {@link Publisher}. The function arguments assume that\r\n * their input is neither {@code null} nor {@link Optional}.\r\n * <p>This variant registers the new adapter after existing adapters.\r\n * It will be matched for the exact reactive type if no earlier adapter was\r\n * registered for the specific type, and it will be matched for assignability\r\n * in a second pass if no earlier adapter had an assignable type before.\r\n * @see #registerReactiveTypeOverride\r\n * @see #getAdapter\r\n */\r\npublic void registerReactiveType(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\r\n    this.adapters.add(buildAdapter(descriptor, toAdapter, fromAdapter));\r\n}",
    "comment": "\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter after existing adapters.\n\t * It will be matched for the exact reactive type if no earlier adapter was\n\t * registered for the specific type, and it will be matched for assignability\n\t * in a second pass if no earlier adapter had an assignable type before.\n\t * @see #registerReactiveTypeOverride\n\t * @see #getAdapter\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#registerReactiveTypeOverride(ReactiveTypeDescriptor,Function<Object,Publisher<?>>,Function<Publisher<?>,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Register a reactive type along with functions to adapt to and from a\r\n * Reactive Streams {@link Publisher}. The function arguments assume that\r\n * their input is neither {@code null} nor {@link Optional}.\r\n * <p>This variant registers the new adapter first, effectively overriding\r\n * any previously registered adapters for the same reactive type. This allows\r\n * for overriding existing adapters, in particular default adapters.\r\n * <p>Note that existing adapters for specific types will still match before\r\n * an assignability match with the new adapter. In order to override all\r\n * existing matches, a new reactive type adapter needs to be registered\r\n * for every specific type, not relying on subtype assignability matches.\r\n * @since 5.3.30\r\n * @see #registerReactiveType\r\n * @see #getAdapter\r\n */\r\npublic void registerReactiveTypeOverride(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\r\n    this.adapters.add(0, buildAdapter(descriptor, toAdapter, fromAdapter));\r\n}",
    "comment": "\n\t * Register a reactive type along with functions to adapt to and from a\n\t * Reactive Streams {@link Publisher}. The function arguments assume that\n\t * their input is neither {@code null} nor {@link Optional}.\n\t * <p>This variant registers the new adapter first, effectively overriding\n\t * any previously registered adapters for the same reactive type. This allows\n\t * for overriding existing adapters, in particular default adapters.\n\t * <p>Note that existing adapters for specific types will still match before\n\t * an assignability match with the new adapter. In order to override all\n\t * existing matches, a new reactive type adapter needs to be registered\n\t * for every specific type, not relying on subtype assignability matches.\n\t * @since 5.3.30\n\t * @see #registerReactiveType\n\t * @see #getAdapter\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#buildAdapter(ReactiveTypeDescriptor,Function<Object,Publisher<?>>,Function<Publisher<?>,Object>)",
    "entityType": "method",
    "code": "private ReactiveAdapter buildAdapter(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {\r\n    return (reactorPresent ? new ReactorAdapter(descriptor, toAdapter, fromAdapter) : new ReactiveAdapter(descriptor, toAdapter, fromAdapter));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#hasAdapters()",
    "entityType": "method",
    "code": "/**\r\n * Return whether the registry has any adapters.\r\n */\r\npublic boolean hasAdapters() {\r\n    return !this.adapters.isEmpty();\r\n}",
    "comment": "\n\t * Return whether the registry has any adapters.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#getAdapter(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Get the adapter for the given reactive type.\r\n * @return the corresponding adapter, or {@code null} if none available\r\n */\r\n@Nullable\r\npublic ReactiveAdapter getAdapter(Class<?> reactiveType) {\r\n    return getAdapter(reactiveType, null);\r\n}",
    "comment": "\n\t * Get the adapter for the given reactive type.\n\t * @return the corresponding adapter, or {@code null} if none available\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#getAdapter(Class<?>,Object)",
    "entityType": "method",
    "code": "/**\r\n * Get the adapter for the given reactive type. Or if a \"source\" object is\r\n * provided, its actual type is used instead.\r\n * @param reactiveType the reactive type\r\n * (may be {@code null} if a concrete source object is given)\r\n * @param source an instance of the reactive type\r\n * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\r\n * @return the corresponding adapter, or {@code null} if none available\r\n */\r\n@Nullable\r\npublic ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {\r\n    if (this.adapters.isEmpty()) {\r\n        return null;\r\n    }\r\n    Object sourceToUse = (source instanceof Optional<?> optional ? optional.orElse(null) : source);\r\n    Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    for (ReactiveAdapter adapter : this.adapters) {\r\n        if (adapter.getReactiveType() == clazz) {\r\n            return adapter;\r\n        }\r\n    }\r\n    for (ReactiveAdapter adapter : this.adapters) {\r\n        if (adapter.getReactiveType().isAssignableFrom(clazz)) {\r\n            return adapter;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Get the adapter for the given reactive type. Or if a \"source\" object is\n\t * provided, its actual type is used instead.\n\t * @param reactiveType the reactive type\n\t * (may be {@code null} if a concrete source object is given)\n\t * @param source an instance of the reactive type\n\t * (i.e. to adapt from; may be {@code null} if the reactive type is specified)\n\t * @return the corresponding adapter, or {@code null} if none available\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistry#getSharedInstance()",
    "entityType": "method",
    "code": "/**\r\n * Return a shared default {@code ReactiveAdapterRegistry} instance,\r\n * lazily building it once needed.\r\n * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured\r\n * {@code ReactiveAdapterRegistry} instance for customization purposes.\r\n * This accessor is only meant as a fallback for code paths that want to\r\n * fall back on a default instance if one isn't provided.\r\n * @return the shared {@code ReactiveAdapterRegistry} instance\r\n * @since 5.0.2\r\n */\r\npublic static ReactiveAdapterRegistry getSharedInstance() {\r\n    ReactiveAdapterRegistry registry = sharedInstance;\r\n    if (registry == null) {\r\n        synchronized (ReactiveAdapterRegistry.class) {\r\n            registry = sharedInstance;\r\n            if (registry == null) {\r\n                registry = new ReactiveAdapterRegistry();\r\n                sharedInstance = registry;\r\n            }\r\n        }\r\n    }\r\n    return registry;\r\n}",
    "comment": "\n\t * Return a shared default {@code ReactiveAdapterRegistry} instance,\n\t * lazily building it once needed.\n\t * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured\n\t * {@code ReactiveAdapterRegistry} instance for customization purposes.\n\t * This accessor is only meant as a fallback for code paths that want to\n\t * fall back on a default instance if one isn't provided.\n\t * @return the shared {@code ReactiveAdapterRegistry} instance\n\t * @since 5.0.2\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactorAdapter",
    "entityType": "class",
    "code": "ReactorAdapter(ReactiveTypeDescriptor descriptor, Function<Object, Publisher<?>> toPublisherFunction, Function<Publisher<?>, Object> fromPublisherFunction) {\r\n    super(descriptor, toPublisherFunction, fromPublisherFunction);\r\n}\n@Override\r\npublic <T> Publisher<T> toPublisher(@Nullable Object source) {\r\n    Publisher<T> publisher = super.toPublisher(source);\r\n    return (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));\r\n}",
    "comment": "\n\t * ReactiveAdapter variant that wraps adapted Publishers as {@link Flux} or\n\t * {@link Mono} depending on {@link ReactiveTypeDescriptor#isMultiValue()}.\n\t * This is important in places where only the stream and stream element type\n\t * information is available like encoders and decoders.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactorAdapter#toPublisher(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> Publisher<T> toPublisher(@Nullable Object source) {\r\n    Publisher<T> publisher = super.toPublisher(source);\r\n    return (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactorRegistrar",
    "entityType": "class",
    "code": "private static final Flow.Publisher<?> EMPTY_FLOW = JdkFlowAdapter.publisherToFlowPublisher(Flux.empty());\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    // Register Flux and Mono before Publisher...\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty), source -> (Mono<?>) source, Mono::from);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty), source -> (Flux<?>) source, Flux::from);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty), source -> (Publisher<?>) source, source -> source);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.nonDeferredAsyncValue(CompletionStage.class, EmptyCompletableFuture::new), source -> Mono.fromCompletionStage((CompletionStage<?>) source), source -> Mono.from(source).toFuture());\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_FLOW), source -> JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<?>) source), JdkFlowAdapter::publisherToFlowPublisher);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactorRegistrar#registerAdapters(ReactiveAdapterRegistry)",
    "entityType": "method",
    "code": "void registerAdapters(ReactiveAdapterRegistry registry) {\r\n    // Register Flux and Mono before Publisher...\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty), source -> (Mono<?>) source, Mono::from);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty), source -> (Flux<?>) source, Flux::from);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty), source -> (Publisher<?>) source, source -> source);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.nonDeferredAsyncValue(CompletionStage.class, EmptyCompletableFuture::new), source -> Mono.fromCompletionStage((CompletionStage<?>) source), source -> Mono.from(source).toFuture());\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_FLOW), source -> JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<?>) source), JdkFlowAdapter::publisherToFlowPublisher);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.EmptyCompletableFuture",
    "entityType": "class",
    "code": "EmptyCompletableFuture() {\r\n    complete(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3Registrar",
    "entityType": "class",
    "code": "void registerAdapters(ReactiveAdapterRegistry registry) {\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.rxjava3.core.Flowable.class, io.reactivex.rxjava3.core.Flowable::empty), source -> (io.reactivex.rxjava3.core.Flowable<?>) source, io.reactivex.rxjava3.core.Flowable::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.rxjava3.core.Observable.class, io.reactivex.rxjava3.core.Observable::empty), source -> ((io.reactivex.rxjava3.core.Observable<?>) source).toFlowable(io.reactivex.rxjava3.core.BackpressureStrategy.BUFFER), io.reactivex.rxjava3.core.Observable::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleRequiredValue(io.reactivex.rxjava3.core.Single.class), source -> ((io.reactivex.rxjava3.core.Single<?>) source).toFlowable(), io.reactivex.rxjava3.core.Single::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(io.reactivex.rxjava3.core.Maybe.class, io.reactivex.rxjava3.core.Maybe::empty), source -> ((io.reactivex.rxjava3.core.Maybe<?>) source).toFlowable(), io.reactivex.rxjava3.core.Maybe::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.noValue(io.reactivex.rxjava3.core.Completable.class, io.reactivex.rxjava3.core.Completable::complete), source -> ((io.reactivex.rxjava3.core.Completable) source).toFlowable(), io.reactivex.rxjava3.core.Completable::fromPublisher);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3Registrar#registerAdapters(ReactiveAdapterRegistry)",
    "entityType": "method",
    "code": "void registerAdapters(ReactiveAdapterRegistry registry) {\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.rxjava3.core.Flowable.class, io.reactivex.rxjava3.core.Flowable::empty), source -> (io.reactivex.rxjava3.core.Flowable<?>) source, io.reactivex.rxjava3.core.Flowable::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(io.reactivex.rxjava3.core.Observable.class, io.reactivex.rxjava3.core.Observable::empty), source -> ((io.reactivex.rxjava3.core.Observable<?>) source).toFlowable(io.reactivex.rxjava3.core.BackpressureStrategy.BUFFER), io.reactivex.rxjava3.core.Observable::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleRequiredValue(io.reactivex.rxjava3.core.Single.class), source -> ((io.reactivex.rxjava3.core.Single<?>) source).toFlowable(), io.reactivex.rxjava3.core.Single::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(io.reactivex.rxjava3.core.Maybe.class, io.reactivex.rxjava3.core.Maybe::empty), source -> ((io.reactivex.rxjava3.core.Maybe<?>) source).toFlowable(), io.reactivex.rxjava3.core.Maybe::fromPublisher);\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.noValue(io.reactivex.rxjava3.core.Completable.class, io.reactivex.rxjava3.core.Completable::complete), source -> ((io.reactivex.rxjava3.core.Completable) source).toFlowable(), io.reactivex.rxjava3.core.Completable::fromPublisher);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.CoroutinesRegistrar",
    "entityType": "class",
    "code": "@SuppressWarnings(\"KotlinInternalInJava\")\r\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(kotlinx.coroutines.Deferred.class, () -> kotlinx.coroutines.CompletableDeferredKt.CompletableDeferred(null)), source -> CoroutinesUtils.deferredToMono((kotlinx.coroutines.Deferred<?>) source), source -> CoroutinesUtils.monoToDeferred(Mono.from(source)));\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(kotlinx.coroutines.flow.Flow.class, kotlinx.coroutines.flow.FlowKt::emptyFlow), source -> kotlinx.coroutines.reactor.ReactorFlowKt.asFlux((kotlinx.coroutines.flow.Flow<?>) source), kotlinx.coroutines.reactive.ReactiveFlowKt::asFlow);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.CoroutinesRegistrar#registerAdapters(ReactiveAdapterRegistry)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"KotlinInternalInJava\")\r\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.singleOptionalValue(kotlinx.coroutines.Deferred.class, () -> kotlinx.coroutines.CompletableDeferredKt.CompletableDeferred(null)), source -> CoroutinesUtils.deferredToMono((kotlinx.coroutines.Deferred<?>) source), source -> CoroutinesUtils.monoToDeferred(Mono.from(source)));\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(kotlinx.coroutines.flow.Flow.class, kotlinx.coroutines.flow.FlowKt::emptyFlow), source -> kotlinx.coroutines.reactor.ReactorFlowKt.asFlux((kotlinx.coroutines.flow.Flow<?>) source), kotlinx.coroutines.reactive.ReactiveFlowKt::asFlow);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MutinyRegistrar",
    "entityType": "class",
    "code": "private static final Method uniToPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.UniConvert.class, \"toPublisher\");\n@SuppressWarnings(\"unchecked\")\r\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    ReactiveTypeDescriptor uniDesc = ReactiveTypeDescriptor.singleOptionalValue(io.smallrye.mutiny.Uni.class, () -> io.smallrye.mutiny.Uni.createFrom().nothing());\r\n    ReactiveTypeDescriptor multiDesc = ReactiveTypeDescriptor.multiValue(io.smallrye.mutiny.Multi.class, () -> io.smallrye.mutiny.Multi.createFrom().empty());\r\n    if (Flow.Publisher.class.isAssignableFrom(uniToPublisher.getReturnType())) {\r\n        // Mutiny 2 based on Flow.Publisher\r\n        Method uniPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.UniCreate.class, \"publisher\", Flow.Publisher.class);\r\n        Method multiPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.MultiCreate.class, \"publisher\", Flow.Publisher.class);\r\n        registry.registerReactiveType(uniDesc, uni -> FlowAdapters.toPublisher((Flow.Publisher<Object>) Objects.requireNonNull(ReflectionUtils.invokeMethod(uniToPublisher, ((Uni<?>) uni).convert()))), publisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(uniPublisher, Uni.createFrom(), FlowAdapters.toFlowPublisher(publisher))));\r\n        registry.registerReactiveType(multiDesc, multi -> FlowAdapters.toPublisher((Flow.Publisher<Object>) multi), publisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(multiPublisher, Multi.createFrom(), FlowAdapters.toFlowPublisher(publisher))));\r\n    } else {\r\n        // Mutiny 1 based on Reactive Streams\r\n        registry.registerReactiveType(uniDesc, uni -> ((io.smallrye.mutiny.Uni<?>) uni).convert().toPublisher(), publisher -> io.smallrye.mutiny.Uni.createFrom().publisher(publisher));\r\n        registry.registerReactiveType(multiDesc, multi -> (io.smallrye.mutiny.Multi<?>) multi, publisher -> io.smallrye.mutiny.Multi.createFrom().publisher(publisher));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MutinyRegistrar#registerAdapters(ReactiveAdapterRegistry)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    ReactiveTypeDescriptor uniDesc = ReactiveTypeDescriptor.singleOptionalValue(io.smallrye.mutiny.Uni.class, () -> io.smallrye.mutiny.Uni.createFrom().nothing());\r\n    ReactiveTypeDescriptor multiDesc = ReactiveTypeDescriptor.multiValue(io.smallrye.mutiny.Multi.class, () -> io.smallrye.mutiny.Multi.createFrom().empty());\r\n    if (Flow.Publisher.class.isAssignableFrom(uniToPublisher.getReturnType())) {\r\n        // Mutiny 2 based on Flow.Publisher\r\n        Method uniPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.UniCreate.class, \"publisher\", Flow.Publisher.class);\r\n        Method multiPublisher = ClassUtils.getMethod(io.smallrye.mutiny.groups.MultiCreate.class, \"publisher\", Flow.Publisher.class);\r\n        registry.registerReactiveType(uniDesc, uni -> FlowAdapters.toPublisher((Flow.Publisher<Object>) Objects.requireNonNull(ReflectionUtils.invokeMethod(uniToPublisher, ((Uni<?>) uni).convert()))), publisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(uniPublisher, Uni.createFrom(), FlowAdapters.toFlowPublisher(publisher))));\r\n        registry.registerReactiveType(multiDesc, multi -> FlowAdapters.toPublisher((Flow.Publisher<Object>) multi), publisher -> Objects.requireNonNull(ReflectionUtils.invokeMethod(multiPublisher, Multi.createFrom(), FlowAdapters.toFlowPublisher(publisher))));\r\n    } else {\r\n        // Mutiny 1 based on Reactive Streams\r\n        registry.registerReactiveType(uniDesc, uni -> ((io.smallrye.mutiny.Uni<?>) uni).convert().toPublisher(), publisher -> io.smallrye.mutiny.Uni.createFrom().publisher(publisher));\r\n        registry.registerReactiveType(multiDesc, multi -> (io.smallrye.mutiny.Multi<?>) multi, publisher -> io.smallrye.mutiny.Multi.createFrom().publisher(publisher));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FlowAdaptersRegistrar",
    "entityType": "class",
    "code": "private static final Flow.Subscription EMPTY_SUBSCRIPTION = new Flow.Subscription() {\r\n\r\n    @Override\r\n    public void request(long n) {\r\n    }\r\n\r\n    @Override\r\n    public void cancel() {\r\n    }\r\n};\nprivate static final Flow.Publisher<Object> EMPTY_PUBLISHER = subscriber -> {\r\n    subscriber.onSubscribe(EMPTY_SUBSCRIPTION);\r\n    subscriber.onComplete();\r\n};\n@SuppressWarnings(\"unchecked\")\r\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_PUBLISHER), source -> FlowAdapters.toPublisher((Flow.Publisher<Object>) source), source -> FlowAdapters.toFlowPublisher((Publisher<Object>) source));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.FlowAdaptersRegistrar#registerAdapters(ReactiveAdapterRegistry)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nvoid registerAdapters(ReactiveAdapterRegistry registry) {\r\n    registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(Flow.Publisher.class, () -> EMPTY_PUBLISHER), source -> FlowAdapters.toPublisher((Flow.Publisher<Object>) source), source -> FlowAdapters.toFlowPublisher((Publisher<Object>) source));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SpringCoreBlockHoundIntegration",
    "entityType": "class",
    "code": "@Override\r\npublic void applyTo(BlockHound.Builder builder) {\r\n    // Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\r\n    String segmentClassName = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\r\n    builder.allowBlockingCallsInside(segmentClassName, \"doTask\");\r\n    builder.allowBlockingCallsInside(segmentClassName, \"clear\");\r\n    builder.allowBlockingCallsInside(segmentClassName, \"restructure\");\r\n    String referenceManagerClassName = \"org.springframework.util.ConcurrentReferenceHashMap$ReferenceManager\";\r\n    builder.allowBlockingCallsInside(referenceManagerClassName, \"pollForPurge\");\r\n}",
    "comment": "\n\t * {@code BlockHoundIntegration} for spring-core classes.\n\t * Explicitly allows locking within {@link ConcurrentReferenceHashMap}.\n\t * @since 5.2.4\n\t "
  },
  {
    "entityId": "org.springframework.core.SpringCoreBlockHoundIntegration#applyTo(BlockHound.Builder)",
    "entityType": "method",
    "code": "@Override\r\npublic void applyTo(BlockHound.Builder builder) {\r\n    // Avoid hard references potentially anywhere in spring-core (no need for structural dependency)\r\n    String segmentClassName = \"org.springframework.util.ConcurrentReferenceHashMap$Segment\";\r\n    builder.allowBlockingCallsInside(segmentClassName, \"doTask\");\r\n    builder.allowBlockingCallsInside(segmentClassName, \"clear\");\r\n    builder.allowBlockingCallsInside(segmentClassName, \"restructure\");\r\n    String referenceManagerClassName = \"org.springframework.util.ConcurrentReferenceHashMap$ReferenceManager\";\r\n    builder.allowBlockingCallsInside(referenceManagerClassName, \"pollForPurge\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor",
    "entityType": "class",
    "code": "private final Class<?> reactiveType;\nprivate final boolean multiValue;\nprivate final boolean noValue;\n@Nullable\r\nprivate final Supplier<?> emptySupplier;\nprivate final boolean deferred;\nprivate ReactiveTypeDescriptor(Class<?> reactiveType, boolean multiValue, boolean noValue, @Nullable Supplier<?> emptySupplier) {\r\n    this(reactiveType, multiValue, noValue, emptySupplier, true);\r\n}\nprivate ReactiveTypeDescriptor(Class<?> reactiveType, boolean multiValue, boolean noValue, @Nullable Supplier<?> emptySupplier, boolean deferred) {\r\n    Assert.notNull(reactiveType, \"'reactiveType' must not be null\");\r\n    this.reactiveType = reactiveType;\r\n    this.multiValue = multiValue;\r\n    this.noValue = noValue;\r\n    this.emptySupplier = emptySupplier;\r\n    this.deferred = deferred;\r\n}\n/**\r\n * Return the reactive type for this descriptor.\r\n */\r\npublic Class<?> getReactiveType() {\r\n    return this.reactiveType;\r\n}\n/**\r\n * Return {@code true} if the reactive type can produce more than 1 value\r\n * can be produced and is therefore a good fit to adapt to {@code Flux}.\r\n * A {@code false} return value implies the reactive type can produce 1\r\n * value at most and is therefore a good fit to adapt to {@code Mono}.\r\n */\r\npublic boolean isMultiValue() {\r\n    return this.multiValue;\r\n}\n/**\r\n * Return {@code true} if the reactive type does not produce any values and\r\n * only provides completion and error signals.\r\n */\r\npublic boolean isNoValue() {\r\n    return this.noValue;\r\n}\n/**\r\n * Return {@code true} if the reactive type can complete with no values.\r\n */\r\npublic boolean supportsEmpty() {\r\n    return (this.emptySupplier != null);\r\n}\n/**\r\n * Return an empty-value instance for the underlying reactive or async type.\r\n * <p>Use of this type implies {@link #supportsEmpty()} is {@code true}.\r\n */\r\npublic Object getEmptyValue() {\r\n    Assert.state(this.emptySupplier != null, \"Empty values not supported\");\r\n    Object emptyValue = this.emptySupplier.get();\r\n    Assert.notNull(emptyValue, \"Invalid null return value from emptySupplier\");\r\n    return emptyValue;\r\n}\n/**\r\n * Whether the underlying operation is deferred and needs to be started\r\n * explicitly, for example, via subscribing (or similar), or whether it is triggered\r\n * without the consumer having any control.\r\n * @since 5.2.7\r\n */\r\npublic boolean isDeferred() {\r\n    return this.deferred;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    return this.reactiveType.equals(((ReactiveTypeDescriptor) other).reactiveType);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.reactiveType.hashCode();\r\n}\n/**\r\n * Descriptor for a reactive type that can produce {@code 0..N} values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor multiValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, true, false, emptySupplier);\r\n}\n/**\r\n * Descriptor for a reactive type that can produce 0..1 values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor singleOptionalValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, false, emptySupplier);\r\n}\n/**\r\n * Descriptor for a reactive type that must produce 1 value to complete.\r\n * @param type the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor singleRequiredValue(Class<?> type) {\r\n    return new ReactiveTypeDescriptor(type, false, false, null);\r\n}\n/**\r\n * Descriptor for a reactive type that does not produce any values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor noValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, true, emptySupplier);\r\n}\n/**\r\n * The same as {@link #singleOptionalValue(Class, Supplier)} but for a\r\n * non-deferred, async type such as {@link java.util.concurrent.CompletableFuture}.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n * @since 5.2.7\r\n */\r\npublic static ReactiveTypeDescriptor nonDeferredAsyncValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, false, emptySupplier, false);\r\n}",
    "comment": "\n * Describes the semantics of a reactive type including boolean checks for\n * {@link #isMultiValue()}, {@link #isNoValue()}, and {@link #supportsEmpty()}.\n *\n * @author Rossen Stoyanchev\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#getReactiveType()",
    "entityType": "method",
    "code": "/**\r\n * Return the reactive type for this descriptor.\r\n */\r\npublic Class<?> getReactiveType() {\r\n    return this.reactiveType;\r\n}",
    "comment": "\n\t * Return the reactive type for this descriptor.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#isMultiValue()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the reactive type can produce more than 1 value\r\n * can be produced and is therefore a good fit to adapt to {@code Flux}.\r\n * A {@code false} return value implies the reactive type can produce 1\r\n * value at most and is therefore a good fit to adapt to {@code Mono}.\r\n */\r\npublic boolean isMultiValue() {\r\n    return this.multiValue;\r\n}",
    "comment": "\n\t * Return {@code true} if the reactive type can produce more than 1 value\n\t * can be produced and is therefore a good fit to adapt to {@code Flux}.\n\t * A {@code false} return value implies the reactive type can produce 1\n\t * value at most and is therefore a good fit to adapt to {@code Mono}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#isNoValue()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the reactive type does not produce any values and\r\n * only provides completion and error signals.\r\n */\r\npublic boolean isNoValue() {\r\n    return this.noValue;\r\n}",
    "comment": "\n\t * Return {@code true} if the reactive type does not produce any values and\n\t * only provides completion and error signals.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#supportsEmpty()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the reactive type can complete with no values.\r\n */\r\npublic boolean supportsEmpty() {\r\n    return (this.emptySupplier != null);\r\n}",
    "comment": "\n\t * Return {@code true} if the reactive type can complete with no values.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#getEmptyValue()",
    "entityType": "method",
    "code": "/**\r\n * Return an empty-value instance for the underlying reactive or async type.\r\n * <p>Use of this type implies {@link #supportsEmpty()} is {@code true}.\r\n */\r\npublic Object getEmptyValue() {\r\n    Assert.state(this.emptySupplier != null, \"Empty values not supported\");\r\n    Object emptyValue = this.emptySupplier.get();\r\n    Assert.notNull(emptyValue, \"Invalid null return value from emptySupplier\");\r\n    return emptyValue;\r\n}",
    "comment": "\n\t * Return an empty-value instance for the underlying reactive or async type.\n\t * <p>Use of this type implies {@link #supportsEmpty()} is {@code true}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#isDeferred()",
    "entityType": "method",
    "code": "/**\r\n * Whether the underlying operation is deferred and needs to be started\r\n * explicitly, for example, via subscribing (or similar), or whether it is triggered\r\n * without the consumer having any control.\r\n * @since 5.2.7\r\n */\r\npublic boolean isDeferred() {\r\n    return this.deferred;\r\n}",
    "comment": "\n\t * Whether the underlying operation is deferred and needs to be started\n\t * explicitly, for example, via subscribing (or similar), or whether it is triggered\n\t * without the consumer having any control.\n\t * @since 5.2.7\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    return this.reactiveType.equals(((ReactiveTypeDescriptor) other).reactiveType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.reactiveType.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#multiValue(Class<?>,Supplier<?>)",
    "entityType": "method",
    "code": "/**\r\n * Descriptor for a reactive type that can produce {@code 0..N} values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor multiValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, true, false, emptySupplier);\r\n}",
    "comment": "\n\t * Descriptor for a reactive type that can produce {@code 0..N} values.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#singleOptionalValue(Class<?>,Supplier<?>)",
    "entityType": "method",
    "code": "/**\r\n * Descriptor for a reactive type that can produce 0..1 values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor singleOptionalValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, false, emptySupplier);\r\n}",
    "comment": "\n\t * Descriptor for a reactive type that can produce 0..1 values.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#singleRequiredValue(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Descriptor for a reactive type that must produce 1 value to complete.\r\n * @param type the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor singleRequiredValue(Class<?> type) {\r\n    return new ReactiveTypeDescriptor(type, false, false, null);\r\n}",
    "comment": "\n\t * Descriptor for a reactive type that must produce 1 value to complete.\n\t * @param type the reactive type\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#noValue(Class<?>,Supplier<?>)",
    "entityType": "method",
    "code": "/**\r\n * Descriptor for a reactive type that does not produce any values.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n */\r\npublic static ReactiveTypeDescriptor noValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, true, emptySupplier);\r\n}",
    "comment": "\n\t * Descriptor for a reactive type that does not produce any values.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t "
  },
  {
    "entityId": "org.springframework.core.ReactiveTypeDescriptor#nonDeferredAsyncValue(Class<?>,Supplier<?>)",
    "entityType": "method",
    "code": "/**\r\n * The same as {@link #singleOptionalValue(Class, Supplier)} but for a\r\n * non-deferred, async type such as {@link java.util.concurrent.CompletableFuture}.\r\n * @param type the reactive type\r\n * @param emptySupplier a supplier of an empty-value instance of the reactive type\r\n * @since 5.2.7\r\n */\r\npublic static ReactiveTypeDescriptor nonDeferredAsyncValue(Class<?> type, Supplier<?> emptySupplier) {\r\n    return new ReactiveTypeDescriptor(type, false, false, emptySupplier, false);\r\n}",
    "comment": "\n\t * The same as {@link #singleOptionalValue(Class, Supplier)} but for a\n\t * non-deferred, async type such as {@link java.util.concurrent.CompletableFuture}.\n\t * @param type the reactive type\n\t * @param emptySupplier a supplier of an empty-value instance of the reactive type\n\t * @since 5.2.7\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType",
    "entityType": "class",
    "code": "/**\r\n * {@code ResolvableType} returned when no value is available. {@code NONE} is used\r\n * in preference to {@code null} so that multiple method calls can be safely chained.\r\n */\r\npublic static final ResolvableType NONE = new ResolvableType(EmptyType.INSTANCE, null, null, 0);\nprivate static final ResolvableType[] EMPTY_TYPES_ARRAY = new ResolvableType[0];\nprivate static final ConcurrentReferenceHashMap<ResolvableType, ResolvableType> cache = new ConcurrentReferenceHashMap<>(256);\n/**\r\n * The underlying Java type being managed.\r\n */\r\nprivate final Type type;\n/**\r\n * The component type for an array or {@code null} if the type should be deduced.\r\n */\r\n@Nullable\r\nprivate final ResolvableType componentType;\n/**\r\n * Optional provider for the type.\r\n */\r\n@Nullable\r\nprivate final TypeProvider typeProvider;\n/**\r\n * The {@code VariableResolver} to use or {@code null} if no resolver is available.\r\n */\r\n@Nullable\r\nprivate final VariableResolver variableResolver;\n@Nullable\r\nprivate final Integer hash;\n@Nullable\r\nprivate Class<?> resolved;\n@Nullable\r\nprivate volatile ResolvableType superType;\nprivate volatile ResolvableType @Nullable [] interfaces;\nprivate volatile ResolvableType @Nullable [] generics;\n@Nullable\r\nprivate volatile Boolean unresolvableGenerics;\n/**\r\n * Private constructor used to create a new {@code ResolvableType} for cache key purposes,\r\n * with no upfront resolution.\r\n */\r\nprivate ResolvableType(Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\r\n    this.type = type;\r\n    this.componentType = null;\r\n    this.typeProvider = typeProvider;\r\n    this.variableResolver = variableResolver;\r\n    this.hash = calculateHashCode();\r\n    this.resolved = null;\r\n}\n/**\r\n * Private constructor used to create a new {@code ResolvableType} for cache value purposes,\r\n * with upfront resolution and a pre-calculated hash.\r\n * @since 4.2\r\n */\r\nprivate ResolvableType(Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver, @Nullable Integer hash) {\r\n    this.type = type;\r\n    this.componentType = null;\r\n    this.typeProvider = typeProvider;\r\n    this.variableResolver = variableResolver;\r\n    this.hash = hash;\r\n    this.resolved = resolveClass();\r\n}\n/**\r\n * Private constructor used to create a new {@code ResolvableType} for uncached purposes,\r\n * with upfront resolution but lazily calculated hash.\r\n */\r\nprivate ResolvableType(Type type, @Nullable ResolvableType componentType, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\r\n    this.type = type;\r\n    this.componentType = componentType;\r\n    this.typeProvider = typeProvider;\r\n    this.variableResolver = variableResolver;\r\n    this.hash = null;\r\n    this.resolved = resolveClass();\r\n}\n/**\r\n * Private constructor used to create a new {@code ResolvableType} on a {@link Class} basis.\r\n * <p>Avoids all {@code instanceof} checks in order to create a straight {@link Class} wrapper.\r\n * @since 4.2\r\n */\r\nprivate ResolvableType(@Nullable Class<?> clazz) {\r\n    this.resolved = (clazz != null ? clazz : Object.class);\r\n    this.type = this.resolved;\r\n    this.componentType = null;\r\n    this.typeProvider = null;\r\n    this.variableResolver = null;\r\n    this.hash = null;\r\n}\n/**\r\n * Return the underling Java {@link Type} being managed.\r\n */\r\npublic Type getType() {\r\n    return SerializableTypeWrapper.unwrap(this.type);\r\n}\n/**\r\n * Return the underlying Java {@link Class} being managed, if available;\r\n * otherwise {@code null}.\r\n */\r\n@Nullable\r\npublic Class<?> getRawClass() {\r\n    if (this.type == this.resolved) {\r\n        return this.resolved;\r\n    }\r\n    Type rawType = this.type;\r\n    if (rawType instanceof ParameterizedType parameterizedType) {\r\n        rawType = parameterizedType.getRawType();\r\n    }\r\n    return (rawType instanceof Class<?> rawClass ? rawClass : null);\r\n}\n/**\r\n * Return the underlying source of the resolvable type. Will return a {@link Field},\r\n * {@link MethodParameter} or {@link Type} depending on how the {@code ResolvableType}\r\n * was constructed. This method is primarily to provide access to additional type\r\n * information or meta-data that alternative JVM languages may provide.\r\n */\r\npublic Object getSource() {\r\n    Object source = (this.typeProvider != null ? this.typeProvider.getSource() : null);\r\n    return (source != null ? source : this.type);\r\n}\n/**\r\n * Return this type as a resolved {@code Class}, falling back to\r\n * {@link java.lang.Object} if no specific class can be resolved.\r\n * @return the resolved {@link Class} or the {@code Object} fallback\r\n * @since 5.1\r\n * @see #getRawClass()\r\n * @see #resolve(Class)\r\n */\r\npublic Class<?> toClass() {\r\n    return resolve(Object.class);\r\n}\n/**\r\n * Determine whether the given object is an instance of this {@code ResolvableType}.\r\n * @param obj the object to check\r\n * @since 4.2\r\n * @see #isAssignableFrom(Class)\r\n */\r\npublic boolean isInstance(@Nullable Object obj) {\r\n    return (obj != null && isAssignableFrom(obj.getClass()));\r\n}\n/**\r\n * Determine whether this {@code ResolvableType} is assignable from the\r\n * specified other type.\r\n * @param other the type to be checked against (as a {@code Class})\r\n * @since 4.2\r\n * @see #isAssignableFrom(ResolvableType)\r\n */\r\npublic boolean isAssignableFrom(Class<?> other) {\r\n    // As of 6.1: shortcut assignability check for top-level Class references\r\n    return (this.type instanceof Class<?> clazz ? ClassUtils.isAssignable(clazz, other) : isAssignableFrom(forClass(other), false, null, false));\r\n}\n/**\r\n * Determine whether this {@code ResolvableType} is assignable from the\r\n * specified other type.\r\n * <p>Attempts to follow the same rules as the Java compiler, considering\r\n * whether both the {@link #resolve() resolved} {@code Class} is\r\n * {@link Class#isAssignableFrom(Class) assignable from} the given type\r\n * as well as whether all {@link #getGenerics() generics} are assignable.\r\n * @param other the type to be checked against (as a {@code ResolvableType})\r\n * @return {@code true} if the specified other type can be assigned to this\r\n * {@code ResolvableType}; {@code false} otherwise\r\n */\r\npublic boolean isAssignableFrom(ResolvableType other) {\r\n    return isAssignableFrom(other, false, null, false);\r\n}\n/**\r\n * Determine whether this {@code ResolvableType} is assignable from the\r\n * specified other type, as far as the other type is actually resolvable.\r\n * @param other the type to be checked against (as a {@code ResolvableType})\r\n * @return {@code true} if the specified other type can be assigned to this\r\n * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\r\n * @since 6.2\r\n */\r\npublic boolean isAssignableFromResolvedPart(ResolvableType other) {\r\n    return isAssignableFrom(other, false, null, true);\r\n}\nprivate boolean isAssignableFrom(ResolvableType other, boolean strict, @Nullable Map<Type, Type> matchedBefore, boolean upUntilUnresolvable) {\r\n    Assert.notNull(other, \"ResolvableType must not be null\");\r\n    // If we cannot resolve types, we are not assignable\r\n    if (this == NONE || other == NONE) {\r\n        return false;\r\n    }\r\n    if (matchedBefore != null) {\r\n        if (matchedBefore.get(this.type) == other.type) {\r\n            return true;\r\n        }\r\n    } else {\r\n        // As of 6.1: shortcut assignability check for top-level Class references\r\n        if (this.type instanceof Class<?> clazz && other.type instanceof Class<?> otherClazz) {\r\n            return (strict ? clazz.isAssignableFrom(otherClazz) : ClassUtils.isAssignable(clazz, otherClazz));\r\n        }\r\n    }\r\n    if (upUntilUnresolvable && (other.isUnresolvableTypeVariable() || other.isWildcardWithoutBounds())) {\r\n        return true;\r\n    }\r\n    // Deal with array by delegating to the component type\r\n    if (isArray()) {\r\n        return (other.isArray() && getComponentType().isAssignableFrom(other.getComponentType(), true, matchedBefore, upUntilUnresolvable));\r\n    }\r\n    // Deal with wildcard bounds\r\n    WildcardBounds ourBounds = WildcardBounds.get(this);\r\n    WildcardBounds otherBounds = WildcardBounds.get(other);\r\n    // In the form X is assignable to <? extends Number>\r\n    if (otherBounds != null) {\r\n        if (ourBounds != null) {\r\n            return (ourBounds.isSameKind(otherBounds) && ourBounds.isAssignableFrom(otherBounds.getBounds(), matchedBefore));\r\n        } else if (upUntilUnresolvable) {\r\n            return otherBounds.isAssignableFrom(this, matchedBefore);\r\n        } else if (!strict) {\r\n            return (matchedBefore != null ? otherBounds.equalsType(this) : otherBounds.isAssignableTo(this, matchedBefore));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    // In the form <? extends Number> is assignable to X...\r\n    if (ourBounds != null) {\r\n        return ourBounds.isAssignableFrom(other, matchedBefore);\r\n    }\r\n    // Main assignability check about to follow\r\n    boolean exactMatch = (strict && matchedBefore != null);\r\n    boolean checkGenerics = true;\r\n    Class<?> ourResolved = null;\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        // Try default variable resolution\r\n        if (this.variableResolver != null) {\r\n            ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n            if (resolved != null) {\r\n                ourResolved = resolved.resolve();\r\n            }\r\n        }\r\n        if (ourResolved == null) {\r\n            // Try variable resolution against target type\r\n            if (other.variableResolver != null) {\r\n                ResolvableType resolved = other.variableResolver.resolveVariable(variable);\r\n                if (resolved != null) {\r\n                    ourResolved = resolved.resolve();\r\n                    checkGenerics = false;\r\n                }\r\n            }\r\n        }\r\n        if (ourResolved == null) {\r\n            // Unresolved type variable, potentially nested -> never insist on exact match\r\n            exactMatch = false;\r\n        }\r\n    }\r\n    if (ourResolved == null) {\r\n        ourResolved = toClass();\r\n    }\r\n    Class<?> otherResolved = other.toClass();\r\n    // We need an exact type match for generics\r\n    // List<CharSequence> is not assignable from List<String>\r\n    if (exactMatch ? !ourResolved.equals(otherResolved) : (strict ? !ourResolved.isAssignableFrom(otherResolved) : !ClassUtils.isAssignable(ourResolved, otherResolved))) {\r\n        return false;\r\n    }\r\n    if (checkGenerics) {\r\n        // Recursively check each generic\r\n        ResolvableType[] ourGenerics = getGenerics();\r\n        ResolvableType[] otherGenerics = other.as(ourResolved).getGenerics();\r\n        if (ourGenerics.length != otherGenerics.length) {\r\n            return false;\r\n        }\r\n        if (ourGenerics.length > 0) {\r\n            if (matchedBefore == null) {\r\n                matchedBefore = new IdentityHashMap<>(1);\r\n            }\r\n            matchedBefore.put(this.type, other.type);\r\n            for (int i = 0; i < ourGenerics.length; i++) {\r\n                ResolvableType otherGeneric = otherGenerics[i];\r\n                if (!ourGenerics[i].isAssignableFrom(otherGeneric, !otherGeneric.isUnresolvableTypeVariable(), matchedBefore, upUntilUnresolvable)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Return {@code true} if this type resolves to a Class that represents an array.\r\n * @see #getComponentType()\r\n */\r\npublic boolean isArray() {\r\n    if (this == NONE) {\r\n        return false;\r\n    }\r\n    return ((this.type instanceof Class<?> clazz && clazz.isArray()) || this.type instanceof GenericArrayType || resolveType().isArray());\r\n}\n/**\r\n * Return the ResolvableType representing the component type of the array or\r\n * {@link #NONE} if this type does not represent an array.\r\n * @see #isArray()\r\n */\r\npublic ResolvableType getComponentType() {\r\n    if (this == NONE) {\r\n        return NONE;\r\n    }\r\n    if (this.componentType != null) {\r\n        return this.componentType;\r\n    }\r\n    if (this.type instanceof Class<?> clazz) {\r\n        Class<?> componentType = clazz.componentType();\r\n        return forType(componentType, this.variableResolver);\r\n    }\r\n    if (this.type instanceof GenericArrayType genericArrayType) {\r\n        return forType(genericArrayType.getGenericComponentType(), this.variableResolver);\r\n    }\r\n    return resolveType().getComponentType();\r\n}\n/**\r\n * Convenience method to return this type as a resolvable {@link Collection} type.\r\n * <p>Returns {@link #NONE} if this type does not implement or extend\r\n * {@link Collection}.\r\n * @see #as(Class)\r\n * @see #asMap()\r\n */\r\npublic ResolvableType asCollection() {\r\n    return as(Collection.class);\r\n}\n/**\r\n * Convenience method to return this type as a resolvable {@link Map} type.\r\n * <p>Returns {@link #NONE} if this type does not implement or extend\r\n * {@link Map}.\r\n * @see #as(Class)\r\n * @see #asCollection()\r\n */\r\npublic ResolvableType asMap() {\r\n    return as(Map.class);\r\n}\n/**\r\n * Return this type as a {@code ResolvableType} of the specified class. Searches\r\n * {@link #getSuperType() supertype} and {@link #getInterfaces() interface}\r\n * hierarchies to find a match, returning {@link #NONE} if this type does not\r\n * implement or extend the specified class.\r\n * @param type the required type (typically narrowed)\r\n * @return a {@code ResolvableType} representing this object as the specified\r\n * type, or {@link #NONE} if not resolvable as that type\r\n * @see #asCollection()\r\n * @see #asMap()\r\n * @see #getSuperType()\r\n * @see #getInterfaces()\r\n */\r\npublic ResolvableType as(Class<?> type) {\r\n    if (this == NONE) {\r\n        return NONE;\r\n    }\r\n    Class<?> resolved = resolve();\r\n    if (resolved == null || resolved == type) {\r\n        return this;\r\n    }\r\n    for (ResolvableType interfaceType : getInterfaces()) {\r\n        ResolvableType interfaceAsType = interfaceType.as(type);\r\n        if (interfaceAsType != NONE) {\r\n            return interfaceAsType;\r\n        }\r\n    }\r\n    return getSuperType().as(type);\r\n}\n/**\r\n * Return a {@code ResolvableType} representing the direct supertype of this type.\r\n * <p>If no supertype is available this method returns {@link #NONE}.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @see #getInterfaces()\r\n */\r\npublic ResolvableType getSuperType() {\r\n    Class<?> resolved = resolve();\r\n    if (resolved == null) {\r\n        return NONE;\r\n    }\r\n    try {\r\n        Type superclass = resolved.getGenericSuperclass();\r\n        if (superclass == null) {\r\n            return NONE;\r\n        }\r\n        ResolvableType superType = this.superType;\r\n        if (superType == null) {\r\n            superType = forType(superclass, this);\r\n            this.superType = superType;\r\n        }\r\n        return superType;\r\n    } catch (TypeNotPresentException ex) {\r\n        // Ignore non-present types in generic signature\r\n        return NONE;\r\n    }\r\n}\n/**\r\n * Return a {@code ResolvableType} array representing the direct interfaces\r\n * implemented by this type. If this type does not implement any interfaces an\r\n * empty array is returned.\r\n * <p>Note: The resulting {@code ResolvableType} instances may not be {@link Serializable}.\r\n * @see #getSuperType()\r\n */\r\npublic ResolvableType[] getInterfaces() {\r\n    Class<?> resolved = resolve();\r\n    if (resolved == null) {\r\n        return EMPTY_TYPES_ARRAY;\r\n    }\r\n    ResolvableType[] interfaces = this.interfaces;\r\n    if (interfaces == null) {\r\n        Type[] genericIfcs = resolved.getGenericInterfaces();\r\n        if (genericIfcs.length > 0) {\r\n            interfaces = new ResolvableType[genericIfcs.length];\r\n            for (int i = 0; i < genericIfcs.length; i++) {\r\n                interfaces[i] = forType(genericIfcs[i], this);\r\n            }\r\n        } else {\r\n            interfaces = EMPTY_TYPES_ARRAY;\r\n        }\r\n        this.interfaces = interfaces;\r\n    }\r\n    return interfaces;\r\n}\n/**\r\n * Return {@code true} if this type contains generic parameters.\r\n * @see #getGeneric(int...)\r\n * @see #getGenerics()\r\n */\r\npublic boolean hasGenerics() {\r\n    return (getGenerics().length > 0);\r\n}\n/**\r\n * Return {@code true} if this type contains at least a generic type\r\n * that is resolved. In other words, this returns {@code false} if\r\n * the type contains unresolvable generics only, that is, no substitute\r\n * for any of its declared type variables.\r\n * @since 6.2\r\n */\r\npublic boolean hasResolvableGenerics() {\r\n    if (this == NONE) {\r\n        return false;\r\n    }\r\n    ResolvableType[] generics = getGenerics();\r\n    for (ResolvableType generic : generics) {\r\n        if (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Determine whether the underlying type has any unresolvable generics:\r\n * either through an unresolvable type variable on the type itself\r\n * or through implementing a generic interface in a raw fashion,\r\n * i.e. without substituting that interface's type variables.\r\n * The result will be {@code true} only in those two scenarios.\r\n */\r\npublic boolean hasUnresolvableGenerics() {\r\n    if (this == NONE) {\r\n        return false;\r\n    }\r\n    return hasUnresolvableGenerics(null);\r\n}\nprivate boolean hasUnresolvableGenerics(@Nullable Set<Type> alreadySeen) {\r\n    Boolean unresolvableGenerics = this.unresolvableGenerics;\r\n    if (unresolvableGenerics == null) {\r\n        unresolvableGenerics = determineUnresolvableGenerics(alreadySeen);\r\n        this.unresolvableGenerics = unresolvableGenerics;\r\n    }\r\n    return unresolvableGenerics;\r\n}\nprivate boolean determineUnresolvableGenerics(@Nullable Set<Type> alreadySeen) {\r\n    if (alreadySeen != null && alreadySeen.contains(this.type)) {\r\n        // Self-referencing generic -> not unresolvable\r\n        return false;\r\n    }\r\n    ResolvableType[] generics = getGenerics();\r\n    for (ResolvableType generic : generics) {\r\n        if (generic.isUnresolvableTypeVariable() || generic.isWildcardWithoutBounds() || generic.hasUnresolvableGenerics(currentTypeSeen(alreadySeen))) {\r\n            return true;\r\n        }\r\n    }\r\n    Class<?> resolved = resolve();\r\n    if (resolved != null) {\r\n        try {\r\n            for (Type genericInterface : resolved.getGenericInterfaces()) {\r\n                if (genericInterface instanceof Class<?> clazz) {\r\n                    if (clazz.getTypeParameters().length > 0) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        } catch (TypeNotPresentException ex) {\r\n            // Ignore non-present types in generic signature\r\n        }\r\n        Class<?> superclass = resolved.getSuperclass();\r\n        if (superclass != null && superclass != Object.class) {\r\n            return getSuperType().hasUnresolvableGenerics(currentTypeSeen(alreadySeen));\r\n        }\r\n    }\r\n    return false;\r\n}\nprivate Set<Type> currentTypeSeen(@Nullable Set<Type> alreadySeen) {\r\n    if (alreadySeen == null) {\r\n        alreadySeen = new HashSet<>(4);\r\n    }\r\n    alreadySeen.add(this.type);\r\n    return alreadySeen;\r\n}\n/**\r\n * Determine whether the underlying type is a type variable that\r\n * cannot be resolved through the associated variable resolver.\r\n */\r\nprivate boolean isUnresolvableTypeVariable() {\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        if (this.variableResolver == null) {\r\n            return true;\r\n        }\r\n        ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n        if (resolved == null || resolved.isUnresolvableTypeVariable() || resolved.isWildcardWithoutBounds()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Determine whether the underlying type represents a wildcard\r\n * without specific bounds (i.e., equal to {@code ? extends Object}).\r\n */\r\nprivate boolean isWildcardWithoutBounds() {\r\n    if (this.type instanceof WildcardType wildcardType) {\r\n        if (wildcardType.getLowerBounds().length == 0) {\r\n            Type[] upperBounds = wildcardType.getUpperBounds();\r\n            if (upperBounds.length == 0 || (upperBounds.length == 1 && Object.class == upperBounds[0])) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified nesting level.\r\n * <p>See {@link #getNested(int, Map)} for details.\r\n * @param nestingLevel the nesting level\r\n * @return the {@code ResolvableType} type, or {@code #NONE}\r\n */\r\npublic ResolvableType getNested(int nestingLevel) {\r\n    return getNested(nestingLevel, null);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified nesting level.\r\n * <p>The nesting level refers to the specific generic parameter that should be returned.\r\n * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\r\n * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\r\n * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\r\n * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\r\n * for the given level. For example, an index of 0 would refer to a {@code Map} key;\r\n * whereas, 1 would refer to the value. If the map does not contain a value for a\r\n * specific level the last generic will be used (for example, a {@code Map} value).\r\n * <p>Nesting levels may also apply to array types; for example given\r\n * {@code String[]}, a nesting level of 2 refers to {@code String}.\r\n * <p>If a type does not {@link #hasGenerics() contain} generics the\r\n * {@link #getSuperType() supertype} hierarchy will be considered.\r\n * @param nestingLevel the required nesting level, indexed from 1 for the\r\n * current type, 2 for the first nested generic, 3 for the second and so on\r\n * @param typeIndexesPerLevel a map containing the generic index for a given\r\n * nesting level (can be {@code null})\r\n * @return a {@code ResolvableType} for the nested level, or {@link #NONE}\r\n */\r\npublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\r\n    ResolvableType result = this;\r\n    for (int i = 2; i <= nestingLevel; i++) {\r\n        if (result.isArray()) {\r\n            result = result.getComponentType();\r\n        } else {\r\n            // Handle derived types\r\n            while (result != ResolvableType.NONE && !result.hasGenerics()) {\r\n                result = result.getSuperType();\r\n            }\r\n            Integer index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\r\n            index = (index == null ? result.getGenerics().length - 1 : index);\r\n            result = result.getGeneric(index);\r\n        }\r\n    }\r\n    return result;\r\n}\n/**\r\n * Return a {@code ResolvableType} representing the generic parameter for the\r\n * given indexes. Indexes are zero based; for example given the type\r\n * {@code Map<Integer, List<String>>}, {@code getGeneric(0)} will access the\r\n * {@code Integer}. Nested generics can be accessed by specifying multiple indexes;\r\n * for example {@code getGeneric(1, 0)} will access the {@code String} from the\r\n * nested {@code List}. For convenience, if no indexes are specified the first\r\n * generic is returned.\r\n * <p>If no generic is available at the specified indexes {@link #NONE} is returned.\r\n * @param indexes the indexes that refer to the generic parameter\r\n * (can be omitted to return the first generic)\r\n * @return a {@code ResolvableType} for the specified generic, or {@link #NONE}\r\n * @see #hasGenerics()\r\n * @see #getGenerics()\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\npublic ResolvableType getGeneric(int@Nullable ... indexes) {\r\n    ResolvableType[] generics = getGenerics();\r\n    if (indexes == null || indexes.length == 0) {\r\n        return (generics.length == 0 ? NONE : generics[0]);\r\n    }\r\n    ResolvableType generic = this;\r\n    for (int index : indexes) {\r\n        generics = generic.getGenerics();\r\n        if (index < 0 || index >= generics.length) {\r\n            return NONE;\r\n        }\r\n        generic = generics[index];\r\n    }\r\n    return generic;\r\n}\n/**\r\n * Return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters of\r\n * this type. If no generics are available an empty array is returned. If you need to\r\n * access a specific generic consider using the {@link #getGeneric(int...)} method as\r\n * it allows access to nested generics and protects against\r\n * {@code IndexOutOfBoundsExceptions}.\r\n * @return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters\r\n * (never {@code null})\r\n * @see #hasGenerics()\r\n * @see #getGeneric(int...)\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\npublic ResolvableType[] getGenerics() {\r\n    if (this == NONE) {\r\n        return EMPTY_TYPES_ARRAY;\r\n    }\r\n    ResolvableType[] generics = this.generics;\r\n    if (generics == null) {\r\n        if (this.type instanceof Class<?> clazz) {\r\n            Type[] typeParams = clazz.getTypeParameters();\r\n            if (typeParams.length > 0) {\r\n                generics = new ResolvableType[typeParams.length];\r\n                for (int i = 0; i < generics.length; i++) {\r\n                    generics[i] = ResolvableType.forType(typeParams[i], this);\r\n                }\r\n            } else {\r\n                generics = EMPTY_TYPES_ARRAY;\r\n            }\r\n        } else if (this.type instanceof ParameterizedType parameterizedType) {\r\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\r\n            if (actualTypeArguments.length > 0) {\r\n                generics = new ResolvableType[actualTypeArguments.length];\r\n                for (int i = 0; i < actualTypeArguments.length; i++) {\r\n                    generics[i] = forType(actualTypeArguments[i], this.variableResolver);\r\n                }\r\n            } else {\r\n                generics = EMPTY_TYPES_ARRAY;\r\n            }\r\n        } else {\r\n            generics = resolveType().getGenerics();\r\n        }\r\n        this.generics = generics;\r\n    }\r\n    return generics;\r\n}\n/**\r\n * Convenience method that will {@link #getGenerics() get} and\r\n * {@link #resolve() resolve} generic parameters.\r\n * @return an array of resolved generic parameters (the resulting array\r\n * will never be {@code null}, but it may contain {@code null} elements)\r\n * @see #getGenerics()\r\n * @see #resolve()\r\n */\r\n@Nullable\r\npublic Class<?>[] resolveGenerics() {\r\n    ResolvableType[] generics = getGenerics();\r\n    @Nullable\r\n    Class<?>[] resolvedGenerics = new Class<?>[generics.length];\r\n    for (int i = 0; i < generics.length; i++) {\r\n        resolvedGenerics[i] = generics[i].resolve();\r\n    }\r\n    return resolvedGenerics;\r\n}\n/**\r\n * Convenience method that will {@link #getGenerics() get} and {@link #resolve()\r\n * resolve} generic parameters, using the specified {@code fallback} if any type\r\n * cannot be resolved.\r\n * @param fallback the fallback class to use if resolution fails\r\n * @return an array of resolved generic parameters\r\n * @see #getGenerics()\r\n * @see #resolve()\r\n */\r\npublic Class<?>[] resolveGenerics(Class<?> fallback) {\r\n    ResolvableType[] generics = getGenerics();\r\n    Class<?>[] resolvedGenerics = new Class<?>[generics.length];\r\n    for (int i = 0; i < generics.length; i++) {\r\n        resolvedGenerics[i] = generics[i].resolve(fallback);\r\n    }\r\n    return resolvedGenerics;\r\n}\n/**\r\n * Convenience method that will {@link #getGeneric(int...) get} and\r\n * {@link #resolve() resolve} a specific generic parameter.\r\n * @param indexes the indexes that refer to the generic parameter\r\n * (can be omitted to return the first generic)\r\n * @return a resolved {@link Class} or {@code null}\r\n * @see #getGeneric(int...)\r\n * @see #resolve()\r\n */\r\n@Nullable\r\npublic Class<?> resolveGeneric(int... indexes) {\r\n    return getGeneric(indexes).resolve();\r\n}\n/**\r\n * Resolve this type to a {@link java.lang.Class}, returning {@code null}\r\n * if the type cannot be resolved. This method will consider bounds of\r\n * {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\r\n * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\r\n * <p>If this method returns a non-null {@code Class} and {@link #hasGenerics()}\r\n * returns {@code false}, the given type effectively wraps a plain {@code Class},\r\n * allowing for plain {@code Class} processing if desirable.\r\n * @return the resolved {@link Class}, or {@code null} if not resolvable\r\n * @see #resolve(Class)\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\n@Nullable\r\npublic Class<?> resolve() {\r\n    return this.resolved;\r\n}\n/**\r\n * Resolve this type to a {@link java.lang.Class}, returning the specified\r\n * {@code fallback} if the type cannot be resolved. This method will consider bounds\r\n * of {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\r\n * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\r\n * @param fallback the fallback class to use if resolution fails\r\n * @return the resolved {@link Class} or the {@code fallback}\r\n * @see #resolve()\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\npublic Class<?> resolve(Class<?> fallback) {\r\n    return (this.resolved != null ? this.resolved : fallback);\r\n}\n@Nullable\r\nprivate Class<?> resolveClass() {\r\n    if (this.type == EmptyType.INSTANCE) {\r\n        return null;\r\n    }\r\n    if (this.type instanceof Class<?> clazz) {\r\n        return clazz;\r\n    }\r\n    if (this.type instanceof GenericArrayType) {\r\n        Class<?> resolvedComponent = getComponentType().resolve();\r\n        return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);\r\n    }\r\n    return resolveType().resolve();\r\n}\n/**\r\n * Resolve this type by a single level, returning the resolved value or {@link #NONE}.\r\n * <p>Note: The returned {@code ResolvableType} should only be used as an intermediary\r\n * as it cannot be serialized.\r\n */\r\nResolvableType resolveType() {\r\n    if (this.type instanceof ParameterizedType parameterizedType) {\r\n        return forType(parameterizedType.getRawType(), this.variableResolver);\r\n    }\r\n    if (this.type instanceof WildcardType wildcardType) {\r\n        Type resolved = resolveBounds(wildcardType.getUpperBounds());\r\n        if (resolved == null) {\r\n            resolved = resolveBounds(wildcardType.getLowerBounds());\r\n        }\r\n        return forType(resolved, this.variableResolver);\r\n    }\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        // Try default variable resolution\r\n        if (this.variableResolver != null) {\r\n            ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n            if (resolved != null) {\r\n                return resolved;\r\n            }\r\n        }\r\n        // Fallback to bounds\r\n        return forType(resolveBounds(variable.getBounds()), this.variableResolver);\r\n    }\r\n    return NONE;\r\n}\n@Nullable\r\nprivate ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    if (this.type instanceof TypeVariable) {\r\n        return resolveType().resolveVariable(variable);\r\n    }\r\n    if (this.type instanceof ParameterizedType parameterizedType) {\r\n        Class<?> resolved = resolve();\r\n        if (resolved == null) {\r\n            return null;\r\n        }\r\n        TypeVariable<?>[] variables = resolved.getTypeParameters();\r\n        for (int i = 0; i < variables.length; i++) {\r\n            if (ObjectUtils.nullSafeEquals(variables[i].getName(), variable.getName())) {\r\n                Type actualType = parameterizedType.getActualTypeArguments()[i];\r\n                return forType(actualType, this.variableResolver);\r\n            }\r\n        }\r\n        Type ownerType = parameterizedType.getOwnerType();\r\n        if (ownerType != null) {\r\n            return forType(ownerType, this.variableResolver).resolveVariable(variable);\r\n        }\r\n    }\r\n    if (this.type instanceof WildcardType) {\r\n        ResolvableType resolved = resolveType().resolveVariable(variable);\r\n        if (resolved != null) {\r\n            return resolved;\r\n        }\r\n    }\r\n    if (this.variableResolver != null) {\r\n        return this.variableResolver.resolveVariable(variable);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Check for full equality of all type resolution artifacts:\r\n * type as well as {@code TypeProvider} and {@code VariableResolver}.\r\n * @see #equalsType(ResolvableType)\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || other.getClass() != getClass()) {\r\n        return false;\r\n    }\r\n    ResolvableType otherType = (ResolvableType) other;\r\n    if (!equalsType(otherType)) {\r\n        return false;\r\n    }\r\n    if (this.typeProvider != otherType.typeProvider && (this.typeProvider == null || otherType.typeProvider == null || !ObjectUtils.nullSafeEquals(this.typeProvider.getType(), otherType.typeProvider.getType()))) {\r\n        return false;\r\n    }\r\n    if (this.variableResolver != otherType.variableResolver && (this.variableResolver == null || otherType.variableResolver == null || !ObjectUtils.nullSafeEquals(this.variableResolver.getSource(), otherType.variableResolver.getSource()))) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n/**\r\n * Check for type-level equality with another {@code ResolvableType}.\r\n * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\r\n * this works between different sources as well, for example, method parameters and return types.\r\n * @param otherType the {@code ResolvableType} to match against\r\n * @return whether the declared type and type variables match\r\n * @since 6.1\r\n */\r\npublic boolean equalsType(ResolvableType otherType) {\r\n    return (ObjectUtils.nullSafeEquals(this.type, otherType.type) && ObjectUtils.nullSafeEquals(this.componentType, otherType.componentType));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return (this.hash != null ? this.hash : calculateHashCode());\r\n}\nprivate int calculateHashCode() {\r\n    int hashCode = ObjectUtils.nullSafeHashCode(this.type);\r\n    if (this.componentType != null) {\r\n        hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.componentType);\r\n    }\r\n    if (this.typeProvider != null) {\r\n        hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.typeProvider.getType());\r\n    }\r\n    if (this.variableResolver != null) {\r\n        hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.variableResolver.getSource());\r\n    }\r\n    return hashCode;\r\n}\n/**\r\n * Adapts this {@code ResolvableType} to a {@link VariableResolver}.\r\n */\r\n@Nullable\r\nVariableResolver asVariableResolver() {\r\n    if (this == NONE) {\r\n        return null;\r\n    }\r\n    return new DefaultVariableResolver(this);\r\n}\n/**\r\n * Custom serialization support for {@link #NONE}.\r\n */\r\nprivate Object readResolve() {\r\n    return (this.type == EmptyType.INSTANCE ? NONE : this);\r\n}\n/**\r\n * Return a String representation of this type in its fully resolved form\r\n * (including any generic parameters).\r\n */\r\n@Override\r\npublic String toString() {\r\n    if (isArray()) {\r\n        return getComponentType() + \"[]\";\r\n    }\r\n    if (this.resolved == null) {\r\n        return \"?\";\r\n    }\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        if (this.variableResolver == null || this.variableResolver.resolveVariable(variable) == null) {\r\n            // Don't bother with variable boundaries for toString()...\r\n            // Can cause infinite recursions in case of self-references\r\n            return \"?\";\r\n        }\r\n    }\r\n    if (hasGenerics()) {\r\n        return this.resolved.getName() + '<' + StringUtils.arrayToDelimitedString(getGenerics(), \", \") + '>';\r\n    }\r\n    return this.resolved.getName();\r\n}\n// Factory methods\r\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Class},\r\n * using the full generic type information for assignability checks.\r\n * <p>For example: {@code ResolvableType.forClass(MyArrayList.class)}.\r\n * @param clazz the class to introspect ({@code null} is semantically\r\n * equivalent to {@code Object.class} for typical use cases here)\r\n * @return a {@code ResolvableType} for the specified class\r\n * @see #forClass(Class, Class)\r\n * @see #forClassWithGenerics(Class, Class...)\r\n */\r\npublic static ResolvableType forClass(@Nullable Class<?> clazz) {\r\n    return new ResolvableType(clazz);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Class},\r\n * doing assignability checks against the raw class only (analogous to\r\n * {@link Class#isAssignableFrom}, which this serves as a wrapper for).\r\n * <p>For example: {@code ResolvableType.forRawClass(List.class)}.\r\n * @param clazz the class to introspect ({@code null} is semantically\r\n * equivalent to {@code Object.class} for typical use cases here)\r\n * @return a {@code ResolvableType} for the specified class\r\n * @since 4.2\r\n * @see #forClass(Class)\r\n * @see #getRawClass()\r\n */\r\npublic static ResolvableType forRawClass(@Nullable Class<?> clazz) {\r\n    return new ResolvableType(clazz) {\r\n\r\n        @Override\r\n        public ResolvableType[] getGenerics() {\r\n            return EMPTY_TYPES_ARRAY;\r\n        }\r\n\r\n        @Override\r\n        public boolean isAssignableFrom(Class<?> other) {\r\n            return (clazz == null || ClassUtils.isAssignable(clazz, other));\r\n        }\r\n\r\n        @Override\r\n        public boolean isAssignableFrom(ResolvableType other) {\r\n            Class<?> otherClass = other.resolve();\r\n            return (otherClass != null && (clazz == null || ClassUtils.isAssignable(clazz, otherClass)));\r\n        }\r\n    };\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified base type\r\n * (interface or base class) with a given implementation class.\r\n * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\r\n * @param baseType the base type (must not be {@code null})\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified base type backed by the\r\n * given implementation class\r\n * @see #forClass(Class)\r\n * @see #forClassWithGenerics(Class, Class...)\r\n */\r\npublic static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {\r\n    Assert.notNull(baseType, \"Base type must not be null\");\r\n    ResolvableType asType = forType(implementationClass).as(baseType);\r\n    return (asType == NONE ? forType(baseType) : asType);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\r\n * @param clazz the class (or interface) to introspect\r\n * @param generics the generics of the class\r\n * @return a {@code ResolvableType} for the specific class and generics\r\n * @see #forClassWithGenerics(Class, ResolvableType...)\r\n */\r\npublic static ResolvableType forClassWithGenerics(Class<?> clazz, Class<?>... generics) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(generics, \"Generics array must not be null\");\r\n    ResolvableType[] resolvableGenerics = new ResolvableType[generics.length];\r\n    for (int i = 0; i < generics.length; i++) {\r\n        resolvableGenerics[i] = forClass(generics[i]);\r\n    }\r\n    return forClassWithGenerics(clazz, resolvableGenerics);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\r\n * @param clazz the class (or interface) to introspect\r\n * @param generics the generics of the class\r\n * @return a {@code ResolvableType} for the specific class and generics\r\n * @see #forClassWithGenerics(Class, Class...)\r\n */\r\npublic static ResolvableType forClassWithGenerics(Class<?> clazz, @Nullable ResolvableType@Nullable ... generics) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    TypeVariable<?>[] variables = clazz.getTypeParameters();\r\n    if (generics != null) {\r\n        Assert.isTrue(variables.length == generics.length, () -> \"Mismatched number of generics specified for \" + clazz.toGenericString());\r\n    }\r\n    Type[] arguments = new Type[variables.length];\r\n    for (int i = 0; i < variables.length; i++) {\r\n        ResolvableType generic = (generics != null ? generics[i] : null);\r\n        Type argument = (generic != null ? generic.getType() : null);\r\n        arguments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);\r\n    }\r\n    return forType(new SyntheticParameterizedType(clazz, arguments), (generics != null ? new TypeVariablesVariableResolver(variables, generics) : null));\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified instance. The instance does not\r\n * convey generic information but if it implements {@link ResolvableTypeProvider} a\r\n * more precise {@code ResolvableType} can be used than the simple one based on\r\n * the {@link #forClass(Class) Class instance}.\r\n * @param instance the instance (possibly {@code null})\r\n * @return a {@code ResolvableType} for the specified instance,\r\n * or {@code NONE} for {@code null}\r\n * @since 4.2\r\n * @see ResolvableTypeProvider\r\n */\r\npublic static ResolvableType forInstance(@Nullable Object instance) {\r\n    if (instance instanceof ResolvableTypeProvider resolvableTypeProvider) {\r\n        ResolvableType type = resolvableTypeProvider.getResolvableType();\r\n        if (type != null) {\r\n            return type;\r\n        }\r\n    }\r\n    return (instance != null ? forClass(instance.getClass()) : NONE);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Field}.\r\n * @param field the source field\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field, Class)\r\n */\r\npublic static ResolvableType forField(Field field) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    return forType(null, new FieldTypeProvider(field), null);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with a given\r\n * implementation.\r\n * <p>Use this variant when the class that declares the field includes generic\r\n * parameter variables that are satisfied by the implementation class.\r\n * @param field the source field\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, Class<?> implementationClass) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\r\n    return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with a given\r\n * implementation.\r\n * <p>Use this variant when the class that declares the field includes generic\r\n * parameter variables that are satisfied by the implementation type.\r\n * @param field the source field\r\n * @param implementationType the implementation type\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    ResolvableType owner = (implementationType != null ? implementationType : NONE);\r\n    owner = owner.as(field.getDeclaringClass());\r\n    return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with the\r\n * given nesting level.\r\n * @param field the source field\r\n * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\r\n * generic type; etc)\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, int nestingLevel) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    return forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with a given\r\n * implementation and the given nesting level.\r\n * <p>Use this variant when the class that declares the field includes generic\r\n * parameter variables that are satisfied by the implementation class.\r\n * @param field the source field\r\n * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\r\n * generic type; etc)\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\r\n    return forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Constructor} parameter.\r\n * @param constructor the source constructor (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @return a {@code ResolvableType} for the specified constructor parameter\r\n * @see #forConstructorParameter(Constructor, int, Class)\r\n */\r\npublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {\r\n    Assert.notNull(constructor, \"Constructor must not be null\");\r\n    return forMethodParameter(new MethodParameter(constructor, parameterIndex));\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Constructor} parameter\r\n * with a given implementation. Use this variant when the class that declares the\r\n * constructor includes generic parameter variables that are satisfied by the\r\n * implementation class.\r\n * @param constructor the source constructor (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified constructor parameter\r\n * @see #forConstructorParameter(Constructor, int)\r\n */\r\npublic static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex, Class<?> implementationClass) {\r\n    Assert.notNull(constructor, \"Constructor must not be null\");\r\n    MethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);\r\n    return forMethodParameter(methodParameter);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} return type.\r\n * @param method the source for the method return type\r\n * @return a {@code ResolvableType} for the specified method return\r\n * @see #forMethodReturnType(Method, Class)\r\n */\r\npublic static ResolvableType forMethodReturnType(Method method) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return forMethodParameter(new MethodParameter(method, -1));\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} return type.\r\n * <p>Use this variant when the class that declares the method includes generic\r\n * parameter variables that are satisfied by the implementation class.\r\n * @param method the source for the method return type\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified method return\r\n * @see #forMethodReturnType(Method)\r\n */\r\npublic static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    MethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);\r\n    return forMethodParameter(methodParameter);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} parameter.\r\n * @param method the source method (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int, Class)\r\n * @see #forMethodParameter(MethodParameter)\r\n */\r\npublic static ResolvableType forMethodParameter(Method method, int parameterIndex) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    return forMethodParameter(new MethodParameter(method, parameterIndex));\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Method} parameter with a\r\n * given implementation. Use this variant when the class that declares the method\r\n * includes generic parameter variables that are satisfied by the implementation class.\r\n * @param method the source method (must not be {@code null})\r\n * @param parameterIndex the parameter index\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int, Class)\r\n * @see #forMethodParameter(MethodParameter)\r\n */\r\npublic static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    MethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);\r\n    return forMethodParameter(methodParameter);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter}.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int)\r\n */\r\npublic static ResolvableType forMethodParameter(MethodParameter methodParameter) {\r\n    return forMethodParameter(methodParameter, (Type) null);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter} with a\r\n * given implementation type. Use this variant when the class that declares the method\r\n * includes generic parameter variables that are satisfied by the implementation type.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @param implementationType the implementation type\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(MethodParameter)\r\n */\r\npublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable ResolvableType implementationType) {\r\n    Assert.notNull(methodParameter, \"MethodParameter must not be null\");\r\n    implementationType = (implementationType != null ? implementationType : forType(methodParameter.getContainingClass()));\r\n    ResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\r\n    return forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter},\r\n * overriding the target type to resolve with a specific given type.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @param targetType the type to resolve (a part of the method parameter's type)\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @see #forMethodParameter(Method, int)\r\n */\r\npublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\r\n    Assert.notNull(methodParameter, \"MethodParameter must not be null\");\r\n    return forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link MethodParameter} at\r\n * a specific nesting level, overriding the target type to resolve with a specific\r\n * given type.\r\n * @param methodParameter the source method parameter (must not be {@code null})\r\n * @param targetType the type to resolve (a part of the method parameter's type)\r\n * @param nestingLevel the nesting level to use\r\n * @return a {@code ResolvableType} for the specified method parameter\r\n * @since 5.2\r\n * @see #forMethodParameter(Method, int)\r\n */\r\nstatic ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType, int nestingLevel) {\r\n    ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());\r\n    return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).getNested(nestingLevel, methodParameter.typeIndexesPerLevel);\r\n}\n/**\r\n * Return a {@code ResolvableType} as an array of the specified {@code componentType}.\r\n * @param componentType the component type\r\n * @return a {@code ResolvableType} as an array of the specified component type\r\n */\r\npublic static ResolvableType forArrayComponent(ResolvableType componentType) {\r\n    Assert.notNull(componentType, \"Component type must not be null\");\r\n    Class<?> arrayType = componentType.toClass().arrayType();\r\n    return new ResolvableType(arrayType, componentType, null, null);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the bounds of the specified {@link TypeVariable}.\r\n * @param typeVariable the type variable\r\n * @return a {@code ResolvableType} for the specified bounds\r\n * @since 6.2.3\r\n */\r\nstatic ResolvableType forVariableBounds(TypeVariable<?> typeVariable) {\r\n    return forType(resolveBounds(typeVariable.getBounds()));\r\n}\n@Nullable\r\nprivate static Type resolveBounds(Type[] bounds) {\r\n    if (bounds.length == 0 || bounds[0] == Object.class) {\r\n        return null;\r\n    }\r\n    return bounds[0];\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Type}.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @param type the source type (potentially {@code null})\r\n * @return a {@code ResolvableType} for the specified {@link Type}\r\n * @see #forType(Type, ResolvableType)\r\n */\r\npublic static ResolvableType forType(@Nullable Type type) {\r\n    return forType(type, null, null);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Type} backed by the given\r\n * owner type.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @param type the source type or {@code null}\r\n * @param owner the owner type used to resolve variables\r\n * @return a {@code ResolvableType} for the specified {@link Type} and owner\r\n * @see #forType(Type)\r\n */\r\npublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\r\n    VariableResolver variableResolver = null;\r\n    if (owner != null) {\r\n        variableResolver = owner.asVariableResolver();\r\n    }\r\n    return forType(type, variableResolver);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @param typeReference the reference to obtain the source type from\r\n * @return a {@code ResolvableType} for the specified {@link ParameterizedTypeReference}\r\n * @since 4.3.12\r\n * @see #forType(Type)\r\n */\r\npublic static ResolvableType forType(ParameterizedTypeReference<?> typeReference) {\r\n    return forType(typeReference.getType(), null, null);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\r\n * {@link VariableResolver}.\r\n * @param type the source type or {@code null}\r\n * @param variableResolver the variable resolver or {@code null}\r\n * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\r\n */\r\nstatic ResolvableType forType(@Nullable Type type, @Nullable VariableResolver variableResolver) {\r\n    return forType(type, null, variableResolver);\r\n}\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Type} backed by a given\r\n * {@link VariableResolver}.\r\n * @param type the source type or {@code null}\r\n * @param typeProvider the type provider or {@code null}\r\n * @param variableResolver the variable resolver or {@code null}\r\n * @return a {@code ResolvableType} for the specified {@link Type} and {@link VariableResolver}\r\n */\r\nstatic ResolvableType forType(@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\r\n    if (type == null && typeProvider != null) {\r\n        type = SerializableTypeWrapper.forTypeProvider(typeProvider);\r\n    }\r\n    if (type == null) {\r\n        return NONE;\r\n    }\r\n    // For simple Class references, build the wrapper right away -\r\n    // no expensive resolution necessary, so not worth caching...\r\n    if (type instanceof Class) {\r\n        return new ResolvableType(type, null, typeProvider, variableResolver);\r\n    }\r\n    // Purge empty entries on access since we don't have a clean-up thread or the like.\r\n    cache.purgeUnreferencedEntries();\r\n    // Check the cache - we may have a ResolvableType which has been resolved before...\r\n    ResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);\r\n    ResolvableType cachedType = cache.get(resultType);\r\n    if (cachedType == null) {\r\n        cachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);\r\n        cache.put(cachedType, cachedType);\r\n    }\r\n    resultType.resolved = cachedType.resolved;\r\n    return resultType;\r\n}\n/**\r\n * Clear the internal {@code ResolvableType}/{@code SerializableTypeWrapper} cache.\r\n * @since 4.2\r\n */\r\npublic static void clearCache() {\r\n    cache.clear();\r\n    SerializableTypeWrapper.cache.clear();\r\n}\n/**\r\n * Strategy interface used to resolve {@link TypeVariable TypeVariables}.\r\n */\r\ninterface VariableResolver extends Serializable {\r\n\r\n    /**\r\n     * Return the source of the resolver (used for hashCode and equals).\r\n     */\r\n    Object getSource();\r\n\r\n    /**\r\n     * Resolve the specified variable.\r\n     * @param variable the variable to resolve\r\n     * @return the resolved variable, or {@code null} if not found\r\n     */\r\n    @Nullable\r\n    ResolvableType resolveVariable(TypeVariable<?> variable);\r\n}\n@SuppressWarnings(\"serial\")\r\nprivate static class DefaultVariableResolver implements VariableResolver {\r\n\r\n    private final ResolvableType source;\r\n\r\n    DefaultVariableResolver(ResolvableType resolvableType) {\r\n        this.source = resolvableType;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n        return this.source.resolveVariable(variable);\r\n    }\r\n\r\n    @Override\r\n    public Object getSource() {\r\n        return this.source;\r\n    }\r\n}\n@SuppressWarnings(\"serial\")\r\nprivate static class TypeVariablesVariableResolver implements VariableResolver {\r\n\r\n    private final TypeVariable<?>[] variables;\r\n\r\n    @Nullable\r\n    private final ResolvableType[] generics;\r\n\r\n    public TypeVariablesVariableResolver(TypeVariable<?>[] variables, @Nullable ResolvableType[] generics) {\r\n        this.variables = variables;\r\n        this.generics = generics;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n        TypeVariable<?> variableToCompare = SerializableTypeWrapper.unwrap(variable);\r\n        for (int i = 0; i < this.variables.length; i++) {\r\n            TypeVariable<?> resolvedVariable = SerializableTypeWrapper.unwrap(this.variables[i]);\r\n            if (ObjectUtils.nullSafeEquals(resolvedVariable, variableToCompare)) {\r\n                return this.generics[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Object getSource() {\r\n        return this.generics;\r\n    }\r\n}\nprivate static final class SyntheticParameterizedType implements ParameterizedType, Serializable {\r\n\r\n    private final Type rawType;\r\n\r\n    private final Type[] typeArguments;\r\n\r\n    public SyntheticParameterizedType(Type rawType, Type[] typeArguments) {\r\n        this.rawType = rawType;\r\n        this.typeArguments = typeArguments;\r\n    }\r\n\r\n    @Override\r\n    public String getTypeName() {\r\n        String typeName = this.rawType.getTypeName();\r\n        if (this.typeArguments.length > 0) {\r\n            StringJoiner stringJoiner = new StringJoiner(\", \", \"<\", \">\");\r\n            for (Type argument : this.typeArguments) {\r\n                stringJoiner.add(argument.getTypeName());\r\n            }\r\n            return typeName + stringJoiner;\r\n        }\r\n        return typeName;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Type getOwnerType() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Type getRawType() {\r\n        return this.rawType;\r\n    }\r\n\r\n    @Override\r\n    public Type[] getActualTypeArguments() {\r\n        return this.typeArguments;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        return (this == other || (other instanceof ParameterizedType that && that.getOwnerType() == null && this.rawType.equals(that.getRawType()) && Arrays.equals(this.typeArguments, that.getActualTypeArguments())));\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return (this.rawType.hashCode() * 31 + Arrays.hashCode(this.typeArguments));\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return getTypeName();\r\n    }\r\n}\n/**\r\n * Internal helper to handle bounds from {@link WildcardType WildcardTypes}.\r\n */\r\nprivate static class WildcardBounds {\r\n\r\n    private final Kind kind;\r\n\r\n    private final ResolvableType[] bounds;\r\n\r\n    /**\r\n     * Internal constructor to create a new {@link WildcardBounds} instance.\r\n     * @param kind the kind of bounds\r\n     * @param bounds the bounds\r\n     * @see #get(ResolvableType)\r\n     */\r\n    public WildcardBounds(Kind kind, ResolvableType[] bounds) {\r\n        this.kind = kind;\r\n        this.bounds = bounds;\r\n    }\r\n\r\n    /**\r\n     * Return {@code true} if these bounds are the same kind as the specified bounds.\r\n     */\r\n    public boolean isSameKind(WildcardBounds bounds) {\r\n        return this.kind == bounds.kind;\r\n    }\r\n\r\n    /**\r\n     * Return {@code true} if these bounds are assignable from all the specified types.\r\n     * @param types the types to test against\r\n     * @return {@code true} if these bounds are assignable from all types\r\n     */\r\n    public boolean isAssignableFrom(ResolvableType[] types, @Nullable Map<Type, Type> matchedBefore) {\r\n        for (ResolvableType bound : this.bounds) {\r\n            boolean matched = false;\r\n            for (ResolvableType type : types) {\r\n                if (this.kind == Kind.UPPER ? bound.isAssignableFrom(type, false, matchedBefore, false) : type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                    matched = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!matched) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return {@code true} if these bounds are assignable from the specified type.\r\n     * @param type the type to test against\r\n     * @return {@code true} if these bounds are assignable from the type\r\n     * @since 6.2\r\n     */\r\n    public boolean isAssignableFrom(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\r\n        for (ResolvableType bound : this.bounds) {\r\n            if (this.kind == Kind.UPPER ? !bound.isAssignableFrom(type, false, matchedBefore, false) : !type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return {@code true} if these bounds are assignable to the specified type.\r\n     * @param type the type to test against\r\n     * @return {@code true} if these bounds are assignable to the type\r\n     * @since 6.2\r\n     */\r\n    public boolean isAssignableTo(ResolvableType type, @Nullable Map<Type, Type> matchedBefore) {\r\n        if (this.kind == Kind.UPPER) {\r\n            for (ResolvableType bound : this.bounds) {\r\n                if (type.isAssignableFrom(bound, false, matchedBefore, false)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        } else {\r\n            return (type.resolve() == Object.class);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return {@code true} if these bounds are equal to the specified type.\r\n     * @param type the type to test against\r\n     * @return {@code true} if these bounds are equal to the type\r\n     * @since 6.2.3\r\n     */\r\n    public boolean equalsType(ResolvableType type) {\r\n        for (ResolvableType bound : this.bounds) {\r\n            if (!type.equalsType(bound)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the underlying bounds.\r\n     */\r\n    public ResolvableType[] getBounds() {\r\n        return this.bounds;\r\n    }\r\n\r\n    /**\r\n     * Get a {@link WildcardBounds} instance for the specified type, returning\r\n     * {@code null} if the specified type cannot be resolved to a {@link WildcardType}\r\n     * or an equivalent unresolvable type variable.\r\n     * @param type the source type\r\n     * @return a {@link WildcardBounds} instance or {@code null}\r\n     */\r\n    @Nullable\r\n    public static WildcardBounds get(ResolvableType type) {\r\n        ResolvableType candidate = type;\r\n        while (!(candidate.getType() instanceof WildcardType || candidate.isUnresolvableTypeVariable())) {\r\n            if (candidate == NONE) {\r\n                return null;\r\n            }\r\n            candidate = candidate.resolveType();\r\n        }\r\n        Kind boundsType;\r\n        Type[] bounds;\r\n        if (candidate.getType() instanceof WildcardType wildcardType) {\r\n            boundsType = (wildcardType.getLowerBounds().length > 0 ? Kind.LOWER : Kind.UPPER);\r\n            bounds = (boundsType == Kind.UPPER ? wildcardType.getUpperBounds() : wildcardType.getLowerBounds());\r\n        } else {\r\n            boundsType = Kind.UPPER;\r\n            bounds = ((TypeVariable<?>) candidate.getType()).getBounds();\r\n        }\r\n        ResolvableType[] resolvableBounds = new ResolvableType[bounds.length];\r\n        for (int i = 0; i < bounds.length; i++) {\r\n            resolvableBounds[i] = ResolvableType.forType(bounds[i], type.variableResolver);\r\n        }\r\n        return new WildcardBounds(boundsType, resolvableBounds);\r\n    }\r\n\r\n    /**\r\n     * The various kinds of bounds.\r\n     */\r\n    enum Kind {\r\n\r\n        UPPER, LOWER\r\n    }\r\n}\n/**\r\n * Internal {@link Type} used to represent an empty value.\r\n */\r\n@SuppressWarnings(\"serial\")\r\nstatic class EmptyType implements Type, Serializable {\r\n\r\n    static final Type INSTANCE = new EmptyType();\r\n\r\n    Object readResolve() {\r\n        return INSTANCE;\r\n    }\r\n}",
    "comment": "\n * Encapsulates a Java {@link java.lang.reflect.Type}, providing access to\n * {@link #getSuperType() supertypes}, {@link #getInterfaces() interfaces}, and\n * {@link #getGeneric(int...) generic parameters} along with the ability to ultimately\n * {@link #resolve() resolve} to a {@link java.lang.Class}.\n *\n * <p>A {@code ResolvableType} may be obtained from a {@linkplain #forField(Field) field},\n * a {@linkplain #forMethodParameter(Method, int) method parameter},\n * a {@linkplain #forMethodReturnType(Method) method return type}, or a\n * {@linkplain #forClass(Class) class}. Most methods on this class will themselves return\n * a {@code ResolvableType}, allowing for easy navigation. For example:\n * <pre class=\"code\">\n * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;\n *\n * public void example() {\n *     ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\"myMap\"));\n *     t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;\n *     t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;\n *     t.getGeneric(0).resolve(); // Integer\n *     t.getGeneric(1).resolve(); // List\n *     t.getGeneric(1); // List&lt;String&gt;\n *     t.resolveGeneric(1, 0); // String\n * }\n * </pre>\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Stephane Nicoll\n * @author Yanming Zhou\n * @since 4.0\n * @see #forField(Field)\n * @see #forMethodParameter(Method, int)\n * @see #forMethodReturnType(Method)\n * @see #forConstructorParameter(Constructor, int)\n * @see #forClass(Class)\n * @see #forType(Type)\n * @see #forInstance(Object)\n * @see ResolvableTypeProvider\n "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getType()",
    "entityType": "method",
    "code": "/**\r\n * Return the underling Java {@link Type} being managed.\r\n */\r\npublic Type getType() {\r\n    return SerializableTypeWrapper.unwrap(this.type);\r\n}",
    "comment": "\n\t * Return the underling Java {@link Type} being managed.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getRawClass()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying Java {@link Class} being managed, if available;\r\n * otherwise {@code null}.\r\n */\r\n@Nullable\r\npublic Class<?> getRawClass() {\r\n    if (this.type == this.resolved) {\r\n        return this.resolved;\r\n    }\r\n    Type rawType = this.type;\r\n    if (rawType instanceof ParameterizedType parameterizedType) {\r\n        rawType = parameterizedType.getRawType();\r\n    }\r\n    return (rawType instanceof Class<?> rawClass ? rawClass : null);\r\n}",
    "comment": "\n\t * Return the underlying Java {@link Class} being managed, if available;\n\t * otherwise {@code null}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying source of the resolvable type. Will return a {@link Field},\r\n * {@link MethodParameter} or {@link Type} depending on how the {@code ResolvableType}\r\n * was constructed. This method is primarily to provide access to additional type\r\n * information or meta-data that alternative JVM languages may provide.\r\n */\r\npublic Object getSource() {\r\n    Object source = (this.typeProvider != null ? this.typeProvider.getSource() : null);\r\n    return (source != null ? source : this.type);\r\n}",
    "comment": "\n\t * Return the underlying source of the resolvable type. Will return a {@link Field},\n\t * {@link MethodParameter} or {@link Type} depending on how the {@code ResolvableType}\n\t * was constructed. This method is primarily to provide access to additional type\n\t * information or meta-data that alternative JVM languages may provide.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#toClass()",
    "entityType": "method",
    "code": "/**\r\n * Return this type as a resolved {@code Class}, falling back to\r\n * {@link java.lang.Object} if no specific class can be resolved.\r\n * @return the resolved {@link Class} or the {@code Object} fallback\r\n * @since 5.1\r\n * @see #getRawClass()\r\n * @see #resolve(Class)\r\n */\r\npublic Class<?> toClass() {\r\n    return resolve(Object.class);\r\n}",
    "comment": "\n\t * Return this type as a resolved {@code Class}, falling back to\n\t * {@link java.lang.Object} if no specific class can be resolved.\n\t * @return the resolved {@link Class} or the {@code Object} fallback\n\t * @since 5.1\n\t * @see #getRawClass()\n\t * @see #resolve(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isInstance(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given object is an instance of this {@code ResolvableType}.\r\n * @param obj the object to check\r\n * @since 4.2\r\n * @see #isAssignableFrom(Class)\r\n */\r\npublic boolean isInstance(@Nullable Object obj) {\r\n    return (obj != null && isAssignableFrom(obj.getClass()));\r\n}",
    "comment": "\n\t * Determine whether the given object is an instance of this {@code ResolvableType}.\n\t * @param obj the object to check\n\t * @since 4.2\n\t * @see #isAssignableFrom(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isAssignableFrom(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this {@code ResolvableType} is assignable from the\r\n * specified other type.\r\n * @param other the type to be checked against (as a {@code Class})\r\n * @since 4.2\r\n * @see #isAssignableFrom(ResolvableType)\r\n */\r\npublic boolean isAssignableFrom(Class<?> other) {\r\n    // As of 6.1: shortcut assignability check for top-level Class references\r\n    return (this.type instanceof Class<?> clazz ? ClassUtils.isAssignable(clazz, other) : isAssignableFrom(forClass(other), false, null, false));\r\n}",
    "comment": "\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type.\n\t * @param other the type to be checked against (as a {@code Class})\n\t * @since 4.2\n\t * @see #isAssignableFrom(ResolvableType)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isAssignableFrom(ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this {@code ResolvableType} is assignable from the\r\n * specified other type.\r\n * <p>Attempts to follow the same rules as the Java compiler, considering\r\n * whether both the {@link #resolve() resolved} {@code Class} is\r\n * {@link Class#isAssignableFrom(Class) assignable from} the given type\r\n * as well as whether all {@link #getGenerics() generics} are assignable.\r\n * @param other the type to be checked against (as a {@code ResolvableType})\r\n * @return {@code true} if the specified other type can be assigned to this\r\n * {@code ResolvableType}; {@code false} otherwise\r\n */\r\npublic boolean isAssignableFrom(ResolvableType other) {\r\n    return isAssignableFrom(other, false, null, false);\r\n}",
    "comment": "\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type.\n\t * <p>Attempts to follow the same rules as the Java compiler, considering\n\t * whether both the {@link #resolve() resolved} {@code Class} is\n\t * {@link Class#isAssignableFrom(Class) assignable from} the given type\n\t * as well as whether all {@link #getGenerics() generics} are assignable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType}; {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isAssignableFromResolvedPart(ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this {@code ResolvableType} is assignable from the\r\n * specified other type, as far as the other type is actually resolvable.\r\n * @param other the type to be checked against (as a {@code ResolvableType})\r\n * @return {@code true} if the specified other type can be assigned to this\r\n * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\r\n * @since 6.2\r\n */\r\npublic boolean isAssignableFromResolvedPart(ResolvableType other) {\r\n    return isAssignableFrom(other, false, null, true);\r\n}",
    "comment": "\n\t * Determine whether this {@code ResolvableType} is assignable from the\n\t * specified other type, as far as the other type is actually resolvable.\n\t * @param other the type to be checked against (as a {@code ResolvableType})\n\t * @return {@code true} if the specified other type can be assigned to this\n\t * {@code ResolvableType} as far as it is resolvable; {@code false} otherwise\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isAssignableFrom(ResolvableType,boolean,Map<Type,Type>,boolean)",
    "entityType": "method",
    "code": "private boolean isAssignableFrom(ResolvableType other, boolean strict, @Nullable Map<Type, Type> matchedBefore, boolean upUntilUnresolvable) {\r\n    Assert.notNull(other, \"ResolvableType must not be null\");\r\n    // If we cannot resolve types, we are not assignable\r\n    if (this == NONE || other == NONE) {\r\n        return false;\r\n    }\r\n    if (matchedBefore != null) {\r\n        if (matchedBefore.get(this.type) == other.type) {\r\n            return true;\r\n        }\r\n    } else {\r\n        // As of 6.1: shortcut assignability check for top-level Class references\r\n        if (this.type instanceof Class<?> clazz && other.type instanceof Class<?> otherClazz) {\r\n            return (strict ? clazz.isAssignableFrom(otherClazz) : ClassUtils.isAssignable(clazz, otherClazz));\r\n        }\r\n    }\r\n    if (upUntilUnresolvable && (other.isUnresolvableTypeVariable() || other.isWildcardWithoutBounds())) {\r\n        return true;\r\n    }\r\n    // Deal with array by delegating to the component type\r\n    if (isArray()) {\r\n        return (other.isArray() && getComponentType().isAssignableFrom(other.getComponentType(), true, matchedBefore, upUntilUnresolvable));\r\n    }\r\n    // Deal with wildcard bounds\r\n    WildcardBounds ourBounds = WildcardBounds.get(this);\r\n    WildcardBounds otherBounds = WildcardBounds.get(other);\r\n    // In the form X is assignable to <? extends Number>\r\n    if (otherBounds != null) {\r\n        if (ourBounds != null) {\r\n            return (ourBounds.isSameKind(otherBounds) && ourBounds.isAssignableFrom(otherBounds.getBounds(), matchedBefore));\r\n        } else if (upUntilUnresolvable) {\r\n            return otherBounds.isAssignableFrom(this, matchedBefore);\r\n        } else if (!strict) {\r\n            return (matchedBefore != null ? otherBounds.equalsType(this) : otherBounds.isAssignableTo(this, matchedBefore));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    // In the form <? extends Number> is assignable to X...\r\n    if (ourBounds != null) {\r\n        return ourBounds.isAssignableFrom(other, matchedBefore);\r\n    }\r\n    // Main assignability check about to follow\r\n    boolean exactMatch = (strict && matchedBefore != null);\r\n    boolean checkGenerics = true;\r\n    Class<?> ourResolved = null;\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        // Try default variable resolution\r\n        if (this.variableResolver != null) {\r\n            ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n            if (resolved != null) {\r\n                ourResolved = resolved.resolve();\r\n            }\r\n        }\r\n        if (ourResolved == null) {\r\n            // Try variable resolution against target type\r\n            if (other.variableResolver != null) {\r\n                ResolvableType resolved = other.variableResolver.resolveVariable(variable);\r\n                if (resolved != null) {\r\n                    ourResolved = resolved.resolve();\r\n                    checkGenerics = false;\r\n                }\r\n            }\r\n        }\r\n        if (ourResolved == null) {\r\n            // Unresolved type variable, potentially nested -> never insist on exact match\r\n            exactMatch = false;\r\n        }\r\n    }\r\n    if (ourResolved == null) {\r\n        ourResolved = toClass();\r\n    }\r\n    Class<?> otherResolved = other.toClass();\r\n    // We need an exact type match for generics\r\n    // List<CharSequence> is not assignable from List<String>\r\n    if (exactMatch ? !ourResolved.equals(otherResolved) : (strict ? !ourResolved.isAssignableFrom(otherResolved) : !ClassUtils.isAssignable(ourResolved, otherResolved))) {\r\n        return false;\r\n    }\r\n    if (checkGenerics) {\r\n        // Recursively check each generic\r\n        ResolvableType[] ourGenerics = getGenerics();\r\n        ResolvableType[] otherGenerics = other.as(ourResolved).getGenerics();\r\n        if (ourGenerics.length != otherGenerics.length) {\r\n            return false;\r\n        }\r\n        if (ourGenerics.length > 0) {\r\n            if (matchedBefore == null) {\r\n                matchedBefore = new IdentityHashMap<>(1);\r\n            }\r\n            matchedBefore.put(this.type, other.type);\r\n            for (int i = 0; i < ourGenerics.length; i++) {\r\n                ResolvableType otherGeneric = otherGenerics[i];\r\n                if (!ourGenerics[i].isAssignableFrom(otherGeneric, !otherGeneric.isUnresolvableTypeVariable(), matchedBefore, upUntilUnresolvable)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isArray()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if this type resolves to a Class that represents an array.\r\n * @see #getComponentType()\r\n */\r\npublic boolean isArray() {\r\n    if (this == NONE) {\r\n        return false;\r\n    }\r\n    return ((this.type instanceof Class<?> clazz && clazz.isArray()) || this.type instanceof GenericArrayType || resolveType().isArray());\r\n}",
    "comment": "\n\t * Return {@code true} if this type resolves to a Class that represents an array.\n\t * @see #getComponentType()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getComponentType()",
    "entityType": "method",
    "code": "/**\r\n * Return the ResolvableType representing the component type of the array or\r\n * {@link #NONE} if this type does not represent an array.\r\n * @see #isArray()\r\n */\r\npublic ResolvableType getComponentType() {\r\n    if (this == NONE) {\r\n        return NONE;\r\n    }\r\n    if (this.componentType != null) {\r\n        return this.componentType;\r\n    }\r\n    if (this.type instanceof Class<?> clazz) {\r\n        Class<?> componentType = clazz.componentType();\r\n        return forType(componentType, this.variableResolver);\r\n    }\r\n    if (this.type instanceof GenericArrayType genericArrayType) {\r\n        return forType(genericArrayType.getGenericComponentType(), this.variableResolver);\r\n    }\r\n    return resolveType().getComponentType();\r\n}",
    "comment": "\n\t * Return the ResolvableType representing the component type of the array or\n\t * {@link #NONE} if this type does not represent an array.\n\t * @see #isArray()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#asCollection()",
    "entityType": "method",
    "code": "/**\r\n * Convenience method to return this type as a resolvable {@link Collection} type.\r\n * <p>Returns {@link #NONE} if this type does not implement or extend\r\n * {@link Collection}.\r\n * @see #as(Class)\r\n * @see #asMap()\r\n */\r\npublic ResolvableType asCollection() {\r\n    return as(Collection.class);\r\n}",
    "comment": "\n\t * Convenience method to return this type as a resolvable {@link Collection} type.\n\t * <p>Returns {@link #NONE} if this type does not implement or extend\n\t * {@link Collection}.\n\t * @see #as(Class)\n\t * @see #asMap()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#asMap()",
    "entityType": "method",
    "code": "/**\r\n * Convenience method to return this type as a resolvable {@link Map} type.\r\n * <p>Returns {@link #NONE} if this type does not implement or extend\r\n * {@link Map}.\r\n * @see #as(Class)\r\n * @see #asCollection()\r\n */\r\npublic ResolvableType asMap() {\r\n    return as(Map.class);\r\n}",
    "comment": "\n\t * Convenience method to return this type as a resolvable {@link Map} type.\n\t * <p>Returns {@link #NONE} if this type does not implement or extend\n\t * {@link Map}.\n\t * @see #as(Class)\n\t * @see #asCollection()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#as(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return this type as a {@code ResolvableType} of the specified class. Searches\r\n * {@link #getSuperType() supertype} and {@link #getInterfaces() interface}\r\n * hierarchies to find a match, returning {@link #NONE} if this type does not\r\n * implement or extend the specified class.\r\n * @param type the required type (typically narrowed)\r\n * @return a {@code ResolvableType} representing this object as the specified\r\n * type, or {@link #NONE} if not resolvable as that type\r\n * @see #asCollection()\r\n * @see #asMap()\r\n * @see #getSuperType()\r\n * @see #getInterfaces()\r\n */\r\npublic ResolvableType as(Class<?> type) {\r\n    if (this == NONE) {\r\n        return NONE;\r\n    }\r\n    Class<?> resolved = resolve();\r\n    if (resolved == null || resolved == type) {\r\n        return this;\r\n    }\r\n    for (ResolvableType interfaceType : getInterfaces()) {\r\n        ResolvableType interfaceAsType = interfaceType.as(type);\r\n        if (interfaceAsType != NONE) {\r\n            return interfaceAsType;\r\n        }\r\n    }\r\n    return getSuperType().as(type);\r\n}",
    "comment": "\n\t * Return this type as a {@code ResolvableType} of the specified class. Searches\n\t * {@link #getSuperType() supertype} and {@link #getInterfaces() interface}\n\t * hierarchies to find a match, returning {@link #NONE} if this type does not\n\t * implement or extend the specified class.\n\t * @param type the required type (typically narrowed)\n\t * @return a {@code ResolvableType} representing this object as the specified\n\t * type, or {@link #NONE} if not resolvable as that type\n\t * @see #asCollection()\n\t * @see #asMap()\n\t * @see #getSuperType()\n\t * @see #getInterfaces()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getSuperType()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} representing the direct supertype of this type.\r\n * <p>If no supertype is available this method returns {@link #NONE}.\r\n * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\r\n * @see #getInterfaces()\r\n */\r\npublic ResolvableType getSuperType() {\r\n    Class<?> resolved = resolve();\r\n    if (resolved == null) {\r\n        return NONE;\r\n    }\r\n    try {\r\n        Type superclass = resolved.getGenericSuperclass();\r\n        if (superclass == null) {\r\n            return NONE;\r\n        }\r\n        ResolvableType superType = this.superType;\r\n        if (superType == null) {\r\n            superType = forType(superclass, this);\r\n            this.superType = superType;\r\n        }\r\n        return superType;\r\n    } catch (TypeNotPresentException ex) {\r\n        // Ignore non-present types in generic signature\r\n        return NONE;\r\n    }\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} representing the direct supertype of this type.\n\t * <p>If no supertype is available this method returns {@link #NONE}.\n\t * <p>Note: The resulting {@code ResolvableType} instance may not be {@link Serializable}.\n\t * @see #getInterfaces()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getInterfaces()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} array representing the direct interfaces\r\n * implemented by this type. If this type does not implement any interfaces an\r\n * empty array is returned.\r\n * <p>Note: The resulting {@code ResolvableType} instances may not be {@link Serializable}.\r\n * @see #getSuperType()\r\n */\r\npublic ResolvableType[] getInterfaces() {\r\n    Class<?> resolved = resolve();\r\n    if (resolved == null) {\r\n        return EMPTY_TYPES_ARRAY;\r\n    }\r\n    ResolvableType[] interfaces = this.interfaces;\r\n    if (interfaces == null) {\r\n        Type[] genericIfcs = resolved.getGenericInterfaces();\r\n        if (genericIfcs.length > 0) {\r\n            interfaces = new ResolvableType[genericIfcs.length];\r\n            for (int i = 0; i < genericIfcs.length; i++) {\r\n                interfaces[i] = forType(genericIfcs[i], this);\r\n            }\r\n        } else {\r\n            interfaces = EMPTY_TYPES_ARRAY;\r\n        }\r\n        this.interfaces = interfaces;\r\n    }\r\n    return interfaces;\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} array representing the direct interfaces\n\t * implemented by this type. If this type does not implement any interfaces an\n\t * empty array is returned.\n\t * <p>Note: The resulting {@code ResolvableType} instances may not be {@link Serializable}.\n\t * @see #getSuperType()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#hasGenerics()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if this type contains generic parameters.\r\n * @see #getGeneric(int...)\r\n * @see #getGenerics()\r\n */\r\npublic boolean hasGenerics() {\r\n    return (getGenerics().length > 0);\r\n}",
    "comment": "\n\t * Return {@code true} if this type contains generic parameters.\n\t * @see #getGeneric(int...)\n\t * @see #getGenerics()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#hasResolvableGenerics()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if this type contains at least a generic type\r\n * that is resolved. In other words, this returns {@code false} if\r\n * the type contains unresolvable generics only, that is, no substitute\r\n * for any of its declared type variables.\r\n * @since 6.2\r\n */\r\npublic boolean hasResolvableGenerics() {\r\n    if (this == NONE) {\r\n        return false;\r\n    }\r\n    ResolvableType[] generics = getGenerics();\r\n    for (ResolvableType generic : generics) {\r\n        if (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Return {@code true} if this type contains at least a generic type\n\t * that is resolved. In other words, this returns {@code false} if\n\t * the type contains unresolvable generics only, that is, no substitute\n\t * for any of its declared type variables.\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#hasUnresolvableGenerics()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying type has any unresolvable generics:\r\n * either through an unresolvable type variable on the type itself\r\n * or through implementing a generic interface in a raw fashion,\r\n * i.e. without substituting that interface's type variables.\r\n * The result will be {@code true} only in those two scenarios.\r\n */\r\npublic boolean hasUnresolvableGenerics() {\r\n    if (this == NONE) {\r\n        return false;\r\n    }\r\n    return hasUnresolvableGenerics(null);\r\n}",
    "comment": "\n\t * Determine whether the underlying type has any unresolvable generics:\n\t * either through an unresolvable type variable on the type itself\n\t * or through implementing a generic interface in a raw fashion,\n\t * i.e. without substituting that interface's type variables.\n\t * The result will be {@code true} only in those two scenarios.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#hasUnresolvableGenerics(Set<Type>)",
    "entityType": "method",
    "code": "private boolean hasUnresolvableGenerics(@Nullable Set<Type> alreadySeen) {\r\n    Boolean unresolvableGenerics = this.unresolvableGenerics;\r\n    if (unresolvableGenerics == null) {\r\n        unresolvableGenerics = determineUnresolvableGenerics(alreadySeen);\r\n        this.unresolvableGenerics = unresolvableGenerics;\r\n    }\r\n    return unresolvableGenerics;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#determineUnresolvableGenerics(Set<Type>)",
    "entityType": "method",
    "code": "private boolean determineUnresolvableGenerics(@Nullable Set<Type> alreadySeen) {\r\n    if (alreadySeen != null && alreadySeen.contains(this.type)) {\r\n        // Self-referencing generic -> not unresolvable\r\n        return false;\r\n    }\r\n    ResolvableType[] generics = getGenerics();\r\n    for (ResolvableType generic : generics) {\r\n        if (generic.isUnresolvableTypeVariable() || generic.isWildcardWithoutBounds() || generic.hasUnresolvableGenerics(currentTypeSeen(alreadySeen))) {\r\n            return true;\r\n        }\r\n    }\r\n    Class<?> resolved = resolve();\r\n    if (resolved != null) {\r\n        try {\r\n            for (Type genericInterface : resolved.getGenericInterfaces()) {\r\n                if (genericInterface instanceof Class<?> clazz) {\r\n                    if (clazz.getTypeParameters().length > 0) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        } catch (TypeNotPresentException ex) {\r\n            // Ignore non-present types in generic signature\r\n        }\r\n        Class<?> superclass = resolved.getSuperclass();\r\n        if (superclass != null && superclass != Object.class) {\r\n            return getSuperType().hasUnresolvableGenerics(currentTypeSeen(alreadySeen));\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#currentTypeSeen(Set<Type>)",
    "entityType": "method",
    "code": "private Set<Type> currentTypeSeen(@Nullable Set<Type> alreadySeen) {\r\n    if (alreadySeen == null) {\r\n        alreadySeen = new HashSet<>(4);\r\n    }\r\n    alreadySeen.add(this.type);\r\n    return alreadySeen;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isUnresolvableTypeVariable()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying type is a type variable that\r\n * cannot be resolved through the associated variable resolver.\r\n */\r\nprivate boolean isUnresolvableTypeVariable() {\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        if (this.variableResolver == null) {\r\n            return true;\r\n        }\r\n        ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n        if (resolved == null || resolved.isUnresolvableTypeVariable() || resolved.isWildcardWithoutBounds()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the underlying type is a type variable that\n\t * cannot be resolved through the associated variable resolver.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#isWildcardWithoutBounds()",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the underlying type represents a wildcard\r\n * without specific bounds (i.e., equal to {@code ? extends Object}).\r\n */\r\nprivate boolean isWildcardWithoutBounds() {\r\n    if (this.type instanceof WildcardType wildcardType) {\r\n        if (wildcardType.getLowerBounds().length == 0) {\r\n            Type[] upperBounds = wildcardType.getUpperBounds();\r\n            if (upperBounds.length == 0 || (upperBounds.length == 1 && Object.class == upperBounds[0])) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the underlying type represents a wildcard\n\t * without specific bounds (i.e., equal to {@code ? extends Object}).\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getNested(int)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified nesting level.\r\n * <p>See {@link #getNested(int, Map)} for details.\r\n * @param nestingLevel the nesting level\r\n * @return the {@code ResolvableType} type, or {@code #NONE}\r\n */\r\npublic ResolvableType getNested(int nestingLevel) {\r\n    return getNested(nestingLevel, null);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified nesting level.\n\t * <p>See {@link #getNested(int, Map)} for details.\n\t * @param nestingLevel the nesting level\n\t * @return the {@code ResolvableType} type, or {@code #NONE}\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getNested(int,Map<Integer,Integer>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified nesting level.\r\n * <p>The nesting level refers to the specific generic parameter that should be returned.\r\n * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\r\n * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\r\n * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\r\n * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\r\n * for the given level. For example, an index of 0 would refer to a {@code Map} key;\r\n * whereas, 1 would refer to the value. If the map does not contain a value for a\r\n * specific level the last generic will be used (for example, a {@code Map} value).\r\n * <p>Nesting levels may also apply to array types; for example given\r\n * {@code String[]}, a nesting level of 2 refers to {@code String}.\r\n * <p>If a type does not {@link #hasGenerics() contain} generics the\r\n * {@link #getSuperType() supertype} hierarchy will be considered.\r\n * @param nestingLevel the required nesting level, indexed from 1 for the\r\n * current type, 2 for the first nested generic, 3 for the second and so on\r\n * @param typeIndexesPerLevel a map containing the generic index for a given\r\n * nesting level (can be {@code null})\r\n * @return a {@code ResolvableType} for the nested level, or {@link #NONE}\r\n */\r\npublic ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {\r\n    ResolvableType result = this;\r\n    for (int i = 2; i <= nestingLevel; i++) {\r\n        if (result.isArray()) {\r\n            result = result.getComponentType();\r\n        } else {\r\n            // Handle derived types\r\n            while (result != ResolvableType.NONE && !result.hasGenerics()) {\r\n                result = result.getSuperType();\r\n            }\r\n            Integer index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);\r\n            index = (index == null ? result.getGenerics().length - 1 : index);\r\n            result = result.getGeneric(index);\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified nesting level.\n\t * <p>The nesting level refers to the specific generic parameter that should be returned.\n\t * A nesting level of 1 indicates this type; 2 indicates the first nested generic;\n\t * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers\n\t * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}.\n\t * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic\n\t * for the given level. For example, an index of 0 would refer to a {@code Map} key;\n\t * whereas, 1 would refer to the value. If the map does not contain a value for a\n\t * specific level the last generic will be used (for example, a {@code Map} value).\n\t * <p>Nesting levels may also apply to array types; for example given\n\t * {@code String[]}, a nesting level of 2 refers to {@code String}.\n\t * <p>If a type does not {@link #hasGenerics() contain} generics the\n\t * {@link #getSuperType() supertype} hierarchy will be considered.\n\t * @param nestingLevel the required nesting level, indexed from 1 for the\n\t * current type, 2 for the first nested generic, 3 for the second and so on\n\t * @param typeIndexesPerLevel a map containing the generic index for a given\n\t * nesting level (can be {@code null})\n\t * @return a {@code ResolvableType} for the nested level, or {@link #NONE}\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getGeneric(int)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} representing the generic parameter for the\r\n * given indexes. Indexes are zero based; for example given the type\r\n * {@code Map<Integer, List<String>>}, {@code getGeneric(0)} will access the\r\n * {@code Integer}. Nested generics can be accessed by specifying multiple indexes;\r\n * for example {@code getGeneric(1, 0)} will access the {@code String} from the\r\n * nested {@code List}. For convenience, if no indexes are specified the first\r\n * generic is returned.\r\n * <p>If no generic is available at the specified indexes {@link #NONE} is returned.\r\n * @param indexes the indexes that refer to the generic parameter\r\n * (can be omitted to return the first generic)\r\n * @return a {@code ResolvableType} for the specified generic, or {@link #NONE}\r\n * @see #hasGenerics()\r\n * @see #getGenerics()\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\npublic ResolvableType getGeneric(int@Nullable ... indexes) {\r\n    ResolvableType[] generics = getGenerics();\r\n    if (indexes == null || indexes.length == 0) {\r\n        return (generics.length == 0 ? NONE : generics[0]);\r\n    }\r\n    ResolvableType generic = this;\r\n    for (int index : indexes) {\r\n        generics = generic.getGenerics();\r\n        if (index < 0 || index >= generics.length) {\r\n            return NONE;\r\n        }\r\n        generic = generics[index];\r\n    }\r\n    return generic;\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} representing the generic parameter for the\n\t * given indexes. Indexes are zero based; for example given the type\n\t * {@code Map<Integer, List<String>>}, {@code getGeneric(0)} will access the\n\t * {@code Integer}. Nested generics can be accessed by specifying multiple indexes;\n\t * for example {@code getGeneric(1, 0)} will access the {@code String} from the\n\t * nested {@code List}. For convenience, if no indexes are specified the first\n\t * generic is returned.\n\t * <p>If no generic is available at the specified indexes {@link #NONE} is returned.\n\t * @param indexes the indexes that refer to the generic parameter\n\t * (can be omitted to return the first generic)\n\t * @return a {@code ResolvableType} for the specified generic, or {@link #NONE}\n\t * @see #hasGenerics()\n\t * @see #getGenerics()\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#getGenerics()",
    "entityType": "method",
    "code": "/**\r\n * Return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters of\r\n * this type. If no generics are available an empty array is returned. If you need to\r\n * access a specific generic consider using the {@link #getGeneric(int...)} method as\r\n * it allows access to nested generics and protects against\r\n * {@code IndexOutOfBoundsExceptions}.\r\n * @return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters\r\n * (never {@code null})\r\n * @see #hasGenerics()\r\n * @see #getGeneric(int...)\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\npublic ResolvableType[] getGenerics() {\r\n    if (this == NONE) {\r\n        return EMPTY_TYPES_ARRAY;\r\n    }\r\n    ResolvableType[] generics = this.generics;\r\n    if (generics == null) {\r\n        if (this.type instanceof Class<?> clazz) {\r\n            Type[] typeParams = clazz.getTypeParameters();\r\n            if (typeParams.length > 0) {\r\n                generics = new ResolvableType[typeParams.length];\r\n                for (int i = 0; i < generics.length; i++) {\r\n                    generics[i] = ResolvableType.forType(typeParams[i], this);\r\n                }\r\n            } else {\r\n                generics = EMPTY_TYPES_ARRAY;\r\n            }\r\n        } else if (this.type instanceof ParameterizedType parameterizedType) {\r\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\r\n            if (actualTypeArguments.length > 0) {\r\n                generics = new ResolvableType[actualTypeArguments.length];\r\n                for (int i = 0; i < actualTypeArguments.length; i++) {\r\n                    generics[i] = forType(actualTypeArguments[i], this.variableResolver);\r\n                }\r\n            } else {\r\n                generics = EMPTY_TYPES_ARRAY;\r\n            }\r\n        } else {\r\n            generics = resolveType().getGenerics();\r\n        }\r\n        this.generics = generics;\r\n    }\r\n    return generics;\r\n}",
    "comment": "\n\t * Return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters of\n\t * this type. If no generics are available an empty array is returned. If you need to\n\t * access a specific generic consider using the {@link #getGeneric(int...)} method as\n\t * it allows access to nested generics and protects against\n\t * {@code IndexOutOfBoundsExceptions}.\n\t * @return an array of {@code ResolvableType ResolvableTypes} representing the generic parameters\n\t * (never {@code null})\n\t * @see #hasGenerics()\n\t * @see #getGeneric(int...)\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveGenerics()",
    "entityType": "method",
    "code": "/**\r\n * Convenience method that will {@link #getGenerics() get} and\r\n * {@link #resolve() resolve} generic parameters.\r\n * @return an array of resolved generic parameters (the resulting array\r\n * will never be {@code null}, but it may contain {@code null} elements)\r\n * @see #getGenerics()\r\n * @see #resolve()\r\n */\r\n@Nullable\r\npublic Class<?>[] resolveGenerics() {\r\n    ResolvableType[] generics = getGenerics();\r\n    @Nullable\r\n    Class<?>[] resolvedGenerics = new Class<?>[generics.length];\r\n    for (int i = 0; i < generics.length; i++) {\r\n        resolvedGenerics[i] = generics[i].resolve();\r\n    }\r\n    return resolvedGenerics;\r\n}",
    "comment": "\n\t * Convenience method that will {@link #getGenerics() get} and\n\t * {@link #resolve() resolve} generic parameters.\n\t * @return an array of resolved generic parameters (the resulting array\n\t * will never be {@code null}, but it may contain {@code null} elements)\n\t * @see #getGenerics()\n\t * @see #resolve()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveGenerics(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Convenience method that will {@link #getGenerics() get} and {@link #resolve()\r\n * resolve} generic parameters, using the specified {@code fallback} if any type\r\n * cannot be resolved.\r\n * @param fallback the fallback class to use if resolution fails\r\n * @return an array of resolved generic parameters\r\n * @see #getGenerics()\r\n * @see #resolve()\r\n */\r\npublic Class<?>[] resolveGenerics(Class<?> fallback) {\r\n    ResolvableType[] generics = getGenerics();\r\n    Class<?>[] resolvedGenerics = new Class<?>[generics.length];\r\n    for (int i = 0; i < generics.length; i++) {\r\n        resolvedGenerics[i] = generics[i].resolve(fallback);\r\n    }\r\n    return resolvedGenerics;\r\n}",
    "comment": "\n\t * Convenience method that will {@link #getGenerics() get} and {@link #resolve()\n\t * resolve} generic parameters, using the specified {@code fallback} if any type\n\t * cannot be resolved.\n\t * @param fallback the fallback class to use if resolution fails\n\t * @return an array of resolved generic parameters\n\t * @see #getGenerics()\n\t * @see #resolve()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveGeneric(int)",
    "entityType": "method",
    "code": "/**\r\n * Convenience method that will {@link #getGeneric(int...) get} and\r\n * {@link #resolve() resolve} a specific generic parameter.\r\n * @param indexes the indexes that refer to the generic parameter\r\n * (can be omitted to return the first generic)\r\n * @return a resolved {@link Class} or {@code null}\r\n * @see #getGeneric(int...)\r\n * @see #resolve()\r\n */\r\n@Nullable\r\npublic Class<?> resolveGeneric(int... indexes) {\r\n    return getGeneric(indexes).resolve();\r\n}",
    "comment": "\n\t * Convenience method that will {@link #getGeneric(int...) get} and\n\t * {@link #resolve() resolve} a specific generic parameter.\n\t * @param indexes the indexes that refer to the generic parameter\n\t * (can be omitted to return the first generic)\n\t * @return a resolved {@link Class} or {@code null}\n\t * @see #getGeneric(int...)\n\t * @see #resolve()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolve()",
    "entityType": "method",
    "code": "/**\r\n * Resolve this type to a {@link java.lang.Class}, returning {@code null}\r\n * if the type cannot be resolved. This method will consider bounds of\r\n * {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\r\n * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\r\n * <p>If this method returns a non-null {@code Class} and {@link #hasGenerics()}\r\n * returns {@code false}, the given type effectively wraps a plain {@code Class},\r\n * allowing for plain {@code Class} processing if desirable.\r\n * @return the resolved {@link Class}, or {@code null} if not resolvable\r\n * @see #resolve(Class)\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\n@Nullable\r\npublic Class<?> resolve() {\r\n    return this.resolved;\r\n}",
    "comment": "\n\t * Resolve this type to a {@link java.lang.Class}, returning {@code null}\n\t * if the type cannot be resolved. This method will consider bounds of\n\t * {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\n\t * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\n\t * <p>If this method returns a non-null {@code Class} and {@link #hasGenerics()}\n\t * returns {@code false}, the given type effectively wraps a plain {@code Class},\n\t * allowing for plain {@code Class} processing if desirable.\n\t * @return the resolved {@link Class}, or {@code null} if not resolvable\n\t * @see #resolve(Class)\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolve(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve this type to a {@link java.lang.Class}, returning the specified\r\n * {@code fallback} if the type cannot be resolved. This method will consider bounds\r\n * of {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\r\n * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\r\n * @param fallback the fallback class to use if resolution fails\r\n * @return the resolved {@link Class} or the {@code fallback}\r\n * @see #resolve()\r\n * @see #resolveGeneric(int...)\r\n * @see #resolveGenerics()\r\n */\r\npublic Class<?> resolve(Class<?> fallback) {\r\n    return (this.resolved != null ? this.resolved : fallback);\r\n}",
    "comment": "\n\t * Resolve this type to a {@link java.lang.Class}, returning the specified\n\t * {@code fallback} if the type cannot be resolved. This method will consider bounds\n\t * of {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if\n\t * direct resolution fails; however, bounds of {@code Object.class} will be ignored.\n\t * @param fallback the fallback class to use if resolution fails\n\t * @return the resolved {@link Class} or the {@code fallback}\n\t * @see #resolve()\n\t * @see #resolveGeneric(int...)\n\t * @see #resolveGenerics()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveClass()",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Class<?> resolveClass() {\r\n    if (this.type == EmptyType.INSTANCE) {\r\n        return null;\r\n    }\r\n    if (this.type instanceof Class<?> clazz) {\r\n        return clazz;\r\n    }\r\n    if (this.type instanceof GenericArrayType) {\r\n        Class<?> resolvedComponent = getComponentType().resolve();\r\n        return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);\r\n    }\r\n    return resolveType().resolve();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveType()",
    "entityType": "method",
    "code": "/**\r\n * Resolve this type by a single level, returning the resolved value or {@link #NONE}.\r\n * <p>Note: The returned {@code ResolvableType} should only be used as an intermediary\r\n * as it cannot be serialized.\r\n */\r\nResolvableType resolveType() {\r\n    if (this.type instanceof ParameterizedType parameterizedType) {\r\n        return forType(parameterizedType.getRawType(), this.variableResolver);\r\n    }\r\n    if (this.type instanceof WildcardType wildcardType) {\r\n        Type resolved = resolveBounds(wildcardType.getUpperBounds());\r\n        if (resolved == null) {\r\n            resolved = resolveBounds(wildcardType.getLowerBounds());\r\n        }\r\n        return forType(resolved, this.variableResolver);\r\n    }\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        // Try default variable resolution\r\n        if (this.variableResolver != null) {\r\n            ResolvableType resolved = this.variableResolver.resolveVariable(variable);\r\n            if (resolved != null) {\r\n                return resolved;\r\n            }\r\n        }\r\n        // Fallback to bounds\r\n        return forType(resolveBounds(variable.getBounds()), this.variableResolver);\r\n    }\r\n    return NONE;\r\n}",
    "comment": "\n\t * Resolve this type by a single level, returning the resolved value or {@link #NONE}.\n\t * <p>Note: The returned {@code ResolvableType} should only be used as an intermediary\n\t * as it cannot be serialized.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#resolveVariable(TypeVariable<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate ResolvableType resolveVariable(TypeVariable<?> variable) {\r\n    if (this.type instanceof TypeVariable) {\r\n        return resolveType().resolveVariable(variable);\r\n    }\r\n    if (this.type instanceof ParameterizedType parameterizedType) {\r\n        Class<?> resolved = resolve();\r\n        if (resolved == null) {\r\n            return null;\r\n        }\r\n        TypeVariable<?>[] variables = resolved.getTypeParameters();\r\n        for (int i = 0; i < variables.length; i++) {\r\n            if (ObjectUtils.nullSafeEquals(variables[i].getName(), variable.getName())) {\r\n                Type actualType = parameterizedType.getActualTypeArguments()[i];\r\n                return forType(actualType, this.variableResolver);\r\n            }\r\n        }\r\n        Type ownerType = parameterizedType.getOwnerType();\r\n        if (ownerType != null) {\r\n            return forType(ownerType, this.variableResolver).resolveVariable(variable);\r\n        }\r\n    }\r\n    if (this.type instanceof WildcardType) {\r\n        ResolvableType resolved = resolveType().resolveVariable(variable);\r\n        if (resolved != null) {\r\n            return resolved;\r\n        }\r\n    }\r\n    if (this.variableResolver != null) {\r\n        return this.variableResolver.resolveVariable(variable);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * Check for full equality of all type resolution artifacts:\r\n * type as well as {@code TypeProvider} and {@code VariableResolver}.\r\n * @see #equalsType(ResolvableType)\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || other.getClass() != getClass()) {\r\n        return false;\r\n    }\r\n    ResolvableType otherType = (ResolvableType) other;\r\n    if (!equalsType(otherType)) {\r\n        return false;\r\n    }\r\n    if (this.typeProvider != otherType.typeProvider && (this.typeProvider == null || otherType.typeProvider == null || !ObjectUtils.nullSafeEquals(this.typeProvider.getType(), otherType.typeProvider.getType()))) {\r\n        return false;\r\n    }\r\n    if (this.variableResolver != otherType.variableResolver && (this.variableResolver == null || otherType.variableResolver == null || !ObjectUtils.nullSafeEquals(this.variableResolver.getSource(), otherType.variableResolver.getSource()))) {\r\n        return false;\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Check for full equality of all type resolution artifacts:\n\t * type as well as {@code TypeProvider} and {@code VariableResolver}.\n\t * @see #equalsType(ResolvableType)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#equalsType(ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Check for type-level equality with another {@code ResolvableType}.\r\n * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\r\n * this works between different sources as well, for example, method parameters and return types.\r\n * @param otherType the {@code ResolvableType} to match against\r\n * @return whether the declared type and type variables match\r\n * @since 6.1\r\n */\r\npublic boolean equalsType(ResolvableType otherType) {\r\n    return (ObjectUtils.nullSafeEquals(this.type, otherType.type) && ObjectUtils.nullSafeEquals(this.componentType, otherType.componentType));\r\n}",
    "comment": "\n\t * Check for type-level equality with another {@code ResolvableType}.\n\t * <p>In contrast to {@link #equals(Object)} or {@link #isAssignableFrom(ResolvableType)},\n\t * this works between different sources as well, for example, method parameters and return types.\n\t * @param otherType the {@code ResolvableType} to match against\n\t * @return whether the declared type and type variables match\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return (this.hash != null ? this.hash : calculateHashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#calculateHashCode()",
    "entityType": "method",
    "code": "private int calculateHashCode() {\r\n    int hashCode = ObjectUtils.nullSafeHashCode(this.type);\r\n    if (this.componentType != null) {\r\n        hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.componentType);\r\n    }\r\n    if (this.typeProvider != null) {\r\n        hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.typeProvider.getType());\r\n    }\r\n    if (this.variableResolver != null) {\r\n        hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.variableResolver.getSource());\r\n    }\r\n    return hashCode;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableType#asVariableResolver()",
    "entityType": "method",
    "code": "/**\r\n * Adapts this {@code ResolvableType} to a {@link VariableResolver}.\r\n */\r\n@Nullable\r\nVariableResolver asVariableResolver() {\r\n    if (this == NONE) {\r\n        return null;\r\n    }\r\n    return new DefaultVariableResolver(this);\r\n}",
    "comment": "\n\t * Adapts this {@code ResolvableType} to a {@link VariableResolver}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#readResolve()",
    "entityType": "method",
    "code": "/**\r\n * Custom serialization support for {@link #NONE}.\r\n */\r\nprivate Object readResolve() {\r\n    return (this.type == EmptyType.INSTANCE ? NONE : this);\r\n}",
    "comment": "\n\t * Custom serialization support for {@link #NONE}.\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#toString()",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of this type in its fully resolved form\r\n * (including any generic parameters).\r\n */\r\n@Override\r\npublic String toString() {\r\n    if (isArray()) {\r\n        return getComponentType() + \"[]\";\r\n    }\r\n    if (this.resolved == null) {\r\n        return \"?\";\r\n    }\r\n    if (this.type instanceof TypeVariable<?> variable) {\r\n        if (this.variableResolver == null || this.variableResolver.resolveVariable(variable) == null) {\r\n            // Don't bother with variable boundaries for toString()...\r\n            // Can cause infinite recursions in case of self-references\r\n            return \"?\";\r\n        }\r\n    }\r\n    if (hasGenerics()) {\r\n        return this.resolved.getName() + '<' + StringUtils.arrayToDelimitedString(getGenerics(), \", \") + '>';\r\n    }\r\n    return this.resolved.getName();\r\n}",
    "comment": "\n\t * Return a String representation of this type in its fully resolved form\n\t * (including any generic parameters).\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forClass(Class<?>)",
    "entityType": "method",
    "code": "// Factory methods\r\n/**\r\n * Return a {@code ResolvableType} for the specified {@link Class},\r\n * using the full generic type information for assignability checks.\r\n * <p>For example: {@code ResolvableType.forClass(MyArrayList.class)}.\r\n * @param clazz the class to introspect ({@code null} is semantically\r\n * equivalent to {@code Object.class} for typical use cases here)\r\n * @return a {@code ResolvableType} for the specified class\r\n * @see #forClass(Class, Class)\r\n * @see #forClassWithGenerics(Class, Class...)\r\n */\r\npublic static ResolvableType forClass(@Nullable Class<?> clazz) {\r\n    return new ResolvableType(clazz);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Class},\n\t * using the full generic type information for assignability checks.\n\t * <p>For example: {@code ResolvableType.forClass(MyArrayList.class)}.\n\t * @param clazz the class to introspect ({@code null} is semantically\n\t * equivalent to {@code Object.class} for typical use cases here)\n\t * @return a {@code ResolvableType} for the specified class\n\t * @see #forClass(Class, Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forRawClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Class},\r\n * doing assignability checks against the raw class only (analogous to\r\n * {@link Class#isAssignableFrom}, which this serves as a wrapper for).\r\n * <p>For example: {@code ResolvableType.forRawClass(List.class)}.\r\n * @param clazz the class to introspect ({@code null} is semantically\r\n * equivalent to {@code Object.class} for typical use cases here)\r\n * @return a {@code ResolvableType} for the specified class\r\n * @since 4.2\r\n * @see #forClass(Class)\r\n * @see #getRawClass()\r\n */\r\npublic static ResolvableType forRawClass(@Nullable Class<?> clazz) {\r\n    return new ResolvableType(clazz) {\r\n\r\n        @Override\r\n        public ResolvableType[] getGenerics() {\r\n            return EMPTY_TYPES_ARRAY;\r\n        }\r\n\r\n        @Override\r\n        public boolean isAssignableFrom(Class<?> other) {\r\n            return (clazz == null || ClassUtils.isAssignable(clazz, other));\r\n        }\r\n\r\n        @Override\r\n        public boolean isAssignableFrom(ResolvableType other) {\r\n            Class<?> otherClass = other.resolve();\r\n            return (otherClass != null && (clazz == null || ClassUtils.isAssignable(clazz, otherClass)));\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Class},\n\t * doing assignability checks against the raw class only (analogous to\n\t * {@link Class#isAssignableFrom}, which this serves as a wrapper for).\n\t * <p>For example: {@code ResolvableType.forRawClass(List.class)}.\n\t * @param clazz the class to introspect ({@code null} is semantically\n\t * equivalent to {@code Object.class} for typical use cases here)\n\t * @return a {@code ResolvableType} for the specified class\n\t * @since 4.2\n\t * @see #forClass(Class)\n\t * @see #getRawClass()\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forClass(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified base type\r\n * (interface or base class) with a given implementation class.\r\n * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\r\n * @param baseType the base type (must not be {@code null})\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified base type backed by the\r\n * given implementation class\r\n * @see #forClass(Class)\r\n * @see #forClassWithGenerics(Class, Class...)\r\n */\r\npublic static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {\r\n    Assert.notNull(baseType, \"Base type must not be null\");\r\n    ResolvableType asType = forType(implementationClass).as(baseType);\r\n    return (asType == NONE ? forType(baseType) : asType);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified base type\n\t * (interface or base class) with a given implementation class.\n\t * <p>For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}.\n\t * @param baseType the base type (must not be {@code null})\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified base type backed by the\n\t * given implementation class\n\t * @see #forClass(Class)\n\t * @see #forClassWithGenerics(Class, Class...)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forClassWithGenerics(Class<?>,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\r\n * @param clazz the class (or interface) to introspect\r\n * @param generics the generics of the class\r\n * @return a {@code ResolvableType} for the specific class and generics\r\n * @see #forClassWithGenerics(Class, ResolvableType...)\r\n */\r\npublic static ResolvableType forClassWithGenerics(Class<?> clazz, Class<?>... generics) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(generics, \"Generics array must not be null\");\r\n    ResolvableType[] resolvableGenerics = new ResolvableType[generics.length];\r\n    for (int i = 0; i < generics.length; i++) {\r\n        resolvableGenerics[i] = forClass(generics[i]);\r\n    }\r\n    return forClassWithGenerics(clazz, resolvableGenerics);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@code ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, ResolvableType...)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forClassWithGenerics(Class<?>,ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\r\n * @param clazz the class (or interface) to introspect\r\n * @param generics the generics of the class\r\n * @return a {@code ResolvableType} for the specific class and generics\r\n * @see #forClassWithGenerics(Class, Class...)\r\n */\r\npublic static ResolvableType forClassWithGenerics(Class<?> clazz, @Nullable ResolvableType@Nullable ... generics) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    TypeVariable<?>[] variables = clazz.getTypeParameters();\r\n    if (generics != null) {\r\n        Assert.isTrue(variables.length == generics.length, () -> \"Mismatched number of generics specified for \" + clazz.toGenericString());\r\n    }\r\n    Type[] arguments = new Type[variables.length];\r\n    for (int i = 0; i < variables.length; i++) {\r\n        ResolvableType generic = (generics != null ? generics[i] : null);\r\n        Type argument = (generic != null ? generic.getType() : null);\r\n        arguments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);\r\n    }\r\n    return forType(new SyntheticParameterizedType(clazz, arguments), (generics != null ? new TypeVariablesVariableResolver(variables, generics) : null));\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Class} with pre-declared generics.\n\t * @param clazz the class (or interface) to introspect\n\t * @param generics the generics of the class\n\t * @return a {@code ResolvableType} for the specific class and generics\n\t * @see #forClassWithGenerics(Class, Class...)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forInstance(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified instance. The instance does not\r\n * convey generic information but if it implements {@link ResolvableTypeProvider} a\r\n * more precise {@code ResolvableType} can be used than the simple one based on\r\n * the {@link #forClass(Class) Class instance}.\r\n * @param instance the instance (possibly {@code null})\r\n * @return a {@code ResolvableType} for the specified instance,\r\n * or {@code NONE} for {@code null}\r\n * @since 4.2\r\n * @see ResolvableTypeProvider\r\n */\r\npublic static ResolvableType forInstance(@Nullable Object instance) {\r\n    if (instance instanceof ResolvableTypeProvider resolvableTypeProvider) {\r\n        ResolvableType type = resolvableTypeProvider.getResolvableType();\r\n        if (type != null) {\r\n            return type;\r\n        }\r\n    }\r\n    return (instance != null ? forClass(instance.getClass()) : NONE);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified instance. The instance does not\n\t * convey generic information but if it implements {@link ResolvableTypeProvider} a\n\t * more precise {@code ResolvableType} can be used than the simple one based on\n\t * the {@link #forClass(Class) Class instance}.\n\t * @param instance the instance (possibly {@code null})\n\t * @return a {@code ResolvableType} for the specified instance,\n\t * or {@code NONE} for {@code null}\n\t * @since 4.2\n\t * @see ResolvableTypeProvider\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forField(Field)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Field}.\r\n * @param field the source field\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field, Class)\r\n */\r\npublic static ResolvableType forField(Field field) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    return forType(null, new FieldTypeProvider(field), null);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Field}.\n\t * @param field the source field\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forField(Field,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with a given\r\n * implementation.\r\n * <p>Use this variant when the class that declares the field includes generic\r\n * parameter variables that are satisfied by the implementation class.\r\n * @param field the source field\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, Class<?> implementationClass) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\r\n    return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forField(Field,ResolvableType)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with a given\r\n * implementation.\r\n * <p>Use this variant when the class that declares the field includes generic\r\n * parameter variables that are satisfied by the implementation type.\r\n * @param field the source field\r\n * @param implementationType the implementation type\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    ResolvableType owner = (implementationType != null ? implementationType : NONE);\r\n    owner = owner.as(field.getDeclaringClass());\r\n    return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation type.\n\t * @param field the source field\n\t * @param implementationType the implementation type\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forField(Field,int)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with the\r\n * given nesting level.\r\n * @param field the source field\r\n * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\r\n * generic type; etc)\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, int nestingLevel) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    return forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Field} with the\n\t * given nesting level.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @see #forField(Field)\n\t "
  },
  {
    "entityId": "org.springframework.core.ResolvableType#forField(Field,int,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code ResolvableType} for the specified {@link Field} with a given\r\n * implementation and the given nesting level.\r\n * <p>Use this variant when the class that declares the field includes generic\r\n * parameter variables that are satisfied by the implementation class.\r\n * @param field the source field\r\n * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\r\n * generic type; etc)\r\n * @param implementationClass the implementation class\r\n * @return a {@code ResolvableType} for the specified field\r\n * @see #forField(Field)\r\n */\r\npublic static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {\r\n    Assert.notNull(field, \"Field must not be null\");\r\n    ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());\r\n    return forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);\r\n}",
    "comment": "\n\t * Return a {@code ResolvableType} for the specified {@link Field} with a given\n\t * implementation and the given nesting level.\n\t * <p>Use this variant when the class that declares the field includes generic\n\t * parameter variables that are satisfied by the implementation class.\n\t * @param field the source field\n\t * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested\n\t * generic type; etc)\n\t * @param implementationClass the implementation class\n\t * @return a {@code ResolvableType} for the specified field\n\t * @see #forField(Field)\n\t "
  }
]