[
  {
    "entityId": "org.springframework.util.SoftEntryReference#getNext()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Reference<K, V> getNext() {\r\n    return this.nextReference;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SoftEntryReference#release()",
    "entityType": "method",
    "code": "@Override\r\npublic void release() {\r\n    enqueue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WeakEntryReference",
    "entityType": "class",
    "code": "private final int hash;\n@Nullable\r\nprivate final Reference<K, V> nextReference;\npublic WeakEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next, ReferenceQueue<Entry<K, V>> queue) {\r\n    super(entry, queue);\r\n    this.hash = hash;\r\n    this.nextReference = next;\r\n}\n@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}\n@Override\r\n@Nullable\r\npublic Reference<K, V> getNext() {\r\n    return this.nextReference;\r\n}\n@Override\r\npublic void release() {\r\n    enqueue();\r\n}",
    "comment": "\n\t * Internal {@link Reference} implementation for {@link WeakReference WeakReferences}.\n\t "
  },
  {
    "entityId": "org.springframework.util.WeakEntryReference#getHash()",
    "entityType": "method",
    "code": "@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WeakEntryReference#getNext()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Reference<K, V> getNext() {\r\n    return this.nextReference;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WeakEntryReference#release()",
    "entityType": "method",
    "code": "@Override\r\npublic void release() {\r\n    enqueue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator",
    "entityType": "class",
    "code": "private String threadNamePrefix;\nprivate int threadPriority = Thread.NORM_PRIORITY;\nprivate boolean daemon = false;\n@Nullable\r\nprivate ThreadGroup threadGroup;\nprivate final AtomicInteger threadCount = new AtomicInteger();\n/**\r\n * Create a new CustomizableThreadCreator with default thread name prefix.\r\n */\r\npublic CustomizableThreadCreator() {\r\n    this.threadNamePrefix = getDefaultThreadNamePrefix();\r\n}\n/**\r\n * Create a new CustomizableThreadCreator with the given thread name prefix.\r\n * @param threadNamePrefix the prefix to use for the names of newly created threads\r\n */\r\npublic CustomizableThreadCreator(@Nullable String threadNamePrefix) {\r\n    this.threadNamePrefix = (threadNamePrefix != null ? threadNamePrefix : getDefaultThreadNamePrefix());\r\n}\n/**\r\n * Specify the prefix to use for the names of newly created threads.\r\n * Default is \"SimpleAsyncTaskExecutor-\".\r\n */\r\npublic void setThreadNamePrefix(@Nullable String threadNamePrefix) {\r\n    this.threadNamePrefix = (threadNamePrefix != null ? threadNamePrefix : getDefaultThreadNamePrefix());\r\n}\n/**\r\n * Return the thread name prefix to use for the names of newly\r\n * created threads.\r\n */\r\npublic String getThreadNamePrefix() {\r\n    return this.threadNamePrefix;\r\n}\n/**\r\n * Set the priority of the threads that this factory creates.\r\n * Default is 5.\r\n * @see java.lang.Thread#NORM_PRIORITY\r\n */\r\npublic void setThreadPriority(int threadPriority) {\r\n    this.threadPriority = threadPriority;\r\n}\n/**\r\n * Return the priority of the threads that this factory creates.\r\n */\r\npublic int getThreadPriority() {\r\n    return this.threadPriority;\r\n}\n/**\r\n * Set whether this factory is supposed to create daemon threads,\r\n * just executing as long as the application itself is running.\r\n * <p>Default is \"false\": Concrete factories usually support explicit cancelling.\r\n * Hence, if the application shuts down, Runnables will by default finish their\r\n * execution.\r\n * <p>Specify \"true\" for eager shutdown of threads which still actively execute\r\n * a {@link Runnable} at the time that the application itself shuts down.\r\n * @see java.lang.Thread#setDaemon\r\n */\r\npublic void setDaemon(boolean daemon) {\r\n    this.daemon = daemon;\r\n}\n/**\r\n * Return whether this factory should create daemon threads.\r\n */\r\npublic boolean isDaemon() {\r\n    return this.daemon;\r\n}\n/**\r\n * Specify the name of the thread group that threads should be created in.\r\n * @see #setThreadGroup\r\n */\r\npublic void setThreadGroupName(String name) {\r\n    this.threadGroup = new ThreadGroup(name);\r\n}\n/**\r\n * Specify the thread group that threads should be created in.\r\n * @see #setThreadGroupName\r\n */\r\npublic void setThreadGroup(@Nullable ThreadGroup threadGroup) {\r\n    this.threadGroup = threadGroup;\r\n}\n/**\r\n * Return the thread group that threads should be created in\r\n * (or {@code null} for the default group).\r\n */\r\n@Nullable\r\npublic ThreadGroup getThreadGroup() {\r\n    return this.threadGroup;\r\n}\n/**\r\n * Template method for the creation of a new {@link Thread}.\r\n * <p>The default implementation creates a new Thread for the given\r\n * {@link Runnable}, applying an appropriate thread name.\r\n * @param runnable the Runnable to execute\r\n * @see #nextThreadName()\r\n */\r\npublic Thread createThread(Runnable runnable) {\r\n    Thread thread = new Thread(getThreadGroup(), runnable, nextThreadName());\r\n    thread.setPriority(getThreadPriority());\r\n    thread.setDaemon(isDaemon());\r\n    return thread;\r\n}\n/**\r\n * Return the thread name to use for a newly created {@link Thread}.\r\n * <p>The default implementation returns the specified thread name prefix\r\n * with an increasing thread count appended: for example, \"SimpleAsyncTaskExecutor-0\".\r\n * @see #getThreadNamePrefix()\r\n */\r\nprotected String nextThreadName() {\r\n    return getThreadNamePrefix() + this.threadCount.incrementAndGet();\r\n}\n/**\r\n * Build the default thread name prefix for this factory.\r\n * @return the default thread name prefix (never {@code null})\r\n */\r\nprotected String getDefaultThreadNamePrefix() {\r\n    return ClassUtils.getShortName(getClass()) + \"-\";\r\n}",
    "comment": "\n * Simple customizable helper class for creating new {@link Thread} instances.\n * Provides various bean properties: thread name prefix, thread priority, etc.\n *\n * <p>Serves as base class for thread factories such as\n * {@link org.springframework.scheduling.concurrent.CustomizableThreadFactory}.\n *\n * @author Juergen Hoeller\n * @since 2.0.3\n * @see org.springframework.scheduling.concurrent.CustomizableThreadFactory\n "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the prefix to use for the names of newly created threads.\r\n * Default is \"SimpleAsyncTaskExecutor-\".\r\n */\r\npublic void setThreadNamePrefix(@Nullable String threadNamePrefix) {\r\n    this.threadNamePrefix = (threadNamePrefix != null ? threadNamePrefix : getDefaultThreadNamePrefix());\r\n}",
    "comment": "\n\t * Specify the prefix to use for the names of newly created threads.\n\t * Default is \"SimpleAsyncTaskExecutor-\".\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#getThreadNamePrefix()",
    "entityType": "method",
    "code": "/**\r\n * Return the thread name prefix to use for the names of newly\r\n * created threads.\r\n */\r\npublic String getThreadNamePrefix() {\r\n    return this.threadNamePrefix;\r\n}",
    "comment": "\n\t * Return the thread name prefix to use for the names of newly\n\t * created threads.\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
    "entityType": "method",
    "code": "/**\r\n * Set the priority of the threads that this factory creates.\r\n * Default is 5.\r\n * @see java.lang.Thread#NORM_PRIORITY\r\n */\r\npublic void setThreadPriority(int threadPriority) {\r\n    this.threadPriority = threadPriority;\r\n}",
    "comment": "\n\t * Set the priority of the threads that this factory creates.\n\t * Default is 5.\n\t * @see java.lang.Thread#NORM_PRIORITY\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#getThreadPriority()",
    "entityType": "method",
    "code": "/**\r\n * Return the priority of the threads that this factory creates.\r\n */\r\npublic int getThreadPriority() {\r\n    return this.threadPriority;\r\n}",
    "comment": "\n\t * Return the priority of the threads that this factory creates.\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Set whether this factory is supposed to create daemon threads,\r\n * just executing as long as the application itself is running.\r\n * <p>Default is \"false\": Concrete factories usually support explicit cancelling.\r\n * Hence, if the application shuts down, Runnables will by default finish their\r\n * execution.\r\n * <p>Specify \"true\" for eager shutdown of threads which still actively execute\r\n * a {@link Runnable} at the time that the application itself shuts down.\r\n * @see java.lang.Thread#setDaemon\r\n */\r\npublic void setDaemon(boolean daemon) {\r\n    this.daemon = daemon;\r\n}",
    "comment": "\n\t * Set whether this factory is supposed to create daemon threads,\n\t * just executing as long as the application itself is running.\n\t * <p>Default is \"false\": Concrete factories usually support explicit cancelling.\n\t * Hence, if the application shuts down, Runnables will by default finish their\n\t * execution.\n\t * <p>Specify \"true\" for eager shutdown of threads which still actively execute\n\t * a {@link Runnable} at the time that the application itself shuts down.\n\t * @see java.lang.Thread#setDaemon\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#isDaemon()",
    "entityType": "method",
    "code": "/**\r\n * Return whether this factory should create daemon threads.\r\n */\r\npublic boolean isDaemon() {\r\n    return this.daemon;\r\n}",
    "comment": "\n\t * Return whether this factory should create daemon threads.\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the name of the thread group that threads should be created in.\r\n * @see #setThreadGroup\r\n */\r\npublic void setThreadGroupName(String name) {\r\n    this.threadGroup = new ThreadGroup(name);\r\n}",
    "comment": "\n\t * Specify the name of the thread group that threads should be created in.\n\t * @see #setThreadGroup\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
    "entityType": "method",
    "code": "/**\r\n * Specify the thread group that threads should be created in.\r\n * @see #setThreadGroupName\r\n */\r\npublic void setThreadGroup(@Nullable ThreadGroup threadGroup) {\r\n    this.threadGroup = threadGroup;\r\n}",
    "comment": "\n\t * Specify the thread group that threads should be created in.\n\t * @see #setThreadGroupName\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#getThreadGroup()",
    "entityType": "method",
    "code": "/**\r\n * Return the thread group that threads should be created in\r\n * (or {@code null} for the default group).\r\n */\r\n@Nullable\r\npublic ThreadGroup getThreadGroup() {\r\n    return this.threadGroup;\r\n}",
    "comment": "\n\t * Return the thread group that threads should be created in\n\t * (or {@code null} for the default group).\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#createThread(Runnable)",
    "entityType": "method",
    "code": "/**\r\n * Template method for the creation of a new {@link Thread}.\r\n * <p>The default implementation creates a new Thread for the given\r\n * {@link Runnable}, applying an appropriate thread name.\r\n * @param runnable the Runnable to execute\r\n * @see #nextThreadName()\r\n */\r\npublic Thread createThread(Runnable runnable) {\r\n    Thread thread = new Thread(getThreadGroup(), runnable, nextThreadName());\r\n    thread.setPriority(getThreadPriority());\r\n    thread.setDaemon(isDaemon());\r\n    return thread;\r\n}",
    "comment": "\n\t * Template method for the creation of a new {@link Thread}.\n\t * <p>The default implementation creates a new Thread for the given\n\t * {@link Runnable}, applying an appropriate thread name.\n\t * @param runnable the Runnable to execute\n\t * @see #nextThreadName()\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
    "entityType": "method",
    "code": "/**\r\n * Return the thread name to use for a newly created {@link Thread}.\r\n * <p>The default implementation returns the specified thread name prefix\r\n * with an increasing thread count appended: for example, \"SimpleAsyncTaskExecutor-0\".\r\n * @see #getThreadNamePrefix()\r\n */\r\nprotected String nextThreadName() {\r\n    return getThreadNamePrefix() + this.threadCount.incrementAndGet();\r\n}",
    "comment": "\n\t * Return the thread name to use for a newly created {@link Thread}.\n\t * <p>The default implementation returns the specified thread name prefix\n\t * with an increasing thread count appended: for example, \"SimpleAsyncTaskExecutor-0\".\n\t * @see #getThreadNamePrefix()\n\t "
  },
  {
    "entityId": "org.springframework.util.CustomizableThreadCreator#getDefaultThreadNamePrefix()",
    "entityType": "method",
    "code": "/**\r\n * Build the default thread name prefix for this factory.\r\n * @return the default thread name prefix (never {@code null})\r\n */\r\nprotected String getDefaultThreadNamePrefix() {\r\n    return ClassUtils.getShortName(getClass()) + \"-\";\r\n}",
    "comment": "\n\t * Build the default thread name prefix for this factory.\n\t * @return the default thread name prefix (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister",
    "entityType": "class",
    "code": "/**\r\n * A convenient constant for a default {@code DefaultPropertiesPersister} instance,\r\n * as used in Spring's common resource support.\r\n * @since 6.0\r\n */\r\npublic static final DefaultPropertiesPersister INSTANCE = new DefaultPropertiesPersister();\n@Override\r\npublic void load(Properties props, InputStream is) throws IOException {\r\n    props.load(is);\r\n}\n@Override\r\npublic void load(Properties props, Reader reader) throws IOException {\r\n    props.load(reader);\r\n}\n@Override\r\npublic void store(Properties props, OutputStream os, String header) throws IOException {\r\n    props.store(os, header);\r\n}\n@Override\r\npublic void store(Properties props, Writer writer, String header) throws IOException {\r\n    props.store(writer, header);\r\n}\n@Override\r\npublic void loadFromXml(Properties props, InputStream is) throws IOException {\r\n    props.loadFromXML(is);\r\n}\n@Override\r\npublic void storeToXml(Properties props, OutputStream os, String header) throws IOException {\r\n    props.storeToXML(os, header);\r\n}\n@Override\r\npublic void storeToXml(Properties props, OutputStream os, String header, String encoding) throws IOException {\r\n    props.storeToXML(os, header, encoding);\r\n}",
    "comment": "\n * Default implementation of the {@link PropertiesPersister} interface.\n * Follows the native parsing of {@code java.util.Properties}.\n *\n * <p>Allows for reading from any Reader and writing to any Writer, for example\n * to specify a charset for a properties file. This is a capability that standard\n * {@code java.util.Properties} unfortunately lacked up until JDK 5:\n * You were only able to load files using the ISO-8859-1 charset there.\n *\n * <p>Loading from and storing to a stream delegates to {@code Properties.load}\n * and {@code Properties.store}, respectively, to be fully compatible with\n * the Unicode conversion as implemented by the JDK Properties class. As of JDK 6,\n * {@code Properties.load/store} is also used for readers/writers, effectively\n * turning this class into a plain backwards compatibility adapter.\n *\n * <p>The persistence code that works with Reader/Writer follows the JDK's parsing\n * strategy but does not implement Unicode conversion, because the Reader/Writer\n * should already apply proper decoding/encoding of characters. If you prefer\n * to escape unicode characters in your properties files, do <i>not</i> specify\n * an encoding for a Reader/Writer (like ReloadableResourceBundleMessageSource's\n * \"defaultEncoding\" and \"fileEncodings\" properties).\n *\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @since 10.03.2004\n * @see java.util.Properties\n * @see java.util.Properties#load\n * @see java.util.Properties#store\n "
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#load(Properties,InputStream)",
    "entityType": "method",
    "code": "@Override\r\npublic void load(Properties props, InputStream is) throws IOException {\r\n    props.load(is);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#load(Properties,Reader)",
    "entityType": "method",
    "code": "@Override\r\npublic void load(Properties props, Reader reader) throws IOException {\r\n    props.load(reader);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#store(Properties,OutputStream,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void store(Properties props, OutputStream os, String header) throws IOException {\r\n    props.store(os, header);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#store(Properties,Writer,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void store(Properties props, Writer writer, String header) throws IOException {\r\n    props.store(writer, header);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#loadFromXml(Properties,InputStream)",
    "entityType": "method",
    "code": "@Override\r\npublic void loadFromXml(Properties props, InputStream is) throws IOException {\r\n    props.loadFromXML(is);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#storeToXml(Properties,OutputStream,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void storeToXml(Properties props, OutputStream os, String header) throws IOException {\r\n    props.storeToXML(os, header);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultPropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void storeToXml(Properties props, OutputStream os, String header, String encoding) throws IOException {\r\n    props.storeToXML(os, header, encoding);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils",
    "entityType": "class",
    "code": "private static final String MD5_ALGORITHM_NAME = \"MD5\";\nprivate static final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n/**\r\n * Calculate the MD5 digest of the given bytes.\r\n * @param bytes the bytes to calculate the digest over\r\n * @return the digest\r\n */\r\npublic static byte[] md5Digest(byte[] bytes) {\r\n    return digest(MD5_ALGORITHM_NAME, bytes);\r\n}\n/**\r\n * Calculate the MD5 digest of the given stream.\r\n * <p>This method does <strong>not</strong> close the input stream.\r\n * @param inputStream the InputStream to calculate the digest over\r\n * @return the digest\r\n * @since 4.2\r\n */\r\npublic static byte[] md5Digest(InputStream inputStream) throws IOException {\r\n    return digest(MD5_ALGORITHM_NAME, inputStream);\r\n}\n/**\r\n * Return a hexadecimal string representation of the MD5 digest of the given bytes.\r\n * @param bytes the bytes to calculate the digest over\r\n * @return a hexadecimal digest string\r\n */\r\npublic static String md5DigestAsHex(byte[] bytes) {\r\n    return digestAsHexString(MD5_ALGORITHM_NAME, bytes);\r\n}\n/**\r\n * Return a hexadecimal string representation of the MD5 digest of the given stream.\r\n * <p>This method does <strong>not</strong> close the input stream.\r\n * @param inputStream the InputStream to calculate the digest over\r\n * @return a hexadecimal digest string\r\n * @since 4.2\r\n */\r\npublic static String md5DigestAsHex(InputStream inputStream) throws IOException {\r\n    return digestAsHexString(MD5_ALGORITHM_NAME, inputStream);\r\n}\n/**\r\n * Append a hexadecimal string representation of the MD5 digest of the given\r\n * bytes to the given {@link StringBuilder}.\r\n * @param bytes the bytes to calculate the digest over\r\n * @param builder the string builder to append the digest to\r\n * @return the given string builder\r\n */\r\npublic static StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder) {\r\n    return appendDigestAsHex(MD5_ALGORITHM_NAME, bytes, builder);\r\n}\n/**\r\n * Append a hexadecimal string representation of the MD5 digest of the given\r\n * inputStream to the given {@link StringBuilder}.\r\n * <p>This method does <strong>not</strong> close the input stream.\r\n * @param inputStream the inputStream to calculate the digest over\r\n * @param builder the string builder to append the digest to\r\n * @return the given string builder\r\n * @since 4.2\r\n */\r\npublic static StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder) throws IOException {\r\n    return appendDigestAsHex(MD5_ALGORITHM_NAME, inputStream, builder);\r\n}\n/**\r\n * Create a new {@link MessageDigest} with the given algorithm.\r\n * <p>Necessary because {@code MessageDigest} is not thread-safe.\r\n */\r\nprivate static MessageDigest getDigest(String algorithm) {\r\n    try {\r\n        return MessageDigest.getInstance(algorithm);\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new IllegalStateException(\"Could not find MessageDigest with algorithm \\\"\" + algorithm + \"\\\"\", ex);\r\n    }\r\n}\nprivate static byte[] digest(String algorithm, byte[] bytes) {\r\n    return getDigest(algorithm).digest(bytes);\r\n}\nprivate static byte[] digest(String algorithm, InputStream inputStream) throws IOException {\r\n    MessageDigest messageDigest = getDigest(algorithm);\r\n    if (inputStream instanceof UpdateMessageDigestInputStream digestInputStream) {\r\n        digestInputStream.updateMessageDigest(messageDigest);\r\n        return messageDigest.digest();\r\n    } else {\r\n        final byte[] buffer = new byte[StreamUtils.BUFFER_SIZE];\r\n        int bytesRead;\r\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\r\n            messageDigest.update(buffer, 0, bytesRead);\r\n        }\r\n        return messageDigest.digest();\r\n    }\r\n}\nprivate static String digestAsHexString(String algorithm, byte[] bytes) {\r\n    char[] hexDigest = digestAsHexChars(algorithm, bytes);\r\n    return new String(hexDigest);\r\n}\nprivate static String digestAsHexString(String algorithm, InputStream inputStream) throws IOException {\r\n    char[] hexDigest = digestAsHexChars(algorithm, inputStream);\r\n    return new String(hexDigest);\r\n}\nprivate static StringBuilder appendDigestAsHex(String algorithm, byte[] bytes, StringBuilder builder) {\r\n    char[] hexDigest = digestAsHexChars(algorithm, bytes);\r\n    return builder.append(hexDigest);\r\n}\nprivate static StringBuilder appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder) throws IOException {\r\n    char[] hexDigest = digestAsHexChars(algorithm, inputStream);\r\n    return builder.append(hexDigest);\r\n}\nprivate static char[] digestAsHexChars(String algorithm, byte[] bytes) {\r\n    byte[] digest = digest(algorithm, bytes);\r\n    return encodeHex(digest);\r\n}\nprivate static char[] digestAsHexChars(String algorithm, InputStream inputStream) throws IOException {\r\n    byte[] digest = digest(algorithm, inputStream);\r\n    return encodeHex(digest);\r\n}\nprivate static char[] encodeHex(byte[] bytes) {\r\n    char[] chars = new char[32];\r\n    for (int i = 0; i < chars.length; i = i + 2) {\r\n        byte b = bytes[i / 2];\r\n        chars[i] = HEX_CHARS[(b >>> 0x4) & 0xf];\r\n        chars[i + 1] = HEX_CHARS[b & 0xf];\r\n    }\r\n    return chars;\r\n}",
    "comment": "\n * Miscellaneous methods for calculating digests.\n *\n * <p>Mainly for internal use within the framework; consider\n * <a href=\"https://commons.apache.org/codec/\">Apache Commons Codec</a>\n * for a more comprehensive suite of digest utilities.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Craig Andrews\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#md5Digest(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Calculate the MD5 digest of the given bytes.\r\n * @param bytes the bytes to calculate the digest over\r\n * @return the digest\r\n */\r\npublic static byte[] md5Digest(byte[] bytes) {\r\n    return digest(MD5_ALGORITHM_NAME, bytes);\r\n}",
    "comment": "\n\t * Calculate the MD5 digest of the given bytes.\n\t * @param bytes the bytes to calculate the digest over\n\t * @return the digest\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Calculate the MD5 digest of the given stream.\r\n * <p>This method does <strong>not</strong> close the input stream.\r\n * @param inputStream the InputStream to calculate the digest over\r\n * @return the digest\r\n * @since 4.2\r\n */\r\npublic static byte[] md5Digest(InputStream inputStream) throws IOException {\r\n    return digest(MD5_ALGORITHM_NAME, inputStream);\r\n}",
    "comment": "\n\t * Calculate the MD5 digest of the given stream.\n\t * <p>This method does <strong>not</strong> close the input stream.\n\t * @param inputStream the InputStream to calculate the digest over\n\t * @return the digest\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#md5DigestAsHex(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hexadecimal string representation of the MD5 digest of the given bytes.\r\n * @param bytes the bytes to calculate the digest over\r\n * @return a hexadecimal digest string\r\n */\r\npublic static String md5DigestAsHex(byte[] bytes) {\r\n    return digestAsHexString(MD5_ALGORITHM_NAME, bytes);\r\n}",
    "comment": "\n\t * Return a hexadecimal string representation of the MD5 digest of the given bytes.\n\t * @param bytes the bytes to calculate the digest over\n\t * @return a hexadecimal digest string\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Return a hexadecimal string representation of the MD5 digest of the given stream.\r\n * <p>This method does <strong>not</strong> close the input stream.\r\n * @param inputStream the InputStream to calculate the digest over\r\n * @return a hexadecimal digest string\r\n * @since 4.2\r\n */\r\npublic static String md5DigestAsHex(InputStream inputStream) throws IOException {\r\n    return digestAsHexString(MD5_ALGORITHM_NAME, inputStream);\r\n}",
    "comment": "\n\t * Return a hexadecimal string representation of the MD5 digest of the given stream.\n\t * <p>This method does <strong>not</strong> close the input stream.\n\t * @param inputStream the InputStream to calculate the digest over\n\t * @return a hexadecimal digest string\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(byte[],StringBuilder)",
    "entityType": "method",
    "code": "/**\r\n * Append a hexadecimal string representation of the MD5 digest of the given\r\n * bytes to the given {@link StringBuilder}.\r\n * @param bytes the bytes to calculate the digest over\r\n * @param builder the string builder to append the digest to\r\n * @return the given string builder\r\n */\r\npublic static StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder) {\r\n    return appendDigestAsHex(MD5_ALGORITHM_NAME, bytes, builder);\r\n}",
    "comment": "\n\t * Append a hexadecimal string representation of the MD5 digest of the given\n\t * bytes to the given {@link StringBuilder}.\n\t * @param bytes the bytes to calculate the digest over\n\t * @param builder the string builder to append the digest to\n\t * @return the given string builder\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(InputStream,StringBuilder)",
    "entityType": "method",
    "code": "/**\r\n * Append a hexadecimal string representation of the MD5 digest of the given\r\n * inputStream to the given {@link StringBuilder}.\r\n * <p>This method does <strong>not</strong> close the input stream.\r\n * @param inputStream the inputStream to calculate the digest over\r\n * @param builder the string builder to append the digest to\r\n * @return the given string builder\r\n * @since 4.2\r\n */\r\npublic static StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder) throws IOException {\r\n    return appendDigestAsHex(MD5_ALGORITHM_NAME, inputStream, builder);\r\n}",
    "comment": "\n\t * Append a hexadecimal string representation of the MD5 digest of the given\n\t * inputStream to the given {@link StringBuilder}.\n\t * <p>This method does <strong>not</strong> close the input stream.\n\t * @param inputStream the inputStream to calculate the digest over\n\t * @param builder the string builder to append the digest to\n\t * @return the given string builder\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#getDigest(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MessageDigest} with the given algorithm.\r\n * <p>Necessary because {@code MessageDigest} is not thread-safe.\r\n */\r\nprivate static MessageDigest getDigest(String algorithm) {\r\n    try {\r\n        return MessageDigest.getInstance(algorithm);\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new IllegalStateException(\"Could not find MessageDigest with algorithm \\\"\" + algorithm + \"\\\"\", ex);\r\n    }\r\n}",
    "comment": "\n\t * Create a new {@link MessageDigest} with the given algorithm.\n\t * <p>Necessary because {@code MessageDigest} is not thread-safe.\n\t "
  },
  {
    "entityId": "org.springframework.util.DigestUtils#digest(String,byte[])",
    "entityType": "method",
    "code": "private static byte[] digest(String algorithm, byte[] bytes) {\r\n    return getDigest(algorithm).digest(bytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#digest(String,InputStream)",
    "entityType": "method",
    "code": "private static byte[] digest(String algorithm, InputStream inputStream) throws IOException {\r\n    MessageDigest messageDigest = getDigest(algorithm);\r\n    if (inputStream instanceof UpdateMessageDigestInputStream digestInputStream) {\r\n        digestInputStream.updateMessageDigest(messageDigest);\r\n        return messageDigest.digest();\r\n    } else {\r\n        final byte[] buffer = new byte[StreamUtils.BUFFER_SIZE];\r\n        int bytesRead;\r\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\r\n            messageDigest.update(buffer, 0, bytesRead);\r\n        }\r\n        return messageDigest.digest();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#digestAsHexString(String,byte[])",
    "entityType": "method",
    "code": "private static String digestAsHexString(String algorithm, byte[] bytes) {\r\n    char[] hexDigest = digestAsHexChars(algorithm, bytes);\r\n    return new String(hexDigest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
    "entityType": "method",
    "code": "private static String digestAsHexString(String algorithm, InputStream inputStream) throws IOException {\r\n    char[] hexDigest = digestAsHexChars(algorithm, inputStream);\r\n    return new String(hexDigest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#appendDigestAsHex(String,byte[],StringBuilder)",
    "entityType": "method",
    "code": "private static StringBuilder appendDigestAsHex(String algorithm, byte[] bytes, StringBuilder builder) {\r\n    char[] hexDigest = digestAsHexChars(algorithm, bytes);\r\n    return builder.append(hexDigest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#appendDigestAsHex(String,InputStream,StringBuilder)",
    "entityType": "method",
    "code": "private static StringBuilder appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder) throws IOException {\r\n    char[] hexDigest = digestAsHexChars(algorithm, inputStream);\r\n    return builder.append(hexDigest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#digestAsHexChars(String,byte[])",
    "entityType": "method",
    "code": "private static char[] digestAsHexChars(String algorithm, byte[] bytes) {\r\n    byte[] digest = digest(algorithm, bytes);\r\n    return encodeHex(digest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
    "entityType": "method",
    "code": "private static char[] digestAsHexChars(String algorithm, InputStream inputStream) throws IOException {\r\n    byte[] digest = digest(algorithm, inputStream);\r\n    return encodeHex(digest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtils#encodeHex(byte[])",
    "entityType": "method",
    "code": "private static char[] encodeHex(byte[] bytes) {\r\n    char[] chars = new char[32];\r\n    for (int i = 0; i < chars.length; i = i + 2) {\r\n        byte b = bytes[i / 2];\r\n        chars[i] = HEX_CHARS[(b >>> 0x4) & 0xf];\r\n        chars[i + 1] = HEX_CHARS[b & 0xf];\r\n    }\r\n    return chars;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ErrorHandler",
    "entityType": "class",
    "code": "/**\r\n * Handle the given error, possibly rethrowing it as a fatal exception.\r\n */\r\nvoid handleError(Throwable t);",
    "comment": "\n * A strategy for handling errors. This is especially useful for handling\n * errors that occur during asynchronous execution of tasks that have been\n * submitted to a TaskScheduler. In such cases, it may not be possible to\n * throw the error to the original caller.\n *\n * @author Mark Fisher\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.util.ErrorHandler#handleError(Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Handle the given error, possibly rethrowing it as a fatal exception.\r\n */\r\nvoid handleError(Throwable t);",
    "comment": "\n\t * Handle the given error, possibly rethrowing it as a fatal exception.\n\t "
  },
  {
    "entityId": "org.springframework.util.ExceptionTypeFilter",
    "entityType": "class",
    "code": "public ExceptionTypeFilter(Collection<? extends Class<? extends Throwable>> includes, Collection<? extends Class<? extends Throwable>> excludes, boolean matchIfEmpty) {\r\n    super(includes, excludes, matchIfEmpty);\r\n}\n@Override\r\nprotected boolean match(Class<? extends Throwable> instance, Class<? extends Throwable> candidate) {\r\n    return candidate.isAssignableFrom(instance);\r\n}",
    "comment": "\n * An {@link InstanceFilter} implementation that handles exception types. A type\n * will match against a given candidate if it is assignable to that candidate.\n *\n * @author Stephane Nicoll\n * @since 4.1\n "
  },
  {
    "entityId": "org.springframework.util.ExceptionTypeFilter#match(Class<? extends Throwable>,Class<? extends Throwable>)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean match(Class<? extends Throwable> instance, Class<? extends Throwable> candidate) {\r\n    return candidate.isAssignableFrom(instance);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream",
    "entityType": "class",
    "code": "private static final int DEFAULT_BLOCK_SIZE = 256;\n// The buffers used to store the content bytes\r\nprivate final Deque<byte[]> buffers = new ArrayDeque<>();\n// The size, in bytes, to use when allocating the first byte[]\r\nprivate final int initialBlockSize;\n// The size, in bytes, to use when allocating the next byte[]\r\nprivate int nextBlockSize = 0;\n// The number of bytes in previous buffers.\r\n// (The number of bytes in the current buffer is in 'index'.)\r\nprivate int alreadyBufferedSize = 0;\n// The index in the byte[] found at buffers.getLast() to be written next\r\nprivate int index = 0;\n// Is the stream closed?\r\nprivate boolean closed = false;\n/**\r\n * Create a new {@code FastByteArrayOutputStream} with the default initial\r\n * capacity of 256 bytes.\r\n */\r\npublic FastByteArrayOutputStream() {\r\n    this(DEFAULT_BLOCK_SIZE);\r\n}\n/**\r\n * Create a new {@code FastByteArrayOutputStream} with the specified initial\r\n * capacity.\r\n * @param initialBlockSize the initial buffer size in bytes\r\n */\r\npublic FastByteArrayOutputStream(int initialBlockSize) {\r\n    Assert.isTrue(initialBlockSize > 0, \"Initial block size must be greater than 0\");\r\n    this.initialBlockSize = initialBlockSize;\r\n    this.nextBlockSize = initialBlockSize;\r\n}\n// Overridden methods\r\n@Override\r\npublic void write(int datum) throws IOException {\r\n    if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n    if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\r\n        addBuffer(1);\r\n    }\r\n    // store the byte\r\n    this.buffers.getLast()[this.index++] = (byte) datum;\r\n}\n@Override\r\npublic void write(byte[] data, int offset, int length) throws IOException {\r\n    if (offset < 0 || offset + length > data.length || length < 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    } else {\r\n        if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\r\n            addBuffer(length);\r\n        }\r\n        if (this.index + length > this.buffers.getLast().length) {\r\n            int pos = offset;\r\n            do {\r\n                if (this.index == this.buffers.getLast().length) {\r\n                    addBuffer(length);\r\n                }\r\n                int copyLength = this.buffers.getLast().length - this.index;\r\n                if (length < copyLength) {\r\n                    copyLength = length;\r\n                }\r\n                System.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);\r\n                pos += copyLength;\r\n                this.index += copyLength;\r\n                length -= copyLength;\r\n            } while (length > 0);\r\n        } else {\r\n            // copy in the sub-array\r\n            System.arraycopy(data, offset, this.buffers.getLast(), this.index, length);\r\n            this.index += length;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void close() {\r\n    this.closed = true;\r\n}\n/**\r\n * Convert this stream's contents to a string by decoding the bytes using the\r\n * platform's default character set. The length of the new {@code String}\r\n * is a function of the character set, and hence may not be equal to the\r\n * size of the buffers.\r\n * <p>This method always replaces malformed-input and unmappable-character\r\n * sequences with the default replacement string for the platform's\r\n * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\r\n * class should be used when more control over the decoding process is\r\n * required.\r\n * @return a String decoded from this stream's contents\r\n * @see #toString(Charset)\r\n */\r\n@Override\r\npublic String toString() {\r\n    return toString(Charset.defaultCharset());\r\n}\n/**\r\n * Convert this stream's contents to a string by decoding the bytes using the\r\n * specified {@link Charset}.\r\n * @param charset the {@link Charset} to use to decode the bytes\r\n * @return a String decoded from this stream's contents\r\n * @since 6.1.2\r\n * @see #toString()\r\n */\r\npublic String toString(Charset charset) {\r\n    if (size() == 0) {\r\n        return \"\";\r\n    }\r\n    if (this.buffers.size() == 1) {\r\n        return new String(this.buffers.getFirst(), 0, this.index, charset);\r\n    }\r\n    return new String(toByteArrayUnsafe(), charset);\r\n}\n// Custom methods\r\n/**\r\n * Return the number of bytes stored in this {@code FastByteArrayOutputStream}.\r\n */\r\npublic int size() {\r\n    return (this.alreadyBufferedSize + this.index);\r\n}\n/**\r\n * Convert this stream's contents to a byte array and return the byte array.\r\n * <p>Also replaces the internal structures with the byte array to\r\n * conserve memory: if the byte array is being created anyway, we might\r\n * as well as use it. This approach also means that if this method is\r\n * called twice without any writes in the interim, the second call is\r\n * a no-op.\r\n * <p>This method is \"unsafe\" as it returns the internal buffer.\r\n * Callers should not modify the returned buffer.\r\n * @return the current contents of this stream as a byte array\r\n * @see #size()\r\n * @see #toByteArray()\r\n */\r\npublic byte[] toByteArrayUnsafe() {\r\n    int totalSize = size();\r\n    if (totalSize == 0) {\r\n        return new byte[0];\r\n    }\r\n    resize(totalSize);\r\n    return this.buffers.getFirst();\r\n}\n/**\r\n * Create a newly allocated byte array.\r\n * <p>Its size is the current size of this output stream, and it will\r\n * contain the valid contents of the internal buffers.\r\n * @return the current contents of this stream as a byte array\r\n * @see #size()\r\n * @see #toByteArrayUnsafe()\r\n */\r\npublic byte[] toByteArray() {\r\n    byte[] bytesUnsafe = toByteArrayUnsafe();\r\n    return bytesUnsafe.clone();\r\n}\n/**\r\n * Reset the contents of this {@code FastByteArrayOutputStream}.\r\n * <p>All currently accumulated output in the output stream is discarded.\r\n * The output stream can be used again.\r\n */\r\npublic void reset() {\r\n    this.buffers.clear();\r\n    this.nextBlockSize = this.initialBlockSize;\r\n    this.closed = false;\r\n    this.index = 0;\r\n    this.alreadyBufferedSize = 0;\r\n}\n/**\r\n * Get an {@link InputStream} to retrieve the contents of this\r\n * {@code FastByteArrayOutputStream}.\r\n * <p>Note that if any methods are called on this {@code FastByteArrayOutputStream}\r\n * (including, but not limited to, any of the write methods, {@link #reset()},\r\n * {@link #toByteArray()}, and {@link #toByteArrayUnsafe()}) then the\r\n * {@code InputStream}'s behavior is undefined.\r\n * @return {@code  InputStream} of the contents of this {@code FastByteArrayOutputStream}\r\n */\r\npublic InputStream getInputStream() {\r\n    return new FastByteArrayInputStream(this);\r\n}\n/**\r\n * Write the contents of this {@code FastByteArrayOutputStream} to the given\r\n * {@link OutputStream}.\r\n * @param out the OutputStream to write to\r\n */\r\npublic void writeTo(OutputStream out) throws IOException {\r\n    Iterator<byte[]> it = this.buffers.iterator();\r\n    while (it.hasNext()) {\r\n        byte[] bytes = it.next();\r\n        if (it.hasNext()) {\r\n            out.write(bytes, 0, bytes.length);\r\n        } else {\r\n            out.write(bytes, 0, this.index);\r\n        }\r\n    }\r\n}\n/**\r\n * Resize the internal buffer size to the specified capacity.\r\n * @param targetCapacity the desired size of the buffer\r\n * @throws IllegalArgumentException if the given capacity is smaller than\r\n * the actual size of the content stored in the buffer already\r\n * @see FastByteArrayOutputStream#size()\r\n */\r\npublic void resize(int targetCapacity) {\r\n    Assert.isTrue(targetCapacity >= size(), \"New capacity must not be smaller than current size\");\r\n    if (this.buffers.peekFirst() == null) {\r\n        this.nextBlockSize = targetCapacity - size();\r\n    } else if (size() == targetCapacity && this.buffers.getFirst().length == targetCapacity) {\r\n        // do nothing - already at the targetCapacity\r\n    } else {\r\n        int totalSize = size();\r\n        byte[] data = new byte[targetCapacity];\r\n        int pos = 0;\r\n        Iterator<byte[]> it = this.buffers.iterator();\r\n        while (it.hasNext()) {\r\n            byte[] bytes = it.next();\r\n            if (it.hasNext()) {\r\n                System.arraycopy(bytes, 0, data, pos, bytes.length);\r\n                pos += bytes.length;\r\n            } else {\r\n                System.arraycopy(bytes, 0, data, pos, this.index);\r\n            }\r\n        }\r\n        this.buffers.clear();\r\n        this.buffers.add(data);\r\n        this.index = totalSize;\r\n        this.alreadyBufferedSize = 0;\r\n    }\r\n}\n/**\r\n * Create a new buffer and store it in the ArrayDeque.\r\n * <p>Adds a new buffer that can store at least {@code minCapacity} bytes.\r\n */\r\nprivate void addBuffer(int minCapacity) {\r\n    if (this.buffers.peekLast() != null) {\r\n        this.alreadyBufferedSize += this.index;\r\n        this.index = 0;\r\n    }\r\n    if (this.nextBlockSize < minCapacity) {\r\n        this.nextBlockSize = nextPowerOf2(minCapacity);\r\n    }\r\n    this.buffers.add(new byte[this.nextBlockSize]);\r\n    // block size doubles each time\r\n    this.nextBlockSize *= 2;\r\n}\n/**\r\n * Get the next power of 2 of a number (ex, the next power of 2 of 119 is 128).\r\n */\r\nprivate static int nextPowerOf2(int val) {\r\n    val--;\r\n    val = (val >> 1) | val;\r\n    val = (val >> 2) | val;\r\n    val = (val >> 4) | val;\r\n    val = (val >> 8) | val;\r\n    val = (val >> 16) | val;\r\n    val++;\r\n    return val;\r\n}\n/**\r\n * An implementation of {@link java.io.InputStream} that reads from a given\r\n * {@code FastByteArrayOutputStream}.\r\n */\r\nprivate static final class FastByteArrayInputStream extends UpdateMessageDigestInputStream {\r\n\r\n    private final FastByteArrayOutputStream fastByteArrayOutputStream;\r\n\r\n    private final Iterator<byte[]> buffersIterator;\r\n\r\n    private byte @Nullable [] currentBuffer;\r\n\r\n    private int currentBufferLength = 0;\r\n\r\n    private int nextIndexInCurrentBuffer = 0;\r\n\r\n    private int totalBytesRead = 0;\r\n\r\n    /**\r\n     * Create a new {@code FastByteArrayInputStream} backed by the given\r\n     * {@code FastByteArrayOutputStream}.\r\n     */\r\n    public FastByteArrayInputStream(FastByteArrayOutputStream fastByteArrayOutputStream) {\r\n        this.fastByteArrayOutputStream = fastByteArrayOutputStream;\r\n        this.buffersIterator = fastByteArrayOutputStream.buffers.iterator();\r\n        if (this.buffersIterator.hasNext()) {\r\n            this.currentBuffer = this.buffersIterator.next();\r\n            if (this.currentBuffer == fastByteArrayOutputStream.buffers.getLast()) {\r\n                this.currentBufferLength = fastByteArrayOutputStream.index;\r\n            } else {\r\n                this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int read() {\r\n        if (this.currentBuffer == null) {\r\n            // This stream doesn't have any data in it...\r\n            return -1;\r\n        }\r\n        if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n            this.totalBytesRead++;\r\n            return this.currentBuffer[this.nextIndexInCurrentBuffer++] & 0xFF;\r\n        } else {\r\n            if (this.buffersIterator.hasNext()) {\r\n                this.currentBuffer = this.buffersIterator.next();\r\n                updateCurrentBufferLength();\r\n                this.nextIndexInCurrentBuffer = 0;\r\n            } else {\r\n                this.currentBuffer = null;\r\n            }\r\n            return read();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int read(byte[] b) {\r\n        return read(b, 0, b.length);\r\n    }\r\n\r\n    @Override\r\n    public int read(byte[] b, int off, int len) {\r\n        if (off < 0 || len < 0 || len > b.length - off) {\r\n            throw new IndexOutOfBoundsException();\r\n        } else if (len == 0) {\r\n            return 0;\r\n        } else {\r\n            if (this.currentBuffer == null) {\r\n                // This stream doesn't have any data in it...\r\n                return -1;\r\n            } else {\r\n                if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n                    int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n                    System.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);\r\n                    this.totalBytesRead += bytesToCopy;\r\n                    this.nextIndexInCurrentBuffer += bytesToCopy;\r\n                    int remaining = read(b, off + bytesToCopy, len - bytesToCopy);\r\n                    return bytesToCopy + Math.max(remaining, 0);\r\n                } else {\r\n                    if (this.buffersIterator.hasNext()) {\r\n                        this.currentBuffer = this.buffersIterator.next();\r\n                        updateCurrentBufferLength();\r\n                        this.nextIndexInCurrentBuffer = 0;\r\n                    } else {\r\n                        this.currentBuffer = null;\r\n                    }\r\n                    return read(b, off, len);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public long skip(long n) throws IOException {\r\n        if (n > Integer.MAX_VALUE) {\r\n            throw new IllegalArgumentException(\"n exceeds maximum (\" + Integer.MAX_VALUE + \"): \" + n);\r\n        } else if (n == 0) {\r\n            return 0;\r\n        } else if (n < 0) {\r\n            throw new IllegalArgumentException(\"n must be 0 or greater: \" + n);\r\n        }\r\n        int len = (int) n;\r\n        if (this.currentBuffer == null) {\r\n            // This stream doesn't have any data in it...\r\n            return 0;\r\n        } else {\r\n            if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n                int bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n                this.totalBytesRead += bytesToSkip;\r\n                this.nextIndexInCurrentBuffer += bytesToSkip;\r\n                return (bytesToSkip + skip(len - bytesToSkip));\r\n            } else {\r\n                if (this.buffersIterator.hasNext()) {\r\n                    this.currentBuffer = this.buffersIterator.next();\r\n                    updateCurrentBufferLength();\r\n                    this.nextIndexInCurrentBuffer = 0;\r\n                } else {\r\n                    this.currentBuffer = null;\r\n                }\r\n                return skip(len);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int available() {\r\n        return (this.fastByteArrayOutputStream.size() - this.totalBytesRead);\r\n    }\r\n\r\n    /**\r\n     * Update the message digest with the remaining bytes in this stream.\r\n     * @param messageDigest the message digest to update\r\n     */\r\n    @Override\r\n    public void updateMessageDigest(MessageDigest messageDigest) {\r\n        updateMessageDigest(messageDigest, available());\r\n    }\r\n\r\n    /**\r\n     * Update the message digest with the next len bytes in this stream.\r\n     * Avoids creating new byte arrays and use internal buffers for performance.\r\n     * @param messageDigest the message digest to update\r\n     * @param len how many bytes to read from this stream and use to update the message digest\r\n     */\r\n    @Override\r\n    public void updateMessageDigest(MessageDigest messageDigest, int len) {\r\n        if (this.currentBuffer == null) {\r\n            // This stream doesn't have any data in it...\r\n            return;\r\n        } else if (len == 0) {\r\n            return;\r\n        } else if (len < 0) {\r\n            throw new IllegalArgumentException(\"len must be 0 or greater: \" + len);\r\n        } else {\r\n            if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n                int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n                messageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);\r\n                this.nextIndexInCurrentBuffer += bytesToCopy;\r\n                updateMessageDigest(messageDigest, len - bytesToCopy);\r\n            } else {\r\n                if (this.buffersIterator.hasNext()) {\r\n                    this.currentBuffer = this.buffersIterator.next();\r\n                    updateCurrentBufferLength();\r\n                    this.nextIndexInCurrentBuffer = 0;\r\n                } else {\r\n                    this.currentBuffer = null;\r\n                }\r\n                updateMessageDigest(messageDigest, len);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void updateCurrentBufferLength() {\r\n        if (this.currentBuffer == this.fastByteArrayOutputStream.buffers.getLast()) {\r\n            this.currentBufferLength = this.fastByteArrayOutputStream.index;\r\n        } else {\r\n            this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\r\n        }\r\n    }\r\n}",
    "comment": "\n * A speedy alternative to {@link java.io.ByteArrayOutputStream}. Note that\n * this variant does <i>not</i> extend {@code ByteArrayOutputStream}, unlike\n * its sibling {@link ResizableByteArrayOutputStream}.\n *\n * <p>Unlike {@link java.io.ByteArrayOutputStream}, this implementation is backed\n * by a {@link java.util.ArrayDeque} of {@code byte[]} buffers instead of one\n * constantly resizing {@code byte[]}. It does not copy buffers when it gets expanded.\n *\n * <p>The initial buffer is only created when the stream is first written.\n * There is also no copying of the internal buffers if the stream's content is\n * extracted via the {@link #writeTo(OutputStream)} method.\n *\n * @author Craig Andrews\n * @author Juergen Hoeller\n * @since 4.2\n * @see #resize\n * @see ResizableByteArrayOutputStream\n "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#write(int)",
    "entityType": "method",
    "code": "// Overridden methods\r\n@Override\r\npublic void write(int datum) throws IOException {\r\n    if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    }\r\n    if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\r\n        addBuffer(1);\r\n    }\r\n    // store the byte\r\n    this.buffers.getLast()[this.index++] = (byte) datum;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void write(byte[] data, int offset, int length) throws IOException {\r\n    if (offset < 0 || offset + length > data.length || length < 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (this.closed) {\r\n        throw new IOException(\"Stream closed\");\r\n    } else {\r\n        if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\r\n            addBuffer(length);\r\n        }\r\n        if (this.index + length > this.buffers.getLast().length) {\r\n            int pos = offset;\r\n            do {\r\n                if (this.index == this.buffers.getLast().length) {\r\n                    addBuffer(length);\r\n                }\r\n                int copyLength = this.buffers.getLast().length - this.index;\r\n                if (length < copyLength) {\r\n                    copyLength = length;\r\n                }\r\n                System.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);\r\n                pos += copyLength;\r\n                this.index += copyLength;\r\n                length -= copyLength;\r\n            } while (length > 0);\r\n        } else {\r\n            // copy in the sub-array\r\n            System.arraycopy(data, offset, this.buffers.getLast(), this.index, length);\r\n            this.index += length;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#close()",
    "entityType": "method",
    "code": "@Override\r\npublic void close() {\r\n    this.closed = true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#toString()",
    "entityType": "method",
    "code": "/**\r\n * Convert this stream's contents to a string by decoding the bytes using the\r\n * platform's default character set. The length of the new {@code String}\r\n * is a function of the character set, and hence may not be equal to the\r\n * size of the buffers.\r\n * <p>This method always replaces malformed-input and unmappable-character\r\n * sequences with the default replacement string for the platform's\r\n * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\r\n * class should be used when more control over the decoding process is\r\n * required.\r\n * @return a String decoded from this stream's contents\r\n * @see #toString(Charset)\r\n */\r\n@Override\r\npublic String toString() {\r\n    return toString(Charset.defaultCharset());\r\n}",
    "comment": "\n\t * Convert this stream's contents to a string by decoding the bytes using the\n\t * platform's default character set. The length of the new {@code String}\n\t * is a function of the character set, and hence may not be equal to the\n\t * size of the buffers.\n\t * <p>This method always replaces malformed-input and unmappable-character\n\t * sequences with the default replacement string for the platform's\n\t * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n\t * class should be used when more control over the decoding process is\n\t * required.\n\t * @return a String decoded from this stream's contents\n\t * @see #toString(Charset)\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
    "entityType": "method",
    "code": "/**\r\n * Convert this stream's contents to a string by decoding the bytes using the\r\n * specified {@link Charset}.\r\n * @param charset the {@link Charset} to use to decode the bytes\r\n * @return a String decoded from this stream's contents\r\n * @since 6.1.2\r\n * @see #toString()\r\n */\r\npublic String toString(Charset charset) {\r\n    if (size() == 0) {\r\n        return \"\";\r\n    }\r\n    if (this.buffers.size() == 1) {\r\n        return new String(this.buffers.getFirst(), 0, this.index, charset);\r\n    }\r\n    return new String(toByteArrayUnsafe(), charset);\r\n}",
    "comment": "\n\t * Convert this stream's contents to a string by decoding the bytes using the\n\t * specified {@link Charset}.\n\t * @param charset the {@link Charset} to use to decode the bytes\n\t * @return a String decoded from this stream's contents\n\t * @since 6.1.2\n\t * @see #toString()\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#size()",
    "entityType": "method",
    "code": "// Custom methods\r\n/**\r\n * Return the number of bytes stored in this {@code FastByteArrayOutputStream}.\r\n */\r\npublic int size() {\r\n    return (this.alreadyBufferedSize + this.index);\r\n}",
    "comment": "\n\t * Return the number of bytes stored in this {@code FastByteArrayOutputStream}.\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
    "entityType": "method",
    "code": "/**\r\n * Convert this stream's contents to a byte array and return the byte array.\r\n * <p>Also replaces the internal structures with the byte array to\r\n * conserve memory: if the byte array is being created anyway, we might\r\n * as well as use it. This approach also means that if this method is\r\n * called twice without any writes in the interim, the second call is\r\n * a no-op.\r\n * <p>This method is \"unsafe\" as it returns the internal buffer.\r\n * Callers should not modify the returned buffer.\r\n * @return the current contents of this stream as a byte array\r\n * @see #size()\r\n * @see #toByteArray()\r\n */\r\npublic byte[] toByteArrayUnsafe() {\r\n    int totalSize = size();\r\n    if (totalSize == 0) {\r\n        return new byte[0];\r\n    }\r\n    resize(totalSize);\r\n    return this.buffers.getFirst();\r\n}",
    "comment": "\n\t * Convert this stream's contents to a byte array and return the byte array.\n\t * <p>Also replaces the internal structures with the byte array to\n\t * conserve memory: if the byte array is being created anyway, we might\n\t * as well as use it. This approach also means that if this method is\n\t * called twice without any writes in the interim, the second call is\n\t * a no-op.\n\t * <p>This method is \"unsafe\" as it returns the internal buffer.\n\t * Callers should not modify the returned buffer.\n\t * @return the current contents of this stream as a byte array\n\t * @see #size()\n\t * @see #toByteArray()\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
    "entityType": "method",
    "code": "/**\r\n * Create a newly allocated byte array.\r\n * <p>Its size is the current size of this output stream, and it will\r\n * contain the valid contents of the internal buffers.\r\n * @return the current contents of this stream as a byte array\r\n * @see #size()\r\n * @see #toByteArrayUnsafe()\r\n */\r\npublic byte[] toByteArray() {\r\n    byte[] bytesUnsafe = toByteArrayUnsafe();\r\n    return bytesUnsafe.clone();\r\n}",
    "comment": "\n\t * Create a newly allocated byte array.\n\t * <p>Its size is the current size of this output stream, and it will\n\t * contain the valid contents of the internal buffers.\n\t * @return the current contents of this stream as a byte array\n\t * @see #size()\n\t * @see #toByteArrayUnsafe()\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#reset()",
    "entityType": "method",
    "code": "/**\r\n * Reset the contents of this {@code FastByteArrayOutputStream}.\r\n * <p>All currently accumulated output in the output stream is discarded.\r\n * The output stream can be used again.\r\n */\r\npublic void reset() {\r\n    this.buffers.clear();\r\n    this.nextBlockSize = this.initialBlockSize;\r\n    this.closed = false;\r\n    this.index = 0;\r\n    this.alreadyBufferedSize = 0;\r\n}",
    "comment": "\n\t * Reset the contents of this {@code FastByteArrayOutputStream}.\n\t * <p>All currently accumulated output in the output stream is discarded.\n\t * The output stream can be used again.\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * Get an {@link InputStream} to retrieve the contents of this\r\n * {@code FastByteArrayOutputStream}.\r\n * <p>Note that if any methods are called on this {@code FastByteArrayOutputStream}\r\n * (including, but not limited to, any of the write methods, {@link #reset()},\r\n * {@link #toByteArray()}, and {@link #toByteArrayUnsafe()}) then the\r\n * {@code InputStream}'s behavior is undefined.\r\n * @return {@code  InputStream} of the contents of this {@code FastByteArrayOutputStream}\r\n */\r\npublic InputStream getInputStream() {\r\n    return new FastByteArrayInputStream(this);\r\n}",
    "comment": "\n\t * Get an {@link InputStream} to retrieve the contents of this\n\t * {@code FastByteArrayOutputStream}.\n\t * <p>Note that if any methods are called on this {@code FastByteArrayOutputStream}\n\t * (including, but not limited to, any of the write methods, {@link #reset()},\n\t * {@link #toByteArray()}, and {@link #toByteArrayUnsafe()}) then the\n\t * {@code InputStream}'s behavior is undefined.\n\t * @return {@code  InputStream} of the contents of this {@code FastByteArrayOutputStream}\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#writeTo(OutputStream)",
    "entityType": "method",
    "code": "/**\r\n * Write the contents of this {@code FastByteArrayOutputStream} to the given\r\n * {@link OutputStream}.\r\n * @param out the OutputStream to write to\r\n */\r\npublic void writeTo(OutputStream out) throws IOException {\r\n    Iterator<byte[]> it = this.buffers.iterator();\r\n    while (it.hasNext()) {\r\n        byte[] bytes = it.next();\r\n        if (it.hasNext()) {\r\n            out.write(bytes, 0, bytes.length);\r\n        } else {\r\n            out.write(bytes, 0, this.index);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Write the contents of this {@code FastByteArrayOutputStream} to the given\n\t * {@link OutputStream}.\n\t * @param out the OutputStream to write to\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
    "entityType": "method",
    "code": "/**\r\n * Resize the internal buffer size to the specified capacity.\r\n * @param targetCapacity the desired size of the buffer\r\n * @throws IllegalArgumentException if the given capacity is smaller than\r\n * the actual size of the content stored in the buffer already\r\n * @see FastByteArrayOutputStream#size()\r\n */\r\npublic void resize(int targetCapacity) {\r\n    Assert.isTrue(targetCapacity >= size(), \"New capacity must not be smaller than current size\");\r\n    if (this.buffers.peekFirst() == null) {\r\n        this.nextBlockSize = targetCapacity - size();\r\n    } else if (size() == targetCapacity && this.buffers.getFirst().length == targetCapacity) {\r\n        // do nothing - already at the targetCapacity\r\n    } else {\r\n        int totalSize = size();\r\n        byte[] data = new byte[targetCapacity];\r\n        int pos = 0;\r\n        Iterator<byte[]> it = this.buffers.iterator();\r\n        while (it.hasNext()) {\r\n            byte[] bytes = it.next();\r\n            if (it.hasNext()) {\r\n                System.arraycopy(bytes, 0, data, pos, bytes.length);\r\n                pos += bytes.length;\r\n            } else {\r\n                System.arraycopy(bytes, 0, data, pos, this.index);\r\n            }\r\n        }\r\n        this.buffers.clear();\r\n        this.buffers.add(data);\r\n        this.index = totalSize;\r\n        this.alreadyBufferedSize = 0;\r\n    }\r\n}",
    "comment": "\n\t * Resize the internal buffer size to the specified capacity.\n\t * @param targetCapacity the desired size of the buffer\n\t * @throws IllegalArgumentException if the given capacity is smaller than\n\t * the actual size of the content stored in the buffer already\n\t * @see FastByteArrayOutputStream#size()\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
    "entityType": "method",
    "code": "/**\r\n * Create a new buffer and store it in the ArrayDeque.\r\n * <p>Adds a new buffer that can store at least {@code minCapacity} bytes.\r\n */\r\nprivate void addBuffer(int minCapacity) {\r\n    if (this.buffers.peekLast() != null) {\r\n        this.alreadyBufferedSize += this.index;\r\n        this.index = 0;\r\n    }\r\n    if (this.nextBlockSize < minCapacity) {\r\n        this.nextBlockSize = nextPowerOf2(minCapacity);\r\n    }\r\n    this.buffers.add(new byte[this.nextBlockSize]);\r\n    // block size doubles each time\r\n    this.nextBlockSize *= 2;\r\n}",
    "comment": "\n\t * Create a new buffer and store it in the ArrayDeque.\n\t * <p>Adds a new buffer that can store at least {@code minCapacity} bytes.\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayOutputStream#nextPowerOf2(int)",
    "entityType": "method",
    "code": "/**\r\n * Get the next power of 2 of a number (ex, the next power of 2 of 119 is 128).\r\n */\r\nprivate static int nextPowerOf2(int val) {\r\n    val--;\r\n    val = (val >> 1) | val;\r\n    val = (val >> 2) | val;\r\n    val = (val >> 4) | val;\r\n    val = (val >> 8) | val;\r\n    val = (val >> 16) | val;\r\n    val++;\r\n    return val;\r\n}",
    "comment": "\n\t * Get the next power of 2 of a number (ex, the next power of 2 of 119 is 128).\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream",
    "entityType": "class",
    "code": "private final FastByteArrayOutputStream fastByteArrayOutputStream;\nprivate final Iterator<byte[]> buffersIterator;\nprivate byte @Nullable [] currentBuffer;\nprivate int currentBufferLength = 0;\nprivate int nextIndexInCurrentBuffer = 0;\nprivate int totalBytesRead = 0;\n/**\r\n * Create a new {@code FastByteArrayInputStream} backed by the given\r\n * {@code FastByteArrayOutputStream}.\r\n */\r\npublic FastByteArrayInputStream(FastByteArrayOutputStream fastByteArrayOutputStream) {\r\n    this.fastByteArrayOutputStream = fastByteArrayOutputStream;\r\n    this.buffersIterator = fastByteArrayOutputStream.buffers.iterator();\r\n    if (this.buffersIterator.hasNext()) {\r\n        this.currentBuffer = this.buffersIterator.next();\r\n        if (this.currentBuffer == fastByteArrayOutputStream.buffers.getLast()) {\r\n            this.currentBufferLength = fastByteArrayOutputStream.index;\r\n        } else {\r\n            this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\r\n        }\r\n    }\r\n}\n@Override\r\npublic int read() {\r\n    if (this.currentBuffer == null) {\r\n        // This stream doesn't have any data in it...\r\n        return -1;\r\n    }\r\n    if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n        this.totalBytesRead++;\r\n        return this.currentBuffer[this.nextIndexInCurrentBuffer++] & 0xFF;\r\n    } else {\r\n        if (this.buffersIterator.hasNext()) {\r\n            this.currentBuffer = this.buffersIterator.next();\r\n            updateCurrentBufferLength();\r\n            this.nextIndexInCurrentBuffer = 0;\r\n        } else {\r\n            this.currentBuffer = null;\r\n        }\r\n        return read();\r\n    }\r\n}\n@Override\r\npublic int read(byte[] b) {\r\n    return read(b, 0, b.length);\r\n}\n@Override\r\npublic int read(byte[] b, int off, int len) {\r\n    if (off < 0 || len < 0 || len > b.length - off) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    } else {\r\n        if (this.currentBuffer == null) {\r\n            // This stream doesn't have any data in it...\r\n            return -1;\r\n        } else {\r\n            if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n                int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n                System.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);\r\n                this.totalBytesRead += bytesToCopy;\r\n                this.nextIndexInCurrentBuffer += bytesToCopy;\r\n                int remaining = read(b, off + bytesToCopy, len - bytesToCopy);\r\n                return bytesToCopy + Math.max(remaining, 0);\r\n            } else {\r\n                if (this.buffersIterator.hasNext()) {\r\n                    this.currentBuffer = this.buffersIterator.next();\r\n                    updateCurrentBufferLength();\r\n                    this.nextIndexInCurrentBuffer = 0;\r\n                } else {\r\n                    this.currentBuffer = null;\r\n                }\r\n                return read(b, off, len);\r\n            }\r\n        }\r\n    }\r\n}\n@Override\r\npublic long skip(long n) throws IOException {\r\n    if (n > Integer.MAX_VALUE) {\r\n        throw new IllegalArgumentException(\"n exceeds maximum (\" + Integer.MAX_VALUE + \"): \" + n);\r\n    } else if (n == 0) {\r\n        return 0;\r\n    } else if (n < 0) {\r\n        throw new IllegalArgumentException(\"n must be 0 or greater: \" + n);\r\n    }\r\n    int len = (int) n;\r\n    if (this.currentBuffer == null) {\r\n        // This stream doesn't have any data in it...\r\n        return 0;\r\n    } else {\r\n        if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n            int bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n            this.totalBytesRead += bytesToSkip;\r\n            this.nextIndexInCurrentBuffer += bytesToSkip;\r\n            return (bytesToSkip + skip(len - bytesToSkip));\r\n        } else {\r\n            if (this.buffersIterator.hasNext()) {\r\n                this.currentBuffer = this.buffersIterator.next();\r\n                updateCurrentBufferLength();\r\n                this.nextIndexInCurrentBuffer = 0;\r\n            } else {\r\n                this.currentBuffer = null;\r\n            }\r\n            return skip(len);\r\n        }\r\n    }\r\n}\n@Override\r\npublic int available() {\r\n    return (this.fastByteArrayOutputStream.size() - this.totalBytesRead);\r\n}\n/**\r\n * Update the message digest with the remaining bytes in this stream.\r\n * @param messageDigest the message digest to update\r\n */\r\n@Override\r\npublic void updateMessageDigest(MessageDigest messageDigest) {\r\n    updateMessageDigest(messageDigest, available());\r\n}\n/**\r\n * Update the message digest with the next len bytes in this stream.\r\n * Avoids creating new byte arrays and use internal buffers for performance.\r\n * @param messageDigest the message digest to update\r\n * @param len how many bytes to read from this stream and use to update the message digest\r\n */\r\n@Override\r\npublic void updateMessageDigest(MessageDigest messageDigest, int len) {\r\n    if (this.currentBuffer == null) {\r\n        // This stream doesn't have any data in it...\r\n        return;\r\n    } else if (len == 0) {\r\n        return;\r\n    } else if (len < 0) {\r\n        throw new IllegalArgumentException(\"len must be 0 or greater: \" + len);\r\n    } else {\r\n        if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n            int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n            messageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);\r\n            this.nextIndexInCurrentBuffer += bytesToCopy;\r\n            updateMessageDigest(messageDigest, len - bytesToCopy);\r\n        } else {\r\n            if (this.buffersIterator.hasNext()) {\r\n                this.currentBuffer = this.buffersIterator.next();\r\n                updateCurrentBufferLength();\r\n                this.nextIndexInCurrentBuffer = 0;\r\n            } else {\r\n                this.currentBuffer = null;\r\n            }\r\n            updateMessageDigest(messageDigest, len);\r\n        }\r\n    }\r\n}\nprivate void updateCurrentBufferLength() {\r\n    if (this.currentBuffer == this.fastByteArrayOutputStream.buffers.getLast()) {\r\n        this.currentBufferLength = this.fastByteArrayOutputStream.index;\r\n    } else {\r\n        this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\r\n    }\r\n}",
    "comment": "\n\t * An implementation of {@link java.io.InputStream} that reads from a given\n\t * {@code FastByteArrayOutputStream}.\n\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#read()",
    "entityType": "method",
    "code": "@Override\r\npublic int read() {\r\n    if (this.currentBuffer == null) {\r\n        // This stream doesn't have any data in it...\r\n        return -1;\r\n    }\r\n    if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n        this.totalBytesRead++;\r\n        return this.currentBuffer[this.nextIndexInCurrentBuffer++] & 0xFF;\r\n    } else {\r\n        if (this.buffersIterator.hasNext()) {\r\n            this.currentBuffer = this.buffersIterator.next();\r\n            updateCurrentBufferLength();\r\n            this.nextIndexInCurrentBuffer = 0;\r\n        } else {\r\n            this.currentBuffer = null;\r\n        }\r\n        return read();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#read(byte[])",
    "entityType": "method",
    "code": "@Override\r\npublic int read(byte[] b) {\r\n    return read(b, 0, b.length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int read(byte[] b, int off, int len) {\r\n    if (off < 0 || len < 0 || len > b.length - off) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    } else {\r\n        if (this.currentBuffer == null) {\r\n            // This stream doesn't have any data in it...\r\n            return -1;\r\n        } else {\r\n            if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n                int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n                System.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);\r\n                this.totalBytesRead += bytesToCopy;\r\n                this.nextIndexInCurrentBuffer += bytesToCopy;\r\n                int remaining = read(b, off + bytesToCopy, len - bytesToCopy);\r\n                return bytesToCopy + Math.max(remaining, 0);\r\n            } else {\r\n                if (this.buffersIterator.hasNext()) {\r\n                    this.currentBuffer = this.buffersIterator.next();\r\n                    updateCurrentBufferLength();\r\n                    this.nextIndexInCurrentBuffer = 0;\r\n                } else {\r\n                    this.currentBuffer = null;\r\n                }\r\n                return read(b, off, len);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#skip(long)",
    "entityType": "method",
    "code": "@Override\r\npublic long skip(long n) throws IOException {\r\n    if (n > Integer.MAX_VALUE) {\r\n        throw new IllegalArgumentException(\"n exceeds maximum (\" + Integer.MAX_VALUE + \"): \" + n);\r\n    } else if (n == 0) {\r\n        return 0;\r\n    } else if (n < 0) {\r\n        throw new IllegalArgumentException(\"n must be 0 or greater: \" + n);\r\n    }\r\n    int len = (int) n;\r\n    if (this.currentBuffer == null) {\r\n        // This stream doesn't have any data in it...\r\n        return 0;\r\n    } else {\r\n        if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n            int bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n            this.totalBytesRead += bytesToSkip;\r\n            this.nextIndexInCurrentBuffer += bytesToSkip;\r\n            return (bytesToSkip + skip(len - bytesToSkip));\r\n        } else {\r\n            if (this.buffersIterator.hasNext()) {\r\n                this.currentBuffer = this.buffersIterator.next();\r\n                updateCurrentBufferLength();\r\n                this.nextIndexInCurrentBuffer = 0;\r\n            } else {\r\n                this.currentBuffer = null;\r\n            }\r\n            return skip(len);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#available()",
    "entityType": "method",
    "code": "@Override\r\npublic int available() {\r\n    return (this.fastByteArrayOutputStream.size() - this.totalBytesRead);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
    "entityType": "method",
    "code": "/**\r\n * Update the message digest with the remaining bytes in this stream.\r\n * @param messageDigest the message digest to update\r\n */\r\n@Override\r\npublic void updateMessageDigest(MessageDigest messageDigest) {\r\n    updateMessageDigest(messageDigest, available());\r\n}",
    "comment": "\n\t\t * Update the message digest with the remaining bytes in this stream.\n\t\t * @param messageDigest the message digest to update\n\t\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
    "entityType": "method",
    "code": "/**\r\n * Update the message digest with the next len bytes in this stream.\r\n * Avoids creating new byte arrays and use internal buffers for performance.\r\n * @param messageDigest the message digest to update\r\n * @param len how many bytes to read from this stream and use to update the message digest\r\n */\r\n@Override\r\npublic void updateMessageDigest(MessageDigest messageDigest, int len) {\r\n    if (this.currentBuffer == null) {\r\n        // This stream doesn't have any data in it...\r\n        return;\r\n    } else if (len == 0) {\r\n        return;\r\n    } else if (len < 0) {\r\n        throw new IllegalArgumentException(\"len must be 0 or greater: \" + len);\r\n    } else {\r\n        if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {\r\n            int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);\r\n            messageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);\r\n            this.nextIndexInCurrentBuffer += bytesToCopy;\r\n            updateMessageDigest(messageDigest, len - bytesToCopy);\r\n        } else {\r\n            if (this.buffersIterator.hasNext()) {\r\n                this.currentBuffer = this.buffersIterator.next();\r\n                updateCurrentBufferLength();\r\n                this.nextIndexInCurrentBuffer = 0;\r\n            } else {\r\n                this.currentBuffer = null;\r\n            }\r\n            updateMessageDigest(messageDigest, len);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t\t * Update the message digest with the next len bytes in this stream.\n\t\t * Avoids creating new byte arrays and use internal buffers for performance.\n\t\t * @param messageDigest the message digest to update\n\t\t * @param len how many bytes to read from this stream and use to update the message digest\n\t\t "
  },
  {
    "entityId": "org.springframework.util.FastByteArrayInputStream#updateCurrentBufferLength()",
    "entityType": "method",
    "code": "private void updateCurrentBufferLength() {\r\n    if (this.currentBuffer == this.fastByteArrayOutputStream.buffers.getLast()) {\r\n        this.currentBufferLength = this.fastByteArrayOutputStream.index;\r\n    } else {\r\n        this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils",
    "entityType": "class",
    "code": "/**\r\n * The default buffer size used when copying bytes.\r\n */\r\npublic static final int BUFFER_SIZE = StreamUtils.BUFFER_SIZE;\n//---------------------------------------------------------------------\r\n// Copy methods for java.io.File\r\n//---------------------------------------------------------------------\r\n/**\r\n * Copy the contents of the given input File to the given output File.\r\n * @param in the file to copy from\r\n * @param out the file to copy to\r\n * @return the number of bytes copied\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static int copy(File in, File out) throws IOException {\r\n    Assert.notNull(in, \"No input File specified\");\r\n    Assert.notNull(out, \"No output File specified\");\r\n    return copy(Files.newInputStream(in.toPath()), Files.newOutputStream(out.toPath()));\r\n}\n/**\r\n * Copy the contents of the given byte array to the given output File.\r\n * @param in the byte array to copy from\r\n * @param out the file to copy to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void copy(byte[] in, File out) throws IOException {\r\n    Assert.notNull(in, \"No input byte array specified\");\r\n    Assert.notNull(out, \"No output File specified\");\r\n    copy(new ByteArrayInputStream(in), Files.newOutputStream(out.toPath()));\r\n}\n/**\r\n * Copy the contents of the given input File into a new byte array.\r\n * @param in the file to copy from\r\n * @return the new byte array that has been copied to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static byte[] copyToByteArray(File in) throws IOException {\r\n    Assert.notNull(in, \"No input File specified\");\r\n    return copyToByteArray(Files.newInputStream(in.toPath()));\r\n}\n//---------------------------------------------------------------------\r\n// Copy methods for java.io.InputStream / java.io.OutputStream\r\n//---------------------------------------------------------------------\r\n/**\r\n * Copy the contents of the given InputStream to the given OutputStream.\r\n * Closes both streams when done.\r\n * @param in the stream to copy from\r\n * @param out the stream to copy to\r\n * @return the number of bytes copied\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static int copy(InputStream in, OutputStream out) throws IOException {\r\n    Assert.notNull(in, \"No InputStream specified\");\r\n    Assert.notNull(out, \"No OutputStream specified\");\r\n    try (in;\r\n        out) {\r\n        int count = (int) in.transferTo(out);\r\n        out.flush();\r\n        return count;\r\n    }\r\n}\n/**\r\n * Copy the contents of the given byte array to the given OutputStream.\r\n * Closes the stream when done.\r\n * @param in the byte array to copy from\r\n * @param out the OutputStream to copy to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void copy(byte[] in, OutputStream out) throws IOException {\r\n    Assert.notNull(in, \"No input byte array specified\");\r\n    Assert.notNull(out, \"No OutputStream specified\");\r\n    try {\r\n        out.write(in);\r\n    } finally {\r\n        close(out);\r\n    }\r\n}\n/**\r\n * Copy the contents of the given InputStream into a new byte array.\r\n * Closes the stream when done.\r\n * @param in the stream to copy from (may be {@code null} or empty)\r\n * @return the new byte array that has been copied to (possibly empty)\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static byte[] copyToByteArray(@Nullable InputStream in) throws IOException {\r\n    if (in == null) {\r\n        return new byte[0];\r\n    }\r\n    try (in) {\r\n        return in.readAllBytes();\r\n    }\r\n}\n//---------------------------------------------------------------------\r\n// Copy methods for java.io.Reader / java.io.Writer\r\n//---------------------------------------------------------------------\r\n/**\r\n * Copy the contents of the given Reader to the given Writer.\r\n * Closes both when done.\r\n * @param in the Reader to copy from\r\n * @param out the Writer to copy to\r\n * @return the number of characters copied\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static int copy(Reader in, Writer out) throws IOException {\r\n    Assert.notNull(in, \"No Reader specified\");\r\n    Assert.notNull(out, \"No Writer specified\");\r\n    try {\r\n        int charCount = 0;\r\n        char[] buffer = new char[BUFFER_SIZE];\r\n        int charsRead;\r\n        while ((charsRead = in.read(buffer)) != -1) {\r\n            out.write(buffer, 0, charsRead);\r\n            charCount += charsRead;\r\n        }\r\n        out.flush();\r\n        return charCount;\r\n    } finally {\r\n        close(in);\r\n        close(out);\r\n    }\r\n}\n/**\r\n * Copy the contents of the given String to the given Writer.\r\n * Closes the writer when done.\r\n * @param in the String to copy from\r\n * @param out the Writer to copy to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void copy(String in, Writer out) throws IOException {\r\n    Assert.notNull(in, \"No input String specified\");\r\n    Assert.notNull(out, \"No Writer specified\");\r\n    try {\r\n        out.write(in);\r\n    } finally {\r\n        close(out);\r\n    }\r\n}\n/**\r\n * Copy the contents of the given Reader into a String.\r\n * Closes the reader when done.\r\n * @param in the reader to copy from (may be {@code null} or empty)\r\n * @return the String that has been copied to (possibly empty)\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static String copyToString(@Nullable Reader in) throws IOException {\r\n    if (in == null) {\r\n        return \"\";\r\n    }\r\n    StringWriter out = new StringWriter(BUFFER_SIZE);\r\n    copy(in, out);\r\n    return out.toString();\r\n}\n/**\r\n * Attempt to close the supplied {@link Closeable}, silently swallowing any\r\n * exceptions.\r\n * @param closeable the {@code Closeable} to close\r\n */\r\nprivate static void close(Closeable closeable) {\r\n    try {\r\n        closeable.close();\r\n    } catch (IOException ex) {\r\n        // ignore\r\n    }\r\n}",
    "comment": "\n * Simple utility methods for file and stream copying. All copy methods use a block size\n * of 4096 bytes, and close all affected streams when done. A variation of the copy\n * methods from this class that leave streams open can be found in {@link StreamUtils}.\n *\n * <p>Mainly for use within the framework, but also useful for application code.\n *\n * @author Juergen Hoeller\n * @author Hyunjin Choi\n * @since 06.10.2003\n * @see StreamUtils\n * @see FileSystemUtils\n "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copy(File,File)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Copy methods for java.io.File\r\n//---------------------------------------------------------------------\r\n/**\r\n * Copy the contents of the given input File to the given output File.\r\n * @param in the file to copy from\r\n * @param out the file to copy to\r\n * @return the number of bytes copied\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static int copy(File in, File out) throws IOException {\r\n    Assert.notNull(in, \"No input File specified\");\r\n    Assert.notNull(out, \"No output File specified\");\r\n    return copy(Files.newInputStream(in.toPath()), Files.newOutputStream(out.toPath()));\r\n}",
    "comment": "\n\t * Copy the contents of the given input File to the given output File.\n\t * @param in the file to copy from\n\t * @param out the file to copy to\n\t * @return the number of bytes copied\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
    "entityType": "method",
    "code": "/**\r\n * Copy the contents of the given byte array to the given output File.\r\n * @param in the byte array to copy from\r\n * @param out the file to copy to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void copy(byte[] in, File out) throws IOException {\r\n    Assert.notNull(in, \"No input byte array specified\");\r\n    Assert.notNull(out, \"No output File specified\");\r\n    copy(new ByteArrayInputStream(in), Files.newOutputStream(out.toPath()));\r\n}",
    "comment": "\n\t * Copy the contents of the given byte array to the given output File.\n\t * @param in the byte array to copy from\n\t * @param out the file to copy to\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copyToByteArray(File)",
    "entityType": "method",
    "code": "/**\r\n * Copy the contents of the given input File into a new byte array.\r\n * @param in the file to copy from\r\n * @return the new byte array that has been copied to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static byte[] copyToByteArray(File in) throws IOException {\r\n    Assert.notNull(in, \"No input File specified\");\r\n    return copyToByteArray(Files.newInputStream(in.toPath()));\r\n}",
    "comment": "\n\t * Copy the contents of the given input File into a new byte array.\n\t * @param in the file to copy from\n\t * @return the new byte array that has been copied to\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Copy methods for java.io.InputStream / java.io.OutputStream\r\n//---------------------------------------------------------------------\r\n/**\r\n * Copy the contents of the given InputStream to the given OutputStream.\r\n * Closes both streams when done.\r\n * @param in the stream to copy from\r\n * @param out the stream to copy to\r\n * @return the number of bytes copied\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static int copy(InputStream in, OutputStream out) throws IOException {\r\n    Assert.notNull(in, \"No InputStream specified\");\r\n    Assert.notNull(out, \"No OutputStream specified\");\r\n    try (in;\r\n        out) {\r\n        int count = (int) in.transferTo(out);\r\n        out.flush();\r\n        return count;\r\n    }\r\n}",
    "comment": "\n\t * Copy the contents of the given InputStream to the given OutputStream.\n\t * Closes both streams when done.\n\t * @param in the stream to copy from\n\t * @param out the stream to copy to\n\t * @return the number of bytes copied\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
    "entityType": "method",
    "code": "/**\r\n * Copy the contents of the given byte array to the given OutputStream.\r\n * Closes the stream when done.\r\n * @param in the byte array to copy from\r\n * @param out the OutputStream to copy to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void copy(byte[] in, OutputStream out) throws IOException {\r\n    Assert.notNull(in, \"No input byte array specified\");\r\n    Assert.notNull(out, \"No OutputStream specified\");\r\n    try {\r\n        out.write(in);\r\n    } finally {\r\n        close(out);\r\n    }\r\n}",
    "comment": "\n\t * Copy the contents of the given byte array to the given OutputStream.\n\t * Closes the stream when done.\n\t * @param in the byte array to copy from\n\t * @param out the OutputStream to copy to\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Copy the contents of the given InputStream into a new byte array.\r\n * Closes the stream when done.\r\n * @param in the stream to copy from (may be {@code null} or empty)\r\n * @return the new byte array that has been copied to (possibly empty)\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static byte[] copyToByteArray(@Nullable InputStream in) throws IOException {\r\n    if (in == null) {\r\n        return new byte[0];\r\n    }\r\n    try (in) {\r\n        return in.readAllBytes();\r\n    }\r\n}",
    "comment": "\n\t * Copy the contents of the given InputStream into a new byte array.\n\t * Closes the stream when done.\n\t * @param in the stream to copy from (may be {@code null} or empty)\n\t * @return the new byte array that has been copied to (possibly empty)\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Copy methods for java.io.Reader / java.io.Writer\r\n//---------------------------------------------------------------------\r\n/**\r\n * Copy the contents of the given Reader to the given Writer.\r\n * Closes both when done.\r\n * @param in the Reader to copy from\r\n * @param out the Writer to copy to\r\n * @return the number of characters copied\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static int copy(Reader in, Writer out) throws IOException {\r\n    Assert.notNull(in, \"No Reader specified\");\r\n    Assert.notNull(out, \"No Writer specified\");\r\n    try {\r\n        int charCount = 0;\r\n        char[] buffer = new char[BUFFER_SIZE];\r\n        int charsRead;\r\n        while ((charsRead = in.read(buffer)) != -1) {\r\n            out.write(buffer, 0, charsRead);\r\n            charCount += charsRead;\r\n        }\r\n        out.flush();\r\n        return charCount;\r\n    } finally {\r\n        close(in);\r\n        close(out);\r\n    }\r\n}",
    "comment": "\n\t * Copy the contents of the given Reader to the given Writer.\n\t * Closes both when done.\n\t * @param in the Reader to copy from\n\t * @param out the Writer to copy to\n\t * @return the number of characters copied\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
    "entityType": "method",
    "code": "/**\r\n * Copy the contents of the given String to the given Writer.\r\n * Closes the writer when done.\r\n * @param in the String to copy from\r\n * @param out the Writer to copy to\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static void copy(String in, Writer out) throws IOException {\r\n    Assert.notNull(in, \"No input String specified\");\r\n    Assert.notNull(out, \"No Writer specified\");\r\n    try {\r\n        out.write(in);\r\n    } finally {\r\n        close(out);\r\n    }\r\n}",
    "comment": "\n\t * Copy the contents of the given String to the given Writer.\n\t * Closes the writer when done.\n\t * @param in the String to copy from\n\t * @param out the Writer to copy to\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
    "entityType": "method",
    "code": "/**\r\n * Copy the contents of the given Reader into a String.\r\n * Closes the reader when done.\r\n * @param in the reader to copy from (may be {@code null} or empty)\r\n * @return the String that has been copied to (possibly empty)\r\n * @throws IOException in case of I/O errors\r\n */\r\npublic static String copyToString(@Nullable Reader in) throws IOException {\r\n    if (in == null) {\r\n        return \"\";\r\n    }\r\n    StringWriter out = new StringWriter(BUFFER_SIZE);\r\n    copy(in, out);\r\n    return out.toString();\r\n}",
    "comment": "\n\t * Copy the contents of the given Reader into a String.\n\t * Closes the reader when done.\n\t * @param in the reader to copy from (may be {@code null} or empty)\n\t * @return the String that has been copied to (possibly empty)\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileCopyUtils#close(Closeable)",
    "entityType": "method",
    "code": "/**\r\n * Attempt to close the supplied {@link Closeable}, silently swallowing any\r\n * exceptions.\r\n * @param closeable the {@code Closeable} to close\r\n */\r\nprivate static void close(Closeable closeable) {\r\n    try {\r\n        closeable.close();\r\n    } catch (IOException ex) {\r\n        // ignore\r\n    }\r\n}",
    "comment": "\n\t * Attempt to close the supplied {@link Closeable}, silently swallowing any\n\t * exceptions.\n\t * @param closeable the {@code Closeable} to close\n\t "
  },
  {
    "entityId": "org.springframework.util.FileSystemUtils",
    "entityType": "class",
    "code": "/**\r\n * Delete the supplied {@link File} - for directories,\r\n * recursively delete any nested directories or files as well.\r\n * <p>Note: Like {@link File#delete()}, this method does not throw any\r\n * exception but rather silently returns {@code false} in case of I/O\r\n * errors. Consider using {@link #deleteRecursively(Path)} for NIO-style\r\n * handling of I/O errors, clearly differentiating between non-existence\r\n * and failure to delete an existing file.\r\n * @param root the root {@code File} to delete\r\n * @return {@code true} if the {@code File} was successfully deleted,\r\n * otherwise {@code false}\r\n */\r\npublic static boolean deleteRecursively(@Nullable File root) {\r\n    if (root == null) {\r\n        return false;\r\n    }\r\n    try {\r\n        return deleteRecursively(root.toPath());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}\n/**\r\n * Delete the supplied {@link Path} &mdash; for directories,\r\n * recursively delete any nested directories or files as well.\r\n * @param root the root {@code Path} to delete\r\n * @return {@code true} if the {@code Path} existed and was deleted,\r\n * or {@code false} if it did not exist\r\n * @throws IOException in the case of I/O errors\r\n * @since 5.0\r\n */\r\npublic static boolean deleteRecursively(@Nullable Path root) throws IOException {\r\n    if (root == null) {\r\n        return false;\r\n    }\r\n    if (!Files.exists(root)) {\r\n        return false;\r\n    }\r\n    Files.walkFileTree(root, new SimpleFileVisitor<>() {\r\n\r\n        @Override\r\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n            Files.delete(file);\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n\r\n        @Override\r\n        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\r\n            Files.delete(dir);\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n    });\r\n    return true;\r\n}\n/**\r\n * Recursively copy the contents of the {@code src} file/directory\r\n * to the {@code dest} file/directory.\r\n * @param src the source directory\r\n * @param dest the destination directory\r\n * @throws IOException in the case of I/O errors\r\n */\r\npublic static void copyRecursively(File src, File dest) throws IOException {\r\n    Assert.notNull(src, \"Source File must not be null\");\r\n    Assert.notNull(dest, \"Destination File must not be null\");\r\n    copyRecursively(src.toPath(), dest.toPath());\r\n}\n/**\r\n * Recursively copy the contents of the {@code src} file/directory\r\n * to the {@code dest} file/directory.\r\n * @param src the source directory\r\n * @param dest the destination directory\r\n * @throws IOException in the case of I/O errors\r\n * @since 5.0\r\n */\r\npublic static void copyRecursively(Path src, Path dest) throws IOException {\r\n    Assert.notNull(src, \"Source Path must not be null\");\r\n    Assert.notNull(dest, \"Destination Path must not be null\");\r\n    BasicFileAttributes srcAttr = Files.readAttributes(src, BasicFileAttributes.class);\r\n    if (srcAttr.isDirectory()) {\r\n        Files.walkFileTree(src, EnumSet.of(FOLLOW_LINKS), Integer.MAX_VALUE, new SimpleFileVisitor<>() {\r\n\r\n            @Override\r\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\r\n                Files.createDirectories(dest.resolve(src.relativize(dir)));\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                Files.copy(file, dest.resolve(src.relativize(file)), StandardCopyOption.REPLACE_EXISTING);\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n    } else if (srcAttr.isRegularFile()) {\r\n        Files.copy(src, dest);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Source File must denote a directory or file\");\r\n    }\r\n}",
    "comment": "\n * Utility methods for working with the file system.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @since 2.5.3\n * @see java.io.File\n * @see java.nio.file.Path\n * @see java.nio.file.Files\n "
  },
  {
    "entityId": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
    "entityType": "method",
    "code": "/**\r\n * Delete the supplied {@link File} - for directories,\r\n * recursively delete any nested directories or files as well.\r\n * <p>Note: Like {@link File#delete()}, this method does not throw any\r\n * exception but rather silently returns {@code false} in case of I/O\r\n * errors. Consider using {@link #deleteRecursively(Path)} for NIO-style\r\n * handling of I/O errors, clearly differentiating between non-existence\r\n * and failure to delete an existing file.\r\n * @param root the root {@code File} to delete\r\n * @return {@code true} if the {@code File} was successfully deleted,\r\n * otherwise {@code false}\r\n */\r\npublic static boolean deleteRecursively(@Nullable File root) {\r\n    if (root == null) {\r\n        return false;\r\n    }\r\n    try {\r\n        return deleteRecursively(root.toPath());\r\n    } catch (IOException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Delete the supplied {@link File} - for directories,\n\t * recursively delete any nested directories or files as well.\n\t * <p>Note: Like {@link File#delete()}, this method does not throw any\n\t * exception but rather silently returns {@code false} in case of I/O\n\t * errors. Consider using {@link #deleteRecursively(Path)} for NIO-style\n\t * handling of I/O errors, clearly differentiating between non-existence\n\t * and failure to delete an existing file.\n\t * @param root the root {@code File} to delete\n\t * @return {@code true} if the {@code File} was successfully deleted,\n\t * otherwise {@code false}\n\t "
  },
  {
    "entityId": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
    "entityType": "method",
    "code": "/**\r\n * Delete the supplied {@link Path} &mdash; for directories,\r\n * recursively delete any nested directories or files as well.\r\n * @param root the root {@code Path} to delete\r\n * @return {@code true} if the {@code Path} existed and was deleted,\r\n * or {@code false} if it did not exist\r\n * @throws IOException in the case of I/O errors\r\n * @since 5.0\r\n */\r\npublic static boolean deleteRecursively(@Nullable Path root) throws IOException {\r\n    if (root == null) {\r\n        return false;\r\n    }\r\n    if (!Files.exists(root)) {\r\n        return false;\r\n    }\r\n    Files.walkFileTree(root, new SimpleFileVisitor<>() {\r\n\r\n        @Override\r\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n            Files.delete(file);\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n\r\n        @Override\r\n        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\r\n            Files.delete(dir);\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n    });\r\n    return true;\r\n}",
    "comment": "\n\t * Delete the supplied {@link Path} &mdash; for directories,\n\t * recursively delete any nested directories or files as well.\n\t * @param root the root {@code Path} to delete\n\t * @return {@code true} if the {@code Path} existed and was deleted,\n\t * or {@code false} if it did not exist\n\t * @throws IOException in the case of I/O errors\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
    "entityType": "method",
    "code": "/**\r\n * Recursively copy the contents of the {@code src} file/directory\r\n * to the {@code dest} file/directory.\r\n * @param src the source directory\r\n * @param dest the destination directory\r\n * @throws IOException in the case of I/O errors\r\n */\r\npublic static void copyRecursively(File src, File dest) throws IOException {\r\n    Assert.notNull(src, \"Source File must not be null\");\r\n    Assert.notNull(dest, \"Destination File must not be null\");\r\n    copyRecursively(src.toPath(), dest.toPath());\r\n}",
    "comment": "\n\t * Recursively copy the contents of the {@code src} file/directory\n\t * to the {@code dest} file/directory.\n\t * @param src the source directory\n\t * @param dest the destination directory\n\t * @throws IOException in the case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
    "entityType": "method",
    "code": "/**\r\n * Recursively copy the contents of the {@code src} file/directory\r\n * to the {@code dest} file/directory.\r\n * @param src the source directory\r\n * @param dest the destination directory\r\n * @throws IOException in the case of I/O errors\r\n * @since 5.0\r\n */\r\npublic static void copyRecursively(Path src, Path dest) throws IOException {\r\n    Assert.notNull(src, \"Source Path must not be null\");\r\n    Assert.notNull(dest, \"Destination Path must not be null\");\r\n    BasicFileAttributes srcAttr = Files.readAttributes(src, BasicFileAttributes.class);\r\n    if (srcAttr.isDirectory()) {\r\n        Files.walkFileTree(src, EnumSet.of(FOLLOW_LINKS), Integer.MAX_VALUE, new SimpleFileVisitor<>() {\r\n\r\n            @Override\r\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\r\n                Files.createDirectories(dest.resolve(src.relativize(dir)));\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                Files.copy(file, dest.resolve(src.relativize(file)), StandardCopyOption.REPLACE_EXISTING);\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n    } else if (srcAttr.isRegularFile()) {\r\n        Files.copy(src, dest);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Source File must denote a directory or file\");\r\n    }\r\n}",
    "comment": "\n\t * Recursively copy the contents of the {@code src} file/directory\n\t * to the {@code dest} file/directory.\n\t * @param src the source directory\n\t * @param dest the destination directory\n\t * @throws IOException in the case of I/O errors\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.FilteredCollection",
    "entityType": "class",
    "code": "private final Collection<E> delegate;\nprivate final Predicate<E> filter;\npublic FilteredCollection(Collection<E> delegate, Predicate<E> filter) {\r\n    Assert.notNull(delegate, \"Delegate must not be null\");\r\n    Assert.notNull(filter, \"Filter must not be null\");\r\n    this.delegate = delegate;\r\n    this.filter = filter;\r\n}\n@Override\r\npublic int size() {\r\n    int size = 0;\r\n    for (E e : this.delegate) {\r\n        if (this.filter.test(e)) {\r\n            size++;\r\n        }\r\n    }\r\n    return size;\r\n}\n@Override\r\npublic Iterator<E> iterator() {\r\n    return new FilteredIterator<>(this.delegate.iterator(), this.filter);\r\n}\n@Override\r\npublic boolean add(E e) {\r\n    boolean added = this.delegate.add(e);\r\n    return added && this.filter.test(e);\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean remove(Object o) {\r\n    boolean removed = this.delegate.remove(o);\r\n    return removed && this.filter.test((E) o);\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean contains(Object o) {\r\n    if (this.delegate.contains(o)) {\r\n        return this.filter.test((E) o);\r\n    } else {\r\n        return false;\r\n    }\r\n}\n@Override\r\npublic void clear() {\r\n    this.delegate.clear();\r\n}",
    "comment": "\n * Collection that filters out values that do not match a predicate.\n * This type is used by {@link CompositeMap}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <E> the type of elements maintained by this collection\n "
  },
  {
    "entityId": "org.springframework.util.FilteredCollection#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    int size = 0;\r\n    for (E e : this.delegate) {\r\n        if (this.filter.test(e)) {\r\n            size++;\r\n        }\r\n    }\r\n    return size;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollection#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<E> iterator() {\r\n    return new FilteredIterator<>(this.delegate.iterator(), this.filter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollection#add(E)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean add(E e) {\r\n    boolean added = this.delegate.add(e);\r\n    return added && this.filter.test(e);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollection#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean remove(Object o) {\r\n    boolean removed = this.delegate.remove(o);\r\n    return removed && this.filter.test((E) o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollection#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean contains(Object o) {\r\n    if (this.delegate.contains(o)) {\r\n        return this.filter.test((E) o);\r\n    } else {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredCollection#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.delegate.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredIterator",
    "entityType": "class",
    "code": "private final Iterator<E> delegate;\nprivate final Predicate<E> filter;\n@Nullable\r\nprivate E next;\nprivate boolean hasNext;\npublic FilteredIterator(Iterator<E> delegate, Predicate<E> filter) {\r\n    Assert.notNull(delegate, \"Delegate must not be null\");\r\n    Assert.notNull(filter, \"Filter must not be null\");\r\n    this.delegate = delegate;\r\n    this.filter = filter;\r\n}\n@Override\r\npublic boolean hasNext() {\r\n    return (this.hasNext || setNext());\r\n}\n@Override\r\npublic E next() {\r\n    if (!this.hasNext && !setNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    this.hasNext = false;\r\n    Assert.state(this.next != null, \"Next should not be null\");\r\n    return this.next;\r\n}\nprivate boolean setNext() {\r\n    while (this.delegate.hasNext()) {\r\n        E next = this.delegate.next();\r\n        if (this.filter.test(next)) {\r\n            this.next = next;\r\n            this.hasNext = true;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n * {@link Iterator} that filters out values that do not match a predicate.\n *\n * <p>This type is used by {@link CompositeMap}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <E> the type of elements returned by this iterator\n "
  },
  {
    "entityId": "org.springframework.util.FilteredIterator#hasNext()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNext() {\r\n    return (this.hasNext || setNext());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic E next() {\r\n    if (!this.hasNext && !setNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    this.hasNext = false;\r\n    Assert.state(this.next != null, \"Next should not be null\");\r\n    return this.next;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredIterator#setNext()",
    "entityType": "method",
    "code": "private boolean setNext() {\r\n    while (this.delegate.hasNext()) {\r\n        E next = this.delegate.next();\r\n        if (this.filter.test(next)) {\r\n            this.next = next;\r\n            this.hasNext = true;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.FilteredMap",
    "entityType": "class",
    "code": "private final Map<K, V> delegate;\nprivate final Predicate<K> filter;\npublic FilteredMap(Map<K, V> delegate, Predicate<K> filter) {\r\n    Assert.notNull(delegate, \"Delegate must not be null\");\r\n    Assert.notNull(filter, \"Filter must not be null\");\r\n    this.delegate = delegate;\r\n    this.filter = filter;\r\n}\n@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    return new FilteredSet<>(this.delegate.entrySet(), entry -> this.filter.test(entry.getKey()));\r\n}\n@Override\r\npublic int size() {\r\n    int size = 0;\r\n    for (K k : keySet()) {\r\n        if (this.filter.test(k)) {\r\n            size++;\r\n        }\r\n    }\r\n    return size;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean containsKey(Object key) {\r\n    if (this.delegate.containsKey(key)) {\r\n        return this.filter.test((K) key);\r\n    } else {\r\n        return false;\r\n    }\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic V get(Object key) {\r\n    V value = this.delegate.get(key);\r\n    if (value != null && this.filter.test((K) key)) {\r\n        return value;\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic V put(K key, V value) {\r\n    V oldValue = this.delegate.put(key, value);\r\n    if (oldValue != null && this.filter.test(key)) {\r\n        return oldValue;\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic V remove(Object key) {\r\n    V oldValue = this.delegate.remove(key);\r\n    if (oldValue != null && this.filter.test((K) key)) {\r\n        return oldValue;\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\npublic void clear() {\r\n    this.delegate.clear();\r\n}\n@Override\r\npublic Set<K> keySet() {\r\n    return new FilteredSet<>(this.delegate.keySet(), this.filter);\r\n}",
    "comment": "\n * Map that filters out values that do not match a predicate.\n * This type is used by {@link CompositeMap}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <K> the type of keys maintained by this map\n * @param <V> the type of mapped values\n "
  }
]