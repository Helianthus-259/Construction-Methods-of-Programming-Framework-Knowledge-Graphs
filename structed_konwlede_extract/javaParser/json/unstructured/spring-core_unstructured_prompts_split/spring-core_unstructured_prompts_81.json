[
  {
    "entityId": "org.springframework.util.EntrySet",
    "entityType": "class",
    "code": "private final Set<Entry<String, V>> delegate;\npublic EntrySet(Set<Entry<String, V>> delegate) {\r\n    this.delegate = delegate;\r\n}\n@Override\r\npublic int size() {\r\n    return this.delegate.size();\r\n}\n@Override\r\npublic boolean contains(Object o) {\r\n    return this.delegate.contains(o);\r\n}\n@Override\r\npublic Iterator<Entry<String, V>> iterator() {\r\n    return new EntrySetIterator();\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean remove(Object o) {\r\n    if (this.delegate.remove(o)) {\r\n        removeCaseInsensitiveKey(((Map.Entry<String, V>) o).getKey());\r\n        return true;\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic void clear() {\r\n    this.delegate.clear();\r\n    caseInsensitiveKeys.clear();\r\n}\n@Override\r\npublic Spliterator<Entry<String, V>> spliterator() {\r\n    return this.delegate.spliterator();\r\n}\n@Override\r\npublic void forEach(Consumer<? super Entry<String, V>> action) {\r\n    this.delegate.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.delegate.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(Object o) {\r\n    return this.delegate.contains(o);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<Entry<String, V>> iterator() {\r\n    return new EntrySetIterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic boolean remove(Object o) {\r\n    if (this.delegate.remove(o)) {\r\n        removeCaseInsensitiveKey(((Map.Entry<String, V>) o).getKey());\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.delegate.clear();\r\n    caseInsensitiveKeys.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<Entry<String, V>> spliterator() {\r\n    return this.delegate.spliterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#forEach(Consumer<? super Entry<String,V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(Consumer<? super Entry<String, V>> action) {\r\n    this.delegate.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator",
    "entityType": "class",
    "code": "private final Iterator<Entry<String, V>> delegate;\n@Nullable\r\nprivate Entry<String, V> last;\npublic EntryIterator() {\r\n    this.delegate = targetMap.entrySet().iterator();\r\n}\nprotected Entry<String, V> nextEntry() {\r\n    Entry<String, V> entry = this.delegate.next();\r\n    this.last = entry;\r\n    return entry;\r\n}\n@Override\r\npublic boolean hasNext() {\r\n    return this.delegate.hasNext();\r\n}\n@Override\r\npublic void remove() {\r\n    this.delegate.remove();\r\n    if (this.last != null) {\r\n        removeCaseInsensitiveKey(this.last.getKey());\r\n        this.last = null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#nextEntry()",
    "entityType": "method",
    "code": "protected Entry<String, V> nextEntry() {\r\n    Entry<String, V> entry = this.delegate.next();\r\n    this.last = entry;\r\n    return entry;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#hasNext()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNext() {\r\n    return this.delegate.hasNext();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#remove()",
    "entityType": "method",
    "code": "@Override\r\npublic void remove() {\r\n    this.delegate.remove();\r\n    if (this.last != null) {\r\n        removeCaseInsensitiveKey(this.last.getKey());\r\n        this.last = null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySetIterator",
    "entityType": "class",
    "code": "@Override\r\npublic String next() {\r\n    return nextEntry().getKey();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.KeySetIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic String next() {\r\n    return nextEntry().getKey();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ValuesIterator",
    "entityType": "class",
    "code": "@Override\r\npublic V next() {\r\n    return nextEntry().getValue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ValuesIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic V next() {\r\n    return nextEntry().getValue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySetIterator",
    "entityType": "class",
    "code": "@Override\r\npublic Entry<String, V> next() {\r\n    return nextEntry();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySetIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic Entry<String, V> next() {\r\n    return nextEntry();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.LinkedMultiValueMap",
    "entityType": "class",
    "code": "private static final long serialVersionUID = 3801124242820219131L;\n/**\r\n * Create a new LinkedMultiValueMap that wraps a {@link LinkedHashMap}.\r\n */\r\npublic LinkedMultiValueMap() {\r\n    super(new LinkedHashMap<>());\r\n}\n/**\r\n * Create a new LinkedMultiValueMap that wraps a {@link LinkedHashMap}\r\n * with an initial capacity that can accommodate the specified number of\r\n * elements without any immediate resize/rehash operations to be expected.\r\n * @param expectedSize the expected number of elements (with a corresponding\r\n * capacity to be derived so that no resize/rehash operations are needed)\r\n * @see CollectionUtils#newLinkedHashMap(int)\r\n */\r\npublic LinkedMultiValueMap(int expectedSize) {\r\n    super(CollectionUtils.newLinkedHashMap(expectedSize));\r\n}\n/**\r\n * Copy constructor: Create a new LinkedMultiValueMap with the same mappings as\r\n * the specified Map. Note that this will be a shallow copy; its value-holding\r\n * List entries will get reused and therefore cannot get modified independently.\r\n * @param otherMap the Map whose mappings are to be placed in this Map\r\n * @see #clone()\r\n * @see #deepCopy()\r\n */\r\npublic LinkedMultiValueMap(Map<K, List<V>> otherMap) {\r\n    super(new LinkedHashMap<>(otherMap));\r\n}\n/**\r\n * Create a deep copy of this Map.\r\n * @return a copy of this Map, including a copy of each value-holding List entry\r\n * (consistently using an independent modifiable {@link ArrayList} for each entry)\r\n * along the lines of {@code MultiValueMap.addAll} semantics\r\n * @since 4.2\r\n * @see #addAll(MultiValueMap)\r\n * @see #clone()\r\n */\r\npublic LinkedMultiValueMap<K, V> deepCopy() {\r\n    LinkedMultiValueMap<K, V> copy = new LinkedMultiValueMap<>(size());\r\n    forEach((key, values) -> copy.put(key, new ArrayList<>(values)));\r\n    return copy;\r\n}\n/**\r\n * Create a regular copy of this Map.\r\n * @return a shallow copy of this Map, reusing this Map's value-holding List entries\r\n * (even if some entries are shared or unmodifiable) along the lines of standard\r\n * {@code Map.put} semantics\r\n * @since 4.2\r\n * @see #put(Object, List)\r\n * @see #putAll(Map)\r\n * @see LinkedMultiValueMap#LinkedMultiValueMap(Map)\r\n * @see #deepCopy()\r\n */\r\n@Override\r\npublic LinkedMultiValueMap<K, V> clone() {\r\n    return new LinkedMultiValueMap<>(this);\r\n}",
    "comment": "\n * Simple implementation of {@link MultiValueMap} that wraps a {@link LinkedHashMap},\n * storing multiple values in an {@link ArrayList}.\n *\n * <p>This Map implementation is generally not thread-safe. It is primarily designed\n * for data structures exposed from request objects, for use in a single thread only.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n * @param <K> the key type\n * @param <V> the value element type\n "
  },
  {
    "entityId": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
    "entityType": "method",
    "code": "/**\r\n * Create a deep copy of this Map.\r\n * @return a copy of this Map, including a copy of each value-holding List entry\r\n * (consistently using an independent modifiable {@link ArrayList} for each entry)\r\n * along the lines of {@code MultiValueMap.addAll} semantics\r\n * @since 4.2\r\n * @see #addAll(MultiValueMap)\r\n * @see #clone()\r\n */\r\npublic LinkedMultiValueMap<K, V> deepCopy() {\r\n    LinkedMultiValueMap<K, V> copy = new LinkedMultiValueMap<>(size());\r\n    forEach((key, values) -> copy.put(key, new ArrayList<>(values)));\r\n    return copy;\r\n}",
    "comment": "\n\t * Create a deep copy of this Map.\n\t * @return a copy of this Map, including a copy of each value-holding List entry\n\t * (consistently using an independent modifiable {@link ArrayList} for each entry)\n\t * along the lines of {@code MultiValueMap.addAll} semantics\n\t * @since 4.2\n\t * @see #addAll(MultiValueMap)\n\t * @see #clone()\n\t "
  },
  {
    "entityId": "org.springframework.util.LinkedMultiValueMap#clone()",
    "entityType": "method",
    "code": "/**\r\n * Create a regular copy of this Map.\r\n * @return a shallow copy of this Map, reusing this Map's value-holding List entries\r\n * (even if some entries are shared or unmodifiable) along the lines of standard\r\n * {@code Map.put} semantics\r\n * @since 4.2\r\n * @see #put(Object, List)\r\n * @see #putAll(Map)\r\n * @see LinkedMultiValueMap#LinkedMultiValueMap(Map)\r\n * @see #deepCopy()\r\n */\r\n@Override\r\npublic LinkedMultiValueMap<K, V> clone() {\r\n    return new LinkedMultiValueMap<>(this);\r\n}",
    "comment": "\n\t * Create a regular copy of this Map.\n\t * @return a shallow copy of this Map, reusing this Map's value-holding List entries\n\t * (even if some entries are shared or unmodifiable) along the lines of standard\n\t * {@code Map.put} semantics\n\t * @since 4.2\n\t * @see #put(Object, List)\n\t * @see #putAll(Map)\n\t * @see LinkedMultiValueMap#LinkedMultiValueMap(Map)\n\t * @see #deepCopy()\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker",
    "entityType": "class",
    "code": "private static final Object[] EMPTY_ARGUMENTS = new Object[0];\n@Nullable\r\nprotected Class<?> targetClass;\n@Nullable\r\nprivate Object targetObject;\n@Nullable\r\nprivate String targetMethod;\n@Nullable\r\nprivate String staticMethod;\n@Nullable\r\nprivate Object @Nullable [] arguments;\n/**\r\n * The method we will call.\r\n */\r\n@Nullable\r\nprivate Method methodObject;\n/**\r\n * Set the target class on which to call the target method.\r\n * Only necessary when the target method is static; else,\r\n * a target object needs to be specified anyway.\r\n * @see #setTargetObject\r\n * @see #setTargetMethod\r\n */\r\npublic void setTargetClass(@Nullable Class<?> targetClass) {\r\n    this.targetClass = targetClass;\r\n}\n/**\r\n * Return the target class on which to call the target method.\r\n */\r\n@Nullable\r\npublic Class<?> getTargetClass() {\r\n    return this.targetClass;\r\n}\n/**\r\n * Set the target object on which to call the target method.\r\n * Only necessary when the target method is not static;\r\n * else, a target class is sufficient.\r\n * @see #setTargetClass\r\n * @see #setTargetMethod\r\n */\r\npublic void setTargetObject(@Nullable Object targetObject) {\r\n    this.targetObject = targetObject;\r\n    if (targetObject != null) {\r\n        this.targetClass = targetObject.getClass();\r\n    }\r\n}\n/**\r\n * Return the target object on which to call the target method.\r\n */\r\n@Nullable\r\npublic Object getTargetObject() {\r\n    return this.targetObject;\r\n}\n/**\r\n * Set the name of the method to be invoked.\r\n * Refers to either a static method or a non-static method,\r\n * depending on a target object being set.\r\n * @see #setTargetClass\r\n * @see #setTargetObject\r\n */\r\npublic void setTargetMethod(@Nullable String targetMethod) {\r\n    this.targetMethod = targetMethod;\r\n}\n/**\r\n * Return the name of the method to be invoked.\r\n */\r\n@Nullable\r\npublic String getTargetMethod() {\r\n    return this.targetMethod;\r\n}\n/**\r\n * Set a fully qualified static method name to invoke,\r\n * for example, \"example.MyExampleClass.myExampleMethod\". This is a\r\n * convenient alternative to specifying targetClass and targetMethod.\r\n * @see #setTargetClass\r\n * @see #setTargetMethod\r\n */\r\npublic void setStaticMethod(String staticMethod) {\r\n    this.staticMethod = staticMethod;\r\n}\n/**\r\n * Set arguments for the method invocation. If this property is not set,\r\n * or the Object array is of length 0, a method with no arguments is assumed.\r\n */\r\npublic void setArguments(@Nullable Object... arguments) {\r\n    this.arguments = arguments;\r\n}\n/**\r\n * Return the arguments for the method invocation.\r\n */\r\n@Nullable\r\npublic Object[] getArguments() {\r\n    return (this.arguments != null ? this.arguments : EMPTY_ARGUMENTS);\r\n}\n/**\r\n * Prepare the specified method.\r\n * The method can be invoked any number of times afterwards.\r\n * @see #getPreparedMethod\r\n * @see #invoke\r\n */\r\npublic void prepare() throws ClassNotFoundException, NoSuchMethodException {\r\n    if (this.staticMethod != null) {\r\n        int lastDotIndex = this.staticMethod.lastIndexOf('.');\r\n        if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length() - 1) {\r\n            throw new IllegalArgumentException(\"staticMethod must be a fully qualified class plus method name: \" + \"for example, 'example.MyExampleClass.myExampleMethod'\");\r\n        }\r\n        String className = this.staticMethod.substring(0, lastDotIndex);\r\n        String methodName = this.staticMethod.substring(lastDotIndex + 1);\r\n        if (this.targetClass == null || !this.targetClass.getName().equals(className)) {\r\n            this.targetClass = resolveClassName(className);\r\n        }\r\n        this.targetMethod = methodName;\r\n    }\r\n    Class<?> targetClass = getTargetClass();\r\n    String targetMethod = getTargetMethod();\r\n    Assert.notNull(targetClass, \"Either 'targetClass' or 'targetObject' is required\");\r\n    Assert.notNull(targetMethod, \"Property 'targetMethod' is required\");\r\n    @Nullable\r\n    Object[] arguments = getArguments();\r\n    Class<?>[] argTypes = new Class<?>[arguments.length];\r\n    for (int i = 0; i < arguments.length; ++i) {\r\n        argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class);\r\n    }\r\n    // Try to get the exact method first.\r\n    try {\r\n        this.methodObject = targetClass.getMethod(targetMethod, argTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        // Just rethrow exception if we can't get any match.\r\n        this.methodObject = findMatchingMethod();\r\n        if (this.methodObject == null) {\r\n            throw ex;\r\n        }\r\n    }\r\n}\n/**\r\n * Resolve the given class name into a Class.\r\n * <p>The default implementations uses {@code ClassUtils.forName},\r\n * using the thread context class loader.\r\n * @param className the class name to resolve\r\n * @return the resolved Class\r\n * @throws ClassNotFoundException if the class name was invalid\r\n */\r\nprotected Class<?> resolveClassName(String className) throws ClassNotFoundException {\r\n    return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());\r\n}\n/**\r\n * Find a matching method with the specified name for the specified arguments.\r\n * @return a matching method, or {@code null} if none\r\n * @see #getTargetClass()\r\n * @see #getTargetMethod()\r\n * @see #getArguments()\r\n */\r\n@Nullable\r\nprotected Method findMatchingMethod() {\r\n    String targetMethod = getTargetMethod();\r\n    @Nullable\r\n    Object[] arguments = getArguments();\r\n    int argCount = arguments.length;\r\n    Class<?> targetClass = getTargetClass();\r\n    Assert.state(targetClass != null, \"No target class set\");\r\n    Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);\r\n    int minTypeDiffWeight = Integer.MAX_VALUE;\r\n    Method matchingMethod = null;\r\n    for (Method candidate : candidates) {\r\n        if (candidate.getName().equals(targetMethod) && candidate.getParameterCount() == argCount) {\r\n            Class<?>[] paramTypes = candidate.getParameterTypes();\r\n            int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments);\r\n            if (typeDiffWeight < minTypeDiffWeight) {\r\n                minTypeDiffWeight = typeDiffWeight;\r\n                matchingMethod = candidate;\r\n            }\r\n        }\r\n    }\r\n    return matchingMethod;\r\n}\n/**\r\n * Return the prepared Method object that will be invoked.\r\n * <p>Can for example be used to determine the return type.\r\n * @return the prepared Method object (never {@code null})\r\n * @throws IllegalStateException if the invoker hasn't been prepared yet\r\n * @see #prepare\r\n * @see #invoke\r\n */\r\npublic Method getPreparedMethod() throws IllegalStateException {\r\n    if (this.methodObject == null) {\r\n        throw new IllegalStateException(\"prepare() must be called prior to invoke() on MethodInvoker\");\r\n    }\r\n    return this.methodObject;\r\n}\n/**\r\n * Return whether this invoker has been prepared already,\r\n * i.e. whether it allows access to {@link #getPreparedMethod()} already.\r\n */\r\npublic boolean isPrepared() {\r\n    return (this.methodObject != null);\r\n}\n/**\r\n * Invoke the specified method.\r\n * <p>The invoker needs to have been prepared before.\r\n * @return the object (possibly null) returned by the method invocation,\r\n * or {@code null} if the method has a void return type\r\n * @throws InvocationTargetException if the target method threw an exception\r\n * @throws IllegalAccessException if the target method couldn't be accessed\r\n * @see #prepare\r\n */\r\n@Nullable\r\npublic Object invoke() throws InvocationTargetException, IllegalAccessException {\r\n    // In the static case, target will simply be {@code null}.\r\n    Object targetObject = getTargetObject();\r\n    Method preparedMethod = getPreparedMethod();\r\n    if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {\r\n        throw new IllegalArgumentException(\"Target method must not be non-static without a target\");\r\n    }\r\n    ReflectionUtils.makeAccessible(preparedMethod);\r\n    return preparedMethod.invoke(targetObject, getArguments());\r\n}\n/**\r\n * Algorithm that judges the match between the declared parameter types of a candidate method\r\n * and a specific list of arguments that this method is supposed to be invoked with.\r\n * <p>Determines a weight that represents the class hierarchy difference between types and\r\n * arguments. A direct match, i.e. type Integer &rarr; arg of class Integer, does not increase\r\n * the result - all direct matches means weight 0. A match between type Object and arg of\r\n * class Integer would increase the weight by 2, due to the superclass 2 steps up in the\r\n * hierarchy (i.e. Object) being the last one that still matches the required type Object.\r\n * Type Number and class Integer would increase the weight by 1 accordingly, due to the\r\n * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.\r\n * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a\r\n * constructor (Number) which would in turn be preferred to a constructor (Object).\r\n * All argument weights get accumulated.\r\n * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm\r\n * used for constructor and factory method selection in Spring's bean container (in case\r\n * of lenient constructor resolution which is the default for regular bean definitions).\r\n * @param paramTypes the parameter types to match\r\n * @param args the arguments to match\r\n * @return the accumulated weight for all arguments\r\n */\r\npublic static int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args) {\r\n    int result = 0;\r\n    for (int i = 0; i < paramTypes.length; i++) {\r\n        if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n        if (args[i] != null) {\r\n            Class<?> paramType = paramTypes[i];\r\n            Class<?> superClass = args[i].getClass().getSuperclass();\r\n            while (superClass != null) {\r\n                if (paramType.equals(superClass)) {\r\n                    result = result + 2;\r\n                    superClass = null;\r\n                } else if (ClassUtils.isAssignable(paramType, superClass)) {\r\n                    result = result + 2;\r\n                    superClass = superClass.getSuperclass();\r\n                } else {\r\n                    superClass = null;\r\n                }\r\n            }\r\n            if (paramType.isInterface()) {\r\n                result = result + 1;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": "\n * Helper class that allows for specifying a method to invoke in a declarative\n * fashion, be it static or non-static.\n *\n * <p>Usage: Specify \"targetClass\"/\"targetMethod\" or \"targetObject\"/\"targetMethod\",\n * optionally specify arguments, prepare the invoker. Afterwards, you may\n * invoke the method any number of times, obtaining the invocation result.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @since 19.02.2004\n * @see #prepare\n * @see #invoke\n "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Set the target class on which to call the target method.\r\n * Only necessary when the target method is static; else,\r\n * a target object needs to be specified anyway.\r\n * @see #setTargetObject\r\n * @see #setTargetMethod\r\n */\r\npublic void setTargetClass(@Nullable Class<?> targetClass) {\r\n    this.targetClass = targetClass;\r\n}",
    "comment": "\n\t * Set the target class on which to call the target method.\n\t * Only necessary when the target method is static; else,\n\t * a target object needs to be specified anyway.\n\t * @see #setTargetObject\n\t * @see #setTargetMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#getTargetClass()",
    "entityType": "method",
    "code": "/**\r\n * Return the target class on which to call the target method.\r\n */\r\n@Nullable\r\npublic Class<?> getTargetClass() {\r\n    return this.targetClass;\r\n}",
    "comment": "\n\t * Return the target class on which to call the target method.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
    "entityType": "method",
    "code": "/**\r\n * Set the target object on which to call the target method.\r\n * Only necessary when the target method is not static;\r\n * else, a target class is sufficient.\r\n * @see #setTargetClass\r\n * @see #setTargetMethod\r\n */\r\npublic void setTargetObject(@Nullable Object targetObject) {\r\n    this.targetObject = targetObject;\r\n    if (targetObject != null) {\r\n        this.targetClass = targetObject.getClass();\r\n    }\r\n}",
    "comment": "\n\t * Set the target object on which to call the target method.\n\t * Only necessary when the target method is not static;\n\t * else, a target class is sufficient.\n\t * @see #setTargetClass\n\t * @see #setTargetMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#getTargetObject()",
    "entityType": "method",
    "code": "/**\r\n * Return the target object on which to call the target method.\r\n */\r\n@Nullable\r\npublic Object getTargetObject() {\r\n    return this.targetObject;\r\n}",
    "comment": "\n\t * Return the target object on which to call the target method.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#setTargetMethod(String)",
    "entityType": "method",
    "code": "/**\r\n * Set the name of the method to be invoked.\r\n * Refers to either a static method or a non-static method,\r\n * depending on a target object being set.\r\n * @see #setTargetClass\r\n * @see #setTargetObject\r\n */\r\npublic void setTargetMethod(@Nullable String targetMethod) {\r\n    this.targetMethod = targetMethod;\r\n}",
    "comment": "\n\t * Set the name of the method to be invoked.\n\t * Refers to either a static method or a non-static method,\n\t * depending on a target object being set.\n\t * @see #setTargetClass\n\t * @see #setTargetObject\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#getTargetMethod()",
    "entityType": "method",
    "code": "/**\r\n * Return the name of the method to be invoked.\r\n */\r\n@Nullable\r\npublic String getTargetMethod() {\r\n    return this.targetMethod;\r\n}",
    "comment": "\n\t * Return the name of the method to be invoked.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
    "entityType": "method",
    "code": "/**\r\n * Set a fully qualified static method name to invoke,\r\n * for example, \"example.MyExampleClass.myExampleMethod\". This is a\r\n * convenient alternative to specifying targetClass and targetMethod.\r\n * @see #setTargetClass\r\n * @see #setTargetMethod\r\n */\r\npublic void setStaticMethod(String staticMethod) {\r\n    this.staticMethod = staticMethod;\r\n}",
    "comment": "\n\t * Set a fully qualified static method name to invoke,\n\t * for example, \"example.MyExampleClass.myExampleMethod\". This is a\n\t * convenient alternative to specifying targetClass and targetMethod.\n\t * @see #setTargetClass\n\t * @see #setTargetMethod\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#setArguments(Object)",
    "entityType": "method",
    "code": "/**\r\n * Set arguments for the method invocation. If this property is not set,\r\n * or the Object array is of length 0, a method with no arguments is assumed.\r\n */\r\npublic void setArguments(@Nullable Object... arguments) {\r\n    this.arguments = arguments;\r\n}",
    "comment": "\n\t * Set arguments for the method invocation. If this property is not set,\n\t * or the Object array is of length 0, a method with no arguments is assumed.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#getArguments()",
    "entityType": "method",
    "code": "/**\r\n * Return the arguments for the method invocation.\r\n */\r\n@Nullable\r\npublic Object[] getArguments() {\r\n    return (this.arguments != null ? this.arguments : EMPTY_ARGUMENTS);\r\n}",
    "comment": "\n\t * Return the arguments for the method invocation.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#prepare()",
    "entityType": "method",
    "code": "/**\r\n * Prepare the specified method.\r\n * The method can be invoked any number of times afterwards.\r\n * @see #getPreparedMethod\r\n * @see #invoke\r\n */\r\npublic void prepare() throws ClassNotFoundException, NoSuchMethodException {\r\n    if (this.staticMethod != null) {\r\n        int lastDotIndex = this.staticMethod.lastIndexOf('.');\r\n        if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length() - 1) {\r\n            throw new IllegalArgumentException(\"staticMethod must be a fully qualified class plus method name: \" + \"for example, 'example.MyExampleClass.myExampleMethod'\");\r\n        }\r\n        String className = this.staticMethod.substring(0, lastDotIndex);\r\n        String methodName = this.staticMethod.substring(lastDotIndex + 1);\r\n        if (this.targetClass == null || !this.targetClass.getName().equals(className)) {\r\n            this.targetClass = resolveClassName(className);\r\n        }\r\n        this.targetMethod = methodName;\r\n    }\r\n    Class<?> targetClass = getTargetClass();\r\n    String targetMethod = getTargetMethod();\r\n    Assert.notNull(targetClass, \"Either 'targetClass' or 'targetObject' is required\");\r\n    Assert.notNull(targetMethod, \"Property 'targetMethod' is required\");\r\n    @Nullable\r\n    Object[] arguments = getArguments();\r\n    Class<?>[] argTypes = new Class<?>[arguments.length];\r\n    for (int i = 0; i < arguments.length; ++i) {\r\n        argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class);\r\n    }\r\n    // Try to get the exact method first.\r\n    try {\r\n        this.methodObject = targetClass.getMethod(targetMethod, argTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        // Just rethrow exception if we can't get any match.\r\n        this.methodObject = findMatchingMethod();\r\n        if (this.methodObject == null) {\r\n            throw ex;\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Prepare the specified method.\n\t * The method can be invoked any number of times afterwards.\n\t * @see #getPreparedMethod\n\t * @see #invoke\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#resolveClassName(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given class name into a Class.\r\n * <p>The default implementations uses {@code ClassUtils.forName},\r\n * using the thread context class loader.\r\n * @param className the class name to resolve\r\n * @return the resolved Class\r\n * @throws ClassNotFoundException if the class name was invalid\r\n */\r\nprotected Class<?> resolveClassName(String className) throws ClassNotFoundException {\r\n    return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());\r\n}",
    "comment": "\n\t * Resolve the given class name into a Class.\n\t * <p>The default implementations uses {@code ClassUtils.forName},\n\t * using the thread context class loader.\n\t * @param className the class name to resolve\n\t * @return the resolved Class\n\t * @throws ClassNotFoundException if the class name was invalid\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#findMatchingMethod()",
    "entityType": "method",
    "code": "/**\r\n * Find a matching method with the specified name for the specified arguments.\r\n * @return a matching method, or {@code null} if none\r\n * @see #getTargetClass()\r\n * @see #getTargetMethod()\r\n * @see #getArguments()\r\n */\r\n@Nullable\r\nprotected Method findMatchingMethod() {\r\n    String targetMethod = getTargetMethod();\r\n    @Nullable\r\n    Object[] arguments = getArguments();\r\n    int argCount = arguments.length;\r\n    Class<?> targetClass = getTargetClass();\r\n    Assert.state(targetClass != null, \"No target class set\");\r\n    Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);\r\n    int minTypeDiffWeight = Integer.MAX_VALUE;\r\n    Method matchingMethod = null;\r\n    for (Method candidate : candidates) {\r\n        if (candidate.getName().equals(targetMethod) && candidate.getParameterCount() == argCount) {\r\n            Class<?>[] paramTypes = candidate.getParameterTypes();\r\n            int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments);\r\n            if (typeDiffWeight < minTypeDiffWeight) {\r\n                minTypeDiffWeight = typeDiffWeight;\r\n                matchingMethod = candidate;\r\n            }\r\n        }\r\n    }\r\n    return matchingMethod;\r\n}",
    "comment": "\n\t * Find a matching method with the specified name for the specified arguments.\n\t * @return a matching method, or {@code null} if none\n\t * @see #getTargetClass()\n\t * @see #getTargetMethod()\n\t * @see #getArguments()\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#getPreparedMethod()",
    "entityType": "method",
    "code": "/**\r\n * Return the prepared Method object that will be invoked.\r\n * <p>Can for example be used to determine the return type.\r\n * @return the prepared Method object (never {@code null})\r\n * @throws IllegalStateException if the invoker hasn't been prepared yet\r\n * @see #prepare\r\n * @see #invoke\r\n */\r\npublic Method getPreparedMethod() throws IllegalStateException {\r\n    if (this.methodObject == null) {\r\n        throw new IllegalStateException(\"prepare() must be called prior to invoke() on MethodInvoker\");\r\n    }\r\n    return this.methodObject;\r\n}",
    "comment": "\n\t * Return the prepared Method object that will be invoked.\n\t * <p>Can for example be used to determine the return type.\n\t * @return the prepared Method object (never {@code null})\n\t * @throws IllegalStateException if the invoker hasn't been prepared yet\n\t * @see #prepare\n\t * @see #invoke\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#isPrepared()",
    "entityType": "method",
    "code": "/**\r\n * Return whether this invoker has been prepared already,\r\n * i.e. whether it allows access to {@link #getPreparedMethod()} already.\r\n */\r\npublic boolean isPrepared() {\r\n    return (this.methodObject != null);\r\n}",
    "comment": "\n\t * Return whether this invoker has been prepared already,\n\t * i.e. whether it allows access to {@link #getPreparedMethod()} already.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#invoke()",
    "entityType": "method",
    "code": "/**\r\n * Invoke the specified method.\r\n * <p>The invoker needs to have been prepared before.\r\n * @return the object (possibly null) returned by the method invocation,\r\n * or {@code null} if the method has a void return type\r\n * @throws InvocationTargetException if the target method threw an exception\r\n * @throws IllegalAccessException if the target method couldn't be accessed\r\n * @see #prepare\r\n */\r\n@Nullable\r\npublic Object invoke() throws InvocationTargetException, IllegalAccessException {\r\n    // In the static case, target will simply be {@code null}.\r\n    Object targetObject = getTargetObject();\r\n    Method preparedMethod = getPreparedMethod();\r\n    if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {\r\n        throw new IllegalArgumentException(\"Target method must not be non-static without a target\");\r\n    }\r\n    ReflectionUtils.makeAccessible(preparedMethod);\r\n    return preparedMethod.invoke(targetObject, getArguments());\r\n}",
    "comment": "\n\t * Invoke the specified method.\n\t * <p>The invoker needs to have been prepared before.\n\t * @return the object (possibly null) returned by the method invocation,\n\t * or {@code null} if the method has a void return type\n\t * @throws InvocationTargetException if the target method threw an exception\n\t * @throws IllegalAccessException if the target method couldn't be accessed\n\t * @see #prepare\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
    "entityType": "method",
    "code": "/**\r\n * Algorithm that judges the match between the declared parameter types of a candidate method\r\n * and a specific list of arguments that this method is supposed to be invoked with.\r\n * <p>Determines a weight that represents the class hierarchy difference between types and\r\n * arguments. A direct match, i.e. type Integer &rarr; arg of class Integer, does not increase\r\n * the result - all direct matches means weight 0. A match between type Object and arg of\r\n * class Integer would increase the weight by 2, due to the superclass 2 steps up in the\r\n * hierarchy (i.e. Object) being the last one that still matches the required type Object.\r\n * Type Number and class Integer would increase the weight by 1 accordingly, due to the\r\n * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.\r\n * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a\r\n * constructor (Number) which would in turn be preferred to a constructor (Object).\r\n * All argument weights get accumulated.\r\n * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm\r\n * used for constructor and factory method selection in Spring's bean container (in case\r\n * of lenient constructor resolution which is the default for regular bean definitions).\r\n * @param paramTypes the parameter types to match\r\n * @param args the arguments to match\r\n * @return the accumulated weight for all arguments\r\n */\r\npublic static int getTypeDifferenceWeight(Class<?>[] paramTypes, @Nullable Object[] args) {\r\n    int result = 0;\r\n    for (int i = 0; i < paramTypes.length; i++) {\r\n        if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n        if (args[i] != null) {\r\n            Class<?> paramType = paramTypes[i];\r\n            Class<?> superClass = args[i].getClass().getSuperclass();\r\n            while (superClass != null) {\r\n                if (paramType.equals(superClass)) {\r\n                    result = result + 2;\r\n                    superClass = null;\r\n                } else if (ClassUtils.isAssignable(paramType, superClass)) {\r\n                    result = result + 2;\r\n                    superClass = superClass.getSuperclass();\r\n                } else {\r\n                    superClass = null;\r\n                }\r\n            }\r\n            if (paramType.isInterface()) {\r\n                result = result + 1;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Algorithm that judges the match between the declared parameter types of a candidate method\n\t * and a specific list of arguments that this method is supposed to be invoked with.\n\t * <p>Determines a weight that represents the class hierarchy difference between types and\n\t * arguments. A direct match, i.e. type Integer &rarr; arg of class Integer, does not increase\n\t * the result - all direct matches means weight 0. A match between type Object and arg of\n\t * class Integer would increase the weight by 2, due to the superclass 2 steps up in the\n\t * hierarchy (i.e. Object) being the last one that still matches the required type Object.\n\t * Type Number and class Integer would increase the weight by 1 accordingly, due to the\n\t * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number.\n\t * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a\n\t * constructor (Number) which would in turn be preferred to a constructor (Object).\n\t * All argument weights get accumulated.\n\t * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm\n\t * used for constructor and factory method selection in Spring's bean container (in case\n\t * of lenient constructor resolution which is the default for regular bean definitions).\n\t * @param paramTypes the parameter types to match\n\t * @param args the arguments to match\n\t * @return the accumulated weight for all arguments\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType",
    "entityType": "class",
    "code": "private static final long serialVersionUID = 4085923477777865903L;\nprotected static final String WILDCARD_TYPE = \"*\";\nprivate static final String PARAM_CHARSET = \"charset\";\nprivate static final BitSet TOKEN;\nstatic {\r\n    // variable names refer to RFC 2616, section 2.2\r\n    BitSet ctl = new BitSet(128);\r\n    for (int i = 0; i <= 31; i++) {\r\n        ctl.set(i);\r\n    }\r\n    ctl.set(127);\r\n    BitSet separators = new BitSet(128);\r\n    separators.set('(');\r\n    separators.set(')');\r\n    separators.set('<');\r\n    separators.set('>');\r\n    separators.set('@');\r\n    separators.set(',');\r\n    separators.set(';');\r\n    separators.set(':');\r\n    separators.set('\\\\');\r\n    separators.set('\\\"');\r\n    separators.set('/');\r\n    separators.set('[');\r\n    separators.set(']');\r\n    separators.set('?');\r\n    separators.set('=');\r\n    separators.set('{');\r\n    separators.set('}');\r\n    separators.set(' ');\r\n    separators.set('\\t');\r\n    TOKEN = new BitSet(128);\r\n    TOKEN.set(0, 128);\r\n    TOKEN.andNot(ctl);\r\n    TOKEN.andNot(separators);\r\n}\nprivate final String type;\nprivate final String subtype;\n@SuppressWarnings(\"serial\")\r\nprivate final Map<String, String> parameters;\n@Nullable\r\nprivate transient Charset resolvedCharset;\n@Nullable\r\nprivate volatile String toStringValue;\n/**\r\n * Create a new {@code MimeType} for the given primary type.\r\n * <p>The {@linkplain #getSubtype() subtype} is set to <code>\"&#42;\"</code>,\r\n * and the parameters are empty.\r\n * @param type the primary type\r\n * @throws IllegalArgumentException if any of the parameters contains illegal characters\r\n */\r\npublic MimeType(String type) {\r\n    this(type, WILDCARD_TYPE);\r\n}\n/**\r\n * Create a new {@code MimeType} for the given primary type and subtype.\r\n * <p>The parameters are empty.\r\n * @param type the primary type\r\n * @param subtype the subtype\r\n * @throws IllegalArgumentException if any of the parameters contains illegal characters\r\n */\r\npublic MimeType(String type, String subtype) {\r\n    this(type, subtype, Collections.emptyMap());\r\n}\n/**\r\n * Create a new {@code MimeType} for the given type, subtype, and character set.\r\n * @param type the primary type\r\n * @param subtype the subtype\r\n * @param charset the character set\r\n * @throws IllegalArgumentException if any of the parameters contains illegal characters\r\n */\r\npublic MimeType(String type, String subtype, Charset charset) {\r\n    this(type, subtype, Collections.singletonMap(PARAM_CHARSET, charset.name()));\r\n    this.resolvedCharset = charset;\r\n}\n/**\r\n * Copy-constructor that copies the type, subtype, parameters of the given {@code MimeType},\r\n * and allows to set the specified character set.\r\n * @param other the other MimeType\r\n * @param charset the character set\r\n * @throws IllegalArgumentException if any of the parameters contains illegal characters\r\n * @since 4.3\r\n */\r\npublic MimeType(MimeType other, Charset charset) {\r\n    this(other.getType(), other.getSubtype(), addCharsetParameter(charset, other.getParameters()));\r\n    this.resolvedCharset = charset;\r\n}\n/**\r\n * Copy-constructor that copies the type and subtype of the given {@code MimeType},\r\n * and allows for different parameter.\r\n * @param other the other MimeType\r\n * @param parameters the parameters (may be {@code null})\r\n * @throws IllegalArgumentException if any of the parameters contains illegal characters\r\n */\r\npublic MimeType(MimeType other, @Nullable Map<String, String> parameters) {\r\n    this(other.getType(), other.getSubtype(), parameters);\r\n}\n/**\r\n * Create a new {@code MimeType} for the given type, subtype, and parameters.\r\n * @param type the primary type\r\n * @param subtype the subtype\r\n * @param parameters the parameters (may be {@code null})\r\n * @throws IllegalArgumentException if any of the parameters contains illegal characters\r\n */\r\npublic MimeType(String type, String subtype, @Nullable Map<String, String> parameters) {\r\n    Assert.hasLength(type, \"'type' must not be empty\");\r\n    Assert.hasLength(subtype, \"'subtype' must not be empty\");\r\n    checkToken(type);\r\n    checkToken(subtype);\r\n    this.type = type.toLowerCase(Locale.ROOT);\r\n    this.subtype = subtype.toLowerCase(Locale.ROOT);\r\n    if (!CollectionUtils.isEmpty(parameters)) {\r\n        Map<String, String> map = new LinkedCaseInsensitiveMap<>(parameters.size(), Locale.ROOT);\r\n        parameters.forEach((parameter, value) -> {\r\n            checkParameters(parameter, value);\r\n            map.put(parameter, value);\r\n        });\r\n        this.parameters = Collections.unmodifiableMap(map);\r\n    } else {\r\n        this.parameters = Collections.emptyMap();\r\n    }\r\n}\n/**\r\n * Copy-constructor that copies the type, subtype and parameters of the given {@code MimeType},\r\n * skipping checks performed in other constructors.\r\n * @param other the other MimeType\r\n * @since 5.3\r\n */\r\nprotected MimeType(MimeType other) {\r\n    this.type = other.type;\r\n    this.subtype = other.subtype;\r\n    this.parameters = other.parameters;\r\n    this.resolvedCharset = other.resolvedCharset;\r\n    this.toStringValue = other.toStringValue;\r\n}\n/**\r\n * Checks the given token string for illegal characters, as defined in RFC 2616,\r\n * section 2.2.\r\n * @throws IllegalArgumentException in case of illegal characters\r\n * @see <a href=\"https://tools.ietf.org/html/rfc2616#section-2.2\">HTTP 1.1, section 2.2</a>\r\n */\r\nprivate void checkToken(String token) {\r\n    for (int i = 0; i < token.length(); i++) {\r\n        char ch = token.charAt(i);\r\n        if (!TOKEN.get(ch)) {\r\n            throw new IllegalArgumentException(\"Invalid token character '\" + ch + \"' in token \\\"\" + token + \"\\\"\");\r\n        }\r\n    }\r\n}\nprotected void checkParameters(String parameter, String value) {\r\n    Assert.hasLength(parameter, \"'parameter' must not be empty\");\r\n    Assert.hasLength(value, \"'value' must not be empty\");\r\n    checkToken(parameter);\r\n    if (PARAM_CHARSET.equals(parameter)) {\r\n        if (this.resolvedCharset == null) {\r\n            this.resolvedCharset = Charset.forName(unquote(value));\r\n        }\r\n    } else if (!isQuotedString(value)) {\r\n        checkToken(value);\r\n    }\r\n}\nprivate boolean isQuotedString(String s) {\r\n    if (s.length() < 2) {\r\n        return false;\r\n    }\r\n    return ((s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) || (s.startsWith(\"'\") && s.endsWith(\"'\")));\r\n}\nprotected String unquote(String s) {\r\n    return (isQuotedString(s) ? s.substring(1, s.length() - 1) : s);\r\n}\n/**\r\n * Indicates whether the {@linkplain #getType() type} is the wildcard character\r\n * <code>&#42;</code> or not.\r\n */\r\npublic boolean isWildcardType() {\r\n    return WILDCARD_TYPE.equals(getType());\r\n}\n/**\r\n * Indicates whether the {@linkplain #getSubtype() subtype} is the wildcard\r\n * character <code>&#42;</code> or the wildcard character followed by a suffix\r\n * (for example, <code>&#42;+xml</code>).\r\n * @return whether the subtype is a wildcard\r\n */\r\npublic boolean isWildcardSubtype() {\r\n    String subtype = getSubtype();\r\n    return (WILDCARD_TYPE.equals(subtype) || subtype.startsWith(\"*+\"));\r\n}\n/**\r\n * Indicates whether this MIME Type is concrete, i.e. whether neither the type\r\n * nor the subtype is a wildcard character <code>&#42;</code>.\r\n * @return whether this MIME Type is concrete\r\n */\r\npublic boolean isConcrete() {\r\n    return !isWildcardType() && !isWildcardSubtype();\r\n}\n/**\r\n * Return the primary type.\r\n */\r\npublic String getType() {\r\n    return this.type;\r\n}\n/**\r\n * Return the subtype.\r\n */\r\npublic String getSubtype() {\r\n    return this.subtype;\r\n}\n/**\r\n * Return the subtype suffix as defined in RFC 6839.\r\n * @since 5.3\r\n */\r\n@Nullable\r\npublic String getSubtypeSuffix() {\r\n    int suffixIndex = this.subtype.lastIndexOf('+');\r\n    if (suffixIndex != -1 && this.subtype.length() > suffixIndex) {\r\n        return this.subtype.substring(suffixIndex + 1);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Return the character set, as indicated by a {@code charset} parameter, if any.\r\n * @return the character set, or {@code null} if not available\r\n * @since 4.3\r\n */\r\n@Nullable\r\npublic Charset getCharset() {\r\n    return this.resolvedCharset;\r\n}\n/**\r\n * Return a generic parameter value, given a parameter name.\r\n * @param name the parameter name\r\n * @return the parameter value, or {@code null} if not present\r\n */\r\n@Nullable\r\npublic String getParameter(String name) {\r\n    return this.parameters.get(name);\r\n}\n/**\r\n * Return all generic parameter values.\r\n * @return a read-only map (possibly empty, never {@code null})\r\n */\r\npublic Map<String, String> getParameters() {\r\n    return this.parameters;\r\n}\n/**\r\n * Indicate whether this MIME Type includes the given MIME Type.\r\n * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},\r\n * and {@code application/*+xml} includes {@code application/soap+xml}, etc.\r\n * This method is <b>not</b> symmetric.\r\n * @param other the reference MIME Type with which to compare\r\n * @return {@code true} if this MIME Type includes the given MIME Type;\r\n * {@code false} otherwise\r\n */\r\npublic boolean includes(@Nullable MimeType other) {\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    if (isWildcardType()) {\r\n        // */* includes anything\r\n        return true;\r\n    } else if (getType().equals(other.getType())) {\r\n        if (getSubtype().equals(other.getSubtype())) {\r\n            return true;\r\n        }\r\n        if (isWildcardSubtype()) {\r\n            // Wildcard with suffix, for example, application/*+xml\r\n            int thisPlusIdx = getSubtype().lastIndexOf('+');\r\n            if (thisPlusIdx == -1) {\r\n                return true;\r\n            } else {\r\n                // application/*+xml includes application/soap+xml\r\n                int otherPlusIdx = other.getSubtype().lastIndexOf('+');\r\n                if (otherPlusIdx != -1) {\r\n                    String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx);\r\n                    String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1);\r\n                    String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1);\r\n                    if (thisSubtypeSuffix.equals(otherSubtypeSuffix) && WILDCARD_TYPE.equals(thisSubtypeNoSuffix)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Indicate whether this MIME Type is compatible with the given MIME Type.\r\n * <p>For instance, {@code text/*} is compatible with {@code text/plain},\r\n * {@code text/html}, and vice versa. In effect, this method is similar to\r\n * {@link #includes}, except that it <b>is</b> symmetric.\r\n * @param other the reference MIME Type with which to compare\r\n * @return {@code true} if this MIME Type is compatible with the given MIME Type;\r\n * {@code false} otherwise\r\n */\r\npublic boolean isCompatibleWith(@Nullable MimeType other) {\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    if (isWildcardType() || other.isWildcardType()) {\r\n        return true;\r\n    } else if (getType().equals(other.getType())) {\r\n        if (getSubtype().equals(other.getSubtype())) {\r\n            return true;\r\n        }\r\n        if (isWildcardSubtype() || other.isWildcardSubtype()) {\r\n            String thisSuffix = getSubtypeSuffix();\r\n            String otherSuffix = other.getSubtypeSuffix();\r\n            if (getSubtype().equals(WILDCARD_TYPE) || other.getSubtype().equals(WILDCARD_TYPE)) {\r\n                return true;\r\n            } else if (isWildcardSubtype() && thisSuffix != null) {\r\n                return (thisSuffix.equals(other.getSubtype()) || thisSuffix.equals(otherSuffix));\r\n            } else if (other.isWildcardSubtype() && otherSuffix != null) {\r\n                return (getSubtype().equals(otherSuffix) || otherSuffix.equals(thisSuffix));\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Similar to {@link #equals(Object)} but based on the type and subtype\r\n * only, i.e. ignoring parameters.\r\n * @param other the other mime type to compare to\r\n * @return whether the two mime types have the same type and subtype\r\n * @since 5.1.4\r\n */\r\npublic boolean equalsTypeAndSubtype(@Nullable MimeType other) {\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    return this.type.equalsIgnoreCase(other.type) && this.subtype.equalsIgnoreCase(other.subtype);\r\n}\n/**\r\n * Unlike {@link Collection#contains(Object)} which relies on\r\n * {@link MimeType#equals(Object)}, this method only checks the type and the\r\n * subtype, but otherwise ignores parameters.\r\n * @param mimeTypes the list of mime types to perform the check against\r\n * @return whether the list contains the given mime type\r\n * @since 5.1.4\r\n */\r\npublic boolean isPresentIn(Collection<? extends MimeType> mimeTypes) {\r\n    for (MimeType mimeType : mimeTypes) {\r\n        if (mimeType.equalsTypeAndSubtype(this)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MimeType otherType && this.type.equalsIgnoreCase(otherType.type) && this.subtype.equalsIgnoreCase(otherType.subtype) && parametersAreEqual(otherType)));\r\n}\n/**\r\n * Determine if the parameters in this {@code MimeType} and the supplied\r\n * {@code MimeType} are equal, performing case-insensitive comparisons\r\n * for {@link Charset Charsets}.\r\n * @since 4.2\r\n */\r\nprivate boolean parametersAreEqual(MimeType other) {\r\n    if (this.parameters.size() != other.parameters.size()) {\r\n        return false;\r\n    }\r\n    for (Map.Entry<String, String> entry : this.parameters.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (!other.parameters.containsKey(key)) {\r\n            return false;\r\n        }\r\n        if (PARAM_CHARSET.equals(key)) {\r\n            if (!ObjectUtils.nullSafeEquals(getCharset(), other.getCharset())) {\r\n                return false;\r\n            }\r\n        } else if (!ObjectUtils.nullSafeEquals(entry.getValue(), other.parameters.get(key))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Override\r\npublic int hashCode() {\r\n    int result = this.type.hashCode();\r\n    result = 31 * result + this.subtype.hashCode();\r\n    result = 31 * result + this.parameters.hashCode();\r\n    return result;\r\n}\n@Override\r\npublic String toString() {\r\n    String value = this.toStringValue;\r\n    if (value == null) {\r\n        StringBuilder builder = new StringBuilder();\r\n        appendTo(builder);\r\n        value = builder.toString();\r\n        this.toStringValue = value;\r\n    }\r\n    return value;\r\n}\nprotected void appendTo(StringBuilder builder) {\r\n    builder.append(this.type);\r\n    builder.append('/');\r\n    builder.append(this.subtype);\r\n    appendTo(this.parameters, builder);\r\n}\nprivate void appendTo(Map<String, String> map, StringBuilder builder) {\r\n    map.forEach((key, val) -> {\r\n        builder.append(';');\r\n        builder.append(key);\r\n        builder.append('=');\r\n        builder.append(val);\r\n    });\r\n}\n/**\r\n * Compares this MIME Type to another alphabetically.\r\n * @param other the MIME Type to compare to\r\n */\r\n@Override\r\npublic int compareTo(MimeType other) {\r\n    int comp = getType().compareToIgnoreCase(other.getType());\r\n    if (comp != 0) {\r\n        return comp;\r\n    }\r\n    comp = getSubtype().compareToIgnoreCase(other.getSubtype());\r\n    if (comp != 0) {\r\n        return comp;\r\n    }\r\n    comp = getParameters().size() - other.getParameters().size();\r\n    if (comp != 0) {\r\n        return comp;\r\n    }\r\n    TreeSet<String> thisAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\r\n    thisAttributes.addAll(getParameters().keySet());\r\n    TreeSet<String> otherAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\r\n    otherAttributes.addAll(other.getParameters().keySet());\r\n    Iterator<String> thisAttributesIterator = thisAttributes.iterator();\r\n    Iterator<String> otherAttributesIterator = otherAttributes.iterator();\r\n    while (thisAttributesIterator.hasNext()) {\r\n        String thisAttribute = thisAttributesIterator.next();\r\n        String otherAttribute = otherAttributesIterator.next();\r\n        comp = thisAttribute.compareToIgnoreCase(otherAttribute);\r\n        if (comp != 0) {\r\n            return comp;\r\n        }\r\n        if (PARAM_CHARSET.equals(thisAttribute)) {\r\n            Charset thisCharset = getCharset();\r\n            Charset otherCharset = other.getCharset();\r\n            if (thisCharset != otherCharset) {\r\n                if (thisCharset == null) {\r\n                    return -1;\r\n                }\r\n                if (otherCharset == null) {\r\n                    return 1;\r\n                }\r\n                comp = thisCharset.compareTo(otherCharset);\r\n                if (comp != 0) {\r\n                    return comp;\r\n                }\r\n            }\r\n        } else {\r\n            String thisValue = getParameters().get(thisAttribute);\r\n            String otherValue = other.getParameters().get(otherAttribute);\r\n            Assert.notNull(thisValue, \"Parameter for \" + thisAttribute + \" must not be null\");\r\n            if (otherValue == null) {\r\n                otherValue = \"\";\r\n            }\r\n            comp = thisValue.compareTo(otherValue);\r\n            if (comp != 0) {\r\n                return comp;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\n/**\r\n * Indicates whether this {@code MimeType} is more specific than the given\r\n * type.\r\n * <ol>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code false}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code true}.</li>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code false}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code true}.</li>\r\n * <li>if the two mime types have identical {@linkplain #getType() type} and\r\n * {@linkplain #getSubtype() subtype}, then the mime type with the most\r\n * parameters is more specific than the other.</li>\r\n * <li>Otherwise, this method returns {@code false}.</li>\r\n * </ol>\r\n * @param other the {@code MimeType} to be compared\r\n * @return the result of the comparison\r\n * @since 6.0\r\n * @see #isLessSpecific(MimeType)\r\n * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\r\n * and Content, section 5.3.2</a>\r\n */\r\npublic boolean isMoreSpecific(MimeType other) {\r\n    Assert.notNull(other, \"Other must not be null\");\r\n    boolean thisWildcard = isWildcardType();\r\n    boolean otherWildcard = other.isWildcardType();\r\n    if (thisWildcard && !otherWildcard) {\r\n        // */* > audio/*\r\n        return false;\r\n    } else if (!thisWildcard && otherWildcard) {\r\n        // audio/* < */*\r\n        return true;\r\n    } else {\r\n        boolean thisWildcardSubtype = isWildcardSubtype();\r\n        boolean otherWildcardSubtype = other.isWildcardSubtype();\r\n        if (thisWildcardSubtype && !otherWildcardSubtype) {\r\n            // audio/* > audio/basic\r\n            return false;\r\n        } else if (!thisWildcardSubtype && otherWildcardSubtype) {\r\n            // audio/basic < audio/*\r\n            return true;\r\n        } else if (getType().equals(other.getType()) && getSubtype().equals(other.getSubtype())) {\r\n            int paramsSize1 = getParameters().size();\r\n            int paramsSize2 = other.getParameters().size();\r\n            return paramsSize1 > paramsSize2;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\n/**\r\n * Indicates whether this {@code MimeType} is less specific than the given type.\r\n * <ol>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code true}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code false}.</li>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code true}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code false}.</li>\r\n * <li>if the two mime types have identical {@linkplain #getType() type} and\r\n * {@linkplain #getSubtype() subtype}, then the mime type with the least\r\n * parameters is less specific than the other.</li>\r\n * <li>Otherwise, this method returns {@code false}.</li>\r\n * </ol>\r\n * @param other the {@code MimeType} to be compared\r\n * @return the result of the comparison\r\n * @since 6.0\r\n * @see #isMoreSpecific(MimeType)\r\n * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\r\n * and Content, section 5.3.2</a>\r\n */\r\npublic boolean isLessSpecific(MimeType other) {\r\n    Assert.notNull(other, \"Other must not be null\");\r\n    return other.isMoreSpecific(this);\r\n}\nprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\r\n    // Rely on default serialization, just initialize state after deserialization.\r\n    ois.defaultReadObject();\r\n    // Initialize transient fields.\r\n    String charsetName = getParameter(PARAM_CHARSET);\r\n    if (charsetName != null) {\r\n        this.resolvedCharset = Charset.forName(unquote(charsetName));\r\n    }\r\n}\n/**\r\n * Parse the given String value into a {@code MimeType} object,\r\n * with this method name following the 'valueOf' naming convention\r\n * (as supported by {@link org.springframework.core.convert.ConversionService}).\r\n * @see MimeTypeUtils#parseMimeType(String)\r\n */\r\npublic static MimeType valueOf(String value) {\r\n    return MimeTypeUtils.parseMimeType(value);\r\n}\nprivate static Map<String, String> addCharsetParameter(Charset charset, Map<String, String> parameters) {\r\n    Map<String, String> map = new LinkedHashMap<>(parameters);\r\n    map.put(PARAM_CHARSET, charset.name());\r\n    return map;\r\n}",
    "comment": "\n * Represents a MIME Type, as originally defined in RFC 2046 and subsequently\n * used in other Internet protocols including HTTP.\n *\n * <p>This class, however, does not contain support for the q-parameters used\n * in HTTP content negotiation. Those can be found in the subclass\n * {@code org.springframework.http.MediaType} in the {@code spring-web} module.\n *\n * <p>Consists of a {@linkplain #getType() type} and a {@linkplain #getSubtype() subtype}.\n * Also has functionality to parse MIME Type values from a {@code String} using\n * {@link #valueOf(String)}. For more parsing options see {@link MimeTypeUtils}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.0\n * @see MimeTypeUtils\n "
  },
  {
    "entityId": "org.springframework.util.MimeType#checkToken(String)",
    "entityType": "method",
    "code": "/**\r\n * Checks the given token string for illegal characters, as defined in RFC 2616,\r\n * section 2.2.\r\n * @throws IllegalArgumentException in case of illegal characters\r\n * @see <a href=\"https://tools.ietf.org/html/rfc2616#section-2.2\">HTTP 1.1, section 2.2</a>\r\n */\r\nprivate void checkToken(String token) {\r\n    for (int i = 0; i < token.length(); i++) {\r\n        char ch = token.charAt(i);\r\n        if (!TOKEN.get(ch)) {\r\n            throw new IllegalArgumentException(\"Invalid token character '\" + ch + \"' in token \\\"\" + token + \"\\\"\");\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Checks the given token string for illegal characters, as defined in RFC 2616,\n\t * section 2.2.\n\t * @throws IllegalArgumentException in case of illegal characters\n\t * @see <a href=\"https://tools.ietf.org/html/rfc2616#section-2.2\">HTTP 1.1, section 2.2</a>\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#checkParameters(String,String)",
    "entityType": "method",
    "code": "protected void checkParameters(String parameter, String value) {\r\n    Assert.hasLength(parameter, \"'parameter' must not be empty\");\r\n    Assert.hasLength(value, \"'value' must not be empty\");\r\n    checkToken(parameter);\r\n    if (PARAM_CHARSET.equals(parameter)) {\r\n        if (this.resolvedCharset == null) {\r\n            this.resolvedCharset = Charset.forName(unquote(value));\r\n        }\r\n    } else if (!isQuotedString(value)) {\r\n        checkToken(value);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#isQuotedString(String)",
    "entityType": "method",
    "code": "private boolean isQuotedString(String s) {\r\n    if (s.length() < 2) {\r\n        return false;\r\n    }\r\n    return ((s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) || (s.startsWith(\"'\") && s.endsWith(\"'\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#unquote(String)",
    "entityType": "method",
    "code": "protected String unquote(String s) {\r\n    return (isQuotedString(s) ? s.substring(1, s.length() - 1) : s);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#isWildcardType()",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether the {@linkplain #getType() type} is the wildcard character\r\n * <code>&#42;</code> or not.\r\n */\r\npublic boolean isWildcardType() {\r\n    return WILDCARD_TYPE.equals(getType());\r\n}",
    "comment": "\n\t * Indicates whether the {@linkplain #getType() type} is the wildcard character\n\t * <code>&#42;</code> or not.\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#isWildcardSubtype()",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether the {@linkplain #getSubtype() subtype} is the wildcard\r\n * character <code>&#42;</code> or the wildcard character followed by a suffix\r\n * (for example, <code>&#42;+xml</code>).\r\n * @return whether the subtype is a wildcard\r\n */\r\npublic boolean isWildcardSubtype() {\r\n    String subtype = getSubtype();\r\n    return (WILDCARD_TYPE.equals(subtype) || subtype.startsWith(\"*+\"));\r\n}",
    "comment": "\n\t * Indicates whether the {@linkplain #getSubtype() subtype} is the wildcard\n\t * character <code>&#42;</code> or the wildcard character followed by a suffix\n\t * (for example, <code>&#42;+xml</code>).\n\t * @return whether the subtype is a wildcard\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#isConcrete()",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether this MIME Type is concrete, i.e. whether neither the type\r\n * nor the subtype is a wildcard character <code>&#42;</code>.\r\n * @return whether this MIME Type is concrete\r\n */\r\npublic boolean isConcrete() {\r\n    return !isWildcardType() && !isWildcardSubtype();\r\n}",
    "comment": "\n\t * Indicates whether this MIME Type is concrete, i.e. whether neither the type\n\t * nor the subtype is a wildcard character <code>&#42;</code>.\n\t * @return whether this MIME Type is concrete\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#getType()",
    "entityType": "method",
    "code": "/**\r\n * Return the primary type.\r\n */\r\npublic String getType() {\r\n    return this.type;\r\n}",
    "comment": "\n\t * Return the primary type.\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#getSubtype()",
    "entityType": "method",
    "code": "/**\r\n * Return the subtype.\r\n */\r\npublic String getSubtype() {\r\n    return this.subtype;\r\n}",
    "comment": "\n\t * Return the subtype.\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#getSubtypeSuffix()",
    "entityType": "method",
    "code": "/**\r\n * Return the subtype suffix as defined in RFC 6839.\r\n * @since 5.3\r\n */\r\n@Nullable\r\npublic String getSubtypeSuffix() {\r\n    int suffixIndex = this.subtype.lastIndexOf('+');\r\n    if (suffixIndex != -1 && this.subtype.length() > suffixIndex) {\r\n        return this.subtype.substring(suffixIndex + 1);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Return the subtype suffix as defined in RFC 6839.\n\t * @since 5.3\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#getCharset()",
    "entityType": "method",
    "code": "/**\r\n * Return the character set, as indicated by a {@code charset} parameter, if any.\r\n * @return the character set, or {@code null} if not available\r\n * @since 4.3\r\n */\r\n@Nullable\r\npublic Charset getCharset() {\r\n    return this.resolvedCharset;\r\n}",
    "comment": "\n\t * Return the character set, as indicated by a {@code charset} parameter, if any.\n\t * @return the character set, or {@code null} if not available\n\t * @since 4.3\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#getParameter(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a generic parameter value, given a parameter name.\r\n * @param name the parameter name\r\n * @return the parameter value, or {@code null} if not present\r\n */\r\n@Nullable\r\npublic String getParameter(String name) {\r\n    return this.parameters.get(name);\r\n}",
    "comment": "\n\t * Return a generic parameter value, given a parameter name.\n\t * @param name the parameter name\n\t * @return the parameter value, or {@code null} if not present\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#getParameters()",
    "entityType": "method",
    "code": "/**\r\n * Return all generic parameter values.\r\n * @return a read-only map (possibly empty, never {@code null})\r\n */\r\npublic Map<String, String> getParameters() {\r\n    return this.parameters;\r\n}",
    "comment": "\n\t * Return all generic parameter values.\n\t * @return a read-only map (possibly empty, never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#includes(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether this MIME Type includes the given MIME Type.\r\n * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},\r\n * and {@code application/*+xml} includes {@code application/soap+xml}, etc.\r\n * This method is <b>not</b> symmetric.\r\n * @param other the reference MIME Type with which to compare\r\n * @return {@code true} if this MIME Type includes the given MIME Type;\r\n * {@code false} otherwise\r\n */\r\npublic boolean includes(@Nullable MimeType other) {\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    if (isWildcardType()) {\r\n        // */* includes anything\r\n        return true;\r\n    } else if (getType().equals(other.getType())) {\r\n        if (getSubtype().equals(other.getSubtype())) {\r\n            return true;\r\n        }\r\n        if (isWildcardSubtype()) {\r\n            // Wildcard with suffix, for example, application/*+xml\r\n            int thisPlusIdx = getSubtype().lastIndexOf('+');\r\n            if (thisPlusIdx == -1) {\r\n                return true;\r\n            } else {\r\n                // application/*+xml includes application/soap+xml\r\n                int otherPlusIdx = other.getSubtype().lastIndexOf('+');\r\n                if (otherPlusIdx != -1) {\r\n                    String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx);\r\n                    String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1);\r\n                    String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1);\r\n                    if (thisSubtypeSuffix.equals(otherSubtypeSuffix) && WILDCARD_TYPE.equals(thisSubtypeNoSuffix)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Indicate whether this MIME Type includes the given MIME Type.\n\t * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},\n\t * and {@code application/*+xml} includes {@code application/soap+xml}, etc.\n\t * This method is <b>not</b> symmetric.\n\t * @param other the reference MIME Type with which to compare\n\t * @return {@code true} if this MIME Type includes the given MIME Type;\n\t * {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#isCompatibleWith(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Indicate whether this MIME Type is compatible with the given MIME Type.\r\n * <p>For instance, {@code text/*} is compatible with {@code text/plain},\r\n * {@code text/html}, and vice versa. In effect, this method is similar to\r\n * {@link #includes}, except that it <b>is</b> symmetric.\r\n * @param other the reference MIME Type with which to compare\r\n * @return {@code true} if this MIME Type is compatible with the given MIME Type;\r\n * {@code false} otherwise\r\n */\r\npublic boolean isCompatibleWith(@Nullable MimeType other) {\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    if (isWildcardType() || other.isWildcardType()) {\r\n        return true;\r\n    } else if (getType().equals(other.getType())) {\r\n        if (getSubtype().equals(other.getSubtype())) {\r\n            return true;\r\n        }\r\n        if (isWildcardSubtype() || other.isWildcardSubtype()) {\r\n            String thisSuffix = getSubtypeSuffix();\r\n            String otherSuffix = other.getSubtypeSuffix();\r\n            if (getSubtype().equals(WILDCARD_TYPE) || other.getSubtype().equals(WILDCARD_TYPE)) {\r\n                return true;\r\n            } else if (isWildcardSubtype() && thisSuffix != null) {\r\n                return (thisSuffix.equals(other.getSubtype()) || thisSuffix.equals(otherSuffix));\r\n            } else if (other.isWildcardSubtype() && otherSuffix != null) {\r\n                return (getSubtype().equals(otherSuffix) || otherSuffix.equals(thisSuffix));\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Indicate whether this MIME Type is compatible with the given MIME Type.\n\t * <p>For instance, {@code text/*} is compatible with {@code text/plain},\n\t * {@code text/html}, and vice versa. In effect, this method is similar to\n\t * {@link #includes}, except that it <b>is</b> symmetric.\n\t * @param other the reference MIME Type with which to compare\n\t * @return {@code true} if this MIME Type is compatible with the given MIME Type;\n\t * {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Similar to {@link #equals(Object)} but based on the type and subtype\r\n * only, i.e. ignoring parameters.\r\n * @param other the other mime type to compare to\r\n * @return whether the two mime types have the same type and subtype\r\n * @since 5.1.4\r\n */\r\npublic boolean equalsTypeAndSubtype(@Nullable MimeType other) {\r\n    if (other == null) {\r\n        return false;\r\n    }\r\n    return this.type.equalsIgnoreCase(other.type) && this.subtype.equalsIgnoreCase(other.subtype);\r\n}",
    "comment": "\n\t * Similar to {@link #equals(Object)} but based on the type and subtype\n\t * only, i.e. ignoring parameters.\n\t * @param other the other mime type to compare to\n\t * @return whether the two mime types have the same type and subtype\n\t * @since 5.1.4\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
    "entityType": "method",
    "code": "/**\r\n * Unlike {@link Collection#contains(Object)} which relies on\r\n * {@link MimeType#equals(Object)}, this method only checks the type and the\r\n * subtype, but otherwise ignores parameters.\r\n * @param mimeTypes the list of mime types to perform the check against\r\n * @return whether the list contains the given mime type\r\n * @since 5.1.4\r\n */\r\npublic boolean isPresentIn(Collection<? extends MimeType> mimeTypes) {\r\n    for (MimeType mimeType : mimeTypes) {\r\n        if (mimeType.equalsTypeAndSubtype(this)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Unlike {@link Collection#contains(Object)} which relies on\n\t * {@link MimeType#equals(Object)}, this method only checks the type and the\n\t * subtype, but otherwise ignores parameters.\n\t * @param mimeTypes the list of mime types to perform the check against\n\t * @return whether the list contains the given mime type\n\t * @since 5.1.4\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MimeType otherType && this.type.equalsIgnoreCase(otherType.type) && this.subtype.equalsIgnoreCase(otherType.subtype) && parametersAreEqual(otherType)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#parametersAreEqual(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the parameters in this {@code MimeType} and the supplied\r\n * {@code MimeType} are equal, performing case-insensitive comparisons\r\n * for {@link Charset Charsets}.\r\n * @since 4.2\r\n */\r\nprivate boolean parametersAreEqual(MimeType other) {\r\n    if (this.parameters.size() != other.parameters.size()) {\r\n        return false;\r\n    }\r\n    for (Map.Entry<String, String> entry : this.parameters.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (!other.parameters.containsKey(key)) {\r\n            return false;\r\n        }\r\n        if (PARAM_CHARSET.equals(key)) {\r\n            if (!ObjectUtils.nullSafeEquals(getCharset(), other.getCharset())) {\r\n                return false;\r\n            }\r\n        } else if (!ObjectUtils.nullSafeEquals(entry.getValue(), other.parameters.get(key))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Determine if the parameters in this {@code MimeType} and the supplied\n\t * {@code MimeType} are equal, performing case-insensitive comparisons\n\t * for {@link Charset Charsets}.\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    int result = this.type.hashCode();\r\n    result = 31 * result + this.subtype.hashCode();\r\n    result = 31 * result + this.parameters.hashCode();\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    String value = this.toStringValue;\r\n    if (value == null) {\r\n        StringBuilder builder = new StringBuilder();\r\n        appendTo(builder);\r\n        value = builder.toString();\r\n        this.toStringValue = value;\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#appendTo(StringBuilder)",
    "entityType": "method",
    "code": "protected void appendTo(StringBuilder builder) {\r\n    builder.append(this.type);\r\n    builder.append('/');\r\n    builder.append(this.subtype);\r\n    appendTo(this.parameters, builder);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#appendTo(Map<String,String>,StringBuilder)",
    "entityType": "method",
    "code": "private void appendTo(Map<String, String> map, StringBuilder builder) {\r\n    map.forEach((key, val) -> {\r\n        builder.append(';');\r\n        builder.append(key);\r\n        builder.append('=');\r\n        builder.append(val);\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#compareTo(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Compares this MIME Type to another alphabetically.\r\n * @param other the MIME Type to compare to\r\n */\r\n@Override\r\npublic int compareTo(MimeType other) {\r\n    int comp = getType().compareToIgnoreCase(other.getType());\r\n    if (comp != 0) {\r\n        return comp;\r\n    }\r\n    comp = getSubtype().compareToIgnoreCase(other.getSubtype());\r\n    if (comp != 0) {\r\n        return comp;\r\n    }\r\n    comp = getParameters().size() - other.getParameters().size();\r\n    if (comp != 0) {\r\n        return comp;\r\n    }\r\n    TreeSet<String> thisAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\r\n    thisAttributes.addAll(getParameters().keySet());\r\n    TreeSet<String> otherAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\r\n    otherAttributes.addAll(other.getParameters().keySet());\r\n    Iterator<String> thisAttributesIterator = thisAttributes.iterator();\r\n    Iterator<String> otherAttributesIterator = otherAttributes.iterator();\r\n    while (thisAttributesIterator.hasNext()) {\r\n        String thisAttribute = thisAttributesIterator.next();\r\n        String otherAttribute = otherAttributesIterator.next();\r\n        comp = thisAttribute.compareToIgnoreCase(otherAttribute);\r\n        if (comp != 0) {\r\n            return comp;\r\n        }\r\n        if (PARAM_CHARSET.equals(thisAttribute)) {\r\n            Charset thisCharset = getCharset();\r\n            Charset otherCharset = other.getCharset();\r\n            if (thisCharset != otherCharset) {\r\n                if (thisCharset == null) {\r\n                    return -1;\r\n                }\r\n                if (otherCharset == null) {\r\n                    return 1;\r\n                }\r\n                comp = thisCharset.compareTo(otherCharset);\r\n                if (comp != 0) {\r\n                    return comp;\r\n                }\r\n            }\r\n        } else {\r\n            String thisValue = getParameters().get(thisAttribute);\r\n            String otherValue = other.getParameters().get(otherAttribute);\r\n            Assert.notNull(thisValue, \"Parameter for \" + thisAttribute + \" must not be null\");\r\n            if (otherValue == null) {\r\n                otherValue = \"\";\r\n            }\r\n            comp = thisValue.compareTo(otherValue);\r\n            if (comp != 0) {\r\n                return comp;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "comment": "\n\t * Compares this MIME Type to another alphabetically.\n\t * @param other the MIME Type to compare to\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#isMoreSpecific(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether this {@code MimeType} is more specific than the given\r\n * type.\r\n * <ol>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code false}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code true}.</li>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code false}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code true}.</li>\r\n * <li>if the two mime types have identical {@linkplain #getType() type} and\r\n * {@linkplain #getSubtype() subtype}, then the mime type with the most\r\n * parameters is more specific than the other.</li>\r\n * <li>Otherwise, this method returns {@code false}.</li>\r\n * </ol>\r\n * @param other the {@code MimeType} to be compared\r\n * @return the result of the comparison\r\n * @since 6.0\r\n * @see #isLessSpecific(MimeType)\r\n * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\r\n * and Content, section 5.3.2</a>\r\n */\r\npublic boolean isMoreSpecific(MimeType other) {\r\n    Assert.notNull(other, \"Other must not be null\");\r\n    boolean thisWildcard = isWildcardType();\r\n    boolean otherWildcard = other.isWildcardType();\r\n    if (thisWildcard && !otherWildcard) {\r\n        // */* > audio/*\r\n        return false;\r\n    } else if (!thisWildcard && otherWildcard) {\r\n        // audio/* < */*\r\n        return true;\r\n    } else {\r\n        boolean thisWildcardSubtype = isWildcardSubtype();\r\n        boolean otherWildcardSubtype = other.isWildcardSubtype();\r\n        if (thisWildcardSubtype && !otherWildcardSubtype) {\r\n            // audio/* > audio/basic\r\n            return false;\r\n        } else if (!thisWildcardSubtype && otherWildcardSubtype) {\r\n            // audio/basic < audio/*\r\n            return true;\r\n        } else if (getType().equals(other.getType()) && getSubtype().equals(other.getSubtype())) {\r\n            int paramsSize1 = getParameters().size();\r\n            int paramsSize2 = other.getParameters().size();\r\n            return paramsSize1 > paramsSize2;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Indicates whether this {@code MimeType} is more specific than the given\n\t * type.\n\t * <ol>\n\t * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does not, then this method returns {@code false}.</li>\n\t * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does, then this method returns {@code true}.</li>\n\t * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does not, then this method returns {@code false}.</li>\n\t * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does, then this method returns {@code true}.</li>\n\t * <li>if the two mime types have identical {@linkplain #getType() type} and\n\t * {@linkplain #getSubtype() subtype}, then the mime type with the most\n\t * parameters is more specific than the other.</li>\n\t * <li>Otherwise, this method returns {@code false}.</li>\n\t * </ol>\n\t * @param other the {@code MimeType} to be compared\n\t * @return the result of the comparison\n\t * @since 6.0\n\t * @see #isLessSpecific(MimeType)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\n\t * and Content, section 5.3.2</a>\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#isLessSpecific(MimeType)",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether this {@code MimeType} is less specific than the given type.\r\n * <ol>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code true}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code false}.</li>\r\n * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does not, then this method returns {@code true}.</li>\r\n * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\r\n * and the other does, then this method returns {@code false}.</li>\r\n * <li>if the two mime types have identical {@linkplain #getType() type} and\r\n * {@linkplain #getSubtype() subtype}, then the mime type with the least\r\n * parameters is less specific than the other.</li>\r\n * <li>Otherwise, this method returns {@code false}.</li>\r\n * </ol>\r\n * @param other the {@code MimeType} to be compared\r\n * @return the result of the comparison\r\n * @since 6.0\r\n * @see #isMoreSpecific(MimeType)\r\n * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\r\n * and Content, section 5.3.2</a>\r\n */\r\npublic boolean isLessSpecific(MimeType other) {\r\n    Assert.notNull(other, \"Other must not be null\");\r\n    return other.isMoreSpecific(this);\r\n}",
    "comment": "\n\t * Indicates whether this {@code MimeType} is less specific than the given type.\n\t * <ol>\n\t * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does not, then this method returns {@code true}.</li>\n\t * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does, then this method returns {@code false}.</li>\n\t * <li>if this mime type has a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does not, then this method returns {@code true}.</li>\n\t * <li>if this mime type does not have a {@linkplain #isWildcardType() wildcard type},\n\t * and the other does, then this method returns {@code false}.</li>\n\t * <li>if the two mime types have identical {@linkplain #getType() type} and\n\t * {@linkplain #getSubtype() subtype}, then the mime type with the least\n\t * parameters is less specific than the other.</li>\n\t * <li>Otherwise, this method returns {@code false}.</li>\n\t * </ol>\n\t * @param other the {@code MimeType} to be compared\n\t * @return the result of the comparison\n\t * @since 6.0\n\t * @see #isMoreSpecific(MimeType)\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\n\t * and Content, section 5.3.2</a>\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
    "entityType": "method",
    "code": "private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\r\n    // Rely on default serialization, just initialize state after deserialization.\r\n    ois.defaultReadObject();\r\n    // Initialize transient fields.\r\n    String charsetName = getParameter(PARAM_CHARSET);\r\n    if (charsetName != null) {\r\n        this.resolvedCharset = Charset.forName(unquote(charsetName));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeType#valueOf(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the given String value into a {@code MimeType} object,\r\n * with this method name following the 'valueOf' naming convention\r\n * (as supported by {@link org.springframework.core.convert.ConversionService}).\r\n * @see MimeTypeUtils#parseMimeType(String)\r\n */\r\npublic static MimeType valueOf(String value) {\r\n    return MimeTypeUtils.parseMimeType(value);\r\n}",
    "comment": "\n\t * Parse the given String value into a {@code MimeType} object,\n\t * with this method name following the 'valueOf' naming convention\n\t * (as supported by {@link org.springframework.core.convert.ConversionService}).\n\t * @see MimeTypeUtils#parseMimeType(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeType#addCharsetParameter(Charset,Map<String,String>)",
    "entityType": "method",
    "code": "private static Map<String, String> addCharsetParameter(Charset charset, Map<String, String> parameters) {\r\n    Map<String, String> map = new LinkedHashMap<>(parameters);\r\n    map.put(PARAM_CHARSET, charset.name());\r\n    return map;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils",
    "entityType": "class",
    "code": "private static final byte[] BOUNDARY_CHARS = new byte[] { '-', '_', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };\n/**\r\n * Public constant mime type that includes all media ranges (i.e. \"&#42;/&#42;\").\r\n */\r\npublic static final MimeType ALL;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#ALL}.\r\n */\r\npublic static final String ALL_VALUE = \"*/*\";\n/**\r\n * Public constant mime type for {@code application/graphql+json}.\r\n * @since 5.3.19\r\n * @see <a href=\"https://github.com/graphql/graphql-over-http\">GraphQL over HTTP spec</a>\r\n */\r\npublic static final MimeType APPLICATION_GRAPHQL;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#APPLICATION_GRAPHQL}.\r\n * @since 5.3.19\r\n */\r\npublic static final String APPLICATION_GRAPHQL_VALUE = \"application/graphql+json\";\n/**\r\n * Public constant mime type for {@code application/json}.\r\n */\r\npublic static final MimeType APPLICATION_JSON;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#APPLICATION_JSON}.\r\n */\r\npublic static final String APPLICATION_JSON_VALUE = \"application/json\";\n/**\r\n * Public constant mime type for {@code application/octet-stream}.\r\n */\r\npublic static final MimeType APPLICATION_OCTET_STREAM;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#APPLICATION_OCTET_STREAM}.\r\n */\r\npublic static final String APPLICATION_OCTET_STREAM_VALUE = \"application/octet-stream\";\n/**\r\n * Public constant mime type for {@code application/xml}.\r\n */\r\npublic static final MimeType APPLICATION_XML;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#APPLICATION_XML}.\r\n */\r\npublic static final String APPLICATION_XML_VALUE = \"application/xml\";\n/**\r\n * Public constant mime type for {@code image/gif}.\r\n */\r\npublic static final MimeType IMAGE_GIF;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#IMAGE_GIF}.\r\n */\r\npublic static final String IMAGE_GIF_VALUE = \"image/gif\";\n/**\r\n * Public constant mime type for {@code image/jpeg}.\r\n */\r\npublic static final MimeType IMAGE_JPEG;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#IMAGE_JPEG}.\r\n */\r\npublic static final String IMAGE_JPEG_VALUE = \"image/jpeg\";\n/**\r\n * Public constant mime type for {@code image/png}.\r\n */\r\npublic static final MimeType IMAGE_PNG;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#IMAGE_PNG}.\r\n */\r\npublic static final String IMAGE_PNG_VALUE = \"image/png\";\n/**\r\n * Public constant mime type for {@code text/html}.\r\n */\r\npublic static final MimeType TEXT_HTML;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#TEXT_HTML}.\r\n */\r\npublic static final String TEXT_HTML_VALUE = \"text/html\";\n/**\r\n * Public constant mime type for {@code text/plain}.\r\n */\r\npublic static final MimeType TEXT_PLAIN;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#TEXT_PLAIN}.\r\n */\r\npublic static final String TEXT_PLAIN_VALUE = \"text/plain\";\n/**\r\n * Public constant mime type for {@code text/xml}.\r\n */\r\npublic static final MimeType TEXT_XML;\n/**\r\n * A String equivalent of {@link MimeTypeUtils#TEXT_XML}.\r\n */\r\npublic static final String TEXT_XML_VALUE = \"text/xml\";\nprivate static final ConcurrentLruCache<String, MimeType> cachedMimeTypes = new ConcurrentLruCache<>(64, MimeTypeUtils::parseMimeTypeInternal);\n@Nullable\r\nprivate static volatile Random random;\nstatic {\r\n    // Not using \"parseMimeType\" to avoid static init cost\r\n    ALL = new MimeType(MimeType.WILDCARD_TYPE, MimeType.WILDCARD_TYPE);\r\n    APPLICATION_GRAPHQL = new MimeType(\"application\", \"graphql+json\");\r\n    APPLICATION_JSON = new MimeType(\"application\", \"json\");\r\n    APPLICATION_OCTET_STREAM = new MimeType(\"application\", \"octet-stream\");\r\n    APPLICATION_XML = new MimeType(\"application\", \"xml\");\r\n    IMAGE_GIF = new MimeType(\"image\", \"gif\");\r\n    IMAGE_JPEG = new MimeType(\"image\", \"jpeg\");\r\n    IMAGE_PNG = new MimeType(\"image\", \"png\");\r\n    TEXT_HTML = new MimeType(\"text\", \"html\");\r\n    TEXT_PLAIN = new MimeType(\"text\", \"plain\");\r\n    TEXT_XML = new MimeType(\"text\", \"xml\");\r\n}\n/**\r\n * Parse the given String into a single {@code MimeType}.\r\n * Recently parsed {@code MimeType} are cached for further retrieval.\r\n * @param mimeType the string to parse\r\n * @return the mime type\r\n * @throws InvalidMimeTypeException if the string cannot be parsed\r\n */\r\npublic static MimeType parseMimeType(String mimeType) {\r\n    if (!StringUtils.hasLength(mimeType)) {\r\n        throw new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\r\n    }\r\n    // do not cache multipart mime types with random boundaries\r\n    if (mimeType.startsWith(\"multipart\")) {\r\n        return parseMimeTypeInternal(mimeType);\r\n    }\r\n    return cachedMimeTypes.get(mimeType);\r\n}\nprivate static MimeType parseMimeTypeInternal(String mimeType) {\r\n    int index = mimeType.indexOf(';');\r\n    String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim();\r\n    if (fullType.isEmpty()) {\r\n        throw new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\r\n    }\r\n    // java.net.HttpURLConnection returns a *; q=.2 Accept header\r\n    if (MimeType.WILDCARD_TYPE.equals(fullType)) {\r\n        fullType = \"*/*\";\r\n    }\r\n    int subIndex = fullType.indexOf('/');\r\n    if (subIndex == -1) {\r\n        throw new InvalidMimeTypeException(mimeType, \"does not contain '/'\");\r\n    }\r\n    if (subIndex == fullType.length() - 1) {\r\n        throw new InvalidMimeTypeException(mimeType, \"does not contain subtype after '/'\");\r\n    }\r\n    String type = fullType.substring(0, subIndex);\r\n    String subtype = fullType.substring(subIndex + 1);\r\n    if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {\r\n        throw new InvalidMimeTypeException(mimeType, \"wildcard type is legal only in '*/*' (all mime types)\");\r\n    }\r\n    Map<String, String> parameters = null;\r\n    do {\r\n        int nextIndex = index + 1;\r\n        boolean quoted = false;\r\n        while (nextIndex < mimeType.length()) {\r\n            char ch = mimeType.charAt(nextIndex);\r\n            if (ch == ';') {\r\n                if (!quoted) {\r\n                    break;\r\n                }\r\n            } else if (ch == '\"') {\r\n                quoted = !quoted;\r\n            }\r\n            nextIndex++;\r\n        }\r\n        String parameter = mimeType.substring(index + 1, nextIndex).trim();\r\n        if (parameter.length() > 0) {\r\n            if (parameters == null) {\r\n                parameters = new LinkedHashMap<>(4);\r\n            }\r\n            int eqIndex = parameter.indexOf('=');\r\n            if (eqIndex >= 0) {\r\n                String attribute = parameter.substring(0, eqIndex).trim();\r\n                String value = parameter.substring(eqIndex + 1).trim();\r\n                parameters.put(attribute, value);\r\n            }\r\n        }\r\n        index = nextIndex;\r\n    } while (index < mimeType.length());\r\n    try {\r\n        return new MimeType(type, subtype, parameters);\r\n    } catch (UnsupportedCharsetException ex) {\r\n        throw new InvalidMimeTypeException(mimeType, \"unsupported charset '\" + ex.getCharsetName() + \"'\");\r\n    } catch (IllegalArgumentException ex) {\r\n        throw new InvalidMimeTypeException(mimeType, ex.getMessage());\r\n    }\r\n}\n/**\r\n * Parse the comma-separated string into a mutable list of {@code MimeType} objects.\r\n * @param mimeTypes the string to parse\r\n * @return the list of mime types\r\n * @throws InvalidMimeTypeException if the string cannot be parsed\r\n */\r\npublic static List<MimeType> parseMimeTypes(String mimeTypes) {\r\n    if (!StringUtils.hasLength(mimeTypes)) {\r\n        return Collections.emptyList();\r\n    }\r\n    return tokenize(mimeTypes).stream().filter(StringUtils::hasText).map(MimeTypeUtils::parseMimeType).collect(Collectors.toList());\r\n}\n/**\r\n * Tokenize the given comma-separated string of {@code MimeType} objects\r\n * into a {@code List<String>}. Unlike simple tokenization by \",\", this\r\n * method takes into account quoted parameters.\r\n * @param mimeTypes the string to tokenize\r\n * @return the list of tokens\r\n * @since 5.1.3\r\n */\r\npublic static List<String> tokenize(String mimeTypes) {\r\n    if (!StringUtils.hasLength(mimeTypes)) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<String> tokens = new ArrayList<>();\r\n    boolean inQuotes = false;\r\n    int startIndex = 0;\r\n    int i = 0;\r\n    while (i < mimeTypes.length()) {\r\n        switch(mimeTypes.charAt(i)) {\r\n            case '\"' ->\r\n                inQuotes = !inQuotes;\r\n            case ',' ->\r\n                {\r\n                    if (!inQuotes) {\r\n                        tokens.add(mimeTypes.substring(startIndex, i));\r\n                        startIndex = i + 1;\r\n                    }\r\n                }\r\n            case '\\\\' ->\r\n                i++;\r\n        }\r\n        i++;\r\n    }\r\n    tokens.add(mimeTypes.substring(startIndex));\r\n    return tokens;\r\n}\n/**\r\n * Generate a string representation of the given collection of {@link MimeType}\r\n * objects.\r\n * @param mimeTypes the {@code MimeType} objects\r\n * @return a string representation of the {@code MimeType} objects\r\n */\r\npublic static String toString(Collection<? extends MimeType> mimeTypes) {\r\n    StringBuilder builder = new StringBuilder();\r\n    for (Iterator<? extends MimeType> iterator = mimeTypes.iterator(); iterator.hasNext(); ) {\r\n        MimeType mimeType = iterator.next();\r\n        mimeType.appendTo(builder);\r\n        if (iterator.hasNext()) {\r\n            builder.append(\", \");\r\n        }\r\n    }\r\n    return builder.toString();\r\n}\n/**\r\n * Sort the given list of {@code MimeType} objects by\r\n * {@linkplain MimeType#isMoreSpecific(MimeType) specificity}.\r\n * <p>Because of the computational cost, this method throws an exception if\r\n * the given list contains too many elements.\r\n * @param mimeTypes the list of mime types to be sorted\r\n * @throws InvalidMimeTypeException if {@code mimeTypes} contains more than 50 elements\r\n * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\r\n * and Content, section 5.3.2</a>\r\n * @see MimeType#isMoreSpecific(MimeType)\r\n */\r\npublic static <T extends MimeType> void sortBySpecificity(List<T> mimeTypes) {\r\n    Assert.notNull(mimeTypes, \"'mimeTypes' must not be null\");\r\n    if (mimeTypes.size() > 50) {\r\n        throw new InvalidMimeTypeException(mimeTypes.toString(), \"Too many elements\");\r\n    }\r\n    bubbleSort(mimeTypes, MimeType::isLessSpecific);\r\n}\nstatic <T> void bubbleSort(List<T> list, BiPredicate<? super T, ? super T> swap) {\r\n    int len = list.size();\r\n    for (int i = 0; i < len; i++) {\r\n        for (int j = 1; j < len - i; j++) {\r\n            T prev = list.get(j - 1);\r\n            T cur = list.get(j);\r\n            if (swap.test(prev, cur)) {\r\n                list.set(j, prev);\r\n                list.set(j - 1, cur);\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Generate a random MIME boundary as bytes, often used in multipart mime types.\r\n */\r\npublic static byte[] generateMultipartBoundary() {\r\n    Random randomToUse = initRandom();\r\n    byte[] boundary = new byte[randomToUse.nextInt(11) + 30];\r\n    for (int i = 0; i < boundary.length; i++) {\r\n        boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)];\r\n    }\r\n    return boundary;\r\n}\n/**\r\n * Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.\r\n */\r\nprivate static Random initRandom() {\r\n    Random randomToUse = random;\r\n    if (randomToUse == null) {\r\n        synchronized (MimeTypeUtils.class) {\r\n            randomToUse = random;\r\n            if (randomToUse == null) {\r\n                randomToUse = new SecureRandom();\r\n                random = randomToUse;\r\n            }\r\n        }\r\n    }\r\n    return randomToUse;\r\n}\n/**\r\n * Generate a random MIME boundary as String, often used in multipart mime types.\r\n */\r\npublic static String generateMultipartBoundaryString() {\r\n    return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII);\r\n}",
    "comment": "\n * Miscellaneous {@link MimeType} utility methods.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Dimitrios Liapis\n * @author Brian Clozel\n * @author Sam Brannen\n * @since 4.0\n "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the given String into a single {@code MimeType}.\r\n * Recently parsed {@code MimeType} are cached for further retrieval.\r\n * @param mimeType the string to parse\r\n * @return the mime type\r\n * @throws InvalidMimeTypeException if the string cannot be parsed\r\n */\r\npublic static MimeType parseMimeType(String mimeType) {\r\n    if (!StringUtils.hasLength(mimeType)) {\r\n        throw new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\r\n    }\r\n    // do not cache multipart mime types with random boundaries\r\n    if (mimeType.startsWith(\"multipart\")) {\r\n        return parseMimeTypeInternal(mimeType);\r\n    }\r\n    return cachedMimeTypes.get(mimeType);\r\n}",
    "comment": "\n\t * Parse the given String into a single {@code MimeType}.\n\t * Recently parsed {@code MimeType} are cached for further retrieval.\n\t * @param mimeType the string to parse\n\t * @return the mime type\n\t * @throws InvalidMimeTypeException if the string cannot be parsed\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
    "entityType": "method",
    "code": "private static MimeType parseMimeTypeInternal(String mimeType) {\r\n    int index = mimeType.indexOf(';');\r\n    String fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim();\r\n    if (fullType.isEmpty()) {\r\n        throw new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\r\n    }\r\n    // java.net.HttpURLConnection returns a *; q=.2 Accept header\r\n    if (MimeType.WILDCARD_TYPE.equals(fullType)) {\r\n        fullType = \"*/*\";\r\n    }\r\n    int subIndex = fullType.indexOf('/');\r\n    if (subIndex == -1) {\r\n        throw new InvalidMimeTypeException(mimeType, \"does not contain '/'\");\r\n    }\r\n    if (subIndex == fullType.length() - 1) {\r\n        throw new InvalidMimeTypeException(mimeType, \"does not contain subtype after '/'\");\r\n    }\r\n    String type = fullType.substring(0, subIndex);\r\n    String subtype = fullType.substring(subIndex + 1);\r\n    if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {\r\n        throw new InvalidMimeTypeException(mimeType, \"wildcard type is legal only in '*/*' (all mime types)\");\r\n    }\r\n    Map<String, String> parameters = null;\r\n    do {\r\n        int nextIndex = index + 1;\r\n        boolean quoted = false;\r\n        while (nextIndex < mimeType.length()) {\r\n            char ch = mimeType.charAt(nextIndex);\r\n            if (ch == ';') {\r\n                if (!quoted) {\r\n                    break;\r\n                }\r\n            } else if (ch == '\"') {\r\n                quoted = !quoted;\r\n            }\r\n            nextIndex++;\r\n        }\r\n        String parameter = mimeType.substring(index + 1, nextIndex).trim();\r\n        if (parameter.length() > 0) {\r\n            if (parameters == null) {\r\n                parameters = new LinkedHashMap<>(4);\r\n            }\r\n            int eqIndex = parameter.indexOf('=');\r\n            if (eqIndex >= 0) {\r\n                String attribute = parameter.substring(0, eqIndex).trim();\r\n                String value = parameter.substring(eqIndex + 1).trim();\r\n                parameters.put(attribute, value);\r\n            }\r\n        }\r\n        index = nextIndex;\r\n    } while (index < mimeType.length());\r\n    try {\r\n        return new MimeType(type, subtype, parameters);\r\n    } catch (UnsupportedCharsetException ex) {\r\n        throw new InvalidMimeTypeException(mimeType, \"unsupported charset '\" + ex.getCharsetName() + \"'\");\r\n    } catch (IllegalArgumentException ex) {\r\n        throw new InvalidMimeTypeException(mimeType, ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the comma-separated string into a mutable list of {@code MimeType} objects.\r\n * @param mimeTypes the string to parse\r\n * @return the list of mime types\r\n * @throws InvalidMimeTypeException if the string cannot be parsed\r\n */\r\npublic static List<MimeType> parseMimeTypes(String mimeTypes) {\r\n    if (!StringUtils.hasLength(mimeTypes)) {\r\n        return Collections.emptyList();\r\n    }\r\n    return tokenize(mimeTypes).stream().filter(StringUtils::hasText).map(MimeTypeUtils::parseMimeType).collect(Collectors.toList());\r\n}",
    "comment": "\n\t * Parse the comma-separated string into a mutable list of {@code MimeType} objects.\n\t * @param mimeTypes the string to parse\n\t * @return the list of mime types\n\t * @throws InvalidMimeTypeException if the string cannot be parsed\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#tokenize(String)",
    "entityType": "method",
    "code": "/**\r\n * Tokenize the given comma-separated string of {@code MimeType} objects\r\n * into a {@code List<String>}. Unlike simple tokenization by \",\", this\r\n * method takes into account quoted parameters.\r\n * @param mimeTypes the string to tokenize\r\n * @return the list of tokens\r\n * @since 5.1.3\r\n */\r\npublic static List<String> tokenize(String mimeTypes) {\r\n    if (!StringUtils.hasLength(mimeTypes)) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<String> tokens = new ArrayList<>();\r\n    boolean inQuotes = false;\r\n    int startIndex = 0;\r\n    int i = 0;\r\n    while (i < mimeTypes.length()) {\r\n        switch(mimeTypes.charAt(i)) {\r\n            case '\"' ->\r\n                inQuotes = !inQuotes;\r\n            case ',' ->\r\n                {\r\n                    if (!inQuotes) {\r\n                        tokens.add(mimeTypes.substring(startIndex, i));\r\n                        startIndex = i + 1;\r\n                    }\r\n                }\r\n            case '\\\\' ->\r\n                i++;\r\n        }\r\n        i++;\r\n    }\r\n    tokens.add(mimeTypes.substring(startIndex));\r\n    return tokens;\r\n}",
    "comment": "\n\t * Tokenize the given comma-separated string of {@code MimeType} objects\n\t * into a {@code List<String>}. Unlike simple tokenization by \",\", this\n\t * method takes into account quoted parameters.\n\t * @param mimeTypes the string to tokenize\n\t * @return the list of tokens\n\t * @since 5.1.3\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#toString(Collection<? extends MimeType>)",
    "entityType": "method",
    "code": "/**\r\n * Generate a string representation of the given collection of {@link MimeType}\r\n * objects.\r\n * @param mimeTypes the {@code MimeType} objects\r\n * @return a string representation of the {@code MimeType} objects\r\n */\r\npublic static String toString(Collection<? extends MimeType> mimeTypes) {\r\n    StringBuilder builder = new StringBuilder();\r\n    for (Iterator<? extends MimeType> iterator = mimeTypes.iterator(); iterator.hasNext(); ) {\r\n        MimeType mimeType = iterator.next();\r\n        mimeType.appendTo(builder);\r\n        if (iterator.hasNext()) {\r\n            builder.append(\", \");\r\n        }\r\n    }\r\n    return builder.toString();\r\n}",
    "comment": "\n\t * Generate a string representation of the given collection of {@link MimeType}\n\t * objects.\n\t * @param mimeTypes the {@code MimeType} objects\n\t * @return a string representation of the {@code MimeType} objects\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
    "entityType": "method",
    "code": "/**\r\n * Sort the given list of {@code MimeType} objects by\r\n * {@linkplain MimeType#isMoreSpecific(MimeType) specificity}.\r\n * <p>Because of the computational cost, this method throws an exception if\r\n * the given list contains too many elements.\r\n * @param mimeTypes the list of mime types to be sorted\r\n * @throws InvalidMimeTypeException if {@code mimeTypes} contains more than 50 elements\r\n * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\r\n * and Content, section 5.3.2</a>\r\n * @see MimeType#isMoreSpecific(MimeType)\r\n */\r\npublic static <T extends MimeType> void sortBySpecificity(List<T> mimeTypes) {\r\n    Assert.notNull(mimeTypes, \"'mimeTypes' must not be null\");\r\n    if (mimeTypes.size() > 50) {\r\n        throw new InvalidMimeTypeException(mimeTypes.toString(), \"Too many elements\");\r\n    }\r\n    bubbleSort(mimeTypes, MimeType::isLessSpecific);\r\n}",
    "comment": "\n\t * Sort the given list of {@code MimeType} objects by\n\t * {@linkplain MimeType#isMoreSpecific(MimeType) specificity}.\n\t * <p>Because of the computational cost, this method throws an exception if\n\t * the given list contains too many elements.\n\t * @param mimeTypes the list of mime types to be sorted\n\t * @throws InvalidMimeTypeException if {@code mimeTypes} contains more than 50 elements\n\t * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.2\">HTTP 1.1: Semantics\n\t * and Content, section 5.3.2</a>\n\t * @see MimeType#isMoreSpecific(MimeType)\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#bubbleSort(List<T>,BiPredicate<? super T,? super T>)",
    "entityType": "method",
    "code": "static <T> void bubbleSort(List<T> list, BiPredicate<? super T, ? super T> swap) {\r\n    int len = list.size();\r\n    for (int i = 0; i < len; i++) {\r\n        for (int j = 1; j < len - i; j++) {\r\n            T prev = list.get(j - 1);\r\n            T cur = list.get(j);\r\n            if (swap.test(prev, cur)) {\r\n                list.set(j, prev);\r\n                list.set(j - 1, cur);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
    "entityType": "method",
    "code": "/**\r\n * Generate a random MIME boundary as bytes, often used in multipart mime types.\r\n */\r\npublic static byte[] generateMultipartBoundary() {\r\n    Random randomToUse = initRandom();\r\n    byte[] boundary = new byte[randomToUse.nextInt(11) + 30];\r\n    for (int i = 0; i < boundary.length; i++) {\r\n        boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)];\r\n    }\r\n    return boundary;\r\n}",
    "comment": "\n\t * Generate a random MIME boundary as bytes, often used in multipart mime types.\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#initRandom()",
    "entityType": "method",
    "code": "/**\r\n * Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.\r\n */\r\nprivate static Random initRandom() {\r\n    Random randomToUse = random;\r\n    if (randomToUse == null) {\r\n        synchronized (MimeTypeUtils.class) {\r\n            randomToUse = random;\r\n            if (randomToUse == null) {\r\n                randomToUse = new SecureRandom();\r\n                random = randomToUse;\r\n            }\r\n        }\r\n    }\r\n    return randomToUse;\r\n}",
    "comment": "\n\t * Lazily initialize the {@link SecureRandom} for {@link #generateMultipartBoundary()}.\n\t "
  },
  {
    "entityId": "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()",
    "entityType": "method",
    "code": "/**\r\n * Generate a random MIME boundary as String, often used in multipart mime types.\r\n */\r\npublic static String generateMultipartBoundaryString() {\r\n    return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII);\r\n}",
    "comment": "\n\t * Generate a random MIME boundary as String, often used in multipart mime types.\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter",
    "entityType": "class",
    "code": "private final MultiValueMap<K, V> targetMap;\n@Nullable\r\nprivate transient Collection<V> values;\n@Nullable\r\nprivate transient Set<Entry<K, V>> entries;\n/**\r\n * Wrap the given target {@link MultiValueMap} as a {@link Map} adapter.\r\n * @param targetMap the target {@code MultiValue}\r\n */\r\npublic MultiToSingleValueMapAdapter(MultiValueMap<K, V> targetMap) {\r\n    Assert.notNull(targetMap, \"'targetMap' must not be null\");\r\n    this.targetMap = targetMap;\r\n}\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}\n@Override\r\npublic boolean containsKey(Object key) {\r\n    return this.targetMap.containsKey(key);\r\n}\n@Override\r\npublic boolean containsValue(@Nullable Object value) {\r\n    Iterator<Entry<K, V>> i = entrySet().iterator();\r\n    if (value == null) {\r\n        while (i.hasNext()) {\r\n            Entry<K, V> e = i.next();\r\n            if (e.getValue() == null) {\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        while (i.hasNext()) {\r\n            Entry<K, V> e = i.next();\r\n            if (value.equals(e.getValue())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\n@Nullable\r\npublic V get(Object key) {\r\n    return adaptValue(this.targetMap.get(key));\r\n}\n@Override\r\n@Nullable\r\npublic V put(K key, @Nullable V value) {\r\n    return adaptValue(this.targetMap.put(key, adaptValue(value)));\r\n}\n@Override\r\n@Nullable\r\npublic V remove(Object key) {\r\n    return adaptValue(this.targetMap.remove(key));\r\n}\n@Override\r\npublic void putAll(Map<? extends K, ? extends V> map) {\r\n    for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\r\n        put(entry.getKey(), entry.getValue());\r\n    }\r\n}\n@Override\r\npublic void clear() {\r\n    this.targetMap.clear();\r\n}\n@Override\r\npublic Set<K> keySet() {\r\n    return this.targetMap.keySet();\r\n}\n@Override\r\npublic Collection<V> values() {\r\n    Collection<V> values = this.values;\r\n    if (values == null) {\r\n        Collection<List<V>> targetValues = this.targetMap.values();\r\n        values = new AbstractCollection<>() {\r\n\r\n            @Override\r\n            public Iterator<V> iterator() {\r\n                Iterator<List<V>> targetIterator = targetValues.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public V next() {\r\n                        return targetIterator.next().get(0);\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetValues.size();\r\n            }\r\n        };\r\n        this.values = values;\r\n    }\r\n    return values;\r\n}\n@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    Set<Entry<K, V>> entries = this.entries;\r\n    if (entries == null) {\r\n        Set<Entry<K, List<V>>> targetEntries = this.targetMap.entrySet();\r\n        entries = new AbstractSet<>() {\r\n\r\n            @Override\r\n            public Iterator<Entry<K, V>> iterator() {\r\n                Iterator<Entry<K, List<V>>> targetIterator = targetEntries.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public Entry<K, V> next() {\r\n                        Entry<K, List<V>> entry = targetIterator.next();\r\n                        return new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), entry.getValue().get(0));\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetEntries.size();\r\n            }\r\n        };\r\n        this.entries = entries;\r\n    }\r\n    return entries;\r\n}\n@Override\r\npublic void forEach(BiConsumer<? super K, ? super V> action) {\r\n    this.targetMap.forEach((k, vs) -> action.accept(k, vs.get(0)));\r\n}\n@Nullable\r\nprivate V adaptValue(@Nullable List<V> values) {\r\n    if (!CollectionUtils.isEmpty(values)) {\r\n        return values.get(0);\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Nullable\r\nprivate List<V> adaptValue(@Nullable V value) {\r\n    if (value != null) {\r\n        return Collections.singletonList(value);\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Map<?, ?> otherMap && size() == otherMap.size()) {\r\n        try {\r\n            for (Entry<K, V> e : entrySet()) {\r\n                K key = e.getKey();\r\n                V value = e.getValue();\r\n                if (value == null) {\r\n                    if (otherMap.get(key) != null || !otherMap.containsKey(key)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!value.equals(otherMap.get(key))) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": "\n * Adapts a given {@link MultiValueMap} to the {@link Map} contract. The\n * difference with {@link SingleToMultiValueMapAdapter} and\n * {@link MultiValueMapAdapter} is that this class adapts in the opposite\n * direction.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <K> the key type\n * @param <V> the value element type\n "
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return this.targetMap.containsKey(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#containsValue(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsValue(@Nullable Object value) {\r\n    Iterator<Entry<K, V>> i = entrySet().iterator();\r\n    if (value == null) {\r\n        while (i.hasNext()) {\r\n            Entry<K, V> e = i.next();\r\n            if (e.getValue() == null) {\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        while (i.hasNext()) {\r\n            Entry<K, V> e = i.next();\r\n            if (value.equals(e.getValue())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V get(Object key) {\r\n    return adaptValue(this.targetMap.get(key));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#put(K,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V put(K key, @Nullable V value) {\r\n    return adaptValue(this.targetMap.put(key, adaptValue(value)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V remove(Object key) {\r\n    return adaptValue(this.targetMap.remove(key));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#putAll(Map<? extends K,? extends V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void putAll(Map<? extends K, ? extends V> map) {\r\n    for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\r\n        put(entry.getKey(), entry.getValue());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.targetMap.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#keySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<K> keySet() {\r\n    return this.targetMap.keySet();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#values()",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<V> values() {\r\n    Collection<V> values = this.values;\r\n    if (values == null) {\r\n        Collection<List<V>> targetValues = this.targetMap.values();\r\n        values = new AbstractCollection<>() {\r\n\r\n            @Override\r\n            public Iterator<V> iterator() {\r\n                Iterator<List<V>> targetIterator = targetValues.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public V next() {\r\n                        return targetIterator.next().get(0);\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetValues.size();\r\n            }\r\n        };\r\n        this.values = values;\r\n    }\r\n    return values;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    Set<Entry<K, V>> entries = this.entries;\r\n    if (entries == null) {\r\n        Set<Entry<K, List<V>>> targetEntries = this.targetMap.entrySet();\r\n        entries = new AbstractSet<>() {\r\n\r\n            @Override\r\n            public Iterator<Entry<K, V>> iterator() {\r\n                Iterator<Entry<K, List<V>>> targetIterator = targetEntries.iterator();\r\n                return new Iterator<>() {\r\n\r\n                    @Override\r\n                    public boolean hasNext() {\r\n                        return targetIterator.hasNext();\r\n                    }\r\n\r\n                    @Override\r\n                    public Entry<K, V> next() {\r\n                        Entry<K, List<V>> entry = targetIterator.next();\r\n                        return new AbstractMap.SimpleImmutableEntry<>(entry.getKey(), entry.getValue().get(0));\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public int size() {\r\n                return targetEntries.size();\r\n            }\r\n        };\r\n        this.entries = entries;\r\n    }\r\n    return entries;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#forEach(BiConsumer<? super K,? super V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(BiConsumer<? super K, ? super V> action) {\r\n    this.targetMap.forEach((k, vs) -> action.accept(k, vs.get(0)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(List<V>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate V adaptValue(@Nullable List<V> values) {\r\n    if (!CollectionUtils.isEmpty(values)) {\r\n        return values.get(0);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(V)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate List<V> adaptValue(@Nullable V value) {\r\n    if (value != null) {\r\n        return Collections.singletonList(value);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Map<?, ?> otherMap && size() == otherMap.size()) {\r\n        try {\r\n            for (Entry<K, V> e : entrySet()) {\r\n                K key = e.getKey();\r\n                V value = e.getValue();\r\n                if (value == null) {\r\n                    if (otherMap.get(key) != null || !otherMap.containsKey(key)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!value.equals(otherMap.get(key))) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiToSingleValueMapAdapter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMap",
    "entityType": "class",
    "code": "/**\r\n * Return the first value for the given key.\r\n * @param key the key\r\n * @return the first value for the specified key, or {@code null} if none\r\n */\r\n@Nullable\r\nV getFirst(K key);\n/**\r\n * Add the given single value to the current list of values for the given key.\r\n * @param key the key\r\n * @param value the value to be added\r\n */\r\nvoid add(K key, @Nullable V value);\n/**\r\n * Add all the values of the given list to the current list of values for the given key.\r\n * @param key they key\r\n * @param values the values to be added\r\n * @since 5.0\r\n */\r\nvoid addAll(K key, List<? extends V> values);\n/**\r\n * Add all the values of the given {@code MultiValueMap} to the current values.\r\n * @param values the values to be added\r\n * @since 5.0\r\n */\r\nvoid addAll(MultiValueMap<K, V> values);\n/**\r\n * {@link #add(Object, Object) Add} the given value, only when the map does not\r\n * {@link #containsKey(Object) contain} the given key.\r\n * @param key the key\r\n * @param value the value to be added\r\n * @since 5.2\r\n */\r\ndefault void addIfAbsent(K key, @Nullable V value) {\r\n    if (!containsKey(key)) {\r\n        add(key, value);\r\n    }\r\n}\n/**\r\n * Set the given single value under the given key.\r\n * @param key the key\r\n * @param value the value to set\r\n */\r\nvoid set(K key, @Nullable V value);\n/**\r\n * Set the given values under.\r\n * @param values the values.\r\n */\r\nvoid setAll(Map<K, V> values);\n/**\r\n * Return a {@code Map} with the first values contained in this {@code MultiValueMap}.\r\n * The difference between this method and {@link #asSingleValueMap()} is\r\n * that this method returns a copy of the entries of this map, whereas\r\n * the latter returns a view.\r\n * @return a single value representation of this map\r\n */\r\nMap<K, V> toSingleValueMap();\n/**\r\n * Return this map as a {@code Map} with the first values contained in this\r\n * {@code MultiValueMap}.\r\n * <p>The difference between this method and {@link #toSingleValueMap()} is\r\n * that this method returns a view of the entries of this map, whereas\r\n * the latter returns a copy.\r\n * @return a single value representation of this map\r\n * @since 6.2\r\n */\r\ndefault Map<K, V> asSingleValueMap() {\r\n    return new MultiToSingleValueMapAdapter<>(this);\r\n}\n/**\r\n * Return a {@code MultiValueMap<K, V>} that adapts the given single-value\r\n * {@code Map<K, V>}.\r\n * <p>The returned map cannot map multiple values to the same key,\r\n * and doing so results in an {@link UnsupportedOperationException}.\r\n * Use {@link #fromMultiValue(Map)} to support multiple values.\r\n * @param map the map to be adapted\r\n * @param <K> the key type\r\n * @param <V> the value element type\r\n * @return a multi-value-map that delegates to {@code map}\r\n * @since 6.2\r\n * @see #fromMultiValue(Map)\r\n */\r\nstatic <K, V> MultiValueMap<K, V> fromSingleValue(Map<K, V> map) {\r\n    Assert.notNull(map, \"Map must not be null\");\r\n    return new SingleToMultiValueMapAdapter<>(map);\r\n}\n/**\r\n * Return a {@code MultiValueMap<K, V>} that adapts the given multi-value\r\n * {@code Map<K, List<V>>}.\r\n * @param map the map to be adapted\r\n * @param <K> the key type\r\n * @param <V> the value element type\r\n * @return a multi-value-map that delegates to {@code map}\r\n * @since 6.2\r\n * @see #fromSingleValue(Map)\r\n */\r\nstatic <K, V> MultiValueMap<K, V> fromMultiValue(Map<K, List<V>> map) {\r\n    Assert.notNull(map, \"Map must not be null\");\r\n    return new MultiValueMapAdapter<>(map);\r\n}",
    "comment": "\n * Extension of the {@code Map} interface that stores multiple values.\n *\n * @author Arjen Poutsma\n * @since 3.0\n * @param <K> the key type\n * @param <V> the value element type\n "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#getFirst(K)",
    "entityType": "method",
    "code": "/**\r\n * Return the first value for the given key.\r\n * @param key the key\r\n * @return the first value for the specified key, or {@code null} if none\r\n */\r\n@Nullable\r\nV getFirst(K key);",
    "comment": "\n\t * Return the first value for the given key.\n\t * @param key the key\n\t * @return the first value for the specified key, or {@code null} if none\n\t "
  }
]