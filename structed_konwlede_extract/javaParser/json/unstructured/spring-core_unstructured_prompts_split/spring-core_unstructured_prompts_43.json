[
  {
    "entityId": "org.springframework.cglib.util.Comparer#compare(int,int)",
    "entityType": "method",
    "code": "int compare(int i, int j);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ComparatorComparer",
    "entityType": "class",
    "code": "private final Object[] a;\nprivate final Comparator cmp;\npublic ComparatorComparer(Object[] a, Comparator cmp) {\r\n    this.a = a;\r\n    this.cmp = cmp;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    return cmp.compare(a[i], a[j]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ComparatorComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    return cmp.compare(a[i], a[j]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ObjectComparer",
    "entityType": "class",
    "code": "private final Object[] a;\npublic ObjectComparer(Object[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    return ((Comparable) a[i]).compareTo(a[j]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ObjectComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    return ((Comparable) a[i]).compareTo(a[j]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.IntComparer",
    "entityType": "class",
    "code": "private final int[] a;\npublic IntComparer(int[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    return a[i] - a[j];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.IntComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    return a[i] - a[j];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.LongComparer",
    "entityType": "class",
    "code": "private final long[] a;\npublic LongComparer(long[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    long vi = a[i];\r\n    long vj = a[j];\r\n    return Long.compare(vi, vj);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.LongComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    long vi = a[i];\r\n    long vj = a[j];\r\n    return Long.compare(vi, vj);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.FloatComparer",
    "entityType": "class",
    "code": "private final float[] a;\npublic FloatComparer(float[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    float vi = a[i];\r\n    float vj = a[j];\r\n    return Float.compare(vi, vj);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.FloatComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    float vi = a[i];\r\n    float vj = a[j];\r\n    return Float.compare(vi, vj);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.DoubleComparer",
    "entityType": "class",
    "code": "private final double[] a;\npublic DoubleComparer(double[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    double vi = a[i];\r\n    double vj = a[j];\r\n    return Double.compare(vi, vj);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.DoubleComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    double vi = a[i];\r\n    double vj = a[j];\r\n    return Double.compare(vi, vj);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ShortComparer",
    "entityType": "class",
    "code": "private final short[] a;\npublic ShortComparer(short[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    return a[i] - a[j];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ShortComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    return a[i] - a[j];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ByteComparer",
    "entityType": "class",
    "code": "private final byte[] a;\npublic ByteComparer(byte[] a) {\r\n    this.a = a;\r\n}\n@Override\r\npublic int compare(int i, int j) {\r\n    return a[i] - a[j];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ByteComparer#compare(int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(int i, int j) {\r\n    return a[i] - a[j];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(ParallelSorter.class.getName());\nprivate Object[] arrays;\npublic Generator() {\r\n    super(SOURCE);\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    // TODO\r\n    return null;\r\n}\npublic void setArrays(Object[] arrays) {\r\n    this.arrays = arrays;\r\n}\npublic ParallelSorter create() {\r\n    return (ParallelSorter) super.create(ClassesKey.create(arrays));\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    if (arrays.length == 0) {\r\n        throw new IllegalArgumentException(\"No arrays specified to sort\");\r\n    }\r\n    for (Object array : arrays) {\r\n        if (!array.getClass().isArray()) {\r\n            throw new IllegalArgumentException(array.getClass() + \" is not an array\");\r\n        }\r\n    }\r\n    new ParallelSorterEmitter(v, getClassName(), arrays);\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((ParallelSorter) ReflectUtils.newInstance(type)).newInstance(arrays);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((ParallelSorter) instance).newInstance(arrays);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    // TODO\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#setArrays(Object[])",
    "entityType": "method",
    "code": "public void setArrays(Object[] arrays) {\r\n    this.arrays = arrays;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#create()",
    "entityType": "method",
    "code": "public ParallelSorter create() {\r\n    return (ParallelSorter) super.create(ClassesKey.create(arrays));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    if (arrays.length == 0) {\r\n        throw new IllegalArgumentException(\"No arrays specified to sort\");\r\n    }\r\n    for (Object array : arrays) {\r\n        if (!array.getClass().isArray()) {\r\n            throw new IllegalArgumentException(array.getClass() + \" is not an array\");\r\n        }\r\n    }\r\n    new ParallelSorterEmitter(v, getClassName(), arrays);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((ParallelSorter) ReflectUtils.newInstance(type)).newInstance(arrays);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((ParallelSorter) instance).newInstance(arrays);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorterEmitter",
    "entityType": "class",
    "code": "private static final Type PARALLEL_SORTER = TypeUtils.parseType(\"org.springframework.cglib.util.ParallelSorter\");\nprivate static final Signature CSTRUCT_OBJECT_ARRAY = TypeUtils.parseConstructor(\"Object[]\");\nprivate static final Signature NEW_INSTANCE = new Signature(\"newInstance\", PARALLEL_SORTER, new Type[] { Constants.TYPE_OBJECT_ARRAY });\nprivate static final Signature SWAP = TypeUtils.parseSignature(\"void swap(int, int)\");\npublic ParallelSorterEmitter(ClassVisitor v, String className, Object[] arrays) {\r\n    super(v);\r\n    begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, PARALLEL_SORTER, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(this);\r\n    EmitUtils.factory_method(this, NEW_INSTANCE);\r\n    generateConstructor(arrays);\r\n    generateSwap(arrays);\r\n    end_class();\r\n}\nprivate String getFieldName(int index) {\r\n    return \"FIELD_\" + index;\r\n}\nprivate void generateConstructor(Object[] arrays) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT_ARRAY, null);\r\n    e.load_this();\r\n    e.super_invoke_constructor();\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.super_putfield(\"a\", Constants.TYPE_OBJECT_ARRAY);\r\n    for (int i = 0; i < arrays.length; i++) {\r\n        Type type = Type.getType(arrays[i].getClass());\r\n        declare_field(Constants.ACC_PRIVATE, getFieldName(i), type, null);\r\n        e.load_this();\r\n        e.load_arg(0);\r\n        e.push(i);\r\n        e.aaload();\r\n        e.checkcast(type);\r\n        e.putfield(getFieldName(i));\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}\nprivate void generateSwap(final Object[] arrays) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SWAP, null);\r\n    for (int i = 0; i < arrays.length; i++) {\r\n        Type type = Type.getType(arrays[i].getClass());\r\n        Type component = TypeUtils.getComponentType(type);\r\n        Local T = e.make_local(type);\r\n        e.load_this();\r\n        e.getfield(getFieldName(i));\r\n        e.store_local(T);\r\n        e.load_local(T);\r\n        e.load_arg(0);\r\n        e.load_local(T);\r\n        e.load_arg(1);\r\n        e.array_load(component);\r\n        e.load_local(T);\r\n        e.load_arg(1);\r\n        e.load_local(T);\r\n        e.load_arg(0);\r\n        e.array_load(component);\r\n        e.array_store(component);\r\n        e.array_store(component);\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorterEmitter#getFieldName(int)",
    "entityType": "method",
    "code": "private String getFieldName(int index) {\r\n    return \"FIELD_\" + index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorterEmitter#generateConstructor(Object[])",
    "entityType": "method",
    "code": "private void generateConstructor(Object[] arrays) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT_ARRAY, null);\r\n    e.load_this();\r\n    e.super_invoke_constructor();\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.super_putfield(\"a\", Constants.TYPE_OBJECT_ARRAY);\r\n    for (int i = 0; i < arrays.length; i++) {\r\n        Type type = Type.getType(arrays[i].getClass());\r\n        declare_field(Constants.ACC_PRIVATE, getFieldName(i), type, null);\r\n        e.load_this();\r\n        e.load_arg(0);\r\n        e.push(i);\r\n        e.aaload();\r\n        e.checkcast(type);\r\n        e.putfield(getFieldName(i));\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.ParallelSorterEmitter#generateSwap(Object[])",
    "entityType": "method",
    "code": "private void generateSwap(final Object[] arrays) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SWAP, null);\r\n    for (int i = 0; i < arrays.length; i++) {\r\n        Type type = Type.getType(arrays[i].getClass());\r\n        Type component = TypeUtils.getComponentType(type);\r\n        Local T = e.make_local(type);\r\n        e.load_this();\r\n        e.getfield(getFieldName(i));\r\n        e.store_local(T);\r\n        e.load_local(T);\r\n        e.load_arg(0);\r\n        e.load_local(T);\r\n        e.load_arg(1);\r\n        e.array_load(component);\r\n        e.load_local(T);\r\n        e.load_arg(1);\r\n        e.load_local(T);\r\n        e.load_arg(0);\r\n        e.array_load(component);\r\n        e.array_store(component);\r\n        e.array_store(component);\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate",
    "entityType": "class",
    "code": "private static final int MERGESORT_THRESHOLD = 12;\nprivate static final int QUICKSORT_THRESHOLD = 7;\nabstract protected void swap(int i, int j);\nabstract protected int compare(int i, int j);\nprotected void quickSort(int lo, int hi) {\r\n    quickSortHelper(lo, hi);\r\n    insertionSort(lo, hi);\r\n}\nprivate void quickSortHelper(int lo, int hi) {\r\n    for (; ; ) {\r\n        int diff = hi - lo;\r\n        if (diff <= QUICKSORT_THRESHOLD) {\r\n            break;\r\n        }\r\n        int i = (hi + lo) / 2;\r\n        if (compare(lo, i) > 0) {\r\n            swap(lo, i);\r\n        }\r\n        if (compare(lo, hi) > 0) {\r\n            swap(lo, hi);\r\n        }\r\n        if (compare(i, hi) > 0) {\r\n            swap(i, hi);\r\n        }\r\n        int j = hi - 1;\r\n        swap(i, j);\r\n        i = lo;\r\n        int v = j;\r\n        for (; ; ) {\r\n            while (compare(++i, v) < 0) {\r\n                /* nothing */\r\n            }\r\n            while (compare(--j, v) > 0) {\r\n                /* nothing */\r\n            }\r\n            if (j < i) {\r\n                break;\r\n            }\r\n            swap(i, j);\r\n        }\r\n        swap(i, hi - 1);\r\n        if (j - lo <= hi - i + 1) {\r\n            quickSortHelper(lo, j);\r\n            lo = i + 1;\r\n        } else {\r\n            quickSortHelper(i + 1, hi);\r\n            hi = j;\r\n        }\r\n    }\r\n}\nprivate void insertionSort(int lo, int hi) {\r\n    for (int i = lo + 1; i <= hi; i++) {\r\n        for (int j = i; j > lo; j--) {\r\n            if (compare(j - 1, j) > 0) {\r\n                swap(j - 1, j);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\nprotected void mergeSort(int lo, int hi) {\r\n    int diff = hi - lo;\r\n    if (diff <= MERGESORT_THRESHOLD) {\r\n        insertionSort(lo, hi);\r\n        return;\r\n    }\r\n    int mid = lo + diff / 2;\r\n    mergeSort(lo, mid);\r\n    mergeSort(mid, hi);\r\n    merge(lo, mid, hi, mid - lo, hi - mid);\r\n}\nprivate void merge(int lo, int pivot, int hi, int len1, int len2) {\r\n    if (len1 == 0 || len2 == 0) {\r\n        return;\r\n    }\r\n    if (len1 + len2 == 2) {\r\n        if (compare(pivot, lo) < 0) {\r\n            swap(pivot, lo);\r\n        }\r\n        return;\r\n    }\r\n    int first_cut, second_cut;\r\n    int len11, len22;\r\n    if (len1 > len2) {\r\n        len11 = len1 / 2;\r\n        first_cut = lo + len11;\r\n        second_cut = lower(pivot, hi, first_cut);\r\n        len22 = second_cut - pivot;\r\n    } else {\r\n        len22 = len2 / 2;\r\n        second_cut = pivot + len22;\r\n        first_cut = upper(lo, pivot, second_cut);\r\n        len11 = first_cut - lo;\r\n    }\r\n    rotate(first_cut, pivot, second_cut);\r\n    int new_mid = first_cut + len22;\r\n    merge(lo, first_cut, new_mid, len11, len22);\r\n    merge(new_mid, second_cut, hi, len1 - len11, len2 - len22);\r\n}\nprivate void rotate(int lo, int mid, int hi) {\r\n    int lot = lo;\r\n    int hit = mid - 1;\r\n    while (lot < hit) {\r\n        swap(lot++, hit--);\r\n    }\r\n    lot = mid;\r\n    hit = hi - 1;\r\n    while (lot < hit) {\r\n        swap(lot++, hit--);\r\n    }\r\n    lot = lo;\r\n    hit = hi - 1;\r\n    while (lot < hit) {\r\n        swap(lot++, hit--);\r\n    }\r\n}\nprivate int lower(int lo, int hi, int val) {\r\n    int len = hi - lo;\r\n    while (len > 0) {\r\n        int half = len / 2;\r\n        int mid = lo + half;\r\n        if (compare(mid, val) < 0) {\r\n            lo = mid + 1;\r\n            len = len - half - 1;\r\n        } else {\r\n            len = half;\r\n        }\r\n    }\r\n    return lo;\r\n}\nprivate int upper(int lo, int hi, int val) {\r\n    int len = hi - lo;\r\n    while (len > 0) {\r\n        int half = len / 2;\r\n        int mid = lo + half;\r\n        if (compare(val, mid) < 0) {\r\n            len = half;\r\n        } else {\r\n            lo = mid + 1;\r\n            len = len - half - 1;\r\n        }\r\n    }\r\n    return lo;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#swap(int,int)",
    "entityType": "method",
    "code": "abstract protected void swap(int i, int j);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#compare(int,int)",
    "entityType": "method",
    "code": "abstract protected int compare(int i, int j);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#quickSort(int,int)",
    "entityType": "method",
    "code": "protected void quickSort(int lo, int hi) {\r\n    quickSortHelper(lo, hi);\r\n    insertionSort(lo, hi);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#quickSortHelper(int,int)",
    "entityType": "method",
    "code": "private void quickSortHelper(int lo, int hi) {\r\n    for (; ; ) {\r\n        int diff = hi - lo;\r\n        if (diff <= QUICKSORT_THRESHOLD) {\r\n            break;\r\n        }\r\n        int i = (hi + lo) / 2;\r\n        if (compare(lo, i) > 0) {\r\n            swap(lo, i);\r\n        }\r\n        if (compare(lo, hi) > 0) {\r\n            swap(lo, hi);\r\n        }\r\n        if (compare(i, hi) > 0) {\r\n            swap(i, hi);\r\n        }\r\n        int j = hi - 1;\r\n        swap(i, j);\r\n        i = lo;\r\n        int v = j;\r\n        for (; ; ) {\r\n            while (compare(++i, v) < 0) {\r\n                /* nothing */\r\n            }\r\n            while (compare(--j, v) > 0) {\r\n                /* nothing */\r\n            }\r\n            if (j < i) {\r\n                break;\r\n            }\r\n            swap(i, j);\r\n        }\r\n        swap(i, hi - 1);\r\n        if (j - lo <= hi - i + 1) {\r\n            quickSortHelper(lo, j);\r\n            lo = i + 1;\r\n        } else {\r\n            quickSortHelper(i + 1, hi);\r\n            hi = j;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#insertionSort(int,int)",
    "entityType": "method",
    "code": "private void insertionSort(int lo, int hi) {\r\n    for (int i = lo + 1; i <= hi; i++) {\r\n        for (int j = i; j > lo; j--) {\r\n            if (compare(j - 1, j) > 0) {\r\n                swap(j - 1, j);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#mergeSort(int,int)",
    "entityType": "method",
    "code": "protected void mergeSort(int lo, int hi) {\r\n    int diff = hi - lo;\r\n    if (diff <= MERGESORT_THRESHOLD) {\r\n        insertionSort(lo, hi);\r\n        return;\r\n    }\r\n    int mid = lo + diff / 2;\r\n    mergeSort(lo, mid);\r\n    mergeSort(mid, hi);\r\n    merge(lo, mid, hi, mid - lo, hi - mid);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#merge(int,int,int,int,int)",
    "entityType": "method",
    "code": "private void merge(int lo, int pivot, int hi, int len1, int len2) {\r\n    if (len1 == 0 || len2 == 0) {\r\n        return;\r\n    }\r\n    if (len1 + len2 == 2) {\r\n        if (compare(pivot, lo) < 0) {\r\n            swap(pivot, lo);\r\n        }\r\n        return;\r\n    }\r\n    int first_cut, second_cut;\r\n    int len11, len22;\r\n    if (len1 > len2) {\r\n        len11 = len1 / 2;\r\n        first_cut = lo + len11;\r\n        second_cut = lower(pivot, hi, first_cut);\r\n        len22 = second_cut - pivot;\r\n    } else {\r\n        len22 = len2 / 2;\r\n        second_cut = pivot + len22;\r\n        first_cut = upper(lo, pivot, second_cut);\r\n        len11 = first_cut - lo;\r\n    }\r\n    rotate(first_cut, pivot, second_cut);\r\n    int new_mid = first_cut + len22;\r\n    merge(lo, first_cut, new_mid, len11, len22);\r\n    merge(new_mid, second_cut, hi, len1 - len11, len2 - len22);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#rotate(int,int,int)",
    "entityType": "method",
    "code": "private void rotate(int lo, int mid, int hi) {\r\n    int lot = lo;\r\n    int hit = mid - 1;\r\n    while (lot < hit) {\r\n        swap(lot++, hit--);\r\n    }\r\n    lot = mid;\r\n    hit = hi - 1;\r\n    while (lot < hit) {\r\n        swap(lot++, hit--);\r\n    }\r\n    lot = lo;\r\n    hit = hi - 1;\r\n    while (lot < hit) {\r\n        swap(lot++, hit--);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#lower(int,int,int)",
    "entityType": "method",
    "code": "private int lower(int lo, int hi, int val) {\r\n    int len = hi - lo;\r\n    while (len > 0) {\r\n        int half = len / 2;\r\n        int mid = lo + half;\r\n        if (compare(mid, val) < 0) {\r\n            lo = mid + 1;\r\n            len = len - half - 1;\r\n        } else {\r\n            len = half;\r\n        }\r\n    }\r\n    return lo;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.SorterTemplate#upper(int,int,int)",
    "entityType": "method",
    "code": "private int upper(int lo, int hi, int val) {\r\n    int len = hi - lo;\r\n    while (len > 0) {\r\n        int half = len / 2;\r\n        int mid = lo + half;\r\n        if (compare(val, mid) < 0) {\r\n            len = half;\r\n        } else {\r\n            lo = mid + 1;\r\n            len = len - half - 1;\r\n        }\r\n    }\r\n    return lo;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.StringSwitcher",
    "entityType": "class",
    "code": "private static final Type STRING_SWITCHER = TypeUtils.parseType(\"org.springframework.cglib.util.StringSwitcher\");\nprivate static final Signature INT_VALUE = TypeUtils.parseSignature(\"int intValue(String)\");\nprivate static final StringSwitcherKey KEY_FACTORY = (StringSwitcherKey) KeyFactory.create(StringSwitcherKey.class);\ninterface StringSwitcherKey {\r\n\r\n    public Object newInstance(String[] strings, int[] ints, boolean fixedInput);\r\n}\n/**\r\n * Helper method to create a StringSwitcher.\r\n * For finer control over the generated instance, use a new instance of StringSwitcher.Generator\r\n * instead of this static method.\r\n * @param strings the array of String keys; must be the same length as the value array\r\n * @param ints the array of integer results; must be the same length as the key array\r\n * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\r\n * the result will be undefined, and the resulting code will be faster\r\n */\r\npublic static StringSwitcher create(String[] strings, int[] ints, boolean fixedInput) {\r\n    Generator gen = new Generator();\r\n    gen.setStrings(strings);\r\n    gen.setInts(ints);\r\n    gen.setFixedInput(fixedInput);\r\n    return gen.create();\r\n}\nprotected StringSwitcher() {\r\n}\n/**\r\n * Return the integer associated with the given key.\r\n * @param s the key\r\n * @return the associated integer value, or <code>-1</code> if the key is unknown (unless\r\n * <code>fixedInput</code> was specified when this <code>StringSwitcher</code> was created,\r\n * in which case the return value for an unknown key is undefined)\r\n */\r\nabstract public int intValue(String s);\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(StringSwitcher.class.getName());\r\n\r\n    private String[] strings;\r\n\r\n    private int[] ints;\r\n\r\n    private boolean fixedInput;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    /**\r\n     * Set the array of recognized Strings.\r\n     * @param strings the array of String keys; must be the same length as the value array\r\n     * @see #setInts\r\n     */\r\n    public void setStrings(String[] strings) {\r\n        this.strings = strings;\r\n    }\r\n\r\n    /**\r\n     * Set the array of integer results.\r\n     * @param ints the array of integer results; must be the same length as the key array\r\n     * @see #setStrings\r\n     */\r\n    public void setInts(int[] ints) {\r\n        this.ints = ints;\r\n    }\r\n\r\n    /**\r\n     * Configure how unknown String keys will be handled.\r\n     * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\r\n     * the result will be undefined, and the resulting code will be faster\r\n     */\r\n    public void setFixedInput(boolean fixedInput) {\r\n        this.fixedInput = fixedInput;\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return getClass().getClassLoader();\r\n    }\r\n\r\n    /**\r\n     * Generate the <code>StringSwitcher</code>.\r\n     */\r\n    public StringSwitcher create() {\r\n        setNamePrefix(StringSwitcher.class.getName());\r\n        Object key = KEY_FACTORY.newInstance(strings, ints, fixedInput);\r\n        return (StringSwitcher) super.create(key);\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) throws Exception {\r\n        ClassEmitter ce = new ClassEmitter(v);\r\n        ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), STRING_SWITCHER, null, Constants.SOURCE_FILE);\r\n        EmitUtils.null_constructor(ce);\r\n        final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, INT_VALUE, null);\r\n        e.load_arg(0);\r\n        final List stringList = Arrays.asList(strings);\r\n        int style = fixedInput ? Constants.SWITCH_STYLE_HASHONLY : Constants.SWITCH_STYLE_HASH;\r\n        EmitUtils.string_switch(e, strings, style, new ObjectSwitchCallback() {\r\n\r\n            @Override\r\n            public void processCase(Object key, Label end) {\r\n                e.push(ints[stringList.indexOf(key)]);\r\n                e.return_value();\r\n            }\r\n\r\n            @Override\r\n            public void processDefault() {\r\n                e.push(-1);\r\n                e.return_value();\r\n            }\r\n        });\r\n        e.end_method();\r\n        ce.end_class();\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ReflectUtils.newInstance(type);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return instance;\r\n    }\r\n}",
    "comment": "\n * This class implements a simple String &rarr; int mapping for a fixed set of keys.\n "
  },
  {
    "entityId": "org.springframework.cglib.util.StringSwitcher#create(String[],int[],boolean)",
    "entityType": "method",
    "code": "/**\r\n * Helper method to create a StringSwitcher.\r\n * For finer control over the generated instance, use a new instance of StringSwitcher.Generator\r\n * instead of this static method.\r\n * @param strings the array of String keys; must be the same length as the value array\r\n * @param ints the array of integer results; must be the same length as the key array\r\n * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\r\n * the result will be undefined, and the resulting code will be faster\r\n */\r\npublic static StringSwitcher create(String[] strings, int[] ints, boolean fixedInput) {\r\n    Generator gen = new Generator();\r\n    gen.setStrings(strings);\r\n    gen.setInts(ints);\r\n    gen.setFixedInput(fixedInput);\r\n    return gen.create();\r\n}",
    "comment": "\n     * Helper method to create a StringSwitcher.\n     * For finer control over the generated instance, use a new instance of StringSwitcher.Generator\n     * instead of this static method.\n     * @param strings the array of String keys; must be the same length as the value array\n     * @param ints the array of integer results; must be the same length as the key array\n     * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\n     * the result will be undefined, and the resulting code will be faster\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.StringSwitcher#intValue(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the integer associated with the given key.\r\n * @param s the key\r\n * @return the associated integer value, or <code>-1</code> if the key is unknown (unless\r\n * <code>fixedInput</code> was specified when this <code>StringSwitcher</code> was created,\r\n * in which case the return value for an unknown key is undefined)\r\n */\r\nabstract public int intValue(String s);",
    "comment": "\n     * Return the integer associated with the given key.\n     * @param s the key\n     * @return the associated integer value, or <code>-1</code> if the key is unknown (unless\n     * <code>fixedInput</code> was specified when this <code>StringSwitcher</code> was created,\n     * in which case the return value for an unknown key is undefined)\n     "
  },
  {
    "entityId": "org.springframework.cglib.util.StringSwitcherKey",
    "entityType": "class",
    "code": "public Object newInstance(String[] strings, int[] ints, boolean fixedInput);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.StringSwitcherKey#newInstance(String[],int[],boolean)",
    "entityType": "method",
    "code": "public Object newInstance(String[] strings, int[] ints, boolean fixedInput);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(StringSwitcher.class.getName());\nprivate String[] strings;\nprivate int[] ints;\nprivate boolean fixedInput;\npublic Generator() {\r\n    super(SOURCE);\r\n}\n/**\r\n * Set the array of recognized Strings.\r\n * @param strings the array of String keys; must be the same length as the value array\r\n * @see #setInts\r\n */\r\npublic void setStrings(String[] strings) {\r\n    this.strings = strings;\r\n}\n/**\r\n * Set the array of integer results.\r\n * @param ints the array of integer results; must be the same length as the key array\r\n * @see #setStrings\r\n */\r\npublic void setInts(int[] ints) {\r\n    this.ints = ints;\r\n}\n/**\r\n * Configure how unknown String keys will be handled.\r\n * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\r\n * the result will be undefined, and the resulting code will be faster\r\n */\r\npublic void setFixedInput(boolean fixedInput) {\r\n    this.fixedInput = fixedInput;\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return getClass().getClassLoader();\r\n}\n/**\r\n * Generate the <code>StringSwitcher</code>.\r\n */\r\npublic StringSwitcher create() {\r\n    setNamePrefix(StringSwitcher.class.getName());\r\n    Object key = KEY_FACTORY.newInstance(strings, ints, fixedInput);\r\n    return (StringSwitcher) super.create(key);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), STRING_SWITCHER, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(ce);\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, INT_VALUE, null);\r\n    e.load_arg(0);\r\n    final List stringList = Arrays.asList(strings);\r\n    int style = fixedInput ? Constants.SWITCH_STYLE_HASHONLY : Constants.SWITCH_STYLE_HASH;\r\n    EmitUtils.string_switch(e, strings, style, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            e.push(ints[stringList.indexOf(key)]);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.push(-1);\r\n            e.return_value();\r\n        }\r\n    });\r\n    e.end_method();\r\n    ce.end_class();\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#setStrings(String[])",
    "entityType": "method",
    "code": "/**\r\n * Set the array of recognized Strings.\r\n * @param strings the array of String keys; must be the same length as the value array\r\n * @see #setInts\r\n */\r\npublic void setStrings(String[] strings) {\r\n    this.strings = strings;\r\n}",
    "comment": "\n         * Set the array of recognized Strings.\n         * @param strings the array of String keys; must be the same length as the value array\n         * @see #setInts\n         "
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#setInts(int[])",
    "entityType": "method",
    "code": "/**\r\n * Set the array of integer results.\r\n * @param ints the array of integer results; must be the same length as the key array\r\n * @see #setStrings\r\n */\r\npublic void setInts(int[] ints) {\r\n    this.ints = ints;\r\n}",
    "comment": "\n         * Set the array of integer results.\n         * @param ints the array of integer results; must be the same length as the key array\n         * @see #setStrings\n         "
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#setFixedInput(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Configure how unknown String keys will be handled.\r\n * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\r\n * the result will be undefined, and the resulting code will be faster\r\n */\r\npublic void setFixedInput(boolean fixedInput) {\r\n    this.fixedInput = fixedInput;\r\n}",
    "comment": "\n         * Configure how unknown String keys will be handled.\n         * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\n         * the result will be undefined, and the resulting code will be faster\n         "
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return getClass().getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#create()",
    "entityType": "method",
    "code": "/**\r\n * Generate the <code>StringSwitcher</code>.\r\n */\r\npublic StringSwitcher create() {\r\n    setNamePrefix(StringSwitcher.class.getName());\r\n    Object key = KEY_FACTORY.newInstance(strings, ints, fixedInput);\r\n    return (StringSwitcher) super.create(key);\r\n}",
    "comment": "\n         * Generate the <code>StringSwitcher</code>.\n         "
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), STRING_SWITCHER, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(ce);\r\n    final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, INT_VALUE, null);\r\n    e.load_arg(0);\r\n    final List stringList = Arrays.asList(strings);\r\n    int style = fixedInput ? Constants.SWITCH_STYLE_HASHONLY : Constants.SWITCH_STYLE_HASH;\r\n    EmitUtils.string_switch(e, strings, style, new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            e.push(ints[stringList.indexOf(key)]);\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.push(-1);\r\n            e.return_value();\r\n        }\r\n    });\r\n    e.end_method();\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.util.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AliasRegistry",
    "entityType": "class",
    "code": "/**\r\n * Given a name, register an alias for it.\r\n * @param name the canonical name\r\n * @param alias the alias to be registered\r\n * @throws IllegalStateException if the alias is already in use\r\n * and may not be overridden\r\n */\r\nvoid registerAlias(String name, String alias);\n/**\r\n * Remove the specified alias from this registry.\r\n * @param alias the alias to remove\r\n * @throws IllegalStateException if no such alias was found\r\n */\r\nvoid removeAlias(String alias);\n/**\r\n * Determine whether the given name is defined as an alias\r\n * (as opposed to the name of an actually registered component).\r\n * @param name the name to check\r\n * @return whether the given name is an alias\r\n */\r\nboolean isAlias(String name);\n/**\r\n * Return the aliases for the given name, if defined.\r\n * @param name the name to check for aliases\r\n * @return the aliases, or an empty array if none\r\n */\r\nString[] getAliases(String name);",
    "comment": "\n * Common interface for managing aliases. Serves as a super-interface for\n * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n "
  },
  {
    "entityId": "org.springframework.core.AliasRegistry#registerAlias(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Given a name, register an alias for it.\r\n * @param name the canonical name\r\n * @param alias the alias to be registered\r\n * @throws IllegalStateException if the alias is already in use\r\n * and may not be overridden\r\n */\r\nvoid registerAlias(String name, String alias);",
    "comment": "\n\t * Given a name, register an alias for it.\n\t * @param name the canonical name\n\t * @param alias the alias to be registered\n\t * @throws IllegalStateException if the alias is already in use\n\t * and may not be overridden\n\t "
  },
  {
    "entityId": "org.springframework.core.AliasRegistry#removeAlias(String)",
    "entityType": "method",
    "code": "/**\r\n * Remove the specified alias from this registry.\r\n * @param alias the alias to remove\r\n * @throws IllegalStateException if no such alias was found\r\n */\r\nvoid removeAlias(String alias);",
    "comment": "\n\t * Remove the specified alias from this registry.\n\t * @param alias the alias to remove\n\t * @throws IllegalStateException if no such alias was found\n\t "
  },
  {
    "entityId": "org.springframework.core.AliasRegistry#isAlias(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given name is defined as an alias\r\n * (as opposed to the name of an actually registered component).\r\n * @param name the name to check\r\n * @return whether the given name is an alias\r\n */\r\nboolean isAlias(String name);",
    "comment": "\n\t * Determine whether the given name is defined as an alias\n\t * (as opposed to the name of an actually registered component).\n\t * @param name the name to check\n\t * @return whether the given name is an alias\n\t "
  },
  {
    "entityId": "org.springframework.core.AliasRegistry#getAliases(String)",
    "entityType": "method",
    "code": "/**\r\n * Return the aliases for the given name, if defined.\r\n * @param name the name to check for aliases\r\n * @return the aliases, or an empty array if none\r\n */\r\nString[] getAliases(String name);",
    "comment": "\n\t * Return the aliases for the given name, if defined.\n\t * @param name the name to check for aliases\n\t * @return the aliases, or an empty array if none\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation",
    "entityType": "class",
    "code": "@Nullable\r\nprivate volatile A synthesizedAnnotation;\n@Override\r\npublic boolean isDirectlyPresent() {\r\n    return isPresent() && getDistance() == 0;\r\n}\n@Override\r\npublic boolean isMetaPresent() {\r\n    return isPresent() && getDistance() > 0;\r\n}\n@Override\r\npublic boolean hasNonDefaultValue(String attributeName) {\r\n    return !hasDefaultValue(attributeName);\r\n}\n@Override\r\npublic byte getByte(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Byte.class);\r\n}\n@Override\r\npublic byte[] getByteArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, byte[].class);\r\n}\n@Override\r\npublic boolean getBoolean(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Boolean.class);\r\n}\n@Override\r\npublic boolean[] getBooleanArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, boolean[].class);\r\n}\n@Override\r\npublic char getChar(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Character.class);\r\n}\n@Override\r\npublic char[] getCharArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, char[].class);\r\n}\n@Override\r\npublic short getShort(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Short.class);\r\n}\n@Override\r\npublic short[] getShortArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, short[].class);\r\n}\n@Override\r\npublic int getInt(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Integer.class);\r\n}\n@Override\r\npublic int[] getIntArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, int[].class);\r\n}\n@Override\r\npublic long getLong(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Long.class);\r\n}\n@Override\r\npublic long[] getLongArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, long[].class);\r\n}\n@Override\r\npublic double getDouble(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Double.class);\r\n}\n@Override\r\npublic double[] getDoubleArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, double[].class);\r\n}\n@Override\r\npublic float getFloat(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Float.class);\r\n}\n@Override\r\npublic float[] getFloatArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, float[].class);\r\n}\n@Override\r\npublic String getString(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, String.class);\r\n}\n@Override\r\npublic String[] getStringArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, String[].class);\r\n}\n@Override\r\npublic Class<?> getClass(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Class.class);\r\n}\n@Override\r\npublic Class<?>[] getClassArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Class[].class);\r\n}\n@Override\r\npublic <E extends Enum<E>> E getEnum(String attributeName, Class<E> type) {\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return getRequiredAttributeValue(attributeName, type);\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) {\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (E[]) getRequiredAttributeValue(attributeName, type.arrayType());\r\n}\n@Override\r\npublic Optional<Object> getValue(String attributeName) {\r\n    return getValue(attributeName, Object.class);\r\n}\n@Override\r\npublic <T> Optional<T> getValue(String attributeName, Class<T> type) {\r\n    return Optional.ofNullable(getAttributeValue(attributeName, type));\r\n}\n@Override\r\npublic Optional<Object> getDefaultValue(String attributeName) {\r\n    return getDefaultValue(attributeName, Object.class);\r\n}\n@Override\r\npublic MergedAnnotation<A> filterDefaultValues() {\r\n    return filterAttributes(this::hasNonDefaultValue);\r\n}\n@Override\r\npublic AnnotationAttributes asAnnotationAttributes(Adapt... adaptations) {\r\n    return asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType()), adaptations);\r\n}\n@Override\r\npublic Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition) throws NoSuchElementException {\r\n    return (condition.test(this) ? Optional.of(synthesize()) : Optional.empty());\r\n}\n@Override\r\npublic A synthesize() {\r\n    if (!isPresent()) {\r\n        throw new NoSuchElementException(\"Unable to synthesize missing annotation\");\r\n    }\r\n    A synthesized = this.synthesizedAnnotation;\r\n    if (synthesized == null) {\r\n        synthesized = createSynthesizedAnnotation();\r\n        this.synthesizedAnnotation = synthesized;\r\n    }\r\n    return synthesized;\r\n}\nprivate <T> T getRequiredAttributeValue(String attributeName, Class<T> type) {\r\n    T value = getAttributeValue(attributeName, type);\r\n    if (value == null) {\r\n        throw new NoSuchElementException(\"No attribute named '\" + attributeName + \"' present in merged annotation \" + getType().getName());\r\n    }\r\n    return value;\r\n}\n/**\r\n * Get the underlying attribute value.\r\n * @param attributeName the attribute name\r\n * @param type the type to return (see {@link MergedAnnotation} class\r\n * documentation for details)\r\n * @return the attribute value or {@code null} if the value is not found and\r\n * is not required\r\n * @throws IllegalArgumentException if the source type is not compatible\r\n * @throws NoSuchElementException if the value is required but not found\r\n */\r\n@Nullable\r\nprotected abstract <T> T getAttributeValue(String attributeName, Class<T> type);\n/**\r\n * Factory method used to create the synthesized annotation.\r\n * <p>If the source is an annotation that is not <em>synthesizable</em>, it\r\n * will be returned unmodified.\r\n * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\r\n * for an explanation of what is considered synthesizable.\r\n */\r\nprotected abstract A createSynthesizedAnnotation();",
    "comment": "\n * Abstract base class for {@link MergedAnnotation} implementations.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @since 5.2\n * @param <A> the annotation type\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#isDirectlyPresent()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isDirectlyPresent() {\r\n    return isPresent() && getDistance() == 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#isMetaPresent()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isMetaPresent() {\r\n    return isPresent() && getDistance() > 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#hasNonDefaultValue(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNonDefaultValue(String attributeName) {\r\n    return !hasDefaultValue(attributeName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getByte(String)",
    "entityType": "method",
    "code": "@Override\r\npublic byte getByte(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Byte.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getByteArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic byte[] getByteArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, byte[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getBoolean(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean getBoolean(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Boolean.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getBooleanArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean[] getBooleanArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, boolean[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getChar(String)",
    "entityType": "method",
    "code": "@Override\r\npublic char getChar(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Character.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getCharArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic char[] getCharArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, char[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getShort(String)",
    "entityType": "method",
    "code": "@Override\r\npublic short getShort(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Short.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getShortArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic short[] getShortArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, short[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getInt(String)",
    "entityType": "method",
    "code": "@Override\r\npublic int getInt(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getIntArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic int[] getIntArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, int[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getLong(String)",
    "entityType": "method",
    "code": "@Override\r\npublic long getLong(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Long.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getLongArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic long[] getLongArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, long[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getDouble(String)",
    "entityType": "method",
    "code": "@Override\r\npublic double getDouble(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Double.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getDoubleArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic double[] getDoubleArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, double[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getFloat(String)",
    "entityType": "method",
    "code": "@Override\r\npublic float getFloat(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Float.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getFloatArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic float[] getFloatArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, float[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getString(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String getString(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getStringArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getStringArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, String[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getClass(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Class<?> getClass(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Class.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getClassArray(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Class<?>[] getClassArray(String attributeName) {\r\n    return getRequiredAttributeValue(attributeName, Class[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getEnum(String,Class<E>)",
    "entityType": "method",
    "code": "@Override\r\npublic <E extends Enum<E>> E getEnum(String attributeName, Class<E> type) {\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return getRequiredAttributeValue(attributeName, type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getEnumArray(String,Class<E>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <E extends Enum<E>> E[] getEnumArray(String attributeName, Class<E> type) {\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    return (E[]) getRequiredAttributeValue(attributeName, type.arrayType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getValue(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Optional<Object> getValue(String attributeName) {\r\n    return getValue(attributeName, Object.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getValue(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> Optional<T> getValue(String attributeName, Class<T> type) {\r\n    return Optional.ofNullable(getAttributeValue(attributeName, type));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getDefaultValue(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Optional<Object> getDefaultValue(String attributeName) {\r\n    return getDefaultValue(attributeName, Object.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#filterDefaultValues()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<A> filterDefaultValues() {\r\n    return filterAttributes(this::hasNonDefaultValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#asAnnotationAttributes(Adapt)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationAttributes asAnnotationAttributes(Adapt... adaptations) {\r\n    return asMap(mergedAnnotation -> new AnnotationAttributes(mergedAnnotation.getType()), adaptations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#synthesize(Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic Optional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition) throws NoSuchElementException {\r\n    return (condition.test(this) ? Optional.of(synthesize()) : Optional.empty());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#synthesize()",
    "entityType": "method",
    "code": "@Override\r\npublic A synthesize() {\r\n    if (!isPresent()) {\r\n        throw new NoSuchElementException(\"Unable to synthesize missing annotation\");\r\n    }\r\n    A synthesized = this.synthesizedAnnotation;\r\n    if (synthesized == null) {\r\n        synthesized = createSynthesizedAnnotation();\r\n        this.synthesizedAnnotation = synthesized;\r\n    }\r\n    return synthesized;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getRequiredAttributeValue(String,Class<T>)",
    "entityType": "method",
    "code": "private <T> T getRequiredAttributeValue(String attributeName, Class<T> type) {\r\n    T value = getAttributeValue(attributeName, type);\r\n    if (value == null) {\r\n        throw new NoSuchElementException(\"No attribute named '\" + attributeName + \"' present in merged annotation \" + getType().getName());\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#getAttributeValue(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Get the underlying attribute value.\r\n * @param attributeName the attribute name\r\n * @param type the type to return (see {@link MergedAnnotation} class\r\n * documentation for details)\r\n * @return the attribute value or {@code null} if the value is not found and\r\n * is not required\r\n * @throws IllegalArgumentException if the source type is not compatible\r\n * @throws NoSuchElementException if the value is required but not found\r\n */\r\n@Nullable\r\nprotected abstract <T> T getAttributeValue(String attributeName, Class<T> type);",
    "comment": "\n\t * Get the underlying attribute value.\n\t * @param attributeName the attribute name\n\t * @param type the type to return (see {@link MergedAnnotation} class\n\t * documentation for details)\n\t * @return the attribute value or {@code null} if the value is not found and\n\t * is not required\n\t * @throws IllegalArgumentException if the source type is not compatible\n\t * @throws NoSuchElementException if the value is required but not found\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AbstractMergedAnnotation#createSynthesizedAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * Factory method used to create the synthesized annotation.\r\n * <p>If the source is an annotation that is not <em>synthesizable</em>, it\r\n * will be returned unmodified.\r\n * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\r\n * for an explanation of what is considered synthesizable.\r\n */\r\nprotected abstract A createSynthesizedAnnotation();",
    "comment": "\n\t * Factory method used to create the synthesized annotation.\n\t * <p>If the source is an annotation that is not <em>synthesizable</em>, it\n\t * will be returned unmodified.\n\t * <p>Consult the documentation for {@link MergedAnnotation#synthesize()}\n\t * for an explanation of what is considered synthesizable.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils",
    "entityType": "class",
    "code": "/**\r\n * Build an adapted {@link AnnotatedElement} for the given annotations,\r\n * typically for use with other methods on {@link AnnotatedElementUtils}.\r\n * @param annotations the annotations to expose through the {@code AnnotatedElement}\r\n * @since 4.3\r\n */\r\npublic static AnnotatedElement forAnnotations(Annotation... annotations) {\r\n    return new AnnotatedElementForAnnotations(annotations);\r\n}\n/**\r\n * Get the fully qualified class names of all meta-annotation types\r\n * <em>present</em> on the annotation (of the specified {@code annotationType})\r\n * on the supplied {@link AnnotatedElement}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type on which to find meta-annotations\r\n * @return the names of all meta-annotations present on the annotation,\r\n * or an empty set if not found\r\n * @since 4.2\r\n * @see #getMetaAnnotationTypes(AnnotatedElement, String)\r\n * @see #hasMetaAnnotationTypes\r\n */\r\npublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));\r\n}\n/**\r\n * Get the fully qualified class names of all meta-annotation\r\n * types <em>present</em> on the annotation (of the specified\r\n * {@code annotationName}) on the supplied {@link AnnotatedElement}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation\r\n * type on which to find meta-annotations\r\n * @return the names of all meta-annotations present on the annotation,\r\n * or an empty set if none found\r\n * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\r\n * @see #hasMetaAnnotationTypes\r\n */\r\npublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\r\n    for (Annotation annotation : element.getAnnotations()) {\r\n        if (annotation.annotationType().getName().equals(annotationName)) {\r\n            return getMetaAnnotationTypes(element, annotation);\r\n        }\r\n    }\r\n    return Collections.emptySet();\r\n}\nprivate static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {\r\n    if (annotation == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return getAnnotations(annotation.annotationType()).stream().map(mergedAnnotation -> mergedAnnotation.getType().getName()).collect(Collectors.toCollection(LinkedHashSet::new));\r\n}\n/**\r\n * Determine if the supplied {@link AnnotatedElement} is annotated with\r\n * a <em>composed annotation</em> that is meta-annotated with an\r\n * annotation of the specified {@code annotationType}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the meta-annotation type to find\r\n * @return {@code true} if a matching meta-annotation is present\r\n * @since 4.2.3\r\n * @see #getMetaAnnotationTypes\r\n */\r\npublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    return getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);\r\n}\n/**\r\n * Determine if the supplied {@link AnnotatedElement} is annotated with a\r\n * <em>composed annotation</em> that is meta-annotated with an annotation\r\n * of the specified {@code annotationName}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the\r\n * meta-annotation type to find\r\n * @return {@code true} if a matching meta-annotation is present\r\n * @see #getMetaAnnotationTypes\r\n */\r\npublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\r\n    return getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);\r\n}\n/**\r\n * Determine if an annotation of the specified {@code annotationType}\r\n * is <em>present</em> on the supplied {@link AnnotatedElement} or\r\n * within the annotation hierarchy <em>above</em> the specified element.\r\n * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\r\n * will return a non-null value.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return {@code true} if a matching annotation is present\r\n * @since 4.2.3\r\n * @see #hasAnnotation(AnnotatedElement, Class)\r\n */\r\npublic static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.isAnnotationPresent(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return getAnnotations(element).isPresent(annotationType);\r\n}\n/**\r\n * Determine if an annotation of the specified {@code annotationName} is\r\n * <em>present</em> on the supplied {@link AnnotatedElement} or within the\r\n * annotation hierarchy <em>above</em> the specified element.\r\n * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}\r\n * will return a non-null value.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @return {@code true} if a matching annotation is present\r\n */\r\npublic static boolean isAnnotated(AnnotatedElement element, String annotationName) {\r\n    return getAnnotations(element).isPresent(annotationName);\r\n}\n/**\r\n * Get the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    MergedAnnotation<?> mergedAnnotation = getAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, false, false);\r\n}\n/**\r\n * Get the first annotation of the specified {@code annotationName} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},\r\n * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, String annotationName) {\r\n    return getMergedAnnotationAttributes(element, annotationName, false, false);\r\n}\n/**\r\n * Get the first annotation of the specified {@code annotationName} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>Attributes from lower levels in the annotation hierarchy override attributes\r\n * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are\r\n * fully supported, both within a single annotation and within the annotation hierarchy.\r\n * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by\r\n * this method will stop searching the annotation hierarchy once the first annotation\r\n * of the specified {@code annotationName} has been found. As a consequence,\r\n * additional annotations of the specified {@code annotationName} will be ignored.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into Strings or to\r\n * preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances\r\n * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element, String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    MergedAnnotation<?> mergedAnnotation = getAnnotations(element).get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}\n/**\r\n * Get the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element},\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy, and synthesize\r\n * the result back into an annotation of the specified {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return getAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared()).synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}\n/**\r\n * Get <strong>all</strong> annotations of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 4.3\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String)\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> getAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return getAnnotations(element).stream(annotationType).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Get <strong>all</strong> annotations of the specified {@code annotationTypes}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the\r\n * annotation hierarchy and synthesize the results back into an annotation\r\n * of the corresponding {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationTypes the annotation types to find\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 5.1\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\r\n    return getAnnotations(element).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes)).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>The container type that holds the repeatable annotations will be looked up\r\n * via {@link java.lang.annotation.Repeatable}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @since 4.3\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return getMergedRepeatableAnnotations(element, annotationType, null);\r\n}\n/**\r\n * Get all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\r\n * {@code null}, the search will be restricted to supporting only repeatable\r\n * annotations whose container is the supplied {@code containerType}. This\r\n * prevents the search from finding repeatable annotations declared as\r\n * meta-annotations on other types of repeatable annotations. If you need to\r\n * support such a use case, favor {@link #getMergedRepeatableAnnotations(AnnotatedElement, Class)}\r\n * over this method or alternatively use the {@link MergedAnnotations} API\r\n * directly in conjunction with {@link RepeatableContainers} that are\r\n * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\r\n * multiple repeatable annotation types.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @param containerType the type of the container that holds the annotations;\r\n * may be {@code null} if the container type should be looked up via\r\n * {@link java.lang.annotation.Repeatable}\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @throws AnnotationConfigurationException if the supplied {@code containerType}\r\n * is not a valid container annotation for the supplied {@code annotationType}\r\n * @since 4.3\r\n * @see #getMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> getMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\r\n    return getRepeatableAnnotations(element, containerType, annotationType).stream(annotationType).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Get the annotation attributes of <strong>all</strong> annotations of the specified\r\n * {@code annotationName} in the annotation hierarchy above the supplied\r\n * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}.\r\n * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\r\n * this method does <em>not</em> support attribute overrides.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\r\n * attributes from all annotations found, or {@code null} if not found\r\n * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\npublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName) {\r\n    return getAllAnnotationAttributes(element, annotationName, false, false);\r\n}\n/**\r\n * Get the annotation attributes of <strong>all</strong> annotations of\r\n * the specified {@code annotationName} in the annotation hierarchy above\r\n * the supplied {@link AnnotatedElement} and store the results in a\r\n * {@link MultiValueMap}.\r\n * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},\r\n * this method does <em>not</em> support attribute overrides.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into Strings or to\r\n * preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\r\n * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation\r\n * attributes from all annotations found, or {@code null} if not found\r\n */\r\npublic static MultiValueMap<String, @Nullable Object> getAllAnnotationAttributes(AnnotatedElement element, String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {\r\n    Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);\r\n    return getAnnotations(element).stream(annotationName).filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes)).map(MergedAnnotation::withNonMergedAttributes).collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));\r\n}\n/**\r\n * Determine if an annotation of the specified {@code annotationType}\r\n * is <em>available</em> on the supplied {@link AnnotatedElement} or\r\n * within the annotation hierarchy <em>above</em> the specified element.\r\n * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}\r\n * will return a non-null value.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return {@code true} if a matching annotation is present\r\n * @since 4.3\r\n * @see #isAnnotated(AnnotatedElement, Class)\r\n */\r\npublic static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.isAnnotationPresent(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return findAnnotations(element).isPresent(annotationType);\r\n}\n/**\r\n * Find the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>Attributes from lower levels in the annotation hierarchy override\r\n * attributes of the same name from higher levels, and\r\n * {@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm\r\n * used by this method will stop searching the annotation hierarchy once the\r\n * first annotation of the specified {@code annotationType} has been found.\r\n * As a consequence, additional annotations of the specified\r\n * {@code annotationType} will be ignored.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into\r\n * Strings or to preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\r\n * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    MergedAnnotation<?> mergedAnnotation = findAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}\n/**\r\n * Find the first annotation of the specified {@code annotationName} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element} and\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy.\r\n * <p>Attributes from lower levels in the annotation hierarchy override\r\n * attributes of the same name from higher levels, and\r\n * {@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>In contrast to {@link #getAllAnnotationAttributes}, the search\r\n * algorithm used by this method will stop searching the annotation\r\n * hierarchy once the first annotation of the specified\r\n * {@code annotationName} has been found. As a consequence, additional\r\n * annotations of the specified {@code annotationName} will be ignored.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation type to find\r\n * @param classValuesAsString whether to convert Class references into Strings or to\r\n * preserve them as Class references\r\n * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into\r\n * {@code AnnotationAttributes} maps or to preserve them as Annotation instances\r\n * @return the merged {@code AnnotationAttributes}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n */\r\n@Nullable\r\npublic static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    MergedAnnotation<?> mergedAnnotation = findAnnotations(element).get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());\r\n    return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);\r\n}\n/**\r\n * Find the first annotation of the specified {@code annotationType} within\r\n * the annotation hierarchy <em>above</em> the supplied {@code element},\r\n * merge that annotation's attributes with <em>matching</em> attributes from\r\n * annotations in lower levels of the annotation hierarchy, and synthesize\r\n * the result back into an annotation of the specified {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\r\n * within a single annotation and within the annotation hierarchy.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type to find\r\n * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\r\n * @since 4.2\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\r\n * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\r\n */\r\n@Nullable\r\npublic static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\r\n    // Shortcut: directly present on the element, with no merging needed?\r\n    if (AnnotationFilter.PLAIN.matches(annotationType) || AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {\r\n        return element.getDeclaredAnnotation(annotationType);\r\n    }\r\n    // Exhaustive retrieval of merged annotations...\r\n    return findAnnotations(element).get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared()).synthesize(MergedAnnotation::isPresent).orElse(null);\r\n}\n/**\r\n * Find <strong>all</strong> annotations of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 4.3\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #getAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return findAnnotations(element).stream(annotationType).sorted(highAggregateIndexesFirst()).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Find <strong>all</strong> annotations of the specified {@code annotationTypes}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the\r\n * annotation hierarchy and synthesize the results back into an annotation\r\n * of the corresponding {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationTypes the annotation types to find\r\n * @return the set of all merged, synthesized {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @since 5.1\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {\r\n    return findAnnotations(element).stream().filter(MergedAnnotationPredicates.typeIn(annotationTypes)).sorted(highAggregateIndexesFirst()).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\n/**\r\n * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>The container type that holds the repeatable annotations will be looked up\r\n * via {@link java.lang.annotation.Repeatable}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @since 4.3\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType) {\r\n    return findMergedRepeatableAnnotations(element, annotationType, null);\r\n}\n/**\r\n * Find all <em>repeatable annotations</em> of the specified {@code annotationType}\r\n * within the annotation hierarchy <em>above</em> the supplied {@code element};\r\n * and for each annotation found, merge that annotation's attributes with\r\n * <em>matching</em> attributes from annotations in lower levels of the annotation\r\n * hierarchy and synthesize the results back into an annotation of the specified\r\n * {@code annotationType}.\r\n * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a\r\n * single annotation and within annotation hierarchies.\r\n * <p>This method follows <em>find semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * <p><strong>WARNING</strong>: if the supplied {@code containerType} is not\r\n * {@code null}, the search will be restricted to supporting only repeatable\r\n * annotations whose container is the supplied {@code containerType}. This\r\n * prevents the search from finding repeatable annotations declared as\r\n * meta-annotations on other types of repeatable annotations. If you need to\r\n * support such a use case, favor {@link #findMergedRepeatableAnnotations(AnnotatedElement, Class)}\r\n * over this method or alternatively use the {@link MergedAnnotations} API\r\n * directly in conjunction with {@link RepeatableContainers} that are\r\n * {@linkplain RepeatableContainers#and(Class, Class) composed} to support\r\n * multiple repeatable annotation types.\r\n * @param element the annotated element (never {@code null})\r\n * @param annotationType the annotation type to find (never {@code null})\r\n * @param containerType the type of the container that holds the annotations;\r\n * may be {@code null} if the container type should be looked up via\r\n * {@link java.lang.annotation.Repeatable}\r\n * @return the set of all merged repeatable {@code Annotations} found,\r\n * or an empty set if none were found\r\n * @throws IllegalArgumentException if the {@code element} or {@code annotationType}\r\n * is {@code null}, or if the container type cannot be resolved\r\n * @throws AnnotationConfigurationException if the supplied {@code containerType}\r\n * is not a valid container annotation for the supplied {@code annotationType}\r\n * @since 4.3\r\n * @see #findMergedAnnotation(AnnotatedElement, Class)\r\n * @see #findAllMergedAnnotations(AnnotatedElement, Class)\r\n */\r\npublic static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element, Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {\r\n    return findRepeatableAnnotations(element, containerType, annotationType).stream(annotationType).sorted(highAggregateIndexesFirst()).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n}\nprivate static MergedAnnotations getAnnotations(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());\r\n}\nprivate static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element, @Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\r\n    RepeatableContainers repeatableContainers;\r\n    if (containerType == null) {\r\n        // Invoke RepeatableContainers.of() in order to adhere to the contract of\r\n        // getMergedRepeatableAnnotations() which states that an IllegalArgumentException\r\n        // will be thrown if the container cannot be resolved.\r\n        //\r\n        // In any case, we use standardRepeatables() in order to support repeatable\r\n        // annotations on other types of repeatable annotations (i.e., nested repeatable\r\n        // annotation types).\r\n        //\r\n        // See https://github.com/spring-projects/spring-framework/issues/20279\r\n        RepeatableContainers.of(annotationType, null);\r\n        repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    } else {\r\n        repeatableContainers = RepeatableContainers.of(annotationType, containerType);\r\n    }\r\n    return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);\r\n}\nprivate static MergedAnnotations findAnnotations(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());\r\n}\nprivate static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element, @Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {\r\n    RepeatableContainers repeatableContainers;\r\n    if (containerType == null) {\r\n        // Invoke RepeatableContainers.of() in order to adhere to the contract of\r\n        // findMergedRepeatableAnnotations() which states that an IllegalArgumentException\r\n        // will be thrown if the container cannot be resolved.\r\n        //\r\n        // In any case, we use standardRepeatables() in order to support repeatable\r\n        // annotations on other types of repeatable annotations (i.e., nested repeatable\r\n        // annotation types).\r\n        //\r\n        // See https://github.com/spring-projects/spring-framework/issues/20279\r\n        RepeatableContainers.of(annotationType, null);\r\n        repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    } else {\r\n        repeatableContainers = RepeatableContainers.of(annotationType, containerType);\r\n    }\r\n    return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);\r\n}\n@Nullable\r\nprivate static MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {\r\n    return (map.isEmpty() ? null : map);\r\n}\nprivate static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {\r\n    return Comparator.<MergedAnnotation<A>>comparingInt(MergedAnnotation::getAggregateIndex).reversed();\r\n}\n@Nullable\r\nprivate static AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {\r\n    if (!annotation.isPresent()) {\r\n        return null;\r\n    }\r\n    return annotation.asAnnotationAttributes(Adapt.values(classValuesAsString, nestedAnnotationsAsMap));\r\n}\n/**\r\n * Adapted {@link AnnotatedElement} that holds specific annotations.\r\n */\r\nprivate static class AnnotatedElementForAnnotations implements AnnotatedElement {\r\n\r\n    private final Annotation[] annotations;\r\n\r\n    AnnotatedElementForAnnotations(Annotation... annotations) {\r\n        this.annotations = annotations;\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {\r\n        for (Annotation annotation : this.annotations) {\r\n            if (annotation.annotationType() == annotationClass) {\r\n                return (T) annotation;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Annotation[] getAnnotations() {\r\n        return this.annotations.clone();\r\n    }\r\n\r\n    @Override\r\n    public Annotation[] getDeclaredAnnotations() {\r\n        return this.annotations.clone();\r\n    }\r\n}",
    "comment": "\n * General utility methods for finding annotations, meta-annotations, and\n * repeatable annotations on {@link AnnotatedElement AnnotatedElements}.\n *\n * <p>{@code AnnotatedElementUtils} defines the public API for Spring's\n * meta-annotation programming model with support for <em>annotation attribute\n * overrides</em>. If you do not need support for annotation attribute\n * overrides, consider using {@link AnnotationUtils} instead.\n *\n * <p>Note that the features of this class are not provided by the JDK's\n * introspection facilities themselves.\n *\n * <h3>Annotation Attribute Overrides</h3>\n * <p>Support for meta-annotations with <em>attribute overrides</em> in\n * <em>composed annotations</em> is provided by all variants of the\n * {@code getMergedAnnotationAttributes()}, {@code getMergedAnnotation()},\n * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},\n * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},\n * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}\n * methods.\n *\n * <h3>Find vs. Get Semantics</h3>\n * <p>The search algorithms used by methods in this class follow either\n * <em>find</em> or <em>get</em> semantics. Consult the javadocs for each\n * individual method for details on which search algorithm is used.\n *\n * <p><strong>Get semantics</strong> are limited to searching for annotations\n * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared\n * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared\n * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}.\n *\n * <p><strong>Find semantics</strong> are much more exhaustive, providing\n * <em>get semantics</em> plus support for the following:\n *\n * <ul>\n * <li>Searching on interfaces, if the annotated element is a class\n * <li>Searching on superclasses, if the annotated element is a class\n * <li>Resolving bridged methods, if the annotated element is a method\n * <li>Searching on methods in interfaces, if the annotated element is a method\n * <li>Searching on methods in superclasses, if the annotated element is a method\n * </ul>\n *\n * <h3>Support for {@code @Inherited}</h3>\n * <p>Methods following <em>get semantics</em> will honor the contract of Java's\n * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally\n * declared annotations (including custom composed annotations) will be favored over\n * inherited annotations. In contrast, methods following <em>find semantics</em>\n * will completely ignore the presence of {@code @Inherited} since the <em>find</em>\n * search algorithm manually traverses type and method hierarchies and thereby\n * implicitly supports annotation inheritance without a need for {@code @Inherited}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 4.0\n * @see AliasFor\n * @see AnnotationAttributes\n * @see AnnotationUtils\n * @see BridgeMethodResolver\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#forAnnotations(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Build an adapted {@link AnnotatedElement} for the given annotations,\r\n * typically for use with other methods on {@link AnnotatedElementUtils}.\r\n * @param annotations the annotations to expose through the {@code AnnotatedElement}\r\n * @since 4.3\r\n */\r\npublic static AnnotatedElement forAnnotations(Annotation... annotations) {\r\n    return new AnnotatedElementForAnnotations(annotations);\r\n}",
    "comment": "\n\t * Build an adapted {@link AnnotatedElement} for the given annotations,\n\t * typically for use with other methods on {@link AnnotatedElementUtils}.\n\t * @param annotations the annotations to expose through the {@code AnnotatedElement}\n\t * @since 4.3\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMetaAnnotationTypes(AnnotatedElement,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Get the fully qualified class names of all meta-annotation types\r\n * <em>present</em> on the annotation (of the specified {@code annotationType})\r\n * on the supplied {@link AnnotatedElement}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the annotation type on which to find meta-annotations\r\n * @return the names of all meta-annotations present on the annotation,\r\n * or an empty set if not found\r\n * @since 4.2\r\n * @see #getMetaAnnotationTypes(AnnotatedElement, String)\r\n * @see #hasMetaAnnotationTypes\r\n */\r\npublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));\r\n}",
    "comment": "\n\t * Get the fully qualified class names of all meta-annotation types\n\t * <em>present</em> on the annotation (of the specified {@code annotationType})\n\t * on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if not found\n\t * @since 4.2\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, String)\n\t * @see #hasMetaAnnotationTypes\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMetaAnnotationTypes(AnnotatedElement,String)",
    "entityType": "method",
    "code": "/**\r\n * Get the fully qualified class names of all meta-annotation\r\n * types <em>present</em> on the annotation (of the specified\r\n * {@code annotationName}) on the supplied {@link AnnotatedElement}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationName the fully qualified class name of the annotation\r\n * type on which to find meta-annotations\r\n * @return the names of all meta-annotations present on the annotation,\r\n * or an empty set if none found\r\n * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\r\n * @see #hasMetaAnnotationTypes\r\n */\r\npublic static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {\r\n    for (Annotation annotation : element.getAnnotations()) {\r\n        if (annotation.annotationType().getName().equals(annotationName)) {\r\n            return getMetaAnnotationTypes(element, annotation);\r\n        }\r\n    }\r\n    return Collections.emptySet();\r\n}",
    "comment": "\n\t * Get the fully qualified class names of all meta-annotation\n\t * types <em>present</em> on the annotation (of the specified\n\t * {@code annotationName}) on the supplied {@link AnnotatedElement}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type on which to find meta-annotations\n\t * @return the names of all meta-annotations present on the annotation,\n\t * or an empty set if none found\n\t * @see #getMetaAnnotationTypes(AnnotatedElement, Class)\n\t * @see #hasMetaAnnotationTypes\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#getMetaAnnotationTypes(AnnotatedElement,Annotation)",
    "entityType": "method",
    "code": "private static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {\r\n    if (annotation == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return getAnnotations(annotation.annotationType()).stream().map(mergedAnnotation -> mergedAnnotation.getType().getName()).collect(Collectors.toCollection(LinkedHashSet::new));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtils#hasMetaAnnotationTypes(AnnotatedElement,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied {@link AnnotatedElement} is annotated with\r\n * a <em>composed annotation</em> that is meta-annotated with an\r\n * annotation of the specified {@code annotationType}.\r\n * <p>This method follows <em>get semantics</em> as described in the\r\n * {@linkplain AnnotatedElementUtils class-level javadoc}.\r\n * @param element the annotated element\r\n * @param annotationType the meta-annotation type to find\r\n * @return {@code true} if a matching meta-annotation is present\r\n * @since 4.2.3\r\n * @see #getMetaAnnotationTypes\r\n */\r\npublic static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    return getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);\r\n}",
    "comment": "\n\t * Determine if the supplied {@link AnnotatedElement} is annotated with\n\t * a <em>composed annotation</em> that is meta-annotated with an\n\t * annotation of the specified {@code annotationType}.\n\t * <p>This method follows <em>get semantics</em> as described in the\n\t * {@linkplain AnnotatedElementUtils class-level javadoc}.\n\t * @param element the annotated element\n\t * @param annotationType the meta-annotation type to find\n\t * @return {@code true} if a matching meta-annotation is present\n\t * @since 4.2.3\n\t * @see #getMetaAnnotationTypes\n\t "
  }
]