[
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#standardAnnotationMetadata()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponent.class);\r\n    doTestAnnotationInfo(metadata);\r\n    doTestMethodAnnotationInfo(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#asmAnnotationMetadata()",
    "entityType": "method",
    "code": "@Test\r\nvoid asmAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponent.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    doTestAnnotationInfo(metadata);\r\n    doTestMethodAnnotationInfo(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethod",
    "entityType": "class",
    "code": "private final ClassName className;\nprivate final String name;\nprivate final MethodSpec methodSpec;\n/**\r\n * Create a new {@link GeneratedMethod} instance with the given name. This\r\n * constructor is package-private since names should only be generated via\r\n * {@link GeneratedMethods}.\r\n * @param className the declaring class of the method\r\n * @param name the generated method name\r\n * @param method consumer to generate the method\r\n */\r\nGeneratedMethod(ClassName className, String name, Consumer<MethodSpec.Builder> method) {\r\n    this.className = className;\r\n    this.name = name;\r\n    MethodSpec.Builder builder = MethodSpec.methodBuilder(this.name);\r\n    method.accept(builder);\r\n    this.methodSpec = builder.build();\r\n    Assert.state(this.name.equals(this.methodSpec.name), \"'method' consumer must not change the generated method name\");\r\n}\n/**\r\n * Return the generated name of the method.\r\n * @return the name of the generated method\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}\n/**\r\n * Return a {@link MethodReference} to this generated method.\r\n * @return a method reference\r\n */\r\npublic MethodReference toMethodReference() {\r\n    return new DefaultMethodReference(this.methodSpec, this.className);\r\n}\n/**\r\n * Return the {@link MethodSpec} for this generated method.\r\n * @return the method spec\r\n * @throws IllegalStateException if one of the {@code generateBy(...)}\r\n * methods has not been called\r\n */\r\nMethodSpec getMethodSpec() {\r\n    return this.methodSpec;\r\n}\n@Override\r\npublic String toString() {\r\n    return this.name;\r\n}",
    "comment": "\n * A generated method.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n * @see GeneratedMethods\n "
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#standardAnnotationMetadataForSubclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardAnnotationMetadataForSubclass() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotatedComponentSubClass.class);\r\n    doTestSubClassAnnotationInfo(metadata, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethod#getName()",
    "entityType": "method",
    "code": "/**\r\n * Return the generated name of the method.\r\n * @return the name of the generated method\r\n */\r\npublic String getName() {\r\n    return this.name;\r\n}",
    "comment": "\n\t * Return the generated name of the method.\n\t * @return the name of the generated method\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethod#toMethodReference()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link MethodReference} to this generated method.\r\n * @return a method reference\r\n */\r\npublic MethodReference toMethodReference() {\r\n    return new DefaultMethodReference(this.methodSpec, this.className);\r\n}",
    "comment": "\n\t * Return a {@link MethodReference} to this generated method.\n\t * @return a method reference\n\t "
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#asmAnnotationMetadataForSubclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid asmAnnotationMetadataForSubclass() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedComponentSubClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    doTestSubClassAnnotationInfo(metadata, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethod#getMethodSpec()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link MethodSpec} for this generated method.\r\n * @return the method spec\r\n * @throws IllegalStateException if one of the {@code generateBy(...)}\r\n * methods has not been called\r\n */\r\nMethodSpec getMethodSpec() {\r\n    return this.methodSpec;\r\n}",
    "comment": "\n\t * Return the {@link MethodSpec} for this generated method.\n\t * @return the method spec\n\t * @throws IllegalStateException if one of the {@code generateBy(...)}\n\t * methods has not been called\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethod#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#doTestSubClassAnnotationInfo(AnnotationMetadata,boolean)",
    "entityType": "method",
    "code": "private void doTestSubClassAnnotationInfo(AnnotationMetadata metadata, boolean asm) {\r\n    assertThat(metadata.getClassName()).isEqualTo(AnnotatedComponentSubClass.class.getName());\r\n    assertThat(metadata.isInterface()).isFalse();\r\n    assertThat(metadata.isAnnotation()).isFalse();\r\n    assertThat(metadata.isAbstract()).isFalse();\r\n    assertThat(metadata.isConcrete()).isTrue();\r\n    assertThat(metadata.hasSuperClass()).isTrue();\r\n    assertThat(metadata.getSuperClassName()).isEqualTo(AnnotatedComponent.class.getName());\r\n    assertThat(metadata.getInterfaceNames()).isEmpty();\r\n    assertThat(metadata.isAnnotated(Component.class.getName())).isFalse();\r\n    assertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\r\n    assertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\r\n    if (asm) {\r\n        assertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isFalse();\r\n        assertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\r\n        assertThat(metadata.getAnnotationTypes()).isEmpty();\r\n    } else {\r\n        assertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\r\n        assertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\r\n        assertThat(metadata.getAnnotationTypes()).containsExactly(NamedComposedAnnotation.class.getName());\r\n    }\r\n    assertThat(metadata.hasAnnotation(Component.class.getName())).isFalse();\r\n    assertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\r\n    assertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\r\n    assertThat(metadata.hasMetaAnnotation(Component.class.getName())).isFalse();\r\n    assertThat(metadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\r\n    assertThat(metadata.getAnnotationAttributes(Component.class.getName())).isNull();\r\n    assertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), false)).isNull();\r\n    assertThat(metadata.getAnnotationAttributes(MetaAnnotation.class.getName(), true)).isNull();\r\n    assertThat(metadata.getAnnotatedMethods(DirectAnnotation.class.getName())).isEmpty();\r\n    assertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isFalse();\r\n    assertThat(metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName())).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#standardAnnotationMetadataForInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardAnnotationMetadataForInterface() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(AnnotationMetadata.class);\r\n    doTestMetadataForInterfaceClass(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#asmAnnotationMetadataForInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid asmAnnotationMetadataForInterface() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotationMetadata.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    doTestMetadataForInterfaceClass(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#doTestMetadataForInterfaceClass(AnnotationMetadata)",
    "entityType": "method",
    "code": "private void doTestMetadataForInterfaceClass(AnnotationMetadata metadata) {\r\n    assertThat(metadata.getClassName()).isEqualTo(AnnotationMetadata.class.getName());\r\n    assertThat(metadata.isInterface()).isTrue();\r\n    assertThat(metadata.isAnnotation()).isFalse();\r\n    assertThat(metadata.isAbstract()).isTrue();\r\n    assertThat(metadata.isConcrete()).isFalse();\r\n    assertThat(metadata.hasSuperClass()).isFalse();\r\n    assertThat(metadata.getSuperClassName()).isNull();\r\n    assertThat(metadata.getInterfaceNames()).hasSize(2);\r\n    assertThat(metadata.getInterfaceNames()[0]).isEqualTo(ClassMetadata.class.getName());\r\n    assertThat(metadata.getInterfaceNames()[1]).isEqualTo(AnnotatedTypeMetadata.class.getName());\r\n    assertThat(metadata.getAnnotationTypes()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#standardAnnotationMetadataForAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid standardAnnotationMetadataForAnnotation() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(Component.class);\r\n    doTestMetadataForAnnotationClass(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#asmAnnotationMetadataForAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid asmAnnotationMetadataForAnnotation() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(Component.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    doTestMetadataForAnnotationClass(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#doTestMetadataForAnnotationClass(AnnotationMetadata)",
    "entityType": "method",
    "code": "private void doTestMetadataForAnnotationClass(AnnotationMetadata metadata) {\r\n    assertThat(metadata.getClassName()).isEqualTo(Component.class.getName());\r\n    assertThat(metadata.isInterface()).isTrue();\r\n    assertThat(metadata.isAnnotation()).isTrue();\r\n    assertThat(metadata.isAbstract()).isTrue();\r\n    assertThat(metadata.isConcrete()).isFalse();\r\n    assertThat(metadata.hasSuperClass()).isFalse();\r\n    assertThat(metadata.getSuperClassName()).isNull();\r\n    assertThat(metadata.getInterfaceNames()).hasSize(1);\r\n    assertThat(metadata.getInterfaceNames()[0]).isEqualTo(Annotation.class.getName());\r\n    assertThat(metadata.isAnnotated(Documented.class.getName())).isFalse();\r\n    assertThat(metadata.isAnnotated(Scope.class.getName())).isFalse();\r\n    assertThat(metadata.isAnnotated(SpecialAttr.class.getName())).isFalse();\r\n    assertThat(metadata.hasAnnotation(Documented.class.getName())).isFalse();\r\n    assertThat(metadata.hasAnnotation(Scope.class.getName())).isFalse();\r\n    assertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isFalse();\r\n    assertThat(metadata.getAnnotationTypes()).hasSize(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#standardAnnotationMetadata_nestedAnnotationsAsMap_false()",
    "entityType": "method",
    "code": "/**\r\n * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\r\n * defaults to return nested annotations and annotation arrays as actual\r\n * Annotation instances. It is recommended for compatibility with ASM-based\r\n * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\r\n * 'true' as is done in the main test above.\r\n */\r\n@Test\r\nvoid standardAnnotationMetadata_nestedAnnotationsAsMap_false() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    AnnotationMetadata metadata = new StandardAnnotationMetadata(AnnotatedComponent.class);\r\n    AnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\r\n    Annotation[] nestedAnnoArray = (Annotation[]) specialAttrs.get(\"nestedAnnoArray\");\r\n    assertThat(nestedAnnoArray[0]).isInstanceOf(NestedAnno.class);\r\n}",
    "comment": "\n\t * In order to preserve backward-compatibility, {@link StandardAnnotationMetadata}\n\t * defaults to return nested annotations and annotation arrays as actual\n\t * Annotation instances. It is recommended for compatibility with ASM-based\n\t * AnnotationMetadata implementations to set the 'nestedAnnotationsAsMap' flag to\n\t * 'true' as is done in the main test above.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#metaAnnotationOverridesUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "@Test\r\nvoid metaAnnotationOverridesUsingStandardAnnotationMetadata() {\r\n    @SuppressWarnings(\"deprecation\")\r\n    AnnotationMetadata metadata = new StandardAnnotationMetadata(ComposedConfigurationWithAttributeOverridesClass.class);\r\n    assertMetaAnnotationOverrides(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#metaAnnotationOverridesUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "@Test\r\nvoid metaAnnotationOverridesUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(ComposedConfigurationWithAttributeOverridesClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertMetaAnnotationOverrides(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#assertMetaAnnotationOverrides(AnnotationMetadata)",
    "entityType": "method",
    "code": "private void assertMetaAnnotationOverrides(AnnotationMetadata metadata) {\r\n    AnnotationAttributes attributes = (AnnotationAttributes) metadata.getAnnotationAttributes(TestComponentScan.class.getName(), false);\r\n    assertThat(attributes.getStringArray(\"value\")).containsExactly(\"org.example.componentscan\");\r\n    assertThat(attributes.getStringArray(\"basePackages\")).containsExactly(\"org.example.componentscan\");\r\n    assertThat(attributes.getClassArray(\"basePackageClasses\")).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "// SPR-11649\r\n@Test\r\nvoid multipleAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(NamedAnnotationsClass.class);\r\n    assertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "// SPR-11649\r\n@Test\r\nvoid multipleAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedAnnotationsClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "// SPR-11649\r\n@Test\r\nvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationClass.class);\r\n    assertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "// SPR-11649\r\n@Test\r\nvoid composedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertMultipleAnnotationsWithIdenticalAttributeNames(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "// gh-31041\r\n@Test\r\nvoid multipleComposedRepeatableAnnotationsUsingStandardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\r\n    assertRepeatableAnnotations(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "// gh-31041\r\n@Test\r\nvoid multipleComposedRepeatableAnnotationsUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertRepeatableAnnotations(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "// gh-31074\r\n@Test\r\nvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingStandardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleComposedRepeatableAnnotationsClass.class);\r\n    assertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "// gh-31074\r\n@Test\r\nvoid multipleComposedRepeatableAnnotationsSortedByReversedMetaDistanceUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleComposedRepeatableAnnotationsClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertRepeatableAnnotationsSortedByReversedMetaDistance(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "// gh-31041\r\n@Test\r\nvoid multipleRepeatableAnnotationsInContainersUsingStandardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(MultipleRepeatableAnnotationsInContainersClass.class);\r\n    assertRepeatableAnnotations(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "// gh-31041\r\n@Test\r\nvoid multipleRepeatableAnnotationsInContainersUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(MultipleRepeatableAnnotationsInContainersClass.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertRepeatableAnnotations(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils()",
    "entityType": "method",
    "code": "/**\r\n * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\r\n * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\r\n * behaves the same.\r\n */\r\n// gh-31041\r\n@Test\r\nvoid multipleComposedRepeatableAnnotationsUsingAnnotatedElementUtils() {\r\n    Class<?> element = MultipleComposedRepeatableAnnotationsClass.class;\r\n    Set<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\r\n    assertRepeatableAnnotations(annotations);\r\n    annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\r\n    assertRepeatableAnnotations(annotations);\r\n}",
    "comment": "\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils()",
    "entityType": "method",
    "code": "/**\r\n * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\r\n * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\r\n * behaves the same.\r\n */\r\n// gh-31041\r\n@Test\r\nvoid multipleRepeatableAnnotationsInContainersUsingAnnotatedElementUtils() {\r\n    Class<?> element = MultipleRepeatableAnnotationsInContainersClass.class;\r\n    Set<TestComponentScan> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class);\r\n    assertRepeatableAnnotations(annotations);\r\n    annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(element, TestComponentScan.class, TestComponentScans.class);\r\n    assertRepeatableAnnotations(annotations);\r\n}",
    "comment": "\n\t * Tests {@code AnnotatedElementUtils#getMergedRepeatableAnnotations()} variants to ensure that\n\t * {@link AnnotationMetadata#getMergedRepeatableAnnotationAttributes(Class, Class, boolean)}\n\t * behaves the same.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#assertRepeatableAnnotations(AnnotationMetadata)",
    "entityType": "method",
    "code": "private static void assertRepeatableAnnotations(AnnotationMetadata metadata) {\r\n    Set<AnnotationAttributes> attributesSet = metadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, true);\r\n    assertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream)).containsExactly(\"A\", \"B\", \"C\", \"D\");\r\n    assertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream)).containsExactly(\"A\", \"B\", \"C\", \"D\");\r\n    assertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackageClasses\")).flatMap(Arrays::stream)).containsExactly(\"java.lang.String\", \"java.lang.Integer\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata)",
    "entityType": "method",
    "code": "private static void assertRepeatableAnnotationsSortedByReversedMetaDistance(AnnotationMetadata metadata) {\r\n    // Note: although the real @ComponentScan annotation is not looked up using\r\n    // \"sortByReversedMetaDistance\" semantics, we can still use @TestComponentScan\r\n    // to verify the expected behavior.\r\n    Set<AnnotationAttributes> attributesSet = metadata.getMergedRepeatableAnnotationAttributes(TestComponentScan.class, TestComponentScans.class, false, true);\r\n    assertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"value\")).flatMap(Arrays::stream)).containsExactly(\"C\", \"D\", \"A\", \"B\");\r\n    assertThat(attributesSet.stream().map(attributes -> attributes.getStringArray(\"basePackages\")).flatMap(Arrays::stream)).containsExactly(\"C\", \"D\", \"A\", \"B\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#assertRepeatableAnnotations(Set<TestComponentScan>)",
    "entityType": "method",
    "code": "private static void assertRepeatableAnnotations(Set<TestComponentScan> annotations) {\r\n    assertThat(annotations.stream().map(TestComponentScan::value).flatMap(Arrays::stream)).containsExactly(\"A\", \"B\", \"C\", \"D\");\r\n    assertThat(annotations.stream().map(TestComponentScan::basePackages).flatMap(Arrays::stream)).containsExactly(\"A\", \"B\", \"C\", \"D\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata()",
    "entityType": "method",
    "code": "@Test\r\nvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingStandardAnnotationMetadata() {\r\n    AnnotationMetadata metadata = AnnotationMetadata.introspect(NamedComposedAnnotationExtended.class);\r\n    assertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata()",
    "entityType": "method",
    "code": "@Test\r\nvoid inheritedAnnotationWithMetaAnnotationsWithIdenticalAttributeNamesUsingSimpleAnnotationMetadata() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(NamedComposedAnnotationExtended.class.getName());\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    assertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata)",
    "entityType": "method",
    "code": "private void assertMultipleAnnotationsWithIdenticalAttributeNames(AnnotationMetadata metadata) {\r\n    AnnotationAttributes attributes1 = (AnnotationAttributes) metadata.getAnnotationAttributes(NamedAnnotation1.class.getName(), false);\r\n    String name1 = attributes1.getString(\"name\");\r\n    assertThat(name1).as(\"name of NamedAnnotation1\").isEqualTo(\"name 1\");\r\n    AnnotationAttributes attributes2 = (AnnotationAttributes) metadata.getAnnotationAttributes(NamedAnnotation2.class.getName(), false);\r\n    String name2 = attributes2.getString(\"name\");\r\n    assertThat(name2).as(\"name of NamedAnnotation2\").isEqualTo(\"name 2\");\r\n    AnnotationAttributes attributes3 = (AnnotationAttributes) metadata.getAnnotationAttributes(NamedAnnotation3.class.getName(), false);\r\n    String name3 = attributes3.getString(\"name\");\r\n    assertThat(name3).as(\"name of NamedAnnotation3\").isEqualTo(\"name 3\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#doTestAnnotationInfo(AnnotationMetadata)",
    "entityType": "method",
    "code": "private void doTestAnnotationInfo(AnnotationMetadata metadata) {\r\n    assertThat(metadata.getClassName()).isEqualTo(AnnotatedComponent.class.getName());\r\n    assertThat(metadata.isInterface()).isFalse();\r\n    assertThat(metadata.isAnnotation()).isFalse();\r\n    assertThat(metadata.isAbstract()).isFalse();\r\n    assertThat(metadata.isConcrete()).isTrue();\r\n    assertThat(metadata.hasSuperClass()).isTrue();\r\n    assertThat(metadata.getSuperClassName()).isEqualTo(Object.class.getName());\r\n    assertThat(metadata.getInterfaceNames()).hasSize(1);\r\n    assertThat(metadata.getInterfaceNames()[0]).isEqualTo(Serializable.class.getName());\r\n    assertThat(metadata.isAnnotated(Component.class.getName())).isTrue();\r\n    assertThat(metadata.isAnnotated(NamedComposedAnnotation.class.getName())).isTrue();\r\n    assertThat(metadata.hasAnnotation(Component.class.getName())).isTrue();\r\n    assertThat(metadata.hasAnnotation(Scope.class.getName())).isTrue();\r\n    assertThat(metadata.hasAnnotation(SpecialAttr.class.getName())).isTrue();\r\n    assertThat(metadata.hasAnnotation(NamedComposedAnnotation.class.getName())).isTrue();\r\n    assertThat(metadata.getAnnotationTypes()).containsExactlyInAnyOrder(Component.class.getName(), Scope.class.getName(), SpecialAttr.class.getName(), DirectAnnotation.class.getName(), MetaMetaAnnotation.class.getName(), EnumSubclasses.class.getName(), NamedComposedAnnotation.class.getName());\r\n    AnnotationAttributes compAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Component.class.getName());\r\n    assertThat(compAttrs).hasSize(1);\r\n    assertThat(compAttrs.getString(\"value\")).isEqualTo(\"myName\");\r\n    AnnotationAttributes scopeAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(Scope.class.getName());\r\n    assertThat(scopeAttrs).hasSize(1);\r\n    assertThat(scopeAttrs.getString(\"value\")).isEqualTo(\"myScope\");\r\n    Set<MethodMetadata> methods = metadata.getAnnotatedMethods(DirectAnnotation.class.getName());\r\n    MethodMetadata method = methods.iterator().next();\r\n    assertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\r\n    assertThat(method.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"myValue\")).isEqualTo(\"direct\");\r\n    List<Object> allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\r\n    assertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\r\n    allMeta = method.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\r\n    assertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(List.of(\"direct\")));\r\n    assertThat(metadata.isAnnotated(IsAnnotatedAnnotation.class.getName())).isTrue();\r\n    {\r\n        // perform tests with classValuesAsString = false (the default)\r\n        AnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName());\r\n        assertThat(specialAttrs).hasSize(6);\r\n        assertThat(String.class.isAssignableFrom(specialAttrs.getClass(\"clazz\"))).isTrue();\r\n        assertThat(specialAttrs.getEnum(\"state\").equals(Thread.State.NEW)).isTrue();\r\n        AnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\r\n        assertThat(nestedAnno.getString(\"value\")).isEqualTo(\"na\");\r\n        assertThat(nestedAnno.getEnum(\"anEnum\").equals(SomeEnum.LABEL1)).isTrue();\r\n        assertThat((Class<?>[]) nestedAnno.get(\"classArray\")).isEqualTo(new Class<?>[] { String.class });\r\n        AnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\r\n        assertThat(nestedAnnoArray).hasSize(2);\r\n        assertThat(nestedAnnoArray[0].getString(\"value\")).isEqualTo(\"default\");\r\n        assertThat(nestedAnnoArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\r\n        assertThat((Class<?>[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] { Void.class });\r\n        assertThat(nestedAnnoArray[1].getString(\"value\")).isEqualTo(\"na1\");\r\n        assertThat(nestedAnnoArray[1].getEnum(\"anEnum\").equals(SomeEnum.LABEL2)).isTrue();\r\n        assertThat((Class<?>[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new Class<?>[] { Number.class });\r\n        assertThat(nestedAnnoArray[1].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] { Number.class });\r\n        AnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\r\n        assertThat(optional.getString(\"value\")).isEqualTo(\"optional\");\r\n        assertThat(optional.getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\r\n        assertThat((Class<?>[]) optional.get(\"classArray\")).isEqualTo(new Class<?>[] { Void.class });\r\n        assertThat(optional.getClassArray(\"classArray\")).isEqualTo(new Class<?>[] { Void.class });\r\n        AnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\r\n        assertThat(optionalArray).hasSize(1);\r\n        assertThat(optionalArray[0].getString(\"value\")).isEqualTo(\"optional\");\r\n        assertThat(optionalArray[0].getEnum(\"anEnum\").equals(SomeEnum.DEFAULT)).isTrue();\r\n        assertThat((Class<?>[]) optionalArray[0].get(\"classArray\")).isEqualTo(new Class<?>[] { Void.class });\r\n        assertThat(optionalArray[0].getClassArray(\"classArray\")).isEqualTo(new Class<?>[] { Void.class });\r\n        assertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\r\n        allMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\r\n        assertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\r\n        allMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\");\r\n        assertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"\")));\r\n        assertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additional\")).isEqualTo(\"\");\r\n        assertThat(((String[]) metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"additionalArray\"))).isEmpty();\r\n    }\r\n    {\r\n        // perform tests with classValuesAsString = true\r\n        AnnotationAttributes specialAttrs = (AnnotationAttributes) metadata.getAnnotationAttributes(SpecialAttr.class.getName(), true);\r\n        assertThat(specialAttrs).hasSize(6);\r\n        assertThat(specialAttrs.get(\"clazz\")).isEqualTo(String.class.getName());\r\n        assertThat(specialAttrs.getString(\"clazz\")).isEqualTo(String.class.getName());\r\n        AnnotationAttributes nestedAnno = specialAttrs.getAnnotation(\"nestedAnno\");\r\n        assertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\r\n        assertThat(nestedAnno.getStringArray(\"classArray\")).isEqualTo(new String[] { String.class.getName() });\r\n        AnnotationAttributes[] nestedAnnoArray = specialAttrs.getAnnotationArray(\"nestedAnnoArray\");\r\n        assertThat((String[]) nestedAnnoArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\r\n        assertThat(nestedAnnoArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\r\n        assertThat((String[]) nestedAnnoArray[1].get(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\r\n        assertThat(nestedAnnoArray[1].getStringArray(\"classArray\")).isEqualTo(new String[] { Number.class.getName() });\r\n        AnnotationAttributes optional = specialAttrs.getAnnotation(\"optional\");\r\n        assertThat((String[]) optional.get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\r\n        assertThat(optional.getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\r\n        AnnotationAttributes[] optionalArray = specialAttrs.getAnnotationArray(\"optionalArray\");\r\n        assertThat((String[]) optionalArray[0].get(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\r\n        assertThat(optionalArray[0].getStringArray(\"classArray\")).isEqualTo(new String[] { Void.class.getName() });\r\n        assertThat(metadata.getAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\")).isEqualTo(\"direct\");\r\n        allMeta = metadata.getAllAnnotationAttributes(DirectAnnotation.class.getName()).get(\"value\");\r\n        assertThat(new HashSet<>(allMeta)).isEqualTo(new HashSet<>(Arrays.asList(\"direct\", \"meta\")));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationMetadataTests#doTestMethodAnnotationInfo(AnnotationMetadata)",
    "entityType": "method",
    "code": "private void doTestMethodAnnotationInfo(AnnotationMetadata classMetadata) {\r\n    assertThat(classMetadata.getDeclaredMethods()).hasSize(3);\r\n    Set<MethodMetadata> methods = classMetadata.getAnnotatedMethods(TestAutowired.class.getName());\r\n    assertThat(methods).hasSize(1);\r\n    for (MethodMetadata methodMetadata : methods) {\r\n        assertThat(methodMetadata.isAnnotated(TestAutowired.class.getName())).isTrue();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedComponent",
    "entityType": "class",
    "code": "public AnnotatedComponent() {\r\n}\n@TestAutowired\r\npublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) ;\npublic void doSleep() ;\n@DirectAnnotation(\"direct\")\r\n@MetaMetaAnnotation\r\npublic void meta() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedComponent#doWork(java.awt.Color)",
    "entityType": "method",
    "code": "@TestAutowired\r\npublic void doWork(@TestQualifier(\"myColor\") java.awt.Color color) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedComponent#doSleep()",
    "entityType": "method",
    "code": "public void doSleep() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedComponent#meta()",
    "entityType": "method",
    "code": "@DirectAnnotation(\"direct\")\r\n@MetaMetaAnnotation\r\npublic void meta() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedComponentSubClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.ComposedConfigurationWithAttributeOverridesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.MultipleComposedRepeatableAnnotationsClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.MultipleRepeatableAnnotationsInContainersClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.NamedAnnotationsClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.NamedComposedAnnotationClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.NamedComposedAnnotationExtended",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethods",
    "entityType": "class",
    "code": "private final ClassName className;\nprivate final Function<MethodName, String> methodNameGenerator;\nprivate final MethodName prefix;\nprivate final List<GeneratedMethod> generatedMethods;\n/**\r\n * Create a new {@link GeneratedMethods} using the specified method name\r\n * generator.\r\n * @param className the declaring class name\r\n * @param methodNameGenerator the method name generator\r\n */\r\nGeneratedMethods(ClassName className, Function<MethodName, String> methodNameGenerator) {\r\n    Assert.notNull(className, \"'className' must not be null\");\r\n    Assert.notNull(methodNameGenerator, \"'methodNameGenerator' must not be null\");\r\n    this.className = className;\r\n    this.methodNameGenerator = methodNameGenerator;\r\n    this.prefix = MethodName.NONE;\r\n    this.generatedMethods = new ArrayList<>();\r\n}\nprivate GeneratedMethods(ClassName className, Function<MethodName, String> methodNameGenerator, MethodName prefix, List<GeneratedMethod> generatedMethods) {\r\n    this.className = className;\r\n    this.methodNameGenerator = methodNameGenerator;\r\n    this.prefix = prefix;\r\n    this.generatedMethods = generatedMethods;\r\n}\n/**\r\n * Add a new {@link GeneratedMethod}.\r\n * <p>The {@code suggestedName} should provide the unqualified form of what\r\n * the method does. For instance, if the method returns an instance of a\r\n * given type, {@code getInstance} can be used as it is automatically\r\n * qualified using {@linkplain #withPrefix(String) the current prefix}.\r\n * <p>The prefix is applied a little differently for suggested names that\r\n * start with {@code get}, {@code set}, or {@code is}. Taking the previous\r\n * example with a {@code myBean} prefix, the actual method name is\r\n * {@code getMyBeanInstance}. Further processing of the method can happen\r\n * to ensure uniqueness within a class.\r\n * @param suggestedName the suggested name for the method\r\n * @param method a {@link Consumer} used to build method\r\n * @return the newly added {@link GeneratedMethod}\r\n */\r\npublic GeneratedMethod add(String suggestedName, Consumer<Builder> method) {\r\n    Assert.notNull(suggestedName, \"'suggestedName' must not be null\");\r\n    return add(new String[] { suggestedName }, method);\r\n}\n/**\r\n * Add a new {@link GeneratedMethod}.\r\n * <p>The {@code suggestedNameParts} should provide the unqualified form of\r\n * what the method does. For instance, if the method returns an instance of\r\n * a given type, {@code [\"get\", \"instance\"]} can be used as it is\r\n * automatically qualified using {@linkplain #withPrefix(String) the current\r\n * prefix}.\r\n * <p>The prefix is applied a little differently for suggested name parts\r\n * that start with {@code get}, {@code set}, or {@code is}. Taking the\r\n * previous example with a {@code myBean} prefix, the actual method name is\r\n * {@code getMyBeanInstance}. Further processing of the method can happen\r\n * to ensure uniqueness within a class.\r\n * @param suggestedNameParts the suggested name parts for the method\r\n * @param method a {@link Consumer} used to build method\r\n * @return the newly added {@link GeneratedMethod}\r\n */\r\npublic GeneratedMethod add(String[] suggestedNameParts, Consumer<Builder> method) {\r\n    Assert.notNull(suggestedNameParts, \"'suggestedNameParts' must not be null\");\r\n    Assert.notNull(method, \"'method' must not be null\");\r\n    String generatedName = this.methodNameGenerator.apply(this.prefix.and(suggestedNameParts));\r\n    GeneratedMethod generatedMethod = new GeneratedMethod(this.className, generatedName, method);\r\n    this.generatedMethods.add(generatedMethod);\r\n    return generatedMethod;\r\n}\n/**\r\n * Specify the prefix to use for method names. The prefix applies to\r\n * suggested method names, with special handling of {@code get}, {@code set},\r\n * and {@code is} prefixes in the suggested name itself.\r\n * @param prefix the prefix to add to suggested method names\r\n * @return a new instance with the specified prefix\r\n */\r\npublic GeneratedMethods withPrefix(String prefix) {\r\n    Assert.notNull(prefix, \"'prefix' must not be null\");\r\n    return new GeneratedMethods(this.className, this.methodNameGenerator, this.prefix.and(prefix), this.generatedMethods);\r\n}\n/**\r\n * Call the given action with each of the {@link MethodSpec MethodSpecs}\r\n * that have been added to this collection.\r\n * @param action the action to perform\r\n */\r\nvoid doWithMethodSpecs(Consumer<MethodSpec> action) {\r\n    stream().map(GeneratedMethod::getMethodSpec).forEach(action);\r\n}\nStream<GeneratedMethod> stream() {\r\n    return this.generatedMethods.stream();\r\n}",
    "comment": "\n * A managed collection of generated methods.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n * @see GeneratedMethod\n "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethods#add(String,Consumer<Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Add a new {@link GeneratedMethod}.\r\n * <p>The {@code suggestedName} should provide the unqualified form of what\r\n * the method does. For instance, if the method returns an instance of a\r\n * given type, {@code getInstance} can be used as it is automatically\r\n * qualified using {@linkplain #withPrefix(String) the current prefix}.\r\n * <p>The prefix is applied a little differently for suggested names that\r\n * start with {@code get}, {@code set}, or {@code is}. Taking the previous\r\n * example with a {@code myBean} prefix, the actual method name is\r\n * {@code getMyBeanInstance}. Further processing of the method can happen\r\n * to ensure uniqueness within a class.\r\n * @param suggestedName the suggested name for the method\r\n * @param method a {@link Consumer} used to build method\r\n * @return the newly added {@link GeneratedMethod}\r\n */\r\npublic GeneratedMethod add(String suggestedName, Consumer<Builder> method) {\r\n    Assert.notNull(suggestedName, \"'suggestedName' must not be null\");\r\n    return add(new String[] { suggestedName }, method);\r\n}",
    "comment": "\n\t * Add a new {@link GeneratedMethod}.\n\t * <p>The {@code suggestedName} should provide the unqualified form of what\n\t * the method does. For instance, if the method returns an instance of a\n\t * given type, {@code getInstance} can be used as it is automatically\n\t * qualified using {@linkplain #withPrefix(String) the current prefix}.\n\t * <p>The prefix is applied a little differently for suggested names that\n\t * start with {@code get}, {@code set}, or {@code is}. Taking the previous\n\t * example with a {@code myBean} prefix, the actual method name is\n\t * {@code getMyBeanInstance}. Further processing of the method can happen\n\t * to ensure uniqueness within a class.\n\t * @param suggestedName the suggested name for the method\n\t * @param method a {@link Consumer} used to build method\n\t * @return the newly added {@link GeneratedMethod}\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethods#add(String[],Consumer<Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Add a new {@link GeneratedMethod}.\r\n * <p>The {@code suggestedNameParts} should provide the unqualified form of\r\n * what the method does. For instance, if the method returns an instance of\r\n * a given type, {@code [\"get\", \"instance\"]} can be used as it is\r\n * automatically qualified using {@linkplain #withPrefix(String) the current\r\n * prefix}.\r\n * <p>The prefix is applied a little differently for suggested name parts\r\n * that start with {@code get}, {@code set}, or {@code is}. Taking the\r\n * previous example with a {@code myBean} prefix, the actual method name is\r\n * {@code getMyBeanInstance}. Further processing of the method can happen\r\n * to ensure uniqueness within a class.\r\n * @param suggestedNameParts the suggested name parts for the method\r\n * @param method a {@link Consumer} used to build method\r\n * @return the newly added {@link GeneratedMethod}\r\n */\r\npublic GeneratedMethod add(String[] suggestedNameParts, Consumer<Builder> method) {\r\n    Assert.notNull(suggestedNameParts, \"'suggestedNameParts' must not be null\");\r\n    Assert.notNull(method, \"'method' must not be null\");\r\n    String generatedName = this.methodNameGenerator.apply(this.prefix.and(suggestedNameParts));\r\n    GeneratedMethod generatedMethod = new GeneratedMethod(this.className, generatedName, method);\r\n    this.generatedMethods.add(generatedMethod);\r\n    return generatedMethod;\r\n}",
    "comment": "\n\t * Add a new {@link GeneratedMethod}.\n\t * <p>The {@code suggestedNameParts} should provide the unqualified form of\n\t * what the method does. For instance, if the method returns an instance of\n\t * a given type, {@code [\"get\", \"instance\"]} can be used as it is\n\t * automatically qualified using {@linkplain #withPrefix(String) the current\n\t * prefix}.\n\t * <p>The prefix is applied a little differently for suggested name parts\n\t * that start with {@code get}, {@code set}, or {@code is}. Taking the\n\t * previous example with a {@code myBean} prefix, the actual method name is\n\t * {@code getMyBeanInstance}. Further processing of the method can happen\n\t * to ensure uniqueness within a class.\n\t * @param suggestedNameParts the suggested name parts for the method\n\t * @param method a {@link Consumer} used to build method\n\t * @return the newly added {@link GeneratedMethod}\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethods#withPrefix(String)",
    "entityType": "method",
    "code": "/**\r\n * Specify the prefix to use for method names. The prefix applies to\r\n * suggested method names, with special handling of {@code get}, {@code set},\r\n * and {@code is} prefixes in the suggested name itself.\r\n * @param prefix the prefix to add to suggested method names\r\n * @return a new instance with the specified prefix\r\n */\r\npublic GeneratedMethods withPrefix(String prefix) {\r\n    Assert.notNull(prefix, \"'prefix' must not be null\");\r\n    return new GeneratedMethods(this.className, this.methodNameGenerator, this.prefix.and(prefix), this.generatedMethods);\r\n}",
    "comment": "\n\t * Specify the prefix to use for method names. The prefix applies to\n\t * suggested method names, with special handling of {@code get}, {@code set},\n\t * and {@code is} prefixes in the suggested name itself.\n\t * @param prefix the prefix to add to suggested method names\n\t * @return a new instance with the specified prefix\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethods#doWithMethodSpecs(Consumer<MethodSpec>)",
    "entityType": "method",
    "code": "/**\r\n * Call the given action with each of the {@link MethodSpec MethodSpecs}\r\n * that have been added to this collection.\r\n * @param action the action to perform\r\n */\r\nvoid doWithMethodSpecs(Consumer<MethodSpec> action) {\r\n    stream().map(GeneratedMethod::getMethodSpec).forEach(action);\r\n}",
    "comment": "\n\t * Call the given action with each of the {@link MethodSpec MethodSpecs}\n\t * that have been added to this collection.\n\t * @param action the action to perform\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedMethods#stream()",
    "entityType": "method",
    "code": "Stream<GeneratedMethod> stream() {\r\n    return this.generatedMethods.stream();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests",
    "entityType": "class",
    "code": "@Test\r\nvoid directAnnotationMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeComponent\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid inheritedAnnotationFromInterfaceDoesNotMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeClassWithSomeComponentInterface\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class);\r\n    // Must fail as annotation on interfaces should not be considered a match\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid inheritedAnnotationFromBaseClassDoesMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeSubclassOfSomeComponent\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid nonInheritedAnnotationDoesNotMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(NonInheritedAnnotation.class);\r\n    // Must fail as annotation isn't inherited\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid nonAnnotatedClassDoesntMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeNonCandidateClass\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(Component.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid matchesInterfacesIfConfigured() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeClassWithSomeComponentInterface\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class, false, true);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": "\n * @author Ramnivas Laddad\n * @author Juergen Hoeller\n * @author Oliver Gierke\n * @author Sam Brannen\n * @see AnnotationTypeFilterTestsTypes\n "
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests#directAnnotationMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid directAnnotationMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeComponent\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests#inheritedAnnotationFromInterfaceDoesNotMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid inheritedAnnotationFromInterfaceDoesNotMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeClassWithSomeComponentInterface\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class);\r\n    // Must fail as annotation on interfaces should not be considered a match\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests#inheritedAnnotationFromBaseClassDoesMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid inheritedAnnotationFromBaseClassDoesMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeSubclassOfSomeComponent\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests#nonInheritedAnnotationDoesNotMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid nonInheritedAnnotationDoesNotMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(NonInheritedAnnotation.class);\r\n    // Must fail as annotation isn't inherited\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests#nonAnnotatedClassDoesntMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid nonAnnotatedClassDoesntMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeNonCandidateClass\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(Component.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotationTypeFilterTests#matchesInterfacesIfConfigured()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchesInterfacesIfConfigured() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AnnotationTypeFilterTestsTypes$SomeClassWithSomeComponentInterface\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AnnotationTypeFilter filter = new AnnotationTypeFilter(InheritedAnnotation.class, false, true);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedTypeReference",
    "entityType": "class",
    "code": "private final ClassName className;\nprivate GeneratedTypeReference(ClassName className) {\r\n    super(className.packageName(), className.simpleName(), safeCreate(className.enclosingClassName()));\r\n    this.className = className;\r\n}\n@Nullable\r\nprivate static GeneratedTypeReference safeCreate(@Nullable ClassName className) {\r\n    return (className != null ? new GeneratedTypeReference(className) : null);\r\n}\npublic static GeneratedTypeReference of(ClassName className) {\r\n    Assert.notNull(className, \"ClassName must not be null\");\r\n    return new GeneratedTypeReference(className);\r\n}\n@Override\r\npublic String getCanonicalName() {\r\n    return this.className.canonicalName();\r\n}\n@Override\r\nprotected boolean isPrimitive() {\r\n    return this.className.isPrimitive();\r\n}",
    "comment": "\n * A {@link TypeReference} for a generated {@linkplain ClassName type}.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedTypeReference#safeCreate(ClassName)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static GeneratedTypeReference safeCreate(@Nullable ClassName className) {\r\n    return (className != null ? new GeneratedTypeReference(className) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedTypeReference#of(ClassName)",
    "entityType": "method",
    "code": "public static GeneratedTypeReference of(ClassName className) {\r\n    Assert.notNull(className, \"ClassName must not be null\");\r\n    return new GeneratedTypeReference(className);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedTypeReference#getCanonicalName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getCanonicalName() {\r\n    return this.className.canonicalName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GeneratedTypeReference#isPrimitive()",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean isPrimitive() {\r\n    return this.className.isPrimitive();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests",
    "entityType": "class",
    "code": "@Test\r\nvoid namePatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"example.type.AspectJTypeFilterTestsTypes.SomeClass\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"*..SomeClass\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"example..SomeClass\");\r\n}\n@Test\r\nvoid namePatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"example.type.AspectJTypeFilterTestsTypes.SomeClassX\");\r\n}\n@Test\r\nvoid subclassPatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"example.type.AspectJTypeFilterTestsTypes.SomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"*+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"java.lang.Object+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassImplementingSomeInterface\", \"*+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassImplementingSomeInterface\", \"java.lang.Object+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeClassExtendingSomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"*+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"java.lang.Object+\");\r\n}\n@Test\r\nvoid subclassPatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"java.lang.String+\");\r\n}\n@Test\r\nvoid annotationPatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.core.testfixture.stereotype.Component *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@* *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@*..* *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@*..*Component *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.core.testfixture.stereotype.Component *..*Component\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.core.testfixture.stereotype.Component *\");\r\n}\n@Test\r\nvoid annotationPatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.stereotype.Repository *..*\");\r\n}\n@Test\r\nvoid compositionPatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"!*..SomeOtherClass\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+ \" + \"&& example.type.AspectJTypeFilterTestsTypes.SomeClass+ \" + \"&& example.type.AspectJTypeFilterTestsTypes.SomeClassExtendingSomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+ \" + \"|| example.type.AspectJTypeFilterTestsTypes.SomeClass+ \" + \"|| example.type.AspectJTypeFilterTestsTypes.SomeClassExtendingSomeClass+\");\r\n}\n@Test\r\nvoid compositionPatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"*..Bogus && example.type.AspectJTypeFilterTestsTypes.SomeClass\");\r\n}\nprivate void assertMatch(String type, String typePattern) throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(type);\r\n    AspectJTypeFilter filter = new AspectJTypeFilter(typePattern, getClass().getClassLoader());\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(type);\r\n}\nprivate void assertNoMatch(String type, String typePattern) throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(type);\r\n    AspectJTypeFilter filter = new AspectJTypeFilter(typePattern, getClass().getClassLoader());\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(type);\r\n}",
    "comment": "\n * @author Ramnivas Laddad\n * @author Sam Brannen\n * @see AspectJTypeFilterTestsTypes\n "
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#namePatternMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid namePatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"example.type.AspectJTypeFilterTestsTypes.SomeClass\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"*..SomeClass\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"example..SomeClass\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#namePatternNoMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid namePatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"example.type.AspectJTypeFilterTestsTypes.SomeClassX\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#subclassPatternMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid subclassPatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"example.type.AspectJTypeFilterTestsTypes.SomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"*+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"java.lang.Object+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassImplementingSomeInterface\", \"*+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassImplementingSomeInterface\", \"java.lang.Object+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeClassExtendingSomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"*+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"java.lang.Object+\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#subclassPatternNoMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid subclassPatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClass\", \"java.lang.String+\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#annotationPatternMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid annotationPatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.core.testfixture.stereotype.Component *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@* *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@*..* *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@*..*Component *..*\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.core.testfixture.stereotype.Component *..*Component\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.core.testfixture.stereotype.Component *\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#annotationPatternNoMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid annotationPatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassAnnotatedWithComponent\", \"@org.springframework.stereotype.Repository *..*\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#compositionPatternMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid compositionPatternMatches() throws Exception {\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"!*..SomeOtherClass\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+ \" + \"&& example.type.AspectJTypeFilterTestsTypes.SomeClass+ \" + \"&& example.type.AspectJTypeFilterTestsTypes.SomeClassExtendingSomeClass+\");\r\n    assertMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface\", \"example.type.AspectJTypeFilterTestsTypes.SomeInterface+ \" + \"|| example.type.AspectJTypeFilterTestsTypes.SomeClass+ \" + \"|| example.type.AspectJTypeFilterTestsTypes.SomeClassExtendingSomeClass+\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#compositionPatternNoMatches()",
    "entityType": "method",
    "code": "@Test\r\nvoid compositionPatternNoMatches() throws Exception {\r\n    assertNoMatch(\"example.type.AspectJTypeFilterTestsTypes$SomeClass\", \"*..Bogus && example.type.AspectJTypeFilterTestsTypes.SomeClass\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#assertMatch(String,String)",
    "entityType": "method",
    "code": "private void assertMatch(String type, String typePattern) throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(type);\r\n    AspectJTypeFilter filter = new AspectJTypeFilter(typePattern, getClass().getClassLoader());\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AspectJTypeFilterTests#assertNoMatch(String,String)",
    "entityType": "method",
    "code": "private void assertNoMatch(String type, String typePattern) throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(type);\r\n    AspectJTypeFilter filter = new AspectJTypeFilter(typePattern, getClass().getClassLoader());\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    ClassloadingAssertions.assertClassNotLoaded(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.GenerationContext",
    "entityType": "class",
    "code": "/**\r\n * Get the {@link GeneratedClasses} used by the context.\r\n * <p>All generated classes are written at the end of AOT processing.\r\n * @return the generated classes\r\n */\r\nGeneratedClasses getGeneratedClasses();\n/**\r\n * Get the {@link GeneratedFiles} used by the context.\r\n * <p>Used to write resource, java source, or class bytecode files.\r\n * @return the generated files\r\n */\r\nGeneratedFiles getGeneratedFiles();\n/**\r\n * Get the {@link RuntimeHints} used by the context.\r\n * <p>Used to record {@linkplain ReflectionHints reflection},\r\n * {@linkplain ResourceHints resource}, {@linkplain SerializationHints\r\n * serialization}, and {@linkplain ProxyHints proxy} hints so that the\r\n * application can run as a native image.\r\n * @return the runtime hints\r\n */\r\nRuntimeHints getRuntimeHints();\n/**\r\n * Create a new {@link GenerationContext} instance using the specified\r\n * name to qualify generated assets for a dedicated round of code\r\n * generation.\r\n * <p>If the specified name is already in use, a unique sequence is added\r\n * to ensure the name is unique.\r\n * @param name the name to use\r\n * @return a specialized {@link GenerationContext} for the specified name\r\n */\r\nGenerationContext withName(String name);",
    "comment": "\n * Central interface used for code generation.\n *\n * <p>A generation context provides:\n * <ul>\n * <li>Management of all {@linkplain #getGeneratedClasses() generated classes},\n * including naming convention support.</li>\n * <li>Central management of all {@linkplain #getGeneratedFiles() generated files}.</li>\n * <li>Support for recording {@linkplain #getRuntimeHints() runtime hints}.</li>\n * </ul>\n *\n * <p>If a dedicated round of code generation is required while processing, it\n * is possible to create a specialized context using {@link #withName(String)}.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.GenerationContext#getGeneratedClasses()",
    "entityType": "method",
    "code": "/**\r\n * Get the {@link GeneratedClasses} used by the context.\r\n * <p>All generated classes are written at the end of AOT processing.\r\n * @return the generated classes\r\n */\r\nGeneratedClasses getGeneratedClasses();",
    "comment": "\n\t * Get the {@link GeneratedClasses} used by the context.\n\t * <p>All generated classes are written at the end of AOT processing.\n\t * @return the generated classes\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GenerationContext#getGeneratedFiles()",
    "entityType": "method",
    "code": "/**\r\n * Get the {@link GeneratedFiles} used by the context.\r\n * <p>Used to write resource, java source, or class bytecode files.\r\n * @return the generated files\r\n */\r\nGeneratedFiles getGeneratedFiles();",
    "comment": "\n\t * Get the {@link GeneratedFiles} used by the context.\n\t * <p>Used to write resource, java source, or class bytecode files.\n\t * @return the generated files\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GenerationContext#getRuntimeHints()",
    "entityType": "method",
    "code": "/**\r\n * Get the {@link RuntimeHints} used by the context.\r\n * <p>Used to record {@linkplain ReflectionHints reflection},\r\n * {@linkplain ResourceHints resource}, {@linkplain SerializationHints\r\n * serialization}, and {@linkplain ProxyHints proxy} hints so that the\r\n * application can run as a native image.\r\n * @return the runtime hints\r\n */\r\nRuntimeHints getRuntimeHints();",
    "comment": "\n\t * Get the {@link RuntimeHints} used by the context.\n\t * <p>Used to record {@linkplain ReflectionHints reflection},\n\t * {@linkplain ResourceHints resource}, {@linkplain SerializationHints\n\t * serialization}, and {@linkplain ProxyHints proxy} hints so that the\n\t * application can run as a native image.\n\t * @return the runtime hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.GenerationContext#withName(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link GenerationContext} instance using the specified\r\n * name to qualify generated assets for a dedicated round of code\r\n * generation.\r\n * <p>If the specified name is already in use, a unique sequence is added\r\n * to ensure the name is unique.\r\n * @param name the name to use\r\n * @return a specialized {@link GenerationContext} for the specified name\r\n */\r\nGenerationContext withName(String name);",
    "comment": "\n\t * Create a new {@link GenerationContext} instance using the specified\n\t * name to qualify generated assets for a dedicated round of code\n\t * generation.\n\t * <p>If the specified name is already in use, a unique sequence is added\n\t * to ensure the name is unique.\n\t * @param name the name to use\n\t * @return a specialized {@link GenerationContext} for the specified name\n\t "
  },
  {
    "entityId": "org.springframework.core.type.AssignableTypeFilterTests",
    "entityType": "class",
    "code": "@Test\r\nvoid directMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$TestNonInheritingClass\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter matchingFilter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.TestNonInheritingClass.class);\r\n    AssignableTypeFilter notMatchingFilter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.TestInterface.class);\r\n    assertThat(notMatchingFilter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    assertThat(matchingFilter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n}\n@Test\r\nvoid interfaceMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$TestInterfaceImpl\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter filter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.TestInterface.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid superClassMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$SomeDaoLikeImpl\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter filter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.SimpleJdbcDaoSupport.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}\n@Test\r\nvoid interfaceThroughSuperClassMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$SomeDaoLikeImpl\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter filter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.JdbcDaoSupport.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": "\n * @author Ramnivas Laddad\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.core.type.AssignableTypeFilterTests#directMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid directMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$TestNonInheritingClass\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter matchingFilter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.TestNonInheritingClass.class);\r\n    AssignableTypeFilter notMatchingFilter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.TestInterface.class);\r\n    assertThat(notMatchingFilter.match(metadataReader, metadataReaderFactory)).isFalse();\r\n    assertThat(matchingFilter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AssignableTypeFilterTests#interfaceMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid interfaceMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$TestInterfaceImpl\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter filter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.TestInterface.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AssignableTypeFilterTests#superClassMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid superClassMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$SomeDaoLikeImpl\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter filter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.SimpleJdbcDaoSupport.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AssignableTypeFilterTests#interfaceThroughSuperClassMatch()",
    "entityType": "method",
    "code": "@Test\r\nvoid interfaceThroughSuperClassMatch() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    String classUnderTest = \"example.type.AssignableTypeFilterTestsTypes$SomeDaoLikeImpl\";\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(classUnderTest);\r\n    AssignableTypeFilter filter = new AssignableTypeFilter(example.type.AssignableTypeFilterTestsTypes.JdbcDaoSupport.class);\r\n    assertThat(filter.match(metadataReader, metadataReaderFactory)).isTrue();\r\n    ClassloadingAssertions.assertClassNotLoaded(classUnderTest);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryGeneratedFiles",
    "entityType": "class",
    "code": "private final Map<Kind, Map<String, InputStreamSource>> files = new HashMap<>();\n@Override\r\npublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\r\n    Map<String, InputStreamSource> paths = this.files.computeIfAbsent(kind, key -> new LinkedHashMap<>());\r\n    handler.accept(new InMemoryFileHandler(paths, path));\r\n}\n/**\r\n * Return a {@link Map} of the generated files of a specific {@link Kind}.\r\n * @param kind the kind of generated file\r\n * @return a {@link Map} of paths to {@link InputStreamSource} instances\r\n */\r\npublic Map<String, InputStreamSource> getGeneratedFiles(Kind kind) {\r\n    Assert.notNull(kind, \"'kind' must not be null\");\r\n    return Collections.unmodifiableMap(this.files.getOrDefault(kind, Collections.emptyMap()));\r\n}\n/**\r\n * Return the content of the specified file.\r\n * @param kind the kind of generated file\r\n * @param path the path of the file\r\n * @return the file content or {@code null} if no file could be found\r\n * @throws IOException on read error\r\n */\r\n@Nullable\r\npublic String getGeneratedFileContent(Kind kind, String path) throws IOException {\r\n    InputStreamSource source = getGeneratedFile(kind, path);\r\n    if (source != null) {\r\n        return new String(source.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Return the {@link InputStreamSource} of specified file.\r\n * @param kind the kind of generated file\r\n * @param path the path of the file\r\n * @return the file source or {@code null} if no file could be found\r\n */\r\n@Nullable\r\npublic InputStreamSource getGeneratedFile(Kind kind, String path) {\r\n    Assert.notNull(kind, \"'kind' must not be null\");\r\n    Assert.hasLength(path, \"'path' must not be empty\");\r\n    Map<String, InputStreamSource> paths = this.files.get(kind);\r\n    return (paths != null ? paths.get(path) : null);\r\n}\nprivate static class InMemoryFileHandler extends FileHandler {\r\n\r\n    private final Map<String, InputStreamSource> paths;\r\n\r\n    private final String key;\r\n\r\n    InMemoryFileHandler(Map<String, InputStreamSource> paths, String key) {\r\n        super(paths.containsKey(key), () -> paths.get(key));\r\n        this.paths = paths;\r\n        this.key = key;\r\n    }\r\n\r\n    @Override\r\n    protected void copy(InputStreamSource content, boolean override) {\r\n        this.paths.put(this.key, content);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return this.key;\r\n    }\r\n}",
    "comment": "\n * {@link GeneratedFiles} implementation that keeps generated files in-memory.\n *\n * @author Phillip Webb\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
    "entityType": "method",
    "code": "@Override\r\npublic void handleFile(Kind kind, String path, ThrowingConsumer<FileHandler> handler) {\r\n    Map<String, InputStreamSource> paths = this.files.computeIfAbsent(kind, key -> new LinkedHashMap<>());\r\n    handler.accept(new InMemoryFileHandler(paths, path));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryGeneratedFiles#getGeneratedFiles(Kind)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Map} of the generated files of a specific {@link Kind}.\r\n * @param kind the kind of generated file\r\n * @return a {@link Map} of paths to {@link InputStreamSource} instances\r\n */\r\npublic Map<String, InputStreamSource> getGeneratedFiles(Kind kind) {\r\n    Assert.notNull(kind, \"'kind' must not be null\");\r\n    return Collections.unmodifiableMap(this.files.getOrDefault(kind, Collections.emptyMap()));\r\n}",
    "comment": "\n\t * Return a {@link Map} of the generated files of a specific {@link Kind}.\n\t * @param kind the kind of generated file\n\t * @return a {@link Map} of paths to {@link InputStreamSource} instances\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryGeneratedFiles#getGeneratedFileContent(Kind,String)",
    "entityType": "method",
    "code": "/**\r\n * Return the content of the specified file.\r\n * @param kind the kind of generated file\r\n * @param path the path of the file\r\n * @return the file content or {@code null} if no file could be found\r\n * @throws IOException on read error\r\n */\r\n@Nullable\r\npublic String getGeneratedFileContent(Kind kind, String path) throws IOException {\r\n    InputStreamSource source = getGeneratedFile(kind, path);\r\n    if (source != null) {\r\n        return new String(source.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Return the content of the specified file.\n\t * @param kind the kind of generated file\n\t * @param path the path of the file\n\t * @return the file content or {@code null} if no file could be found\n\t * @throws IOException on read error\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryGeneratedFiles#getGeneratedFile(Kind,String)",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link InputStreamSource} of specified file.\r\n * @param kind the kind of generated file\r\n * @param path the path of the file\r\n * @return the file source or {@code null} if no file could be found\r\n */\r\n@Nullable\r\npublic InputStreamSource getGeneratedFile(Kind kind, String path) {\r\n    Assert.notNull(kind, \"'kind' must not be null\");\r\n    Assert.hasLength(path, \"'path' must not be empty\");\r\n    Map<String, InputStreamSource> paths = this.files.get(kind);\r\n    return (paths != null ? paths.get(path) : null);\r\n}",
    "comment": "\n\t * Return the {@link InputStreamSource} of specified file.\n\t * @param kind the kind of generated file\n\t * @param path the path of the file\n\t * @return the file source or {@code null} if no file could be found\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryFileHandler",
    "entityType": "class",
    "code": "private final Map<String, InputStreamSource> paths;\nprivate final String key;\nInMemoryFileHandler(Map<String, InputStreamSource> paths, String key) {\r\n    super(paths.containsKey(key), () -> paths.get(key));\r\n    this.paths = paths;\r\n    this.key = key;\r\n}\n@Override\r\nprotected void copy(InputStreamSource content, boolean override) {\r\n    this.paths.put(this.key, content);\r\n}\n@Override\r\npublic String toString() {\r\n    return this.key;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryFileHandler#copy(InputStreamSource,boolean)",
    "entityType": "method",
    "code": "@Override\r\nprotected void copy(InputStreamSource content, boolean override) {\r\n    this.paths.put(this.key, content);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.InMemoryFileHandler#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.key;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.CachingMetadataReaderLeakTests",
    "entityType": "class",
    "code": "private static final int ITEMS_TO_LOAD = 9999;\nprivate final MetadataReaderFactory mrf = new CachingMetadataReaderFactory();\n@Test\r\nvoid significantLoad() throws Exception {\r\n    // the biggest public class in the JDK (>60k)\r\n    URL url = getClass().getResource(\"/java/awt/Component.class\");\r\n    assertThat(url).isNotNull();\r\n    // look at a LOT of items\r\n    for (int i = 0; i < ITEMS_TO_LOAD; i++) {\r\n        Resource resource = new UrlResource(url) {\r\n\r\n            @Override\r\n            public boolean equals(@Nullable Object obj) {\r\n                return (obj == this);\r\n            }\r\n\r\n            @Override\r\n            public int hashCode() {\r\n                return System.identityHashCode(this);\r\n            }\r\n        };\r\n        MetadataReader reader = mrf.getMetadataReader(resource);\r\n        assertThat(reader).isNotNull();\r\n    }\r\n    // useful for profiling to take snapshots\r\n    // System.in.read();\r\n}",
    "comment": "\n * Tests for checking the behaviour of {@link CachingMetadataReaderFactory} under\n * load. If the cache is not controlled, this test should fail with an out of memory\n * exception around entry 5k.\n *\n * @author Costin Leau\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.type.CachingMetadataReaderLeakTests#significantLoad()",
    "entityType": "method",
    "code": "@Test\r\nvoid significantLoad() throws Exception {\r\n    // the biggest public class in the JDK (>60k)\r\n    URL url = getClass().getResource(\"/java/awt/Component.class\");\r\n    assertThat(url).isNotNull();\r\n    // look at a LOT of items\r\n    for (int i = 0; i < ITEMS_TO_LOAD; i++) {\r\n        Resource resource = new UrlResource(url) {\r\n\r\n            @Override\r\n            public boolean equals(@Nullable Object obj) {\r\n                return (obj == this);\r\n            }\r\n\r\n            @Override\r\n            public int hashCode() {\r\n                return System.identityHashCode(this);\r\n            }\r\n        };\r\n        MetadataReader reader = mrf.getMetadataReader(resource);\r\n        assertThat(reader).isNotNull();\r\n    }\r\n    // useful for profiling to take snapshots\r\n    // System.in.read();\r\n}",
    "comment": ""
  }
]