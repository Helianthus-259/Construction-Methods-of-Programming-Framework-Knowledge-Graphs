[
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveArrayClassType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveArrayClassType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"arrayClassType\"));\r\n    assertThat(type.resolve()).isEqualTo(List[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveGenericArrayType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveGenericArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    assertThat(type.resolve()).isEqualTo(List[].class);\r\n    assertThat(type.getComponentType().resolve()).isEqualTo(List.class);\r\n    assertThat(type.getComponentType().getGeneric().resolve()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveGenericMultiArrayType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveGenericMultiArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericMultiArrayType\"));\r\n    assertThat(type.resolve()).isEqualTo(List[][][].class);\r\n    assertThat(type.getComponentType().resolve()).isEqualTo(List[][].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveGenericArrayFromGeneric()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveGenericArrayFromGeneric() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringArrayList\"));\r\n    ResolvableType generic = type.asCollection().getGeneric();\r\n    assertThat(generic.getType().toString()).isEqualTo(\"E\");\r\n    assertThat(generic.isArray()).isTrue();\r\n    assertThat(generic.resolve()).isEqualTo(String[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableGenericArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableGenericArray() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"), TypedFields.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T[]\");\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.resolve()).isEqualTo(String[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableGenericArrayUnknown()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableGenericArrayUnknown() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"));\r\n    assertThat(type.getType().toString()).isEqualTo(\"T[]\");\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.resolve()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableGenericArrayUnknownWithFallback()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableGenericArrayUnknownWithFallback() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"));\r\n    assertThat(type.getType().toString()).isEqualTo(\"T[]\");\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.toClass()).isEqualTo(Object.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveWildcardTypeUpperBounds()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveWildcardTypeUpperBounds() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(Number.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveWildcardLowerBounds()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveWildcardLowerBounds() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardSuperType\"));\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(Number.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableFromFieldType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableFromFieldType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableFromFieldTypeUnknown()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableFromFieldTypeUnknown() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableFromInheritedField()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableFromInheritedField() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMap\")).as(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric(1, 0).resolve()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableFromInheritedFieldSwitched()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableFromInheritedFieldSwitched() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMapSwitched\")).as(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric(1, 0).resolve()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#doesResolveFromOuterOwner()",
    "entityType": "method",
    "code": "@Test\r\nvoid doesResolveFromOuterOwner() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"listOfListOfUnknown\")).as(Collection.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric(0).as(Collection.class).getGeneric(0).as(Collection.class).resolve()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#intArrayNotAssignableToIntegerArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid intArrayNotAssignableToIntegerArray() throws Exception {\r\n    ResolvableType integerArray = ResolvableType.forField(Fields.class.getField(\"integerArray\"));\r\n    ResolvableType intArray = ResolvableType.forField(Fields.class.getField(\"intArray\"));\r\n    assertThat(integerArray.isAssignableFrom(intArray)).isFalse();\r\n    assertThat(intArray.isAssignableFrom(integerArray)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveBoundedTypeVariableResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveBoundedTypeVariableResult() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"boundedTypeVariableResult\"));\r\n    assertThat(type.resolve()).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveBoundedTypeVariableWildcardResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveBoundedTypeVariableWildcardResult() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"boundedTypeVariableWildcardResult\"));\r\n    assertThat(type.getGeneric(1).asCollection().resolveGeneric()).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveVariableNotFound()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveVariableNotFound() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"typedReturn\"));\r\n    assertThat(type.resolve()).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromSimpleInterfaceType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromSimpleInterfaceType() {\r\n    ResolvableType type = ResolvableType.forClass(MySimpleInterfaceType.class).as(MyInterfaceType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromSimpleCollectionInterfaceType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromSimpleCollectionInterfaceType() {\r\n    ResolvableType type = ResolvableType.forClass(MyCollectionInterfaceType.class).as(MyInterfaceType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromSimpleSuperclassType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromSimpleSuperclassType() {\r\n    ResolvableType type = ResolvableType.forClass(MySimpleSuperclassType.class).as(MySuperclassType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromSimpleCollectionSuperclassType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromSimpleCollectionSuperclassType() {\r\n    ResolvableType type = ResolvableType.forClass(MyCollectionSuperclassType.class).as(MySuperclassType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromFieldTypeWithImplementsClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromFieldTypeWithImplementsClass() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"), TypedFields.class);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromFieldTypeWithImplementsType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromFieldTypeWithImplementsType() throws Exception {\r\n    ResolvableType implementationType = ResolvableType.forClassWithGenerics(Fields.class, Integer.class);\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"), implementationType);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromSuperType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.resolve()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.asCollection().resolveGeneric()).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromClassWithImplementsClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromClassWithImplementsClass() {\r\n    ResolvableType type = ResolvableType.forClass(MySuperclassType.class, MyCollectionSuperclassType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromConstructorParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromConstructorParameter() throws Exception {\r\n    Constructor<?> constructor = Constructors.class.getConstructor(List.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.resolveGeneric(0)).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveUnknownTypeVariableFromConstructorParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveUnknownTypeVariableFromConstructorParameter() throws Exception {\r\n    Constructor<?> constructor = Constructors.class.getConstructor(Map.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.resolveGeneric(0)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromConstructorParameterWithImplementsClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromConstructorParameterWithImplementsClass() throws Exception {\r\n    Constructor<?> constructor = Constructors.class.getConstructor(Map.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0, TypedConstructors.class);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.resolveGeneric(0)).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromMethodParameter() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(method, 0);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodParameterWithImplementsClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromMethodParameterWithImplementsClass() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(method, 0, TypedMethods.class);\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodParameterType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromMethodParameterType() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodParameterTypeWithImplementsClass()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid resolveTypeVariableFromMethodParameterTypeWithImplementsClass() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    methodParameter.setContainingClass(TypedMethods.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodParameterTypeWithImplementsType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromMethodParameterTypeWithImplementsType() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    ResolvableType implementationType = ResolvableType.forClassWithGenerics(Methods.class, Integer.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter, implementationType);\r\n    assertThat(type.resolve()).isEqualTo(Integer.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodReturn()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromMethodReturn() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedReturn\");\r\n    ResolvableType type = ResolvableType.forMethodReturnType(method);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromMethodReturnWithImplementsClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromMethodReturnWithImplementsClass() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedReturn\");\r\n    ResolvableType type = ResolvableType.forMethodReturnType(method, TypedMethods.class);\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromType() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\r\n    ResolvableType type = ResolvableType.forType(sourceType);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromTypeWithVariableResolver()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromTypeWithVariableResolver() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\r\n    ResolvableType type = ResolvableType.forType(sourceType, ResolvableType.forClass(TypedMethods.class).as(Methods.class).asVariableResolver());\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeWithCustomVariableResolver()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeWithCustomVariableResolver() throws Exception {\r\n    VariableResolver variableResolver = mock();\r\n    given(variableResolver.getSource()).willReturn(this);\r\n    ResolvableType longType = ResolvableType.forClass(Long.class);\r\n    given(variableResolver.resolveVariable(any())).willReturn(longType);\r\n    ResolvableType variable = ResolvableType.forType(Fields.class.getField(\"typeVariableType\").getGenericType(), variableResolver);\r\n    ResolvableType parameterized = ResolvableType.forType(Fields.class.getField(\"parameterizedType\").getGenericType(), variableResolver);\r\n    assertThat(variable.resolve()).isEqualTo(Long.class);\r\n    assertThat(parameterized.resolve()).isEqualTo(List.class);\r\n    assertThat(parameterized.resolveGeneric()).isEqualTo(Long.class);\r\n    verify(variableResolver, atLeastOnce()).resolveVariable(this.typeVariableCaptor.capture());\r\n    assertThat(this.typeVariableCaptor.getValue().getName()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromReflectiveParameterizedTypeReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromReflectiveParameterizedTypeReference() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\r\n    ResolvableType type = ResolvableType.forType(ParameterizedTypeReference.forType(sourceType));\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveTypeVariableFromDeclaredParameterizedTypeReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveTypeVariableFromDeclaredParameterizedTypeReference() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"charSequenceReturn\").getGenericReturnType();\r\n    ResolvableType reflectiveType = ResolvableType.forType(sourceType);\r\n    ResolvableType declaredType = ResolvableType.forType(new ParameterizedTypeReference<List<CharSequence>>() ;);\r\n    assertThat(declaredType).isEqualTo(reflectiveType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#toStrings()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStrings() throws Exception {\r\n    assertThat(ResolvableType.NONE.toString()).isEqualTo(\"?\");\r\n    assertThat(forField(\"classType\")).hasToString(\"java.util.List<?>\");\r\n    assertThat(forField(\"typeVariableType\")).hasToString(\"?\");\r\n    assertThat(forField(\"parameterizedType\")).hasToString(\"java.util.List<?>\");\r\n    assertThat(forField(\"arrayClassType\")).hasToString(\"java.util.List<?>[]\");\r\n    assertThat(forField(\"genericArrayType\")).hasToString(\"java.util.List<java.lang.String>[]\");\r\n    assertThat(forField(\"genericMultiArrayType\")).hasToString(\"java.util.List<java.lang.String>[][][]\");\r\n    assertThat(forField(\"wildcardType\")).hasToString(\"java.util.List<java.lang.Number>\");\r\n    assertThat(forField(\"wildcardSuperType\")).hasToString(\"java.util.List<java.lang.Number>\");\r\n    assertThat(forField(\"charSequenceList\")).hasToString(\"java.util.List<java.lang.CharSequence>\");\r\n    assertThat(forField(\"stringList\")).hasToString(\"java.util.List<java.lang.String>\");\r\n    assertThat(forField(\"stringListList\")).hasToString(\"java.util.List<java.util.List<java.lang.String>>\");\r\n    assertThat(forField(\"stringArrayList\")).hasToString(\"java.util.List<java.lang.String[]>\");\r\n    assertThat(forField(\"stringIntegerMultiValueMap\")).hasToString(\"org.springframework.util.MultiValueMap<java.lang.String, java.lang.Integer>\");\r\n    assertThat(forField(\"stringIntegerMultiValueMapSwitched\")).hasToString(VariableNameSwitch.class.getName() + \"<java.lang.Integer, java.lang.String>\");\r\n    assertThat(forField(\"listOfListOfUnknown\")).hasToString(\"java.util.List<java.util.List<?>>\");\r\n    assertThat(forTypedField(\"typeVariableType\")).hasToString(\"java.lang.String\");\r\n    assertThat(forTypedField(\"parameterizedType\")).hasToString(\"java.util.List<java.lang.String>\");\r\n    assertThat(ResolvableType.forClass(ListOfGenericArray.class).toString()).isEqualTo(ListOfGenericArray.class.getName());\r\n    assertThat(ResolvableType.forClass(List.class, ListOfGenericArray.class).toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>[]>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getSource()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSource() throws Exception {\r\n    Class<?> classType = MySimpleInterfaceType.class;\r\n    Field basicField = Fields.class.getField(\"classType\");\r\n    Field field = Fields.class.getField(\"charSequenceList\");\r\n    Method method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    assertThat(ResolvableType.forField(basicField).getSource()).isEqualTo(basicField);\r\n    assertThat(ResolvableType.forField(field).getSource()).isEqualTo(field);\r\n    assertThat(ResolvableType.forMethodParameter(methodParameter).getSource()).isEqualTo(methodParameter);\r\n    assertThat(ResolvableType.forMethodParameter(method, 0).getSource()).isEqualTo(methodParameter);\r\n    assertThat(ResolvableType.forClass(classType).getSource()).isEqualTo(classType);\r\n    assertThat(ResolvableType.forClass(classType).getSuperType().getSource()).isEqualTo(classType.getGenericSuperclass());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveFromOuterClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveFromOuterClass() throws Exception {\r\n    Field field = EnclosedInParameterizedType.InnerTyped.class.getField(\"field\");\r\n    ResolvableType type = ResolvableType.forField(field, TypedEnclosedInParameterizedType.TypedInnerTyped.class);\r\n    assertThat(type.resolve()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveFromClassWithGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveFromClassWithGenerics() {\r\n    ResolvableType type = ResolvableType.forClassWithGenerics(List.class, ResolvableType.forClassWithGenerics(List.class, String.class));\r\n    assertThat(type.asCollection().toString()).isEqualTo(\"java.util.Collection<java.util.List<java.lang.String>>\");\r\n    assertThat(type.asCollection().getGeneric().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n    assertThat(type.asCollection().getGeneric().asCollection().toString()).isEqualTo(\"java.util.Collection<java.lang.String>\");\r\n    assertThat(type.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>>\");\r\n    assertThat(type.asCollection().getGeneric().getGeneric().resolve()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromMustNotBeNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forClass(Object.class).isAssignableFrom((ResolvableType) null)).withMessage(\"ResolvableType must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForNone()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForNone() {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    assertThat(objectType.isAssignableFrom(ResolvableType.NONE)).isFalse();\r\n    assertThat(ResolvableType.NONE.isAssignableFrom(objectType)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForClassAndClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForClassAndClass() {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    ResolvableType charSequenceType = ResolvableType.forClass(CharSequence.class);\r\n    ResolvableType stringType = ResolvableType.forClass(String.class);\r\n    assertThatResolvableType(objectType).isAssignableFrom(objectType, charSequenceType, stringType);\r\n    assertThatResolvableType(charSequenceType).isAssignableFrom(charSequenceType, stringType).isNotAssignableFrom(objectType);\r\n    assertThatResolvableType(stringType).isAssignableFrom(stringType).isNotAssignableFrom(objectType, charSequenceType);\r\n    assertThat(objectType.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(objectType.isAssignableFrom(StringBuilder.class)).isTrue();\r\n    assertThat(charSequenceType.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(charSequenceType.isAssignableFrom(StringBuilder.class)).isTrue();\r\n    assertThat(stringType.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(stringType.isAssignableFrom(StringBuilder.class)).isFalse();\r\n    assertThat(objectType.isInstance(\"a String\")).isTrue();\r\n    assertThat(objectType.isInstance(new StringBuilder(\"a StringBuilder\"))).isTrue();\r\n    assertThat(charSequenceType.isInstance(\"a String\")).isTrue();\r\n    assertThat(charSequenceType.isInstance(new StringBuilder(\"a StringBuilder\"))).isTrue();\r\n    assertThat(stringType.isInstance(\"a String\")).isTrue();\r\n    assertThat(stringType.isInstance(new StringBuilder(\"a StringBuilder\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromCannotBeResolved()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromCannotBeResolved() throws Exception {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    ResolvableType unresolvableVariable1 = ResolvableType.forField(AssignmentBase.class.getField(\"o\"));\r\n    ResolvableType unresolvableVariable2 = ResolvableType.forField(AssignmentBase.class.getField(\"c\"));\r\n    ResolvableType unresolvableVariable3 = ResolvableType.forField(AssignmentBase.class.getField(\"s\"));\r\n    assertThat(unresolvableVariable1.resolve()).isNull();\r\n    assertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable1);\r\n    assertThatResolvableType(unresolvableVariable1).isAssignableFrom(objectType);\r\n    assertThat(unresolvableVariable2.resolve()).isNull();\r\n    assertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable2);\r\n    assertThatResolvableType(unresolvableVariable2).isAssignableFrom(objectType);\r\n    assertThat(unresolvableVariable3.resolve()).isEqualTo(Serializable.class);\r\n    assertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable3);\r\n    assertThatResolvableType(unresolvableVariable3).isNotAssignableFrom(objectType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForClassAndSimpleVariable()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForClassAndSimpleVariable() throws Exception {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    ResolvableType charSequenceType = ResolvableType.forClass(CharSequence.class);\r\n    ResolvableType stringType = ResolvableType.forClass(String.class);\r\n    ResolvableType objectVariable = ResolvableType.forField(AssignmentBase.class.getField(\"o\"), Assignment.class);\r\n    ResolvableType charSequenceVariable = ResolvableType.forField(AssignmentBase.class.getField(\"c\"), Assignment.class);\r\n    ResolvableType stringVariable = ResolvableType.forField(AssignmentBase.class.getField(\"s\"), Assignment.class);\r\n    assertThatResolvableType(objectType).isAssignableFrom(objectVariable, charSequenceVariable, stringVariable);\r\n    assertThatResolvableType(charSequenceType).isAssignableFrom(charSequenceVariable, stringVariable).isNotAssignableFrom(objectVariable);\r\n    assertThatResolvableType(stringType).isAssignableFrom(stringVariable).isNotAssignableFrom(objectVariable, charSequenceVariable);\r\n    assertThatResolvableType(objectVariable).isAssignableFrom(objectType, charSequenceType, stringType);\r\n    assertThatResolvableType(charSequenceVariable).isAssignableFrom(charSequenceType, stringType).isNotAssignableFrom(objectType);\r\n    assertThatResolvableType(stringVariable).isAssignableFrom(stringType).isNotAssignableFrom(objectType, charSequenceType);\r\n    assertThatResolvableType(objectVariable).isAssignableFrom(objectVariable, charSequenceVariable, stringVariable);\r\n    assertThatResolvableType(charSequenceVariable).isAssignableFrom(charSequenceVariable, stringVariable).isNotAssignableFrom(objectVariable);\r\n    assertThatResolvableType(stringVariable).isAssignableFrom(stringVariable).isNotAssignableFrom(objectVariable, charSequenceVariable);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForSameClassNonExtendsGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForSameClassNonExtendsGenerics() throws Exception {\r\n    ResolvableType objectList = ResolvableType.forField(AssignmentBase.class.getField(\"listo\"), Assignment.class);\r\n    ResolvableType stringList = ResolvableType.forField(AssignmentBase.class.getField(\"lists\"), Assignment.class);\r\n    assertThatResolvableType(stringList).isNotAssignableFrom(objectList);\r\n    assertThatResolvableType(objectList).isNotAssignableFrom(stringList);\r\n    assertThatResolvableType(stringList).isAssignableFrom(stringList);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForSameClassExtendsGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForSameClassExtendsGenerics() throws Exception {\r\n    // Generic assignment can be a little confusing, given:\r\n    //\r\n    // List<CharSequence> c1, List<? extends CharSequence> c2, List<String> s;\r\n    //\r\n    // c2 = s; is allowed and is often used for argument input, for example\r\n    // see List.addAll(). You can get items from c2 but you cannot add items without\r\n    // getting a generic type 'is not applicable for the arguments' error. This makes\r\n    // sense since if you added a StringBuffer to c2 it would break the rules on s.\r\n    //\r\n    // c1 = s; not allowed. Since there is no '? extends' to cause the generic\r\n    // 'is not applicable for the arguments' error when adding (which would pollute\r\n    // s).\r\n    ResolvableType objectList = ResolvableType.forField(AssignmentBase.class.getField(\"listo\"), Assignment.class);\r\n    ResolvableType charSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listc\"), Assignment.class);\r\n    ResolvableType stringList = ResolvableType.forField(AssignmentBase.class.getField(\"lists\"), Assignment.class);\r\n    ResolvableType extendsObjectList = ResolvableType.forField(AssignmentBase.class.getField(\"listxo\"), Assignment.class);\r\n    ResolvableType extendsCharSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class);\r\n    ResolvableType extendsStringList = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class);\r\n    assertThatResolvableType(objectList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(charSequenceList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(stringList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(extendsObjectList).isAssignableFrom(objectList, charSequenceList, stringList);\r\n    assertThatResolvableType(extendsObjectList).isAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(extendsCharSequenceList).isAssignableFrom(extendsCharSequenceList, extendsStringList).isNotAssignableFrom(extendsObjectList);\r\n    assertThatResolvableType(extendsCharSequenceList).isAssignableFrom(charSequenceList, stringList).isNotAssignableFrom(objectList);\r\n    assertThatResolvableType(extendsStringList).isAssignableFrom(extendsStringList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList);\r\n    assertThatResolvableType(extendsStringList).isAssignableFrom(stringList).isNotAssignableFrom(objectList, charSequenceList);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForDifferentClassesWithGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForDifferentClassesWithGenerics() throws Exception {\r\n    ResolvableType extendsCharSequenceCollection = ResolvableType.forField(AssignmentBase.class.getField(\"collectionxc\"), Assignment.class);\r\n    ResolvableType charSequenceCollection = ResolvableType.forField(AssignmentBase.class.getField(\"collectionc\"), Assignment.class);\r\n    ResolvableType charSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listc\"), Assignment.class);\r\n    ResolvableType extendsCharSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class);\r\n    ResolvableType extendsStringList = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class);\r\n    assertThatResolvableType(extendsCharSequenceCollection).isAssignableFrom(charSequenceCollection, charSequenceList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(charSequenceCollection).isAssignableFrom(charSequenceList).isNotAssignableFrom(extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(charSequenceList).isNotAssignableFrom(extendsCharSequenceCollection, charSequenceCollection);\r\n    assertThatResolvableType(extendsCharSequenceList).isNotAssignableFrom(extendsCharSequenceCollection, charSequenceCollection);\r\n    assertThatResolvableType(extendsStringList).isNotAssignableFrom(charSequenceCollection, charSequenceList, extendsCharSequenceList);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForArrays()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForArrays() throws Exception {\r\n    ResolvableType object = ResolvableType.forField(AssignmentBase.class.getField(\"o\"), Assignment.class);\r\n    ResolvableType objectArray = ResolvableType.forField(AssignmentBase.class.getField(\"oarray\"), Assignment.class);\r\n    ResolvableType charSequenceArray = ResolvableType.forField(AssignmentBase.class.getField(\"carray\"), Assignment.class);\r\n    ResolvableType stringArray = ResolvableType.forField(AssignmentBase.class.getField(\"sarray\"), Assignment.class);\r\n    assertThatResolvableType(object).isAssignableFrom(objectArray, charSequenceArray, stringArray);\r\n    assertThatResolvableType(objectArray).isAssignableFrom(objectArray, charSequenceArray, stringArray).isNotAssignableFrom(object);\r\n    assertThatResolvableType(charSequenceArray).isAssignableFrom(charSequenceArray, stringArray).isNotAssignableFrom(object, objectArray);\r\n    assertThatResolvableType(stringArray).isAssignableFrom(stringArray).isNotAssignableFrom(object, objectArray, charSequenceArray);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForWildcards()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForWildcards() throws Exception {\r\n    ResolvableType object = ResolvableType.forClass(Object.class);\r\n    ResolvableType charSequence = ResolvableType.forClass(CharSequence.class);\r\n    ResolvableType string = ResolvableType.forClass(String.class);\r\n    ResolvableType extendsAnon = ResolvableType.forField(AssignmentBase.class.getField(\"listAnon\"), Assignment.class).getGeneric();\r\n    ResolvableType extendsObject = ResolvableType.forField(AssignmentBase.class.getField(\"listxo\"), Assignment.class).getGeneric();\r\n    ResolvableType extendsCharSequence = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class).getGeneric();\r\n    ResolvableType extendsString = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class).getGeneric();\r\n    ResolvableType superObject = ResolvableType.forField(AssignmentBase.class.getField(\"listso\"), Assignment.class).getGeneric();\r\n    ResolvableType superCharSequence = ResolvableType.forField(AssignmentBase.class.getField(\"listsc\"), Assignment.class).getGeneric();\r\n    ResolvableType superString = ResolvableType.forField(AssignmentBase.class.getField(\"listss\"), Assignment.class).getGeneric();\r\n    // Language Spec 4.5.1. Type Arguments and Wildcards\r\n    // ? extends T <= ? extends S if T <: S\r\n    assertThatResolvableType(extendsCharSequence).isAssignableFrom(extendsCharSequence, extendsString).isNotAssignableFrom(extendsObject);\r\n    assertThatResolvableType(extendsCharSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\r\n    // ? super T <= ? super S if S <: T\r\n    assertThatResolvableType(superCharSequence).isAssignableFrom(superObject, superCharSequence).isNotAssignableFrom(superString);\r\n    assertThatResolvableType(superCharSequence).isAssignableFrom(object, charSequence).isNotAssignableFrom(string);\r\n    // [Implied] super / extends cannot be mixed\r\n    assertThatResolvableType(superCharSequence).isNotAssignableFrom(extendsObject, extendsCharSequence, extendsString);\r\n    assertThatResolvableType(extendsCharSequence).isNotAssignableFrom(superObject, superCharSequence, superString);\r\n    // T <= T\r\n    assertThatResolvableType(charSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\r\n    // T <= ? extends T\r\n    assertThatResolvableType(extendsCharSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\r\n    assertThatResolvableType(charSequence).isAssignableFrom(extendsCharSequence, extendsString).isNotAssignableFrom(extendsObject);\r\n    assertThatResolvableType(extendsAnon).isAssignableFrom(object, charSequence, string);\r\n    // T <= ? super T\r\n    assertThatResolvableType(superCharSequence).isAssignableFrom(object, charSequence).isNotAssignableFrom(string);\r\n    assertThatResolvableType(charSequence).isNotAssignableFrom(superObject, superCharSequence, superString);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForComplexWildcards()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForComplexWildcards() throws Exception {\r\n    ResolvableType complex1 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard1\"));\r\n    ResolvableType complex2 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard2\"));\r\n    ResolvableType complex3 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard3\"));\r\n    ResolvableType complex4 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard4\"));\r\n    assertThatResolvableType(complex1).isAssignableFrom(complex2);\r\n    assertThatResolvableType(complex2).isNotAssignableFrom(complex1);\r\n    assertThatResolvableType(complex3).isAssignableFrom(complex4);\r\n    assertThatResolvableType(complex4).isNotAssignableFrom(complex3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForUnresolvedWildcard()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForUnresolvedWildcard() {\r\n    ResolvableType wildcard = ResolvableType.forInstance(new Wildcard<>());\r\n    ResolvableType wildcardFixed = ResolvableType.forInstance(new WildcardFixed());\r\n    ResolvableType wildcardConcrete = ResolvableType.forClassWithGenerics(Wildcard.class, CharSequence.class);\r\n    ResolvableType wildcardConsumer = ResolvableType.forInstance(new WildcardConsumer<>());\r\n    assertThat(wildcard.isAssignableFrom(wildcardFixed)).isTrue();\r\n    assertThat(wildcard.isAssignableFromResolvedPart(wildcardFixed)).isTrue();\r\n    assertThat(wildcard.isAssignableFrom(wildcardConcrete)).isTrue();\r\n    assertThat(wildcard.isAssignableFromResolvedPart(wildcardConcrete)).isTrue();\r\n    assertThat(wildcardFixed.isAssignableFrom(wildcard)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFromResolvedPart(wildcard)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFrom(wildcardConcrete)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFromResolvedPart(wildcardConcrete)).isFalse();\r\n    assertThat(wildcardConcrete.isAssignableFrom(wildcard)).isTrue();\r\n    assertThat(wildcardConcrete.isAssignableFromResolvedPart(wildcard)).isTrue();\r\n    assertThat(wildcardConcrete.isAssignableFrom(wildcardFixed)).isFalse();\r\n    assertThat(wildcardConcrete.isAssignableFromResolvedPart(wildcardFixed)).isFalse();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFrom(wildcard)).isFalse();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFromResolvedPart(wildcard)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#isAssignableFromForUnresolvedDoubleWildcard()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAssignableFromForUnresolvedDoubleWildcard() {\r\n    ResolvableType wildcard = ResolvableType.forInstance(new DoubleWildcard<>());\r\n    ResolvableType wildcardFixed = ResolvableType.forInstance(new DoubleWildcardFixed());\r\n    ResolvableType wildcardConsumer = ResolvableType.forInstance(new DoubleWildcardConsumer<>());\r\n    assertThat(wildcard.isAssignableFrom(wildcardFixed)).isTrue();\r\n    assertThat(wildcard.isAssignableFromResolvedPart(wildcardFixed)).isTrue();\r\n    assertThat(wildcardFixed.isAssignableFrom(wildcard)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFromResolvedPart(wildcard)).isFalse();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFrom(wildcard)).isTrue();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFromResolvedPart(wildcard)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#strictGenericsMatching()",
    "entityType": "method",
    "code": "@Test\r\nvoid strictGenericsMatching() {\r\n    ResolvableType consumerUnresolved = ResolvableType.forClass(Consumer.class);\r\n    ResolvableType consumerObject = ResolvableType.forClassWithGenerics(Consumer.class, Object.class);\r\n    ResolvableType consumerNestedUnresolved = ResolvableType.forClassWithGenerics(Consumer.class, ResolvableType.forClass(Consumer.class));\r\n    ResolvableType consumerNumber = ResolvableType.forClassWithGenerics(Consumer.class, Number.class);\r\n    ResolvableType consumerExtendsNumber = ResolvableType.forClass(SubConsumer.class);\r\n    assertThat(consumerUnresolved.isAssignableFrom(consumerObject)).isTrue();\r\n    assertThat(consumerUnresolved.isAssignableFromResolvedPart(consumerObject)).isTrue();\r\n    assertThat(consumerObject.isAssignableFrom(consumerUnresolved)).isTrue();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerUnresolved)).isTrue();\r\n    assertThat(consumerUnresolved.isAssignableFrom(consumerNestedUnresolved)).isTrue();\r\n    assertThat(consumerUnresolved.isAssignableFromResolvedPart(consumerNestedUnresolved)).isTrue();\r\n    assertThat(consumerObject.isAssignableFrom(consumerNestedUnresolved)).isFalse();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerNestedUnresolved)).isFalse();\r\n    assertThat(consumerObject.isAssignableFrom(consumerNumber)).isFalse();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerNumber)).isFalse();\r\n    assertThat(consumerObject.isAssignableFrom(consumerExtendsNumber)).isFalse();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerExtendsNumber)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#identifyTypeVariable()",
    "entityType": "method",
    "code": "@Test\r\nvoid identifyTypeVariable() throws Exception {\r\n    Method method = ClassArguments.class.getMethod(\"typedArgumentFirst\", Class.class, Class.class, Class.class);\r\n    ResolvableType returnType = ResolvableType.forMethodReturnType(method, ClassArguments.class);\r\n    ResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, ClassArguments.class);\r\n    ResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, ClassArguments.class);\r\n    ResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, ClassArguments.class);\r\n    assertThat(returnType.getType().equals(arg0.as(Class.class).getGeneric(0).getType())).isTrue();\r\n    assertThat(returnType.getType().equals(arg1.as(Class.class).getGeneric(0).getType())).isFalse();\r\n    assertThat(returnType.getType().equals(arg2.as(Class.class).getGeneric(0).getType())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hashCodeAndEquals()",
    "entityType": "method",
    "code": "@Test\r\nvoid hashCodeAndEquals() throws Exception {\r\n    ResolvableType forClass = ResolvableType.forClass(List.class);\r\n    ResolvableType forFieldDirect = ResolvableType.forField(Fields.class.getDeclaredField(\"stringList\"));\r\n    ResolvableType forFieldViaType = ResolvableType.forType(Fields.class.getDeclaredField(\"stringList\").getGenericType(), (VariableResolver) null);\r\n    ResolvableType forFieldWithImplementation = ResolvableType.forField(Fields.class.getDeclaredField(\"stringList\"), TypedFields.class);\r\n    assertThat(forClass).isEqualTo(forClass);\r\n    assertThat(forClass.hashCode()).isEqualTo(forClass.hashCode());\r\n    assertThat(forClass).isNotEqualTo(forFieldDirect);\r\n    assertThat(forClass).isNotEqualTo(forFieldWithImplementation);\r\n    assertThat(forFieldDirect).isEqualTo(forFieldDirect);\r\n    assertThat(forFieldDirect).isNotEqualTo(forFieldViaType);\r\n    assertThat(forFieldDirect).isNotEqualTo(forFieldWithImplementation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#javaDocSample()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaDocSample() throws Exception {\r\n    ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\"myMap\"));\r\n    assertThat(t.toString()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getType().getTypeName()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getType().toString()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getSuperType().toString()).isEqualTo(\"java.util.AbstractMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.asMap().toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getGeneric(0).resolve()).isEqualTo(Integer.class);\r\n    assertThat(t.getGeneric(1).resolve()).isEqualTo(List.class);\r\n    assertThat(t.getGeneric(1).toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n    assertThat(t.resolveGeneric(1, 0)).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forClassWithGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid forClassWithGenerics() {\r\n    ResolvableType elementType = ResolvableType.forClassWithGenerics(Map.class, Integer.class, String.class);\r\n    ResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\r\n    assertThat(listType.toString()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\r\n    assertThat(listType.getType().getTypeName()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\r\n    assertThat(listType.getType().toString()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#classWithGenericsAs()",
    "entityType": "method",
    "code": "@Test\r\nvoid classWithGenericsAs() {\r\n    ResolvableType type = ResolvableType.forClassWithGenerics(MultiValueMap.class, Integer.class, String.class);\r\n    assertThat(type.asMap().toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forClassWithMismatchedGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid forClassWithMismatchedGenerics() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forClassWithGenerics(Map.class, Integer.class)).withMessageContaining(\"Mismatched number of generics specified for\").withMessageContaining(\"java.util.Map<K,V>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forArrayComponent()",
    "entityType": "method",
    "code": "@Test\r\nvoid forArrayComponent() throws Exception {\r\n    ResolvableType elementType = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    ResolvableType type = ResolvableType.forArrayComponent(elementType);\r\n    assertThat(type.toString()).isEqualTo(\"java.util.List<java.lang.String>[]\");\r\n    assertThat(type.resolve()).isEqualTo(List[].class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#serialize()",
    "entityType": "method",
    "code": "@Test\r\nvoid serialize() throws Exception {\r\n    testSerialization(ResolvableType.forClass(List.class));\r\n    testSerialization(ResolvableType.forField(Fields.class.getField(\"charSequenceList\")));\r\n    testSerialization(ResolvableType.forMethodParameter(Methods.class.getMethod(\"charSequenceParameter\", List.class), 0));\r\n    testSerialization(ResolvableType.forMethodReturnType(Methods.class.getMethod(\"charSequenceReturn\")));\r\n    testSerialization(ResolvableType.forConstructorParameter(Constructors.class.getConstructor(List.class), 0));\r\n    testSerialization(ResolvableType.forField(Fields.class.getField(\"charSequenceList\")).getGeneric());\r\n    ResolvableType deserializedNone = testSerialization(ResolvableType.NONE);\r\n    assertThat(deserializedNone).isSameAs(ResolvableType.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#canResolveVoid()",
    "entityType": "method",
    "code": "@Test\r\nvoid canResolveVoid() {\r\n    ResolvableType type = ResolvableType.forClass(void.class);\r\n    assertThat(type.resolve()).isEqualTo(void.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#narrow()",
    "entityType": "method",
    "code": "@Test\r\nvoid narrow() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    ResolvableType narrow = ResolvableType.forType(ArrayList.class, type);\r\n    assertThat(narrow.getGeneric().resolve()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasResolvableGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasResolvableGenerics() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.hasResolvableGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasResolvableGenericsWithSingleBoundedWildcard()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasResolvableGenericsWithSingleBoundedWildcard() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\r\n    assertThat(type.hasResolvableGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasResolvableGenericsWithSingleParameterizedType()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasResolvableGenericsWithSingleParameterizedType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.hasResolvableGenerics()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasResolvableGenericsWithSingleWildcard()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasResolvableGenericsWithSingleWildcard() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"anyListElement\"));\r\n    assertThat(type.hasResolvableGenerics()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenerics() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsBasedOnOwnGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsBasedOnOwnGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(List.class);\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsWhenSelfNotResolvable()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsWhenSelfNotResolvable() {\r\n    ResolvableType type = ResolvableType.forClass(List.class).getGeneric();\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsWhenImplementingRawInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsWhenImplementingRawInterface() {\r\n    ResolvableType type = ResolvableType.forClass(MySimpleInterfaceTypeWithImplementsRaw.class);\r\n    for (ResolvableType generic : type.getGenerics()) {\r\n        assertThat(generic.resolve()).isNotNull();\r\n    }\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsWhenExtends()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsWhenExtends() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsMySimpleInterfaceTypeWithImplementsRaw.class);\r\n    for (ResolvableType generic : type.getGenerics()) {\r\n        assertThat(generic.resolve()).isNotNull();\r\n    }\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsWhenNested()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsWhenNested() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(ListOfListSupplier.class.getMethod(\"get\"));\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsWhenSelfReferring()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsWhenSelfReferring() {\r\n    ResolvableType type = ResolvableType.forInstance(new Bar());\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasUnresolvableGenericsWithEnum()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasUnresolvableGenericsWithEnum() {\r\n    ResolvableType type = ResolvableType.forType(SimpleEnum.class.getGenericSuperclass());\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#recursiveType()",
    "entityType": "method",
    "code": "// gh-33932\r\n@Test\r\nvoid recursiveType() {\r\n    assertThat(ResolvableType.forClass(RecursiveMap.class)).isEqualTo(ResolvableType.forClass(RecursiveMap.class));\r\n    ResolvableType resolvableType1 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMap.class);\r\n    ResolvableType resolvableType2 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMap.class);\r\n    assertThat(resolvableType1).isEqualTo(resolvableType2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#recursiveTypeWithInterface()",
    "entityType": "method",
    "code": "// gh-33932\r\n@Test\r\nvoid recursiveTypeWithInterface() {\r\n    assertThat(ResolvableType.forClass(RecursiveMapWithInterface.class)).isEqualTo(ResolvableType.forClass(RecursiveMapWithInterface.class));\r\n    ResolvableType resolvableType1 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMapWithInterface.class);\r\n    ResolvableType resolvableType2 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMapWithInterface.class);\r\n    assertThat(resolvableType1).isEqualTo(resolvableType2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#spr11219()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr11219() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(BaseProvider.class.getField(\"stuff\"), BaseProvider.class);\r\n    assertThat(type.getNested(2).isAssignableFrom(ResolvableType.forClass(BaseImplementation.class))).isTrue();\r\n    assertThat(type.toString()).isEqualTo(\"java.util.Collection<org.springframework.core.ResolvableTypeTests$IBase<?>>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#spr12701()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr12701() {\r\n    ResolvableType resolvableType = ResolvableType.forClassWithGenerics(Callable.class, String.class);\r\n    Type type = resolvableType.getType();\r\n    assertThat(type).isInstanceOf(ParameterizedType.class);\r\n    assertThat(((ParameterizedType) type).getRawType()).isEqualTo(Callable.class);\r\n    assertThat(((ParameterizedType) type).getActualTypeArguments()).hasSize(1);\r\n    assertThat(((ParameterizedType) type).getActualTypeArguments()[0]).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#spr14648()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr14648() throws Exception {\r\n    ResolvableType collectionClass = ResolvableType.forRawClass(Collection.class);\r\n    ResolvableType setClass = ResolvableType.forRawClass(Set.class);\r\n    ResolvableType fromReturnType = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"wildcardSet\"));\r\n    assertThat(collectionClass.isAssignableFrom(fromReturnType)).isTrue();\r\n    assertThat(setClass.isAssignableFrom(fromReturnType)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#spr16456()",
    "entityType": "method",
    "code": "@Test\r\nvoid spr16456() throws Exception {\r\n    ResolvableType genericType = ResolvableType.forField(UnresolvedWithGenerics.class.getDeclaredField(\"set\")).asCollection();\r\n    ResolvableType type = ResolvableType.forClassWithGenerics(ArrayList.class, genericType.getGeneric());\r\n    assertThat(type.resolveGeneric()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#gh22902()",
    "entityType": "method",
    "code": "@Test\r\nvoid gh22902() throws Exception {\r\n    ResolvableType ab = ResolvableType.forField(ABClient.class.getField(\"field\"));\r\n    assertThat(ab.isAssignableFrom(Object.class)).isFalse();\r\n    assertThat(ab.isAssignableFrom(AwithB.class)).isTrue();\r\n    assertThat(ab.isAssignableFrom(AwithoutB.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#gh32327()",
    "entityType": "method",
    "code": "@Test\r\nvoid gh32327() throws Exception {\r\n    ResolvableType repository1 = ResolvableType.forField(Fields.class.getField(\"repository\"));\r\n    ResolvableType repository2 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"someRepository\"));\r\n    ResolvableType repository3 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"subRepository\"));\r\n    assertThat(repository1.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(repository1.isAssignableFrom(repository2)).isFalse();\r\n    assertThat(repository1.isAssignableFromResolvedPart(repository2)).isTrue();\r\n    assertThat(repository1.isAssignableFrom(repository3)).isTrue();\r\n    assertThat(repository1.isAssignableFromResolvedPart(repository3)).isTrue();\r\n    assertThat(repository2.hasUnresolvableGenerics()).isTrue();\r\n    assertThat(repository2.isAssignableFrom(repository1)).isTrue();\r\n    assertThat(repository2.isAssignableFromResolvedPart(repository1)).isTrue();\r\n    assertThat(repository3.hasUnresolvableGenerics()).isTrue();\r\n    assertThat(repository3.isAssignableFrom(repository1)).isFalse();\r\n    assertThat(repository3.isAssignableFromResolvedPart(repository1)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#gh33535()",
    "entityType": "method",
    "code": "@Test\r\nvoid gh33535() throws Exception {\r\n    ResolvableType repository1 = ResolvableType.forField(Fields.class.getField(\"stringRepository\"));\r\n    ResolvableType repository2 = ResolvableType.forField(Fields.class.getField(\"arrayRepository\"));\r\n    ResolvableType repository3 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"someRepository\"));\r\n    assertThat(repository1.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(repository1.isAssignableFrom(repository3)).isFalse();\r\n    assertThat(repository1.isAssignableFromResolvedPart(repository3)).isTrue();\r\n    assertThat(repository3.isAssignableFrom(repository1)).isTrue();\r\n    assertThat(repository3.isAssignableFromResolvedPart(repository1)).isTrue();\r\n    assertThat(repository2.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(repository2.isAssignableFrom(repository3)).isFalse();\r\n    assertThat(repository2.isAssignableFromResolvedPart(repository3)).isTrue();\r\n    assertThat(repository3.isAssignableFrom(repository2)).isTrue();\r\n    assertThat(repository3.isAssignableFromResolvedPart(repository2)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#testSerialization(ResolvableType)",
    "entityType": "method",
    "code": "private ResolvableType testSerialization(ResolvableType type) throws Exception {\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    ObjectOutputStream oos = new ObjectOutputStream(bos);\r\n    oos.writeObject(type);\r\n    oos.close();\r\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\r\n    ResolvableType read = (ResolvableType) ois.readObject();\r\n    assertThat(read).isEqualTo(type);\r\n    assertThat(read.getType()).isEqualTo(type.getType());\r\n    assertThat(read.resolve()).isEqualTo(type.resolve());\r\n    return read;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forField(String)",
    "entityType": "method",
    "code": "private ResolvableType forField(String field) throws NoSuchFieldException {\r\n    return ResolvableType.forField(Fields.class.getField(field));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forTypedField(String)",
    "entityType": "method",
    "code": "private ResolvableType forTypedField(String field) throws NoSuchFieldException {\r\n    return ResolvableType.forField(Fields.class.getField(field), TypedFields.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#assertThatResolvableType(ResolvableType)",
    "entityType": "method",
    "code": "private static ResolvableTypeAssert assertThatResolvableType(ResolvableType type) {\r\n    return new ResolvableTypeAssert(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendsList",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendsMap",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SomeRepository",
    "entityType": "class",
    "code": "<T> T someMethod(Class<T> arg0, Class<?> arg1, Class<Object> arg2);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SomeRepository#someMethod(Class<T>,Class<?>,Class<Object>)",
    "entityType": "method",
    "code": "<T> T someMethod(Class<T> arg0, Class<?> arg1, Class<Object> arg2);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SubRepository",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Fields",
    "entityType": "class",
    "code": "public List classType;\npublic T typeVariableType;\npublic List<T> parameterizedType;\npublic List[] arrayClassType;\npublic List<String>[] genericArrayType;\npublic List<String>[][][] genericMultiArrayType;\npublic List<?> anyListElement;\npublic List<? extends Number> wildcardType;\npublic List<? super Number> wildcardSuperType = new ArrayList<Object>();\npublic List<CharSequence> charSequenceList;\npublic List<String> stringList;\npublic List<List<String>> stringListList;\npublic List<String[]> stringArrayList;\npublic MultiValueMap<String, Integer> stringIntegerMultiValueMap;\npublic VariableNameSwitch<Integer, String> stringIntegerMultiValueMapSwitched;\npublic List<List> listOfListOfUnknown;\n@SuppressWarnings(\"unused\")\r\nprivate List<String> privateField;\n@SuppressWarnings(\"unused\")\r\nprivate List<String> otherPrivateField;\npublic Map<Map<String, Integer>, Map<Byte, Long>> nested;\npublic T[] variableTypeGenericArray;\npublic Integer[] integerArray;\npublic int[] intArray;\npublic SomeRepository<? extends Serializable> repository;\npublic SomeRepository<String> stringRepository;\npublic SomeRepository<String[]> arrayRepository;",
    "comment": ""
  }
]