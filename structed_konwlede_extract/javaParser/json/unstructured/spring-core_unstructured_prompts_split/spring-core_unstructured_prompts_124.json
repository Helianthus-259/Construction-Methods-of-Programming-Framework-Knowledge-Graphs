[
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#createNamedProxy(String,T)",
    "entityType": "method",
    "code": "/**\r\n * Similar to {@link #createProxy(Object)} but adds an additional argument before\r\n * the argument of type {@code T}. Note that they may potentially be of the same\r\n * time when invoked!\r\n */\r\npublic static <T> T createNamedProxy(String name, T object) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Similar to {@link #createProxy(Object)} but adds an additional argument before\n\t\t * the argument of type {@code T}. Note that they may potentially be of the same\n\t\t * time when invoked!\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#createMock(Class<MOCK>)",
    "entityType": "method",
    "code": "/**\r\n * Simulates factory methods found in libraries such as Mockito and EasyMock.\r\n */\r\npublic static <MOCK> MOCK createMock(Class<MOCK> toMock) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Simulates factory methods found in libraries such as Mockito and EasyMock.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#createNamedMock(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Similar to {@link #createMock(Class)} but adds an additional method argument\r\n * before the parameterized argument.\r\n */\r\npublic static <T> T createNamedMock(String name, Class<T> toMock) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Similar to {@link #createMock(Class)} but adds an additional method argument\n\t\t * before the parameterized argument.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#createVMock(V,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Similar to {@link #createNamedMock(String, Class)} but adds an additional\r\n * parameterized type.\r\n */\r\npublic static <V extends Object, T> T createVMock(V name, Class<T> toMock) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Similar to {@link #createNamedMock(String, Class)} but adds an additional\n\t\t * parameterized type.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#extractValueFrom(MyInterfaceType<T>)",
    "entityType": "method",
    "code": "/**\r\n * Extract some value of the type supported by the interface (i.e., by a concrete,\r\n * non-generic implementation of the interface).\r\n */\r\npublic static <T> T extractValueFrom(MyInterfaceType<T> myInterfaceType) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Extract some value of the type supported by the interface (i.e., by a concrete,\n\t\t * non-generic implementation of the interface).\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#extractMagicValue(Map<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Extract some magic value from the supplied map.\r\n */\r\npublic static <K, V> V extractMagicValue(Map<K, V> map) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Extract some magic value from the supplied map.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#readIntegerInputMessage(MyInterfaceType<Integer>)",
    "entityType": "method",
    "code": "public void readIntegerInputMessage(MyInterfaceType<Integer> message) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#readIntegerArrayInputMessage(MyInterfaceType<Integer>[])",
    "entityType": "method",
    "code": "public void readIntegerArrayInputMessage(MyInterfaceType<Integer>[] message) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MyTypeWithMethods#readGenericArrayInputMessage(T[])",
    "entityType": "method",
    "code": "public void readGenericArrayInputMessage(T[] message) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MySimpleTypeWithMethods",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.GenericClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.A",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.B",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.C",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.D",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.E",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TestIfc",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TestImpl",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BiGenericClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SpecializedBiGenericClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypeFixedBiGenericClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TopLevelClass",
    "entityType": "class",
    "code": "class Nested<X> {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Nested",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypedTopLevelClass",
    "entityType": "class",
    "code": "class TypedNested extends Nested<Long> {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.TypedNested",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithArrayBase",
    "entityType": "class",
    "code": "public abstract T[] array(T... args);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithArrayBase#array(T)",
    "entityType": "method",
    "code": "public abstract T[] array(T... args);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithArray",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Repository",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.IdFixingRepository",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithMethodParameter",
    "entityType": "class",
    "code": "public void nestedGenerics(List<Map<String, Integer>> input) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithMethodParameter#nestedGenerics(List<Map<String,Integer>>)",
    "entityType": "method",
    "code": "public void nestedGenerics(List<Map<String, Integer>> input) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ListOfListSupplier",
    "entityType": "class",
    "code": "List<List<T>> get();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ListOfListSupplier#get()",
    "entityType": "method",
    "code": "List<List<T>> get();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.StringListOfListSupplier",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithElementBounds",
    "entityType": "class",
    "code": "<T extends A> List<T> get() {\r\n    return List.of();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithElementBounds#get()",
    "entityType": "method",
    "code": "<T extends A> List<T> get() {\r\n    return List.of();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithUnresolvableElement",
    "entityType": "class",
    "code": "List<T> get() {\r\n    return List.of();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.WithUnresolvableElement#get()",
    "entityType": "method",
    "code": "List<T> get() {\r\n    return List.of();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests",
    "entityType": "class",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid byteCountsAndPositions(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(0);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(2);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'a');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(1);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'b');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(2);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.read();\r\n    assertThat(buffer.readPosition()).isEqualTo(1);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.read();\r\n    assertThat(buffer.readPosition()).isEqualTo(2);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readPositionSmallerThanZero(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(-1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readPositionGreaterThanWritePosition(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writePositionSmallerThanReadPosition(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    try {\r\n        buffer.write((byte) 'a');\r\n        buffer.read();\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.writePosition(0));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writePositionGreaterThanCapacity(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.writePosition(2));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeAndRead(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(5);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    int ch = buffer.read();\r\n    assertThat(ch).isEqualTo((byte) 'a');\r\n    buffer.write((byte) 'd');\r\n    buffer.write((byte) 'e');\r\n    byte[] result = new byte[4];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'b', 'c', 'd', 'e' });\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeNullString(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.write(null, StandardCharsets.UTF_8));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeNullCharset(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.write(\"test\", null));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeEmptyString(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    buffer.write(\"\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeUtf8String(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(6);\r\n    buffer.write(\"Spring\", StandardCharsets.UTF_8);\r\n    byte[] result = new byte[6];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"Spring\".getBytes(StandardCharsets.UTF_8));\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeUtf8StringOutGrowsCapacity(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(5);\r\n    buffer.write(\"Spring €\", StandardCharsets.UTF_8);\r\n    byte[] result = new byte[10];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"Spring €\".getBytes(StandardCharsets.UTF_8));\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeIsoString(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(\"\\u00A3\", StandardCharsets.ISO_8859_1);\r\n    byte[] result = new byte[1];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"\\u00A3\".getBytes(StandardCharsets.ISO_8859_1));\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeMultipleUtf8String(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    buffer.write(\"abc\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(3);\r\n    buffer.write(\"def\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(6);\r\n    buffer.write(\"ghi\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(9);\r\n    byte[] result = new byte[9];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"abcdefghi\".getBytes());\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid toStringNullCharset(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.toString(null));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid toStringUtf8(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    String spring = \"Spring\";\r\n    byte[] bytes = spring.getBytes(StandardCharsets.UTF_8);\r\n    DataBuffer buffer = createDataBuffer(bytes.length);\r\n    buffer.write(bytes);\r\n    String result = buffer.toString(StandardCharsets.UTF_8);\r\n    assertThat(result).isEqualTo(spring);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid toStringSection(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    String spring = \"Spring\";\r\n    byte[] bytes = spring.getBytes(StandardCharsets.UTF_8);\r\n    DataBuffer buffer = createDataBuffer(bytes.length);\r\n    buffer.write(bytes);\r\n    String result = buffer.toString(1, 3, StandardCharsets.UTF_8);\r\n    assertThat(result).isEqualTo(\"pri\");\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStream(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c', 'd', 'e' });\r\n    buffer.readPosition(1);\r\n    InputStream inputStream = buffer.asInputStream();\r\n    assertThat(inputStream.available()).isEqualTo(4);\r\n    int result = inputStream.read();\r\n    assertThat(result).isEqualTo((byte) 'b');\r\n    assertThat(inputStream.available()).isEqualTo(3);\r\n    assertThat(inputStream.markSupported()).isTrue();\r\n    inputStream.mark(2);\r\n    byte[] bytes = new byte[2];\r\n    int len = inputStream.read(bytes);\r\n    assertThat(len).isEqualTo(2);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'c', 'd' });\r\n    assertThat(inputStream.available()).isEqualTo(1);\r\n    Arrays.fill(bytes, (byte) 0);\r\n    len = inputStream.read(bytes);\r\n    assertThat(len).isEqualTo(1);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'e', (byte) 0 });\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n    assertThat(inputStream.read()).isEqualTo(-1);\r\n    assertThat(inputStream.read(bytes)).isEqualTo(-1);\r\n    inputStream.reset();\r\n    bytes = new byte[3];\r\n    len = inputStream.read(bytes);\r\n    assertThat(len).isEqualTo(3);\r\n    assertThat(bytes).containsExactly('c', 'd', 'e');\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamReleaseOnClose(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    byte[] bytes = { 'a', 'b', 'c' };\r\n    buffer.write(bytes);\r\n    try (InputStream inputStream = buffer.asInputStream(true)) {\r\n        byte[] result = new byte[3];\r\n        int len = inputStream.read(result);\r\n        assertThat(len).isEqualTo(3);\r\n        assertThat(result).isEqualTo(bytes);\r\n    }\r\n    // AbstractDataBufferAllocatingTests.leakDetector will verify the buffer's release\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid outputStream(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write((byte) 'a');\r\n    OutputStream outputStream = buffer.asOutputStream();\r\n    outputStream.write('b');\r\n    outputStream.write(new byte[] { 'c', 'd' });\r\n    buffer.write((byte) 'e');\r\n    byte[] bytes = new byte[5];\r\n    buffer.read(bytes);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'a', 'b', 'c', 'd', 'e' });\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid expand(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    buffer.write((byte) 'a');\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    buffer.write((byte) 'b');\r\n    assertThat(buffer.capacity()).isGreaterThan(1);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid increaseCapacity(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    buffer.capacity(2);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid decreaseCapacityLowReadPosition(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support decreasing the capacity\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    buffer.writePosition(2);\r\n    buffer.capacity(1);\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid decreaseCapacityHighReadPosition(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support decreasing the capacity\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    buffer.writePosition(2);\r\n    buffer.readPosition(2);\r\n    buffer.capacity(1);\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid capacityLessThanZero(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.capacity(-1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer1 = createDataBuffer(1);\r\n    buffer1.write((byte) 'a');\r\n    ByteBuffer buffer2 = createByteBuffer(2);\r\n    buffer2.put((byte) 'b');\r\n    buffer2.flip();\r\n    ByteBuffer buffer3 = createByteBuffer(3);\r\n    buffer3.put((byte) 'c');\r\n    buffer3.flip();\r\n    buffer1.write(buffer2, buffer3);\r\n    // make sure the write index is correctly set\r\n    buffer1.write((byte) 'd');\r\n    assertThat(buffer1.readableByteCount()).isEqualTo(4);\r\n    byte[] result = new byte[4];\r\n    buffer1.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c', 'd' });\r\n    release(buffer1);\r\n}\nprivate ByteBuffer createByteBuffer(int capacity) {\r\n    return ByteBuffer.allocate(capacity);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeDataBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer1 = createDataBuffer(1);\r\n    buffer1.write((byte) 'a');\r\n    DataBuffer buffer2 = createDataBuffer(2);\r\n    buffer2.write((byte) 'b');\r\n    DataBuffer buffer3 = createDataBuffer(3);\r\n    buffer3.write((byte) 'c');\r\n    buffer1.write(buffer2, buffer3);\r\n    // make sure the write index is correctly set\r\n    buffer1.write((byte) 'd');\r\n    assertThat(buffer1.readableByteCount()).isEqualTo(4);\r\n    byte[] result = new byte[4];\r\n    buffer1.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c', 'd' });\r\n    release(buffer1, buffer2, buffer3);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid asByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    // skip a\r\n    buffer.read();\r\n    ByteBuffer result = buffer.asByteBuffer();\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'd');\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid asByteBufferIndexLength(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    @SuppressWarnings(\"deprecation\")\r\n    ByteBuffer result = buffer.asByteBuffer(1, 2);\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, () -> {\r\n        DataBufferUtils.release(buffer);\r\n        return \"Netty 5 does share the internal buffer\";\r\n    });\r\n    buffer.write((byte) 'c');\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid byteBufferContainsDataBufferChanges(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support sharing data between buffers\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = createDataBuffer(1);\r\n    ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, 1);\r\n    dataBuffer.write((byte) 'a');\r\n    assertThat(byteBuffer.limit()).isEqualTo(1);\r\n    byte b = byteBuffer.get();\r\n    assertThat(b).isEqualTo((byte) 'a');\r\n    release(dataBuffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid dataBufferContainsByteBufferChanges(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support sharing data between buffers\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = createDataBuffer(1);\r\n    ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, 1);\r\n    byteBuffer.put((byte) 'a');\r\n    dataBuffer.writePosition(1);\r\n    byte b = dataBuffer.read();\r\n    assertThat(b).isEqualTo((byte) 'a');\r\n    release(dataBuffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid emptyAsByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    ByteBuffer result = buffer.asByteBuffer();\r\n    assertThat(result.capacity()).isEqualTo(0);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid toByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    // skip a\r\n    buffer.read();\r\n    @SuppressWarnings(\"deprecation\")\r\n    ByteBuffer result = buffer.toByteBuffer();\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid toByteBufferIndexLength(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    @SuppressWarnings(\"deprecation\")\r\n    ByteBuffer result = buffer.toByteBuffer(1, 2);\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid toByteBufferDestination(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    ByteBuffer byteBuffer = createByteBuffer(2);\r\n    buffer.toByteBuffer(1, byteBuffer, 0, 2);\r\n    assertThat(byteBuffer.capacity()).isEqualTo(2);\r\n    assertThat(byteBuffer.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    byteBuffer.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.toByteBuffer(0, byteBuffer, 0, 3));\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readableByteBuffers(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(3);\r\n    dataBuffer.write(\"abc\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    dataBuffer.writePosition(2);\r\n    byte[] result = new byte[1];\r\n    try (var iterator = dataBuffer.readableByteBuffers()) {\r\n        assertThat(iterator).hasNext();\r\n        int i = 0;\r\n        while (iterator.hasNext()) {\r\n            ByteBuffer byteBuffer = iterator.next();\r\n            assertThat(byteBuffer.position()).isEqualTo(0);\r\n            assertThat(byteBuffer.limit()).isEqualTo(1);\r\n            assertThat(byteBuffer.capacity()).isEqualTo(1);\r\n            assertThat(byteBuffer.remaining()).isEqualTo(1);\r\n            byteBuffer.get(result, i, 1);\r\n            assertThat(iterator).isExhausted();\r\n        }\r\n    }\r\n    assertThat(result).containsExactly('b');\r\n    release(dataBuffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readableByteBuffersJoined(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = this.bufferFactory.join(Arrays.asList(stringBuffer(\"a\"), stringBuffer(\"b\"), stringBuffer(\"c\")));\r\n    byte[] result = new byte[3];\r\n    try (var iterator = dataBuffer.readableByteBuffers()) {\r\n        assertThat(iterator).hasNext();\r\n        int i = 0;\r\n        while (iterator.hasNext()) {\r\n            ByteBuffer byteBuffer = iterator.next();\r\n            int len = byteBuffer.remaining();\r\n            byteBuffer.get(result, i, len);\r\n            i += len;\r\n            assertThatException().isThrownBy(() -> byteBuffer.put((byte) 'd'));\r\n        }\r\n    }\r\n    assertThat(result).containsExactly('a', 'b', 'c');\r\n    release(dataBuffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writableByteBuffers(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(3);\r\n    dataBuffer.write(\"ab\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    try (DataBuffer.ByteBufferIterator iterator = dataBuffer.writableByteBuffers()) {\r\n        assertThat(iterator).hasNext();\r\n        ByteBuffer byteBuffer = iterator.next();\r\n        assertThat(byteBuffer.position()).isEqualTo(0);\r\n        assertThat(byteBuffer.limit()).isEqualTo(1);\r\n        assertThat(byteBuffer.capacity()).isEqualTo(1);\r\n        assertThat(byteBuffer.remaining()).isEqualTo(1);\r\n        byteBuffer.put((byte) 'c');\r\n        dataBuffer.writePosition(3);\r\n        assertThat(iterator).isExhausted();\r\n    }\r\n    byte[] result = new byte[2];\r\n    dataBuffer.read(result);\r\n    assertThat(result).containsExactly('b', 'c');\r\n    release(dataBuffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid indexOf(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    int result = buffer.indexOf(b -> b == 'c', 0);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.indexOf(b -> b == 'c', Integer.MIN_VALUE);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.indexOf(b -> b == 'c', Integer.MAX_VALUE);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = buffer.indexOf(b -> b == 'z', 0);\r\n    assertThat(result).isEqualTo(-1);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid lastIndexOf(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    int result = buffer.lastIndexOf(b -> b == 'b', 2);\r\n    assertThat(result).isEqualTo(1);\r\n    result = buffer.lastIndexOf(b -> b == 'c', 2);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.lastIndexOf(b -> b == 'b', Integer.MAX_VALUE);\r\n    assertThat(result).isEqualTo(1);\r\n    result = buffer.lastIndexOf(b -> b == 'c', Integer.MAX_VALUE);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.lastIndexOf(b -> b == 'b', Integer.MIN_VALUE);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = buffer.lastIndexOf(b -> b == 'c', Integer.MIN_VALUE);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = buffer.lastIndexOf(b -> b == 'z', 0);\r\n    assertThat(result).isEqualTo(-1);\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid slice(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    DataBuffer slice = buffer.slice(1, 2);\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    buffer.write((byte) 'c');\r\n    assertThat(buffer.readableByteCount()).isEqualTo(3);\r\n    byte[] result = new byte[3];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c' });\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    result = new byte[2];\r\n    slice.read(result);\r\n    if (!(bufferFactory instanceof Netty5DataBufferFactory)) {\r\n        assertThat(result).isEqualTo(new byte[] { 'b', 'c' });\r\n    }\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid retainedSlice(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support retainedSlice\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    DataBuffer slice = buffer.retainedSlice(1, 2);\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    buffer.write((byte) 'c');\r\n    assertThat(buffer.readableByteCount()).isEqualTo(3);\r\n    byte[] result = new byte[3];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c' });\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    result = new byte[2];\r\n    slice.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer, slice);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid spr16351(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(6);\r\n    byte[] bytes = { 'a', 'b', 'c', 'd', 'e', 'f' };\r\n    buffer.write(bytes);\r\n    DataBuffer slice = buffer.slice(3, 3);\r\n    buffer.writePosition(3);\r\n    buffer.write(slice);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(6);\r\n    byte[] result = new byte[6];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(bytes);\r\n    if (bufferFactory instanceof Netty5DataBufferFactory) {\r\n        release(slice);\r\n    }\r\n    release(buffer);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid split(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    assertThatException().isThrownBy(() -> buffer.split(-1));\r\n    assertThatException().isThrownBy(() -> buffer.split(4));\r\n    DataBuffer split = buffer.split(1);\r\n    assertThat(split.readPosition()).isEqualTo(0);\r\n    assertThat(split.writePosition()).isEqualTo(1);\r\n    assertThat(split.capacity()).isEqualTo(1);\r\n    assertThat(split.readableByteCount()).isEqualTo(1);\r\n    byte[] bytes = new byte[1];\r\n    split.read(bytes);\r\n    assertThat(bytes).containsExactly('a');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(1);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'c');\r\n    assertThat(buffer.readableByteCount()).isEqualTo(2);\r\n    bytes = new byte[2];\r\n    buffer.read(bytes);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    DataBuffer buffer2 = createDataBuffer(1);\r\n    buffer2.write(new byte[] { 'a' });\r\n    DataBuffer split2 = buffer2.split(1);\r\n    assertThat(split2.readPosition()).isEqualTo(0);\r\n    assertThat(split2.writePosition()).isEqualTo(1);\r\n    assertThat(split2.capacity()).isEqualTo(1);\r\n    assertThat(split2.readableByteCount()).isEqualTo(1);\r\n    bytes = new byte[1];\r\n    split2.read(bytes);\r\n    assertThat(bytes).containsExactly('a');\r\n    assertThat(buffer2.readPosition()).isEqualTo(0);\r\n    assertThat(buffer2.writePosition()).isEqualTo(0);\r\n    assertThat(buffer2.capacity()).isEqualTo(0);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    release(buffer, buffer2, split, split2);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid join(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer composite = this.bufferFactory.join(Arrays.asList(stringBuffer(\"a\"), stringBuffer(\"b\"), stringBuffer(\"c\")));\r\n    assertThat(composite.readableByteCount()).isEqualTo(3);\r\n    byte[] bytes = new byte[3];\r\n    composite.read(bytes);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'a', 'b', 'c' });\r\n    release(composite);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid getByte(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = stringBuffer(\"abc\");\r\n    assertThat(buffer.getByte(0)).isEqualTo((byte) 'a');\r\n    assertThat(buffer.getByte(1)).isEqualTo((byte) 'b');\r\n    assertThat(buffer.getByte(2)).isEqualTo((byte) 'c');\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(-1));\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(3));\r\n    release(buffer);\r\n}\n// gh-31605\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid shouldHonorSourceBuffersReadPosition(DataBufferFactory bufferFactory) {\r\n    DataBuffer dataBuffer = bufferFactory.wrap(\"ab\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    ByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\r\n    dataBuffer.toByteBuffer(byteBuffer);\r\n    assertThat(StandardCharsets.UTF_8.decode(byteBuffer).toString()).isEqualTo(\"b\");\r\n}\n// gh-31873\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid repeatedWrites(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = bufferFactory.allocateBuffer(256);\r\n    String name = \"Müller\";\r\n    int repeatCount = 19;\r\n    for (int i = 0; i < repeatCount; i++) {\r\n        buffer.write(name, StandardCharsets.UTF_8);\r\n    }\r\n    String result = buffer.toString(StandardCharsets.UTF_8);\r\n    String expected = name.repeat(repeatCount);\r\n    assertThat(result).isEqualTo(expected);\r\n    release(buffer);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#byteCountsAndPositions(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid byteCountsAndPositions(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(0);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(2);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'a');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(1);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'b');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(2);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.read();\r\n    assertThat(buffer.readPosition()).isEqualTo(1);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(1);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.read();\r\n    assertThat(buffer.readPosition()).isEqualTo(2);\r\n    assertThat(buffer.writePosition()).isEqualTo(2);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.writableByteCount()).isEqualTo(0);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#readPositionSmallerThanZero(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readPositionSmallerThanZero(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(-1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#readPositionGreaterThanWritePosition(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readPositionGreaterThanWritePosition(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.readPosition(1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writePositionSmallerThanReadPosition(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writePositionSmallerThanReadPosition(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    try {\r\n        buffer.write((byte) 'a');\r\n        buffer.read();\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.writePosition(0));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writePositionGreaterThanCapacity(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writePositionGreaterThanCapacity(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.writePosition(2));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeAndRead(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeAndRead(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(5);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    int ch = buffer.read();\r\n    assertThat(ch).isEqualTo((byte) 'a');\r\n    buffer.write((byte) 'd');\r\n    buffer.write((byte) 'e');\r\n    byte[] result = new byte[4];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'b', 'c', 'd', 'e' });\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeNullString(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeNullString(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.write(null, StandardCharsets.UTF_8));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeNullCharset(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeNullCharset(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.write(\"test\", null));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeEmptyString(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeEmptyString(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    buffer.write(\"\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeUtf8String(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeUtf8String(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(6);\r\n    buffer.write(\"Spring\", StandardCharsets.UTF_8);\r\n    byte[] result = new byte[6];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"Spring\".getBytes(StandardCharsets.UTF_8));\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeUtf8StringOutGrowsCapacity(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeUtf8StringOutGrowsCapacity(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(5);\r\n    buffer.write(\"Spring €\", StandardCharsets.UTF_8);\r\n    byte[] result = new byte[10];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"Spring €\".getBytes(StandardCharsets.UTF_8));\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeIsoString(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeIsoString(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(\"\\u00A3\", StandardCharsets.ISO_8859_1);\r\n    byte[] result = new byte[1];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"\\u00A3\".getBytes(StandardCharsets.ISO_8859_1));\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeMultipleUtf8String(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeMultipleUtf8String(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    buffer.write(\"abc\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(3);\r\n    buffer.write(\"def\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(6);\r\n    buffer.write(\"ghi\", StandardCharsets.UTF_8);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(9);\r\n    byte[] result = new byte[9];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(\"abcdefghi\".getBytes());\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#toStringNullCharset(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid toStringNullCharset(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.toString(null));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#toStringUtf8(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid toStringUtf8(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    String spring = \"Spring\";\r\n    byte[] bytes = spring.getBytes(StandardCharsets.UTF_8);\r\n    DataBuffer buffer = createDataBuffer(bytes.length);\r\n    buffer.write(bytes);\r\n    String result = buffer.toString(StandardCharsets.UTF_8);\r\n    assertThat(result).isEqualTo(spring);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#toStringSection(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid toStringSection(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    String spring = \"Spring\";\r\n    byte[] bytes = spring.getBytes(StandardCharsets.UTF_8);\r\n    DataBuffer buffer = createDataBuffer(bytes.length);\r\n    buffer.write(bytes);\r\n    String result = buffer.toString(1, 3, StandardCharsets.UTF_8);\r\n    assertThat(result).isEqualTo(\"pri\");\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#inputStream(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid inputStream(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c', 'd', 'e' });\r\n    buffer.readPosition(1);\r\n    InputStream inputStream = buffer.asInputStream();\r\n    assertThat(inputStream.available()).isEqualTo(4);\r\n    int result = inputStream.read();\r\n    assertThat(result).isEqualTo((byte) 'b');\r\n    assertThat(inputStream.available()).isEqualTo(3);\r\n    assertThat(inputStream.markSupported()).isTrue();\r\n    inputStream.mark(2);\r\n    byte[] bytes = new byte[2];\r\n    int len = inputStream.read(bytes);\r\n    assertThat(len).isEqualTo(2);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'c', 'd' });\r\n    assertThat(inputStream.available()).isEqualTo(1);\r\n    Arrays.fill(bytes, (byte) 0);\r\n    len = inputStream.read(bytes);\r\n    assertThat(len).isEqualTo(1);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'e', (byte) 0 });\r\n    assertThat(inputStream.available()).isEqualTo(0);\r\n    assertThat(inputStream.read()).isEqualTo(-1);\r\n    assertThat(inputStream.read(bytes)).isEqualTo(-1);\r\n    inputStream.reset();\r\n    bytes = new byte[3];\r\n    len = inputStream.read(bytes);\r\n    assertThat(len).isEqualTo(3);\r\n    assertThat(bytes).containsExactly('c', 'd', 'e');\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#inputStreamReleaseOnClose(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamReleaseOnClose(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    byte[] bytes = { 'a', 'b', 'c' };\r\n    buffer.write(bytes);\r\n    try (InputStream inputStream = buffer.asInputStream(true)) {\r\n        byte[] result = new byte[3];\r\n        int len = inputStream.read(result);\r\n        assertThat(len).isEqualTo(3);\r\n        assertThat(result).isEqualTo(bytes);\r\n    }\r\n    // AbstractDataBufferAllocatingTests.leakDetector will verify the buffer's release\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#outputStream(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid outputStream(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write((byte) 'a');\r\n    OutputStream outputStream = buffer.asOutputStream();\r\n    outputStream.write('b');\r\n    outputStream.write(new byte[] { 'c', 'd' });\r\n    buffer.write((byte) 'e');\r\n    byte[] bytes = new byte[5];\r\n    buffer.read(bytes);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'a', 'b', 'c', 'd', 'e' });\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#expand(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid expand(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    buffer.write((byte) 'a');\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    buffer.write((byte) 'b');\r\n    assertThat(buffer.capacity()).isGreaterThan(1);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#increaseCapacity(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid increaseCapacity(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    buffer.capacity(2);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#decreaseCapacityLowReadPosition(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid decreaseCapacityLowReadPosition(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support decreasing the capacity\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    buffer.writePosition(2);\r\n    buffer.capacity(1);\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#decreaseCapacityHighReadPosition(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid decreaseCapacityHighReadPosition(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support decreasing the capacity\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(2);\r\n    buffer.writePosition(2);\r\n    buffer.readPosition(2);\r\n    buffer.capacity(1);\r\n    assertThat(buffer.capacity()).isEqualTo(1);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#capacityLessThanZero(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid capacityLessThanZero(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    try {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> buffer.capacity(-1));\r\n    } finally {\r\n        release(buffer);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeByteBuffer(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer1 = createDataBuffer(1);\r\n    buffer1.write((byte) 'a');\r\n    ByteBuffer buffer2 = createByteBuffer(2);\r\n    buffer2.put((byte) 'b');\r\n    buffer2.flip();\r\n    ByteBuffer buffer3 = createByteBuffer(3);\r\n    buffer3.put((byte) 'c');\r\n    buffer3.flip();\r\n    buffer1.write(buffer2, buffer3);\r\n    // make sure the write index is correctly set\r\n    buffer1.write((byte) 'd');\r\n    assertThat(buffer1.readableByteCount()).isEqualTo(4);\r\n    byte[] result = new byte[4];\r\n    buffer1.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c', 'd' });\r\n    release(buffer1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#createByteBuffer(int)",
    "entityType": "method",
    "code": "private ByteBuffer createByteBuffer(int capacity) {\r\n    return ByteBuffer.allocate(capacity);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writeDataBuffer(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writeDataBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer1 = createDataBuffer(1);\r\n    buffer1.write((byte) 'a');\r\n    DataBuffer buffer2 = createDataBuffer(2);\r\n    buffer2.write((byte) 'b');\r\n    DataBuffer buffer3 = createDataBuffer(3);\r\n    buffer3.write((byte) 'c');\r\n    buffer1.write(buffer2, buffer3);\r\n    // make sure the write index is correctly set\r\n    buffer1.write((byte) 'd');\r\n    assertThat(buffer1.readableByteCount()).isEqualTo(4);\r\n    byte[] result = new byte[4];\r\n    buffer1.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c', 'd' });\r\n    release(buffer1, buffer2, buffer3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#asByteBuffer(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid asByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    // skip a\r\n    buffer.read();\r\n    ByteBuffer result = buffer.asByteBuffer();\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'd');\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#asByteBufferIndexLength(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid asByteBufferIndexLength(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    @SuppressWarnings(\"deprecation\")\r\n    ByteBuffer result = buffer.asByteBuffer(1, 2);\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, () -> {\r\n        DataBufferUtils.release(buffer);\r\n        return \"Netty 5 does share the internal buffer\";\r\n    });\r\n    buffer.write((byte) 'c');\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#byteBufferContainsDataBufferChanges(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid byteBufferContainsDataBufferChanges(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support sharing data between buffers\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = createDataBuffer(1);\r\n    ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, 1);\r\n    dataBuffer.write((byte) 'a');\r\n    assertThat(byteBuffer.limit()).isEqualTo(1);\r\n    byte b = byteBuffer.get();\r\n    assertThat(b).isEqualTo((byte) 'a');\r\n    release(dataBuffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#dataBufferContainsByteBufferChanges(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid dataBufferContainsByteBufferChanges(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support sharing data between buffers\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = createDataBuffer(1);\r\n    ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, 1);\r\n    byteBuffer.put((byte) 'a');\r\n    dataBuffer.writePosition(1);\r\n    byte b = dataBuffer.read();\r\n    assertThat(b).isEqualTo((byte) 'a');\r\n    release(dataBuffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#emptyAsByteBuffer(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid emptyAsByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(1);\r\n    ByteBuffer result = buffer.asByteBuffer();\r\n    assertThat(result.capacity()).isEqualTo(0);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#toByteBuffer(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid toByteBuffer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    // skip a\r\n    buffer.read();\r\n    @SuppressWarnings(\"deprecation\")\r\n    ByteBuffer result = buffer.toByteBuffer();\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#toByteBufferIndexLength(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid toByteBufferIndexLength(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    @SuppressWarnings(\"deprecation\")\r\n    ByteBuffer result = buffer.toByteBuffer(1, 2);\r\n    assertThat(result.capacity()).isEqualTo(2);\r\n    assertThat(result.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    result.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#toByteBufferDestination(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid toByteBufferDestination(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(4);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    ByteBuffer byteBuffer = createByteBuffer(2);\r\n    buffer.toByteBuffer(1, byteBuffer, 0, 2);\r\n    assertThat(byteBuffer.capacity()).isEqualTo(2);\r\n    assertThat(byteBuffer.remaining()).isEqualTo(2);\r\n    byte[] resultBytes = new byte[2];\r\n    byteBuffer.get(resultBytes);\r\n    assertThat(resultBytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.toByteBuffer(0, byteBuffer, 0, 3));\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#readableByteBuffers(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readableByteBuffers(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(3);\r\n    dataBuffer.write(\"abc\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    dataBuffer.writePosition(2);\r\n    byte[] result = new byte[1];\r\n    try (var iterator = dataBuffer.readableByteBuffers()) {\r\n        assertThat(iterator).hasNext();\r\n        int i = 0;\r\n        while (iterator.hasNext()) {\r\n            ByteBuffer byteBuffer = iterator.next();\r\n            assertThat(byteBuffer.position()).isEqualTo(0);\r\n            assertThat(byteBuffer.limit()).isEqualTo(1);\r\n            assertThat(byteBuffer.capacity()).isEqualTo(1);\r\n            assertThat(byteBuffer.remaining()).isEqualTo(1);\r\n            byteBuffer.get(result, i, 1);\r\n            assertThat(iterator).isExhausted();\r\n        }\r\n    }\r\n    assertThat(result).containsExactly('b');\r\n    release(dataBuffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#readableByteBuffersJoined(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readableByteBuffersJoined(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = this.bufferFactory.join(Arrays.asList(stringBuffer(\"a\"), stringBuffer(\"b\"), stringBuffer(\"c\")));\r\n    byte[] result = new byte[3];\r\n    try (var iterator = dataBuffer.readableByteBuffers()) {\r\n        assertThat(iterator).hasNext();\r\n        int i = 0;\r\n        while (iterator.hasNext()) {\r\n            ByteBuffer byteBuffer = iterator.next();\r\n            int len = byteBuffer.remaining();\r\n            byteBuffer.get(result, i, len);\r\n            i += len;\r\n            assertThatException().isThrownBy(() -> byteBuffer.put((byte) 'd'));\r\n        }\r\n    }\r\n    assertThat(result).containsExactly('a', 'b', 'c');\r\n    release(dataBuffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#writableByteBuffers(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid writableByteBuffers(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer dataBuffer = this.bufferFactory.allocateBuffer(3);\r\n    dataBuffer.write(\"ab\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    try (DataBuffer.ByteBufferIterator iterator = dataBuffer.writableByteBuffers()) {\r\n        assertThat(iterator).hasNext();\r\n        ByteBuffer byteBuffer = iterator.next();\r\n        assertThat(byteBuffer.position()).isEqualTo(0);\r\n        assertThat(byteBuffer.limit()).isEqualTo(1);\r\n        assertThat(byteBuffer.capacity()).isEqualTo(1);\r\n        assertThat(byteBuffer.remaining()).isEqualTo(1);\r\n        byteBuffer.put((byte) 'c');\r\n        dataBuffer.writePosition(3);\r\n        assertThat(iterator).isExhausted();\r\n    }\r\n    byte[] result = new byte[2];\r\n    dataBuffer.read(result);\r\n    assertThat(result).containsExactly('b', 'c');\r\n    release(dataBuffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#indexOf(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid indexOf(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    int result = buffer.indexOf(b -> b == 'c', 0);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.indexOf(b -> b == 'c', Integer.MIN_VALUE);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.indexOf(b -> b == 'c', Integer.MAX_VALUE);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = buffer.indexOf(b -> b == 'z', 0);\r\n    assertThat(result).isEqualTo(-1);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#lastIndexOf(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid lastIndexOf(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b', 'c' });\r\n    int result = buffer.lastIndexOf(b -> b == 'b', 2);\r\n    assertThat(result).isEqualTo(1);\r\n    result = buffer.lastIndexOf(b -> b == 'c', 2);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.lastIndexOf(b -> b == 'b', Integer.MAX_VALUE);\r\n    assertThat(result).isEqualTo(1);\r\n    result = buffer.lastIndexOf(b -> b == 'c', Integer.MAX_VALUE);\r\n    assertThat(result).isEqualTo(2);\r\n    result = buffer.lastIndexOf(b -> b == 'b', Integer.MIN_VALUE);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = buffer.lastIndexOf(b -> b == 'c', Integer.MIN_VALUE);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = buffer.lastIndexOf(b -> b == 'z', 0);\r\n    assertThat(result).isEqualTo(-1);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#slice(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid slice(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    DataBuffer slice = buffer.slice(1, 2);\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    buffer.write((byte) 'c');\r\n    assertThat(buffer.readableByteCount()).isEqualTo(3);\r\n    byte[] result = new byte[3];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c' });\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    result = new byte[2];\r\n    slice.read(result);\r\n    if (!(bufferFactory instanceof Netty5DataBufferFactory)) {\r\n        assertThat(result).isEqualTo(new byte[] { 'b', 'c' });\r\n    }\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#retainedSlice(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid retainedSlice(DataBufferFactory bufferFactory) {\r\n    assumeFalse(bufferFactory instanceof Netty5DataBufferFactory, \"Netty 5 does not support retainedSlice\");\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    DataBuffer slice = buffer.retainedSlice(1, 2);\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    buffer.write((byte) 'c');\r\n    assertThat(buffer.readableByteCount()).isEqualTo(3);\r\n    byte[] result = new byte[3];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'a', 'b', 'c' });\r\n    assertThat(slice.readableByteCount()).isEqualTo(2);\r\n    result = new byte[2];\r\n    slice.read(result);\r\n    assertThat(result).isEqualTo(new byte[] { 'b', 'c' });\r\n    release(buffer, slice);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#spr16351(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\n@SuppressWarnings(\"deprecation\")\r\nvoid spr16351(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(6);\r\n    byte[] bytes = { 'a', 'b', 'c', 'd', 'e', 'f' };\r\n    buffer.write(bytes);\r\n    DataBuffer slice = buffer.slice(3, 3);\r\n    buffer.writePosition(3);\r\n    buffer.write(slice);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(6);\r\n    byte[] result = new byte[6];\r\n    buffer.read(result);\r\n    assertThat(result).isEqualTo(bytes);\r\n    if (bufferFactory instanceof Netty5DataBufferFactory) {\r\n        release(slice);\r\n    }\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#split(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid split(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = createDataBuffer(3);\r\n    buffer.write(new byte[] { 'a', 'b' });\r\n    assertThatException().isThrownBy(() -> buffer.split(-1));\r\n    assertThatException().isThrownBy(() -> buffer.split(4));\r\n    DataBuffer split = buffer.split(1);\r\n    assertThat(split.readPosition()).isEqualTo(0);\r\n    assertThat(split.writePosition()).isEqualTo(1);\r\n    assertThat(split.capacity()).isEqualTo(1);\r\n    assertThat(split.readableByteCount()).isEqualTo(1);\r\n    byte[] bytes = new byte[1];\r\n    split.read(bytes);\r\n    assertThat(bytes).containsExactly('a');\r\n    assertThat(buffer.readPosition()).isEqualTo(0);\r\n    assertThat(buffer.writePosition()).isEqualTo(1);\r\n    assertThat(buffer.capacity()).isEqualTo(2);\r\n    buffer.write((byte) 'c');\r\n    assertThat(buffer.readableByteCount()).isEqualTo(2);\r\n    bytes = new byte[2];\r\n    buffer.read(bytes);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'b', 'c' });\r\n    DataBuffer buffer2 = createDataBuffer(1);\r\n    buffer2.write(new byte[] { 'a' });\r\n    DataBuffer split2 = buffer2.split(1);\r\n    assertThat(split2.readPosition()).isEqualTo(0);\r\n    assertThat(split2.writePosition()).isEqualTo(1);\r\n    assertThat(split2.capacity()).isEqualTo(1);\r\n    assertThat(split2.readableByteCount()).isEqualTo(1);\r\n    bytes = new byte[1];\r\n    split2.read(bytes);\r\n    assertThat(bytes).containsExactly('a');\r\n    assertThat(buffer2.readPosition()).isEqualTo(0);\r\n    assertThat(buffer2.writePosition()).isEqualTo(0);\r\n    assertThat(buffer2.capacity()).isEqualTo(0);\r\n    assertThat(buffer.readableByteCount()).isEqualTo(0);\r\n    release(buffer, buffer2, split, split2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#join(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid join(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer composite = this.bufferFactory.join(Arrays.asList(stringBuffer(\"a\"), stringBuffer(\"b\"), stringBuffer(\"c\")));\r\n    assertThat(composite.readableByteCount()).isEqualTo(3);\r\n    byte[] bytes = new byte[3];\r\n    composite.read(bytes);\r\n    assertThat(bytes).isEqualTo(new byte[] { 'a', 'b', 'c' });\r\n    release(composite);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#getByte(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid getByte(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = stringBuffer(\"abc\");\r\n    assertThat(buffer.getByte(0)).isEqualTo((byte) 'a');\r\n    assertThat(buffer.getByte(1)).isEqualTo((byte) 'b');\r\n    assertThat(buffer.getByte(2)).isEqualTo((byte) 'c');\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(-1));\r\n    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> buffer.getByte(3));\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#shouldHonorSourceBuffersReadPosition(DataBufferFactory)",
    "entityType": "method",
    "code": "// gh-31605\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid shouldHonorSourceBuffersReadPosition(DataBufferFactory bufferFactory) {\r\n    DataBuffer dataBuffer = bufferFactory.wrap(\"ab\".getBytes(StandardCharsets.UTF_8));\r\n    dataBuffer.readPosition(1);\r\n    ByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\r\n    dataBuffer.toByteBuffer(byteBuffer);\r\n    assertThat(StandardCharsets.UTF_8.decode(byteBuffer).toString()).isEqualTo(\"b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferTests#repeatedWrites(DataBufferFactory)",
    "entityType": "method",
    "code": "// gh-31873\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid repeatedWrites(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer buffer = bufferFactory.allocateBuffer(256);\r\n    String name = \"Müller\";\r\n    int repeatCount = 19;\r\n    for (int i = 0; i < repeatCount; i++) {\r\n        buffer.write(name, StandardCharsets.UTF_8);\r\n    }\r\n    String result = buffer.toString(StandardCharsets.UTF_8);\r\n    String expected = name.repeat(repeatCount);\r\n    assertThat(result).isEqualTo(expected);\r\n    release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests",
    "entityType": "class",
    "code": "private final Resource resource;\nprivate final Path tempFile;\nDataBufferUtilsTests() throws Exception {\r\n    this.resource = new ClassPathResource(\"DataBufferUtilsTests.txt\", getClass());\r\n    this.tempFile = Files.createTempFile(\"DataBufferUtilsTests\", null);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readInputStream(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.readInputStream(this.resource::getInputStream, super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readByteChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> result = DataBufferUtils.readByteChannel(() -> FileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    verifyReadData(result);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readByteChannelError(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    ReadableByteChannel channel = mock();\r\n    given(channel.read(any())).willAnswer(invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        buffer.put(\"foo\".getBytes(StandardCharsets.UTF_8));\r\n        buffer.flip();\r\n        return 3;\r\n    }).willThrow(new IOException());\r\n    Flux<DataBuffer> result = DataBufferUtils.readByteChannel(() -> channel, super.bufferFactory, 3);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).expectError(IOException.class).verify(Duration.ofSeconds(3));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readByteChannelCancel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> result = DataBufferUtils.readByteChannel(() -> FileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelPosition(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), 9, super.bufferFactory, 3);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"qux\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelError(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    AsynchronousFileChannel channel = mock();\r\n    willAnswer(invocation -> {\r\n        ByteBuffer byteBuffer = invocation.getArgument(0);\r\n        byteBuffer.put(\"foo\".getBytes(StandardCharsets.UTF_8));\r\n        long pos = invocation.getArgument(1);\r\n        assertThat(pos).isEqualTo(0);\r\n        Object attachment = invocation.getArgument(2);\r\n        CompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\r\n        completionHandler.completed(3, attachment);\r\n        return null;\r\n    }).willAnswer(invocation -> {\r\n        Object attachment = invocation.getArgument(2);\r\n        CompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\r\n        completionHandler.failed(new IOException(), attachment);\r\n        return null;\r\n    }).given(channel).read(any(), anyLong(), any(), any());\r\n    Flux<DataBuffer> result = DataBufferUtils.readAsynchronousFileChannel(() -> channel, super.bufferFactory, 3);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).expectError(IOException.class).verify(Duration.ofSeconds(3));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelCancel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify();\r\n}\n// gh-22107\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelCancelWithoutDemand(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    BaseSubscriber<DataBuffer> subscriber = new ZeroDemandSubscriber();\r\n    flux.subscribe(subscriber);\r\n    subscriber.cancel();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readPath(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(this.resource.getFile().toPath(), super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readResource(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(this.resource, super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readResourcePosition(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(this.resource, 9, super.bufferFactory, 3);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"qux\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\nprivate void verifyReadData(Flux<DataBuffer> buffers) {\r\n    StepVerifier.create(buffers).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).consumeNextWith(stringConsumer(\"baz\")).consumeNextWith(stringConsumer(\"qux\")).expectComplete().verify(Duration.ofSeconds(3));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readResourcePositionAndTakeUntil(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Resource resource = new ClassPathResource(\"DataBufferUtilsTests.txt\", getClass());\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(resource, 3, super.bufferFactory, 3);\r\n    flux = DataBufferUtils.takeUntilByteCount(flux, 5);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"bar\")).consumeNextWith(stringConsumer(\"ba\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readByteArrayResourcePositionAndTakeUntil(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Resource resource = new ByteArrayResource(\"foobarbazqux\".getBytes());\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(resource, 3, super.bufferFactory, 3);\r\n    flux = DataBufferUtils.takeUntilByteCount(flux, 5);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"bar\")).consumeNextWith(stringConsumer(\"ba\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeOutputStream(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    DataBuffer qux = stringBuffer(\"qux\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz, qux);\r\n    OutputStream os = Files.newOutputStream(tempFile);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, os);\r\n    verifyWrittenData(writeResult);\r\n    os.close();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeWritableByteChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    DataBuffer qux = stringBuffer(\"qux\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz, qux);\r\n    WritableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    verifyWrittenData(writeResult);\r\n    channel.close();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeWritableByteChannelErrorInFlux(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar).concatWith(Flux.error(new RuntimeException()));\r\n    WritableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    StepVerifier.create(writeResult).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).expectError().verify(Duration.ofSeconds(5));\r\n    String result = String.join(\"\", Files.readAllLines(tempFile));\r\n    assertThat(result).isEqualTo(\"foobar\");\r\n    channel.close();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeWritableByteChannelErrorInWrite(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar);\r\n    WritableByteChannel channel = mock();\r\n    given(channel.write(any())).willAnswer(invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        int written = buffer.remaining();\r\n        buffer.position(buffer.limit());\r\n        return written;\r\n    }).willThrow(new IOException());\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    StepVerifier.create(writeResult).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).expectError(IOException.class).verify(Duration.ofSeconds(3));\r\n    channel.close();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeWritableByteChannelCancel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar);\r\n    WritableByteChannel channel = Files.newByteChannel(tempFile, StandardOpenOption.WRITE);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    StepVerifier.create(writeResult, 1).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify(Duration.ofSeconds(5));\r\n    String result = String.join(\"\", Files.readAllLines(tempFile));\r\n    assertThat(result).isEqualTo(\"foo\");\r\n    channel.close();\r\n    flux.subscribe(DataBufferUtils::release);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    DataBuffer qux = stringBuffer(\"qux\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz, qux);\r\n    AsynchronousFileChannel channel = AsynchronousFileChannel.open(tempFile, StandardOpenOption.WRITE);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    verifyWrittenData(writeResult);\r\n    channel.close();\r\n}\nprivate void verifyWrittenData(Flux<DataBuffer> writeResult) throws IOException {\r\n    StepVerifier.create(writeResult).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).consumeNextWith(stringConsumer(\"baz\")).consumeNextWith(stringConsumer(\"qux\")).expectComplete().verify(Duration.ofSeconds(3));\r\n    String result = String.join(\"\", Files.readAllLines(tempFile));\r\n    assertThat(result).isEqualTo(\"foobarbazqux\");\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeAsynchronousFileChannelErrorInFlux(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar).concatWith(Mono.error(new RuntimeException()));\r\n    AsynchronousFileChannel channel = AsynchronousFileChannel.open(tempFile, StandardOpenOption.WRITE);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    StepVerifier.create(writeResult).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).expectError(RuntimeException.class).verify();\r\n    String result = String.join(\"\", Files.readAllLines(tempFile));\r\n    assertThat(result).isEqualTo(\"foobar\");\r\n    channel.close();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeAsynchronousFileChannelErrorInWrite(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar);\r\n    AsynchronousFileChannel channel = mock();\r\n    willAnswer(invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        long pos = invocation.getArgument(1);\r\n        assertThat(pos).isEqualTo(0);\r\n        Object attachment = invocation.getArgument(2);\r\n        CompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\r\n        int written = buffer.remaining();\r\n        buffer.position(buffer.limit());\r\n        completionHandler.completed(written, attachment);\r\n        return null;\r\n    }).willAnswer(invocation -> {\r\n        Object attachment = invocation.getArgument(2);\r\n        CompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\r\n        completionHandler.failed(new IOException(), attachment);\r\n        return null;\r\n    }).given(channel).write(any(), anyLong(), any(), any());\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    StepVerifier.create(writeResult).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).expectError(IOException.class).verify();\r\n    channel.close();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writeAsynchronousFileChannelCanceled(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar);\r\n    AsynchronousFileChannel channel = AsynchronousFileChannel.open(tempFile, StandardOpenOption.WRITE);\r\n    Flux<DataBuffer> writeResult = DataBufferUtils.write(flux, channel);\r\n    StepVerifier.create(writeResult, 1).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify();\r\n    String result = String.join(\"\", Files.readAllLines(tempFile));\r\n    assertThat(result).isEqualTo(\"foo\");\r\n    channel.close();\r\n    flux.subscribe(DataBufferUtils::release);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid writePath(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar);\r\n    Mono<Void> result = DataBufferUtils.write(flux, tempFile);\r\n    StepVerifier.create(result).verifyComplete();\r\n    List<String> written = Files.readAllLines(tempFile);\r\n    assertThat(written).contains(\"foobar\");\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid outputStreamPublisher(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    byte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] baz = \"baz\".getBytes(StandardCharsets.UTF_8);\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\r\n        try {\r\n            outputStream.write(foo);\r\n            outputStream.write(bar);\r\n            outputStream.write(baz);\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor());\r\n    StepVerifier.create(publisher).consumeNextWith(stringConsumer(\"foobarbaz\")).verifyComplete();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid outputStreamPublisherFlush(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    byte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] baz = \"baz\".getBytes(StandardCharsets.UTF_8);\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\r\n        try {\r\n            outputStream.write(foo);\r\n            outputStream.flush();\r\n            outputStream.write(bar);\r\n            outputStream.flush();\r\n            outputStream.write(baz);\r\n            outputStream.flush();\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor());\r\n    StepVerifier.create(publisher).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).consumeNextWith(stringConsumer(\"baz\")).verifyComplete();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid outputStreamPublisherChunkSize(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    byte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] baz = \"baz\".getBytes(StandardCharsets.UTF_8);\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\r\n        try {\r\n            outputStream.write(foo);\r\n            outputStream.write(bar);\r\n            outputStream.write(baz);\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor(), 3);\r\n    StepVerifier.create(publisher).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).consumeNextWith(stringConsumer(\"baz\")).verifyComplete();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid outputStreamPublisherCancel(DataBufferFactory bufferFactory) throws InterruptedException {\r\n    super.bufferFactory = bufferFactory;\r\n    byte[] foo = \"foo\".getBytes(StandardCharsets.UTF_8);\r\n    byte[] bar = \"bar\".getBytes(StandardCharsets.UTF_8);\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\r\n        try {\r\n            assertThatIOException().isThrownBy(() -> {\r\n                outputStream.write(foo);\r\n                outputStream.flush();\r\n                outputStream.write(bar);\r\n                outputStream.flush();\r\n            }).withMessage(\"Subscription has been terminated\");\r\n        } finally {\r\n            latch.countDown();\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor());\r\n    StepVerifier.create(publisher, 1).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify();\r\n    latch.await();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid outputStreamPublisherClosed(DataBufferFactory bufferFactory) throws InterruptedException {\r\n    super.bufferFactory = bufferFactory;\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(outputStream -> {\r\n        try {\r\n            OutputStreamWriter writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8);\r\n            writer.write(\"foo\");\r\n            writer.close();\r\n            assertThatIOException().isThrownBy(() -> writer.write(\"bar\")).withMessage(\"Stream closed\");\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        } finally {\r\n            latch.countDown();\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor());\r\n    StepVerifier.create(publisher).consumeNextWith(stringConsumer(\"foo\")).verifyComplete();\r\n    latch.await();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 3, 3, 64, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize2(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 3, 3, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize3(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 3, 12, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foobarbaz\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize4(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 3, 1, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"f\", \"o\", \"o\", \"b\", \"a\", \"r\", \"b\", \"a\", \"z\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize5(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 3, 2, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"fo\", \"ob\", \"ar\", \"ba\", \"z\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize6(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 1, 3, 1, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberChunkSize7(DataBufferFactory factory) {\r\n    genericInputStreamSubscriberTest(factory, 1, 3, 64, List.of(\"foo\", \"bar\", \"baz\"), List.of(\"foo\", \"bar\", \"baz\"));\r\n}\nvoid genericInputStreamSubscriberTest(DataBufferFactory factory, int writeChunkSize, int readChunkSize, int bufferSize, List<String> input, List<String> expectedOutput) {\r\n    super.bufferFactory = factory;\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(out -> {\r\n        try {\r\n            for (String word : input) {\r\n                out.write(word.getBytes(StandardCharsets.UTF_8));\r\n            }\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor(), writeChunkSize);\r\n    byte[] chunk = new byte[readChunkSize];\r\n    List<String> words = new ArrayList<>();\r\n    try (InputStream in = DataBufferUtils.subscriberInputStream(publisher, bufferSize)) {\r\n        int read;\r\n        while ((read = in.read(chunk)) > -1) {\r\n            words.add(new String(chunk, 0, read, StandardCharsets.UTF_8));\r\n        }\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    assertThat(words).containsExactlyElementsOf(expectedOutput);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberError(DataBufferFactory factory) {\r\n    super.bufferFactory = factory;\r\n    var input = List.of(\"foo \", \"bar \", \"baz\");\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(out -> {\r\n        try {\r\n            for (String word : input) {\r\n                out.write(word.getBytes(StandardCharsets.UTF_8));\r\n            }\r\n            throw new RuntimeException(\"boom\");\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor(), 1);\r\n    RuntimeException error = null;\r\n    byte[] chunk = new byte[4];\r\n    List<String> words = new ArrayList<>();\r\n    try (InputStream in = DataBufferUtils.subscriberInputStream(publisher, 1)) {\r\n        int read;\r\n        while ((read = in.read(chunk)) > -1) {\r\n            words.add(new String(chunk, 0, read, StandardCharsets.UTF_8));\r\n        }\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (RuntimeException e) {\r\n        error = e;\r\n    }\r\n    assertThat(words).containsExactlyElementsOf(List.of(\"foo \", \"bar \", \"baz\"));\r\n    assertThat(error).hasMessage(\"boom\");\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberMixedReadMode(DataBufferFactory factory) {\r\n    super.bufferFactory = factory;\r\n    var input = List.of(\"foo \", \"bar \", \"baz\");\r\n    Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(out -> {\r\n        try {\r\n            for (String word : input) {\r\n                out.write(word.getBytes(StandardCharsets.UTF_8));\r\n            }\r\n        } catch (IOException ex) {\r\n            fail(ex.getMessage(), ex);\r\n        }\r\n    }, super.bufferFactory, Executors.newSingleThreadExecutor(), 1);\r\n    byte[] chunk = new byte[3];\r\n    ArrayList<String> words = new ArrayList<>();\r\n    try (InputStream inputStream = DataBufferUtils.subscriberInputStream(publisher, 1)) {\r\n        words.add(new String(chunk, 0, inputStream.read(chunk), StandardCharsets.UTF_8));\r\n        assertThat(inputStream.read()).isEqualTo(' ' & 0xFF);\r\n        words.add(new String(chunk, 0, inputStream.read(chunk), StandardCharsets.UTF_8));\r\n        assertThat(inputStream.read()).isEqualTo(' ' & 0xFF);\r\n        words.add(new String(chunk, 0, inputStream.read(chunk), StandardCharsets.UTF_8));\r\n        assertThat(inputStream.read()).isEqualTo(-1);\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    assertThat(words).containsExactlyElementsOf(List.of(\"foo\", \"bar\", \"baz\"));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid inputStreamSubscriberClose(DataBufferFactory bufferFactory) throws InterruptedException {\r\n    for (int i = 1; i < 100; i++) {\r\n        CountDownLatch latch = new CountDownLatch(1);\r\n        super.bufferFactory = bufferFactory;\r\n        var input = List.of(\"foo\", \"bar\", \"baz\");\r\n        Publisher<DataBuffer> publisher = DataBufferUtils.outputStreamPublisher(out -> {\r\n            try {\r\n                assertThatIOException().isThrownBy(() -> {\r\n                    for (String word : input) {\r\n                        out.write(word.getBytes(StandardCharsets.UTF_8));\r\n                        out.flush();\r\n                    }\r\n                }).withMessage(\"Subscription has been terminated\");\r\n            } finally {\r\n                latch.countDown();\r\n            }\r\n        }, super.bufferFactory, Executors.newSingleThreadExecutor(), 1);\r\n        byte[] chunk = new byte[3];\r\n        ArrayList<String> words = new ArrayList<>();\r\n        try (InputStream in = DataBufferUtils.subscriberInputStream(publisher, ThreadLocalRandom.current().nextInt(1, 4))) {\r\n            in.read(chunk);\r\n            String word = new String(chunk, StandardCharsets.UTF_8);\r\n            words.add(word);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        assertThat(words).containsExactlyElementsOf(List.of(\"foo\"));\r\n        latch.await();\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAndWriteByteChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    Path source = Paths.get(DataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\").toURI());\r\n    Flux<DataBuffer> sourceFlux = DataBufferUtils.readByteChannel(() -> FileChannel.open(source, StandardOpenOption.READ), super.bufferFactory, 3);\r\n    Path destination = Files.createTempFile(\"DataBufferUtilsTests\", null);\r\n    WritableByteChannel channel = Files.newByteChannel(destination, StandardOpenOption.WRITE);\r\n    DataBufferUtils.write(sourceFlux, channel).subscribe(DataBufferUtils.releaseConsumer(), throwable -> {\r\n        throw new AssertionError(throwable.getMessage(), throwable);\r\n    }, () -> {\r\n        try {\r\n            String expected = String.join(\"\", Files.readAllLines(source));\r\n            String result = String.join(\"\", Files.readAllLines(destination));\r\n            assertThat(result).isEqualTo(expected);\r\n        } catch (IOException e) {\r\n            throw new AssertionError(e.getMessage(), e);\r\n        } finally {\r\n            DataBufferUtils.closeChannel(channel);\r\n        }\r\n    });\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAndWriteAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    Path source = Paths.get(DataBufferUtilsTests.class.getResource(\"DataBufferUtilsTests.txt\").toURI());\r\n    Flux<DataBuffer> sourceFlux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(source, StandardOpenOption.READ), super.bufferFactory, 3);\r\n    Path destination = Files.createTempFile(\"DataBufferUtilsTests\", null);\r\n    AsynchronousFileChannel channel = AsynchronousFileChannel.open(destination, StandardOpenOption.WRITE);\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    DataBufferUtils.write(sourceFlux, channel).subscribe(DataBufferUtils::release, throwable -> {\r\n        throw new AssertionError(throwable.getMessage(), throwable);\r\n    }, () -> {\r\n        try {\r\n            String expected = String.join(\"\", Files.readAllLines(source));\r\n            String result = String.join(\"\", Files.readAllLines(destination));\r\n            assertThat(result).isEqualTo(expected);\r\n            latch.countDown();\r\n        } catch (IOException e) {\r\n            throw new AssertionError(e.getMessage(), e);\r\n        } finally {\r\n            DataBufferUtils.closeChannel(channel);\r\n        }\r\n    });\r\n    latch.await();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid takeUntilByteCount(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(Flux.just(stringBuffer(\"foo\"), stringBuffer(\"bar\")), 5L);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"ba\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid takeUntilByteCountCanceled(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> source = Flux.concat(deferStringBuffer(\"foo\"), deferStringBuffer(\"bar\"));\r\n    Flux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(source, 5L);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid takeUntilByteCountError(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> source = Flux.concat(Mono.defer(() -> Mono.just(stringBuffer(\"foo\"))), Mono.error(new RuntimeException()));\r\n    Flux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(source, 5L);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).expectError(RuntimeException.class).verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid takeUntilByteCountExact(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> source = Flux.concat(deferStringBuffer(\"foo\"), deferStringBuffer(\"bar\"), deferStringBuffer(\"baz\"));\r\n    Flux<DataBuffer> result = DataBufferUtils.takeUntilByteCount(source, 6L);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).consumeNextWith(stringConsumer(\"bar\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid skipUntilByteCount(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> source = Flux.concat(deferStringBuffer(\"foo\"), deferStringBuffer(\"bar\"), deferStringBuffer(\"baz\"));\r\n    Flux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(source, 5L);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"r\")).consumeNextWith(stringConsumer(\"baz\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid skipUntilByteCountCancelled(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> source = Flux.concat(deferStringBuffer(\"foo\"), deferStringBuffer(\"bar\"));\r\n    Flux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(source, 5L);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"r\")).thenCancel().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid skipUntilByteCountErrorInFlux(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    Flux<DataBuffer> flux = Flux.just(foo).concatWith(Mono.error(new RuntimeException()));\r\n    Flux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(flux, 3L);\r\n    StepVerifier.create(result).expectError(RuntimeException.class).verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid skipUntilByteCountShouldSkipAll(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz);\r\n    Flux<DataBuffer> result = DataBufferUtils.skipUntilByteCount(flux, 9L);\r\n    StepVerifier.create(result).expectComplete().verify(Duration.ofSeconds(5));\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid releaseConsumer(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz);\r\n    flux.subscribe(DataBufferUtils.releaseConsumer());\r\n    assertReleased(foo);\r\n    assertReleased(bar);\r\n    assertReleased(baz);\r\n}\nprivate static void assertReleased(DataBuffer dataBuffer) {\r\n    if (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\r\n        ByteBuf byteBuf = nettyDataBuffer.getNativeBuffer();\r\n        assertThat(byteBuf.refCnt()).isEqualTo(0);\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid SPR16070(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    ReadableByteChannel channel = mock();\r\n    given(channel.read(any())).willAnswer(putByte('a')).willAnswer(putByte('b')).willAnswer(putByte('c')).willReturn(-1);\r\n    Flux<DataBuffer> read = DataBufferUtils.readByteChannel(() -> channel, super.bufferFactory, 1);\r\n    StepVerifier.create(read).consumeNextWith(stringConsumer(\"a\")).consumeNextWith(stringConsumer(\"b\")).consumeNextWith(stringConsumer(\"c\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}\nprivate Answer<Integer> putByte(int b) {\r\n    return invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        buffer.put((byte) b);\r\n        return 1;\r\n    };\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid join(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz);\r\n    Mono<DataBuffer> result = DataBufferUtils.join(flux);\r\n    StepVerifier.create(result).consumeNextWith(buf -> {\r\n        assertThat(buf.toString(StandardCharsets.UTF_8)).isEqualTo(\"foobarbaz\");\r\n        release(buf);\r\n    }).verifyComplete();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid joinWithLimit(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    DataBuffer baz = stringBuffer(\"baz\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar, baz);\r\n    Mono<DataBuffer> result = DataBufferUtils.join(flux, 8);\r\n    StepVerifier.create(result).verifyError(DataBufferLimitException.class);\r\n}\n// gh-26060\r\n@Test\r\nvoid joinWithLimitDoesNotOverRelease() {\r\n    NettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT);\r\n    byte[] bytes = \"foo-bar-baz\".getBytes(StandardCharsets.UTF_8);\r\n    NettyDataBuffer buffer = bufferFactory.allocateBuffer(bytes.length);\r\n    // should be at 2 now\r\n    buffer.getNativeBuffer().retain();\r\n    buffer.write(bytes);\r\n    Mono<DataBuffer> result = DataBufferUtils.join(Flux.just(buffer), 8);\r\n    StepVerifier.create(result).verifyError(DataBufferLimitException.class);\r\n    assertThat(buffer.getNativeBuffer().refCnt()).isEqualTo(1);\r\n    buffer.release();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid joinErrors(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    Flux<DataBuffer> flux = Flux.just(foo, bar).concatWith(Flux.error(new RuntimeException()));\r\n    Mono<DataBuffer> result = DataBufferUtils.join(flux);\r\n    StepVerifier.create(result).expectError(RuntimeException.class).verify();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid joinCanceled(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> source = Flux.concat(deferStringBuffer(\"foo\"), deferStringBuffer(\"bar\"), deferStringBuffer(\"baz\"));\r\n    Mono<DataBuffer> result = DataBufferUtils.join(source);\r\n    StepVerifier.create(result).thenCancel().verify();\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid matcher(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foo\");\r\n    DataBuffer bar = stringBuffer(\"bar\");\r\n    byte[] delims = \"ooba\".getBytes(StandardCharsets.UTF_8);\r\n    DataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delims);\r\n    int result = matcher.match(foo);\r\n    assertThat(result).isEqualTo(-1);\r\n    result = matcher.match(bar);\r\n    assertThat(result).isEqualTo(1);\r\n    release(foo, bar);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid matcher2(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foooobar\");\r\n    byte[] delims = \"oo\".getBytes(StandardCharsets.UTF_8);\r\n    DataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delims);\r\n    int endIndex = matcher.match(foo);\r\n    assertThat(endIndex).isEqualTo(2);\r\n    foo.readPosition(endIndex + 1);\r\n    endIndex = matcher.match(foo);\r\n    assertThat(endIndex).isEqualTo(4);\r\n    foo.readPosition(endIndex + 1);\r\n    endIndex = matcher.match(foo);\r\n    assertThat(endIndex).isEqualTo(-1);\r\n    release(foo);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid matcher3(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    DataBuffer foo = stringBuffer(\"foooobar\");\r\n    byte[] delims = \"oo\".getBytes(StandardCharsets.UTF_8);\r\n    DataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delims);\r\n    int endIndex = matcher.match(foo);\r\n    assertThat(endIndex).isEqualTo(2);\r\n    foo.readPosition(endIndex + 1);\r\n    endIndex = matcher.match(foo);\r\n    assertThat(endIndex).isEqualTo(4);\r\n    foo.readPosition(endIndex + 1);\r\n    endIndex = matcher.match(foo);\r\n    assertThat(endIndex).isEqualTo(-1);\r\n    release(foo);\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid propagateContextByteChannel(DataBufferFactory bufferFactory) throws IOException {\r\n    Path path = Paths.get(this.resource.getURI());\r\n    try (SeekableByteChannel out = Files.newByteChannel(this.tempFile, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {\r\n        Flux<DataBuffer> result = DataBufferUtils.read(path, bufferFactory, 1024, StandardOpenOption.READ).transformDeferredContextual((f, ctx) -> {\r\n            assertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\r\n            return f;\r\n        }).transform(f -> DataBufferUtils.write(f, out)).transformDeferredContextual((f, ctx) -> {\r\n            assertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\r\n            return f;\r\n        }).contextWrite(Context.of(\"key\", \"TEST\"));\r\n        StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).verifyComplete();\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid propagateContextAsynchronousFileChannel(DataBufferFactory bufferFactory) throws IOException {\r\n    Path path = Paths.get(this.resource.getURI());\r\n    try (AsynchronousFileChannel out = AsynchronousFileChannel.open(this.tempFile, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {\r\n        Flux<DataBuffer> result = DataBufferUtils.read(path, bufferFactory, 1024, StandardOpenOption.READ).transformDeferredContextual((f, ctx) -> {\r\n            assertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\r\n            return f;\r\n        }).transform(f -> DataBufferUtils.write(f, out)).transformDeferredContextual((f, ctx) -> {\r\n            assertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\r\n            return f;\r\n        }).contextWrite(Context.of(\"key\", \"TEST\"));\r\n        StepVerifier.create(result).consumeNextWith(DataBufferUtils::release).verifyComplete();\r\n    }\r\n}\n@ParameterizedDataBufferAllocatingTest\r\nvoid propagateContextPath(DataBufferFactory bufferFactory) throws IOException {\r\n    Path path = Paths.get(this.resource.getURI());\r\n    Path out = Files.createTempFile(\"data-buffer-utils-tests\", \".tmp\");\r\n    Flux<Void> result = DataBufferUtils.read(path, bufferFactory, 1024, StandardOpenOption.READ).transformDeferredContextual((f, ctx) -> {\r\n        assertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\r\n        return f;\r\n    }).transform(f -> DataBufferUtils.write(f, out)).transformDeferredContextual((f, ctx) -> {\r\n        assertThat(ctx.getOrDefault(\"key\", \"EMPTY\")).isEqualTo(\"TEST\");\r\n        return f;\r\n    }).contextWrite(Context.of(\"key\", \"TEST\"));\r\n    StepVerifier.create(result).verifyComplete();\r\n}\nprivate static class ZeroDemandSubscriber extends BaseSubscriber<DataBuffer> {\r\n\r\n    @Override\r\n    protected void hookOnSubscribe(Subscription subscription) {\r\n        // Just subscribe without requesting\r\n    }\r\n}",
    "comment": "\n * @author Arjen Poutsma\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readInputStream(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readInputStream(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.readInputStream(this.resource::getInputStream, super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readByteChannel(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readByteChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> result = DataBufferUtils.readByteChannel(() -> FileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    verifyReadData(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readByteChannelError(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readByteChannelError(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    ReadableByteChannel channel = mock();\r\n    given(channel.read(any())).willAnswer(invocation -> {\r\n        ByteBuffer buffer = invocation.getArgument(0);\r\n        buffer.put(\"foo\".getBytes(StandardCharsets.UTF_8));\r\n        buffer.flip();\r\n        return 3;\r\n    }).willThrow(new IOException());\r\n    Flux<DataBuffer> result = DataBufferUtils.readByteChannel(() -> channel, super.bufferFactory, 3);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).expectError(IOException.class).verify(Duration.ofSeconds(3));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readByteChannelCancel(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readByteChannelCancel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> result = DataBufferUtils.readByteChannel(() -> FileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readAsynchronousFileChannel(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readAsynchronousFileChannelPosition(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelPosition(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), 9, super.bufferFactory, 3);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"qux\")).expectComplete().verify(Duration.ofSeconds(5));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readAsynchronousFileChannelError(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelError(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    AsynchronousFileChannel channel = mock();\r\n    willAnswer(invocation -> {\r\n        ByteBuffer byteBuffer = invocation.getArgument(0);\r\n        byteBuffer.put(\"foo\".getBytes(StandardCharsets.UTF_8));\r\n        long pos = invocation.getArgument(1);\r\n        assertThat(pos).isEqualTo(0);\r\n        Object attachment = invocation.getArgument(2);\r\n        CompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\r\n        completionHandler.completed(3, attachment);\r\n        return null;\r\n    }).willAnswer(invocation -> {\r\n        Object attachment = invocation.getArgument(2);\r\n        CompletionHandler<Integer, Object> completionHandler = invocation.getArgument(3);\r\n        completionHandler.failed(new IOException(), attachment);\r\n        return null;\r\n    }).given(channel).read(any(), anyLong(), any(), any());\r\n    Flux<DataBuffer> result = DataBufferUtils.readAsynchronousFileChannel(() -> channel, super.bufferFactory, 3);\r\n    StepVerifier.create(result).consumeNextWith(stringConsumer(\"foo\")).expectError(IOException.class).verify(Duration.ofSeconds(3));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readAsynchronousFileChannelCancel(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelCancel(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    StepVerifier.create(flux).consumeNextWith(stringConsumer(\"foo\")).thenCancel().verify();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readAsynchronousFileChannelCancelWithoutDemand(DataBufferFactory)",
    "entityType": "method",
    "code": "// gh-22107\r\n@ParameterizedDataBufferAllocatingTest\r\nvoid readAsynchronousFileChannelCancelWithoutDemand(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    URI uri = this.resource.getURI();\r\n    Flux<DataBuffer> flux = DataBufferUtils.readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(Paths.get(uri), StandardOpenOption.READ), super.bufferFactory, 3);\r\n    BaseSubscriber<DataBuffer> subscriber = new ZeroDemandSubscriber();\r\n    flux.subscribe(subscriber);\r\n    subscriber.cancel();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readPath(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readPath(DataBufferFactory bufferFactory) throws Exception {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(this.resource.getFile().toPath(), super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.DataBufferUtilsTests#readResource(DataBufferFactory)",
    "entityType": "method",
    "code": "@ParameterizedDataBufferAllocatingTest\r\nvoid readResource(DataBufferFactory bufferFactory) {\r\n    super.bufferFactory = bufferFactory;\r\n    Flux<DataBuffer> flux = DataBufferUtils.read(this.resource, super.bufferFactory, 3);\r\n    verifyReadData(flux);\r\n}",
    "comment": ""
  }
]