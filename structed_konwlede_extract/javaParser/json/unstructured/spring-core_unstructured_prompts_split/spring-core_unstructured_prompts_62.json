[
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#slice(int,int)",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic NettyDataBuffer slice(int index, int length) {\r\n    ByteBuf slice = this.byteBuf.slice(index, length);\r\n    return new NettyDataBuffer(slice, this.dataBufferFactory);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#retainedSlice(int,int)",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic NettyDataBuffer retainedSlice(int index, int length) {\r\n    ByteBuf slice = this.byteBuf.retainedSlice(index, length);\r\n    return new NettyDataBuffer(slice, this.dataBufferFactory);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#split(int)",
    "entityType": "method",
    "code": "@Override\r\npublic NettyDataBuffer split(int index) {\r\n    ByteBuf split = this.byteBuf.retainedSlice(0, index);\r\n    int writerIndex = this.byteBuf.writerIndex();\r\n    int readerIndex = this.byteBuf.readerIndex();\r\n    split.writerIndex(Math.min(writerIndex, index));\r\n    split.readerIndex(Math.min(readerIndex, index));\r\n    this.byteBuf = this.byteBuf.slice(index, this.byteBuf.capacity() - index);\r\n    this.byteBuf.writerIndex(Math.max(writerIndex, index) - index);\r\n    this.byteBuf.readerIndex(Math.max(readerIndex, index) - index);\r\n    return new NettyDataBuffer(split, this.dataBufferFactory);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#asByteBuffer()",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic ByteBuffer asByteBuffer() {\r\n    return this.byteBuf.nioBuffer();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#asByteBuffer(int,int)",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic ByteBuffer asByteBuffer(int index, int length) {\r\n    return this.byteBuf.nioBuffer(index, length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#toByteBuffer(int,int)",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic ByteBuffer toByteBuffer(int index, int length) {\r\n    ByteBuffer result = this.byteBuf.isDirect() ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);\r\n    this.byteBuf.getBytes(index, result);\r\n    return result.flip();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#toByteBuffer(int,ByteBuffer,int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void toByteBuffer(int srcPos, ByteBuffer dest, int destPos, int length) {\r\n    Assert.notNull(dest, \"Dest must not be null\");\r\n    dest = dest.duplicate().clear();\r\n    dest.put(destPos, this.byteBuf.nioBuffer(srcPos, length), 0, length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#readableByteBuffers()",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer.ByteBufferIterator readableByteBuffers() {\r\n    ByteBuffer[] readable = this.byteBuf.nioBuffers(this.byteBuf.readerIndex(), this.byteBuf.readableBytes());\r\n    return new ByteBufferIterator(readable, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#writableByteBuffers()",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer.ByteBufferIterator writableByteBuffers() {\r\n    ByteBuffer[] writable = this.byteBuf.nioBuffers(this.byteBuf.writerIndex(), this.byteBuf.writableBytes());\r\n    return new ByteBufferIterator(writable, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#toString(Charset)",
    "entityType": "method",
    "code": "@Override\r\npublic String toString(Charset charset) {\r\n    Assert.notNull(charset, \"Charset must not be null\");\r\n    return this.byteBuf.toString(charset);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#toString(int,int,Charset)",
    "entityType": "method",
    "code": "@Override\r\npublic String toString(int index, int length, Charset charset) {\r\n    Assert.notNull(charset, \"Charset must not be null\");\r\n    return this.byteBuf.toString(index, length, charset);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#isAllocated()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAllocated() {\r\n    return this.byteBuf.refCnt() > 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#retain()",
    "entityType": "method",
    "code": "@Override\r\npublic PooledDataBuffer retain() {\r\n    return new NettyDataBuffer(this.byteBuf.retain(), this.dataBufferFactory);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#touch(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic PooledDataBuffer touch(Object hint) {\r\n    this.byteBuf.touch(hint);\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#release()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean release() {\r\n    return this.byteBuf.release();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof NettyDataBuffer that && this.byteBuf.equals(that.byteBuf)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.byteBuf.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBuffer#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.byteBuf.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteBufferIterator",
    "entityType": "class",
    "code": "private final ByteBuffer[] byteBuffers;\nprivate final boolean readOnly;\nprivate int cursor = 0;\npublic ByteBufferIterator(ByteBuffer[] byteBuffers, boolean readOnly) {\r\n    this.byteBuffers = byteBuffers;\r\n    this.readOnly = readOnly;\r\n}\n@Override\r\npublic boolean hasNext() {\r\n    return this.cursor < this.byteBuffers.length;\r\n}\n@Override\r\npublic ByteBuffer next() {\r\n    int index = this.cursor;\r\n    if (index < this.byteBuffers.length) {\r\n        this.cursor = index + 1;\r\n        ByteBuffer next = this.byteBuffers[index];\r\n        return this.readOnly ? next.asReadOnlyBuffer() : next;\r\n    } else {\r\n        throw new NoSuchElementException();\r\n    }\r\n}\n@Override\r\npublic void close() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteBufferIterator#hasNext()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNext() {\r\n    return this.cursor < this.byteBuffers.length;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteBufferIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic ByteBuffer next() {\r\n    int index = this.cursor;\r\n    if (index < this.byteBuffers.length) {\r\n        this.cursor = index + 1;\r\n        ByteBuffer next = this.byteBuffers[index];\r\n        return this.readOnly ? next.asReadOnlyBuffer() : next;\r\n    } else {\r\n        throw new NoSuchElementException();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteBufferIterator#close()",
    "entityType": "method",
    "code": "@Override\r\npublic void close() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory",
    "entityType": "class",
    "code": "private final ByteBufAllocator byteBufAllocator;\n/**\r\n * Create a new {@code NettyDataBufferFactory} based on the given factory.\r\n * @param byteBufAllocator the factory to use\r\n * @see io.netty.buffer.PooledByteBufAllocator\r\n * @see io.netty.buffer.UnpooledByteBufAllocator\r\n */\r\npublic NettyDataBufferFactory(ByteBufAllocator byteBufAllocator) {\r\n    Assert.notNull(byteBufAllocator, \"ByteBufAllocator must not be null\");\r\n    this.byteBufAllocator = byteBufAllocator;\r\n}\n/**\r\n * Return the {@code ByteBufAllocator} used by this factory.\r\n */\r\npublic ByteBufAllocator getByteBufAllocator() {\r\n    return this.byteBufAllocator;\r\n}\n@Override\r\n@Deprecated\r\npublic NettyDataBuffer allocateBuffer() {\r\n    ByteBuf byteBuf = this.byteBufAllocator.buffer();\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}\n@Override\r\npublic NettyDataBuffer allocateBuffer(int initialCapacity) {\r\n    ByteBuf byteBuf = this.byteBufAllocator.buffer(initialCapacity);\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}\n@Override\r\npublic NettyDataBuffer wrap(ByteBuffer byteBuffer) {\r\n    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBuffer);\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}\n@Override\r\npublic DataBuffer wrap(byte[] bytes) {\r\n    ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}\n/**\r\n * Wrap the given Netty {@link ByteBuf} in a {@code NettyDataBuffer}.\r\n * @param byteBuf the Netty byte buffer to wrap\r\n * @return the wrapped buffer\r\n */\r\npublic NettyDataBuffer wrap(ByteBuf byteBuf) {\r\n    byteBuf.touch();\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}\n/**\r\n * {@inheritDoc}\r\n * <p>This implementation uses Netty's {@link CompositeByteBuf}.\r\n */\r\n@Override\r\npublic DataBuffer join(List<? extends DataBuffer> dataBuffers) {\r\n    Assert.notEmpty(dataBuffers, \"DataBuffer List must not be empty\");\r\n    int bufferCount = dataBuffers.size();\r\n    if (bufferCount == 1) {\r\n        return dataBuffers.get(0);\r\n    }\r\n    CompositeByteBuf composite = this.byteBufAllocator.compositeBuffer(bufferCount);\r\n    for (DataBuffer dataBuffer : dataBuffers) {\r\n        Assert.isInstanceOf(NettyDataBuffer.class, dataBuffer);\r\n        composite.addComponent(true, ((NettyDataBuffer) dataBuffer).getNativeBuffer());\r\n    }\r\n    return new NettyDataBuffer(composite, this);\r\n}\n@Override\r\npublic boolean isDirect() {\r\n    return this.byteBufAllocator.isDirectBufferPooled();\r\n}\n/**\r\n * Return the given Netty {@link DataBuffer} as a {@link ByteBuf}.\r\n * <p>Returns the {@linkplain NettyDataBuffer#getNativeBuffer() native buffer}\r\n * if {@code dataBuffer} is a {@link NettyDataBuffer}; returns\r\n * {@link Unpooled#wrappedBuffer(ByteBuffer)} otherwise.\r\n * @param dataBuffer the {@code DataBuffer} to return a {@code ByteBuf} for\r\n * @return the netty {@code ByteBuf}\r\n */\r\npublic static ByteBuf toByteBuf(DataBuffer dataBuffer) {\r\n    if (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\r\n        return nettyDataBuffer.getNativeBuffer();\r\n    } else {\r\n        ByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\r\n        dataBuffer.toByteBuffer(byteBuffer);\r\n        return Unpooled.wrappedBuffer(byteBuffer);\r\n    }\r\n}\n@Override\r\npublic String toString() {\r\n    return \"NettyDataBufferFactory (\" + this.byteBufAllocator + \")\";\r\n}",
    "comment": "\n * Implementation of the {@code DataBufferFactory} interface based on a\n * Netty 4 {@link ByteBufAllocator}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 5.0\n * @see io.netty.buffer.PooledByteBufAllocator\n * @see io.netty.buffer.UnpooledByteBufAllocator\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#getByteBufAllocator()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code ByteBufAllocator} used by this factory.\r\n */\r\npublic ByteBufAllocator getByteBufAllocator() {\r\n    return this.byteBufAllocator;\r\n}",
    "comment": "\n\t * Return the {@code ByteBufAllocator} used by this factory.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#allocateBuffer()",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic NettyDataBuffer allocateBuffer() {\r\n    ByteBuf byteBuf = this.byteBufAllocator.buffer();\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#allocateBuffer(int)",
    "entityType": "method",
    "code": "@Override\r\npublic NettyDataBuffer allocateBuffer(int initialCapacity) {\r\n    ByteBuf byteBuf = this.byteBufAllocator.buffer(initialCapacity);\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#wrap(ByteBuffer)",
    "entityType": "method",
    "code": "@Override\r\npublic NettyDataBuffer wrap(ByteBuffer byteBuffer) {\r\n    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBuffer);\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#wrap(byte[])",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer wrap(byte[] bytes) {\r\n    ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#wrap(ByteBuf)",
    "entityType": "method",
    "code": "/**\r\n * Wrap the given Netty {@link ByteBuf} in a {@code NettyDataBuffer}.\r\n * @param byteBuf the Netty byte buffer to wrap\r\n * @return the wrapped buffer\r\n */\r\npublic NettyDataBuffer wrap(ByteBuf byteBuf) {\r\n    byteBuf.touch();\r\n    return new NettyDataBuffer(byteBuf, this);\r\n}",
    "comment": "\n\t * Wrap the given Netty {@link ByteBuf} in a {@code NettyDataBuffer}.\n\t * @param byteBuf the Netty byte buffer to wrap\n\t * @return the wrapped buffer\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#join(List<? extends DataBuffer>)",
    "entityType": "method",
    "code": "/**\r\n * {@inheritDoc}\r\n * <p>This implementation uses Netty's {@link CompositeByteBuf}.\r\n */\r\n@Override\r\npublic DataBuffer join(List<? extends DataBuffer> dataBuffers) {\r\n    Assert.notEmpty(dataBuffers, \"DataBuffer List must not be empty\");\r\n    int bufferCount = dataBuffers.size();\r\n    if (bufferCount == 1) {\r\n        return dataBuffers.get(0);\r\n    }\r\n    CompositeByteBuf composite = this.byteBufAllocator.compositeBuffer(bufferCount);\r\n    for (DataBuffer dataBuffer : dataBuffers) {\r\n        Assert.isInstanceOf(NettyDataBuffer.class, dataBuffer);\r\n        composite.addComponent(true, ((NettyDataBuffer) dataBuffer).getNativeBuffer());\r\n    }\r\n    return new NettyDataBuffer(composite, this);\r\n}",
    "comment": "\n\t * {@inheritDoc}\n\t * <p>This implementation uses Netty's {@link CompositeByteBuf}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#isDirect()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isDirect() {\r\n    return this.byteBufAllocator.isDirectBufferPooled();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#toByteBuf(DataBuffer)",
    "entityType": "method",
    "code": "/**\r\n * Return the given Netty {@link DataBuffer} as a {@link ByteBuf}.\r\n * <p>Returns the {@linkplain NettyDataBuffer#getNativeBuffer() native buffer}\r\n * if {@code dataBuffer} is a {@link NettyDataBuffer}; returns\r\n * {@link Unpooled#wrappedBuffer(ByteBuffer)} otherwise.\r\n * @param dataBuffer the {@code DataBuffer} to return a {@code ByteBuf} for\r\n * @return the netty {@code ByteBuf}\r\n */\r\npublic static ByteBuf toByteBuf(DataBuffer dataBuffer) {\r\n    if (dataBuffer instanceof NettyDataBuffer nettyDataBuffer) {\r\n        return nettyDataBuffer.getNativeBuffer();\r\n    } else {\r\n        ByteBuffer byteBuffer = ByteBuffer.allocate(dataBuffer.readableByteCount());\r\n        dataBuffer.toByteBuffer(byteBuffer);\r\n        return Unpooled.wrappedBuffer(byteBuffer);\r\n    }\r\n}",
    "comment": "\n\t * Return the given Netty {@link DataBuffer} as a {@link ByteBuf}.\n\t * <p>Returns the {@linkplain NettyDataBuffer#getNativeBuffer() native buffer}\n\t * if {@code dataBuffer} is a {@link NettyDataBuffer}; returns\n\t * {@link Unpooled#wrappedBuffer(ByteBuffer)} otherwise.\n\t * @param dataBuffer the {@code DataBuffer} to return a {@code ByteBuf} for\n\t * @return the netty {@code ByteBuf}\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.NettyDataBufferFactory#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"NettyDataBufferFactory (\" + this.byteBufAllocator + \")\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamPublisher",
    "entityType": "class",
    "code": "private static final int DEFAULT_CHUNK_SIZE = 1024;\nprivate final OutputStreamHandler outputStreamHandler;\nprivate final ByteMapper<T> byteMapper;\nprivate final Executor executor;\nprivate final int chunkSize;\n/**\r\n * Create an instance.\r\n * @param outputStreamHandler invoked when the first buffer is requested\r\n * @param byteMapper maps written bytes to {@code T}\r\n * @param executor used to invoke the {@code outputStreamHandler}\r\n * @param chunkSize the chunk sizes to be produced by the publisher\r\n */\r\nOutputStreamPublisher(OutputStreamHandler outputStreamHandler, ByteMapper<T> byteMapper, Executor executor, @Nullable Integer chunkSize) {\r\n    Assert.notNull(outputStreamHandler, \"OutputStreamHandler must not be null\");\r\n    Assert.notNull(byteMapper, \"ByteMapper must not be null\");\r\n    Assert.notNull(executor, \"Executor must not be null\");\r\n    Assert.isTrue(chunkSize == null || chunkSize > 0, \"ChunkSize must be larger than 0\");\r\n    this.outputStreamHandler = outputStreamHandler;\r\n    this.byteMapper = byteMapper;\r\n    this.executor = executor;\r\n    this.chunkSize = (chunkSize != null ? chunkSize : DEFAULT_CHUNK_SIZE);\r\n}\n@Override\r\npublic void subscribe(Subscriber<? super T> subscriber) {\r\n    // We don't use Assert.notNull(), because a NullPointerException is required\r\n    // for Reactive Streams compliance.\r\n    Objects.requireNonNull(subscriber, \"Subscriber must not be null\");\r\n    OutputStreamSubscription<T> subscription = new OutputStreamSubscription<>(subscriber, this.outputStreamHandler, this.byteMapper, this.chunkSize);\r\n    subscriber.onSubscribe(subscription);\r\n    this.executor.execute(subscription::invokeHandler);\r\n}\n/**\r\n * Contract to provide callback access to the {@link OutputStream}.\r\n */\r\n@FunctionalInterface\r\npublic interface OutputStreamHandler {\r\n\r\n    void handle(OutputStream outputStream) throws Exception;\r\n}\n/**\r\n * Maps from bytes to byte buffers.\r\n * @param <T> the type of byte buffer to map to\r\n */\r\npublic interface ByteMapper<T> {\r\n\r\n    T map(int b);\r\n\r\n    T map(byte[] b, int off, int len);\r\n}\nprivate static final class OutputStreamSubscription<T> extends OutputStream implements Subscription {\r\n\r\n    private static final Object READY = new Object();\r\n\r\n    private final Subscriber<? super T> actual;\r\n\r\n    private final OutputStreamHandler outputStreamHandler;\r\n\r\n    private final ByteMapper<T> byteMapper;\r\n\r\n    private final int chunkSize;\r\n\r\n    private final AtomicLong requested = new AtomicLong();\r\n\r\n    private final AtomicReference<Object> parkedThread = new AtomicReference<>();\r\n\r\n    @Nullable\r\n    private volatile Throwable error;\r\n\r\n    private long produced;\r\n\r\n    OutputStreamSubscription(Subscriber<? super T> actual, OutputStreamHandler outputStreamHandler, ByteMapper<T> byteMapper, int chunkSize) {\r\n        this.actual = actual;\r\n        this.outputStreamHandler = outputStreamHandler;\r\n        this.byteMapper = byteMapper;\r\n        this.chunkSize = chunkSize;\r\n    }\r\n\r\n    @Override\r\n    public void write(int b) throws IOException {\r\n        checkDemandAndAwaitIfNeeded();\r\n        T next = this.byteMapper.map(b);\r\n        this.actual.onNext(next);\r\n        this.produced++;\r\n    }\r\n\r\n    @Override\r\n    public void write(byte[] b) throws IOException {\r\n        write(b, 0, b.length);\r\n    }\r\n\r\n    @Override\r\n    public void write(byte[] b, int off, int len) throws IOException {\r\n        checkDemandAndAwaitIfNeeded();\r\n        T next = this.byteMapper.map(b, off, len);\r\n        this.actual.onNext(next);\r\n        this.produced++;\r\n    }\r\n\r\n    private void checkDemandAndAwaitIfNeeded() throws IOException {\r\n        long r = this.requested.get();\r\n        if (isTerminated(r) || isCancelled(r)) {\r\n            throw new IOException(\"Subscription has been terminated\");\r\n        }\r\n        long p = this.produced;\r\n        if (p == r) {\r\n            if (p > 0) {\r\n                r = tryProduce(p);\r\n                this.produced = 0;\r\n            }\r\n            while (true) {\r\n                if (isTerminated(r) || isCancelled(r)) {\r\n                    throw new IOException(\"Subscription has been terminated\");\r\n                }\r\n                if (r != 0) {\r\n                    return;\r\n                }\r\n                await();\r\n                r = this.requested.get();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void invokeHandler() {\r\n        // assume sync write within try-with-resource block\r\n        // use BufferedOutputStream, so that written bytes are buffered\r\n        // before publishing as byte buffer\r\n        try (OutputStream outputStream = new BufferedOutputStream(this, this.chunkSize)) {\r\n            this.outputStreamHandler.handle(outputStream);\r\n        } catch (Exception ex) {\r\n            long previousState = tryTerminate();\r\n            if (isCancelled(previousState)) {\r\n                return;\r\n            }\r\n            if (isTerminated(previousState)) {\r\n                // failure due to illegal requestN\r\n                Throwable error = this.error;\r\n                if (error != null) {\r\n                    this.actual.onError(error);\r\n                    return;\r\n                }\r\n            }\r\n            this.actual.onError(ex);\r\n            return;\r\n        }\r\n        long previousState = tryTerminate();\r\n        if (isCancelled(previousState)) {\r\n            return;\r\n        }\r\n        if (isTerminated(previousState)) {\r\n            // failure due to illegal requestN\r\n            Throwable error = this.error;\r\n            if (error != null) {\r\n                this.actual.onError(error);\r\n                return;\r\n            }\r\n        }\r\n        this.actual.onComplete();\r\n    }\r\n\r\n    @Override\r\n    public void request(long n) {\r\n        if (n <= 0) {\r\n            this.error = new IllegalArgumentException(\"request should be a positive number\");\r\n            long previousState = tryTerminate();\r\n            if (isTerminated(previousState) || isCancelled(previousState)) {\r\n                return;\r\n            }\r\n            if (previousState > 0) {\r\n                // error should eventually be observed and propagated\r\n                return;\r\n            }\r\n            // resume parked thread, so it can observe error and propagate it\r\n            resume();\r\n            return;\r\n        }\r\n        if (addCap(n) == 0) {\r\n            // resume parked thread so it can continue the work\r\n            resume();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void cancel() {\r\n        long previousState = tryCancel();\r\n        if (isCancelled(previousState) || previousState > 0) {\r\n            return;\r\n        }\r\n        // resume parked thread, so it can be unblocked and close all the resources\r\n        resume();\r\n    }\r\n\r\n    private void await() {\r\n        Thread toUnpark = Thread.currentThread();\r\n        while (true) {\r\n            Object current = this.parkedThread.get();\r\n            if (current == READY) {\r\n                break;\r\n            }\r\n            if (current != null && current != toUnpark) {\r\n                throw new IllegalStateException(\"Only one (Virtual)Thread can await!\");\r\n            }\r\n            if (this.parkedThread.compareAndSet(null, toUnpark)) {\r\n                LockSupport.park();\r\n                // we don't just break here because park() can wake up spuriously\r\n                // if we got a proper resume, get() == READY and the loop will quit above\r\n            }\r\n        }\r\n        // clear the resume indicator so that the next await call will park without a resume()\r\n        this.parkedThread.lazySet(null);\r\n    }\r\n\r\n    private void resume() {\r\n        if (this.parkedThread.get() != READY) {\r\n            Object old = this.parkedThread.getAndSet(READY);\r\n            if (old != READY) {\r\n                LockSupport.unpark((Thread) old);\r\n            }\r\n        }\r\n    }\r\n\r\n    private long tryCancel() {\r\n        while (true) {\r\n            long r = this.requested.get();\r\n            if (isCancelled(r)) {\r\n                return r;\r\n            }\r\n            if (this.requested.compareAndSet(r, Long.MIN_VALUE)) {\r\n                return r;\r\n            }\r\n        }\r\n    }\r\n\r\n    private long tryTerminate() {\r\n        while (true) {\r\n            long r = this.requested.get();\r\n            if (isCancelled(r) || isTerminated(r)) {\r\n                return r;\r\n            }\r\n            if (this.requested.compareAndSet(r, Long.MIN_VALUE | Long.MAX_VALUE)) {\r\n                return r;\r\n            }\r\n        }\r\n    }\r\n\r\n    private long tryProduce(long n) {\r\n        while (true) {\r\n            long current = this.requested.get();\r\n            if (isTerminated(current) || isCancelled(current)) {\r\n                return current;\r\n            }\r\n            if (current == Long.MAX_VALUE) {\r\n                return Long.MAX_VALUE;\r\n            }\r\n            long update = current - n;\r\n            if (update < 0L) {\r\n                update = 0L;\r\n            }\r\n            if (this.requested.compareAndSet(current, update)) {\r\n                return update;\r\n            }\r\n        }\r\n    }\r\n\r\n    private long addCap(long n) {\r\n        while (true) {\r\n            long r = this.requested.get();\r\n            if (isTerminated(r) || isCancelled(r) || r == Long.MAX_VALUE) {\r\n                return r;\r\n            }\r\n            long u = addCap(r, n);\r\n            if (this.requested.compareAndSet(r, u)) {\r\n                return r;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static boolean isTerminated(long state) {\r\n        return state == (Long.MIN_VALUE | Long.MAX_VALUE);\r\n    }\r\n\r\n    private static boolean isCancelled(long state) {\r\n        return state == Long.MIN_VALUE;\r\n    }\r\n\r\n    private static long addCap(long a, long b) {\r\n        long res = a + b;\r\n        if (res < 0L) {\r\n            return Long.MAX_VALUE;\r\n        }\r\n        return res;\r\n    }\r\n}",
    "comment": "\n * Bridges between {@link OutputStream} and {@link Publisher Publisher&lt;DataBuffer&gt;}.\n *\n * <p>When there is demand on the Reactive Streams subscription, any write to\n * the OutputStream is mapped to a buffer and published to the subscriber.\n * If there is no demand, writes block until demand materializes.\n * If the subscription is cancelled, further writes raise {@code IOException}.\n *\n * <p>Note that this class has a near duplicate in\n * {@link org.springframework.http.client.OutputStreamPublisher}.\n *\n * @author Oleh Dokuka\n * @author Arjen Poutsma\n * @since 6.1\n * @param <T> the published byte buffer type\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamPublisher#subscribe(Subscriber<? super T>)",
    "entityType": "method",
    "code": "@Override\r\npublic void subscribe(Subscriber<? super T> subscriber) {\r\n    // We don't use Assert.notNull(), because a NullPointerException is required\r\n    // for Reactive Streams compliance.\r\n    Objects.requireNonNull(subscriber, \"Subscriber must not be null\");\r\n    OutputStreamSubscription<T> subscription = new OutputStreamSubscription<>(subscriber, this.outputStreamHandler, this.byteMapper, this.chunkSize);\r\n    subscriber.onSubscribe(subscription);\r\n    this.executor.execute(subscription::invokeHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamHandler",
    "entityType": "class",
    "code": "void handle(OutputStream outputStream) throws Exception;",
    "comment": "\n\t * Contract to provide callback access to the {@link OutputStream}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamHandler#handle(OutputStream)",
    "entityType": "method",
    "code": "void handle(OutputStream outputStream) throws Exception;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteMapper",
    "entityType": "class",
    "code": "T map(int b);\nT map(byte[] b, int off, int len);",
    "comment": "\n\t * Maps from bytes to byte buffers.\n\t * @param <T> the type of byte buffer to map to\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteMapper#map(int)",
    "entityType": "method",
    "code": "T map(int b);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.ByteMapper#map(byte[],int,int)",
    "entityType": "method",
    "code": "T map(byte[] b, int off, int len);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription",
    "entityType": "class",
    "code": "private static final Object READY = new Object();\nprivate final Subscriber<? super T> actual;\nprivate final OutputStreamHandler outputStreamHandler;\nprivate final ByteMapper<T> byteMapper;\nprivate final int chunkSize;\nprivate final AtomicLong requested = new AtomicLong();\nprivate final AtomicReference<Object> parkedThread = new AtomicReference<>();\n@Nullable\r\nprivate volatile Throwable error;\nprivate long produced;\nOutputStreamSubscription(Subscriber<? super T> actual, OutputStreamHandler outputStreamHandler, ByteMapper<T> byteMapper, int chunkSize) {\r\n    this.actual = actual;\r\n    this.outputStreamHandler = outputStreamHandler;\r\n    this.byteMapper = byteMapper;\r\n    this.chunkSize = chunkSize;\r\n}\n@Override\r\npublic void write(int b) throws IOException {\r\n    checkDemandAndAwaitIfNeeded();\r\n    T next = this.byteMapper.map(b);\r\n    this.actual.onNext(next);\r\n    this.produced++;\r\n}\n@Override\r\npublic void write(byte[] b) throws IOException {\r\n    write(b, 0, b.length);\r\n}\n@Override\r\npublic void write(byte[] b, int off, int len) throws IOException {\r\n    checkDemandAndAwaitIfNeeded();\r\n    T next = this.byteMapper.map(b, off, len);\r\n    this.actual.onNext(next);\r\n    this.produced++;\r\n}\nprivate void checkDemandAndAwaitIfNeeded() throws IOException {\r\n    long r = this.requested.get();\r\n    if (isTerminated(r) || isCancelled(r)) {\r\n        throw new IOException(\"Subscription has been terminated\");\r\n    }\r\n    long p = this.produced;\r\n    if (p == r) {\r\n        if (p > 0) {\r\n            r = tryProduce(p);\r\n            this.produced = 0;\r\n        }\r\n        while (true) {\r\n            if (isTerminated(r) || isCancelled(r)) {\r\n                throw new IOException(\"Subscription has been terminated\");\r\n            }\r\n            if (r != 0) {\r\n                return;\r\n            }\r\n            await();\r\n            r = this.requested.get();\r\n        }\r\n    }\r\n}\nprivate void invokeHandler() {\r\n    // assume sync write within try-with-resource block\r\n    // use BufferedOutputStream, so that written bytes are buffered\r\n    // before publishing as byte buffer\r\n    try (OutputStream outputStream = new BufferedOutputStream(this, this.chunkSize)) {\r\n        this.outputStreamHandler.handle(outputStream);\r\n    } catch (Exception ex) {\r\n        long previousState = tryTerminate();\r\n        if (isCancelled(previousState)) {\r\n            return;\r\n        }\r\n        if (isTerminated(previousState)) {\r\n            // failure due to illegal requestN\r\n            Throwable error = this.error;\r\n            if (error != null) {\r\n                this.actual.onError(error);\r\n                return;\r\n            }\r\n        }\r\n        this.actual.onError(ex);\r\n        return;\r\n    }\r\n    long previousState = tryTerminate();\r\n    if (isCancelled(previousState)) {\r\n        return;\r\n    }\r\n    if (isTerminated(previousState)) {\r\n        // failure due to illegal requestN\r\n        Throwable error = this.error;\r\n        if (error != null) {\r\n            this.actual.onError(error);\r\n            return;\r\n        }\r\n    }\r\n    this.actual.onComplete();\r\n}\n@Override\r\npublic void request(long n) {\r\n    if (n <= 0) {\r\n        this.error = new IllegalArgumentException(\"request should be a positive number\");\r\n        long previousState = tryTerminate();\r\n        if (isTerminated(previousState) || isCancelled(previousState)) {\r\n            return;\r\n        }\r\n        if (previousState > 0) {\r\n            // error should eventually be observed and propagated\r\n            return;\r\n        }\r\n        // resume parked thread, so it can observe error and propagate it\r\n        resume();\r\n        return;\r\n    }\r\n    if (addCap(n) == 0) {\r\n        // resume parked thread so it can continue the work\r\n        resume();\r\n    }\r\n}\n@Override\r\npublic void cancel() {\r\n    long previousState = tryCancel();\r\n    if (isCancelled(previousState) || previousState > 0) {\r\n        return;\r\n    }\r\n    // resume parked thread, so it can be unblocked and close all the resources\r\n    resume();\r\n}\nprivate void await() {\r\n    Thread toUnpark = Thread.currentThread();\r\n    while (true) {\r\n        Object current = this.parkedThread.get();\r\n        if (current == READY) {\r\n            break;\r\n        }\r\n        if (current != null && current != toUnpark) {\r\n            throw new IllegalStateException(\"Only one (Virtual)Thread can await!\");\r\n        }\r\n        if (this.parkedThread.compareAndSet(null, toUnpark)) {\r\n            LockSupport.park();\r\n            // we don't just break here because park() can wake up spuriously\r\n            // if we got a proper resume, get() == READY and the loop will quit above\r\n        }\r\n    }\r\n    // clear the resume indicator so that the next await call will park without a resume()\r\n    this.parkedThread.lazySet(null);\r\n}\nprivate void resume() {\r\n    if (this.parkedThread.get() != READY) {\r\n        Object old = this.parkedThread.getAndSet(READY);\r\n        if (old != READY) {\r\n            LockSupport.unpark((Thread) old);\r\n        }\r\n    }\r\n}\nprivate long tryCancel() {\r\n    while (true) {\r\n        long r = this.requested.get();\r\n        if (isCancelled(r)) {\r\n            return r;\r\n        }\r\n        if (this.requested.compareAndSet(r, Long.MIN_VALUE)) {\r\n            return r;\r\n        }\r\n    }\r\n}\nprivate long tryTerminate() {\r\n    while (true) {\r\n        long r = this.requested.get();\r\n        if (isCancelled(r) || isTerminated(r)) {\r\n            return r;\r\n        }\r\n        if (this.requested.compareAndSet(r, Long.MIN_VALUE | Long.MAX_VALUE)) {\r\n            return r;\r\n        }\r\n    }\r\n}\nprivate long tryProduce(long n) {\r\n    while (true) {\r\n        long current = this.requested.get();\r\n        if (isTerminated(current) || isCancelled(current)) {\r\n            return current;\r\n        }\r\n        if (current == Long.MAX_VALUE) {\r\n            return Long.MAX_VALUE;\r\n        }\r\n        long update = current - n;\r\n        if (update < 0L) {\r\n            update = 0L;\r\n        }\r\n        if (this.requested.compareAndSet(current, update)) {\r\n            return update;\r\n        }\r\n    }\r\n}\nprivate long addCap(long n) {\r\n    while (true) {\r\n        long r = this.requested.get();\r\n        if (isTerminated(r) || isCancelled(r) || r == Long.MAX_VALUE) {\r\n            return r;\r\n        }\r\n        long u = addCap(r, n);\r\n        if (this.requested.compareAndSet(r, u)) {\r\n            return r;\r\n        }\r\n    }\r\n}\nprivate static boolean isTerminated(long state) {\r\n    return state == (Long.MIN_VALUE | Long.MAX_VALUE);\r\n}\nprivate static boolean isCancelled(long state) {\r\n    return state == Long.MIN_VALUE;\r\n}\nprivate static long addCap(long a, long b) {\r\n    long res = a + b;\r\n    if (res < 0L) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n    return res;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#write(int)",
    "entityType": "method",
    "code": "@Override\r\npublic void write(int b) throws IOException {\r\n    checkDemandAndAwaitIfNeeded();\r\n    T next = this.byteMapper.map(b);\r\n    this.actual.onNext(next);\r\n    this.produced++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#write(byte[])",
    "entityType": "method",
    "code": "@Override\r\npublic void write(byte[] b) throws IOException {\r\n    write(b, 0, b.length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#write(byte[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void write(byte[] b, int off, int len) throws IOException {\r\n    checkDemandAndAwaitIfNeeded();\r\n    T next = this.byteMapper.map(b, off, len);\r\n    this.actual.onNext(next);\r\n    this.produced++;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#checkDemandAndAwaitIfNeeded()",
    "entityType": "method",
    "code": "private void checkDemandAndAwaitIfNeeded() throws IOException {\r\n    long r = this.requested.get();\r\n    if (isTerminated(r) || isCancelled(r)) {\r\n        throw new IOException(\"Subscription has been terminated\");\r\n    }\r\n    long p = this.produced;\r\n    if (p == r) {\r\n        if (p > 0) {\r\n            r = tryProduce(p);\r\n            this.produced = 0;\r\n        }\r\n        while (true) {\r\n            if (isTerminated(r) || isCancelled(r)) {\r\n                throw new IOException(\"Subscription has been terminated\");\r\n            }\r\n            if (r != 0) {\r\n                return;\r\n            }\r\n            await();\r\n            r = this.requested.get();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#invokeHandler()",
    "entityType": "method",
    "code": "private void invokeHandler() {\r\n    // assume sync write within try-with-resource block\r\n    // use BufferedOutputStream, so that written bytes are buffered\r\n    // before publishing as byte buffer\r\n    try (OutputStream outputStream = new BufferedOutputStream(this, this.chunkSize)) {\r\n        this.outputStreamHandler.handle(outputStream);\r\n    } catch (Exception ex) {\r\n        long previousState = tryTerminate();\r\n        if (isCancelled(previousState)) {\r\n            return;\r\n        }\r\n        if (isTerminated(previousState)) {\r\n            // failure due to illegal requestN\r\n            Throwable error = this.error;\r\n            if (error != null) {\r\n                this.actual.onError(error);\r\n                return;\r\n            }\r\n        }\r\n        this.actual.onError(ex);\r\n        return;\r\n    }\r\n    long previousState = tryTerminate();\r\n    if (isCancelled(previousState)) {\r\n        return;\r\n    }\r\n    if (isTerminated(previousState)) {\r\n        // failure due to illegal requestN\r\n        Throwable error = this.error;\r\n        if (error != null) {\r\n            this.actual.onError(error);\r\n            return;\r\n        }\r\n    }\r\n    this.actual.onComplete();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#request(long)",
    "entityType": "method",
    "code": "@Override\r\npublic void request(long n) {\r\n    if (n <= 0) {\r\n        this.error = new IllegalArgumentException(\"request should be a positive number\");\r\n        long previousState = tryTerminate();\r\n        if (isTerminated(previousState) || isCancelled(previousState)) {\r\n            return;\r\n        }\r\n        if (previousState > 0) {\r\n            // error should eventually be observed and propagated\r\n            return;\r\n        }\r\n        // resume parked thread, so it can observe error and propagate it\r\n        resume();\r\n        return;\r\n    }\r\n    if (addCap(n) == 0) {\r\n        // resume parked thread so it can continue the work\r\n        resume();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#cancel()",
    "entityType": "method",
    "code": "@Override\r\npublic void cancel() {\r\n    long previousState = tryCancel();\r\n    if (isCancelled(previousState) || previousState > 0) {\r\n        return;\r\n    }\r\n    // resume parked thread, so it can be unblocked and close all the resources\r\n    resume();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#await()",
    "entityType": "method",
    "code": "private void await() {\r\n    Thread toUnpark = Thread.currentThread();\r\n    while (true) {\r\n        Object current = this.parkedThread.get();\r\n        if (current == READY) {\r\n            break;\r\n        }\r\n        if (current != null && current != toUnpark) {\r\n            throw new IllegalStateException(\"Only one (Virtual)Thread can await!\");\r\n        }\r\n        if (this.parkedThread.compareAndSet(null, toUnpark)) {\r\n            LockSupport.park();\r\n            // we don't just break here because park() can wake up spuriously\r\n            // if we got a proper resume, get() == READY and the loop will quit above\r\n        }\r\n    }\r\n    // clear the resume indicator so that the next await call will park without a resume()\r\n    this.parkedThread.lazySet(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#resume()",
    "entityType": "method",
    "code": "private void resume() {\r\n    if (this.parkedThread.get() != READY) {\r\n        Object old = this.parkedThread.getAndSet(READY);\r\n        if (old != READY) {\r\n            LockSupport.unpark((Thread) old);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#tryCancel()",
    "entityType": "method",
    "code": "private long tryCancel() {\r\n    while (true) {\r\n        long r = this.requested.get();\r\n        if (isCancelled(r)) {\r\n            return r;\r\n        }\r\n        if (this.requested.compareAndSet(r, Long.MIN_VALUE)) {\r\n            return r;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#tryTerminate()",
    "entityType": "method",
    "code": "private long tryTerminate() {\r\n    while (true) {\r\n        long r = this.requested.get();\r\n        if (isCancelled(r) || isTerminated(r)) {\r\n            return r;\r\n        }\r\n        if (this.requested.compareAndSet(r, Long.MIN_VALUE | Long.MAX_VALUE)) {\r\n            return r;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#tryProduce(long)",
    "entityType": "method",
    "code": "private long tryProduce(long n) {\r\n    while (true) {\r\n        long current = this.requested.get();\r\n        if (isTerminated(current) || isCancelled(current)) {\r\n            return current;\r\n        }\r\n        if (current == Long.MAX_VALUE) {\r\n            return Long.MAX_VALUE;\r\n        }\r\n        long update = current - n;\r\n        if (update < 0L) {\r\n            update = 0L;\r\n        }\r\n        if (this.requested.compareAndSet(current, update)) {\r\n            return update;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#addCap(long)",
    "entityType": "method",
    "code": "private long addCap(long n) {\r\n    while (true) {\r\n        long r = this.requested.get();\r\n        if (isTerminated(r) || isCancelled(r) || r == Long.MAX_VALUE) {\r\n            return r;\r\n        }\r\n        long u = addCap(r, n);\r\n        if (this.requested.compareAndSet(r, u)) {\r\n            return r;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#isTerminated(long)",
    "entityType": "method",
    "code": "private static boolean isTerminated(long state) {\r\n    return state == (Long.MIN_VALUE | Long.MAX_VALUE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#isCancelled(long)",
    "entityType": "method",
    "code": "private static boolean isCancelled(long state) {\r\n    return state == Long.MIN_VALUE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.OutputStreamSubscription#addCap(long,long)",
    "entityType": "method",
    "code": "private static long addCap(long a, long b) {\r\n    long res = a + b;\r\n    if (res < 0L) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n    return res;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.PooledDataBuffer",
    "entityType": "class",
    "code": "/**\r\n * Return {@code true} if this buffer is allocated;\r\n * {@code false} if it has been deallocated.\r\n * @since 5.1\r\n */\r\nboolean isAllocated();\n/**\r\n * Increase the reference count for this buffer by one.\r\n * @return this buffer\r\n */\r\nPooledDataBuffer retain();\n/**\r\n * Associate the given hint with the data buffer for debugging purposes.\r\n * @return this buffer\r\n * @since 5.3.2\r\n */\r\n@Override\r\nPooledDataBuffer touch(Object hint);\n/**\r\n * Decrease the reference count for this buffer by one,\r\n * and deallocate it once the count reaches zero.\r\n * @return {@code true} if the buffer was deallocated;\r\n * {@code false} otherwise\r\n */\r\nboolean release();",
    "comment": "\n * Extension of {@link DataBuffer} that allows for buffers that share\n * a memory pool. Introduces methods for reference counting.\n *\n * @author Arjen Poutsma\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.PooledDataBuffer#isAllocated()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if this buffer is allocated;\r\n * {@code false} if it has been deallocated.\r\n * @since 5.1\r\n */\r\nboolean isAllocated();",
    "comment": "\n\t * Return {@code true} if this buffer is allocated;\n\t * {@code false} if it has been deallocated.\n\t * @since 5.1\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.PooledDataBuffer#retain()",
    "entityType": "method",
    "code": "/**\r\n * Increase the reference count for this buffer by one.\r\n * @return this buffer\r\n */\r\nPooledDataBuffer retain();",
    "comment": "\n\t * Increase the reference count for this buffer by one.\n\t * @return this buffer\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.PooledDataBuffer#touch(Object)",
    "entityType": "method",
    "code": "/**\r\n * Associate the given hint with the data buffer for debugging purposes.\r\n * @return this buffer\r\n * @since 5.3.2\r\n */\r\n@Override\r\nPooledDataBuffer touch(Object hint);",
    "comment": "\n\t * Associate the given hint with the data buffer for debugging purposes.\n\t * @return this buffer\n\t * @since 5.3.2\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.PooledDataBuffer#release()",
    "entityType": "method",
    "code": "/**\r\n * Decrease the reference count for this buffer by one,\r\n * and deallocate it once the count reaches zero.\r\n * @return {@code true} if the buffer was deallocated;\r\n * {@code false} otherwise\r\n */\r\nboolean release();",
    "comment": "\n\t * Decrease the reference count for this buffer by one,\n\t * and deallocate it once the count reaches zero.\n\t * @return {@code true} if the buffer was deallocated;\n\t * {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream",
    "entityType": "class",
    "code": "private static final Object READY = new Object();\nprivate static final DataBuffer DONE = DefaultDataBufferFactory.sharedInstance.allocateBuffer(0);\nprivate static final DataBuffer CLOSED = DefaultDataBufferFactory.sharedInstance.allocateBuffer(0);\nprivate final int prefetch;\nprivate final int limit;\nprivate final ReentrantLock lock;\nprivate final Queue<DataBuffer> queue;\nprivate final AtomicReference<Object> parkedThread = new AtomicReference<>();\nprivate final AtomicInteger workAmount = new AtomicInteger();\nprivate volatile boolean closed;\nprivate int consumed;\n@Nullable\r\nprivate DataBuffer available;\n@Nullable\r\nprivate Subscription subscription;\nprivate boolean done;\n@Nullable\r\nprivate Throwable error;\n/**\r\n * Create an instance.\r\n * @param demand the number of buffers to request initially, and buffer\r\n * internally on an ongoing basis.\r\n */\r\nSubscriberInputStream(int demand) {\r\n    this.prefetch = demand;\r\n    this.limit = (demand == Integer.MAX_VALUE ? Integer.MAX_VALUE : demand - (demand >> 2));\r\n    this.queue = new ArrayBlockingQueue<>(demand);\r\n    this.lock = new ReentrantLock(false);\r\n}\n@Override\r\npublic void onSubscribe(Subscription subscription) {\r\n    if (this.subscription != null) {\r\n        subscription.cancel();\r\n        return;\r\n    }\r\n    this.subscription = subscription;\r\n    subscription.request(this.prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : this.prefetch);\r\n}\n@Override\r\npublic void onNext(DataBuffer buffer) {\r\n    Assert.notNull(buffer, \"DataBuffer must not be null\");\r\n    if (this.done) {\r\n        discard(buffer);\r\n        return;\r\n    }\r\n    if (!this.queue.offer(buffer)) {\r\n        discard(buffer);\r\n        this.error = new RuntimeException(\"Buffer overflow\");\r\n        this.done = true;\r\n    }\r\n    int previousWorkState = addWork();\r\n    if (previousWorkState == Integer.MIN_VALUE) {\r\n        DataBuffer value = this.queue.poll();\r\n        if (value != null) {\r\n            discard(value);\r\n        }\r\n        return;\r\n    }\r\n    if (previousWorkState == 0) {\r\n        resume();\r\n    }\r\n}\n@Override\r\npublic void onError(Throwable throwable) {\r\n    if (this.done) {\r\n        return;\r\n    }\r\n    this.error = throwable;\r\n    this.done = true;\r\n    if (addWork() == 0) {\r\n        resume();\r\n    }\r\n}\n@Override\r\npublic void onComplete() {\r\n    if (this.done) {\r\n        return;\r\n    }\r\n    this.done = true;\r\n    if (addWork() == 0) {\r\n        resume();\r\n    }\r\n}\nint addWork() {\r\n    for (; ; ) {\r\n        int produced = this.workAmount.getPlain();\r\n        if (produced == Integer.MIN_VALUE) {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n        int nextProduced = (produced == Integer.MAX_VALUE ? 1 : produced + 1);\r\n        if (this.workAmount.weakCompareAndSetRelease(produced, nextProduced)) {\r\n            return produced;\r\n        }\r\n    }\r\n}\nprivate void resume() {\r\n    if (this.parkedThread != READY) {\r\n        Object old = this.parkedThread.getAndSet(READY);\r\n        if (old != READY) {\r\n            LockSupport.unpark((Thread) old);\r\n        }\r\n    }\r\n}\n/* InputStream implementation */\r\n@Override\r\npublic int read() throws IOException {\r\n    if (!this.lock.tryLock()) {\r\n        if (this.closed) {\r\n            return -1;\r\n        }\r\n        throw new ConcurrentModificationException(\"Concurrent access is not allowed\");\r\n    }\r\n    try {\r\n        DataBuffer next = getNextOrAwait();\r\n        if (next == DONE) {\r\n            this.closed = true;\r\n            cleanAndFinalize();\r\n            if (this.error == null) {\r\n                return -1;\r\n            } else {\r\n                throw Exceptions.propagate(this.error);\r\n            }\r\n        } else if (next == CLOSED) {\r\n            cleanAndFinalize();\r\n            return -1;\r\n        }\r\n        return next.read() & 0xFF;\r\n    } catch (Throwable ex) {\r\n        this.closed = true;\r\n        requiredSubscriber().cancel();\r\n        cleanAndFinalize();\r\n        throw Exceptions.propagate(ex);\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}\n@Override\r\npublic int read(byte[] b, int off, int len) throws IOException {\r\n    Objects.checkFromIndexSize(off, len, b.length);\r\n    if (len == 0) {\r\n        return 0;\r\n    }\r\n    if (!this.lock.tryLock()) {\r\n        if (this.closed) {\r\n            return -1;\r\n        }\r\n        throw new ConcurrentModificationException(\"concurrent access is disallowed\");\r\n    }\r\n    try {\r\n        for (int j = 0; j < len; ) {\r\n            DataBuffer next = getNextOrAwait();\r\n            if (next == DONE) {\r\n                cleanAndFinalize();\r\n                if (this.error == null) {\r\n                    this.closed = true;\r\n                    return j == 0 ? -1 : j;\r\n                } else {\r\n                    if (j == 0) {\r\n                        this.closed = true;\r\n                        throw Exceptions.propagate(this.error);\r\n                    }\r\n                    return j;\r\n                }\r\n            } else if (next == CLOSED) {\r\n                requiredSubscriber().cancel();\r\n                cleanAndFinalize();\r\n                return -1;\r\n            }\r\n            int initialReadPosition = next.readPosition();\r\n            next.read(b, off + j, Math.min(len - j, next.readableByteCount()));\r\n            j += next.readPosition() - initialReadPosition;\r\n        }\r\n        return len;\r\n    } catch (Throwable ex) {\r\n        this.closed = true;\r\n        requiredSubscriber().cancel();\r\n        cleanAndFinalize();\r\n        throw Exceptions.propagate(ex);\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}\nprivate DataBuffer getNextOrAwait() {\r\n    if (this.available == null || this.available.readableByteCount() == 0) {\r\n        discard(this.available);\r\n        this.available = null;\r\n        int actualWorkAmount = this.workAmount.getAcquire();\r\n        for (; ; ) {\r\n            if (this.closed) {\r\n                return CLOSED;\r\n            }\r\n            boolean done = this.done;\r\n            DataBuffer buffer = this.queue.poll();\r\n            if (buffer != null) {\r\n                int consumed = ++this.consumed;\r\n                this.available = buffer;\r\n                if (consumed == this.limit) {\r\n                    this.consumed = 0;\r\n                    requiredSubscriber().request(this.limit);\r\n                }\r\n                break;\r\n            }\r\n            if (done) {\r\n                return DONE;\r\n            }\r\n            actualWorkAmount = this.workAmount.addAndGet(-actualWorkAmount);\r\n            if (actualWorkAmount == 0) {\r\n                await();\r\n            }\r\n        }\r\n    }\r\n    return this.available;\r\n}\nprivate void cleanAndFinalize() {\r\n    discard(this.available);\r\n    this.available = null;\r\n    for (; ; ) {\r\n        int workAmount = this.workAmount.getPlain();\r\n        DataBuffer value;\r\n        while ((value = this.queue.poll()) != null) {\r\n            discard(value);\r\n        }\r\n        if (this.workAmount.weakCompareAndSetPlain(workAmount, Integer.MIN_VALUE)) {\r\n            return;\r\n        }\r\n    }\r\n}\n@Override\r\npublic void close() throws IOException {\r\n    if (this.closed) {\r\n        return;\r\n    }\r\n    this.closed = true;\r\n    if (!this.lock.tryLock()) {\r\n        if (addWork() == 0) {\r\n            resume();\r\n        }\r\n        return;\r\n    }\r\n    try {\r\n        requiredSubscriber().cancel();\r\n        cleanAndFinalize();\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}\nprivate Subscription requiredSubscriber() {\r\n    Assert.state(this.subscription != null, \"Subscriber must be subscribed to use InputStream\");\r\n    return this.subscription;\r\n}\nprivate void discard(@Nullable DataBuffer buffer) {\r\n    DataBufferUtils.release(buffer);\r\n}\nprivate void await() {\r\n    Thread toUnpark = Thread.currentThread();\r\n    while (true) {\r\n        Object current = this.parkedThread.get();\r\n        if (current == READY) {\r\n            break;\r\n        }\r\n        if (current != null && current != toUnpark) {\r\n            throw new IllegalStateException(\"Only one (Virtual)Thread can await!\");\r\n        }\r\n        if (this.parkedThread.compareAndSet(null, toUnpark)) {\r\n            LockSupport.park();\r\n            // we don't just break here because park() can wake up spuriously\r\n            // if we got a proper resume, get() == READY and the loop will quit above\r\n        }\r\n    }\r\n    // clear the resume indicator so that the next await call will park without a resume()\r\n    this.parkedThread.lazySet(null);\r\n}",
    "comment": "\n * An {@link InputStream} backed by {@link Flow.Subscriber Flow.Subscriber}\n * receiving byte buffers from a {@link Flow.Publisher} source.\n *\n * <p>Byte buffers are stored in a queue. The {@code demand} constructor value\n * determines the number of buffers requested initially. When storage falls\n * below a {@code (demand - (demand >> 2))} limit, a request is made to refill\n * the queue.\n *\n * <p>The {@code InputStream} terminates after an onError or onComplete signal,\n * and stored buffers are read. If the {@code InputStream} is closed,\n * the {@link Flow.Subscription} is cancelled, and stored buffers released.\n *\n * <p>Note that this class has a near duplicate in\n * {@link org.springframework.http.client.SubscriberInputStream}.\n *\n * @author Oleh Dokuka\n * @author Rossen Stoyanchev\n * @since 6.2\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#onSubscribe(Subscription)",
    "entityType": "method",
    "code": "@Override\r\npublic void onSubscribe(Subscription subscription) {\r\n    if (this.subscription != null) {\r\n        subscription.cancel();\r\n        return;\r\n    }\r\n    this.subscription = subscription;\r\n    subscription.request(this.prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : this.prefetch);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#onNext(DataBuffer)",
    "entityType": "method",
    "code": "@Override\r\npublic void onNext(DataBuffer buffer) {\r\n    Assert.notNull(buffer, \"DataBuffer must not be null\");\r\n    if (this.done) {\r\n        discard(buffer);\r\n        return;\r\n    }\r\n    if (!this.queue.offer(buffer)) {\r\n        discard(buffer);\r\n        this.error = new RuntimeException(\"Buffer overflow\");\r\n        this.done = true;\r\n    }\r\n    int previousWorkState = addWork();\r\n    if (previousWorkState == Integer.MIN_VALUE) {\r\n        DataBuffer value = this.queue.poll();\r\n        if (value != null) {\r\n            discard(value);\r\n        }\r\n        return;\r\n    }\r\n    if (previousWorkState == 0) {\r\n        resume();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#onError(Throwable)",
    "entityType": "method",
    "code": "@Override\r\npublic void onError(Throwable throwable) {\r\n    if (this.done) {\r\n        return;\r\n    }\r\n    this.error = throwable;\r\n    this.done = true;\r\n    if (addWork() == 0) {\r\n        resume();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#onComplete()",
    "entityType": "method",
    "code": "@Override\r\npublic void onComplete() {\r\n    if (this.done) {\r\n        return;\r\n    }\r\n    this.done = true;\r\n    if (addWork() == 0) {\r\n        resume();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#addWork()",
    "entityType": "method",
    "code": "int addWork() {\r\n    for (; ; ) {\r\n        int produced = this.workAmount.getPlain();\r\n        if (produced == Integer.MIN_VALUE) {\r\n            return Integer.MIN_VALUE;\r\n        }\r\n        int nextProduced = (produced == Integer.MAX_VALUE ? 1 : produced + 1);\r\n        if (this.workAmount.weakCompareAndSetRelease(produced, nextProduced)) {\r\n            return produced;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#resume()",
    "entityType": "method",
    "code": "private void resume() {\r\n    if (this.parkedThread != READY) {\r\n        Object old = this.parkedThread.getAndSet(READY);\r\n        if (old != READY) {\r\n            LockSupport.unpark((Thread) old);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#read()",
    "entityType": "method",
    "code": "/* InputStream implementation */\r\n@Override\r\npublic int read() throws IOException {\r\n    if (!this.lock.tryLock()) {\r\n        if (this.closed) {\r\n            return -1;\r\n        }\r\n        throw new ConcurrentModificationException(\"Concurrent access is not allowed\");\r\n    }\r\n    try {\r\n        DataBuffer next = getNextOrAwait();\r\n        if (next == DONE) {\r\n            this.closed = true;\r\n            cleanAndFinalize();\r\n            if (this.error == null) {\r\n                return -1;\r\n            } else {\r\n                throw Exceptions.propagate(this.error);\r\n            }\r\n        } else if (next == CLOSED) {\r\n            cleanAndFinalize();\r\n            return -1;\r\n        }\r\n        return next.read() & 0xFF;\r\n    } catch (Throwable ex) {\r\n        this.closed = true;\r\n        requiredSubscriber().cancel();\r\n        cleanAndFinalize();\r\n        throw Exceptions.propagate(ex);\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#read(byte[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic int read(byte[] b, int off, int len) throws IOException {\r\n    Objects.checkFromIndexSize(off, len, b.length);\r\n    if (len == 0) {\r\n        return 0;\r\n    }\r\n    if (!this.lock.tryLock()) {\r\n        if (this.closed) {\r\n            return -1;\r\n        }\r\n        throw new ConcurrentModificationException(\"concurrent access is disallowed\");\r\n    }\r\n    try {\r\n        for (int j = 0; j < len; ) {\r\n            DataBuffer next = getNextOrAwait();\r\n            if (next == DONE) {\r\n                cleanAndFinalize();\r\n                if (this.error == null) {\r\n                    this.closed = true;\r\n                    return j == 0 ? -1 : j;\r\n                } else {\r\n                    if (j == 0) {\r\n                        this.closed = true;\r\n                        throw Exceptions.propagate(this.error);\r\n                    }\r\n                    return j;\r\n                }\r\n            } else if (next == CLOSED) {\r\n                requiredSubscriber().cancel();\r\n                cleanAndFinalize();\r\n                return -1;\r\n            }\r\n            int initialReadPosition = next.readPosition();\r\n            next.read(b, off + j, Math.min(len - j, next.readableByteCount()));\r\n            j += next.readPosition() - initialReadPosition;\r\n        }\r\n        return len;\r\n    } catch (Throwable ex) {\r\n        this.closed = true;\r\n        requiredSubscriber().cancel();\r\n        cleanAndFinalize();\r\n        throw Exceptions.propagate(ex);\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#getNextOrAwait()",
    "entityType": "method",
    "code": "private DataBuffer getNextOrAwait() {\r\n    if (this.available == null || this.available.readableByteCount() == 0) {\r\n        discard(this.available);\r\n        this.available = null;\r\n        int actualWorkAmount = this.workAmount.getAcquire();\r\n        for (; ; ) {\r\n            if (this.closed) {\r\n                return CLOSED;\r\n            }\r\n            boolean done = this.done;\r\n            DataBuffer buffer = this.queue.poll();\r\n            if (buffer != null) {\r\n                int consumed = ++this.consumed;\r\n                this.available = buffer;\r\n                if (consumed == this.limit) {\r\n                    this.consumed = 0;\r\n                    requiredSubscriber().request(this.limit);\r\n                }\r\n                break;\r\n            }\r\n            if (done) {\r\n                return DONE;\r\n            }\r\n            actualWorkAmount = this.workAmount.addAndGet(-actualWorkAmount);\r\n            if (actualWorkAmount == 0) {\r\n                await();\r\n            }\r\n        }\r\n    }\r\n    return this.available;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#cleanAndFinalize()",
    "entityType": "method",
    "code": "private void cleanAndFinalize() {\r\n    discard(this.available);\r\n    this.available = null;\r\n    for (; ; ) {\r\n        int workAmount = this.workAmount.getPlain();\r\n        DataBuffer value;\r\n        while ((value = this.queue.poll()) != null) {\r\n            discard(value);\r\n        }\r\n        if (this.workAmount.weakCompareAndSetPlain(workAmount, Integer.MIN_VALUE)) {\r\n            return;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#close()",
    "entityType": "method",
    "code": "@Override\r\npublic void close() throws IOException {\r\n    if (this.closed) {\r\n        return;\r\n    }\r\n    this.closed = true;\r\n    if (!this.lock.tryLock()) {\r\n        if (addWork() == 0) {\r\n            resume();\r\n        }\r\n        return;\r\n    }\r\n    try {\r\n        requiredSubscriber().cancel();\r\n        cleanAndFinalize();\r\n    } finally {\r\n        this.lock.unlock();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#requiredSubscriber()",
    "entityType": "method",
    "code": "private Subscription requiredSubscriber() {\r\n    Assert.state(this.subscription != null, \"Subscriber must be subscribed to use InputStream\");\r\n    return this.subscription;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#discard(DataBuffer)",
    "entityType": "method",
    "code": "private void discard(@Nullable DataBuffer buffer) {\r\n    DataBufferUtils.release(buffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.SubscriberInputStream#await()",
    "entityType": "method",
    "code": "private void await() {\r\n    Thread toUnpark = Thread.currentThread();\r\n    while (true) {\r\n        Object current = this.parkedThread.get();\r\n        if (current == READY) {\r\n            break;\r\n        }\r\n        if (current != null && current != toUnpark) {\r\n            throw new IllegalStateException(\"Only one (Virtual)Thread can await!\");\r\n        }\r\n        if (this.parkedThread.compareAndSet(null, toUnpark)) {\r\n            LockSupport.park();\r\n            // we don't just break here because park() can wake up spuriously\r\n            // if we got a proper resume, get() == READY and the loop will quit above\r\n        }\r\n    }\r\n    // clear the resume indicator so that the next await call will park without a resume()\r\n    this.parkedThread.lazySet(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.buffer.TouchableDataBuffer",
    "entityType": "class",
    "code": "/**\r\n * Associate the given hint with the data buffer for debugging purposes.\r\n * @return this buffer\r\n */\r\nTouchableDataBuffer touch(Object hint);",
    "comment": "\n * Extension of {@link DataBuffer} that allows for buffers that can be given\n * hints for debugging purposes.\n *\n * @author Arjen Poutsma\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.core.io.buffer.TouchableDataBuffer#touch(Object)",
    "entityType": "method",
    "code": "/**\r\n * Associate the given hint with the data buffer for debugging purposes.\r\n * @return this buffer\r\n */\r\nTouchableDataBuffer touch(Object hint);",
    "comment": "\n\t * Associate the given hint with the data buffer for debugging purposes.\n\t * @return this buffer\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource",
    "entityType": "class",
    "code": "private final byte[] byteArray;\nprivate final String description;\n/**\r\n * Create a new {@code ByteArrayResource}.\r\n * @param byteArray the byte array to wrap\r\n */\r\npublic ByteArrayResource(byte[] byteArray) {\r\n    this(byteArray, \"resource loaded from byte array\");\r\n}\n/**\r\n * Create a new {@code ByteArrayResource} with a description.\r\n * @param byteArray the byte array to wrap\r\n * @param description where the byte array comes from\r\n */\r\npublic ByteArrayResource(byte[] byteArray, @Nullable String description) {\r\n    Assert.notNull(byteArray, \"Byte array must not be null\");\r\n    this.byteArray = byteArray;\r\n    this.description = (description != null ? description : \"\");\r\n}\n/**\r\n * Return the underlying byte array.\r\n */\r\npublic final byte[] getByteArray() {\r\n    return this.byteArray;\r\n}\n/**\r\n * This implementation always returns {@code true}.\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return true;\r\n}\n/**\r\n * This implementation returns the length of the underlying byte array.\r\n */\r\n@Override\r\npublic long contentLength() {\r\n    return this.byteArray.length;\r\n}\n/**\r\n * This implementation returns a ByteArrayInputStream for the\r\n * underlying byte array.\r\n * @see java.io.ByteArrayInputStream\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    return new ByteArrayInputStream(this.byteArray);\r\n}\n@Override\r\npublic byte[] getContentAsByteArray() throws IOException {\r\n    int length = this.byteArray.length;\r\n    byte[] result = new byte[length];\r\n    System.arraycopy(this.byteArray, 0, result, 0, length);\r\n    return result;\r\n}\n@Override\r\npublic String getContentAsString(Charset charset) throws IOException {\r\n    return new String(this.byteArray, charset);\r\n}\n/**\r\n * This implementation returns a description that includes the passed-in\r\n * {@code description}, if any.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"Byte array resource [\" + this.description + \"]\";\r\n}\n/**\r\n * This implementation compares the underlying byte array.\r\n * @see java.util.Arrays#equals(byte[], byte[])\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ByteArrayResource that && Arrays.equals(this.byteArray, that.byteArray)));\r\n}\n/**\r\n * This implementation returns the hash code based on the\r\n * underlying byte array.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return Arrays.hashCode(this.byteArray);\r\n}",
    "comment": "\n * {@link Resource} implementation for a given byte array.\n * <p>Creates a {@link ByteArrayInputStream} for the given byte array.\n *\n * <p>Useful for loading content from any given byte array,\n * without having to resort to a single-use {@link InputStreamResource}.\n * Particularly useful for creating mail attachments from local content,\n * where JavaMail needs to be able to read the stream multiple times.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.2.3\n * @see java.io.ByteArrayInputStream\n * @see InputStreamResource\n * @see org.springframework.mail.javamail.MimeMessageHelper#addAttachment(String, InputStreamSource)\n "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#getByteArray()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying byte array.\r\n */\r\npublic final byte[] getByteArray() {\r\n    return this.byteArray;\r\n}",
    "comment": "\n\t * Return the underlying byte array.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#exists()",
    "entityType": "method",
    "code": "/**\r\n * This implementation always returns {@code true}.\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return true;\r\n}",
    "comment": "\n\t * This implementation always returns {@code true}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#contentLength()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the length of the underlying byte array.\r\n */\r\n@Override\r\npublic long contentLength() {\r\n    return this.byteArray.length;\r\n}",
    "comment": "\n\t * This implementation returns the length of the underlying byte array.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a ByteArrayInputStream for the\r\n * underlying byte array.\r\n * @see java.io.ByteArrayInputStream\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    return new ByteArrayInputStream(this.byteArray);\r\n}",
    "comment": "\n\t * This implementation returns a ByteArrayInputStream for the\n\t * underlying byte array.\n\t * @see java.io.ByteArrayInputStream\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#getContentAsByteArray()",
    "entityType": "method",
    "code": "@Override\r\npublic byte[] getContentAsByteArray() throws IOException {\r\n    int length = this.byteArray.length;\r\n    byte[] result = new byte[length];\r\n    System.arraycopy(this.byteArray, 0, result, 0, length);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#getContentAsString(Charset)",
    "entityType": "method",
    "code": "@Override\r\npublic String getContentAsString(Charset charset) throws IOException {\r\n    return new String(this.byteArray, charset);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#getDescription()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a description that includes the passed-in\r\n * {@code description}, if any.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"Byte array resource [\" + this.description + \"]\";\r\n}",
    "comment": "\n\t * This implementation returns a description that includes the passed-in\n\t * {@code description}, if any.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying byte array.\r\n * @see java.util.Arrays#equals(byte[], byte[])\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ByteArrayResource that && Arrays.equals(this.byteArray, that.byteArray)));\r\n}",
    "comment": "\n\t * This implementation compares the underlying byte array.\n\t * @see java.util.Arrays#equals(byte[], byte[])\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ByteArrayResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code based on the\r\n * underlying byte array.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return Arrays.hashCode(this.byteArray);\r\n}",
    "comment": "\n\t * This implementation returns the hash code based on the\n\t * underlying byte array.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource",
    "entityType": "class",
    "code": "/**\r\n * Internal representation of the original path supplied by the user,\r\n * used for creating relative paths and resolving URLs and InputStreams.\r\n */\r\nprivate final String path;\nprivate final String absolutePath;\n@Nullable\r\nprivate final ClassLoader classLoader;\n@Nullable\r\nprivate final Class<?> clazz;\n/**\r\n * Create a new {@code ClassPathResource} for {@code ClassLoader} usage.\r\n * <p>A leading slash will be removed, as the {@code ClassLoader} resource\r\n * access methods will not accept it.\r\n * <p>The default class loader will be used for loading the resource.\r\n * @param path the absolute path within the class path\r\n * @see ClassUtils#getDefaultClassLoader()\r\n */\r\npublic ClassPathResource(String path) {\r\n    this(path, (ClassLoader) null);\r\n}\n/**\r\n * Create a new {@code ClassPathResource} for {@code ClassLoader} usage.\r\n * <p>A leading slash will be removed, as the {@code ClassLoader} resource\r\n * access methods will not accept it.\r\n * <p>If the supplied {@code ClassLoader} is {@code null}, the default class\r\n * loader will be used for loading the resource.\r\n * @param path the absolute path within the class path\r\n * @param classLoader the class loader to load the resource with\r\n * @see ClassUtils#getDefaultClassLoader()\r\n */\r\npublic ClassPathResource(String path, @Nullable ClassLoader classLoader) {\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    String pathToUse = StringUtils.cleanPath(path);\r\n    if (pathToUse.startsWith(\"/\")) {\r\n        pathToUse = pathToUse.substring(1);\r\n    }\r\n    this.path = pathToUse;\r\n    this.absolutePath = pathToUse;\r\n    this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\r\n    this.clazz = null;\r\n}\n/**\r\n * Create a new {@code ClassPathResource} for {@code Class} usage.\r\n * <p>The path can be relative to the given class, or absolute within\r\n * the class path via a leading slash.\r\n * <p>If the supplied {@code Class} is {@code null}, the default class\r\n * loader will be used for loading the resource.\r\n * <p>This is also useful for resource access within the module system,\r\n * loading a resource from the containing module of a given {@code Class}.\r\n * See {@link ModuleResource} and its javadoc.\r\n * @param path relative or absolute path within the class path\r\n * @param clazz the class to load resources with\r\n * @see ClassUtils#getDefaultClassLoader()\r\n * @see ModuleResource\r\n */\r\npublic ClassPathResource(String path, @Nullable Class<?> clazz) {\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    this.path = StringUtils.cleanPath(path);\r\n    String absolutePath = this.path;\r\n    if (clazz != null && !absolutePath.startsWith(\"/\")) {\r\n        absolutePath = ClassUtils.classPackageAsResourcePath(clazz) + \"/\" + absolutePath;\r\n    } else if (absolutePath.startsWith(\"/\")) {\r\n        absolutePath = absolutePath.substring(1);\r\n    }\r\n    this.absolutePath = absolutePath;\r\n    this.classLoader = null;\r\n    this.clazz = clazz;\r\n}\n/**\r\n * Return the <em>absolute path</em> for this resource, as a\r\n * {@linkplain StringUtils#cleanPath(String) cleaned} resource path within\r\n * the class path.\r\n * <p>The path returned by this method does not have a leading slash and is\r\n * suitable for use with {@link ClassLoader#getResource(String)}.\r\n */\r\npublic final String getPath() {\r\n    return this.absolutePath;\r\n}\n/**\r\n * Return the {@link ClassLoader} that this resource will be obtained from.\r\n */\r\n@Nullable\r\npublic final ClassLoader getClassLoader() {\r\n    return (this.clazz != null ? this.clazz.getClassLoader() : this.classLoader);\r\n}\n/**\r\n * This implementation checks for the resolution of a resource URL.\r\n * @see ClassLoader#getResource(String)\r\n * @see Class#getResource(String)\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return (resolveURL() != null);\r\n}\n/**\r\n * This implementation checks for the resolution of a resource URL upfront,\r\n * then proceeding with {@link AbstractFileResolvingResource}'s length check.\r\n * @see ClassLoader#getResource(String)\r\n * @see Class#getResource(String)\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    URL url = resolveURL();\r\n    return (url != null && checkReadable(url));\r\n}\n/**\r\n * Resolves a {@link URL} for the underlying class path resource.\r\n * @return the resolved URL, or {@code null} if not resolvable\r\n */\r\n@Nullable\r\nprotected URL resolveURL() {\r\n    try {\r\n        if (this.clazz != null) {\r\n            return this.clazz.getResource(this.path);\r\n        } else if (this.classLoader != null) {\r\n            return this.classLoader.getResource(this.absolutePath);\r\n        } else {\r\n            return ClassLoader.getSystemResource(this.absolutePath);\r\n        }\r\n    } catch (IllegalArgumentException ex) {\r\n        // Should not happen according to the JDK's contract:\r\n        // see https://github.com/openjdk/jdk/pull/2662\r\n        return null;\r\n    }\r\n}\n/**\r\n * This implementation opens an {@link InputStream} for the underlying class\r\n * path resource, if available.\r\n * @see ClassLoader#getResourceAsStream(String)\r\n * @see Class#getResourceAsStream(String)\r\n * @see ClassLoader#getSystemResourceAsStream(String)\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    InputStream is;\r\n    if (this.clazz != null) {\r\n        is = this.clazz.getResourceAsStream(this.path);\r\n    } else if (this.classLoader != null) {\r\n        is = this.classLoader.getResourceAsStream(this.absolutePath);\r\n    } else {\r\n        is = ClassLoader.getSystemResourceAsStream(this.absolutePath);\r\n    }\r\n    if (is == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\r\n    }\r\n    return is;\r\n}\n/**\r\n * This implementation returns a URL for the underlying class path resource,\r\n * if available.\r\n * @see ClassLoader#getResource(String)\r\n * @see Class#getResource(String)\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    URL url = resolveURL();\r\n    if (url == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\r\n    }\r\n    return url;\r\n}\n/**\r\n * This implementation creates a {@code ClassPathResource}, applying the given\r\n * path relative to the path used to create this descriptor.\r\n * @see StringUtils#applyRelativePath(String, String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return (this.clazz != null ? new ClassPathResource(pathToUse, this.clazz) : new ClassPathResource(pathToUse, this.classLoader));\r\n}\n/**\r\n * This implementation returns the name of the file that this class path\r\n * resource refers to.\r\n * @see StringUtils#getFilename(String)\r\n */\r\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    return StringUtils.getFilename(this.absolutePath);\r\n}\n/**\r\n * This implementation returns a description that includes the absolute\r\n * class path location.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"class path resource [\" + this.absolutePath + \"]\";\r\n}\n/**\r\n * This implementation compares the underlying class path locations and\r\n * associated class loaders.\r\n * @see #getPath()\r\n * @see #getClassLoader()\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ClassPathResource that && this.absolutePath.equals(that.absolutePath) && ObjectUtils.nullSafeEquals(getClassLoader(), that.getClassLoader())));\r\n}\n/**\r\n * This implementation returns the hash code of the underlying class path location.\r\n * @see #getPath()\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return this.absolutePath.hashCode();\r\n}",
    "comment": "\n * {@link Resource} implementation for class path resources. Uses either a\n * given {@link ClassLoader} or a given {@link Class} for loading resources.\n *\n * <p>Supports resolution as {@code java.io.File} if the class path\n * resource resides in the file system, but not for resources in a JAR.\n * Always supports resolution as {@code java.net.URL}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n * @see ClassLoader#getResourceAsStream(String)\n * @see ClassLoader#getResource(String)\n * @see Class#getResourceAsStream(String)\n * @see Class#getResource(String)\n "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#getPath()",
    "entityType": "method",
    "code": "/**\r\n * Return the <em>absolute path</em> for this resource, as a\r\n * {@linkplain StringUtils#cleanPath(String) cleaned} resource path within\r\n * the class path.\r\n * <p>The path returned by this method does not have a leading slash and is\r\n * suitable for use with {@link ClassLoader#getResource(String)}.\r\n */\r\npublic final String getPath() {\r\n    return this.absolutePath;\r\n}",
    "comment": "\n\t * Return the <em>absolute path</em> for this resource, as a\n\t * {@linkplain StringUtils#cleanPath(String) cleaned} resource path within\n\t * the class path.\n\t * <p>The path returned by this method does not have a leading slash and is\n\t * suitable for use with {@link ClassLoader#getResource(String)}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#getClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link ClassLoader} that this resource will be obtained from.\r\n */\r\n@Nullable\r\npublic final ClassLoader getClassLoader() {\r\n    return (this.clazz != null ? this.clazz.getClassLoader() : this.classLoader);\r\n}",
    "comment": "\n\t * Return the {@link ClassLoader} that this resource will be obtained from.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#exists()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks for the resolution of a resource URL.\r\n * @see ClassLoader#getResource(String)\r\n * @see Class#getResource(String)\r\n */\r\n@Override\r\npublic boolean exists() {\r\n    return (resolveURL() != null);\r\n}",
    "comment": "\n\t * This implementation checks for the resolution of a resource URL.\n\t * @see ClassLoader#getResource(String)\n\t * @see Class#getResource(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#isReadable()",
    "entityType": "method",
    "code": "/**\r\n * This implementation checks for the resolution of a resource URL upfront,\r\n * then proceeding with {@link AbstractFileResolvingResource}'s length check.\r\n * @see ClassLoader#getResource(String)\r\n * @see Class#getResource(String)\r\n */\r\n@Override\r\npublic boolean isReadable() {\r\n    URL url = resolveURL();\r\n    return (url != null && checkReadable(url));\r\n}",
    "comment": "\n\t * This implementation checks for the resolution of a resource URL upfront,\n\t * then proceeding with {@link AbstractFileResolvingResource}'s length check.\n\t * @see ClassLoader#getResource(String)\n\t * @see Class#getResource(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#resolveURL()",
    "entityType": "method",
    "code": "/**\r\n * Resolves a {@link URL} for the underlying class path resource.\r\n * @return the resolved URL, or {@code null} if not resolvable\r\n */\r\n@Nullable\r\nprotected URL resolveURL() {\r\n    try {\r\n        if (this.clazz != null) {\r\n            return this.clazz.getResource(this.path);\r\n        } else if (this.classLoader != null) {\r\n            return this.classLoader.getResource(this.absolutePath);\r\n        } else {\r\n            return ClassLoader.getSystemResource(this.absolutePath);\r\n        }\r\n    } catch (IllegalArgumentException ex) {\r\n        // Should not happen according to the JDK's contract:\r\n        // see https://github.com/openjdk/jdk/pull/2662\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Resolves a {@link URL} for the underlying class path resource.\n\t * @return the resolved URL, or {@code null} if not resolvable\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens an {@link InputStream} for the underlying class\r\n * path resource, if available.\r\n * @see ClassLoader#getResourceAsStream(String)\r\n * @see Class#getResourceAsStream(String)\r\n * @see ClassLoader#getSystemResourceAsStream(String)\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    InputStream is;\r\n    if (this.clazz != null) {\r\n        is = this.clazz.getResourceAsStream(this.path);\r\n    } else if (this.classLoader != null) {\r\n        is = this.classLoader.getResourceAsStream(this.absolutePath);\r\n    } else {\r\n        is = ClassLoader.getSystemResourceAsStream(this.absolutePath);\r\n    }\r\n    if (is == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\r\n    }\r\n    return is;\r\n}",
    "comment": "\n\t * This implementation opens an {@link InputStream} for the underlying class\n\t * path resource, if available.\n\t * @see ClassLoader#getResourceAsStream(String)\n\t * @see Class#getResourceAsStream(String)\n\t * @see ClassLoader#getSystemResourceAsStream(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#getURL()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a URL for the underlying class path resource,\r\n * if available.\r\n * @see ClassLoader#getResource(String)\r\n * @see Class#getResource(String)\r\n */\r\n@Override\r\npublic URL getURL() throws IOException {\r\n    URL url = resolveURL();\r\n    if (url == null) {\r\n        throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\r\n    }\r\n    return url;\r\n}",
    "comment": "\n\t * This implementation returns a URL for the underlying class path resource,\n\t * if available.\n\t * @see ClassLoader#getResource(String)\n\t * @see Class#getResource(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#createRelative(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation creates a {@code ClassPathResource}, applying the given\r\n * path relative to the path used to create this descriptor.\r\n * @see StringUtils#applyRelativePath(String, String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) {\r\n    String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\r\n    return (this.clazz != null ? new ClassPathResource(pathToUse, this.clazz) : new ClassPathResource(pathToUse, this.classLoader));\r\n}",
    "comment": "\n\t * This implementation creates a {@code ClassPathResource}, applying the given\n\t * path relative to the path used to create this descriptor.\n\t * @see StringUtils#applyRelativePath(String, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#getFilename()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the name of the file that this class path\r\n * resource refers to.\r\n * @see StringUtils#getFilename(String)\r\n */\r\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    return StringUtils.getFilename(this.absolutePath);\r\n}",
    "comment": "\n\t * This implementation returns the name of the file that this class path\n\t * resource refers to.\n\t * @see StringUtils#getFilename(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.ClassPathResource#getDescription()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a description that includes the absolute\r\n * class path location.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"class path resource [\" + this.absolutePath + \"]\";\r\n}",
    "comment": "\n\t * This implementation returns a description that includes the absolute\n\t * class path location.\n\t "
  }
]