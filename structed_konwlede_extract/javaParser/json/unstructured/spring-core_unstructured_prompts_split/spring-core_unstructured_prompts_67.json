[
  {
    "entityId": "org.springframework.core.log.LogMessage#format(String,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Build a lazily formatted message from the given format string and arguments.\r\n * @param format the format string (following {@link String#format} rules)\r\n * @param arg1 the first argument (can be {@code null})\r\n * @param arg2 the second argument (can be {@code null})\r\n * @see String#format(String, Object...)\r\n */\r\npublic static LogMessage format(String format, @Nullable Object arg1, @Nullable Object arg2) {\r\n    return new FormatMessage2(format, arg1, arg2);\r\n}",
    "comment": "\n\t * Build a lazily formatted message from the given format string and arguments.\n\t * @param format the format string (following {@link String#format} rules)\n\t * @param arg1 the first argument (can be {@code null})\n\t * @param arg2 the second argument (can be {@code null})\n\t * @see String#format(String, Object...)\n\t "
  },
  {
    "entityId": "org.springframework.core.log.LogMessage#format(String,Object,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Build a lazily formatted message from the given format string and arguments.\r\n * @param format the format string (following {@link String#format} rules)\r\n * @param arg1 the first argument (can be {@code null})\r\n * @param arg2 the second argument (can be {@code null})\r\n * @param arg3 the third argument (can be {@code null})\r\n * @see String#format(String, Object...)\r\n */\r\npublic static LogMessage format(String format, @Nullable Object arg1, @Nullable Object arg2, @Nullable Object arg3) {\r\n    return new FormatMessage3(format, arg1, arg2, arg3);\r\n}",
    "comment": "\n\t * Build a lazily formatted message from the given format string and arguments.\n\t * @param format the format string (following {@link String#format} rules)\n\t * @param arg1 the first argument (can be {@code null})\n\t * @param arg2 the second argument (can be {@code null})\n\t * @param arg3 the third argument (can be {@code null})\n\t * @see String#format(String, Object...)\n\t "
  },
  {
    "entityId": "org.springframework.core.log.LogMessage#format(String,Object,Object,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Build a lazily formatted message from the given format string and arguments.\r\n * @param format the format string (following {@link String#format} rules)\r\n * @param arg1 the first argument (can be {@code null})\r\n * @param arg2 the second argument (can be {@code null})\r\n * @param arg3 the third argument (can be {@code null})\r\n * @param arg4 the fourth argument (can be {@code null})\r\n * @see String#format(String, Object...)\r\n */\r\npublic static LogMessage format(String format, @Nullable Object arg1, @Nullable Object arg2, @Nullable Object arg3, @Nullable Object arg4) {\r\n    return new FormatMessage4(format, arg1, arg2, arg3, arg4);\r\n}",
    "comment": "\n\t * Build a lazily formatted message from the given format string and arguments.\n\t * @param format the format string (following {@link String#format} rules)\n\t * @param arg1 the first argument (can be {@code null})\n\t * @param arg2 the second argument (can be {@code null})\n\t * @param arg3 the third argument (can be {@code null})\n\t * @param arg4 the fourth argument (can be {@code null})\n\t * @see String#format(String, Object...)\n\t "
  },
  {
    "entityId": "org.springframework.core.log.LogMessage#format(String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Build a lazily formatted message from the given format string and varargs.\r\n * <p>This varargs {@code format()} variant may be costly. You should therefore\r\n * use the individual argument variants whenever possible;\r\n * {@link #format(String, Object)}, {@link #format(String, Object, Object)}, etc.\r\n * @param format the format string (following {@link String#format} rules)\r\n * @param args the varargs array (can be {@code null} and can contain {@code null}\r\n * elements)\r\n * @see String#format(String, Object...)\r\n */\r\npublic static LogMessage format(String format, @Nullable Object... args) {\r\n    return new FormatMessageX(format, args);\r\n}",
    "comment": "\n\t * Build a lazily formatted message from the given format string and varargs.\n\t * <p>This varargs {@code format()} variant may be costly. You should therefore\n\t * use the individual argument variants whenever possible;\n\t * {@link #format(String, Object)}, {@link #format(String, Object, Object)}, etc.\n\t * @param format the format string (following {@link String#format} rules)\n\t * @param args the varargs array (can be {@code null} and can contain {@code null}\n\t * elements)\n\t * @see String#format(String, Object...)\n\t "
  },
  {
    "entityId": "org.springframework.core.log.SupplierMessage",
    "entityType": "class",
    "code": "private final Supplier<? extends CharSequence> supplier;\nSupplierMessage(Supplier<? extends CharSequence> supplier) {\r\n    Assert.notNull(supplier, \"Supplier must not be null\");\r\n    this.supplier = supplier;\r\n}\n@Override\r\nString buildString() {\r\n    return this.supplier.get().toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.SupplierMessage#buildString()",
    "entityType": "method",
    "code": "@Override\r\nString buildString() {\r\n    return this.supplier.get().toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage",
    "entityType": "class",
    "code": "protected final String format;\nFormatMessage(String format) {\r\n    Assert.notNull(format, \"Format must not be null\");\r\n    this.format = format;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage1",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object arg1;\nFormatMessage1(String format, @Nullable Object arg1) {\r\n    super(format);\r\n    this.arg1 = arg1;\r\n}\n@Override\r\nprotected String buildString() {\r\n    return String.format(this.format, this.arg1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage1#buildString()",
    "entityType": "method",
    "code": "@Override\r\nprotected String buildString() {\r\n    return String.format(this.format, this.arg1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage2",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object arg1;\n@Nullable\r\nprivate final Object arg2;\nFormatMessage2(String format, @Nullable Object arg1, @Nullable Object arg2) {\r\n    super(format);\r\n    this.arg1 = arg1;\r\n    this.arg2 = arg2;\r\n}\n@Override\r\nString buildString() {\r\n    return String.format(this.format, this.arg1, this.arg2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage2#buildString()",
    "entityType": "method",
    "code": "@Override\r\nString buildString() {\r\n    return String.format(this.format, this.arg1, this.arg2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage3",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object arg1;\n@Nullable\r\nprivate final Object arg2;\n@Nullable\r\nprivate final Object arg3;\nFormatMessage3(String format, @Nullable Object arg1, @Nullable Object arg2, @Nullable Object arg3) {\r\n    super(format);\r\n    this.arg1 = arg1;\r\n    this.arg2 = arg2;\r\n    this.arg3 = arg3;\r\n}\n@Override\r\nString buildString() {\r\n    return String.format(this.format, this.arg1, this.arg2, this.arg3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage3#buildString()",
    "entityType": "method",
    "code": "@Override\r\nString buildString() {\r\n    return String.format(this.format, this.arg1, this.arg2, this.arg3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage4",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object arg1;\n@Nullable\r\nprivate final Object arg2;\n@Nullable\r\nprivate final Object arg3;\n@Nullable\r\nprivate final Object arg4;\nFormatMessage4(String format, @Nullable Object arg1, @Nullable Object arg2, @Nullable Object arg3, @Nullable Object arg4) {\r\n    super(format);\r\n    this.arg1 = arg1;\r\n    this.arg2 = arg2;\r\n    this.arg3 = arg3;\r\n    this.arg4 = arg4;\r\n}\n@Override\r\nString buildString() {\r\n    return String.format(this.format, this.arg1, this.arg2, this.arg3, this.arg4);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessage4#buildString()",
    "entityType": "method",
    "code": "@Override\r\nString buildString() {\r\n    return String.format(this.format, this.arg1, this.arg2, this.arg3, this.arg4);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessageX",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object[] args;\nFormatMessageX(String format, @Nullable Object... args) {\r\n    super(format);\r\n    this.args = args;\r\n}\n@Override\r\nString buildString() {\r\n    return String.format(this.format, this.args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.log.FormatMessageX#buildString()",
    "entityType": "method",
    "code": "@Override\r\nString buildString() {\r\n    return String.format(this.format, this.args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodClassKey",
    "entityType": "class",
    "code": "private final Method method;\n@Nullable\r\nprivate final Class<?> targetClass;\n/**\r\n * Create a key object for the given method and target class.\r\n * @param method the method to wrap (must not be {@code null})\r\n * @param targetClass the target class that the method will be invoked\r\n * on (may be {@code null} if identical to the declaring class)\r\n */\r\npublic MethodClassKey(Method method, @Nullable Class<?> targetClass) {\r\n    this.method = method;\r\n    this.targetClass = targetClass;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MethodClassKey that && this.method.equals(that.method) && ObjectUtils.nullSafeEquals(this.targetClass, that.targetClass)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.method.hashCode() + (this.targetClass != null ? this.targetClass.hashCode() * 29 : 0);\r\n}\n@Override\r\npublic String toString() {\r\n    return this.method + (this.targetClass != null ? \" on \" + this.targetClass : \"\");\r\n}\n@Override\r\npublic int compareTo(MethodClassKey other) {\r\n    int result = this.method.getName().compareTo(other.method.getName());\r\n    if (result == 0) {\r\n        result = this.method.toString().compareTo(other.method.toString());\r\n        if (result == 0 && this.targetClass != null && other.targetClass != null) {\r\n            result = this.targetClass.getName().compareTo(other.targetClass.getName());\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": "\n * A common key class for a method against a specific target class,\n * including {@link #toString()} representation and {@link Comparable}\n * support (as suggested for custom {@code HashMap} keys as of Java 8).\n *\n * @author Juergen Hoeller\n * @since 4.3\n "
  },
  {
    "entityId": "org.springframework.core.MethodClassKey#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MethodClassKey that && this.method.equals(that.method) && ObjectUtils.nullSafeEquals(this.targetClass, that.targetClass)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodClassKey#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.method.hashCode() + (this.targetClass != null ? this.targetClass.hashCode() * 29 : 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodClassKey#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.method + (this.targetClass != null ? \" on \" + this.targetClass : \"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodClassKey#compareTo(MethodClassKey)",
    "entityType": "method",
    "code": "@Override\r\npublic int compareTo(MethodClassKey other) {\r\n    int result = this.method.getName().compareTo(other.method.getName());\r\n    if (result == 0) {\r\n        result = this.method.toString().compareTo(other.method.toString());\r\n        if (result == 0 && this.targetClass != null && other.targetClass != null) {\r\n            result = this.targetClass.getName().compareTo(other.targetClass.getName());\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodIntrospector",
    "entityType": "class",
    "code": "private MethodIntrospector() {\r\n}\n/**\r\n * Select methods on the given target type based on the lookup of associated metadata.\r\n * <p>Callers define methods of interest through the {@link MetadataLookup} parameter,\r\n * allowing to collect the associated metadata into the result map.\r\n * @param targetType the target type to search methods on\r\n * @param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,\r\n * returning non-null metadata to be associated with a given method if there is a match,\r\n * or {@code null} for no match\r\n * @return the selected methods associated with their metadata (in the order of retrieval),\r\n * or an empty map in case of no match\r\n */\r\npublic static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {\r\n    final Map<Method, T> methodMap = new LinkedHashMap<>();\r\n    Set<Class<?>> handlerTypes = new LinkedHashSet<>();\r\n    Class<?> specificHandlerType = null;\r\n    if (!Proxy.isProxyClass(targetType)) {\r\n        specificHandlerType = ClassUtils.getUserClass(targetType);\r\n        handlerTypes.add(specificHandlerType);\r\n    }\r\n    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));\r\n    for (Class<?> currentHandlerType : handlerTypes) {\r\n        final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);\r\n        ReflectionUtils.doWithMethods(currentHandlerType, method -> {\r\n            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\r\n            T result = metadataLookup.inspect(specificMethod);\r\n            if (result != null) {\r\n                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\r\n                if (bridgedMethod == specificMethod || bridgedMethod == method || bridgedMethod.equals(specificMethod) || bridgedMethod.equals(method) || metadataLookup.inspect(bridgedMethod) == null) {\r\n                    methodMap.put(specificMethod, result);\r\n                }\r\n            }\r\n        }, ReflectionUtils.USER_DECLARED_METHODS);\r\n    }\r\n    return methodMap;\r\n}\n/**\r\n * Select methods on the given target type based on a filter.\r\n * <p>Callers define methods of interest through the {@code MethodFilter} parameter.\r\n * @param targetType the target type to search methods on\r\n * @param methodFilter a {@code MethodFilter} to help\r\n * recognize handler methods of interest\r\n * @return the selected methods, or an empty set in case of no match\r\n */\r\npublic static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {\r\n    return selectMethods(targetType, (MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet();\r\n}\n/**\r\n * Select an invocable method on the target type: either the given method itself\r\n * if actually exposed on the target type, or otherwise a corresponding method\r\n * on one of the target type's interfaces or on the target type itself.\r\n * <p>Matches on user-declared interfaces will be preferred since they are likely\r\n * to contain relevant metadata that corresponds to the method on the target class.\r\n * @param method the method to check\r\n * @param targetType the target type to search methods on\r\n * (typically an interface-based JDK proxy)\r\n * @return a corresponding invocable method on the target type\r\n * @throws IllegalStateException if the given method is not invocable on the given\r\n * target type (typically due to a proxy mismatch)\r\n */\r\npublic static Method selectInvocableMethod(Method method, Class<?> targetType) {\r\n    if (method.getDeclaringClass().isAssignableFrom(targetType)) {\r\n        return method;\r\n    }\r\n    try {\r\n        String methodName = method.getName();\r\n        Class<?>[] parameterTypes = method.getParameterTypes();\r\n        for (Class<?> ifc : targetType.getInterfaces()) {\r\n            try {\r\n                return ifc.getMethod(methodName, parameterTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                // Alright, not on this interface then...\r\n            }\r\n        }\r\n        // A final desperate attempt on the proxy class itself...\r\n        return targetType.getMethod(methodName, parameterTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new IllegalStateException(String.format(\"Need to invoke method '%s' declared on target class '%s', \" + \"but not found in any interface(s) of the exposed proxy type. \" + \"Either pull the method up to an interface or switch to CGLIB \" + \"proxies by enforcing proxy-target-class mode in your configuration.\", method.getName(), method.getDeclaringClass().getSimpleName()));\r\n    }\r\n}\n/**\r\n * A callback interface for metadata lookup on a given method.\r\n * @param <T> the type of metadata returned\r\n */\r\n@FunctionalInterface\r\npublic interface MetadataLookup<T> {\r\n\r\n    /**\r\n     * Perform a lookup on the given method and return associated metadata, if any.\r\n     * @param method the method to inspect\r\n     * @return non-null metadata to be associated with a method if there is a match,\r\n     * or {@code null} for no match\r\n     */\r\n    @Nullable\r\n    T inspect(Method method);\r\n}",
    "comment": "\n * Defines the algorithm for searching for metadata-associated methods exhaustively\n * including interfaces and parent classes while also dealing with parameterized methods\n * as well as common scenarios encountered with interface and class-based proxies.\n *\n * <p>Typically, but not necessarily, used for finding annotated handler methods.\n *\n * @author Juergen Hoeller\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n * @since 4.2.3\n "
  },
  {
    "entityId": "org.springframework.core.MethodIntrospector#selectMethods(Class<?>,MetadataLookup<T>)",
    "entityType": "method",
    "code": "/**\r\n * Select methods on the given target type based on the lookup of associated metadata.\r\n * <p>Callers define methods of interest through the {@link MetadataLookup} parameter,\r\n * allowing to collect the associated metadata into the result map.\r\n * @param targetType the target type to search methods on\r\n * @param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,\r\n * returning non-null metadata to be associated with a given method if there is a match,\r\n * or {@code null} for no match\r\n * @return the selected methods associated with their metadata (in the order of retrieval),\r\n * or an empty map in case of no match\r\n */\r\npublic static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {\r\n    final Map<Method, T> methodMap = new LinkedHashMap<>();\r\n    Set<Class<?>> handlerTypes = new LinkedHashSet<>();\r\n    Class<?> specificHandlerType = null;\r\n    if (!Proxy.isProxyClass(targetType)) {\r\n        specificHandlerType = ClassUtils.getUserClass(targetType);\r\n        handlerTypes.add(specificHandlerType);\r\n    }\r\n    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));\r\n    for (Class<?> currentHandlerType : handlerTypes) {\r\n        final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);\r\n        ReflectionUtils.doWithMethods(currentHandlerType, method -> {\r\n            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\r\n            T result = metadataLookup.inspect(specificMethod);\r\n            if (result != null) {\r\n                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\r\n                if (bridgedMethod == specificMethod || bridgedMethod == method || bridgedMethod.equals(specificMethod) || bridgedMethod.equals(method) || metadataLookup.inspect(bridgedMethod) == null) {\r\n                    methodMap.put(specificMethod, result);\r\n                }\r\n            }\r\n        }, ReflectionUtils.USER_DECLARED_METHODS);\r\n    }\r\n    return methodMap;\r\n}",
    "comment": "\n\t * Select methods on the given target type based on the lookup of associated metadata.\n\t * <p>Callers define methods of interest through the {@link MetadataLookup} parameter,\n\t * allowing to collect the associated metadata into the result map.\n\t * @param targetType the target type to search methods on\n\t * @param metadataLookup a {@link MetadataLookup} callback to inspect methods of interest,\n\t * returning non-null metadata to be associated with a given method if there is a match,\n\t * or {@code null} for no match\n\t * @return the selected methods associated with their metadata (in the order of retrieval),\n\t * or an empty map in case of no match\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodIntrospector#selectMethods(Class<?>,ReflectionUtils.MethodFilter)",
    "entityType": "method",
    "code": "/**\r\n * Select methods on the given target type based on a filter.\r\n * <p>Callers define methods of interest through the {@code MethodFilter} parameter.\r\n * @param targetType the target type to search methods on\r\n * @param methodFilter a {@code MethodFilter} to help\r\n * recognize handler methods of interest\r\n * @return the selected methods, or an empty set in case of no match\r\n */\r\npublic static Set<Method> selectMethods(Class<?> targetType, final ReflectionUtils.MethodFilter methodFilter) {\r\n    return selectMethods(targetType, (MetadataLookup<Boolean>) method -> (methodFilter.matches(method) ? Boolean.TRUE : null)).keySet();\r\n}",
    "comment": "\n\t * Select methods on the given target type based on a filter.\n\t * <p>Callers define methods of interest through the {@code MethodFilter} parameter.\n\t * @param targetType the target type to search methods on\n\t * @param methodFilter a {@code MethodFilter} to help\n\t * recognize handler methods of interest\n\t * @return the selected methods, or an empty set in case of no match\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodIntrospector#selectInvocableMethod(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Select an invocable method on the target type: either the given method itself\r\n * if actually exposed on the target type, or otherwise a corresponding method\r\n * on one of the target type's interfaces or on the target type itself.\r\n * <p>Matches on user-declared interfaces will be preferred since they are likely\r\n * to contain relevant metadata that corresponds to the method on the target class.\r\n * @param method the method to check\r\n * @param targetType the target type to search methods on\r\n * (typically an interface-based JDK proxy)\r\n * @return a corresponding invocable method on the target type\r\n * @throws IllegalStateException if the given method is not invocable on the given\r\n * target type (typically due to a proxy mismatch)\r\n */\r\npublic static Method selectInvocableMethod(Method method, Class<?> targetType) {\r\n    if (method.getDeclaringClass().isAssignableFrom(targetType)) {\r\n        return method;\r\n    }\r\n    try {\r\n        String methodName = method.getName();\r\n        Class<?>[] parameterTypes = method.getParameterTypes();\r\n        for (Class<?> ifc : targetType.getInterfaces()) {\r\n            try {\r\n                return ifc.getMethod(methodName, parameterTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                // Alright, not on this interface then...\r\n            }\r\n        }\r\n        // A final desperate attempt on the proxy class itself...\r\n        return targetType.getMethod(methodName, parameterTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new IllegalStateException(String.format(\"Need to invoke method '%s' declared on target class '%s', \" + \"but not found in any interface(s) of the exposed proxy type. \" + \"Either pull the method up to an interface or switch to CGLIB \" + \"proxies by enforcing proxy-target-class mode in your configuration.\", method.getName(), method.getDeclaringClass().getSimpleName()));\r\n    }\r\n}",
    "comment": "\n\t * Select an invocable method on the target type: either the given method itself\n\t * if actually exposed on the target type, or otherwise a corresponding method\n\t * on one of the target type's interfaces or on the target type itself.\n\t * <p>Matches on user-declared interfaces will be preferred since they are likely\n\t * to contain relevant metadata that corresponds to the method on the target class.\n\t * @param method the method to check\n\t * @param targetType the target type to search methods on\n\t * (typically an interface-based JDK proxy)\n\t * @return a corresponding invocable method on the target type\n\t * @throws IllegalStateException if the given method is not invocable on the given\n\t * target type (typically due to a proxy mismatch)\n\t "
  },
  {
    "entityId": "org.springframework.core.MetadataLookup",
    "entityType": "class",
    "code": "/**\r\n * Perform a lookup on the given method and return associated metadata, if any.\r\n * @param method the method to inspect\r\n * @return non-null metadata to be associated with a method if there is a match,\r\n * or {@code null} for no match\r\n */\r\n@Nullable\r\nT inspect(Method method);",
    "comment": "\n\t * A callback interface for metadata lookup on a given method.\n\t * @param <T> the type of metadata returned\n\t "
  },
  {
    "entityId": "org.springframework.core.MetadataLookup#inspect(Method)",
    "entityType": "method",
    "code": "/**\r\n * Perform a lookup on the given method and return associated metadata, if any.\r\n * @param method the method to inspect\r\n * @return non-null metadata to be associated with a method if there is a match,\r\n * or {@code null} for no match\r\n */\r\n@Nullable\r\nT inspect(Method method);",
    "comment": "\n\t\t * Perform a lookup on the given method and return associated metadata, if any.\n\t\t * @param method the method to inspect\n\t\t * @return non-null metadata to be associated with a method if there is a match,\n\t\t * or {@code null} for no match\n\t\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter",
    "entityType": "class",
    "code": "private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];\nprivate final Executable executable;\nprivate final int parameterIndex;\n@Nullable\r\nprivate volatile Parameter parameter;\nprivate int nestingLevel;\n/**\r\n * Map from Integer level to Integer type index.\r\n */\r\n@Nullable\r\nMap<Integer, Integer> typeIndexesPerLevel;\n/**\r\n * The containing class. Could also be supplied by overriding {@link #getContainingClass()}\r\n */\r\n@Nullable\r\nprivate volatile Class<?> containingClass;\n@Nullable\r\nprivate volatile Class<?> parameterType;\n@Nullable\r\nprivate volatile Type genericParameterType;\nprivate volatile Annotation @Nullable [] parameterAnnotations;\n@Nullable\r\nprivate volatile ParameterNameDiscoverer parameterNameDiscoverer;\n@Nullable\r\nvolatile String parameterName;\n@Nullable\r\nprivate volatile MethodParameter nestedMethodParameter;\n/**\r\n * Create a new {@code MethodParameter} for the given method, with nesting level 1.\r\n * @param method the Method to specify a parameter for\r\n * @param parameterIndex the index of the parameter: -1 for the method\r\n * return type; 0 for the first method parameter; 1 for the second method\r\n * parameter, etc.\r\n */\r\npublic MethodParameter(Method method, int parameterIndex) {\r\n    this(method, parameterIndex, 1);\r\n}\n/**\r\n * Create a new {@code MethodParameter} for the given method.\r\n * @param method the Method to specify a parameter for\r\n * @param parameterIndex the index of the parameter: -1 for the method\r\n * return type; 0 for the first method parameter; 1 for the second method\r\n * parameter, etc.\r\n * @param nestingLevel the nesting level of the target type\r\n * (typically 1; for example, in case of a List of Lists, 1 would indicate the\r\n * nested List, whereas 2 would indicate the element of the nested List)\r\n */\r\npublic MethodParameter(Method method, int parameterIndex, int nestingLevel) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    this.executable = method;\r\n    this.parameterIndex = validateIndex(method, parameterIndex);\r\n    this.nestingLevel = nestingLevel;\r\n}\n/**\r\n * Create a new MethodParameter for the given constructor, with nesting level 1.\r\n * @param constructor the Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n */\r\npublic MethodParameter(Constructor<?> constructor, int parameterIndex) {\r\n    this(constructor, parameterIndex, 1);\r\n}\n/**\r\n * Create a new MethodParameter for the given constructor.\r\n * @param constructor the Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @param nestingLevel the nesting level of the target type\r\n * (typically 1; for example, in case of a List of Lists, 1 would indicate the\r\n * nested List, whereas 2 would indicate the element of the nested List)\r\n */\r\npublic MethodParameter(Constructor<?> constructor, int parameterIndex, int nestingLevel) {\r\n    Assert.notNull(constructor, \"Constructor must not be null\");\r\n    this.executable = constructor;\r\n    this.parameterIndex = validateIndex(constructor, parameterIndex);\r\n    this.nestingLevel = nestingLevel;\r\n}\n/**\r\n * Internal constructor used to create a {@link MethodParameter} with a\r\n * containing class already set.\r\n * @param executable the Executable to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @param containingClass the containing class\r\n * @since 5.2\r\n */\r\nMethodParameter(Executable executable, int parameterIndex, @Nullable Class<?> containingClass) {\r\n    Assert.notNull(executable, \"Executable must not be null\");\r\n    this.executable = executable;\r\n    this.parameterIndex = validateIndex(executable, parameterIndex);\r\n    this.nestingLevel = 1;\r\n    this.containingClass = containingClass;\r\n}\n/**\r\n * Copy constructor, resulting in an independent MethodParameter object\r\n * based on the same metadata and cache state that the original object was in.\r\n * @param original the original MethodParameter object to copy from\r\n */\r\npublic MethodParameter(MethodParameter original) {\r\n    Assert.notNull(original, \"Original must not be null\");\r\n    this.executable = original.executable;\r\n    this.parameterIndex = original.parameterIndex;\r\n    this.parameter = original.parameter;\r\n    this.nestingLevel = original.nestingLevel;\r\n    this.typeIndexesPerLevel = original.typeIndexesPerLevel;\r\n    this.containingClass = original.containingClass;\r\n    this.parameterType = original.parameterType;\r\n    this.genericParameterType = original.genericParameterType;\r\n    this.parameterAnnotations = original.parameterAnnotations;\r\n    this.parameterNameDiscoverer = original.parameterNameDiscoverer;\r\n    this.parameterName = original.parameterName;\r\n}\n/**\r\n * Return the wrapped Method, if any.\r\n * <p>Note: Either Method or Constructor is available.\r\n * @return the Method, or {@code null} if none\r\n */\r\n@Nullable\r\npublic Method getMethod() {\r\n    return (this.executable instanceof Method method ? method : null);\r\n}\n/**\r\n * Return the wrapped Constructor, if any.\r\n * <p>Note: Either Method or Constructor is available.\r\n * @return the Constructor, or {@code null} if none\r\n */\r\n@Nullable\r\npublic Constructor<?> getConstructor() {\r\n    return (this.executable instanceof Constructor<?> constructor ? constructor : null);\r\n}\n/**\r\n * Return the class that declares the underlying Method or Constructor.\r\n */\r\npublic Class<?> getDeclaringClass() {\r\n    return this.executable.getDeclaringClass();\r\n}\n/**\r\n * Return the wrapped member.\r\n * @return the Method or Constructor as Member\r\n */\r\npublic Member getMember() {\r\n    return this.executable;\r\n}\n/**\r\n * Return the wrapped annotated element.\r\n * <p>Note: This method exposes the annotations declared on the method/constructor\r\n * itself (i.e. at the method/constructor level, not at the parameter level).\r\n * <p>To get the {@link AnnotatedElement} at the parameter level, use\r\n * {@link #getParameter()}.\r\n * @return the Method or Constructor as AnnotatedElement\r\n */\r\npublic AnnotatedElement getAnnotatedElement() {\r\n    return this.executable;\r\n}\n/**\r\n * Return the wrapped executable.\r\n * @return the Method or Constructor as Executable\r\n * @since 5.0\r\n */\r\npublic Executable getExecutable() {\r\n    return this.executable;\r\n}\n/**\r\n * Return the {@link Parameter} descriptor for method/constructor parameter.\r\n * @since 5.0\r\n */\r\npublic Parameter getParameter() {\r\n    if (this.parameterIndex < 0) {\r\n        throw new IllegalStateException(\"Cannot retrieve Parameter descriptor for method return type\");\r\n    }\r\n    Parameter parameter = this.parameter;\r\n    if (parameter == null) {\r\n        parameter = getExecutable().getParameters()[this.parameterIndex];\r\n        this.parameter = parameter;\r\n    }\r\n    return parameter;\r\n}\n/**\r\n * Return the index of the method/constructor parameter.\r\n * @return the parameter index (-1 in case of the return type)\r\n */\r\npublic int getParameterIndex() {\r\n    return this.parameterIndex;\r\n}\n/**\r\n * Increase this parameter's nesting level.\r\n * @see #getNestingLevel()\r\n * @deprecated since 5.2 in favor of {@link #nested(Integer)}\r\n */\r\n@Deprecated\r\npublic void increaseNestingLevel() {\r\n    this.nestingLevel++;\r\n}\n/**\r\n * Decrease this parameter's nesting level.\r\n * @see #getNestingLevel()\r\n * @deprecated since 5.2 in favor of retaining the original MethodParameter and\r\n * using {@link #nested(Integer)} if nesting is required\r\n */\r\n@Deprecated\r\npublic void decreaseNestingLevel() {\r\n    getTypeIndexesPerLevel().remove(this.nestingLevel);\r\n    this.nestingLevel--;\r\n}\n/**\r\n * Return the nesting level of the target type\r\n * (typically 1; for example, in case of a List of Lists, 1 would indicate the\r\n * nested List, whereas 2 would indicate the element of the nested List).\r\n */\r\npublic int getNestingLevel() {\r\n    return this.nestingLevel;\r\n}\n/**\r\n * Return a variant of this {@code MethodParameter} with the type\r\n * for the current level set to the specified value.\r\n * @param typeIndex the new type index\r\n * @since 5.2\r\n */\r\npublic MethodParameter withTypeIndex(int typeIndex) {\r\n    return nested(this.nestingLevel, typeIndex);\r\n}\n/**\r\n * Set the type index for the current nesting level.\r\n * @param typeIndex the corresponding type index\r\n * (or {@code null} for the default type index)\r\n * @see #getNestingLevel()\r\n * @deprecated since 5.2 in favor of {@link #withTypeIndex}\r\n */\r\n@Deprecated\r\npublic void setTypeIndexForCurrentLevel(int typeIndex) {\r\n    getTypeIndexesPerLevel().put(this.nestingLevel, typeIndex);\r\n}\n/**\r\n * Return the type index for the current nesting level.\r\n * @return the corresponding type index, or {@code null}\r\n * if none specified (indicating the default type index)\r\n * @see #getNestingLevel()\r\n */\r\n@Nullable\r\npublic Integer getTypeIndexForCurrentLevel() {\r\n    return getTypeIndexForLevel(this.nestingLevel);\r\n}\n/**\r\n * Return the type index for the specified nesting level.\r\n * @param nestingLevel the nesting level to check\r\n * @return the corresponding type index, or {@code null}\r\n * if none specified (indicating the default type index)\r\n */\r\n@Nullable\r\npublic Integer getTypeIndexForLevel(int nestingLevel) {\r\n    return getTypeIndexesPerLevel().get(nestingLevel);\r\n}\n/**\r\n * Obtain the (lazily constructed) type-indexes-per-level Map.\r\n */\r\nprivate Map<Integer, Integer> getTypeIndexesPerLevel() {\r\n    if (this.typeIndexesPerLevel == null) {\r\n        this.typeIndexesPerLevel = new HashMap<>(4);\r\n    }\r\n    return this.typeIndexesPerLevel;\r\n}\n/**\r\n * Return a variant of this {@code MethodParameter} which points to the\r\n * same parameter but one nesting level deeper.\r\n * @since 4.3\r\n */\r\npublic MethodParameter nested() {\r\n    return nested(null);\r\n}\n/**\r\n * Return a variant of this {@code MethodParameter} which points to the\r\n * same parameter but one nesting level deeper.\r\n * @param typeIndex the type index for the new nesting level\r\n * @since 5.2\r\n */\r\npublic MethodParameter nested(@Nullable Integer typeIndex) {\r\n    MethodParameter nestedParam = this.nestedMethodParameter;\r\n    if (nestedParam != null && typeIndex == null) {\r\n        return nestedParam;\r\n    }\r\n    nestedParam = nested(this.nestingLevel + 1, typeIndex);\r\n    if (typeIndex == null) {\r\n        this.nestedMethodParameter = nestedParam;\r\n    }\r\n    return nestedParam;\r\n}\nprivate MethodParameter nested(int nestingLevel, @Nullable Integer typeIndex) {\r\n    MethodParameter copy = clone();\r\n    copy.nestingLevel = nestingLevel;\r\n    if (this.typeIndexesPerLevel != null) {\r\n        copy.typeIndexesPerLevel = new HashMap<>(this.typeIndexesPerLevel);\r\n    }\r\n    if (typeIndex != null) {\r\n        copy.getTypeIndexesPerLevel().put(copy.nestingLevel, typeIndex);\r\n    }\r\n    copy.parameterType = null;\r\n    copy.genericParameterType = null;\r\n    return copy;\r\n}\n/**\r\n * Return whether this method indicates a parameter which is not required:\r\n * either in the form of Java 8's {@link java.util.Optional}, JSpecify annotations,\r\n * any variant of a parameter-level {@code @Nullable} annotation (such as from Spring,\r\n * JSR-305 or Jakarta set of annotations), a language-level nullable type\r\n * declaration or {@code Continuation} parameter in Kotlin.\r\n * @since 4.3\r\n * @see Nullness#forMethodParameter(MethodParameter)\r\n */\r\npublic boolean isOptional() {\r\n    return (getParameterType() == Optional.class || Nullness.forMethodParameter(this) == Nullness.NULLABLE || (KotlinDetector.isKotlinType(getContainingClass()) && KotlinDelegate.isOptional(this)));\r\n}\n/**\r\n * Return a variant of this {@code MethodParameter} which points to\r\n * the same parameter but one nesting level deeper in case of a\r\n * {@link java.util.Optional} declaration.\r\n * @since 4.3\r\n * @see #isOptional()\r\n * @see #nested()\r\n */\r\npublic MethodParameter nestedIfOptional() {\r\n    return (getParameterType() == Optional.class ? nested() : this);\r\n}\n/**\r\n * Return a variant of this {@code MethodParameter} which refers to the\r\n * given containing class.\r\n * @param containingClass a specific containing class (potentially a\r\n * subclass of the declaring class, for example, substituting a type variable)\r\n * @since 5.2\r\n * @see #getParameterType()\r\n */\r\npublic MethodParameter withContainingClass(@Nullable Class<?> containingClass) {\r\n    MethodParameter result = clone();\r\n    result.containingClass = containingClass;\r\n    result.parameterType = null;\r\n    return result;\r\n}\n/**\r\n * Set a containing class to resolve the parameter type against.\r\n */\r\n@Deprecated\r\nvoid setContainingClass(Class<?> containingClass) {\r\n    this.containingClass = containingClass;\r\n    this.parameterType = null;\r\n}\n/**\r\n * Return the containing class for this method parameter.\r\n * @return a specific containing class (potentially a subclass of the\r\n * declaring class), or otherwise simply the declaring class itself\r\n * @see #getDeclaringClass()\r\n */\r\npublic Class<?> getContainingClass() {\r\n    Class<?> containingClass = this.containingClass;\r\n    return (containingClass != null ? containingClass : getDeclaringClass());\r\n}\n/**\r\n * Set a resolved (generic) parameter type.\r\n */\r\n@Deprecated\r\nvoid setParameterType(@Nullable Class<?> parameterType) {\r\n    this.parameterType = parameterType;\r\n}\n/**\r\n * Return the type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n */\r\npublic Class<?> getParameterType() {\r\n    Class<?> paramType = this.parameterType;\r\n    if (paramType != null) {\r\n        return paramType;\r\n    }\r\n    if (getContainingClass() != getDeclaringClass()) {\r\n        paramType = ResolvableType.forMethodParameter(this, null, 1).resolve();\r\n    }\r\n    if (paramType == null) {\r\n        paramType = computeParameterType();\r\n    }\r\n    this.parameterType = paramType;\r\n    return paramType;\r\n}\n/**\r\n * Return the generic type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n * @since 3.0\r\n */\r\npublic Type getGenericParameterType() {\r\n    Type paramType = this.genericParameterType;\r\n    if (paramType == null) {\r\n        if (this.parameterIndex < 0) {\r\n            Method method = getMethod();\r\n            paramType = (method != null ? (KotlinDetector.isKotlinType(getContainingClass()) ? KotlinDelegate.getGenericReturnType(method) : method.getGenericReturnType()) : void.class);\r\n        } else {\r\n            Type[] genericParameterTypes = this.executable.getGenericParameterTypes();\r\n            int index = this.parameterIndex;\r\n            if (this.executable instanceof Constructor && ClassUtils.isInnerClass(this.executable.getDeclaringClass()) && genericParameterTypes.length == this.executable.getParameterCount() - 1) {\r\n                // Bug in javac: type array excludes enclosing instance parameter\r\n                // for inner classes with at least one generic constructor parameter,\r\n                // so access it with the actual parameter index lowered by 1\r\n                index = this.parameterIndex - 1;\r\n            }\r\n            paramType = (index >= 0 && index < genericParameterTypes.length ? genericParameterTypes[index] : computeParameterType());\r\n        }\r\n        this.genericParameterType = paramType;\r\n    }\r\n    return paramType;\r\n}\nprivate Class<?> computeParameterType() {\r\n    if (this.parameterIndex < 0) {\r\n        Method method = getMethod();\r\n        if (method == null) {\r\n            return void.class;\r\n        }\r\n        if (KotlinDetector.isKotlinType(getContainingClass())) {\r\n            return KotlinDelegate.getReturnType(method);\r\n        }\r\n        return method.getReturnType();\r\n    }\r\n    return this.executable.getParameterTypes()[this.parameterIndex];\r\n}\n/**\r\n * Return the nested type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n * @since 3.1\r\n * @see #getNestingLevel()\r\n */\r\npublic Class<?> getNestedParameterType() {\r\n    if (this.nestingLevel > 1) {\r\n        Type type = getGenericParameterType();\r\n        for (int i = 2; i <= this.nestingLevel; i++) {\r\n            if (type instanceof ParameterizedType parameterizedType) {\r\n                Type[] args = parameterizedType.getActualTypeArguments();\r\n                Integer index = getTypeIndexForLevel(i);\r\n                type = args[index != null ? index : args.length - 1];\r\n            }\r\n            // TODO: Object.class if unresolvable\r\n        }\r\n        if (type instanceof Class<?> clazz) {\r\n            return clazz;\r\n        } else if (type instanceof ParameterizedType parameterizedType) {\r\n            Type arg = parameterizedType.getRawType();\r\n            if (arg instanceof Class<?> clazz) {\r\n                return clazz;\r\n            }\r\n        }\r\n        return Object.class;\r\n    } else {\r\n        return getParameterType();\r\n    }\r\n}\n/**\r\n * Return the nested generic type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n * @since 4.2\r\n * @see #getNestingLevel()\r\n */\r\npublic Type getNestedGenericParameterType() {\r\n    if (this.nestingLevel > 1) {\r\n        Type type = getGenericParameterType();\r\n        for (int i = 2; i <= this.nestingLevel; i++) {\r\n            if (type instanceof ParameterizedType parameterizedType) {\r\n                Type[] args = parameterizedType.getActualTypeArguments();\r\n                Integer index = getTypeIndexForLevel(i);\r\n                type = args[index != null ? index : args.length - 1];\r\n            }\r\n        }\r\n        return type;\r\n    } else {\r\n        return getGenericParameterType();\r\n    }\r\n}\n/**\r\n * Return the annotations associated with the target method/constructor itself.\r\n */\r\npublic Annotation[] getMethodAnnotations() {\r\n    return adaptAnnotationArray(getAnnotatedElement().getAnnotations());\r\n}\n/**\r\n * Return the method/constructor annotation of the given type, if available.\r\n * @param annotationType the annotation type to look for\r\n * @return the annotation object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\r\n    A annotation = getAnnotatedElement().getAnnotation(annotationType);\r\n    return (annotation != null ? adaptAnnotation(annotation) : null);\r\n}\n/**\r\n * Return whether the method/constructor is annotated with the given type.\r\n * @param annotationType the annotation type to look for\r\n * @since 4.3\r\n * @see #getMethodAnnotation(Class)\r\n */\r\npublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\r\n    return getAnnotatedElement().isAnnotationPresent(annotationType);\r\n}\n/**\r\n * Return the annotations associated with the specific method/constructor parameter.\r\n */\r\npublic Annotation[] getParameterAnnotations() {\r\n    Annotation[] paramAnns = this.parameterAnnotations;\r\n    if (paramAnns == null) {\r\n        Annotation[][] annotationArray = this.executable.getParameterAnnotations();\r\n        int index = this.parameterIndex;\r\n        if (this.executable instanceof Constructor && ClassUtils.isInnerClass(this.executable.getDeclaringClass()) && annotationArray.length == this.executable.getParameterCount() - 1) {\r\n            // Bug in javac in JDK <9: annotation array excludes enclosing instance parameter\r\n            // for inner classes, so access it with the actual parameter index lowered by 1\r\n            index = this.parameterIndex - 1;\r\n        }\r\n        paramAnns = (index >= 0 && index < annotationArray.length && annotationArray[index].length > 0 ? adaptAnnotationArray(annotationArray[index]) : EMPTY_ANNOTATION_ARRAY);\r\n        this.parameterAnnotations = paramAnns;\r\n    }\r\n    return paramAnns;\r\n}\n/**\r\n * Return {@code true} if the parameter has at least one annotation,\r\n * {@code false} if it has none.\r\n * @see #getParameterAnnotations()\r\n */\r\npublic boolean hasParameterAnnotations() {\r\n    return (getParameterAnnotations().length != 0);\r\n}\n/**\r\n * Return the parameter annotation of the given type, if available.\r\n * @param annotationType the annotation type to look for\r\n * @return the annotation object, or {@code null} if not found\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <A extends Annotation> A getParameterAnnotation(Class<A> annotationType) {\r\n    Annotation[] anns = getParameterAnnotations();\r\n    for (Annotation ann : anns) {\r\n        if (annotationType.isInstance(ann)) {\r\n            return (A) ann;\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * Return whether the parameter is declared with the given annotation type.\r\n * @param annotationType the annotation type to look for\r\n * @see #getParameterAnnotation(Class)\r\n */\r\npublic <A extends Annotation> boolean hasParameterAnnotation(Class<A> annotationType) {\r\n    return (getParameterAnnotation(annotationType) != null);\r\n}\n/**\r\n * Initialize parameter name discovery for this method parameter.\r\n * <p>This method does not actually try to retrieve the parameter name at\r\n * this point; it just allows discovery to happen when the application calls\r\n * {@link #getParameterName()} (if ever).\r\n */\r\npublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\r\n    this.parameterNameDiscoverer = parameterNameDiscoverer;\r\n}\n/**\r\n * Return the name of the method/constructor parameter.\r\n * @return the parameter name (may be {@code null} if no\r\n * parameter name metadata is contained in the class file or no\r\n * {@link #initParameterNameDiscovery ParameterNameDiscoverer}\r\n * has been set to begin with)\r\n */\r\n@Nullable\r\npublic String getParameterName() {\r\n    if (this.parameterIndex < 0) {\r\n        return null;\r\n    }\r\n    ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;\r\n    if (discoverer != null) {\r\n        @Nullable\r\n        String[] parameterNames = null;\r\n        if (this.executable instanceof Method method) {\r\n            parameterNames = discoverer.getParameterNames(method);\r\n        } else if (this.executable instanceof Constructor<?> constructor) {\r\n            parameterNames = discoverer.getParameterNames(constructor);\r\n        }\r\n        if (parameterNames != null && this.parameterIndex < parameterNames.length) {\r\n            this.parameterName = parameterNames[this.parameterIndex];\r\n        }\r\n        this.parameterNameDiscoverer = null;\r\n    }\r\n    return this.parameterName;\r\n}\n/**\r\n * A template method to post-process a given annotation instance before\r\n * returning it to the caller.\r\n * <p>The default implementation simply returns the given annotation as-is.\r\n * @param annotation the annotation about to be returned\r\n * @return the post-processed annotation (or simply the original one)\r\n * @since 4.2\r\n */\r\nprotected <A extends Annotation> A adaptAnnotation(A annotation) {\r\n    return annotation;\r\n}\n/**\r\n * A template method to post-process a given annotation array before\r\n * returning it to the caller.\r\n * <p>The default implementation simply returns the given annotation array as-is.\r\n * @param annotations the annotation array about to be returned\r\n * @return the post-processed annotation array (or simply the original one)\r\n * @since 4.2\r\n */\r\nprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\r\n    return annotations;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MethodParameter that && getContainingClass() == that.getContainingClass() && ObjectUtils.nullSafeEquals(this.typeIndexesPerLevel, that.typeIndexesPerLevel) && this.nestingLevel == that.nestingLevel && this.parameterIndex == that.parameterIndex && this.executable.equals(that.executable)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return (31 * this.executable.hashCode() + this.parameterIndex);\r\n}\n@Override\r\npublic String toString() {\r\n    Method method = getMethod();\r\n    return (method != null ? \"method '\" + method.getName() + \"'\" : \"constructor\") + \" parameter \" + this.parameterIndex;\r\n}\n@Override\r\npublic MethodParameter clone() {\r\n    return new MethodParameter(this);\r\n}\n/**\r\n * Create a new MethodParameter for the given method or constructor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Method or Constructor reference is treated in a generic fashion.\r\n * @param methodOrConstructor the Method or Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @return the corresponding MethodParameter instance\r\n * @deprecated as of 5.0, in favor of {@link #forExecutable}\r\n */\r\n@Deprecated\r\npublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\r\n    if (!(methodOrConstructor instanceof Executable executable)) {\r\n        throw new IllegalArgumentException(\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\r\n    }\r\n    return forExecutable(executable, parameterIndex);\r\n}\n/**\r\n * Create a new MethodParameter for the given method or constructor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Method or Constructor reference is treated in a generic fashion.\r\n * @param executable the Method or Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @return the corresponding MethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\r\n    if (executable instanceof Method method) {\r\n        return new MethodParameter(method, parameterIndex);\r\n    } else if (executable instanceof Constructor<?> constructor) {\r\n        return new MethodParameter(constructor, parameterIndex);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\r\n    }\r\n}\n/**\r\n * Create a new MethodParameter for the given parameter descriptor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Java 8 {@link Parameter} descriptor is already available.\r\n * @param parameter the parameter descriptor\r\n * @return the corresponding MethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static MethodParameter forParameter(Parameter parameter) {\r\n    return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));\r\n}\nprotected static int findParameterIndex(Parameter parameter) {\r\n    Executable executable = parameter.getDeclaringExecutable();\r\n    Parameter[] allParams = executable.getParameters();\r\n    // Try first with identity checks for greater performance.\r\n    for (int i = 0; i < allParams.length; i++) {\r\n        if (parameter == allParams[i]) {\r\n            return i;\r\n        }\r\n    }\r\n    // Potentially try again with object equality checks in order to avoid race\r\n    // conditions while invoking java.lang.reflect.Executable.getParameters().\r\n    for (int i = 0; i < allParams.length; i++) {\r\n        if (parameter.equals(allParams[i])) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Given parameter [\" + parameter + \"] does not match any parameter in the declaring executable\");\r\n}\nprivate static int validateIndex(Executable executable, int parameterIndex) {\r\n    int count = executable.getParameterCount();\r\n    Assert.isTrue(parameterIndex >= -1 && parameterIndex < count, () -> \"Parameter index needs to be between -1 and \" + (count - 1));\r\n    return parameterIndex;\r\n}\n/**\r\n * Create a new MethodParameter for the given field-aware constructor,\r\n * for example, on a data class or record type.\r\n * <p>A field-aware method parameter will detect field annotations as well,\r\n * as long as the field name matches the parameter name.\r\n * @param ctor the Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @param fieldName the name of the underlying field,\r\n * matching the constructor's parameter name\r\n * @return the corresponding MethodParameter instance\r\n * @since 6.1\r\n */\r\npublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, @Nullable String fieldName) {\r\n    return new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\r\n}\n/**\r\n * {@link MethodParameter} subclass which detects field annotations as well.\r\n */\r\nprivate static class FieldAwareConstructorParameter extends MethodParameter {\r\n\r\n    private volatile Annotation @Nullable [] combinedAnnotations;\r\n\r\n    public FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, @Nullable String fieldName) {\r\n        super(constructor, parameterIndex);\r\n        this.parameterName = fieldName;\r\n    }\r\n\r\n    @Override\r\n    public Annotation[] getParameterAnnotations() {\r\n        String parameterName = this.parameterName;\r\n        Assert.state(parameterName != null, \"Parameter name not initialized\");\r\n        Annotation[] anns = this.combinedAnnotations;\r\n        if (anns == null) {\r\n            anns = super.getParameterAnnotations();\r\n            try {\r\n                Field field = getDeclaringClass().getDeclaredField(parameterName);\r\n                Annotation[] fieldAnns = field.getAnnotations();\r\n                if (fieldAnns.length > 0) {\r\n                    List<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\r\n                    merged.addAll(Arrays.asList(anns));\r\n                    for (Annotation fieldAnn : fieldAnns) {\r\n                        boolean existingType = false;\r\n                        for (Annotation ann : anns) {\r\n                            if (ann.annotationType() == fieldAnn.annotationType()) {\r\n                                existingType = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!existingType) {\r\n                            merged.add(fieldAnn);\r\n                        }\r\n                    }\r\n                    anns = merged.toArray(EMPTY_ANNOTATION_ARRAY);\r\n                }\r\n            } catch (NoSuchFieldException | SecurityException ex) {\r\n                // ignore\r\n            }\r\n            this.combinedAnnotations = anns;\r\n        }\r\n        return anns;\r\n    }\r\n}\n/**\r\n * Inner class to avoid a hard dependency on Kotlin at runtime.\r\n */\r\nprivate static class KotlinDelegate {\r\n\r\n    /**\r\n     * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\r\n     * an optional parameter (with a default value in the Kotlin declaration) or a\r\n     * {@code Continuation} parameter used in suspending functions.\r\n     */\r\n    public static boolean isOptional(MethodParameter param) {\r\n        Method method = param.getMethod();\r\n        int index = param.getParameterIndex();\r\n        if (method != null && index == -1) {\r\n            KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n            return (function != null && function.getReturnType().isMarkedNullable());\r\n        }\r\n        KFunction<?> function;\r\n        Predicate<KParameter> predicate;\r\n        if (method != null) {\r\n            if (param.getParameterType().getName().equals(\"kotlin.coroutines.Continuation\")) {\r\n                return true;\r\n            }\r\n            function = ReflectJvmMapping.getKotlinFunction(method);\r\n            predicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\r\n        } else {\r\n            Constructor<?> ctor = param.getConstructor();\r\n            Assert.state(ctor != null, \"Neither method nor constructor found\");\r\n            function = ReflectJvmMapping.getKotlinFunction(ctor);\r\n            predicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) || KParameter.Kind.INSTANCE.equals(p.getKind()));\r\n        }\r\n        if (function != null) {\r\n            int i = 0;\r\n            for (KParameter kParameter : function.getParameters()) {\r\n                if (predicate.test(kParameter)) {\r\n                    if (index == i++) {\r\n                        return (kParameter.getType().isMarkedNullable() || kParameter.isOptional());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return the generic return type of the method, with support of suspending\r\n     * functions via Kotlin reflection.\r\n     */\r\n    private static Type getGenericReturnType(Method method) {\r\n        try {\r\n            KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n            if (function != null && function.isSuspend()) {\r\n                return ReflectJvmMapping.getJavaType(function.getReturnType());\r\n            }\r\n        } catch (UnsupportedOperationException ex) {\r\n            // probably a synthetic class - let's use java reflection instead\r\n        }\r\n        return method.getGenericReturnType();\r\n    }\r\n\r\n    /**\r\n     * Return the return type of the method, with support of suspending\r\n     * functions via Kotlin reflection.\r\n     */\r\n    private static Class<?> getReturnType(Method method) {\r\n        try {\r\n            KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n            if (function != null && function.isSuspend()) {\r\n                Type paramType = ReflectJvmMapping.getJavaType(function.getReturnType());\r\n                if (paramType == Unit.class) {\r\n                    paramType = void.class;\r\n                }\r\n                return ResolvableType.forType(paramType).resolve(method.getReturnType());\r\n            }\r\n        } catch (UnsupportedOperationException ex) {\r\n            // probably a synthetic class - let's use java reflection instead\r\n        }\r\n        return method.getReturnType();\r\n    }\r\n}",
    "comment": "\n * Helper class that encapsulates the specification of a method parameter, i.e. a {@link Method}\n * or {@link Constructor} plus a parameter index and a nested type index for a declared generic\n * type. Useful as a specification object to pass along.\n *\n * <p>As of 4.2, there is a {@link org.springframework.core.annotation.SynthesizingMethodParameter}\n * subclass available which synthesizes annotations with attribute aliases. That subclass is used\n * for web and message endpoint processing, in particular.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Andy Clement\n * @author Sam Brannen\n * @author Sebastien Deleuze\n * @author Phillip Webb\n * @since 2.0\n * @see org.springframework.core.annotation.SynthesizingMethodParameter\n "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getMethod()",
    "entityType": "method",
    "code": "/**\r\n * Return the wrapped Method, if any.\r\n * <p>Note: Either Method or Constructor is available.\r\n * @return the Method, or {@code null} if none\r\n */\r\n@Nullable\r\npublic Method getMethod() {\r\n    return (this.executable instanceof Method method ? method : null);\r\n}",
    "comment": "\n\t * Return the wrapped Method, if any.\n\t * <p>Note: Either Method or Constructor is available.\n\t * @return the Method, or {@code null} if none\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getConstructor()",
    "entityType": "method",
    "code": "/**\r\n * Return the wrapped Constructor, if any.\r\n * <p>Note: Either Method or Constructor is available.\r\n * @return the Constructor, or {@code null} if none\r\n */\r\n@Nullable\r\npublic Constructor<?> getConstructor() {\r\n    return (this.executable instanceof Constructor<?> constructor ? constructor : null);\r\n}",
    "comment": "\n\t * Return the wrapped Constructor, if any.\n\t * <p>Note: Either Method or Constructor is available.\n\t * @return the Constructor, or {@code null} if none\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getDeclaringClass()",
    "entityType": "method",
    "code": "/**\r\n * Return the class that declares the underlying Method or Constructor.\r\n */\r\npublic Class<?> getDeclaringClass() {\r\n    return this.executable.getDeclaringClass();\r\n}",
    "comment": "\n\t * Return the class that declares the underlying Method or Constructor.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getMember()",
    "entityType": "method",
    "code": "/**\r\n * Return the wrapped member.\r\n * @return the Method or Constructor as Member\r\n */\r\npublic Member getMember() {\r\n    return this.executable;\r\n}",
    "comment": "\n\t * Return the wrapped member.\n\t * @return the Method or Constructor as Member\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getAnnotatedElement()",
    "entityType": "method",
    "code": "/**\r\n * Return the wrapped annotated element.\r\n * <p>Note: This method exposes the annotations declared on the method/constructor\r\n * itself (i.e. at the method/constructor level, not at the parameter level).\r\n * <p>To get the {@link AnnotatedElement} at the parameter level, use\r\n * {@link #getParameter()}.\r\n * @return the Method or Constructor as AnnotatedElement\r\n */\r\npublic AnnotatedElement getAnnotatedElement() {\r\n    return this.executable;\r\n}",
    "comment": "\n\t * Return the wrapped annotated element.\n\t * <p>Note: This method exposes the annotations declared on the method/constructor\n\t * itself (i.e. at the method/constructor level, not at the parameter level).\n\t * <p>To get the {@link AnnotatedElement} at the parameter level, use\n\t * {@link #getParameter()}.\n\t * @return the Method or Constructor as AnnotatedElement\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getExecutable()",
    "entityType": "method",
    "code": "/**\r\n * Return the wrapped executable.\r\n * @return the Method or Constructor as Executable\r\n * @since 5.0\r\n */\r\npublic Executable getExecutable() {\r\n    return this.executable;\r\n}",
    "comment": "\n\t * Return the wrapped executable.\n\t * @return the Method or Constructor as Executable\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getParameter()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link Parameter} descriptor for method/constructor parameter.\r\n * @since 5.0\r\n */\r\npublic Parameter getParameter() {\r\n    if (this.parameterIndex < 0) {\r\n        throw new IllegalStateException(\"Cannot retrieve Parameter descriptor for method return type\");\r\n    }\r\n    Parameter parameter = this.parameter;\r\n    if (parameter == null) {\r\n        parameter = getExecutable().getParameters()[this.parameterIndex];\r\n        this.parameter = parameter;\r\n    }\r\n    return parameter;\r\n}",
    "comment": "\n\t * Return the {@link Parameter} descriptor for method/constructor parameter.\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getParameterIndex()",
    "entityType": "method",
    "code": "/**\r\n * Return the index of the method/constructor parameter.\r\n * @return the parameter index (-1 in case of the return type)\r\n */\r\npublic int getParameterIndex() {\r\n    return this.parameterIndex;\r\n}",
    "comment": "\n\t * Return the index of the method/constructor parameter.\n\t * @return the parameter index (-1 in case of the return type)\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#increaseNestingLevel()",
    "entityType": "method",
    "code": "/**\r\n * Increase this parameter's nesting level.\r\n * @see #getNestingLevel()\r\n * @deprecated since 5.2 in favor of {@link #nested(Integer)}\r\n */\r\n@Deprecated\r\npublic void increaseNestingLevel() {\r\n    this.nestingLevel++;\r\n}",
    "comment": "\n\t * Increase this parameter's nesting level.\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of {@link #nested(Integer)}\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#decreaseNestingLevel()",
    "entityType": "method",
    "code": "/**\r\n * Decrease this parameter's nesting level.\r\n * @see #getNestingLevel()\r\n * @deprecated since 5.2 in favor of retaining the original MethodParameter and\r\n * using {@link #nested(Integer)} if nesting is required\r\n */\r\n@Deprecated\r\npublic void decreaseNestingLevel() {\r\n    getTypeIndexesPerLevel().remove(this.nestingLevel);\r\n    this.nestingLevel--;\r\n}",
    "comment": "\n\t * Decrease this parameter's nesting level.\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of retaining the original MethodParameter and\n\t * using {@link #nested(Integer)} if nesting is required\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getNestingLevel()",
    "entityType": "method",
    "code": "/**\r\n * Return the nesting level of the target type\r\n * (typically 1; for example, in case of a List of Lists, 1 would indicate the\r\n * nested List, whereas 2 would indicate the element of the nested List).\r\n */\r\npublic int getNestingLevel() {\r\n    return this.nestingLevel;\r\n}",
    "comment": "\n\t * Return the nesting level of the target type\n\t * (typically 1; for example, in case of a List of Lists, 1 would indicate the\n\t * nested List, whereas 2 would indicate the element of the nested List).\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#withTypeIndex(int)",
    "entityType": "method",
    "code": "/**\r\n * Return a variant of this {@code MethodParameter} with the type\r\n * for the current level set to the specified value.\r\n * @param typeIndex the new type index\r\n * @since 5.2\r\n */\r\npublic MethodParameter withTypeIndex(int typeIndex) {\r\n    return nested(this.nestingLevel, typeIndex);\r\n}",
    "comment": "\n\t * Return a variant of this {@code MethodParameter} with the type\n\t * for the current level set to the specified value.\n\t * @param typeIndex the new type index\n\t * @since 5.2\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#setTypeIndexForCurrentLevel(int)",
    "entityType": "method",
    "code": "/**\r\n * Set the type index for the current nesting level.\r\n * @param typeIndex the corresponding type index\r\n * (or {@code null} for the default type index)\r\n * @see #getNestingLevel()\r\n * @deprecated since 5.2 in favor of {@link #withTypeIndex}\r\n */\r\n@Deprecated\r\npublic void setTypeIndexForCurrentLevel(int typeIndex) {\r\n    getTypeIndexesPerLevel().put(this.nestingLevel, typeIndex);\r\n}",
    "comment": "\n\t * Set the type index for the current nesting level.\n\t * @param typeIndex the corresponding type index\n\t * (or {@code null} for the default type index)\n\t * @see #getNestingLevel()\n\t * @deprecated since 5.2 in favor of {@link #withTypeIndex}\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getTypeIndexForCurrentLevel()",
    "entityType": "method",
    "code": "/**\r\n * Return the type index for the current nesting level.\r\n * @return the corresponding type index, or {@code null}\r\n * if none specified (indicating the default type index)\r\n * @see #getNestingLevel()\r\n */\r\n@Nullable\r\npublic Integer getTypeIndexForCurrentLevel() {\r\n    return getTypeIndexForLevel(this.nestingLevel);\r\n}",
    "comment": "\n\t * Return the type index for the current nesting level.\n\t * @return the corresponding type index, or {@code null}\n\t * if none specified (indicating the default type index)\n\t * @see #getNestingLevel()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getTypeIndexForLevel(int)",
    "entityType": "method",
    "code": "/**\r\n * Return the type index for the specified nesting level.\r\n * @param nestingLevel the nesting level to check\r\n * @return the corresponding type index, or {@code null}\r\n * if none specified (indicating the default type index)\r\n */\r\n@Nullable\r\npublic Integer getTypeIndexForLevel(int nestingLevel) {\r\n    return getTypeIndexesPerLevel().get(nestingLevel);\r\n}",
    "comment": "\n\t * Return the type index for the specified nesting level.\n\t * @param nestingLevel the nesting level to check\n\t * @return the corresponding type index, or {@code null}\n\t * if none specified (indicating the default type index)\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getTypeIndexesPerLevel()",
    "entityType": "method",
    "code": "/**\r\n * Obtain the (lazily constructed) type-indexes-per-level Map.\r\n */\r\nprivate Map<Integer, Integer> getTypeIndexesPerLevel() {\r\n    if (this.typeIndexesPerLevel == null) {\r\n        this.typeIndexesPerLevel = new HashMap<>(4);\r\n    }\r\n    return this.typeIndexesPerLevel;\r\n}",
    "comment": "\n\t * Obtain the (lazily constructed) type-indexes-per-level Map.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#nested()",
    "entityType": "method",
    "code": "/**\r\n * Return a variant of this {@code MethodParameter} which points to the\r\n * same parameter but one nesting level deeper.\r\n * @since 4.3\r\n */\r\npublic MethodParameter nested() {\r\n    return nested(null);\r\n}",
    "comment": "\n\t * Return a variant of this {@code MethodParameter} which points to the\n\t * same parameter but one nesting level deeper.\n\t * @since 4.3\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#nested(Integer)",
    "entityType": "method",
    "code": "/**\r\n * Return a variant of this {@code MethodParameter} which points to the\r\n * same parameter but one nesting level deeper.\r\n * @param typeIndex the type index for the new nesting level\r\n * @since 5.2\r\n */\r\npublic MethodParameter nested(@Nullable Integer typeIndex) {\r\n    MethodParameter nestedParam = this.nestedMethodParameter;\r\n    if (nestedParam != null && typeIndex == null) {\r\n        return nestedParam;\r\n    }\r\n    nestedParam = nested(this.nestingLevel + 1, typeIndex);\r\n    if (typeIndex == null) {\r\n        this.nestedMethodParameter = nestedParam;\r\n    }\r\n    return nestedParam;\r\n}",
    "comment": "\n\t * Return a variant of this {@code MethodParameter} which points to the\n\t * same parameter but one nesting level deeper.\n\t * @param typeIndex the type index for the new nesting level\n\t * @since 5.2\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#nested(int,Integer)",
    "entityType": "method",
    "code": "private MethodParameter nested(int nestingLevel, @Nullable Integer typeIndex) {\r\n    MethodParameter copy = clone();\r\n    copy.nestingLevel = nestingLevel;\r\n    if (this.typeIndexesPerLevel != null) {\r\n        copy.typeIndexesPerLevel = new HashMap<>(this.typeIndexesPerLevel);\r\n    }\r\n    if (typeIndex != null) {\r\n        copy.getTypeIndexesPerLevel().put(copy.nestingLevel, typeIndex);\r\n    }\r\n    copy.parameterType = null;\r\n    copy.genericParameterType = null;\r\n    return copy;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#isOptional()",
    "entityType": "method",
    "code": "/**\r\n * Return whether this method indicates a parameter which is not required:\r\n * either in the form of Java 8's {@link java.util.Optional}, JSpecify annotations,\r\n * any variant of a parameter-level {@code @Nullable} annotation (such as from Spring,\r\n * JSR-305 or Jakarta set of annotations), a language-level nullable type\r\n * declaration or {@code Continuation} parameter in Kotlin.\r\n * @since 4.3\r\n * @see Nullness#forMethodParameter(MethodParameter)\r\n */\r\npublic boolean isOptional() {\r\n    return (getParameterType() == Optional.class || Nullness.forMethodParameter(this) == Nullness.NULLABLE || (KotlinDetector.isKotlinType(getContainingClass()) && KotlinDelegate.isOptional(this)));\r\n}",
    "comment": "\n\t * Return whether this method indicates a parameter which is not required:\n\t * either in the form of Java 8's {@link java.util.Optional}, JSpecify annotations,\n\t * any variant of a parameter-level {@code @Nullable} annotation (such as from Spring,\n\t * JSR-305 or Jakarta set of annotations), a language-level nullable type\n\t * declaration or {@code Continuation} parameter in Kotlin.\n\t * @since 4.3\n\t * @see Nullness#forMethodParameter(MethodParameter)\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#nestedIfOptional()",
    "entityType": "method",
    "code": "/**\r\n * Return a variant of this {@code MethodParameter} which points to\r\n * the same parameter but one nesting level deeper in case of a\r\n * {@link java.util.Optional} declaration.\r\n * @since 4.3\r\n * @see #isOptional()\r\n * @see #nested()\r\n */\r\npublic MethodParameter nestedIfOptional() {\r\n    return (getParameterType() == Optional.class ? nested() : this);\r\n}",
    "comment": "\n\t * Return a variant of this {@code MethodParameter} which points to\n\t * the same parameter but one nesting level deeper in case of a\n\t * {@link java.util.Optional} declaration.\n\t * @since 4.3\n\t * @see #isOptional()\n\t * @see #nested()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#withContainingClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return a variant of this {@code MethodParameter} which refers to the\r\n * given containing class.\r\n * @param containingClass a specific containing class (potentially a\r\n * subclass of the declaring class, for example, substituting a type variable)\r\n * @since 5.2\r\n * @see #getParameterType()\r\n */\r\npublic MethodParameter withContainingClass(@Nullable Class<?> containingClass) {\r\n    MethodParameter result = clone();\r\n    result.containingClass = containingClass;\r\n    result.parameterType = null;\r\n    return result;\r\n}",
    "comment": "\n\t * Return a variant of this {@code MethodParameter} which refers to the\n\t * given containing class.\n\t * @param containingClass a specific containing class (potentially a\n\t * subclass of the declaring class, for example, substituting a type variable)\n\t * @since 5.2\n\t * @see #getParameterType()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#setContainingClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Set a containing class to resolve the parameter type against.\r\n */\r\n@Deprecated\r\nvoid setContainingClass(Class<?> containingClass) {\r\n    this.containingClass = containingClass;\r\n    this.parameterType = null;\r\n}",
    "comment": "\n\t * Set a containing class to resolve the parameter type against.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getContainingClass()",
    "entityType": "method",
    "code": "/**\r\n * Return the containing class for this method parameter.\r\n * @return a specific containing class (potentially a subclass of the\r\n * declaring class), or otherwise simply the declaring class itself\r\n * @see #getDeclaringClass()\r\n */\r\npublic Class<?> getContainingClass() {\r\n    Class<?> containingClass = this.containingClass;\r\n    return (containingClass != null ? containingClass : getDeclaringClass());\r\n}",
    "comment": "\n\t * Return the containing class for this method parameter.\n\t * @return a specific containing class (potentially a subclass of the\n\t * declaring class), or otherwise simply the declaring class itself\n\t * @see #getDeclaringClass()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#setParameterType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Set a resolved (generic) parameter type.\r\n */\r\n@Deprecated\r\nvoid setParameterType(@Nullable Class<?> parameterType) {\r\n    this.parameterType = parameterType;\r\n}",
    "comment": "\n\t * Set a resolved (generic) parameter type.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getParameterType()",
    "entityType": "method",
    "code": "/**\r\n * Return the type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n */\r\npublic Class<?> getParameterType() {\r\n    Class<?> paramType = this.parameterType;\r\n    if (paramType != null) {\r\n        return paramType;\r\n    }\r\n    if (getContainingClass() != getDeclaringClass()) {\r\n        paramType = ResolvableType.forMethodParameter(this, null, 1).resolve();\r\n    }\r\n    if (paramType == null) {\r\n        paramType = computeParameterType();\r\n    }\r\n    this.parameterType = paramType;\r\n    return paramType;\r\n}",
    "comment": "\n\t * Return the type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getGenericParameterType()",
    "entityType": "method",
    "code": "/**\r\n * Return the generic type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n * @since 3.0\r\n */\r\npublic Type getGenericParameterType() {\r\n    Type paramType = this.genericParameterType;\r\n    if (paramType == null) {\r\n        if (this.parameterIndex < 0) {\r\n            Method method = getMethod();\r\n            paramType = (method != null ? (KotlinDetector.isKotlinType(getContainingClass()) ? KotlinDelegate.getGenericReturnType(method) : method.getGenericReturnType()) : void.class);\r\n        } else {\r\n            Type[] genericParameterTypes = this.executable.getGenericParameterTypes();\r\n            int index = this.parameterIndex;\r\n            if (this.executable instanceof Constructor && ClassUtils.isInnerClass(this.executable.getDeclaringClass()) && genericParameterTypes.length == this.executable.getParameterCount() - 1) {\r\n                // Bug in javac: type array excludes enclosing instance parameter\r\n                // for inner classes with at least one generic constructor parameter,\r\n                // so access it with the actual parameter index lowered by 1\r\n                index = this.parameterIndex - 1;\r\n            }\r\n            paramType = (index >= 0 && index < genericParameterTypes.length ? genericParameterTypes[index] : computeParameterType());\r\n        }\r\n        this.genericParameterType = paramType;\r\n    }\r\n    return paramType;\r\n}",
    "comment": "\n\t * Return the generic type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 3.0\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#computeParameterType()",
    "entityType": "method",
    "code": "private Class<?> computeParameterType() {\r\n    if (this.parameterIndex < 0) {\r\n        Method method = getMethod();\r\n        if (method == null) {\r\n            return void.class;\r\n        }\r\n        if (KotlinDetector.isKotlinType(getContainingClass())) {\r\n            return KotlinDelegate.getReturnType(method);\r\n        }\r\n        return method.getReturnType();\r\n    }\r\n    return this.executable.getParameterTypes()[this.parameterIndex];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getNestedParameterType()",
    "entityType": "method",
    "code": "/**\r\n * Return the nested type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n * @since 3.1\r\n * @see #getNestingLevel()\r\n */\r\npublic Class<?> getNestedParameterType() {\r\n    if (this.nestingLevel > 1) {\r\n        Type type = getGenericParameterType();\r\n        for (int i = 2; i <= this.nestingLevel; i++) {\r\n            if (type instanceof ParameterizedType parameterizedType) {\r\n                Type[] args = parameterizedType.getActualTypeArguments();\r\n                Integer index = getTypeIndexForLevel(i);\r\n                type = args[index != null ? index : args.length - 1];\r\n            }\r\n            // TODO: Object.class if unresolvable\r\n        }\r\n        if (type instanceof Class<?> clazz) {\r\n            return clazz;\r\n        } else if (type instanceof ParameterizedType parameterizedType) {\r\n            Type arg = parameterizedType.getRawType();\r\n            if (arg instanceof Class<?> clazz) {\r\n                return clazz;\r\n            }\r\n        }\r\n        return Object.class;\r\n    } else {\r\n        return getParameterType();\r\n    }\r\n}",
    "comment": "\n\t * Return the nested type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 3.1\n\t * @see #getNestingLevel()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getNestedGenericParameterType()",
    "entityType": "method",
    "code": "/**\r\n * Return the nested generic type of the method/constructor parameter.\r\n * @return the parameter type (never {@code null})\r\n * @since 4.2\r\n * @see #getNestingLevel()\r\n */\r\npublic Type getNestedGenericParameterType() {\r\n    if (this.nestingLevel > 1) {\r\n        Type type = getGenericParameterType();\r\n        for (int i = 2; i <= this.nestingLevel; i++) {\r\n            if (type instanceof ParameterizedType parameterizedType) {\r\n                Type[] args = parameterizedType.getActualTypeArguments();\r\n                Integer index = getTypeIndexForLevel(i);\r\n                type = args[index != null ? index : args.length - 1];\r\n            }\r\n        }\r\n        return type;\r\n    } else {\r\n        return getGenericParameterType();\r\n    }\r\n}",
    "comment": "\n\t * Return the nested generic type of the method/constructor parameter.\n\t * @return the parameter type (never {@code null})\n\t * @since 4.2\n\t * @see #getNestingLevel()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getMethodAnnotations()",
    "entityType": "method",
    "code": "/**\r\n * Return the annotations associated with the target method/constructor itself.\r\n */\r\npublic Annotation[] getMethodAnnotations() {\r\n    return adaptAnnotationArray(getAnnotatedElement().getAnnotations());\r\n}",
    "comment": "\n\t * Return the annotations associated with the target method/constructor itself.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getMethodAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Return the method/constructor annotation of the given type, if available.\r\n * @param annotationType the annotation type to look for\r\n * @return the annotation object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {\r\n    A annotation = getAnnotatedElement().getAnnotation(annotationType);\r\n    return (annotation != null ? adaptAnnotation(annotation) : null);\r\n}",
    "comment": "\n\t * Return the method/constructor annotation of the given type, if available.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation object, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#hasMethodAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the method/constructor is annotated with the given type.\r\n * @param annotationType the annotation type to look for\r\n * @since 4.3\r\n * @see #getMethodAnnotation(Class)\r\n */\r\npublic <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {\r\n    return getAnnotatedElement().isAnnotationPresent(annotationType);\r\n}",
    "comment": "\n\t * Return whether the method/constructor is annotated with the given type.\n\t * @param annotationType the annotation type to look for\n\t * @since 4.3\n\t * @see #getMethodAnnotation(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getParameterAnnotations()",
    "entityType": "method",
    "code": "/**\r\n * Return the annotations associated with the specific method/constructor parameter.\r\n */\r\npublic Annotation[] getParameterAnnotations() {\r\n    Annotation[] paramAnns = this.parameterAnnotations;\r\n    if (paramAnns == null) {\r\n        Annotation[][] annotationArray = this.executable.getParameterAnnotations();\r\n        int index = this.parameterIndex;\r\n        if (this.executable instanceof Constructor && ClassUtils.isInnerClass(this.executable.getDeclaringClass()) && annotationArray.length == this.executable.getParameterCount() - 1) {\r\n            // Bug in javac in JDK <9: annotation array excludes enclosing instance parameter\r\n            // for inner classes, so access it with the actual parameter index lowered by 1\r\n            index = this.parameterIndex - 1;\r\n        }\r\n        paramAnns = (index >= 0 && index < annotationArray.length && annotationArray[index].length > 0 ? adaptAnnotationArray(annotationArray[index]) : EMPTY_ANNOTATION_ARRAY);\r\n        this.parameterAnnotations = paramAnns;\r\n    }\r\n    return paramAnns;\r\n}",
    "comment": "\n\t * Return the annotations associated with the specific method/constructor parameter.\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#hasParameterAnnotations()",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the parameter has at least one annotation,\r\n * {@code false} if it has none.\r\n * @see #getParameterAnnotations()\r\n */\r\npublic boolean hasParameterAnnotations() {\r\n    return (getParameterAnnotations().length != 0);\r\n}",
    "comment": "\n\t * Return {@code true} if the parameter has at least one annotation,\n\t * {@code false} if it has none.\n\t * @see #getParameterAnnotations()\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getParameterAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Return the parameter annotation of the given type, if available.\r\n * @param annotationType the annotation type to look for\r\n * @return the annotation object, or {@code null} if not found\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic <A extends Annotation> A getParameterAnnotation(Class<A> annotationType) {\r\n    Annotation[] anns = getParameterAnnotations();\r\n    for (Annotation ann : anns) {\r\n        if (annotationType.isInstance(ann)) {\r\n            return (A) ann;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Return the parameter annotation of the given type, if available.\n\t * @param annotationType the annotation type to look for\n\t * @return the annotation object, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#hasParameterAnnotation(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the parameter is declared with the given annotation type.\r\n * @param annotationType the annotation type to look for\r\n * @see #getParameterAnnotation(Class)\r\n */\r\npublic <A extends Annotation> boolean hasParameterAnnotation(Class<A> annotationType) {\r\n    return (getParameterAnnotation(annotationType) != null);\r\n}",
    "comment": "\n\t * Return whether the parameter is declared with the given annotation type.\n\t * @param annotationType the annotation type to look for\n\t * @see #getParameterAnnotation(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#initParameterNameDiscovery(ParameterNameDiscoverer)",
    "entityType": "method",
    "code": "/**\r\n * Initialize parameter name discovery for this method parameter.\r\n * <p>This method does not actually try to retrieve the parameter name at\r\n * this point; it just allows discovery to happen when the application calls\r\n * {@link #getParameterName()} (if ever).\r\n */\r\npublic void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {\r\n    this.parameterNameDiscoverer = parameterNameDiscoverer;\r\n}",
    "comment": "\n\t * Initialize parameter name discovery for this method parameter.\n\t * <p>This method does not actually try to retrieve the parameter name at\n\t * this point; it just allows discovery to happen when the application calls\n\t * {@link #getParameterName()} (if ever).\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#getParameterName()",
    "entityType": "method",
    "code": "/**\r\n * Return the name of the method/constructor parameter.\r\n * @return the parameter name (may be {@code null} if no\r\n * parameter name metadata is contained in the class file or no\r\n * {@link #initParameterNameDiscovery ParameterNameDiscoverer}\r\n * has been set to begin with)\r\n */\r\n@Nullable\r\npublic String getParameterName() {\r\n    if (this.parameterIndex < 0) {\r\n        return null;\r\n    }\r\n    ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;\r\n    if (discoverer != null) {\r\n        @Nullable\r\n        String[] parameterNames = null;\r\n        if (this.executable instanceof Method method) {\r\n            parameterNames = discoverer.getParameterNames(method);\r\n        } else if (this.executable instanceof Constructor<?> constructor) {\r\n            parameterNames = discoverer.getParameterNames(constructor);\r\n        }\r\n        if (parameterNames != null && this.parameterIndex < parameterNames.length) {\r\n            this.parameterName = parameterNames[this.parameterIndex];\r\n        }\r\n        this.parameterNameDiscoverer = null;\r\n    }\r\n    return this.parameterName;\r\n}",
    "comment": "\n\t * Return the name of the method/constructor parameter.\n\t * @return the parameter name (may be {@code null} if no\n\t * parameter name metadata is contained in the class file or no\n\t * {@link #initParameterNameDiscovery ParameterNameDiscoverer}\n\t * has been set to begin with)\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#adaptAnnotation(A)",
    "entityType": "method",
    "code": "/**\r\n * A template method to post-process a given annotation instance before\r\n * returning it to the caller.\r\n * <p>The default implementation simply returns the given annotation as-is.\r\n * @param annotation the annotation about to be returned\r\n * @return the post-processed annotation (or simply the original one)\r\n * @since 4.2\r\n */\r\nprotected <A extends Annotation> A adaptAnnotation(A annotation) {\r\n    return annotation;\r\n}",
    "comment": "\n\t * A template method to post-process a given annotation instance before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation as-is.\n\t * @param annotation the annotation about to be returned\n\t * @return the post-processed annotation (or simply the original one)\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#adaptAnnotationArray(Annotation[])",
    "entityType": "method",
    "code": "/**\r\n * A template method to post-process a given annotation array before\r\n * returning it to the caller.\r\n * <p>The default implementation simply returns the given annotation array as-is.\r\n * @param annotations the annotation array about to be returned\r\n * @return the post-processed annotation array (or simply the original one)\r\n * @since 4.2\r\n */\r\nprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\r\n    return annotations;\r\n}",
    "comment": "\n\t * A template method to post-process a given annotation array before\n\t * returning it to the caller.\n\t * <p>The default implementation simply returns the given annotation array as-is.\n\t * @param annotations the annotation array about to be returned\n\t * @return the post-processed annotation array (or simply the original one)\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MethodParameter that && getContainingClass() == that.getContainingClass() && ObjectUtils.nullSafeEquals(this.typeIndexesPerLevel, that.typeIndexesPerLevel) && this.nestingLevel == that.nestingLevel && this.parameterIndex == that.parameterIndex && this.executable.equals(that.executable)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return (31 * this.executable.hashCode() + this.parameterIndex);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    Method method = getMethod();\r\n    return (method != null ? \"method '\" + method.getName() + \"'\" : \"constructor\") + \" parameter \" + this.parameterIndex;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#clone()",
    "entityType": "method",
    "code": "@Override\r\npublic MethodParameter clone() {\r\n    return new MethodParameter(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#forMethodOrConstructor(Object,int)",
    "entityType": "method",
    "code": "/**\r\n * Create a new MethodParameter for the given method or constructor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Method or Constructor reference is treated in a generic fashion.\r\n * @param methodOrConstructor the Method or Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @return the corresponding MethodParameter instance\r\n * @deprecated as of 5.0, in favor of {@link #forExecutable}\r\n */\r\n@Deprecated\r\npublic static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {\r\n    if (!(methodOrConstructor instanceof Executable executable)) {\r\n        throw new IllegalArgumentException(\"Given object [\" + methodOrConstructor + \"] is neither a Method nor a Constructor\");\r\n    }\r\n    return forExecutable(executable, parameterIndex);\r\n}",
    "comment": "\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param methodOrConstructor the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @deprecated as of 5.0, in favor of {@link #forExecutable}\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#forExecutable(Executable,int)",
    "entityType": "method",
    "code": "/**\r\n * Create a new MethodParameter for the given method or constructor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Method or Constructor reference is treated in a generic fashion.\r\n * @param executable the Method or Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @return the corresponding MethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static MethodParameter forExecutable(Executable executable, int parameterIndex) {\r\n    if (executable instanceof Method method) {\r\n        return new MethodParameter(method, parameterIndex);\r\n    } else if (executable instanceof Constructor<?> constructor) {\r\n        return new MethodParameter(constructor, parameterIndex);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\r\n    }\r\n}",
    "comment": "\n\t * Create a new MethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#forParameter(Parameter)",
    "entityType": "method",
    "code": "/**\r\n * Create a new MethodParameter for the given parameter descriptor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Java 8 {@link Parameter} descriptor is already available.\r\n * @param parameter the parameter descriptor\r\n * @return the corresponding MethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static MethodParameter forParameter(Parameter parameter) {\r\n    return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));\r\n}",
    "comment": "\n\t * Create a new MethodParameter for the given parameter descriptor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Java 8 {@link Parameter} descriptor is already available.\n\t * @param parameter the parameter descriptor\n\t * @return the corresponding MethodParameter instance\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.MethodParameter#findParameterIndex(Parameter)",
    "entityType": "method",
    "code": "protected static int findParameterIndex(Parameter parameter) {\r\n    Executable executable = parameter.getDeclaringExecutable();\r\n    Parameter[] allParams = executable.getParameters();\r\n    // Try first with identity checks for greater performance.\r\n    for (int i = 0; i < allParams.length; i++) {\r\n        if (parameter == allParams[i]) {\r\n            return i;\r\n        }\r\n    }\r\n    // Potentially try again with object equality checks in order to avoid race\r\n    // conditions while invoking java.lang.reflect.Executable.getParameters().\r\n    for (int i = 0; i < allParams.length; i++) {\r\n        if (parameter.equals(allParams[i])) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Given parameter [\" + parameter + \"] does not match any parameter in the declaring executable\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#validateIndex(Executable,int)",
    "entityType": "method",
    "code": "private static int validateIndex(Executable executable, int parameterIndex) {\r\n    int count = executable.getParameterCount();\r\n    Assert.isTrue(parameterIndex >= -1 && parameterIndex < count, () -> \"Parameter index needs to be between -1 and \" + (count - 1));\r\n    return parameterIndex;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.MethodParameter#forFieldAwareConstructor(Constructor<?>,int,String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new MethodParameter for the given field-aware constructor,\r\n * for example, on a data class or record type.\r\n * <p>A field-aware method parameter will detect field annotations as well,\r\n * as long as the field name matches the parameter name.\r\n * @param ctor the Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @param fieldName the name of the underlying field,\r\n * matching the constructor's parameter name\r\n * @return the corresponding MethodParameter instance\r\n * @since 6.1\r\n */\r\npublic static MethodParameter forFieldAwareConstructor(Constructor<?> ctor, int parameterIndex, @Nullable String fieldName) {\r\n    return new FieldAwareConstructorParameter(ctor, parameterIndex, fieldName);\r\n}",
    "comment": "\n\t * Create a new MethodParameter for the given field-aware constructor,\n\t * for example, on a data class or record type.\n\t * <p>A field-aware method parameter will detect field annotations as well,\n\t * as long as the field name matches the parameter name.\n\t * @param ctor the Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @param fieldName the name of the underlying field,\n\t * matching the constructor's parameter name\n\t * @return the corresponding MethodParameter instance\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.core.FieldAwareConstructorParameter",
    "entityType": "class",
    "code": "private volatile Annotation @Nullable [] combinedAnnotations;\npublic FieldAwareConstructorParameter(Constructor<?> constructor, int parameterIndex, @Nullable String fieldName) {\r\n    super(constructor, parameterIndex);\r\n    this.parameterName = fieldName;\r\n}\n@Override\r\npublic Annotation[] getParameterAnnotations() {\r\n    String parameterName = this.parameterName;\r\n    Assert.state(parameterName != null, \"Parameter name not initialized\");\r\n    Annotation[] anns = this.combinedAnnotations;\r\n    if (anns == null) {\r\n        anns = super.getParameterAnnotations();\r\n        try {\r\n            Field field = getDeclaringClass().getDeclaredField(parameterName);\r\n            Annotation[] fieldAnns = field.getAnnotations();\r\n            if (fieldAnns.length > 0) {\r\n                List<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\r\n                merged.addAll(Arrays.asList(anns));\r\n                for (Annotation fieldAnn : fieldAnns) {\r\n                    boolean existingType = false;\r\n                    for (Annotation ann : anns) {\r\n                        if (ann.annotationType() == fieldAnn.annotationType()) {\r\n                            existingType = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!existingType) {\r\n                        merged.add(fieldAnn);\r\n                    }\r\n                }\r\n                anns = merged.toArray(EMPTY_ANNOTATION_ARRAY);\r\n            }\r\n        } catch (NoSuchFieldException | SecurityException ex) {\r\n            // ignore\r\n        }\r\n        this.combinedAnnotations = anns;\r\n    }\r\n    return anns;\r\n}",
    "comment": "\n\t * {@link MethodParameter} subclass which detects field annotations as well.\n\t "
  },
  {
    "entityId": "org.springframework.core.FieldAwareConstructorParameter#getParameterAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic Annotation[] getParameterAnnotations() {\r\n    String parameterName = this.parameterName;\r\n    Assert.state(parameterName != null, \"Parameter name not initialized\");\r\n    Annotation[] anns = this.combinedAnnotations;\r\n    if (anns == null) {\r\n        anns = super.getParameterAnnotations();\r\n        try {\r\n            Field field = getDeclaringClass().getDeclaredField(parameterName);\r\n            Annotation[] fieldAnns = field.getAnnotations();\r\n            if (fieldAnns.length > 0) {\r\n                List<Annotation> merged = new ArrayList<>(anns.length + fieldAnns.length);\r\n                merged.addAll(Arrays.asList(anns));\r\n                for (Annotation fieldAnn : fieldAnns) {\r\n                    boolean existingType = false;\r\n                    for (Annotation ann : anns) {\r\n                        if (ann.annotationType() == fieldAnn.annotationType()) {\r\n                            existingType = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!existingType) {\r\n                        merged.add(fieldAnn);\r\n                    }\r\n                }\r\n                anns = merged.toArray(EMPTY_ANNOTATION_ARRAY);\r\n            }\r\n        } catch (NoSuchFieldException | SecurityException ex) {\r\n            // ignore\r\n        }\r\n        this.combinedAnnotations = anns;\r\n    }\r\n    return anns;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.KotlinDelegate",
    "entityType": "class",
    "code": "/**\r\n * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\r\n * an optional parameter (with a default value in the Kotlin declaration) or a\r\n * {@code Continuation} parameter used in suspending functions.\r\n */\r\npublic static boolean isOptional(MethodParameter param) {\r\n    Method method = param.getMethod();\r\n    int index = param.getParameterIndex();\r\n    if (method != null && index == -1) {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        return (function != null && function.getReturnType().isMarkedNullable());\r\n    }\r\n    KFunction<?> function;\r\n    Predicate<KParameter> predicate;\r\n    if (method != null) {\r\n        if (param.getParameterType().getName().equals(\"kotlin.coroutines.Continuation\")) {\r\n            return true;\r\n        }\r\n        function = ReflectJvmMapping.getKotlinFunction(method);\r\n        predicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\r\n    } else {\r\n        Constructor<?> ctor = param.getConstructor();\r\n        Assert.state(ctor != null, \"Neither method nor constructor found\");\r\n        function = ReflectJvmMapping.getKotlinFunction(ctor);\r\n        predicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) || KParameter.Kind.INSTANCE.equals(p.getKind()));\r\n    }\r\n    if (function != null) {\r\n        int i = 0;\r\n        for (KParameter kParameter : function.getParameters()) {\r\n            if (predicate.test(kParameter)) {\r\n                if (index == i++) {\r\n                    return (kParameter.getType().isMarkedNullable() || kParameter.isOptional());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Return the generic return type of the method, with support of suspending\r\n * functions via Kotlin reflection.\r\n */\r\nprivate static Type getGenericReturnType(Method method) {\r\n    try {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        if (function != null && function.isSuspend()) {\r\n            return ReflectJvmMapping.getJavaType(function.getReturnType());\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // probably a synthetic class - let's use java reflection instead\r\n    }\r\n    return method.getGenericReturnType();\r\n}\n/**\r\n * Return the return type of the method, with support of suspending\r\n * functions via Kotlin reflection.\r\n */\r\nprivate static Class<?> getReturnType(Method method) {\r\n    try {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        if (function != null && function.isSuspend()) {\r\n            Type paramType = ReflectJvmMapping.getJavaType(function.getReturnType());\r\n            if (paramType == Unit.class) {\r\n                paramType = void.class;\r\n            }\r\n            return ResolvableType.forType(paramType).resolve(method.getReturnType());\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // probably a synthetic class - let's use java reflection instead\r\n    }\r\n    return method.getReturnType();\r\n}",
    "comment": "\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t "
  },
  {
    "entityId": "org.springframework.core.KotlinDelegate#isOptional(MethodParameter)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\r\n * an optional parameter (with a default value in the Kotlin declaration) or a\r\n * {@code Continuation} parameter used in suspending functions.\r\n */\r\npublic static boolean isOptional(MethodParameter param) {\r\n    Method method = param.getMethod();\r\n    int index = param.getParameterIndex();\r\n    if (method != null && index == -1) {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        return (function != null && function.getReturnType().isMarkedNullable());\r\n    }\r\n    KFunction<?> function;\r\n    Predicate<KParameter> predicate;\r\n    if (method != null) {\r\n        if (param.getParameterType().getName().equals(\"kotlin.coroutines.Continuation\")) {\r\n            return true;\r\n        }\r\n        function = ReflectJvmMapping.getKotlinFunction(method);\r\n        predicate = p -> KParameter.Kind.VALUE.equals(p.getKind());\r\n    } else {\r\n        Constructor<?> ctor = param.getConstructor();\r\n        Assert.state(ctor != null, \"Neither method nor constructor found\");\r\n        function = ReflectJvmMapping.getKotlinFunction(ctor);\r\n        predicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) || KParameter.Kind.INSTANCE.equals(p.getKind()));\r\n    }\r\n    if (function != null) {\r\n        int i = 0;\r\n        for (KParameter kParameter : function.getParameters()) {\r\n            if (predicate.test(kParameter)) {\r\n                if (index == i++) {\r\n                    return (kParameter.getType().isMarkedNullable() || kParameter.isOptional());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t\t * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,\n\t\t * an optional parameter (with a default value in the Kotlin declaration) or a\n\t\t * {@code Continuation} parameter used in suspending functions.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.KotlinDelegate#getGenericReturnType(Method)",
    "entityType": "method",
    "code": "/**\r\n * Return the generic return type of the method, with support of suspending\r\n * functions via Kotlin reflection.\r\n */\r\nprivate static Type getGenericReturnType(Method method) {\r\n    try {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        if (function != null && function.isSuspend()) {\r\n            return ReflectJvmMapping.getJavaType(function.getReturnType());\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // probably a synthetic class - let's use java reflection instead\r\n    }\r\n    return method.getGenericReturnType();\r\n}",
    "comment": "\n\t\t * Return the generic return type of the method, with support of suspending\n\t\t * functions via Kotlin reflection.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.KotlinDelegate#getReturnType(Method)",
    "entityType": "method",
    "code": "/**\r\n * Return the return type of the method, with support of suspending\r\n * functions via Kotlin reflection.\r\n */\r\nprivate static Class<?> getReturnType(Method method) {\r\n    try {\r\n        KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);\r\n        if (function != null && function.isSuspend()) {\r\n            Type paramType = ReflectJvmMapping.getJavaType(function.getReturnType());\r\n            if (paramType == Unit.class) {\r\n                paramType = void.class;\r\n            }\r\n            return ResolvableType.forType(paramType).resolve(method.getReturnType());\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // probably a synthetic class - let's use java reflection instead\r\n    }\r\n    return method.getReturnType();\r\n}",
    "comment": "\n\t\t * Return the return type of the method, with support of suspending\n\t\t * functions via Kotlin reflection.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.metrics.ApplicationStartup",
    "entityType": "class",
    "code": "/**\r\n * Default \"no op\" {@code ApplicationStartup} implementation.\r\n * <p>This variant is designed for minimal overhead and does not record data.\r\n */\r\nApplicationStartup DEFAULT = new DefaultApplicationStartup();\n/**\r\n * Create a new step and marks its beginning.\r\n * <p>A step name describes the current action or phase. This technical\r\n * name should be \".\" namespaced and can be reused to describe other instances of\r\n * the same step during application startup.\r\n * @param name the step name\r\n */\r\nStartupStep start(String name);",
    "comment": "\n * Instruments the application startup phase using {@link StartupStep steps}.\n * <p>The core container and its infrastructure components can use the {@code ApplicationStartup}\n * to mark steps during the application startup and collect data about the execution context\n * or their processing time.\n *\n * @author Brian Clozel\n * @since 5.3\n "
  },
  {
    "entityId": "org.springframework.core.metrics.ApplicationStartup#start(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new step and marks its beginning.\r\n * <p>A step name describes the current action or phase. This technical\r\n * name should be \".\" namespaced and can be reused to describe other instances of\r\n * the same step during application startup.\r\n * @param name the step name\r\n */\r\nStartupStep start(String name);",
    "comment": "\n\t * Create a new step and marks its beginning.\n\t * <p>A step name describes the current action or phase. This technical\n\t * name should be \".\" namespaced and can be reused to describe other instances of\n\t * the same step during application startup.\n\t * @param name the step name\n\t "
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultApplicationStartup",
    "entityType": "class",
    "code": "private static final DefaultStartupStep DEFAULT_STARTUP_STEP = new DefaultStartupStep();\n@Override\r\npublic DefaultStartupStep start(String name) {\r\n    return DEFAULT_STARTUP_STEP;\r\n}\nstatic class DefaultStartupStep implements StartupStep {\r\n\r\n    private final DefaultTags TAGS = new DefaultTags();\r\n\r\n    @Override\r\n    public String getName() {\r\n        return \"default\";\r\n    }\r\n\r\n    @Override\r\n    public long getId() {\r\n        return 0L;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Long getParentId() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Tags getTags() {\r\n        return this.TAGS;\r\n    }\r\n\r\n    @Override\r\n    public StartupStep tag(String key, String value) {\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n    public StartupStep tag(String key, Supplier<String> value) {\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n    public void end() {\r\n    }\r\n\r\n    static class DefaultTags implements StartupStep.Tags {\r\n\r\n        @Override\r\n        public Iterator<StartupStep.Tag> iterator() {\r\n            return Collections.emptyIterator();\r\n        }\r\n    }\r\n}",
    "comment": "\n * Default \"no op\" {@code ApplicationStartup} implementation.\n *\n * <p>This variant is designed for minimal overhead and does not record events.\n *\n * @author Brian Clozel\n "
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultApplicationStartup#start(String)",
    "entityType": "method",
    "code": "@Override\r\npublic DefaultStartupStep start(String name) {\r\n    return DEFAULT_STARTUP_STEP;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep",
    "entityType": "class",
    "code": "private final DefaultTags TAGS = new DefaultTags();\n@Override\r\npublic String getName() {\r\n    return \"default\";\r\n}\n@Override\r\npublic long getId() {\r\n    return 0L;\r\n}\n@Override\r\n@Nullable\r\npublic Long getParentId() {\r\n    return null;\r\n}\n@Override\r\npublic Tags getTags() {\r\n    return this.TAGS;\r\n}\n@Override\r\npublic StartupStep tag(String key, String value) {\r\n    return this;\r\n}\n@Override\r\npublic StartupStep tag(String key, Supplier<String> value) {\r\n    return this;\r\n}\n@Override\r\npublic void end() ;\nstatic class DefaultTags implements StartupStep.Tags {\r\n\r\n    @Override\r\n    public Iterator<StartupStep.Tag> iterator() {\r\n        return Collections.emptyIterator();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#getName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getName() {\r\n    return \"default\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#getId()",
    "entityType": "method",
    "code": "@Override\r\npublic long getId() {\r\n    return 0L;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#getParentId()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Long getParentId() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#getTags()",
    "entityType": "method",
    "code": "@Override\r\npublic Tags getTags() {\r\n    return this.TAGS;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#tag(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic StartupStep tag(String key, String value) {\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#tag(String,Supplier<String>)",
    "entityType": "method",
    "code": "@Override\r\npublic StartupStep tag(String key, Supplier<String> value) {\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultStartupStep#end()",
    "entityType": "method",
    "code": "@Override\r\npublic void end() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultTags",
    "entityType": "class",
    "code": "@Override\r\npublic Iterator<StartupStep.Tag> iterator() {\r\n    return Collections.emptyIterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.metrics.DefaultTags#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<StartupStep.Tag> iterator() {\r\n    return Collections.emptyIterator();\r\n}",
    "comment": ""
  }
]