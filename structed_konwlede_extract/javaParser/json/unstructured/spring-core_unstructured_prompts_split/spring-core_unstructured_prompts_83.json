[
  {
    "entityId": "org.springframework.util.PlaceholderParser#createSimplePlaceholderPart(String)",
    "entityType": "method",
    "code": "private SimplePlaceholderPart createSimplePlaceholderPart(String text) {\r\n    ParsedSection section = parseSection(text);\r\n    return new SimplePlaceholderPart(text, section.key(), section.fallback());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#createNestedPlaceholderPart(String,List<Part>)",
    "entityType": "method",
    "code": "private NestedPlaceholderPart createNestedPlaceholderPart(String text, List<Part> parts) {\r\n    if (this.separator == null) {\r\n        return new NestedPlaceholderPart(text, parts, null);\r\n    }\r\n    List<Part> keyParts = new ArrayList<>();\r\n    List<Part> defaultParts = new ArrayList<>();\r\n    for (int i = 0; i < parts.size(); i++) {\r\n        Part part = parts.get(i);\r\n        if (!(part instanceof TextPart)) {\r\n            keyParts.add(part);\r\n        } else {\r\n            String candidate = part.text();\r\n            ParsedSection section = parseSection(candidate);\r\n            keyParts.add(new TextPart(section.key()));\r\n            if (section.fallback() != null) {\r\n                defaultParts.add(new TextPart(section.fallback()));\r\n                defaultParts.addAll(parts.subList(i + 1, parts.size()));\r\n                return new NestedPlaceholderPart(text, keyParts, defaultParts);\r\n            }\r\n        }\r\n    }\r\n    return new NestedPlaceholderPart(text, keyParts, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#parseSection(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse an input value that may contain a separator character and return a\r\n * {@link ParsedValue}. If a valid separator character has been identified, the\r\n * given {@code value} is split between a {@code key} and a {@code fallback}. If not,\r\n * only the {@code key} is set.\r\n * <p>\r\n * The returned key may be different from the original value as escaped\r\n * separators, if any, are resolved.\r\n * @param value the value to parse\r\n * @return the parsed section\r\n */\r\nprivate ParsedSection parseSection(String value) {\r\n    if (this.separator == null || !value.contains(this.separator)) {\r\n        return new ParsedSection(value, null);\r\n    }\r\n    int position = 0;\r\n    int index = value.indexOf(this.separator, position);\r\n    StringBuilder buffer = new StringBuilder();\r\n    while (index != -1) {\r\n        if (isEscaped(value, index)) {\r\n            // Accumulate, without the escape character.\r\n            buffer.append(value, position, index - 1);\r\n            buffer.append(value, index, index + this.separator.length());\r\n            position = index + this.separator.length();\r\n            index = value.indexOf(this.separator, position);\r\n        } else {\r\n            buffer.append(value, position, index);\r\n            String key = buffer.toString();\r\n            String fallback = value.substring(index + this.separator.length());\r\n            return new ParsedSection(key, fallback);\r\n        }\r\n    }\r\n    buffer.append(value, position, value.length());\r\n    return new ParsedSection(buffer.toString(), null);\r\n}",
    "comment": "\n\t * Parse an input value that may contain a separator character and return a\n\t * {@link ParsedValue}. If a valid separator character has been identified, the\n\t * given {@code value} is split between a {@code key} and a {@code fallback}. If not,\n\t * only the {@code key} is set.\n\t * <p>\n\t * The returned key may be different from the original value as escaped\n\t * separators, if any, are resolved.\n\t * @param value the value to parse\n\t * @return the parsed section\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#addText(String,int,int,LinkedList<Part>)",
    "entityType": "method",
    "code": "private static void addText(String value, int start, int end, LinkedList<Part> parts) {\r\n    if (start > end) {\r\n        return;\r\n    }\r\n    String text = value.substring(start, end);\r\n    if (!text.isEmpty()) {\r\n        if (!parts.isEmpty()) {\r\n            Part current = parts.removeLast();\r\n            if (current instanceof TextPart textPart) {\r\n                parts.add(new TextPart(textPart.text() + text));\r\n            } else {\r\n                parts.add(current);\r\n                parts.add(new TextPart(text));\r\n            }\r\n        } else {\r\n            parts.add(new TextPart(text));\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#nextStartPrefix(String,int)",
    "entityType": "method",
    "code": "private int nextStartPrefix(String value, int index) {\r\n    return value.indexOf(this.prefix, index);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
    "entityType": "method",
    "code": "private int nextValidEndPrefix(String value, int startIndex) {\r\n    int index = startIndex + this.prefix.length();\r\n    int withinNestedPlaceholder = 0;\r\n    while (index < value.length()) {\r\n        if (StringUtils.substringMatch(value, index, this.suffix)) {\r\n            if (withinNestedPlaceholder > 0) {\r\n                withinNestedPlaceholder--;\r\n                index = index + this.suffix.length();\r\n            } else {\r\n                return index;\r\n            }\r\n        } else if (StringUtils.substringMatch(value, index, this.simplePrefix)) {\r\n            withinNestedPlaceholder++;\r\n            index = index + this.simplePrefix.length();\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    return -1;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#isEscaped(String,int)",
    "entityType": "method",
    "code": "private boolean isEscaped(String value, int index) {\r\n    return (this.escape != null && index > 0 && value.charAt(index - 1) == this.escape);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext",
    "entityType": "class",
    "code": "private final String prefix;\nprivate final String suffix;\nprivate final boolean ignoreUnresolvablePlaceholders;\nprivate final Function<String, List<Part>> parser;\nprivate final PlaceholderResolver resolver;\n@Nullable\r\nprivate Set<String> visitedPlaceholders;\nPartResolutionContext(PlaceholderResolver resolver, String prefix, String suffix, boolean ignoreUnresolvablePlaceholders, Function<String, List<Part>> parser) {\r\n    this.prefix = prefix;\r\n    this.suffix = suffix;\r\n    this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;\r\n    this.parser = parser;\r\n    this.resolver = resolver;\r\n}\n@Override\r\n@Nullable\r\npublic String resolvePlaceholder(String placeholderName) {\r\n    String value = this.resolver.resolvePlaceholder(placeholderName);\r\n    if (value != null && logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\r\n    }\r\n    return value;\r\n}\npublic String handleUnresolvablePlaceholder(String key, String text) {\r\n    if (this.ignoreUnresolvablePlaceholders) {\r\n        return toPlaceholderText(key);\r\n    }\r\n    String originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\r\n    throw new PlaceholderResolutionException(\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\r\n}\nprivate String toPlaceholderText(String text) {\r\n    return this.prefix + text + this.suffix;\r\n}\npublic List<Part> parse(String text) {\r\n    return this.parser.apply(text);\r\n}\npublic void flagPlaceholderAsVisited(String placeholder) {\r\n    if (this.visitedPlaceholders == null) {\r\n        this.visitedPlaceholders = new HashSet<>(4);\r\n    }\r\n    if (!this.visitedPlaceholders.add(placeholder)) {\r\n        throw new PlaceholderResolutionException(\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\r\n    }\r\n}\npublic void removePlaceholder(String placeholder) {\r\n    Assert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\r\n    this.visitedPlaceholders.remove(placeholder);\r\n}",
    "comment": "\n\t * Provide the necessary context to handle and resolve underlying placeholders.\n\t "
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext#resolvePlaceholder(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String resolvePlaceholder(String placeholderName) {\r\n    String value = this.resolver.resolvePlaceholder(placeholderName);\r\n    if (value != null && logger.isTraceEnabled()) {\r\n        logger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext#handleUnresolvablePlaceholder(String,String)",
    "entityType": "method",
    "code": "public String handleUnresolvablePlaceholder(String key, String text) {\r\n    if (this.ignoreUnresolvablePlaceholders) {\r\n        return toPlaceholderText(key);\r\n    }\r\n    String originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\r\n    throw new PlaceholderResolutionException(\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext#toPlaceholderText(String)",
    "entityType": "method",
    "code": "private String toPlaceholderText(String text) {\r\n    return this.prefix + text + this.suffix;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext#parse(String)",
    "entityType": "method",
    "code": "public List<Part> parse(String text) {\r\n    return this.parser.apply(text);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext#flagPlaceholderAsVisited(String)",
    "entityType": "method",
    "code": "public void flagPlaceholderAsVisited(String placeholder) {\r\n    if (this.visitedPlaceholders == null) {\r\n        this.visitedPlaceholders = new HashSet<>(4);\r\n    }\r\n    if (!this.visitedPlaceholders.add(placeholder)) {\r\n        throw new PlaceholderResolutionException(\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
    "entityType": "method",
    "code": "public void removePlaceholder(String placeholder) {\r\n    Assert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\r\n    this.visitedPlaceholders.remove(placeholder);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Part",
    "entityType": "class",
    "code": "/**\r\n * Resolve this part using the specified {@link PartResolutionContext}.\r\n * @param resolutionContext the context to use\r\n * @return the resolved part\r\n */\r\nString resolve(PartResolutionContext resolutionContext);\n/**\r\n * Provide a textual representation of this part.\r\n * @return the raw text that this part defines\r\n */\r\nString text();\n/**\r\n * Return a String that appends the resolution of the specified parts.\r\n * @param parts the parts to resolve\r\n * @param resolutionContext the context to use for the resolution\r\n * @return a concatenation of the supplied parts with placeholders replaced inline\r\n */\r\nstatic String resolveAll(Iterable<Part> parts, PartResolutionContext resolutionContext) {\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Part part : parts) {\r\n        sb.append(part.resolve(resolutionContext));\r\n    }\r\n    return sb.toString();\r\n}",
    "comment": "\n\t * A part is a section of a String containing placeholders to replace.\n\t "
  },
  {
    "entityId": "org.springframework.util.Part#resolve(PartResolutionContext)",
    "entityType": "method",
    "code": "/**\r\n * Resolve this part using the specified {@link PartResolutionContext}.\r\n * @param resolutionContext the context to use\r\n * @return the resolved part\r\n */\r\nString resolve(PartResolutionContext resolutionContext);",
    "comment": "\n\t\t * Resolve this part using the specified {@link PartResolutionContext}.\n\t\t * @param resolutionContext the context to use\n\t\t * @return the resolved part\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Part#text()",
    "entityType": "method",
    "code": "/**\r\n * Provide a textual representation of this part.\r\n * @return the raw text that this part defines\r\n */\r\nString text();",
    "comment": "\n\t\t * Provide a textual representation of this part.\n\t\t * @return the raw text that this part defines\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Part#resolveAll(Iterable<Part>,PartResolutionContext)",
    "entityType": "method",
    "code": "/**\r\n * Return a String that appends the resolution of the specified parts.\r\n * @param parts the parts to resolve\r\n * @param resolutionContext the context to use for the resolution\r\n * @return a concatenation of the supplied parts with placeholders replaced inline\r\n */\r\nstatic String resolveAll(Iterable<Part> parts, PartResolutionContext resolutionContext) {\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Part part : parts) {\r\n        sb.append(part.resolve(resolutionContext));\r\n    }\r\n    return sb.toString();\r\n}",
    "comment": "\n\t\t * Return a String that appends the resolution of the specified parts.\n\t\t * @param parts the parts to resolve\n\t\t * @param resolutionContext the context to use for the resolution\n\t\t * @return a concatenation of the supplied parts with placeholders replaced inline\n\t\t "
  },
  {
    "entityId": "org.springframework.util.AbstractPart",
    "entityType": "class",
    "code": "private final String text;\nprotected AbstractPart(String text) {\r\n    this.text = text;\r\n}\n@Override\r\npublic String text() {\r\n    return this.text;\r\n}\n/**\r\n * Resolve the placeholder with the given {@code key}. If the result of such\r\n * resolution return other placeholders, those are resolved as well until the\r\n * resolution no longer contains any placeholders.\r\n * @param resolutionContext the resolution context to use\r\n * @param key the initial placeholder\r\n * @return the full resolution of the given {@code key} or {@code null} if\r\n * the placeholder has no value to begin with\r\n */\r\n@Nullable\r\nprotected String resolveRecursively(PartResolutionContext resolutionContext, String key) {\r\n    String resolvedValue = resolutionContext.resolvePlaceholder(key);\r\n    if (resolvedValue != null) {\r\n        resolutionContext.flagPlaceholderAsVisited(key);\r\n        // Let's check if we need to recursively resolve that value\r\n        List<Part> nestedParts = resolutionContext.parse(resolvedValue);\r\n        String value = toText(nestedParts);\r\n        if (!isTextOnly(nestedParts)) {\r\n            value = new ParsedValue(resolvedValue, nestedParts).resolve(resolutionContext);\r\n        }\r\n        resolutionContext.removePlaceholder(key);\r\n        return value;\r\n    }\r\n    // Not found\r\n    return null;\r\n}\nprivate boolean isTextOnly(List<Part> parts) {\r\n    return parts.stream().allMatch(TextPart.class::isInstance);\r\n}\nprivate String toText(List<Part> parts) {\r\n    StringBuilder sb = new StringBuilder();\r\n    parts.forEach(part -> sb.append(part.text()));\r\n    return sb.toString();\r\n}",
    "comment": "\n\t * A base {@link Part} implementation.\n\t "
  },
  {
    "entityId": "org.springframework.util.AbstractPart#text()",
    "entityType": "method",
    "code": "@Override\r\npublic String text() {\r\n    return this.text;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the placeholder with the given {@code key}. If the result of such\r\n * resolution return other placeholders, those are resolved as well until the\r\n * resolution no longer contains any placeholders.\r\n * @param resolutionContext the resolution context to use\r\n * @param key the initial placeholder\r\n * @return the full resolution of the given {@code key} or {@code null} if\r\n * the placeholder has no value to begin with\r\n */\r\n@Nullable\r\nprotected String resolveRecursively(PartResolutionContext resolutionContext, String key) {\r\n    String resolvedValue = resolutionContext.resolvePlaceholder(key);\r\n    if (resolvedValue != null) {\r\n        resolutionContext.flagPlaceholderAsVisited(key);\r\n        // Let's check if we need to recursively resolve that value\r\n        List<Part> nestedParts = resolutionContext.parse(resolvedValue);\r\n        String value = toText(nestedParts);\r\n        if (!isTextOnly(nestedParts)) {\r\n            value = new ParsedValue(resolvedValue, nestedParts).resolve(resolutionContext);\r\n        }\r\n        resolutionContext.removePlaceholder(key);\r\n        return value;\r\n    }\r\n    // Not found\r\n    return null;\r\n}",
    "comment": "\n\t\t * Resolve the placeholder with the given {@code key}. If the result of such\n\t\t * resolution return other placeholders, those are resolved as well until the\n\t\t * resolution no longer contains any placeholders.\n\t\t * @param resolutionContext the resolution context to use\n\t\t * @param key the initial placeholder\n\t\t * @return the full resolution of the given {@code key} or {@code null} if\n\t\t * the placeholder has no value to begin with\n\t\t "
  },
  {
    "entityId": "org.springframework.util.AbstractPart#isTextOnly(List<Part>)",
    "entityType": "method",
    "code": "private boolean isTextOnly(List<Part> parts) {\r\n    return parts.stream().allMatch(TextPart.class::isInstance);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AbstractPart#toText(List<Part>)",
    "entityType": "method",
    "code": "private String toText(List<Part> parts) {\r\n    StringBuilder sb = new StringBuilder();\r\n    parts.forEach(part -> sb.append(part.text()));\r\n    return sb.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TextPart",
    "entityType": "class",
    "code": "/**\r\n * Create a new instance.\r\n * @param text the raw (and resolved) text\r\n */\r\npublic TextPart(String text) {\r\n    super(text);\r\n}\n@Override\r\npublic String resolve(PartResolutionContext resolutionContext) {\r\n    return text();\r\n}",
    "comment": "\n\t * A {@link Part} implementation that does not contain a valid placeholder.\n\t "
  },
  {
    "entityId": "org.springframework.util.TextPart#resolve(PartResolutionContext)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolve(PartResolutionContext resolutionContext) {\r\n    return text();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimplePlaceholderPart",
    "entityType": "class",
    "code": "private final String key;\n@Nullable\r\nprivate final String fallback;\n/**\r\n * Create a new instance.\r\n * @param text the raw text\r\n * @param key the key of the placeholder\r\n * @param fallback the fallback to use, if any\r\n */\r\npublic SimplePlaceholderPart(String text, String key, @Nullable String fallback) {\r\n    super(text);\r\n    this.key = key;\r\n    this.fallback = fallback;\r\n}\n@Override\r\npublic String resolve(PartResolutionContext resolutionContext) {\r\n    String value = resolveRecursively(resolutionContext);\r\n    if (value != null) {\r\n        return value;\r\n    } else if (this.fallback != null) {\r\n        return this.fallback;\r\n    }\r\n    return resolutionContext.handleUnresolvablePlaceholder(this.key, text());\r\n}\n@Nullable\r\nprivate String resolveRecursively(PartResolutionContext resolutionContext) {\r\n    if (!this.text().equals(this.key)) {\r\n        String value = resolveRecursively(resolutionContext, this.text());\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    return resolveRecursively(resolutionContext, this.key);\r\n}",
    "comment": "\n\t * A {@link Part} implementation that represents a single placeholder with\n\t * a hard-coded fallback.\n\t "
  },
  {
    "entityId": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolve(PartResolutionContext resolutionContext) {\r\n    String value = resolveRecursively(resolutionContext);\r\n    if (value != null) {\r\n        return value;\r\n    } else if (this.fallback != null) {\r\n        return this.fallback;\r\n    }\r\n    return resolutionContext.handleUnresolvablePlaceholder(this.key, text());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.SimplePlaceholderPart#resolveRecursively(PartResolutionContext)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate String resolveRecursively(PartResolutionContext resolutionContext) {\r\n    if (!this.text().equals(this.key)) {\r\n        String value = resolveRecursively(resolutionContext, this.text());\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    return resolveRecursively(resolutionContext, this.key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NestedPlaceholderPart",
    "entityType": "class",
    "code": "private final List<Part> keyParts;\n@Nullable\r\nprivate final List<Part> defaultParts;\n/**\r\n * Create a new instance.\r\n * @param text the raw text of the root placeholder\r\n * @param keyParts the parts of the key\r\n * @param defaultParts the parts of the fallback, if any\r\n */\r\nNestedPlaceholderPart(String text, List<Part> keyParts, @Nullable List<Part> defaultParts) {\r\n    super(text);\r\n    this.keyParts = keyParts;\r\n    this.defaultParts = defaultParts;\r\n}\n@Override\r\npublic String resolve(PartResolutionContext resolutionContext) {\r\n    String resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\r\n    String value = resolveRecursively(resolutionContext, resolvedKey);\r\n    if (value != null) {\r\n        return value;\r\n    } else if (this.defaultParts != null) {\r\n        return Part.resolveAll(this.defaultParts, resolutionContext);\r\n    }\r\n    return resolutionContext.handleUnresolvablePlaceholder(resolvedKey, text());\r\n}",
    "comment": "\n\t * A {@link Part} implementation that represents a single placeholder\n\t * containing nested placeholders.\n\t "
  },
  {
    "entityId": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
    "entityType": "method",
    "code": "@Override\r\npublic String resolve(PartResolutionContext resolutionContext) {\r\n    String resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\r\n    String value = resolveRecursively(resolutionContext, resolvedKey);\r\n    if (value != null) {\r\n        return value;\r\n    } else if (this.defaultParts != null) {\r\n        return Part.resolveAll(this.defaultParts, resolutionContext);\r\n    }\r\n    return resolutionContext.handleUnresolvablePlaceholder(resolvedKey, text());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolutionException",
    "entityType": "class",
    "code": "private final String reason;\nprivate final String placeholder;\nprivate final List<String> values;\n/**\r\n * Create an exception using the specified reason for its message.\r\n * @param reason the reason for the exception, should contain the placeholder\r\n * @param placeholder the placeholder\r\n * @param value the original expression that led to the issue if available\r\n */\r\nPlaceholderResolutionException(String reason, String placeholder, @Nullable String value) {\r\n    this(reason, placeholder, (value != null ? List.of(value) : Collections.emptyList()));\r\n}\nprivate PlaceholderResolutionException(String reason, String placeholder, List<String> values) {\r\n    super(buildMessage(reason, values));\r\n    this.reason = reason;\r\n    this.placeholder = placeholder;\r\n    this.values = values;\r\n}\nprivate static String buildMessage(String reason, List<String> values) {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(reason);\r\n    if (!CollectionUtils.isEmpty(values)) {\r\n        String valuesChain = values.stream().map(value -> \"\\\"\" + value + \"\\\"\").collect(Collectors.joining(\" <-- \"));\r\n        sb.append(\" in value %s\".formatted(valuesChain));\r\n    }\r\n    return sb.toString();\r\n}\n/**\r\n * Return a {@link PlaceholderResolutionException} that provides\r\n * an additional parent value.\r\n * @param value the parent value to add\r\n * @return a new exception with the parent value added\r\n */\r\nPlaceholderResolutionException withValue(String value) {\r\n    List<String> allValues = new ArrayList<>(this.values);\r\n    allValues.add(value);\r\n    return new PlaceholderResolutionException(this.reason, this.placeholder, allValues);\r\n}\n/**\r\n * Return the placeholder that could not be resolved.\r\n * @return the unresolvable placeholder\r\n */\r\npublic String getPlaceholder() {\r\n    return this.placeholder;\r\n}\n/**\r\n * Return a contextualized list of the resolution attempts that led to this\r\n * exception, where the first element is the value that generated this\r\n * exception.\r\n * @return the stack of values that led to this exception\r\n */\r\npublic List<String> getValues() {\r\n    return this.values;\r\n}",
    "comment": "\n * Thrown when the resolution of placeholder failed. This exception provides\n * the placeholder as well as the hierarchy of values that led to the issue.\n *\n * @author Stephane Nicoll\n * @since 6.2\n "
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolutionException#buildMessage(String,List<String>)",
    "entityType": "method",
    "code": "private static String buildMessage(String reason, List<String> values) {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(reason);\r\n    if (!CollectionUtils.isEmpty(values)) {\r\n        String valuesChain = values.stream().map(value -> \"\\\"\" + value + \"\\\"\").collect(Collectors.joining(\" <-- \"));\r\n        sb.append(\" in value %s\".formatted(valuesChain));\r\n    }\r\n    return sb.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolutionException#withValue(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link PlaceholderResolutionException} that provides\r\n * an additional parent value.\r\n * @param value the parent value to add\r\n * @return a new exception with the parent value added\r\n */\r\nPlaceholderResolutionException withValue(String value) {\r\n    List<String> allValues = new ArrayList<>(this.values);\r\n    allValues.add(value);\r\n    return new PlaceholderResolutionException(this.reason, this.placeholder, allValues);\r\n}",
    "comment": "\n\t * Return a {@link PlaceholderResolutionException} that provides\n\t * an additional parent value.\n\t * @param value the parent value to add\n\t * @return a new exception with the parent value added\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolutionException#getPlaceholder()",
    "entityType": "method",
    "code": "/**\r\n * Return the placeholder that could not be resolved.\r\n * @return the unresolvable placeholder\r\n */\r\npublic String getPlaceholder() {\r\n    return this.placeholder;\r\n}",
    "comment": "\n\t * Return the placeholder that could not be resolved.\n\t * @return the unresolvable placeholder\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolutionException#getValues()",
    "entityType": "method",
    "code": "/**\r\n * Return a contextualized list of the resolution attempts that led to this\r\n * exception, where the first element is the value that generated this\r\n * exception.\r\n * @return the stack of values that led to this exception\r\n */\r\npublic List<String> getValues() {\r\n    return this.values;\r\n}",
    "comment": "\n\t * Return a contextualized list of the resolution attempts that led to this\n\t * exception, where the first element is the value that generated this\n\t * exception.\n\t * @return the stack of values that led to this exception\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister",
    "entityType": "class",
    "code": "/**\r\n * Load properties from the given InputStream into the given\r\n * Properties object.\r\n * @param props the Properties object to load into\r\n * @param is the InputStream to load from\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#load\r\n */\r\nvoid load(Properties props, InputStream is) throws IOException;\n/**\r\n * Load properties from the given Reader into the given\r\n * Properties object.\r\n * @param props the Properties object to load into\r\n * @param reader the Reader to load from\r\n * @throws IOException in case of I/O errors\r\n */\r\nvoid load(Properties props, Reader reader) throws IOException;\n/**\r\n * Write the contents of the given Properties object to the\r\n * given OutputStream.\r\n * @param props the Properties object to store\r\n * @param os the OutputStream to write to\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#store\r\n */\r\nvoid store(Properties props, OutputStream os, String header) throws IOException;\n/**\r\n * Write the contents of the given Properties object to the\r\n * given Writer.\r\n * @param props the Properties object to store\r\n * @param writer the Writer to write to\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n */\r\nvoid store(Properties props, Writer writer, String header) throws IOException;\n/**\r\n * Load properties from the given XML InputStream into the\r\n * given Properties object.\r\n * @param props the Properties object to load into\r\n * @param is the InputStream to load from\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#loadFromXML(java.io.InputStream)\r\n */\r\nvoid loadFromXml(Properties props, InputStream is) throws IOException;\n/**\r\n * Write the contents of the given Properties object to the\r\n * given XML OutputStream.\r\n * @param props the Properties object to store\r\n * @param os the OutputStream to write to\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#storeToXML(java.io.OutputStream, String)\r\n */\r\nvoid storeToXml(Properties props, OutputStream os, String header) throws IOException;\n/**\r\n * Write the contents of the given Properties object to the\r\n * given XML OutputStream.\r\n * @param props the Properties object to store\r\n * @param os the OutputStream to write to\r\n * @param encoding the encoding to use\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#storeToXML(java.io.OutputStream, String, String)\r\n */\r\nvoid storeToXml(Properties props, OutputStream os, String header, String encoding) throws IOException;",
    "comment": "\n * Strategy interface for persisting {@code java.util.Properties},\n * allowing for pluggable parsing strategies.\n *\n * <p>The default implementation is DefaultPropertiesPersister,\n * providing the native parsing of {@code java.util.Properties},\n * but allowing for reading from any Reader and writing to any Writer\n * (which allows to specify an encoding for a properties file).\n *\n * @author Juergen Hoeller\n * @since 10.03.2004\n * @see DefaultPropertiesPersister\n * @see java.util.Properties\n "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Load properties from the given InputStream into the given\r\n * Properties object.\r\n * @param props the Properties object to load into\r\n * @param is the InputStream to load from\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#load\r\n */\r\nvoid load(Properties props, InputStream is) throws IOException;",
    "comment": "\n\t * Load properties from the given InputStream into the given\n\t * Properties object.\n\t * @param props the Properties object to load into\n\t * @param is the InputStream to load from\n\t * @throws IOException in case of I/O errors\n\t * @see java.util.Properties#load\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
    "entityType": "method",
    "code": "/**\r\n * Load properties from the given Reader into the given\r\n * Properties object.\r\n * @param props the Properties object to load into\r\n * @param reader the Reader to load from\r\n * @throws IOException in case of I/O errors\r\n */\r\nvoid load(Properties props, Reader reader) throws IOException;",
    "comment": "\n\t * Load properties from the given Reader into the given\n\t * Properties object.\n\t * @param props the Properties object to load into\n\t * @param reader the Reader to load from\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
    "entityType": "method",
    "code": "/**\r\n * Write the contents of the given Properties object to the\r\n * given OutputStream.\r\n * @param props the Properties object to store\r\n * @param os the OutputStream to write to\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#store\r\n */\r\nvoid store(Properties props, OutputStream os, String header) throws IOException;",
    "comment": "\n\t * Write the contents of the given Properties object to the\n\t * given OutputStream.\n\t * @param props the Properties object to store\n\t * @param os the OutputStream to write to\n\t * @param header the description of the property list\n\t * @throws IOException in case of I/O errors\n\t * @see java.util.Properties#store\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
    "entityType": "method",
    "code": "/**\r\n * Write the contents of the given Properties object to the\r\n * given Writer.\r\n * @param props the Properties object to store\r\n * @param writer the Writer to write to\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n */\r\nvoid store(Properties props, Writer writer, String header) throws IOException;",
    "comment": "\n\t * Write the contents of the given Properties object to the\n\t * given Writer.\n\t * @param props the Properties object to store\n\t * @param writer the Writer to write to\n\t * @param header the description of the property list\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#loadFromXml(Properties,InputStream)",
    "entityType": "method",
    "code": "/**\r\n * Load properties from the given XML InputStream into the\r\n * given Properties object.\r\n * @param props the Properties object to load into\r\n * @param is the InputStream to load from\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#loadFromXML(java.io.InputStream)\r\n */\r\nvoid loadFromXml(Properties props, InputStream is) throws IOException;",
    "comment": "\n\t * Load properties from the given XML InputStream into the\n\t * given Properties object.\n\t * @param props the Properties object to load into\n\t * @param is the InputStream to load from\n\t * @throws IOException in case of I/O errors\n\t * @see java.util.Properties#loadFromXML(java.io.InputStream)\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
    "entityType": "method",
    "code": "/**\r\n * Write the contents of the given Properties object to the\r\n * given XML OutputStream.\r\n * @param props the Properties object to store\r\n * @param os the OutputStream to write to\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#storeToXML(java.io.OutputStream, String)\r\n */\r\nvoid storeToXml(Properties props, OutputStream os, String header) throws IOException;",
    "comment": "\n\t * Write the contents of the given Properties object to the\n\t * given XML OutputStream.\n\t * @param props the Properties object to store\n\t * @param os the OutputStream to write to\n\t * @param header the description of the property list\n\t * @throws IOException in case of I/O errors\n\t * @see java.util.Properties#storeToXML(java.io.OutputStream, String)\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Write the contents of the given Properties object to the\r\n * given XML OutputStream.\r\n * @param props the Properties object to store\r\n * @param os the OutputStream to write to\r\n * @param encoding the encoding to use\r\n * @param header the description of the property list\r\n * @throws IOException in case of I/O errors\r\n * @see java.util.Properties#storeToXML(java.io.OutputStream, String, String)\r\n */\r\nvoid storeToXml(Properties props, OutputStream os, String header, String encoding) throws IOException;",
    "comment": "\n\t * Write the contents of the given Properties object to the\n\t * given XML OutputStream.\n\t * @param props the Properties object to store\n\t * @param os the OutputStream to write to\n\t * @param encoding the encoding to use\n\t * @param header the description of the property list\n\t * @throws IOException in case of I/O errors\n\t * @see java.util.Properties#storeToXML(java.io.OutputStream, String, String)\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertyPlaceholderHelper",
    "entityType": "class",
    "code": "private final PlaceholderParser parser;\n/**\r\n * Create a new {@code PropertyPlaceholderHelper} that uses the supplied prefix and suffix.\r\n * Unresolvable placeholders are ignored.\r\n * @param placeholderPrefix the prefix that denotes the start of a placeholder\r\n * @param placeholderSuffix the suffix that denotes the end of a placeholder\r\n */\r\npublic PropertyPlaceholderHelper(String placeholderPrefix, String placeholderSuffix) {\r\n    this(placeholderPrefix, placeholderSuffix, null, null, true);\r\n}\n/**\r\n * Create a new {@code PropertyPlaceholderHelper} that uses the supplied prefix and suffix.\r\n * @param placeholderPrefix the prefix that denotes the start of a placeholder\r\n * @param placeholderSuffix the suffix that denotes the end of a placeholder\r\n * @param valueSeparator the separating character between the placeholder variable\r\n * and the associated default value, if any\r\n * @param escapeCharacter the escape character to use to ignore placeholder prefix\r\n * or value separator, if any\r\n * @param ignoreUnresolvablePlaceholders indicates whether unresolvable placeholders should\r\n * be ignored ({@code true}) or cause an exception ({@code false})\r\n * @since 6.2\r\n */\r\npublic PropertyPlaceholderHelper(String placeholderPrefix, String placeholderSuffix, @Nullable String valueSeparator, @Nullable Character escapeCharacter, boolean ignoreUnresolvablePlaceholders) {\r\n    Assert.notNull(placeholderPrefix, \"'placeholderPrefix' must not be null\");\r\n    Assert.notNull(placeholderSuffix, \"'placeholderSuffix' must not be null\");\r\n    this.parser = new PlaceholderParser(placeholderPrefix, placeholderSuffix, valueSeparator, escapeCharacter, ignoreUnresolvablePlaceholders);\r\n}\n/**\r\n * Replace all placeholders of format {@code ${name}} with the corresponding\r\n * property from the supplied {@link Properties}.\r\n * @param value the value containing the placeholders to be replaced\r\n * @param properties the {@code Properties} to use for replacement\r\n * @return the supplied value with placeholders replaced inline\r\n */\r\npublic String replacePlaceholders(String value, final Properties properties) {\r\n    Assert.notNull(properties, \"'properties' must not be null\");\r\n    return replacePlaceholders(value, properties::getProperty);\r\n}\n/**\r\n * Replace all placeholders of format {@code ${name}} with the value returned\r\n * from the supplied {@link PlaceholderResolver}.\r\n * @param value the value containing the placeholders to be replaced\r\n * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\r\n * @return the supplied value with placeholders replaced inline\r\n */\r\npublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\r\n    Assert.notNull(value, \"'value' must not be null\");\r\n    return parseStringValue(value, placeholderResolver);\r\n}\nprotected String parseStringValue(String value, PlaceholderResolver placeholderResolver) {\r\n    return this.parser.replacePlaceholders(value, placeholderResolver);\r\n}\n/**\r\n * Strategy interface used to resolve replacement values for placeholders contained in Strings.\r\n */\r\n@FunctionalInterface\r\npublic interface PlaceholderResolver {\r\n\r\n    /**\r\n     * Resolve the supplied placeholder name to the replacement value.\r\n     * @param placeholderName the name of the placeholder to resolve\r\n     * @return the replacement value, or {@code null} if no replacement is to be made\r\n     */\r\n    @Nullable\r\n    String resolvePlaceholder(String placeholderName);\r\n}",
    "comment": "\n * Utility class for working with Strings that have placeholder values in them.\n *\n * <p>A placeholder takes the form {@code ${name}}. Using {@code PropertyPlaceholderHelper}\n * these placeholders can be substituted for user-supplied values.\n *\n * <p>Values for substitution can be supplied using a {@link Properties} instance or\n * using a {@link PlaceholderResolver}.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Stephane Nicoll\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
    "entityType": "method",
    "code": "/**\r\n * Replace all placeholders of format {@code ${name}} with the corresponding\r\n * property from the supplied {@link Properties}.\r\n * @param value the value containing the placeholders to be replaced\r\n * @param properties the {@code Properties} to use for replacement\r\n * @return the supplied value with placeholders replaced inline\r\n */\r\npublic String replacePlaceholders(String value, final Properties properties) {\r\n    Assert.notNull(properties, \"'properties' must not be null\");\r\n    return replacePlaceholders(value, properties::getProperty);\r\n}",
    "comment": "\n\t * Replace all placeholders of format {@code ${name}} with the corresponding\n\t * property from the supplied {@link Properties}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param properties the {@code Properties} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
    "entityType": "method",
    "code": "/**\r\n * Replace all placeholders of format {@code ${name}} with the value returned\r\n * from the supplied {@link PlaceholderResolver}.\r\n * @param value the value containing the placeholders to be replaced\r\n * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\r\n * @return the supplied value with placeholders replaced inline\r\n */\r\npublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\r\n    Assert.notNull(value, \"'value' must not be null\");\r\n    return parseStringValue(value, placeholderResolver);\r\n}",
    "comment": "\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t "
  },
  {
    "entityId": "org.springframework.util.PropertyPlaceholderHelper#parseStringValue(String,PlaceholderResolver)",
    "entityType": "method",
    "code": "protected String parseStringValue(String value, PlaceholderResolver placeholderResolver) {\r\n    return this.parser.replacePlaceholders(value, placeholderResolver);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolver",
    "entityType": "class",
    "code": "/**\r\n * Resolve the supplied placeholder name to the replacement value.\r\n * @param placeholderName the name of the placeholder to resolve\r\n * @return the replacement value, or {@code null} if no replacement is to be made\r\n */\r\n@Nullable\r\nString resolvePlaceholder(String placeholderName);",
    "comment": "\n\t * Strategy interface used to resolve replacement values for placeholders contained in Strings.\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderResolver#resolvePlaceholder(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the supplied placeholder name to the replacement value.\r\n * @param placeholderName the name of the placeholder to resolve\r\n * @return the replacement value, or {@code null} if no replacement is to be made\r\n */\r\n@Nullable\r\nString resolvePlaceholder(String placeholderName);",
    "comment": "\n\t\t * Resolve the supplied placeholder name to the replacement value.\n\t\t * @param placeholderName the name of the placeholder to resolve\n\t\t * @return the replacement value, or {@code null} if no replacement is to be made\n\t\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils",
    "entityType": "class",
    "code": "/**\r\n * Pre-built {@link MethodFilter} that matches all non-bridge non-synthetic methods\r\n * which are not declared on {@code java.lang.Object}.\r\n * @since 3.0.5\r\n */\r\npublic static final MethodFilter USER_DECLARED_METHODS = (method -> !method.isBridge() && !method.isSynthetic() && (method.getDeclaringClass() != Object.class));\n/**\r\n * Pre-built FieldFilter that matches all non-static, non-final fields.\r\n */\r\npublic static final FieldFilter COPYABLE_FIELDS = (field -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers())));\n/**\r\n * Naming prefix for CGLIB-renamed methods.\r\n * @see #isCglibRenamedMethod\r\n */\r\nprivate static final String CGLIB_RENAMED_METHOD_PREFIX = \"CGLIB$\";\nprivate static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\nprivate static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\nprivate static final Field[] EMPTY_FIELD_ARRAY = new Field[0];\nprivate static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\r\n * Cache for {@link Class#getDeclaredMethods()} plus equivalent default methods\r\n * from Java 8 based interfaces, allowing for fast iteration.\r\n */\r\nprivate static final Map<Class<?>, Method[]> declaredMethodsCache = new ConcurrentReferenceHashMap<>(256);\n/**\r\n * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.\r\n */\r\nprivate static final Map<Class<?>, Field[]> declaredFieldsCache = new ConcurrentReferenceHashMap<>(256);\n// Exception handling\r\n/**\r\n * Handle the given reflection exception.\r\n * <p>Should only be called if no checked exception is expected to be thrown\r\n * by a target method, or if an error occurs while accessing a method or field.\r\n * <p>Throws the underlying RuntimeException or Error in case of an\r\n * InvocationTargetException with such a root cause. Throws an\r\n * IllegalStateException with an appropriate message or\r\n * UndeclaredThrowableException otherwise.\r\n * @param ex the reflection exception to handle\r\n */\r\npublic static void handleReflectionException(Exception ex) {\r\n    if (ex instanceof NoSuchMethodException) {\r\n        throw new IllegalStateException(\"Method not found: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof IllegalAccessException) {\r\n        throw new IllegalStateException(\"Could not access method or field: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof InvocationTargetException invocationTargetException) {\r\n        handleInvocationTargetException(invocationTargetException);\r\n    }\r\n    if (ex instanceof RuntimeException runtimeException) {\r\n        throw runtimeException;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}\n/**\r\n * Handle the given invocation target exception. Should only be called if no\r\n * checked exception is expected to be thrown by the target method.\r\n * <p>Throws the underlying RuntimeException or Error in case of such a root\r\n * cause. Throws an UndeclaredThrowableException otherwise.\r\n * @param ex the invocation target exception to handle\r\n */\r\npublic static void handleInvocationTargetException(InvocationTargetException ex) {\r\n    rethrowRuntimeException(ex.getTargetException());\r\n}\n/**\r\n * Rethrow the given {@link Throwable exception}, which is presumably the\r\n * <em>target exception</em> of an {@link InvocationTargetException}.\r\n * Should only be called if no checked exception is expected to be thrown\r\n * by the target method.\r\n * <p>Rethrows the underlying exception cast to a {@link RuntimeException} or\r\n * {@link Error} if appropriate; otherwise, throws an\r\n * {@link UndeclaredThrowableException}.\r\n * @param ex the exception to rethrow\r\n * @throws RuntimeException the rethrown exception\r\n */\r\npublic static void rethrowRuntimeException(@Nullable Throwable ex) {\r\n    if (ex instanceof RuntimeException runtimeException) {\r\n        throw runtimeException;\r\n    }\r\n    if (ex instanceof Error error) {\r\n        throw error;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}\n/**\r\n * Rethrow the given {@link Throwable exception}, which is presumably the\r\n * <em>target exception</em> of an {@link InvocationTargetException}.\r\n * Should only be called if no checked exception is expected to be thrown\r\n * by the target method.\r\n * <p>Rethrows the underlying exception cast to an {@link Exception} or\r\n * {@link Error} if appropriate; otherwise, throws an\r\n * {@link UndeclaredThrowableException}.\r\n * @param throwable the exception to rethrow\r\n * @throws Exception the rethrown exception (in case of a checked exception)\r\n */\r\npublic static void rethrowException(@Nullable Throwable throwable) throws Exception {\r\n    if (throwable instanceof Exception exception) {\r\n        throw exception;\r\n    }\r\n    if (throwable instanceof Error error) {\r\n        throw error;\r\n    }\r\n    throw new UndeclaredThrowableException(throwable);\r\n}\n// Constructor handling\r\n/**\r\n * Obtain an accessible constructor for the given class and parameters.\r\n * @param clazz the clazz to check\r\n * @param parameterTypes the parameter types of the desired constructor\r\n * @return the constructor reference\r\n * @throws NoSuchMethodException if no such constructor exists\r\n * @since 5.0\r\n */\r\npublic static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes) throws NoSuchMethodException {\r\n    Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);\r\n    makeAccessible(ctor);\r\n    return ctor;\r\n}\n/**\r\n * Make the given constructor accessible, explicitly setting it accessible\r\n * if necessary. The {@code setAccessible(true)} method is only called\r\n * when actually necessary, to avoid unnecessary conflicts.\r\n * @param ctor the constructor to make accessible\r\n * @see java.lang.reflect.Constructor#setAccessible\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void makeAccessible(Constructor<?> ctor) {\r\n    if ((!Modifier.isPublic(ctor.getModifiers()) || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {\r\n        ctor.setAccessible(true);\r\n    }\r\n}\n// Method handling\r\n/**\r\n * Attempt to find a {@link Method} on the supplied class with the supplied name\r\n * and no parameters. Searches all superclasses up to {@code Object}.\r\n * <p>Returns {@code null} if no {@link Method} can be found.\r\n * @param clazz the class to introspect\r\n * @param name the name of the method\r\n * @return the Method object, or {@code null} if none found\r\n */\r\n@Nullable\r\npublic static Method findMethod(Class<?> clazz, String name) {\r\n    return findMethod(clazz, name, EMPTY_CLASS_ARRAY);\r\n}\n/**\r\n * Attempt to find a {@link Method} on the supplied class with the supplied name\r\n * and parameter types. Searches all superclasses up to {@code Object}.\r\n * <p>Returns {@code null} if no {@link Method} can be found.\r\n * @param clazz the class to introspect\r\n * @param name the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * (may be {@code null} to indicate any signature)\r\n * @return the Method object, or {@code null} if none found\r\n */\r\n@Nullable\r\npublic static Method findMethod(Class<?> clazz, String name, Class<?>@Nullable ... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(name, \"Method name must not be null\");\r\n    Class<?> searchType = clazz;\r\n    while (searchType != null) {\r\n        Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType, false));\r\n        for (Method method : methods) {\r\n            if (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\r\n                return method;\r\n            }\r\n        }\r\n        searchType = searchType.getSuperclass();\r\n    }\r\n    return null;\r\n}\nprivate static boolean hasSameParams(Method method, Class<?>[] paramTypes) {\r\n    return (paramTypes.length == method.getParameterCount() && Arrays.equals(paramTypes, method.getParameterTypes()));\r\n}\n/**\r\n * Invoke the specified {@link Method} against the supplied target object with no arguments.\r\n * The target object can be {@code null} when invoking a static {@link Method}.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\r\n * @param method the method to invoke\r\n * @param target the target object to invoke the method on\r\n * @return the invocation result, if any\r\n * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\r\n */\r\n@Nullable\r\npublic static Object invokeMethod(Method method, @Nullable Object target) {\r\n    return invokeMethod(method, target, EMPTY_OBJECT_ARRAY);\r\n}\n/**\r\n * Invoke the specified {@link Method} against the supplied target object with the\r\n * supplied arguments. The target object can be {@code null} when invoking a\r\n * static {@link Method}.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\r\n * @param method the method to invoke\r\n * @param target the target object to invoke the method on\r\n * @param args the invocation arguments (may be {@code null})\r\n * @return the invocation result, if any\r\n */\r\n@Nullable\r\npublic static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\r\n    try {\r\n        return method.invoke(target, args);\r\n    } catch (Exception ex) {\r\n        handleReflectionException(ex);\r\n    }\r\n    throw new IllegalStateException(\"Should never get here\");\r\n}\n/**\r\n * Determine whether the given method explicitly declares the given\r\n * exception or one of its superclasses, which means that an exception\r\n * of that type can be propagated as-is within a reflective invocation.\r\n * @param method the declaring method\r\n * @param exceptionType the exception to throw\r\n * @return {@code true} if the exception can be thrown as-is;\r\n * {@code false} if it needs to be wrapped\r\n */\r\npublic static boolean declaresException(Method method, Class<?> exceptionType) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    Class<?>[] declaredExceptions = method.getExceptionTypes();\r\n    for (Class<?> declaredException : declaredExceptions) {\r\n        if (declaredException.isAssignableFrom(exceptionType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Perform the given callback operation on all matching methods of the given\r\n * class, as locally declared or equivalent thereof (such as default methods\r\n * on Java 8 based interfaces that the given class implements).\r\n * @param clazz the class to introspect\r\n * @param mc the callback to invoke for each method\r\n * @throws IllegalStateException if introspection fails\r\n * @since 4.2\r\n * @see #doWithMethods\r\n */\r\npublic static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\r\n    Method[] methods = getDeclaredMethods(clazz, false);\r\n    for (Method method : methods) {\r\n        try {\r\n            mc.doWith(method);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n}\n/**\r\n * Perform the given callback operation on all matching methods of the given\r\n * class and superclasses.\r\n * <p>The same named method occurring on subclass and superclass will appear\r\n * twice, unless excluded by a {@link MethodFilter}.\r\n * @param clazz the class to introspect\r\n * @param mc the callback to invoke for each method\r\n * @throws IllegalStateException if introspection fails\r\n * @see #doWithMethods(Class, MethodCallback, MethodFilter)\r\n */\r\npublic static void doWithMethods(Class<?> clazz, MethodCallback mc) {\r\n    doWithMethods(clazz, mc, null);\r\n}\n/**\r\n * Perform the given callback operation on all matching methods of the given\r\n * class and superclasses (or given interface and super-interfaces).\r\n * <p>The same named method occurring on subclass and superclass will appear\r\n * twice, unless excluded by the specified {@link MethodFilter}.\r\n * @param clazz the class to introspect\r\n * @param mc the callback to invoke for each method\r\n * @param mf the filter that determines the methods to apply the callback to\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\r\n    if (mf == USER_DECLARED_METHODS && clazz == Object.class) {\r\n        // nothing to introspect\r\n        return;\r\n    }\r\n    Method[] methods = getDeclaredMethods(clazz, false);\r\n    for (Method method : methods) {\r\n        if (mf != null && !mf.matches(method)) {\r\n            continue;\r\n        }\r\n        try {\r\n            mc.doWith(method);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n    // Keep backing up the inheritance hierarchy.\r\n    if (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\r\n        doWithMethods(clazz.getSuperclass(), mc, mf);\r\n    } else if (clazz.isInterface()) {\r\n        for (Class<?> superIfc : clazz.getInterfaces()) {\r\n            doWithMethods(superIfc, mc, mf);\r\n        }\r\n    }\r\n}\n/**\r\n * Get all declared methods on the leaf class and all superclasses.\r\n * Leaf class methods are included first.\r\n * @param leafClass the class to introspect\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static Method[] getAllDeclaredMethods(Class<?> leafClass) {\r\n    final List<Method> methods = new ArrayList<>(20);\r\n    doWithMethods(leafClass, methods::add);\r\n    return methods.toArray(EMPTY_METHOD_ARRAY);\r\n}\n/**\r\n * Get the unique set of declared methods on the leaf class and all superclasses.\r\n * Leaf class methods are included first and while traversing the superclass hierarchy\r\n * any methods found with signatures matching a method already included are filtered out.\r\n * @param leafClass the class to introspect\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {\r\n    return getUniqueDeclaredMethods(leafClass, null);\r\n}\n/**\r\n * Get the unique set of declared methods on the leaf class and all superclasses.\r\n * Leaf class methods are included first and while traversing the superclass hierarchy\r\n * any methods found with signatures matching a method already included are filtered out.\r\n * @param leafClass the class to introspect\r\n * @param mf the filter that determines the methods to take into account\r\n * @throws IllegalStateException if introspection fails\r\n * @since 5.2\r\n */\r\npublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {\r\n    final List<Method> methods = new ArrayList<>(20);\r\n    doWithMethods(leafClass, method -> {\r\n        boolean knownSignature = false;\r\n        Method methodBeingOverriddenWithCovariantReturnType = null;\r\n        for (Method existingMethod : methods) {\r\n            if (method.getName().equals(existingMethod.getName()) && method.getParameterCount() == existingMethod.getParameterCount() && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\r\n                // Is this a covariant return type situation?\r\n                if (existingMethod.getReturnType() != method.getReturnType() && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n                    methodBeingOverriddenWithCovariantReturnType = existingMethod;\r\n                } else {\r\n                    knownSignature = true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (methodBeingOverriddenWithCovariantReturnType != null) {\r\n            methods.remove(methodBeingOverriddenWithCovariantReturnType);\r\n        }\r\n        if (!knownSignature && !isCglibRenamedMethod(method)) {\r\n            methods.add(method);\r\n        }\r\n    }, mf);\r\n    return methods.toArray(EMPTY_METHOD_ARRAY);\r\n}\n/**\r\n * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in\r\n * order to avoid new Method instances. In addition, it also includes Java 8\r\n * default methods from locally implemented interfaces, since those are\r\n * effectively to be treated just like declared methods.\r\n * @param clazz the class to introspect\r\n * @return the cached array of methods\r\n * @throws IllegalStateException if introspection fails\r\n * @since 5.2\r\n * @see Class#getDeclaredMethods()\r\n */\r\npublic static Method[] getDeclaredMethods(Class<?> clazz) {\r\n    return getDeclaredMethods(clazz, true);\r\n}\nprivate static Method[] getDeclaredMethods(Class<?> clazz, boolean defensive) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Method[] result = declaredMethodsCache.get(clazz);\r\n    if (result == null) {\r\n        try {\r\n            Method[] declaredMethods = clazz.getDeclaredMethods();\r\n            List<Method> defaultMethods = findDefaultMethodsOnInterfaces(clazz);\r\n            if (defaultMethods != null) {\r\n                result = new Method[declaredMethods.length + defaultMethods.size()];\r\n                System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);\r\n                int index = declaredMethods.length;\r\n                for (Method defaultMethod : defaultMethods) {\r\n                    result[index] = defaultMethod;\r\n                    index++;\r\n                }\r\n            } else {\r\n                result = declaredMethods;\r\n            }\r\n            declaredMethodsCache.put(clazz, (result.length == 0 ? EMPTY_METHOD_ARRAY : result));\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() + \"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\r\n        }\r\n    }\r\n    return (result.length == 0 || !defensive) ? result : result.clone();\r\n}\n@Nullable\r\nprivate static List<Method> findDefaultMethodsOnInterfaces(Class<?> clazz) {\r\n    List<Method> result = null;\r\n    for (Class<?> ifc : clazz.getInterfaces()) {\r\n        for (Method method : ifc.getMethods()) {\r\n            if (method.isDefault()) {\r\n                if (result == null) {\r\n                    result = new ArrayList<>();\r\n                }\r\n                result.add(method);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\n/**\r\n * Determine whether the given method is an \"equals\" method.\r\n * @see java.lang.Object#equals(Object)\r\n */\r\npublic static boolean isEqualsMethod(@Nullable Method method) {\r\n    return (method != null && method.getParameterCount() == 1 && method.getName().equals(\"equals\") && method.getParameterTypes()[0] == Object.class);\r\n}\n/**\r\n * Determine whether the given method is a \"hashCode\" method.\r\n * @see java.lang.Object#hashCode()\r\n */\r\npublic static boolean isHashCodeMethod(@Nullable Method method) {\r\n    return (method != null && method.getParameterCount() == 0 && method.getName().equals(\"hashCode\"));\r\n}\n/**\r\n * Determine whether the given method is a \"toString\" method.\r\n * @see java.lang.Object#toString()\r\n */\r\npublic static boolean isToStringMethod(@Nullable Method method) {\r\n    return (method != null && method.getParameterCount() == 0 && method.getName().equals(\"toString\"));\r\n}\n/**\r\n * Determine whether the given method is originally declared by {@link java.lang.Object}.\r\n */\r\npublic static boolean isObjectMethod(@Nullable Method method) {\r\n    return (method != null && (method.getDeclaringClass() == Object.class || isEqualsMethod(method) || isHashCodeMethod(method) || isToStringMethod(method)));\r\n}\n/**\r\n * Determine whether the given method is a CGLIB 'renamed' method,\r\n * following the pattern \"CGLIB$methodName$0\".\r\n * @param renamedMethod the method to check\r\n */\r\npublic static boolean isCglibRenamedMethod(Method renamedMethod) {\r\n    String name = renamedMethod.getName();\r\n    if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\r\n        int i = name.length() - 1;\r\n        while (i >= 0 && Character.isDigit(name.charAt(i))) {\r\n            i--;\r\n        }\r\n        return (i > CGLIB_RENAMED_METHOD_PREFIX.length() && (i < name.length() - 1) && name.charAt(i) == '$');\r\n    }\r\n    return false;\r\n}\n/**\r\n * Make the given method accessible, explicitly setting it accessible if\r\n * necessary. The {@code setAccessible(true)} method is only called\r\n * when actually necessary, to avoid unnecessary conflicts.\r\n * @param method the method to make accessible\r\n * @see java.lang.reflect.Method#setAccessible\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void makeAccessible(Method method) {\r\n    if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {\r\n        method.setAccessible(true);\r\n    }\r\n}\n// Field handling\r\n/**\r\n * Attempt to find a {@link Field field} on the supplied {@link Class} with the\r\n * supplied {@code name}. Searches all superclasses up to {@link Object}.\r\n * @param clazz the class to introspect\r\n * @param name the name of the field\r\n * @return the corresponding Field object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static Field findField(Class<?> clazz, String name) {\r\n    return findField(clazz, name, null);\r\n}\n/**\r\n * Attempt to find a {@link Field field} on the supplied {@link Class} with the\r\n * supplied {@code name} and/or {@link Class type}. Searches all superclasses\r\n * up to {@link Object}.\r\n * @param clazz the class to introspect\r\n * @param name the name of the field (may be {@code null} if type is specified)\r\n * @param type the type of the field (may be {@code null} if name is specified)\r\n * @return the corresponding Field object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.isTrue(name != null || type != null, \"Either name or type of the field must be specified\");\r\n    Class<?> searchType = clazz;\r\n    while (Object.class != searchType && searchType != null) {\r\n        Field[] fields = getDeclaredFields(searchType);\r\n        for (Field field : fields) {\r\n            if ((name == null || name.equals(field.getName())) && (type == null || type.equals(field.getType()))) {\r\n                return field;\r\n            }\r\n        }\r\n        searchType = searchType.getSuperclass();\r\n    }\r\n    return null;\r\n}\n/**\r\n * Attempt to find a {@link Field field} on the supplied {@link Class} with the\r\n * supplied {@code name}. Searches all superclasses up to {@link Object}.\r\n * @param clazz the class to introspect\r\n * @param name the name of the field (with upper/lower case to be ignored)\r\n * @return the corresponding Field object, or {@code null} if not found\r\n * @since 6.1\r\n */\r\n@Nullable\r\npublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Class<?> searchType = clazz;\r\n    while (Object.class != searchType && searchType != null) {\r\n        Field[] fields = getDeclaredFields(searchType);\r\n        for (Field field : fields) {\r\n            if (name.equalsIgnoreCase(field.getName())) {\r\n                return field;\r\n            }\r\n        }\r\n        searchType = searchType.getSuperclass();\r\n    }\r\n    return null;\r\n}\n/**\r\n * Set the field represented by the supplied {@linkplain Field field object} on\r\n * the specified {@linkplain Object target object} to the specified {@code value}.\r\n * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\r\n * is automatically unwrapped if the underlying field has a primitive type.\r\n * <p>This method does not support setting {@code static final} fields.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\r\n * @param field the field to set\r\n * @param target the target object on which to set the field\r\n * (or {@code null} for a static field)\r\n * @param value the value to set (may be {@code null})\r\n */\r\npublic static void setField(Field field, @Nullable Object target, @Nullable Object value) {\r\n    try {\r\n        field.set(target, value);\r\n    } catch (IllegalAccessException ex) {\r\n        handleReflectionException(ex);\r\n    }\r\n}\n/**\r\n * Get the field represented by the supplied {@link Field field object} on the\r\n * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\r\n * semantics, the returned value is automatically wrapped if the underlying field\r\n * has a primitive type.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\r\n * @param field the field to get\r\n * @param target the target object from which to get the field\r\n * (or {@code null} for a static field)\r\n * @return the field's current value\r\n */\r\n@Nullable\r\npublic static Object getField(Field field, @Nullable Object target) {\r\n    try {\r\n        return field.get(target);\r\n    } catch (IllegalAccessException ex) {\r\n        handleReflectionException(ex);\r\n    }\r\n    throw new IllegalStateException(\"Should never get here\");\r\n}\n/**\r\n * Invoke the given callback on all locally declared fields in the given class.\r\n * @param clazz the target class to analyze\r\n * @param fc the callback to invoke for each field\r\n * @throws IllegalStateException if introspection fails\r\n * @since 4.2\r\n * @see #doWithFields\r\n */\r\npublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\r\n    for (Field field : getDeclaredFields(clazz)) {\r\n        try {\r\n            fc.doWith(field);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n}\n/**\r\n * Invoke the given callback on all fields in the target class, going up the\r\n * class hierarchy to get all declared fields.\r\n * @param clazz the target class to analyze\r\n * @param fc the callback to invoke for each field\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\r\n    doWithFields(clazz, fc, null);\r\n}\n/**\r\n * Invoke the given callback on all fields in the target class, going up the\r\n * class hierarchy to get all declared fields.\r\n * @param clazz the target class to analyze\r\n * @param fc the callback to invoke for each field\r\n * @param ff the filter that determines the fields to apply the callback to\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\r\n    // Keep backing up the inheritance hierarchy.\r\n    Class<?> targetClass = clazz;\r\n    do {\r\n        for (Field field : getDeclaredFields(targetClass)) {\r\n            if (ff != null && !ff.matches(field)) {\r\n                continue;\r\n            }\r\n            try {\r\n                fc.doWith(field);\r\n            } catch (IllegalAccessException ex) {\r\n                throw new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\r\n            }\r\n        }\r\n        targetClass = targetClass.getSuperclass();\r\n    } while (targetClass != null && targetClass != Object.class);\r\n}\n/**\r\n * This variant retrieves {@link Class#getDeclaredFields()} from a local cache\r\n * in order to avoid defensive array copying.\r\n * @param clazz the class to introspect\r\n * @return the cached array of fields\r\n * @throws IllegalStateException if introspection fails\r\n * @see Class#getDeclaredFields()\r\n */\r\nprivate static Field[] getDeclaredFields(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Field[] result = declaredFieldsCache.get(clazz);\r\n    if (result == null) {\r\n        try {\r\n            result = clazz.getDeclaredFields();\r\n            declaredFieldsCache.put(clazz, (result.length == 0 ? EMPTY_FIELD_ARRAY : result));\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() + \"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\r\n        }\r\n    }\r\n    return result;\r\n}\n/**\r\n * Given the source object and the destination, which must be the same class\r\n * or a subclass, copy all fields, including inherited fields. Designed to\r\n * work on objects with public no-arg constructors.\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void shallowCopyFieldState(final Object src, final Object dest) {\r\n    Assert.notNull(src, \"Source for field copy cannot be null\");\r\n    Assert.notNull(dest, \"Destination for field copy cannot be null\");\r\n    if (!src.getClass().isAssignableFrom(dest.getClass())) {\r\n        throw new IllegalArgumentException(\"Destination class [\" + dest.getClass().getName() + \"] must be same or subclass as source class [\" + src.getClass().getName() + \"]\");\r\n    }\r\n    doWithFields(src.getClass(), field -> {\r\n        makeAccessible(field);\r\n        Object srcValue = field.get(src);\r\n        field.set(dest, srcValue);\r\n    }, COPYABLE_FIELDS);\r\n}\n/**\r\n * Determine whether the given field is a \"public static final\" constant.\r\n * @param field the field to check\r\n */\r\npublic static boolean isPublicStaticFinal(Field field) {\r\n    int modifiers = field.getModifiers();\r\n    return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));\r\n}\n/**\r\n * Make the given field accessible, explicitly setting it accessible if\r\n * necessary. The {@code setAccessible(true)} method is only called\r\n * when actually necessary, to avoid unnecessary conflicts.\r\n * @param field the field to make accessible\r\n * @see java.lang.reflect.Field#setAccessible\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void makeAccessible(Field field) {\r\n    if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {\r\n        field.setAccessible(true);\r\n    }\r\n}\n// Cache handling\r\n/**\r\n * Clear the internal method/field cache.\r\n * @since 4.2.4\r\n */\r\npublic static void clearCache() {\r\n    declaredMethodsCache.clear();\r\n    declaredFieldsCache.clear();\r\n}\n/**\r\n * Action to take on each method.\r\n */\r\n@FunctionalInterface\r\npublic interface MethodCallback {\r\n\r\n    /**\r\n     * Perform an operation using the given method.\r\n     * @param method the method to operate on\r\n     */\r\n    void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;\r\n}\n/**\r\n * Callback optionally used to filter methods to be operated on by a method callback.\r\n */\r\n@FunctionalInterface\r\npublic interface MethodFilter {\r\n\r\n    /**\r\n     * Determine whether the given method matches.\r\n     * @param method the method to check\r\n     */\r\n    boolean matches(Method method);\r\n\r\n    /**\r\n     * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n     * <p>If this filter does not match, the next filter will not be applied.\r\n     * @param next the next {@code MethodFilter}\r\n     * @return a composite {@code MethodFilter}\r\n     * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\r\n     * @since 5.3.2\r\n     */\r\n    default MethodFilter and(MethodFilter next) {\r\n        Assert.notNull(next, \"Next MethodFilter must not be null\");\r\n        return method -> matches(method) && next.matches(method);\r\n    }\r\n}\n/**\r\n * Callback interface invoked on each field in the hierarchy.\r\n */\r\n@FunctionalInterface\r\npublic interface FieldCallback {\r\n\r\n    /**\r\n     * Perform an operation using the given field.\r\n     * @param field the field to operate on\r\n     */\r\n    void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;\r\n}\n/**\r\n * Callback optionally used to filter fields to be operated on by a field callback.\r\n */\r\n@FunctionalInterface\r\npublic interface FieldFilter {\r\n\r\n    /**\r\n     * Determine whether the given field matches.\r\n     * @param field the field to check\r\n     */\r\n    boolean matches(Field field);\r\n\r\n    /**\r\n     * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n     * <p>If this filter does not match, the next filter will not be applied.\r\n     * @param next the next {@code FieldFilter}\r\n     * @return a composite {@code FieldFilter}\r\n     * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\r\n     * @since 5.3.2\r\n     */\r\n    default FieldFilter and(FieldFilter next) {\r\n        Assert.notNull(next, \"Next FieldFilter must not be null\");\r\n        return field -> matches(field) && next.matches(field);\r\n    }\r\n}",
    "comment": "\n * Simple utility class for working with the reflection API and handling\n * reflection exceptions.\n *\n * <p>Only intended for internal use.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rod Johnson\n * @author Costin Leau\n * @author Sam Brannen\n * @author Chris Beams\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
    "entityType": "method",
    "code": "// Exception handling\r\n/**\r\n * Handle the given reflection exception.\r\n * <p>Should only be called if no checked exception is expected to be thrown\r\n * by a target method, or if an error occurs while accessing a method or field.\r\n * <p>Throws the underlying RuntimeException or Error in case of an\r\n * InvocationTargetException with such a root cause. Throws an\r\n * IllegalStateException with an appropriate message or\r\n * UndeclaredThrowableException otherwise.\r\n * @param ex the reflection exception to handle\r\n */\r\npublic static void handleReflectionException(Exception ex) {\r\n    if (ex instanceof NoSuchMethodException) {\r\n        throw new IllegalStateException(\"Method not found: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof IllegalAccessException) {\r\n        throw new IllegalStateException(\"Could not access method or field: \" + ex.getMessage());\r\n    }\r\n    if (ex instanceof InvocationTargetException invocationTargetException) {\r\n        handleInvocationTargetException(invocationTargetException);\r\n    }\r\n    if (ex instanceof RuntimeException runtimeException) {\r\n        throw runtimeException;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}",
    "comment": "\n\t * Handle the given reflection exception.\n\t * <p>Should only be called if no checked exception is expected to be thrown\n\t * by a target method, or if an error occurs while accessing a method or field.\n\t * <p>Throws the underlying RuntimeException or Error in case of an\n\t * InvocationTargetException with such a root cause. Throws an\n\t * IllegalStateException with an appropriate message or\n\t * UndeclaredThrowableException otherwise.\n\t * @param ex the reflection exception to handle\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
    "entityType": "method",
    "code": "/**\r\n * Handle the given invocation target exception. Should only be called if no\r\n * checked exception is expected to be thrown by the target method.\r\n * <p>Throws the underlying RuntimeException or Error in case of such a root\r\n * cause. Throws an UndeclaredThrowableException otherwise.\r\n * @param ex the invocation target exception to handle\r\n */\r\npublic static void handleInvocationTargetException(InvocationTargetException ex) {\r\n    rethrowRuntimeException(ex.getTargetException());\r\n}",
    "comment": "\n\t * Handle the given invocation target exception. Should only be called if no\n\t * checked exception is expected to be thrown by the target method.\n\t * <p>Throws the underlying RuntimeException or Error in case of such a root\n\t * cause. Throws an UndeclaredThrowableException otherwise.\n\t * @param ex the invocation target exception to handle\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Rethrow the given {@link Throwable exception}, which is presumably the\r\n * <em>target exception</em> of an {@link InvocationTargetException}.\r\n * Should only be called if no checked exception is expected to be thrown\r\n * by the target method.\r\n * <p>Rethrows the underlying exception cast to a {@link RuntimeException} or\r\n * {@link Error} if appropriate; otherwise, throws an\r\n * {@link UndeclaredThrowableException}.\r\n * @param ex the exception to rethrow\r\n * @throws RuntimeException the rethrown exception\r\n */\r\npublic static void rethrowRuntimeException(@Nullable Throwable ex) {\r\n    if (ex instanceof RuntimeException runtimeException) {\r\n        throw runtimeException;\r\n    }\r\n    if (ex instanceof Error error) {\r\n        throw error;\r\n    }\r\n    throw new UndeclaredThrowableException(ex);\r\n}",
    "comment": "\n\t * Rethrow the given {@link Throwable exception}, which is presumably the\n\t * <em>target exception</em> of an {@link InvocationTargetException}.\n\t * Should only be called if no checked exception is expected to be thrown\n\t * by the target method.\n\t * <p>Rethrows the underlying exception cast to a {@link RuntimeException} or\n\t * {@link Error} if appropriate; otherwise, throws an\n\t * {@link UndeclaredThrowableException}.\n\t * @param ex the exception to rethrow\n\t * @throws RuntimeException the rethrown exception\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Rethrow the given {@link Throwable exception}, which is presumably the\r\n * <em>target exception</em> of an {@link InvocationTargetException}.\r\n * Should only be called if no checked exception is expected to be thrown\r\n * by the target method.\r\n * <p>Rethrows the underlying exception cast to an {@link Exception} or\r\n * {@link Error} if appropriate; otherwise, throws an\r\n * {@link UndeclaredThrowableException}.\r\n * @param throwable the exception to rethrow\r\n * @throws Exception the rethrown exception (in case of a checked exception)\r\n */\r\npublic static void rethrowException(@Nullable Throwable throwable) throws Exception {\r\n    if (throwable instanceof Exception exception) {\r\n        throw exception;\r\n    }\r\n    if (throwable instanceof Error error) {\r\n        throw error;\r\n    }\r\n    throw new UndeclaredThrowableException(throwable);\r\n}",
    "comment": "\n\t * Rethrow the given {@link Throwable exception}, which is presumably the\n\t * <em>target exception</em> of an {@link InvocationTargetException}.\n\t * Should only be called if no checked exception is expected to be thrown\n\t * by the target method.\n\t * <p>Rethrows the underlying exception cast to an {@link Exception} or\n\t * {@link Error} if appropriate; otherwise, throws an\n\t * {@link UndeclaredThrowableException}.\n\t * @param throwable the exception to rethrow\n\t * @throws Exception the rethrown exception (in case of a checked exception)\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#accessibleConstructor(Class<T>,Class<?>)",
    "entityType": "method",
    "code": "// Constructor handling\r\n/**\r\n * Obtain an accessible constructor for the given class and parameters.\r\n * @param clazz the clazz to check\r\n * @param parameterTypes the parameter types of the desired constructor\r\n * @return the constructor reference\r\n * @throws NoSuchMethodException if no such constructor exists\r\n * @since 5.0\r\n */\r\npublic static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes) throws NoSuchMethodException {\r\n    Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);\r\n    makeAccessible(ctor);\r\n    return ctor;\r\n}",
    "comment": "\n\t * Obtain an accessible constructor for the given class and parameters.\n\t * @param clazz the clazz to check\n\t * @param parameterTypes the parameter types of the desired constructor\n\t * @return the constructor reference\n\t * @throws NoSuchMethodException if no such constructor exists\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
    "entityType": "method",
    "code": "/**\r\n * Make the given constructor accessible, explicitly setting it accessible\r\n * if necessary. The {@code setAccessible(true)} method is only called\r\n * when actually necessary, to avoid unnecessary conflicts.\r\n * @param ctor the constructor to make accessible\r\n * @see java.lang.reflect.Constructor#setAccessible\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void makeAccessible(Constructor<?> ctor) {\r\n    if ((!Modifier.isPublic(ctor.getModifiers()) || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {\r\n        ctor.setAccessible(true);\r\n    }\r\n}",
    "comment": "\n\t * Make the given constructor accessible, explicitly setting it accessible\n\t * if necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param ctor the constructor to make accessible\n\t * @see java.lang.reflect.Constructor#setAccessible\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String)",
    "entityType": "method",
    "code": "// Method handling\r\n/**\r\n * Attempt to find a {@link Method} on the supplied class with the supplied name\r\n * and no parameters. Searches all superclasses up to {@code Object}.\r\n * <p>Returns {@code null} if no {@link Method} can be found.\r\n * @param clazz the class to introspect\r\n * @param name the name of the method\r\n * @return the Method object, or {@code null} if none found\r\n */\r\n@Nullable\r\npublic static Method findMethod(Class<?> clazz, String name) {\r\n    return findMethod(clazz, name, EMPTY_CLASS_ARRAY);\r\n}",
    "comment": "\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and no parameters. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @return the Method object, or {@code null} if none found\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Attempt to find a {@link Method} on the supplied class with the supplied name\r\n * and parameter types. Searches all superclasses up to {@code Object}.\r\n * <p>Returns {@code null} if no {@link Method} can be found.\r\n * @param clazz the class to introspect\r\n * @param name the name of the method\r\n * @param paramTypes the parameter types of the method\r\n * (may be {@code null} to indicate any signature)\r\n * @return the Method object, or {@code null} if none found\r\n */\r\n@Nullable\r\npublic static Method findMethod(Class<?> clazz, String name, Class<?>@Nullable ... paramTypes) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(name, \"Method name must not be null\");\r\n    Class<?> searchType = clazz;\r\n    while (searchType != null) {\r\n        Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType, false));\r\n        for (Method method : methods) {\r\n            if (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\r\n                return method;\r\n            }\r\n        }\r\n        searchType = searchType.getSuperclass();\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Attempt to find a {@link Method} on the supplied class with the supplied name\n\t * and parameter types. Searches all superclasses up to {@code Object}.\n\t * <p>Returns {@code null} if no {@link Method} can be found.\n\t * @param clazz the class to introspect\n\t * @param name the name of the method\n\t * @param paramTypes the parameter types of the method\n\t * (may be {@code null} to indicate any signature)\n\t * @return the Method object, or {@code null} if none found\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#hasSameParams(Method,Class<?>[])",
    "entityType": "method",
    "code": "private static boolean hasSameParams(Method method, Class<?>[] paramTypes) {\r\n    return (paramTypes.length == method.getParameterCount() && Arrays.equals(paramTypes, method.getParameterTypes()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
    "entityType": "method",
    "code": "/**\r\n * Invoke the specified {@link Method} against the supplied target object with no arguments.\r\n * The target object can be {@code null} when invoking a static {@link Method}.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\r\n * @param method the method to invoke\r\n * @param target the target object to invoke the method on\r\n * @return the invocation result, if any\r\n * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\r\n */\r\n@Nullable\r\npublic static Object invokeMethod(Method method, @Nullable Object target) {\r\n    return invokeMethod(method, target, EMPTY_OBJECT_ARRAY);\r\n}",
    "comment": "\n\t * Invoke the specified {@link Method} against the supplied target object with no arguments.\n\t * The target object can be {@code null} when invoking a static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @return the invocation result, if any\n\t * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Invoke the specified {@link Method} against the supplied target object with the\r\n * supplied arguments. The target object can be {@code null} when invoking a\r\n * static {@link Method}.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\r\n * @param method the method to invoke\r\n * @param target the target object to invoke the method on\r\n * @param args the invocation arguments (may be {@code null})\r\n * @return the invocation result, if any\r\n */\r\n@Nullable\r\npublic static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {\r\n    try {\r\n        return method.invoke(target, args);\r\n    } catch (Exception ex) {\r\n        handleReflectionException(ex);\r\n    }\r\n    throw new IllegalStateException(\"Should never get here\");\r\n}",
    "comment": "\n\t * Invoke the specified {@link Method} against the supplied target object with the\n\t * supplied arguments. The target object can be {@code null} when invoking a\n\t * static {@link Method}.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}.\n\t * @param method the method to invoke\n\t * @param target the target object to invoke the method on\n\t * @param args the invocation arguments (may be {@code null})\n\t * @return the invocation result, if any\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method explicitly declares the given\r\n * exception or one of its superclasses, which means that an exception\r\n * of that type can be propagated as-is within a reflective invocation.\r\n * @param method the declaring method\r\n * @param exceptionType the exception to throw\r\n * @return {@code true} if the exception can be thrown as-is;\r\n * {@code false} if it needs to be wrapped\r\n */\r\npublic static boolean declaresException(Method method, Class<?> exceptionType) {\r\n    Assert.notNull(method, \"Method must not be null\");\r\n    Class<?>[] declaredExceptions = method.getExceptionTypes();\r\n    for (Class<?> declaredException : declaredExceptions) {\r\n        if (declaredException.isAssignableFrom(exceptionType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the given method explicitly declares the given\n\t * exception or one of its superclasses, which means that an exception\n\t * of that type can be propagated as-is within a reflective invocation.\n\t * @param method the declaring method\n\t * @param exceptionType the exception to throw\n\t * @return {@code true} if the exception can be thrown as-is;\n\t * {@code false} if it needs to be wrapped\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
    "entityType": "method",
    "code": "/**\r\n * Perform the given callback operation on all matching methods of the given\r\n * class, as locally declared or equivalent thereof (such as default methods\r\n * on Java 8 based interfaces that the given class implements).\r\n * @param clazz the class to introspect\r\n * @param mc the callback to invoke for each method\r\n * @throws IllegalStateException if introspection fails\r\n * @since 4.2\r\n * @see #doWithMethods\r\n */\r\npublic static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\r\n    Method[] methods = getDeclaredMethods(clazz, false);\r\n    for (Method method : methods) {\r\n        try {\r\n            mc.doWith(method);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Perform the given callback operation on all matching methods of the given\n\t * class, as locally declared or equivalent thereof (such as default methods\n\t * on Java 8 based interfaces that the given class implements).\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithMethods\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
    "entityType": "method",
    "code": "/**\r\n * Perform the given callback operation on all matching methods of the given\r\n * class and superclasses.\r\n * <p>The same named method occurring on subclass and superclass will appear\r\n * twice, unless excluded by a {@link MethodFilter}.\r\n * @param clazz the class to introspect\r\n * @param mc the callback to invoke for each method\r\n * @throws IllegalStateException if introspection fails\r\n * @see #doWithMethods(Class, MethodCallback, MethodFilter)\r\n */\r\npublic static void doWithMethods(Class<?> clazz, MethodCallback mc) {\r\n    doWithMethods(clazz, mc, null);\r\n}",
    "comment": "\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses.\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by a {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @throws IllegalStateException if introspection fails\n\t * @see #doWithMethods(Class, MethodCallback, MethodFilter)\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
    "entityType": "method",
    "code": "/**\r\n * Perform the given callback operation on all matching methods of the given\r\n * class and superclasses (or given interface and super-interfaces).\r\n * <p>The same named method occurring on subclass and superclass will appear\r\n * twice, unless excluded by the specified {@link MethodFilter}.\r\n * @param clazz the class to introspect\r\n * @param mc the callback to invoke for each method\r\n * @param mf the filter that determines the methods to apply the callback to\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\r\n    if (mf == USER_DECLARED_METHODS && clazz == Object.class) {\r\n        // nothing to introspect\r\n        return;\r\n    }\r\n    Method[] methods = getDeclaredMethods(clazz, false);\r\n    for (Method method : methods) {\r\n        if (mf != null && !mf.matches(method)) {\r\n            continue;\r\n        }\r\n        try {\r\n            mc.doWith(method);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n    // Keep backing up the inheritance hierarchy.\r\n    if (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\r\n        doWithMethods(clazz.getSuperclass(), mc, mf);\r\n    } else if (clazz.isInterface()) {\r\n        for (Class<?> superIfc : clazz.getInterfaces()) {\r\n            doWithMethods(superIfc, mc, mf);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Perform the given callback operation on all matching methods of the given\n\t * class and superclasses (or given interface and super-interfaces).\n\t * <p>The same named method occurring on subclass and superclass will appear\n\t * twice, unless excluded by the specified {@link MethodFilter}.\n\t * @param clazz the class to introspect\n\t * @param mc the callback to invoke for each method\n\t * @param mf the filter that determines the methods to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Get all declared methods on the leaf class and all superclasses.\r\n * Leaf class methods are included first.\r\n * @param leafClass the class to introspect\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static Method[] getAllDeclaredMethods(Class<?> leafClass) {\r\n    final List<Method> methods = new ArrayList<>(20);\r\n    doWithMethods(leafClass, methods::add);\r\n    return methods.toArray(EMPTY_METHOD_ARRAY);\r\n}",
    "comment": "\n\t * Get all declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first.\n\t * @param leafClass the class to introspect\n\t * @throws IllegalStateException if introspection fails\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Get the unique set of declared methods on the leaf class and all superclasses.\r\n * Leaf class methods are included first and while traversing the superclass hierarchy\r\n * any methods found with signatures matching a method already included are filtered out.\r\n * @param leafClass the class to introspect\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {\r\n    return getUniqueDeclaredMethods(leafClass, null);\r\n}",
    "comment": "\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @throws IllegalStateException if introspection fails\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
    "entityType": "method",
    "code": "/**\r\n * Get the unique set of declared methods on the leaf class and all superclasses.\r\n * Leaf class methods are included first and while traversing the superclass hierarchy\r\n * any methods found with signatures matching a method already included are filtered out.\r\n * @param leafClass the class to introspect\r\n * @param mf the filter that determines the methods to take into account\r\n * @throws IllegalStateException if introspection fails\r\n * @since 5.2\r\n */\r\npublic static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {\r\n    final List<Method> methods = new ArrayList<>(20);\r\n    doWithMethods(leafClass, method -> {\r\n        boolean knownSignature = false;\r\n        Method methodBeingOverriddenWithCovariantReturnType = null;\r\n        for (Method existingMethod : methods) {\r\n            if (method.getName().equals(existingMethod.getName()) && method.getParameterCount() == existingMethod.getParameterCount() && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {\r\n                // Is this a covariant return type situation?\r\n                if (existingMethod.getReturnType() != method.getReturnType() && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n                    methodBeingOverriddenWithCovariantReturnType = existingMethod;\r\n                } else {\r\n                    knownSignature = true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (methodBeingOverriddenWithCovariantReturnType != null) {\r\n            methods.remove(methodBeingOverriddenWithCovariantReturnType);\r\n        }\r\n        if (!knownSignature && !isCglibRenamedMethod(method)) {\r\n            methods.add(method);\r\n        }\r\n    }, mf);\r\n    return methods.toArray(EMPTY_METHOD_ARRAY);\r\n}",
    "comment": "\n\t * Get the unique set of declared methods on the leaf class and all superclasses.\n\t * Leaf class methods are included first and while traversing the superclass hierarchy\n\t * any methods found with signatures matching a method already included are filtered out.\n\t * @param leafClass the class to introspect\n\t * @param mf the filter that determines the methods to take into account\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in\r\n * order to avoid new Method instances. In addition, it also includes Java 8\r\n * default methods from locally implemented interfaces, since those are\r\n * effectively to be treated just like declared methods.\r\n * @param clazz the class to introspect\r\n * @return the cached array of methods\r\n * @throws IllegalStateException if introspection fails\r\n * @since 5.2\r\n * @see Class#getDeclaredMethods()\r\n */\r\npublic static Method[] getDeclaredMethods(Class<?> clazz) {\r\n    return getDeclaredMethods(clazz, true);\r\n}",
    "comment": "\n\t * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in\n\t * order to avoid new Method instances. In addition, it also includes Java 8\n\t * default methods from locally implemented interfaces, since those are\n\t * effectively to be treated just like declared methods.\n\t * @param clazz the class to introspect\n\t * @return the cached array of methods\n\t * @throws IllegalStateException if introspection fails\n\t * @since 5.2\n\t * @see Class#getDeclaredMethods()\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean)",
    "entityType": "method",
    "code": "private static Method[] getDeclaredMethods(Class<?> clazz, boolean defensive) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Method[] result = declaredMethodsCache.get(clazz);\r\n    if (result == null) {\r\n        try {\r\n            Method[] declaredMethods = clazz.getDeclaredMethods();\r\n            List<Method> defaultMethods = findDefaultMethodsOnInterfaces(clazz);\r\n            if (defaultMethods != null) {\r\n                result = new Method[declaredMethods.length + defaultMethods.size()];\r\n                System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);\r\n                int index = declaredMethods.length;\r\n                for (Method defaultMethod : defaultMethods) {\r\n                    result[index] = defaultMethod;\r\n                    index++;\r\n                }\r\n            } else {\r\n                result = declaredMethods;\r\n            }\r\n            declaredMethodsCache.put(clazz, (result.length == 0 ? EMPTY_METHOD_ARRAY : result));\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() + \"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\r\n        }\r\n    }\r\n    return (result.length == 0 || !defensive) ? result : result.clone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#findDefaultMethodsOnInterfaces(Class<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static List<Method> findDefaultMethodsOnInterfaces(Class<?> clazz) {\r\n    List<Method> result = null;\r\n    for (Class<?> ifc : clazz.getInterfaces()) {\r\n        for (Method method : ifc.getMethods()) {\r\n            if (method.isDefault()) {\r\n                if (result == null) {\r\n                    result = new ArrayList<>();\r\n                }\r\n                result.add(method);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#isEqualsMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is an \"equals\" method.\r\n * @see java.lang.Object#equals(Object)\r\n */\r\npublic static boolean isEqualsMethod(@Nullable Method method) {\r\n    return (method != null && method.getParameterCount() == 1 && method.getName().equals(\"equals\") && method.getParameterTypes()[0] == Object.class);\r\n}",
    "comment": "\n\t * Determine whether the given method is an \"equals\" method.\n\t * @see java.lang.Object#equals(Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#isHashCodeMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is a \"hashCode\" method.\r\n * @see java.lang.Object#hashCode()\r\n */\r\npublic static boolean isHashCodeMethod(@Nullable Method method) {\r\n    return (method != null && method.getParameterCount() == 0 && method.getName().equals(\"hashCode\"));\r\n}",
    "comment": "\n\t * Determine whether the given method is a \"hashCode\" method.\n\t * @see java.lang.Object#hashCode()\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#isToStringMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is a \"toString\" method.\r\n * @see java.lang.Object#toString()\r\n */\r\npublic static boolean isToStringMethod(@Nullable Method method) {\r\n    return (method != null && method.getParameterCount() == 0 && method.getName().equals(\"toString\"));\r\n}",
    "comment": "\n\t * Determine whether the given method is a \"toString\" method.\n\t * @see java.lang.Object#toString()\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#isObjectMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is originally declared by {@link java.lang.Object}.\r\n */\r\npublic static boolean isObjectMethod(@Nullable Method method) {\r\n    return (method != null && (method.getDeclaringClass() == Object.class || isEqualsMethod(method) || isHashCodeMethod(method) || isToStringMethod(method)));\r\n}",
    "comment": "\n\t * Determine whether the given method is originally declared by {@link java.lang.Object}.\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method is a CGLIB 'renamed' method,\r\n * following the pattern \"CGLIB$methodName$0\".\r\n * @param renamedMethod the method to check\r\n */\r\npublic static boolean isCglibRenamedMethod(Method renamedMethod) {\r\n    String name = renamedMethod.getName();\r\n    if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {\r\n        int i = name.length() - 1;\r\n        while (i >= 0 && Character.isDigit(name.charAt(i))) {\r\n            i--;\r\n        }\r\n        return (i > CGLIB_RENAMED_METHOD_PREFIX.length() && (i < name.length() - 1) && name.charAt(i) == '$');\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the given method is a CGLIB 'renamed' method,\n\t * following the pattern \"CGLIB$methodName$0\".\n\t * @param renamedMethod the method to check\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
    "entityType": "method",
    "code": "/**\r\n * Make the given method accessible, explicitly setting it accessible if\r\n * necessary. The {@code setAccessible(true)} method is only called\r\n * when actually necessary, to avoid unnecessary conflicts.\r\n * @param method the method to make accessible\r\n * @see java.lang.reflect.Method#setAccessible\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void makeAccessible(Method method) {\r\n    if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {\r\n        method.setAccessible(true);\r\n    }\r\n}",
    "comment": "\n\t * Make the given method accessible, explicitly setting it accessible if\n\t * necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param method the method to make accessible\n\t * @see java.lang.reflect.Method#setAccessible\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#findField(Class<?>,String)",
    "entityType": "method",
    "code": "// Field handling\r\n/**\r\n * Attempt to find a {@link Field field} on the supplied {@link Class} with the\r\n * supplied {@code name}. Searches all superclasses up to {@link Object}.\r\n * @param clazz the class to introspect\r\n * @param name the name of the field\r\n * @return the corresponding Field object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static Field findField(Class<?> clazz, String name) {\r\n    return findField(clazz, name, null);\r\n}",
    "comment": "\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field\n\t * @return the corresponding Field object, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Attempt to find a {@link Field field} on the supplied {@link Class} with the\r\n * supplied {@code name} and/or {@link Class type}. Searches all superclasses\r\n * up to {@link Object}.\r\n * @param clazz the class to introspect\r\n * @param name the name of the field (may be {@code null} if type is specified)\r\n * @param type the type of the field (may be {@code null} if name is specified)\r\n * @return the corresponding Field object, or {@code null} if not found\r\n */\r\n@Nullable\r\npublic static Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.isTrue(name != null || type != null, \"Either name or type of the field must be specified\");\r\n    Class<?> searchType = clazz;\r\n    while (Object.class != searchType && searchType != null) {\r\n        Field[] fields = getDeclaredFields(searchType);\r\n        for (Field field : fields) {\r\n            if ((name == null || name.equals(field.getName())) && (type == null || type.equals(field.getType()))) {\r\n                return field;\r\n            }\r\n        }\r\n        searchType = searchType.getSuperclass();\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name} and/or {@link Class type}. Searches all superclasses\n\t * up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (may be {@code null} if type is specified)\n\t * @param type the type of the field (may be {@code null} if name is specified)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Attempt to find a {@link Field field} on the supplied {@link Class} with the\r\n * supplied {@code name}. Searches all superclasses up to {@link Object}.\r\n * @param clazz the class to introspect\r\n * @param name the name of the field (with upper/lower case to be ignored)\r\n * @return the corresponding Field object, or {@code null} if not found\r\n * @since 6.1\r\n */\r\n@Nullable\r\npublic static Field findFieldIgnoreCase(Class<?> clazz, String name) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Class<?> searchType = clazz;\r\n    while (Object.class != searchType && searchType != null) {\r\n        Field[] fields = getDeclaredFields(searchType);\r\n        for (Field field : fields) {\r\n            if (name.equalsIgnoreCase(field.getName())) {\r\n                return field;\r\n            }\r\n        }\r\n        searchType = searchType.getSuperclass();\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * Attempt to find a {@link Field field} on the supplied {@link Class} with the\n\t * supplied {@code name}. Searches all superclasses up to {@link Object}.\n\t * @param clazz the class to introspect\n\t * @param name the name of the field (with upper/lower case to be ignored)\n\t * @return the corresponding Field object, or {@code null} if not found\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#setField(Field,Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Set the field represented by the supplied {@linkplain Field field object} on\r\n * the specified {@linkplain Object target object} to the specified {@code value}.\r\n * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\r\n * is automatically unwrapped if the underlying field has a primitive type.\r\n * <p>This method does not support setting {@code static final} fields.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\r\n * @param field the field to set\r\n * @param target the target object on which to set the field\r\n * (or {@code null} for a static field)\r\n * @param value the value to set (may be {@code null})\r\n */\r\npublic static void setField(Field field, @Nullable Object target, @Nullable Object value) {\r\n    try {\r\n        field.set(target, value);\r\n    } catch (IllegalAccessException ex) {\r\n        handleReflectionException(ex);\r\n    }\r\n}",
    "comment": "\n\t * Set the field represented by the supplied {@linkplain Field field object} on\n\t * the specified {@linkplain Object target object} to the specified {@code value}.\n\t * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value\n\t * is automatically unwrapped if the underlying field has a primitive type.\n\t * <p>This method does not support setting {@code static final} fields.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to set\n\t * @param target the target object on which to set the field\n\t * (or {@code null} for a static field)\n\t * @param value the value to set (may be {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
    "entityType": "method",
    "code": "/**\r\n * Get the field represented by the supplied {@link Field field object} on the\r\n * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\r\n * semantics, the returned value is automatically wrapped if the underlying field\r\n * has a primitive type.\r\n * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\r\n * @param field the field to get\r\n * @param target the target object from which to get the field\r\n * (or {@code null} for a static field)\r\n * @return the field's current value\r\n */\r\n@Nullable\r\npublic static Object getField(Field field, @Nullable Object target) {\r\n    try {\r\n        return field.get(target);\r\n    } catch (IllegalAccessException ex) {\r\n        handleReflectionException(ex);\r\n    }\r\n    throw new IllegalStateException(\"Should never get here\");\r\n}",
    "comment": "\n\t * Get the field represented by the supplied {@link Field field object} on the\n\t * specified {@link Object target object}. In accordance with {@link Field#get(Object)}\n\t * semantics, the returned value is automatically wrapped if the underlying field\n\t * has a primitive type.\n\t * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}.\n\t * @param field the field to get\n\t * @param target the target object from which to get the field\n\t * (or {@code null} for a static field)\n\t * @return the field's current value\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
    "entityType": "method",
    "code": "/**\r\n * Invoke the given callback on all locally declared fields in the given class.\r\n * @param clazz the target class to analyze\r\n * @param fc the callback to invoke for each field\r\n * @throws IllegalStateException if introspection fails\r\n * @since 4.2\r\n * @see #doWithFields\r\n */\r\npublic static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {\r\n    for (Field field : getDeclaredFields(clazz)) {\r\n        try {\r\n            fc.doWith(field);\r\n        } catch (IllegalAccessException ex) {\r\n            throw new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Invoke the given callback on all locally declared fields in the given class.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t * @since 4.2\n\t * @see #doWithFields\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
    "entityType": "method",
    "code": "/**\r\n * Invoke the given callback on all fields in the target class, going up the\r\n * class hierarchy to get all declared fields.\r\n * @param clazz the target class to analyze\r\n * @param fc the callback to invoke for each field\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void doWithFields(Class<?> clazz, FieldCallback fc) {\r\n    doWithFields(clazz, fc, null);\r\n}",
    "comment": "\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @throws IllegalStateException if introspection fails\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
    "entityType": "method",
    "code": "/**\r\n * Invoke the given callback on all fields in the target class, going up the\r\n * class hierarchy to get all declared fields.\r\n * @param clazz the target class to analyze\r\n * @param fc the callback to invoke for each field\r\n * @param ff the filter that determines the fields to apply the callback to\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {\r\n    // Keep backing up the inheritance hierarchy.\r\n    Class<?> targetClass = clazz;\r\n    do {\r\n        for (Field field : getDeclaredFields(targetClass)) {\r\n            if (ff != null && !ff.matches(field)) {\r\n                continue;\r\n            }\r\n            try {\r\n                fc.doWith(field);\r\n            } catch (IllegalAccessException ex) {\r\n                throw new IllegalStateException(\"Not allowed to access field '\" + field.getName() + \"': \" + ex);\r\n            }\r\n        }\r\n        targetClass = targetClass.getSuperclass();\r\n    } while (targetClass != null && targetClass != Object.class);\r\n}",
    "comment": "\n\t * Invoke the given callback on all fields in the target class, going up the\n\t * class hierarchy to get all declared fields.\n\t * @param clazz the target class to analyze\n\t * @param fc the callback to invoke for each field\n\t * @param ff the filter that determines the fields to apply the callback to\n\t * @throws IllegalStateException if introspection fails\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * This variant retrieves {@link Class#getDeclaredFields()} from a local cache\r\n * in order to avoid defensive array copying.\r\n * @param clazz the class to introspect\r\n * @return the cached array of fields\r\n * @throws IllegalStateException if introspection fails\r\n * @see Class#getDeclaredFields()\r\n */\r\nprivate static Field[] getDeclaredFields(Class<?> clazz) {\r\n    Assert.notNull(clazz, \"Class must not be null\");\r\n    Field[] result = declaredFieldsCache.get(clazz);\r\n    if (result == null) {\r\n        try {\r\n            result = clazz.getDeclaredFields();\r\n            declaredFieldsCache.put(clazz, (result.length == 0 ? EMPTY_FIELD_ARRAY : result));\r\n        } catch (Throwable ex) {\r\n            throw new IllegalStateException(\"Failed to introspect Class [\" + clazz.getName() + \"] from ClassLoader [\" + clazz.getClassLoader() + \"]\", ex);\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * This variant retrieves {@link Class#getDeclaredFields()} from a local cache\n\t * in order to avoid defensive array copying.\n\t * @param clazz the class to introspect\n\t * @return the cached array of fields\n\t * @throws IllegalStateException if introspection fails\n\t * @see Class#getDeclaredFields()\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Given the source object and the destination, which must be the same class\r\n * or a subclass, copy all fields, including inherited fields. Designed to\r\n * work on objects with public no-arg constructors.\r\n * @throws IllegalStateException if introspection fails\r\n */\r\npublic static void shallowCopyFieldState(final Object src, final Object dest) {\r\n    Assert.notNull(src, \"Source for field copy cannot be null\");\r\n    Assert.notNull(dest, \"Destination for field copy cannot be null\");\r\n    if (!src.getClass().isAssignableFrom(dest.getClass())) {\r\n        throw new IllegalArgumentException(\"Destination class [\" + dest.getClass().getName() + \"] must be same or subclass as source class [\" + src.getClass().getName() + \"]\");\r\n    }\r\n    doWithFields(src.getClass(), field -> {\r\n        makeAccessible(field);\r\n        Object srcValue = field.get(src);\r\n        field.set(dest, srcValue);\r\n    }, COPYABLE_FIELDS);\r\n}",
    "comment": "\n\t * Given the source object and the destination, which must be the same class\n\t * or a subclass, copy all fields, including inherited fields. Designed to\n\t * work on objects with public no-arg constructors.\n\t * @throws IllegalStateException if introspection fails\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#isPublicStaticFinal(Field)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given field is a \"public static final\" constant.\r\n * @param field the field to check\r\n */\r\npublic static boolean isPublicStaticFinal(Field field) {\r\n    int modifiers = field.getModifiers();\r\n    return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));\r\n}",
    "comment": "\n\t * Determine whether the given field is a \"public static final\" constant.\n\t * @param field the field to check\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
    "entityType": "method",
    "code": "/**\r\n * Make the given field accessible, explicitly setting it accessible if\r\n * necessary. The {@code setAccessible(true)} method is only called\r\n * when actually necessary, to avoid unnecessary conflicts.\r\n * @param field the field to make accessible\r\n * @see java.lang.reflect.Field#setAccessible\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\npublic static void makeAccessible(Field field) {\r\n    if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {\r\n        field.setAccessible(true);\r\n    }\r\n}",
    "comment": "\n\t * Make the given field accessible, explicitly setting it accessible if\n\t * necessary. The {@code setAccessible(true)} method is only called\n\t * when actually necessary, to avoid unnecessary conflicts.\n\t * @param field the field to make accessible\n\t * @see java.lang.reflect.Field#setAccessible\n\t "
  },
  {
    "entityId": "org.springframework.util.ReflectionUtils#clearCache()",
    "entityType": "method",
    "code": "// Cache handling\r\n/**\r\n * Clear the internal method/field cache.\r\n * @since 4.2.4\r\n */\r\npublic static void clearCache() {\r\n    declaredMethodsCache.clear();\r\n    declaredFieldsCache.clear();\r\n}",
    "comment": "\n\t * Clear the internal method/field cache.\n\t * @since 4.2.4\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodCallback",
    "entityType": "class",
    "code": "/**\r\n * Perform an operation using the given method.\r\n * @param method the method to operate on\r\n */\r\nvoid doWith(Method method) throws IllegalArgumentException, IllegalAccessException;",
    "comment": "\n\t * Action to take on each method.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodCallback#doWith(Method)",
    "entityType": "method",
    "code": "/**\r\n * Perform an operation using the given method.\r\n * @param method the method to operate on\r\n */\r\nvoid doWith(Method method) throws IllegalArgumentException, IllegalAccessException;",
    "comment": "\n\t\t * Perform an operation using the given method.\n\t\t * @param method the method to operate on\n\t\t "
  },
  {
    "entityId": "org.springframework.util.MethodFilter",
    "entityType": "class",
    "code": "/**\r\n * Determine whether the given method matches.\r\n * @param method the method to check\r\n */\r\nboolean matches(Method method);\n/**\r\n * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n * <p>If this filter does not match, the next filter will not be applied.\r\n * @param next the next {@code MethodFilter}\r\n * @return a composite {@code MethodFilter}\r\n * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\r\n * @since 5.3.2\r\n */\r\ndefault MethodFilter and(MethodFilter next) {\r\n    Assert.notNull(next, \"Next MethodFilter must not be null\");\r\n    return method -> matches(method) && next.matches(method);\r\n}",
    "comment": "\n\t * Callback optionally used to filter methods to be operated on by a method callback.\n\t "
  },
  {
    "entityId": "org.springframework.util.MethodFilter#matches(Method)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given method matches.\r\n * @param method the method to check\r\n */\r\nboolean matches(Method method);",
    "comment": "\n\t\t * Determine whether the given method matches.\n\t\t * @param method the method to check\n\t\t "
  },
  {
    "entityId": "org.springframework.util.MethodFilter#and(MethodFilter)",
    "entityType": "method",
    "code": "/**\r\n * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n * <p>If this filter does not match, the next filter will not be applied.\r\n * @param next the next {@code MethodFilter}\r\n * @return a composite {@code MethodFilter}\r\n * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\r\n * @since 5.3.2\r\n */\r\ndefault MethodFilter and(MethodFilter next) {\r\n    Assert.notNull(next, \"Next MethodFilter must not be null\");\r\n    return method -> matches(method) && next.matches(method);\r\n}",
    "comment": "\n\t\t * Create a composite filter based on this filter <em>and</em> the provided filter.\n\t\t * <p>If this filter does not match, the next filter will not be applied.\n\t\t * @param next the next {@code MethodFilter}\n\t\t * @return a composite {@code MethodFilter}\n\t\t * @throws IllegalArgumentException if the MethodFilter argument is {@code null}\n\t\t * @since 5.3.2\n\t\t "
  },
  {
    "entityId": "org.springframework.util.FieldCallback",
    "entityType": "class",
    "code": "/**\r\n * Perform an operation using the given field.\r\n * @param field the field to operate on\r\n */\r\nvoid doWith(Field field) throws IllegalArgumentException, IllegalAccessException;",
    "comment": "\n\t * Callback interface invoked on each field in the hierarchy.\n\t "
  },
  {
    "entityId": "org.springframework.util.FieldCallback#doWith(Field)",
    "entityType": "method",
    "code": "/**\r\n * Perform an operation using the given field.\r\n * @param field the field to operate on\r\n */\r\nvoid doWith(Field field) throws IllegalArgumentException, IllegalAccessException;",
    "comment": "\n\t\t * Perform an operation using the given field.\n\t\t * @param field the field to operate on\n\t\t "
  },
  {
    "entityId": "org.springframework.util.FieldFilter",
    "entityType": "class",
    "code": "/**\r\n * Determine whether the given field matches.\r\n * @param field the field to check\r\n */\r\nboolean matches(Field field);\n/**\r\n * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n * <p>If this filter does not match, the next filter will not be applied.\r\n * @param next the next {@code FieldFilter}\r\n * @return a composite {@code FieldFilter}\r\n * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\r\n * @since 5.3.2\r\n */\r\ndefault FieldFilter and(FieldFilter next) {\r\n    Assert.notNull(next, \"Next FieldFilter must not be null\");\r\n    return field -> matches(field) && next.matches(field);\r\n}",
    "comment": "\n\t * Callback optionally used to filter fields to be operated on by a field callback.\n\t "
  },
  {
    "entityId": "org.springframework.util.FieldFilter#matches(Field)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given field matches.\r\n * @param field the field to check\r\n */\r\nboolean matches(Field field);",
    "comment": "\n\t\t * Determine whether the given field matches.\n\t\t * @param field the field to check\n\t\t "
  },
  {
    "entityId": "org.springframework.util.FieldFilter#and(FieldFilter)",
    "entityType": "method",
    "code": "/**\r\n * Create a composite filter based on this filter <em>and</em> the provided filter.\r\n * <p>If this filter does not match, the next filter will not be applied.\r\n * @param next the next {@code FieldFilter}\r\n * @return a composite {@code FieldFilter}\r\n * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\r\n * @since 5.3.2\r\n */\r\ndefault FieldFilter and(FieldFilter next) {\r\n    Assert.notNull(next, \"Next FieldFilter must not be null\");\r\n    return field -> matches(field) && next.matches(field);\r\n}",
    "comment": "\n\t\t * Create a composite filter based on this filter <em>and</em> the provided filter.\n\t\t * <p>If this filter does not match, the next filter will not be applied.\n\t\t * @param next the next {@code FieldFilter}\n\t\t * @return a composite {@code FieldFilter}\n\t\t * @throws IllegalArgumentException if the FieldFilter argument is {@code null}\n\t\t * @since 5.3.2\n\t\t "
  }
]