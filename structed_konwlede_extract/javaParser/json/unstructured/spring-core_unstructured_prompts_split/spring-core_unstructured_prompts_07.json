[
  {
    "entityId": "org.springframework.aot.generate.MethodName",
    "entityType": "class",
    "code": "private static final String[] PREFIXES = { \"get\", \"set\", \"is\" };\n/**\r\n * An empty method name.\r\n */\r\npublic static final MethodName NONE = of();\nprivate final String value;\nprivate MethodName(String value) {\r\n    this.value = value;\r\n}\n/**\r\n * Create a new method name from the specific parts. The returned name will\r\n * be in camel-case and will only contain valid characters from the parts.\r\n * @param parts the parts the form the name\r\n * @return a method name instance\r\n */\r\nstatic MethodName of(String... parts) {\r\n    Assert.notNull(parts, \"'parts' must not be null\");\r\n    return new MethodName(join(parts));\r\n}\n/**\r\n * Create a new method name by concatenating the specified name to this name.\r\n * @param name the name to concatenate\r\n * @return a new method name instance\r\n */\r\nMethodName and(MethodName name) {\r\n    Assert.notNull(name, \"'name' must not be null\");\r\n    return and(name.value);\r\n}\n/**\r\n * Create a new method name by concatenating the specified parts to this name.\r\n * @param parts the parts to concatenate\r\n * @return a new method name instance\r\n */\r\nMethodName and(String... parts) {\r\n    Assert.notNull(parts, \"'parts' must not be null\");\r\n    String joined = join(parts);\r\n    String prefix = getPrefix(joined);\r\n    String suffix = joined.substring(prefix.length());\r\n    return of(prefix, this.value, suffix);\r\n}\nprivate String getPrefix(String name) {\r\n    for (String candidate : PREFIXES) {\r\n        if (name.startsWith(candidate)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return \"\";\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MethodName that && this.value.equals(that.value)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.value.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return (!StringUtils.hasLength(this.value)) ? \"$$aot\" : this.value;\r\n}\nprivate static String join(String[] parts) {\r\n    return StringUtils.uncapitalize(Arrays.stream(parts).map(MethodName::clean).map(StringUtils::capitalize).collect(Collectors.joining()));\r\n}\nprivate static String clean(@Nullable String part) {\r\n    char[] chars = (part != null) ? part.toCharArray() : new char[0];\r\n    StringBuilder name = new StringBuilder(chars.length);\r\n    boolean uppercase = false;\r\n    for (char ch : chars) {\r\n        char outputChar = (!uppercase ? ch : Character.toUpperCase(ch));\r\n        name.append((!Character.isLetter(ch)) ? \"\" : outputChar);\r\n        uppercase = (ch == '.');\r\n    }\r\n    return name.toString();\r\n}",
    "comment": "\n * A camel-case method name that can be built from distinct parts.\n *\n * @author Phillip Webb\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#of(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new method name from the specific parts. The returned name will\r\n * be in camel-case and will only contain valid characters from the parts.\r\n * @param parts the parts the form the name\r\n * @return a method name instance\r\n */\r\nstatic MethodName of(String... parts) {\r\n    Assert.notNull(parts, \"'parts' must not be null\");\r\n    return new MethodName(join(parts));\r\n}",
    "comment": "\n\t * Create a new method name from the specific parts. The returned name will\n\t * be in camel-case and will only contain valid characters from the parts.\n\t * @param parts the parts the form the name\n\t * @return a method name instance\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#and(MethodName)",
    "entityType": "method",
    "code": "/**\r\n * Create a new method name by concatenating the specified name to this name.\r\n * @param name the name to concatenate\r\n * @return a new method name instance\r\n */\r\nMethodName and(MethodName name) {\r\n    Assert.notNull(name, \"'name' must not be null\");\r\n    return and(name.value);\r\n}",
    "comment": "\n\t * Create a new method name by concatenating the specified name to this name.\n\t * @param name the name to concatenate\n\t * @return a new method name instance\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#and(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new method name by concatenating the specified parts to this name.\r\n * @param parts the parts to concatenate\r\n * @return a new method name instance\r\n */\r\nMethodName and(String... parts) {\r\n    Assert.notNull(parts, \"'parts' must not be null\");\r\n    String joined = join(parts);\r\n    String prefix = getPrefix(joined);\r\n    String suffix = joined.substring(prefix.length());\r\n    return of(prefix, this.value, suffix);\r\n}",
    "comment": "\n\t * Create a new method name by concatenating the specified parts to this name.\n\t * @param parts the parts to concatenate\n\t * @return a new method name instance\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#getPrefix(String)",
    "entityType": "method",
    "code": "private String getPrefix(String name) {\r\n    for (String candidate : PREFIXES) {\r\n        if (name.startsWith(candidate)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return \"\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof MethodName that && this.value.equals(that.value)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.value.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return (!StringUtils.hasLength(this.value)) ? \"$$aot\" : this.value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#join(String[])",
    "entityType": "method",
    "code": "private static String join(String[] parts) {\r\n    return StringUtils.uncapitalize(Arrays.stream(parts).map(MethodName::clean).map(StringUtils::capitalize).collect(Collectors.joining()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MethodName#clean(String)",
    "entityType": "method",
    "code": "private static String clean(@Nullable String part) {\r\n    char[] chars = (part != null) ? part.toCharArray() : new char[0];\r\n    StringBuilder name = new StringBuilder(chars.length);\r\n    boolean uppercase = false;\r\n    for (char ch : chars) {\r\n        char outputChar = (!uppercase ? ch : Character.toUpperCase(ch));\r\n        name.append((!Character.isLetter(ch)) ? \"\" : outputChar);\r\n        uppercase = (ch == '.');\r\n    }\r\n    return name.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.ClassloadingAssertions",
    "entityType": "class",
    "code": "private static boolean isClassLoaded(String className) {\r\n    ClassLoader cl = ClassUtils.getDefaultClassLoader();\r\n    Method findLoadedClassMethod = ReflectionUtils.findMethod(cl.getClass(), \"findLoadedClass\", String.class);\r\n    ReflectionUtils.makeAccessible(findLoadedClassMethod);\r\n    Class<?> loadedClass = (Class<?>) ReflectionUtils.invokeMethod(findLoadedClassMethod, cl, className);\r\n    return loadedClass != null;\r\n}\npublic static void assertClassNotLoaded(String className) {\r\n    assertThat(isClassLoaded(className)).as(\"Class [\" + className + \"] should not have been loaded\").isFalse();\r\n}",
    "comment": "\n * @author Ramnivas Laddad\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.type.ClassloadingAssertions#isClassLoaded(String)",
    "entityType": "method",
    "code": "private static boolean isClassLoaded(String className) {\r\n    ClassLoader cl = ClassUtils.getDefaultClassLoader();\r\n    Method findLoadedClassMethod = ReflectionUtils.findMethod(cl.getClass(), \"findLoadedClass\", String.class);\r\n    ReflectionUtils.makeAccessible(findLoadedClassMethod);\r\n    Class<?> loadedClass = (Class<?>) ReflectionUtils.invokeMethod(findLoadedClassMethod, cl, className);\r\n    return loadedClass != null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.ClassloadingAssertions#assertClassNotLoaded(String)",
    "entityType": "method",
    "code": "public static void assertClassNotLoaded(String className) {\r\n    assertThat(isClassLoaded(className)).as(\"Class [\" + className + \"] should not have been loaded\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MethodReference",
    "entityType": "class",
    "code": "/**\r\n * Return this method reference as a {@link CodeBlock}. If the reference is\r\n * to an instance method then {@code this::<method name>} will be returned.\r\n * @return a code block for the method reference.\r\n */\r\nCodeBlock toCodeBlock();\n/**\r\n * Return this method reference as a {@link CodeBlock} using the specified\r\n * {@link ArgumentCodeGenerator}.\r\n * @param argumentCodeGenerator the argument code generator to use\r\n * @return a code block to invoke the method\r\n */\r\ndefault CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator) {\r\n    return toInvokeCodeBlock(argumentCodeGenerator, null);\r\n}\n/**\r\n * Return this method reference as a {@link CodeBlock} using the specified\r\n * {@link ArgumentCodeGenerator}. The {@code targetClassName} defines the\r\n * context in which the method invocation is added.\r\n * <p>If the caller has an instance of the type in which this method is\r\n * defined, it can hint that by specifying the type as a target class.\r\n * @param argumentCodeGenerator the argument code generator to use\r\n * @param targetClassName the target class name\r\n * @return a code block to invoke the method\r\n */\r\nCodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator, @Nullable ClassName targetClassName);\n/**\r\n * Strategy for generating code for arguments based on their type.\r\n */\r\ninterface ArgumentCodeGenerator {\r\n\r\n    /**\r\n     * Generate the code for the given argument type. If this type is\r\n     * not supported, return {@code null}.\r\n     * @param argumentType the argument type\r\n     * @return the code for this argument, or {@code null}\r\n     */\r\n    @Nullable\r\n    CodeBlock generateCode(TypeName argumentType);\r\n\r\n    /**\r\n     * Factory method that returns an {@link ArgumentCodeGenerator} that\r\n     * always returns {@code null}.\r\n     * @return a new {@link ArgumentCodeGenerator} instance\r\n     */\r\n    static ArgumentCodeGenerator none() {\r\n        return from(type -> null);\r\n    }\r\n\r\n    /**\r\n     * Factory method that can be used to create an {@link ArgumentCodeGenerator}\r\n     * that support only the given argument type.\r\n     * @param argumentType the argument type\r\n     * @param argumentCode the code for an argument of that type\r\n     * @return a new {@link ArgumentCodeGenerator} instance\r\n     */\r\n    static ArgumentCodeGenerator of(Class<?> argumentType, String argumentCode) {\r\n        return from(candidateType -> candidateType.equals(ClassName.get(argumentType)) ? CodeBlock.of(argumentCode) : null);\r\n    }\r\n\r\n    /**\r\n     * Factory method that creates a new {@link ArgumentCodeGenerator} from\r\n     * a lambda friendly function. The given function is provided with the\r\n     * argument type and must provide the code to use or {@code null} if\r\n     * the type is not supported.\r\n     * @param function the resolver function\r\n     * @return a new {@link ArgumentCodeGenerator} instance backed by the function\r\n     */\r\n    static ArgumentCodeGenerator from(Function<TypeName, @Nullable CodeBlock> function) {\r\n        return function::apply;\r\n    }\r\n\r\n    /**\r\n     * Create a new composed {@link ArgumentCodeGenerator} by combining this\r\n     * generator with supporting the given argument type.\r\n     * @param argumentType the argument type\r\n     * @param argumentCode the code for an argument of that type\r\n     * @return a new composite {@link ArgumentCodeGenerator} instance\r\n     */\r\n    default ArgumentCodeGenerator and(Class<?> argumentType, String argumentCode) {\r\n        return and(ArgumentCodeGenerator.of(argumentType, argumentCode));\r\n    }\r\n\r\n    /**\r\n     * Create a new composed {@link ArgumentCodeGenerator} by combining this\r\n     * generator with the given generator.\r\n     * @param argumentCodeGenerator the argument generator to add\r\n     * @return a new composite {@link ArgumentCodeGenerator} instance\r\n     */\r\n    default ArgumentCodeGenerator and(ArgumentCodeGenerator argumentCodeGenerator) {\r\n        return from(type -> {\r\n            CodeBlock code = generateCode(type);\r\n            return (code != null ? code : argumentCodeGenerator.generateCode(type));\r\n        });\r\n    }\r\n}",
    "comment": "\n * A reference to a method with convenient code generation for\n * referencing, or invoking it.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodReference#toCodeBlock()",
    "entityType": "method",
    "code": "/**\r\n * Return this method reference as a {@link CodeBlock}. If the reference is\r\n * to an instance method then {@code this::<method name>} will be returned.\r\n * @return a code block for the method reference.\r\n */\r\nCodeBlock toCodeBlock();",
    "comment": "\n\t * Return this method reference as a {@link CodeBlock}. If the reference is\n\t * to an instance method then {@code this::<method name>} will be returned.\n\t * @return a code block for the method reference.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodReference#toInvokeCodeBlock(ArgumentCodeGenerator)",
    "entityType": "method",
    "code": "/**\r\n * Return this method reference as a {@link CodeBlock} using the specified\r\n * {@link ArgumentCodeGenerator}.\r\n * @param argumentCodeGenerator the argument code generator to use\r\n * @return a code block to invoke the method\r\n */\r\ndefault CodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator) {\r\n    return toInvokeCodeBlock(argumentCodeGenerator, null);\r\n}",
    "comment": "\n\t * Return this method reference as a {@link CodeBlock} using the specified\n\t * {@link ArgumentCodeGenerator}.\n\t * @param argumentCodeGenerator the argument code generator to use\n\t * @return a code block to invoke the method\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.MethodReference#toInvokeCodeBlock(ArgumentCodeGenerator,ClassName)",
    "entityType": "method",
    "code": "/**\r\n * Return this method reference as a {@link CodeBlock} using the specified\r\n * {@link ArgumentCodeGenerator}. The {@code targetClassName} defines the\r\n * context in which the method invocation is added.\r\n * <p>If the caller has an instance of the type in which this method is\r\n * defined, it can hint that by specifying the type as a target class.\r\n * @param argumentCodeGenerator the argument code generator to use\r\n * @param targetClassName the target class name\r\n * @return a code block to invoke the method\r\n */\r\nCodeBlock toInvokeCodeBlock(ArgumentCodeGenerator argumentCodeGenerator, @Nullable ClassName targetClassName);",
    "comment": "\n\t * Return this method reference as a {@link CodeBlock} using the specified\n\t * {@link ArgumentCodeGenerator}. The {@code targetClassName} defines the\n\t * context in which the method invocation is added.\n\t * <p>If the caller has an instance of the type in which this method is\n\t * defined, it can hint that by specifying the type as a target class.\n\t * @param argumentCodeGenerator the argument code generator to use\n\t * @param targetClassName the target class name\n\t * @return a code block to invoke the method\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator",
    "entityType": "class",
    "code": "/**\r\n * Generate the code for the given argument type. If this type is\r\n * not supported, return {@code null}.\r\n * @param argumentType the argument type\r\n * @return the code for this argument, or {@code null}\r\n */\r\n@Nullable\r\nCodeBlock generateCode(TypeName argumentType);\n/**\r\n * Factory method that returns an {@link ArgumentCodeGenerator} that\r\n * always returns {@code null}.\r\n * @return a new {@link ArgumentCodeGenerator} instance\r\n */\r\nstatic ArgumentCodeGenerator none() {\r\n    return from(type -> null);\r\n}\n/**\r\n * Factory method that can be used to create an {@link ArgumentCodeGenerator}\r\n * that support only the given argument type.\r\n * @param argumentType the argument type\r\n * @param argumentCode the code for an argument of that type\r\n * @return a new {@link ArgumentCodeGenerator} instance\r\n */\r\nstatic ArgumentCodeGenerator of(Class<?> argumentType, String argumentCode) {\r\n    return from(candidateType -> candidateType.equals(ClassName.get(argumentType)) ? CodeBlock.of(argumentCode) : null);\r\n}\n/**\r\n * Factory method that creates a new {@link ArgumentCodeGenerator} from\r\n * a lambda friendly function. The given function is provided with the\r\n * argument type and must provide the code to use or {@code null} if\r\n * the type is not supported.\r\n * @param function the resolver function\r\n * @return a new {@link ArgumentCodeGenerator} instance backed by the function\r\n */\r\nstatic ArgumentCodeGenerator from(Function<TypeName, @Nullable CodeBlock> function) {\r\n    return function::apply;\r\n}\n/**\r\n * Create a new composed {@link ArgumentCodeGenerator} by combining this\r\n * generator with supporting the given argument type.\r\n * @param argumentType the argument type\r\n * @param argumentCode the code for an argument of that type\r\n * @return a new composite {@link ArgumentCodeGenerator} instance\r\n */\r\ndefault ArgumentCodeGenerator and(Class<?> argumentType, String argumentCode) {\r\n    return and(ArgumentCodeGenerator.of(argumentType, argumentCode));\r\n}\n/**\r\n * Create a new composed {@link ArgumentCodeGenerator} by combining this\r\n * generator with the given generator.\r\n * @param argumentCodeGenerator the argument generator to add\r\n * @return a new composite {@link ArgumentCodeGenerator} instance\r\n */\r\ndefault ArgumentCodeGenerator and(ArgumentCodeGenerator argumentCodeGenerator) {\r\n    return from(type -> {\r\n        CodeBlock code = generateCode(type);\r\n        return (code != null ? code : argumentCodeGenerator.generateCode(type));\r\n    });\r\n}",
    "comment": "\n\t * Strategy for generating code for arguments based on their type.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator#generateCode(TypeName)",
    "entityType": "method",
    "code": "/**\r\n * Generate the code for the given argument type. If this type is\r\n * not supported, return {@code null}.\r\n * @param argumentType the argument type\r\n * @return the code for this argument, or {@code null}\r\n */\r\n@Nullable\r\nCodeBlock generateCode(TypeName argumentType);",
    "comment": "\n\t\t * Generate the code for the given argument type. If this type is\n\t\t * not supported, return {@code null}.\n\t\t * @param argumentType the argument type\n\t\t * @return the code for this argument, or {@code null}\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator#none()",
    "entityType": "method",
    "code": "/**\r\n * Factory method that returns an {@link ArgumentCodeGenerator} that\r\n * always returns {@code null}.\r\n * @return a new {@link ArgumentCodeGenerator} instance\r\n */\r\nstatic ArgumentCodeGenerator none() {\r\n    return from(type -> null);\r\n}",
    "comment": "\n\t\t * Factory method that returns an {@link ArgumentCodeGenerator} that\n\t\t * always returns {@code null}.\n\t\t * @return a new {@link ArgumentCodeGenerator} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator#of(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Factory method that can be used to create an {@link ArgumentCodeGenerator}\r\n * that support only the given argument type.\r\n * @param argumentType the argument type\r\n * @param argumentCode the code for an argument of that type\r\n * @return a new {@link ArgumentCodeGenerator} instance\r\n */\r\nstatic ArgumentCodeGenerator of(Class<?> argumentType, String argumentCode) {\r\n    return from(candidateType -> candidateType.equals(ClassName.get(argumentType)) ? CodeBlock.of(argumentCode) : null);\r\n}",
    "comment": "\n\t\t * Factory method that can be used to create an {@link ArgumentCodeGenerator}\n\t\t * that support only the given argument type.\n\t\t * @param argumentType the argument type\n\t\t * @param argumentCode the code for an argument of that type\n\t\t * @return a new {@link ArgumentCodeGenerator} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator#from(Function<TypeName,CodeBlock>)",
    "entityType": "method",
    "code": "/**\r\n * Factory method that creates a new {@link ArgumentCodeGenerator} from\r\n * a lambda friendly function. The given function is provided with the\r\n * argument type and must provide the code to use or {@code null} if\r\n * the type is not supported.\r\n * @param function the resolver function\r\n * @return a new {@link ArgumentCodeGenerator} instance backed by the function\r\n */\r\nstatic ArgumentCodeGenerator from(Function<TypeName, @Nullable CodeBlock> function) {\r\n    return function::apply;\r\n}",
    "comment": "\n\t\t * Factory method that creates a new {@link ArgumentCodeGenerator} from\n\t\t * a lambda friendly function. The given function is provided with the\n\t\t * argument type and must provide the code to use or {@code null} if\n\t\t * the type is not supported.\n\t\t * @param function the resolver function\n\t\t * @return a new {@link ArgumentCodeGenerator} instance backed by the function\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator#and(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new composed {@link ArgumentCodeGenerator} by combining this\r\n * generator with supporting the given argument type.\r\n * @param argumentType the argument type\r\n * @param argumentCode the code for an argument of that type\r\n * @return a new composite {@link ArgumentCodeGenerator} instance\r\n */\r\ndefault ArgumentCodeGenerator and(Class<?> argumentType, String argumentCode) {\r\n    return and(ArgumentCodeGenerator.of(argumentType, argumentCode));\r\n}",
    "comment": "\n\t\t * Create a new composed {@link ArgumentCodeGenerator} by combining this\n\t\t * generator with supporting the given argument type.\n\t\t * @param argumentType the argument type\n\t\t * @param argumentCode the code for an argument of that type\n\t\t * @return a new composite {@link ArgumentCodeGenerator} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArgumentCodeGenerator#and(ArgumentCodeGenerator)",
    "entityType": "method",
    "code": "/**\r\n * Create a new composed {@link ArgumentCodeGenerator} by combining this\r\n * generator with the given generator.\r\n * @param argumentCodeGenerator the argument generator to add\r\n * @return a new composite {@link ArgumentCodeGenerator} instance\r\n */\r\ndefault ArgumentCodeGenerator and(ArgumentCodeGenerator argumentCodeGenerator) {\r\n    return from(type -> {\r\n        CodeBlock code = generateCode(type);\r\n        return (code != null ? code : argumentCodeGenerator.generateCode(type));\r\n    });\r\n}",
    "comment": "\n\t\t * Create a new composed {@link ArgumentCodeGenerator} by combining this\n\t\t * generator with the given generator.\n\t\t * @param argumentCodeGenerator the argument generator to add\n\t\t * @return a new composite {@link ArgumentCodeGenerator} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.ClassMetadataReadingVisitorMemberClassTests",
    "entityType": "class",
    "code": "@Override\r\npublic ClassMetadata getClassMetadataFor(Class<?> clazz) {\r\n    try {\r\n        MetadataReader reader = new SimpleMetadataReaderFactory().getMetadataReader(clazz.getName());\r\n        return reader.getAnnotationMetadata();\r\n    } catch (IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": "\n * @author Chris Beams\n * @since 3.1\n * @see AbstractClassMetadataMemberClassTests\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.ClassMetadataReadingVisitorMemberClassTests#getClassMetadataFor(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic ClassMetadata getClassMetadataFor(Class<?> clazz) {\r\n    try {\r\n        MetadataReader reader = new SimpleMetadataReaderFactory().getMetadataReader(clazz.getName());\r\n        return reader.getAnnotationMetadata();\r\n    } catch (IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.UnsupportedTypeValueCodeGenerationException",
    "entityType": "class",
    "code": "public UnsupportedTypeValueCodeGenerationException(Object value) {\r\n    super(\"Code generation does not support \" + value.getClass().getName(), value, null);\r\n}",
    "comment": "\n * Thrown when a {@link ValueCodeGenerator} could not generate the code for a\n * given value.\n *\n * @author Stephane Nicoll\n * @since 6.1.2\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests",
    "entityType": "class",
    "code": "private MergedAnnotation<?> annotation;\n@Test\r\nvoid visitWhenHasSimpleTypesCreatesAnnotation() {\r\n    loadFrom(WithSimpleTypesAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(SimpleTypesAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"stringValue\")).contains(\"string\");\r\n    assertThat(this.annotation.getValue(\"byteValue\")).contains((byte) 1);\r\n    assertThat(this.annotation.getValue(\"shortValue\")).contains((short) 2);\r\n    assertThat(this.annotation.getValue(\"intValue\")).contains(3);\r\n    assertThat(this.annotation.getValue(\"longValue\")).contains(4L);\r\n    assertThat(this.annotation.getValue(\"booleanValue\")).contains(true);\r\n    assertThat(this.annotation.getValue(\"charValue\")).contains('c');\r\n    assertThat(this.annotation.getValue(\"doubleValue\")).contains(5.0);\r\n    assertThat(this.annotation.getValue(\"floatValue\")).contains(6.0f);\r\n}\n@Test\r\nvoid visitWhenHasSimpleArrayTypesCreatesAnnotation() {\r\n    loadFrom(WithSimpleArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(SimpleArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"stringValue\")).contains(new String[] { \"string\" });\r\n    assertThat(this.annotation.getValue(\"byteValue\")).contains(new byte[] { 1 });\r\n    assertThat(this.annotation.getValue(\"shortValue\")).contains(new short[] { 2 });\r\n    assertThat(this.annotation.getValue(\"intValue\")).contains(new int[] { 3 });\r\n    assertThat(this.annotation.getValue(\"longValue\")).contains(new long[] { 4 });\r\n    assertThat(this.annotation.getValue(\"booleanValue\")).contains(new boolean[] { true });\r\n    assertThat(this.annotation.getValue(\"charValue\")).contains(new char[] { 'c' });\r\n    assertThat(this.annotation.getValue(\"doubleValue\")).contains(new double[] { 5.0 });\r\n    assertThat(this.annotation.getValue(\"floatValue\")).contains(new float[] { 6.0f });\r\n}\n@Test\r\nvoid visitWhenHasEmptySimpleArrayTypesCreatesAnnotation() {\r\n    loadFrom(WithSimpleEmptyArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(SimpleArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"stringValue\")).contains(new String[] ;);\r\n    assertThat(this.annotation.getValue(\"byteValue\")).contains(new byte[] ;);\r\n    assertThat(this.annotation.getValue(\"shortValue\")).contains(new short[] ;);\r\n    assertThat(this.annotation.getValue(\"intValue\")).contains(new int[] ;);\r\n    assertThat(this.annotation.getValue(\"longValue\")).contains(new long[] ;);\r\n    assertThat(this.annotation.getValue(\"booleanValue\")).contains(new boolean[] ;);\r\n    assertThat(this.annotation.getValue(\"charValue\")).contains(new char[] ;);\r\n    assertThat(this.annotation.getValue(\"doubleValue\")).contains(new double[] ;);\r\n    assertThat(this.annotation.getValue(\"floatValue\")).contains(new float[] ;);\r\n}\n@Test\r\nvoid visitWhenHasEnumAttributesCreatesAnnotation() {\r\n    loadFrom(WithEnumAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(EnumAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"enumValue\")).contains(ExampleEnum.ONE);\r\n    assertThat(this.annotation.getValue(\"enumArrayValue\")).contains(new ExampleEnum[] { ExampleEnum.ONE, ExampleEnum.TWO });\r\n}\n@Test\r\nvoid visitWhenHasAnnotationAttributesCreatesAnnotation() {\r\n    loadFrom(WithAnnotationAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(AnnotationAnnotation.class);\r\n    MergedAnnotation<NestedAnnotation> value = this.annotation.getAnnotation(\"annotationValue\", NestedAnnotation.class);\r\n    assertThat(value.isPresent()).isTrue();\r\n    assertThat(value.getString(MergedAnnotation.VALUE)).isEqualTo(\"a\");\r\n    MergedAnnotation<NestedAnnotation>[] arrayValue = this.annotation.getAnnotationArray(\"annotationArrayValue\", NestedAnnotation.class);\r\n    assertThat(arrayValue).hasSize(2);\r\n    assertThat(arrayValue[0].getString(MergedAnnotation.VALUE)).isEqualTo(\"b\");\r\n    assertThat(arrayValue[1].getString(MergedAnnotation.VALUE)).isEqualTo(\"c\");\r\n}\n@Test\r\nvoid visitWhenHasClassAttributesCreatesAnnotation() {\r\n    loadFrom(WithClassAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(ClassAnnotation.class);\r\n    assertThat(this.annotation.getString(\"classValue\")).isEqualTo(InputStream.class.getName());\r\n    assertThat(this.annotation.getClass(\"classValue\")).isEqualTo(InputStream.class);\r\n    assertThat(this.annotation.getValue(\"classValue\")).contains(InputStream.class);\r\n    assertThat(this.annotation.getStringArray(\"classArrayValue\")).containsExactly(OutputStream.class.getName());\r\n    assertThat(this.annotation.getValue(\"classArrayValue\")).contains(new Class<?>[] { OutputStream.class });\r\n}\nprivate void loadFrom(Class<?> type) {\r\n    ClassVisitor visitor = new ClassVisitor(SpringAsmInfo.ASM_VERSION) {\r\n\r\n        @Override\r\n        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\r\n            return MergedAnnotationReadingVisitor.get(getClass().getClassLoader(), null, descriptor, visible, annotation -> MergedAnnotationMetadataVisitorTests.this.annotation = annotation);\r\n        }\r\n    };\r\n    try {\r\n        new ClassReader(type.getName()).accept(visitor, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES);\r\n    } catch (IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}\n@SimpleTypesAnnotation(stringValue = \"string\", byteValue = 1, shortValue = 2, intValue = 3, longValue = 4, booleanValue = true, charValue = 'c', doubleValue = 5.0, floatValue = 6.0f)\r\nstatic class WithSimpleTypesAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SimpleTypesAnnotation {\r\n\r\n    String stringValue();\r\n\r\n    byte byteValue();\r\n\r\n    short shortValue();\r\n\r\n    int intValue();\r\n\r\n    long longValue();\r\n\r\n    boolean booleanValue();\r\n\r\n    char charValue();\r\n\r\n    double doubleValue();\r\n\r\n    float floatValue();\r\n}\n@SimpleArrayTypesAnnotation(stringValue = \"string\", byteValue = 1, shortValue = 2, intValue = 3, longValue = 4, booleanValue = true, charValue = 'c', doubleValue = 5.0, floatValue = 6.0f)\r\nstatic class WithSimpleArrayTypesAnnotation {\r\n}\n@SimpleArrayTypesAnnotation(stringValue = {}, byteValue = {}, shortValue = {}, intValue = {}, longValue = {}, booleanValue = {}, charValue = {}, doubleValue = {}, floatValue = {})\r\nstatic class WithSimpleEmptyArrayTypesAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SimpleArrayTypesAnnotation {\r\n\r\n    String[] stringValue();\r\n\r\n    byte[] byteValue();\r\n\r\n    short[] shortValue();\r\n\r\n    int[] intValue();\r\n\r\n    long[] longValue();\r\n\r\n    boolean[] booleanValue();\r\n\r\n    char[] charValue();\r\n\r\n    double[] doubleValue();\r\n\r\n    float[] floatValue();\r\n}\n@EnumAnnotation(enumValue = ExampleEnum.ONE, enumArrayValue = { ExampleEnum.ONE, ExampleEnum.TWO })\r\nstatic class WithEnumAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface EnumAnnotation {\r\n\r\n    ExampleEnum enumValue();\r\n\r\n    ExampleEnum[] enumArrayValue();\r\n}\nenum ExampleEnum {\r\n\r\n    ONE, TWO, THREE\r\n}\n@AnnotationAnnotation(annotationValue = @NestedAnnotation(\"a\"), annotationArrayValue = { @NestedAnnotation(\"b\"), @NestedAnnotation(\"c\") })\r\nstatic class WithAnnotationAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AnnotationAnnotation {\r\n\r\n    NestedAnnotation annotationValue();\r\n\r\n    NestedAnnotation[] annotationArrayValue();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NestedAnnotation {\r\n\r\n    String value() default \"\";\r\n}\n@ClassAnnotation(classValue = InputStream.class, classArrayValue = OutputStream.class)\r\nstatic class WithClassAnnotation {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ClassAnnotation {\r\n\r\n    Class<?> classValue();\r\n\r\n    Class<?>[] classArrayValue();\r\n}",
    "comment": "\n * Tests for {@link MergedAnnotationReadingVisitor}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#visitWhenHasSimpleTypesCreatesAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid visitWhenHasSimpleTypesCreatesAnnotation() {\r\n    loadFrom(WithSimpleTypesAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(SimpleTypesAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"stringValue\")).contains(\"string\");\r\n    assertThat(this.annotation.getValue(\"byteValue\")).contains((byte) 1);\r\n    assertThat(this.annotation.getValue(\"shortValue\")).contains((short) 2);\r\n    assertThat(this.annotation.getValue(\"intValue\")).contains(3);\r\n    assertThat(this.annotation.getValue(\"longValue\")).contains(4L);\r\n    assertThat(this.annotation.getValue(\"booleanValue\")).contains(true);\r\n    assertThat(this.annotation.getValue(\"charValue\")).contains('c');\r\n    assertThat(this.annotation.getValue(\"doubleValue\")).contains(5.0);\r\n    assertThat(this.annotation.getValue(\"floatValue\")).contains(6.0f);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#visitWhenHasSimpleArrayTypesCreatesAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid visitWhenHasSimpleArrayTypesCreatesAnnotation() {\r\n    loadFrom(WithSimpleArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(SimpleArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"stringValue\")).contains(new String[] { \"string\" });\r\n    assertThat(this.annotation.getValue(\"byteValue\")).contains(new byte[] { 1 });\r\n    assertThat(this.annotation.getValue(\"shortValue\")).contains(new short[] { 2 });\r\n    assertThat(this.annotation.getValue(\"intValue\")).contains(new int[] { 3 });\r\n    assertThat(this.annotation.getValue(\"longValue\")).contains(new long[] { 4 });\r\n    assertThat(this.annotation.getValue(\"booleanValue\")).contains(new boolean[] { true });\r\n    assertThat(this.annotation.getValue(\"charValue\")).contains(new char[] { 'c' });\r\n    assertThat(this.annotation.getValue(\"doubleValue\")).contains(new double[] { 5.0 });\r\n    assertThat(this.annotation.getValue(\"floatValue\")).contains(new float[] { 6.0f });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#visitWhenHasEmptySimpleArrayTypesCreatesAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid visitWhenHasEmptySimpleArrayTypesCreatesAnnotation() {\r\n    loadFrom(WithSimpleEmptyArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(SimpleArrayTypesAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"stringValue\")).contains(new String[] ;);\r\n    assertThat(this.annotation.getValue(\"byteValue\")).contains(new byte[] ;);\r\n    assertThat(this.annotation.getValue(\"shortValue\")).contains(new short[] ;);\r\n    assertThat(this.annotation.getValue(\"intValue\")).contains(new int[] ;);\r\n    assertThat(this.annotation.getValue(\"longValue\")).contains(new long[] ;);\r\n    assertThat(this.annotation.getValue(\"booleanValue\")).contains(new boolean[] ;);\r\n    assertThat(this.annotation.getValue(\"charValue\")).contains(new char[] ;);\r\n    assertThat(this.annotation.getValue(\"doubleValue\")).contains(new double[] ;);\r\n    assertThat(this.annotation.getValue(\"floatValue\")).contains(new float[] ;);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#visitWhenHasEnumAttributesCreatesAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid visitWhenHasEnumAttributesCreatesAnnotation() {\r\n    loadFrom(WithEnumAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(EnumAnnotation.class);\r\n    assertThat(this.annotation.getValue(\"enumValue\")).contains(ExampleEnum.ONE);\r\n    assertThat(this.annotation.getValue(\"enumArrayValue\")).contains(new ExampleEnum[] { ExampleEnum.ONE, ExampleEnum.TWO });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#visitWhenHasAnnotationAttributesCreatesAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid visitWhenHasAnnotationAttributesCreatesAnnotation() {\r\n    loadFrom(WithAnnotationAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(AnnotationAnnotation.class);\r\n    MergedAnnotation<NestedAnnotation> value = this.annotation.getAnnotation(\"annotationValue\", NestedAnnotation.class);\r\n    assertThat(value.isPresent()).isTrue();\r\n    assertThat(value.getString(MergedAnnotation.VALUE)).isEqualTo(\"a\");\r\n    MergedAnnotation<NestedAnnotation>[] arrayValue = this.annotation.getAnnotationArray(\"annotationArrayValue\", NestedAnnotation.class);\r\n    assertThat(arrayValue).hasSize(2);\r\n    assertThat(arrayValue[0].getString(MergedAnnotation.VALUE)).isEqualTo(\"b\");\r\n    assertThat(arrayValue[1].getString(MergedAnnotation.VALUE)).isEqualTo(\"c\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#visitWhenHasClassAttributesCreatesAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid visitWhenHasClassAttributesCreatesAnnotation() {\r\n    loadFrom(WithClassAnnotation.class);\r\n    assertThat(this.annotation.getType()).isEqualTo(ClassAnnotation.class);\r\n    assertThat(this.annotation.getString(\"classValue\")).isEqualTo(InputStream.class.getName());\r\n    assertThat(this.annotation.getClass(\"classValue\")).isEqualTo(InputStream.class);\r\n    assertThat(this.annotation.getValue(\"classValue\")).contains(InputStream.class);\r\n    assertThat(this.annotation.getStringArray(\"classArrayValue\")).containsExactly(OutputStream.class.getName());\r\n    assertThat(this.annotation.getValue(\"classArrayValue\")).contains(new Class<?>[] { OutputStream.class });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.MergedAnnotationMetadataVisitorTests#loadFrom(Class<?>)",
    "entityType": "method",
    "code": "private void loadFrom(Class<?> type) {\r\n    ClassVisitor visitor = new ClassVisitor(SpringAsmInfo.ASM_VERSION) {\r\n\r\n        @Override\r\n        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\r\n            return MergedAnnotationReadingVisitor.get(getClass().getClassLoader(), null, descriptor, visible, annotation -> MergedAnnotationMetadataVisitorTests.this.annotation = annotation);\r\n        }\r\n    };\r\n    try {\r\n        new ClassReader(type.getName()).accept(visitor, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES);\r\n    } catch (IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.WithSimpleTypesAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.WithSimpleArrayTypesAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.WithSimpleEmptyArrayTypesAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.WithEnumAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.WithAnnotationAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.WithClassAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerationException",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object value;\nprotected ValueCodeGenerationException(String message, @Nullable Object value, @Nullable Throwable cause) {\r\n    super(message, cause);\r\n    this.value = value;\r\n}\npublic ValueCodeGenerationException(@Nullable Object value, Throwable cause) {\r\n    super(buildErrorMessage(value), cause);\r\n    this.value = value;\r\n}\nprivate static String buildErrorMessage(@Nullable Object value) {\r\n    StringBuilder message = new StringBuilder(\"Failed to generate code for '\");\r\n    message.append(value).append(\"'\");\r\n    if (value != null) {\r\n        message.append(\" with type \").append(value.getClass());\r\n    }\r\n    return message.toString();\r\n}\n/**\r\n * Return the value that failed to be generated.\r\n */\r\n@Nullable\r\npublic Object getValue() {\r\n    return this.value;\r\n}",
    "comment": "\n * Thrown when value code generation fails.\n *\n * @author Stephane Nicoll\n * @since 6.1.2\n "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerationException#buildErrorMessage(Object)",
    "entityType": "method",
    "code": "private static String buildErrorMessage(@Nullable Object value) {\r\n    StringBuilder message = new StringBuilder(\"Failed to generate code for '\");\r\n    message.append(value).append(\"'\");\r\n    if (value != null) {\r\n        message.append(\" with type \").append(value.getClass());\r\n    }\r\n    return message.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerationException#getValue()",
    "entityType": "method",
    "code": "/**\r\n * Return the value that failed to be generated.\r\n */\r\n@Nullable\r\npublic Object getValue() {\r\n    return this.value;\r\n}",
    "comment": "\n\t * Return the value that failed to be generated.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataTests",
    "entityType": "class",
    "code": "@Override\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    try {\r\n        return new SimpleMetadataReaderFactory(source.getClassLoader()).getMetadataReader(source.getName()).getAnnotationMetadata();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": "\n * Tests for {@link SimpleAnnotationMetadata} and\n * {@link SimpleAnnotationMetadataReadingVisitor}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataTests#get(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    try {\r\n        return new SimpleMetadataReaderFactory(source.getClassLoader()).getMetadataReader(source.getName()).getAnnotationMetadata();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadataTests",
    "entityType": "class",
    "code": "@Override\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    try {\r\n        return new SimpleMetadataReaderFactory(source.getClassLoader()).getMetadataReader(source.getName()).getAnnotationMetadata();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": "\n * Tests for {@link SimpleMethodMetadata} and\n * {@link SimpleMethodMetadataReadingVisitor}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadataTests#get(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    try {\r\n        return new SimpleMetadataReaderFactory(source.getClassLoader()).getMetadataReader(source.getName()).getAnnotationMetadata();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator",
    "entityType": "class",
    "code": "private static final ValueCodeGenerator INSTANCE = new ValueCodeGenerator(ValueCodeGeneratorDelegates.INSTANCES, null);\nprivate static final CodeBlock NULL_VALUE_CODE_BLOCK = CodeBlock.of(\"null\");\nprivate final List<Delegate> delegates;\n@Nullable\r\nprivate final GeneratedMethods generatedMethods;\nprivate ValueCodeGenerator(List<Delegate> delegates, @Nullable GeneratedMethods generatedMethods) {\r\n    this.delegates = delegates;\r\n    this.generatedMethods = generatedMethods;\r\n}\n/**\r\n * Return an instance that provides support for {@linkplain\r\n * ValueCodeGeneratorDelegates#INSTANCES common value types}.\r\n * @return an instance with support for common value types\r\n */\r\npublic static ValueCodeGenerator withDefaults() {\r\n    return INSTANCE;\r\n}\n/**\r\n * Create an instance with the specified {@link Delegate} implementations.\r\n * @param delegates the delegates to use\r\n * @return an instance with the specified delegates\r\n */\r\npublic static ValueCodeGenerator with(Delegate... delegates) {\r\n    return with(Arrays.asList(delegates));\r\n}\n/**\r\n * Create an instance with the specified {@link Delegate} implementations.\r\n * @param delegates the delegates to use\r\n * @return an instance with the specified delegates\r\n */\r\npublic static ValueCodeGenerator with(List<Delegate> delegates) {\r\n    Assert.notEmpty(delegates, \"Delegates must not be empty\");\r\n    return new ValueCodeGenerator(new ArrayList<>(delegates), null);\r\n}\npublic ValueCodeGenerator add(List<Delegate> additionalDelegates) {\r\n    Assert.notEmpty(additionalDelegates, \"AdditionalDelegates must not be empty\");\r\n    List<Delegate> allDelegates = new ArrayList<>(this.delegates);\r\n    allDelegates.addAll(additionalDelegates);\r\n    return new ValueCodeGenerator(allDelegates, this.generatedMethods);\r\n}\n/**\r\n * Return a {@link ValueCodeGenerator} that is scoped for the specified\r\n * {@link GeneratedMethods}. This allows code generation to generate\r\n * additional methods if necessary, or perform some optimization in\r\n * case of visibility issues.\r\n * @param generatedMethods the generated methods to use\r\n * @return an instance scoped to the specified generated methods\r\n */\r\npublic ValueCodeGenerator scoped(GeneratedMethods generatedMethods) {\r\n    return new ValueCodeGenerator(this.delegates, generatedMethods);\r\n}\n/**\r\n * Generate the code that represents the specified {@code value}.\r\n * @param value the value to generate\r\n * @return the code that represents the specified value\r\n */\r\npublic CodeBlock generateCode(@Nullable Object value) {\r\n    if (value == null) {\r\n        return NULL_VALUE_CODE_BLOCK;\r\n    }\r\n    try {\r\n        for (Delegate delegate : this.delegates) {\r\n            CodeBlock code = delegate.generateCode(this, value);\r\n            if (code != null) {\r\n                return code;\r\n            }\r\n        }\r\n        throw new UnsupportedTypeValueCodeGenerationException(value);\r\n    } catch (Exception ex) {\r\n        throw new ValueCodeGenerationException(value, ex);\r\n    }\r\n}\n/**\r\n * Return the {@link GeneratedMethods} that represents the scope\r\n * in which code generated by this instance will be added, or\r\n * {@code null} if no specific scope is set.\r\n * @return the generated methods to use for code generation\r\n */\r\n@Nullable\r\npublic GeneratedMethods getGeneratedMethods() {\r\n    return this.generatedMethods;\r\n}\n/**\r\n * Strategy interface that can be used to implement code generation for a\r\n * particular value type.\r\n */\r\npublic interface Delegate {\r\n\r\n    /**\r\n     * Generate the code for the specified non-null {@code value}. If this\r\n     * instance does not support the value, it should return {@code null} to\r\n     * indicate so.\r\n     * @param valueCodeGenerator the code generator to use for embedded values\r\n     * @param value the value to generate\r\n     * @return the code that represents the specified value or {@code null} if\r\n     * the specified value is not supported.\r\n     */\r\n    @Nullable\r\n    CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value);\r\n}",
    "comment": "\n * Code generator for a single value. Delegates code generation to a list of\n * configurable {@link Delegate} implementations.\n *\n * @author Stephane Nicoll\n * @since 6.1.2\n "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#withDefaults()",
    "entityType": "method",
    "code": "/**\r\n * Return an instance that provides support for {@linkplain\r\n * ValueCodeGeneratorDelegates#INSTANCES common value types}.\r\n * @return an instance with support for common value types\r\n */\r\npublic static ValueCodeGenerator withDefaults() {\r\n    return INSTANCE;\r\n}",
    "comment": "\n\t * Return an instance that provides support for {@linkplain\n\t * ValueCodeGeneratorDelegates#INSTANCES common value types}.\n\t * @return an instance with support for common value types\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#with(Delegate)",
    "entityType": "method",
    "code": "/**\r\n * Create an instance with the specified {@link Delegate} implementations.\r\n * @param delegates the delegates to use\r\n * @return an instance with the specified delegates\r\n */\r\npublic static ValueCodeGenerator with(Delegate... delegates) {\r\n    return with(Arrays.asList(delegates));\r\n}",
    "comment": "\n\t * Create an instance with the specified {@link Delegate} implementations.\n\t * @param delegates the delegates to use\n\t * @return an instance with the specified delegates\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#with(List<Delegate>)",
    "entityType": "method",
    "code": "/**\r\n * Create an instance with the specified {@link Delegate} implementations.\r\n * @param delegates the delegates to use\r\n * @return an instance with the specified delegates\r\n */\r\npublic static ValueCodeGenerator with(List<Delegate> delegates) {\r\n    Assert.notEmpty(delegates, \"Delegates must not be empty\");\r\n    return new ValueCodeGenerator(new ArrayList<>(delegates), null);\r\n}",
    "comment": "\n\t * Create an instance with the specified {@link Delegate} implementations.\n\t * @param delegates the delegates to use\n\t * @return an instance with the specified delegates\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#add(List<Delegate>)",
    "entityType": "method",
    "code": "public ValueCodeGenerator add(List<Delegate> additionalDelegates) {\r\n    Assert.notEmpty(additionalDelegates, \"AdditionalDelegates must not be empty\");\r\n    List<Delegate> allDelegates = new ArrayList<>(this.delegates);\r\n    allDelegates.addAll(additionalDelegates);\r\n    return new ValueCodeGenerator(allDelegates, this.generatedMethods);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#scoped(GeneratedMethods)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link ValueCodeGenerator} that is scoped for the specified\r\n * {@link GeneratedMethods}. This allows code generation to generate\r\n * additional methods if necessary, or perform some optimization in\r\n * case of visibility issues.\r\n * @param generatedMethods the generated methods to use\r\n * @return an instance scoped to the specified generated methods\r\n */\r\npublic ValueCodeGenerator scoped(GeneratedMethods generatedMethods) {\r\n    return new ValueCodeGenerator(this.delegates, generatedMethods);\r\n}",
    "comment": "\n\t * Return a {@link ValueCodeGenerator} that is scoped for the specified\n\t * {@link GeneratedMethods}. This allows code generation to generate\n\t * additional methods if necessary, or perform some optimization in\n\t * case of visibility issues.\n\t * @param generatedMethods the generated methods to use\n\t * @return an instance scoped to the specified generated methods\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#generateCode(Object)",
    "entityType": "method",
    "code": "/**\r\n * Generate the code that represents the specified {@code value}.\r\n * @param value the value to generate\r\n * @return the code that represents the specified value\r\n */\r\npublic CodeBlock generateCode(@Nullable Object value) {\r\n    if (value == null) {\r\n        return NULL_VALUE_CODE_BLOCK;\r\n    }\r\n    try {\r\n        for (Delegate delegate : this.delegates) {\r\n            CodeBlock code = delegate.generateCode(this, value);\r\n            if (code != null) {\r\n                return code;\r\n            }\r\n        }\r\n        throw new UnsupportedTypeValueCodeGenerationException(value);\r\n    } catch (Exception ex) {\r\n        throw new ValueCodeGenerationException(value, ex);\r\n    }\r\n}",
    "comment": "\n\t * Generate the code that represents the specified {@code value}.\n\t * @param value the value to generate\n\t * @return the code that represents the specified value\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGenerator#getGeneratedMethods()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link GeneratedMethods} that represents the scope\r\n * in which code generated by this instance will be added, or\r\n * {@code null} if no specific scope is set.\r\n * @return the generated methods to use for code generation\r\n */\r\n@Nullable\r\npublic GeneratedMethods getGeneratedMethods() {\r\n    return this.generatedMethods;\r\n}",
    "comment": "\n\t * Return the {@link GeneratedMethods} that represents the scope\n\t * in which code generated by this instance will be added, or\n\t * {@code null} if no specific scope is set.\n\t * @return the generated methods to use for code generation\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.Delegate",
    "entityType": "class",
    "code": "/**\r\n * Generate the code for the specified non-null {@code value}. If this\r\n * instance does not support the value, it should return {@code null} to\r\n * indicate so.\r\n * @param valueCodeGenerator the code generator to use for embedded values\r\n * @param value the value to generate\r\n * @return the code that represents the specified value or {@code null} if\r\n * the specified value is not supported.\r\n */\r\n@Nullable\r\nCodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value);",
    "comment": "\n\t * Strategy interface that can be used to implement code generation for a\n\t * particular value type.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.Delegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "/**\r\n * Generate the code for the specified non-null {@code value}. If this\r\n * instance does not support the value, it should return {@code null} to\r\n * indicate so.\r\n * @param valueCodeGenerator the code generator to use for embedded values\r\n * @param value the value to generate\r\n * @return the code that represents the specified value or {@code null} if\r\n * the specified value is not supported.\r\n */\r\n@Nullable\r\nCodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value);",
    "comment": "\n\t\t * Generate the code for the specified non-null {@code value}. If this\n\t\t * instance does not support the value, it should return {@code null} to\n\t\t * indicate so.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param value the value to generate\n\t\t * @return the code that represents the specified value or {@code null} if\n\t\t * the specified value is not supported.\n\t\t "
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests",
    "entityType": "class",
    "code": "private final AnnotationMetadata standardMetadata = AnnotationMetadata.introspect(AnnotatedSubclass.class);\nprivate final AnnotationMetadata asmMetadata;\nInheritedAnnotationsAnnotationMetadataTests() throws Exception {\r\n    MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();\r\n    MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(AnnotatedSubclass.class.getName());\r\n    this.asmMetadata = metadataReader.getAnnotationMetadata();\r\n}\n@Test\r\nvoid getAnnotationTypes() {\r\n    assertThat(standardMetadata.getAnnotationTypes()).containsExactlyInAnyOrder(NamedAnnotation3.class.getName(), InheritedComposedAnnotation.class.getName());\r\n    assertThat(asmMetadata.getAnnotationTypes()).containsExactly(NamedAnnotation3.class.getName());\r\n}\n@Test\r\nvoid hasAnnotation() {\r\n    assertThat(standardMetadata.hasAnnotation(InheritedComposedAnnotation.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasAnnotation(NamedAnnotation3.class.getName())).isTrue();\r\n    // true because @NamedAnnotation3 is also directly present\r\n    assertThat(asmMetadata.hasAnnotation(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(asmMetadata.hasAnnotation(InheritedComposedAnnotation.class.getName())).isFalse();\r\n}\n@Test\r\nvoid getMetaAnnotationTypes() {\r\n    Set<String> metaAnnotationTypes;\r\n    metaAnnotationTypes = standardMetadata.getMetaAnnotationTypes(InheritedComposedAnnotation.class.getName());\r\n    assertThat(metaAnnotationTypes).containsExactlyInAnyOrder(MetaAnnotation.class.getName(), NamedAnnotation1.class.getName(), NamedAnnotation2.class.getName(), NamedAnnotation3.class.getName());\r\n    metaAnnotationTypes = asmMetadata.getMetaAnnotationTypes(InheritedComposedAnnotation.class.getName());\r\n    assertThat(metaAnnotationTypes).isEmpty();\r\n}\n@Test\r\nvoid hasMetaAnnotation() {\r\n    assertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation1.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation2.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isTrue();\r\n    assertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation1.class.getName())).isFalse();\r\n    assertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation2.class.getName())).isFalse();\r\n    assertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation3.class.getName())).isFalse();\r\n    assertThat(asmMetadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\r\n}\n@Test\r\nvoid isAnnotated() {\r\n    assertThat(standardMetadata.isAnnotated(InheritedComposedAnnotation.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(NamedAnnotation1.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(NamedAnnotation2.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(MetaAnnotation.class.getName())).isTrue();\r\n    // true because @NamedAnnotation3 is also directly present\r\n    assertThat(asmMetadata.isAnnotated(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(asmMetadata.isAnnotated(InheritedComposedAnnotation.class.getName())).isFalse();\r\n    assertThat(asmMetadata.isAnnotated(NamedAnnotation1.class.getName())).isFalse();\r\n    assertThat(asmMetadata.isAnnotated(NamedAnnotation2.class.getName())).isFalse();\r\n    assertThat(asmMetadata.isAnnotated(MetaAnnotation.class.getName())).isFalse();\r\n}\n@Test\r\nvoid getAnnotationAttributes() {\r\n    Map<String, Object> annotationAttributes;\r\n    annotationAttributes = standardMetadata.getAnnotationAttributes(NamedAnnotation1.class.getName());\r\n    assertThat(annotationAttributes.get(\"name\")).isEqualTo(\"name 1\");\r\n    annotationAttributes = asmMetadata.getAnnotationAttributes(NamedAnnotation1.class.getName());\r\n    assertThat(annotationAttributes).isNull();\r\n}\n@Test\r\nvoid getAllAnnotationAttributes() {\r\n    MultiValueMap<String, Object> annotationAttributes;\r\n    annotationAttributes = standardMetadata.getAllAnnotationAttributes(NamedAnnotation3.class.getName());\r\n    assertThat(annotationAttributes).containsKey(\"name\");\r\n    assertThat(annotationAttributes.get(\"name\")).containsExactlyInAnyOrder(\"name 3\", \"local\");\r\n    annotationAttributes = asmMetadata.getAllAnnotationAttributes(NamedAnnotation1.class.getName());\r\n    assertThat(annotationAttributes).isNull();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.ANNOTATION_TYPE)\r\n@interface MetaAnnotation {\r\n}\n@MetaAnnotation\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NamedAnnotation1 {\r\n\r\n    String name() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NamedAnnotation2 {\r\n\r\n    String name() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NamedAnnotation3 {\r\n\r\n    String name() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@NamedAnnotation1(name = \"name 1\")\r\n@NamedAnnotation2(name = \"name 2\")\r\n@NamedAnnotation3(name = \"name 3\")\r\n@Inherited\r\n@interface InheritedComposedAnnotation {\r\n}\n@InheritedComposedAnnotation\r\nprivate static class AnnotatedClass {\r\n}\n@NamedAnnotation3(name = \"local\")\r\nprivate static class AnnotatedSubclass extends AnnotatedClass {\r\n}",
    "comment": "\n * Unit tests demonstrating that the reflection-based {@link StandardAnnotationMetadata}\n * supports {@link Inherited @Inherited} annotations; whereas, the ASM-based\n * {@code SimpleAnnotationMetadata} does not.\n *\n * @author Sam Brannen\n * @since 5.2.3\n * @see AnnotationMetadataTests\n "
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#getAnnotationTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationTypes() {\r\n    assertThat(standardMetadata.getAnnotationTypes()).containsExactlyInAnyOrder(NamedAnnotation3.class.getName(), InheritedComposedAnnotation.class.getName());\r\n    assertThat(asmMetadata.getAnnotationTypes()).containsExactly(NamedAnnotation3.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#hasAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotation() {\r\n    assertThat(standardMetadata.hasAnnotation(InheritedComposedAnnotation.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasAnnotation(NamedAnnotation3.class.getName())).isTrue();\r\n    // true because @NamedAnnotation3 is also directly present\r\n    assertThat(asmMetadata.hasAnnotation(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(asmMetadata.hasAnnotation(InheritedComposedAnnotation.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#getMetaAnnotationTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMetaAnnotationTypes() {\r\n    Set<String> metaAnnotationTypes;\r\n    metaAnnotationTypes = standardMetadata.getMetaAnnotationTypes(InheritedComposedAnnotation.class.getName());\r\n    assertThat(metaAnnotationTypes).containsExactlyInAnyOrder(MetaAnnotation.class.getName(), NamedAnnotation1.class.getName(), NamedAnnotation2.class.getName(), NamedAnnotation3.class.getName());\r\n    metaAnnotationTypes = asmMetadata.getMetaAnnotationTypes(InheritedComposedAnnotation.class.getName());\r\n    assertThat(metaAnnotationTypes).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#hasMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotation() {\r\n    assertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation1.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation2.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasMetaAnnotation(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(standardMetadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isTrue();\r\n    assertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation1.class.getName())).isFalse();\r\n    assertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation2.class.getName())).isFalse();\r\n    assertThat(asmMetadata.hasMetaAnnotation(NamedAnnotation3.class.getName())).isFalse();\r\n    assertThat(asmMetadata.hasMetaAnnotation(MetaAnnotation.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#isAnnotated()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotated() {\r\n    assertThat(standardMetadata.isAnnotated(InheritedComposedAnnotation.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(NamedAnnotation1.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(NamedAnnotation2.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(standardMetadata.isAnnotated(MetaAnnotation.class.getName())).isTrue();\r\n    // true because @NamedAnnotation3 is also directly present\r\n    assertThat(asmMetadata.isAnnotated(NamedAnnotation3.class.getName())).isTrue();\r\n    assertThat(asmMetadata.isAnnotated(InheritedComposedAnnotation.class.getName())).isFalse();\r\n    assertThat(asmMetadata.isAnnotated(NamedAnnotation1.class.getName())).isFalse();\r\n    assertThat(asmMetadata.isAnnotated(NamedAnnotation2.class.getName())).isFalse();\r\n    assertThat(asmMetadata.isAnnotated(MetaAnnotation.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#getAnnotationAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationAttributes() {\r\n    Map<String, Object> annotationAttributes;\r\n    annotationAttributes = standardMetadata.getAnnotationAttributes(NamedAnnotation1.class.getName());\r\n    assertThat(annotationAttributes.get(\"name\")).isEqualTo(\"name 1\");\r\n    annotationAttributes = asmMetadata.getAnnotationAttributes(NamedAnnotation1.class.getName());\r\n    assertThat(annotationAttributes).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.InheritedAnnotationsAnnotationMetadataTests#getAllAnnotationAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributes() {\r\n    MultiValueMap<String, Object> annotationAttributes;\r\n    annotationAttributes = standardMetadata.getAllAnnotationAttributes(NamedAnnotation3.class.getName());\r\n    assertThat(annotationAttributes).containsKey(\"name\");\r\n    assertThat(annotationAttributes.get(\"name\")).containsExactlyInAnyOrder(\"name 3\", \"local\");\r\n    annotationAttributes = asmMetadata.getAllAnnotationAttributes(NamedAnnotation1.class.getName());\r\n    assertThat(annotationAttributes).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.AnnotatedSubclass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeGeneratorDelegates",
    "entityType": "class",
    "code": "/**\r\n * A list of {@link Delegate} implementations for the following common value\r\n * types.\r\n * <ul>\r\n * <li>Primitive types</li>\r\n * <li>String</li>\r\n * <li>Charset</li>\r\n * <li>Enum</li>\r\n * <li>Class</li>\r\n * <li>{@link ResolvableType}</li>\r\n * <li>Array</li>\r\n * <li>List via {@code List.of}</li>\r\n * <li>Set via {@code Set.of} and support for {@link LinkedHashSet}</li>\r\n * <li>Map via {@code Map.of} or {@code Map.ofEntries}</li>\r\n * </ul>\r\n * Those implementations do not require the {@link ValueCodeGenerator} to be\r\n * {@linkplain ValueCodeGenerator#scoped(GeneratedMethods) scoped}.\r\n */\r\npublic static final List<Delegate> INSTANCES = List.of(new PrimitiveDelegate(), new StringDelegate(), new CharsetDelegate(), new EnumDelegate(), new ClassDelegate(), new ResolvableTypeDelegate(), new ArrayDelegate(), new ListDelegate(), new SetDelegate(), new MapDelegate());\n/**\r\n * Abstract {@link Delegate} for {@code Collection} types.\r\n * @param <T> type the collection type\r\n */\r\npublic abstract static class CollectionDelegate<T extends Collection<?>> implements Delegate {\r\n\r\n    private final Class<?> collectionType;\r\n\r\n    private final CodeBlock emptyResult;\r\n\r\n    protected CollectionDelegate(Class<?> collectionType, CodeBlock emptyResult) {\r\n        this.collectionType = collectionType;\r\n        this.emptyResult = emptyResult;\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\r\n        if (this.collectionType.isInstance(value)) {\r\n            T collection = (T) value;\r\n            if (collection.isEmpty()) {\r\n                return this.emptyResult;\r\n            }\r\n            return generateCollectionCode(valueCodeGenerator, collection);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, T collection) {\r\n        return generateCollectionOf(valueCodeGenerator, collection, this.collectionType);\r\n    }\r\n\r\n    protected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator, Collection<?> collection, Class<?> collectionType) {\r\n        Builder code = CodeBlock.builder();\r\n        code.add(\"$T.of(\", collectionType);\r\n        Iterator<?> iterator = collection.iterator();\r\n        while (iterator.hasNext()) {\r\n            Object element = iterator.next();\r\n            code.add(\"$L\", valueCodeGenerator.generateCode(element));\r\n            if (iterator.hasNext()) {\r\n                code.add(\", \");\r\n            }\r\n        }\r\n        code.add(\")\");\r\n        return code.build();\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link Map} types.\r\n */\r\npublic static class MapDelegate implements Delegate {\r\n\r\n    private static final CodeBlock EMPTY_RESULT = CodeBlock.of(\"$T.emptyMap()\", Collections.class);\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\r\n        if (value instanceof Map<?, ?> map) {\r\n            if (map.isEmpty()) {\r\n                return EMPTY_RESULT;\r\n            }\r\n            return generateMapCode(valueCodeGenerator, map);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Generate the code for a non-empty {@link Map}.\r\n     * @param valueCodeGenerator the code generator to use for embedded values\r\n     * @param map the value to generate\r\n     * @return the code that represents the specified map or {@code null} if\r\n     * the specified map is not supported.\r\n     */\r\n    @Nullable\r\n    protected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\r\n        map = orderForCodeConsistency(map);\r\n        boolean useOfEntries = map.size() > 10;\r\n        CodeBlock.Builder code = CodeBlock.builder();\r\n        code.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\r\n        Iterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            Entry<?, ?> entry = iterator.next();\r\n            CodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\r\n            CodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\r\n            if (!useOfEntries) {\r\n                code.add(\"$L, $L\", keyCode, valueCode);\r\n            } else {\r\n                code.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\r\n            }\r\n            if (iterator.hasNext()) {\r\n                code.add(\", \");\r\n            }\r\n        }\r\n        code.add(\")\");\r\n        return code.build();\r\n    }\r\n\r\n    private <K, V> Map<K, V> orderForCodeConsistency(Map<K, V> map) {\r\n        try {\r\n            return new TreeMap<>(map);\r\n        } catch (ClassCastException ex) {\r\n            // If elements are not comparable, just keep the original map\r\n            return map;\r\n        }\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@code primitive} types.\r\n */\r\nprivate static class PrimitiveDelegate implements Delegate {\r\n\r\n    private static final Map<Character, String> CHAR_ESCAPES = Map.of('\\b', \"\\\\b\", '\\t', \"\\\\t\", '\\n', \"\\\\n\", '\\f', \"\\\\f\", '\\r', \"\\\\r\", '\\\"', \"\\\"\", '\\'', \"\\\\'\", '\\\\', \"\\\\\\\\\");\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value instanceof Boolean || value instanceof Integer) {\r\n            return CodeBlock.of(\"$L\", value);\r\n        }\r\n        if (value instanceof Byte) {\r\n            return CodeBlock.of(\"(byte) $L\", value);\r\n        }\r\n        if (value instanceof Short) {\r\n            return CodeBlock.of(\"(short) $L\", value);\r\n        }\r\n        if (value instanceof Long) {\r\n            return CodeBlock.of(\"$LL\", value);\r\n        }\r\n        if (value instanceof Float) {\r\n            return CodeBlock.of(\"$LF\", value);\r\n        }\r\n        if (value instanceof Double) {\r\n            return CodeBlock.of(\"(double) $L\", value);\r\n        }\r\n        if (value instanceof Character character) {\r\n            return CodeBlock.of(\"'$L'\", escape(character));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private String escape(char ch) {\r\n        String escaped = CHAR_ESCAPES.get(ch);\r\n        if (escaped != null) {\r\n            return escaped;\r\n        }\r\n        return (!Character.isISOControl(ch)) ? Character.toString(ch) : String.format(\"\\\\u%04x\", (int) ch);\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link String} types.\r\n */\r\nprivate static class StringDelegate implements Delegate {\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value instanceof String) {\r\n            return CodeBlock.of(\"$S\", value);\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link Charset} types.\r\n */\r\nprivate static class CharsetDelegate implements Delegate {\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value instanceof Charset charset) {\r\n            return CodeBlock.of(\"$T.forName($S)\", Charset.class, charset.name());\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link Enum} types.\r\n */\r\nprivate static class EnumDelegate implements Delegate {\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value instanceof Enum<?> enumValue) {\r\n            return CodeBlock.of(\"$T.$L\", enumValue.getDeclaringClass(), enumValue.name());\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link Class} types.\r\n */\r\nprivate static class ClassDelegate implements Delegate {\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value instanceof Class<?> clazz) {\r\n            return CodeBlock.of(\"$T.class\", ClassUtils.getUserClass(clazz));\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link ResolvableType} types.\r\n */\r\nprivate static class ResolvableTypeDelegate implements Delegate {\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value instanceof ResolvableType resolvableType) {\r\n            return generateCode(resolvableType, false);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static CodeBlock generateCode(ResolvableType resolvableType, boolean allowClassResult) {\r\n        if (ResolvableType.NONE.equals(resolvableType)) {\r\n            return CodeBlock.of(\"$T.NONE\", ResolvableType.class);\r\n        }\r\n        Class<?> type = ClassUtils.getUserClass(resolvableType.toClass());\r\n        if (resolvableType.hasGenerics() && resolvableType.hasResolvableGenerics()) {\r\n            return generateCodeWithGenerics(resolvableType, type);\r\n        }\r\n        if (allowClassResult) {\r\n            return CodeBlock.of(\"$T.class\", type);\r\n        }\r\n        return CodeBlock.of(\"$T.forClass($T.class)\", ResolvableType.class, type);\r\n    }\r\n\r\n    private static CodeBlock generateCodeWithGenerics(ResolvableType target, Class<?> type) {\r\n        ResolvableType[] generics = target.getGenerics();\r\n        boolean hasNoNestedGenerics = Arrays.stream(generics).noneMatch(ResolvableType::hasGenerics);\r\n        CodeBlock.Builder code = CodeBlock.builder();\r\n        code.add(\"$T.forClassWithGenerics($T.class\", ResolvableType.class, type);\r\n        for (ResolvableType generic : generics) {\r\n            code.add(\", $L\", generateCode(generic, hasNoNestedGenerics));\r\n        }\r\n        code.add(\")\");\r\n        return code.build();\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@code array} types.\r\n */\r\nprivate static class ArrayDelegate implements Delegate {\r\n\r\n    @Override\r\n    @Nullable\r\n    public CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n        if (value.getClass().isArray()) {\r\n            Stream<CodeBlock> elements = Arrays.stream(ObjectUtils.toObjectArray(value)).map(codeGenerator::generateCode);\r\n            CodeBlock.Builder code = CodeBlock.builder();\r\n            code.add(\"new $T {\", value.getClass());\r\n            code.add(elements.collect(CodeBlock.joining(\", \")));\r\n            code.add(\"}\");\r\n            return code.build();\r\n        }\r\n        return null;\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link List} types.\r\n */\r\nprivate static class ListDelegate extends CollectionDelegate<List<?>> {\r\n\r\n    ListDelegate() {\r\n        super(List.class, CodeBlock.of(\"$T.emptyList()\", Collections.class));\r\n    }\r\n}\n/**\r\n * {@link Delegate} for {@link Set} types.\r\n */\r\nprivate static class SetDelegate extends CollectionDelegate<Set<?>> {\r\n\r\n    SetDelegate() {\r\n        super(Set.class, CodeBlock.of(\"$T.emptySet()\", Collections.class));\r\n    }\r\n\r\n    @Override\r\n    protected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection) {\r\n        if (collection instanceof LinkedHashSet) {\r\n            return CodeBlock.of(\"new $T($L)\", LinkedHashSet.class, generateCollectionOf(valueCodeGenerator, collection, List.class));\r\n        }\r\n        return super.generateCollectionCode(valueCodeGenerator, orderForCodeConsistency(collection));\r\n    }\r\n\r\n    private Set<?> orderForCodeConsistency(Set<?> set) {\r\n        try {\r\n            return new TreeSet<Object>(set);\r\n        } catch (ClassCastException ex) {\r\n            // If elements are not comparable, just keep the original set\r\n            return set;\r\n        }\r\n    }\r\n}",
    "comment": "\n * Code generator {@link Delegate} for well known value types.\n *\n * @author Stephane Nicoll\n * @since 6.1.2\n "
  },
  {
    "entityId": "org.springframework.aot.generate.CollectionDelegate",
    "entityType": "class",
    "code": "private final Class<?> collectionType;\nprivate final CodeBlock emptyResult;\nprotected CollectionDelegate(Class<?> collectionType, CodeBlock emptyResult) {\r\n    this.collectionType = collectionType;\r\n    this.emptyResult = emptyResult;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\r\n    if (this.collectionType.isInstance(value)) {\r\n        T collection = (T) value;\r\n        if (collection.isEmpty()) {\r\n            return this.emptyResult;\r\n        }\r\n        return generateCollectionCode(valueCodeGenerator, collection);\r\n    }\r\n    return null;\r\n}\nprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, T collection) {\r\n    return generateCollectionOf(valueCodeGenerator, collection, this.collectionType);\r\n}\nprotected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator, Collection<?> collection, Class<?> collectionType) {\r\n    Builder code = CodeBlock.builder();\r\n    code.add(\"$T.of(\", collectionType);\r\n    Iterator<?> iterator = collection.iterator();\r\n    while (iterator.hasNext()) {\r\n        Object element = iterator.next();\r\n        code.add(\"$L\", valueCodeGenerator.generateCode(element));\r\n        if (iterator.hasNext()) {\r\n            code.add(\", \");\r\n        }\r\n    }\r\n    code.add(\")\");\r\n    return code.build();\r\n}",
    "comment": "\n\t * Abstract {@link Delegate} for {@code Collection} types.\n\t * @param <T> type the collection type\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.CollectionDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\r\n    if (this.collectionType.isInstance(value)) {\r\n        T collection = (T) value;\r\n        if (collection.isEmpty()) {\r\n            return this.emptyResult;\r\n        }\r\n        return generateCollectionCode(valueCodeGenerator, collection);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.CollectionDelegate#generateCollectionCode(ValueCodeGenerator,T)",
    "entityType": "method",
    "code": "protected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, T collection) {\r\n    return generateCollectionOf(valueCodeGenerator, collection, this.collectionType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.CollectionDelegate#generateCollectionOf(ValueCodeGenerator,Collection<?>,Class<?>)",
    "entityType": "method",
    "code": "protected final CodeBlock generateCollectionOf(ValueCodeGenerator valueCodeGenerator, Collection<?> collection, Class<?> collectionType) {\r\n    Builder code = CodeBlock.builder();\r\n    code.add(\"$T.of(\", collectionType);\r\n    Iterator<?> iterator = collection.iterator();\r\n    while (iterator.hasNext()) {\r\n        Object element = iterator.next();\r\n        code.add(\"$L\", valueCodeGenerator.generateCode(element));\r\n        if (iterator.hasNext()) {\r\n            code.add(\", \");\r\n        }\r\n    }\r\n    code.add(\")\");\r\n    return code.build();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MapDelegate",
    "entityType": "class",
    "code": "private static final CodeBlock EMPTY_RESULT = CodeBlock.of(\"$T.emptyMap()\", Collections.class);\n@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\r\n    if (value instanceof Map<?, ?> map) {\r\n        if (map.isEmpty()) {\r\n            return EMPTY_RESULT;\r\n        }\r\n        return generateMapCode(valueCodeGenerator, map);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Generate the code for a non-empty {@link Map}.\r\n * @param valueCodeGenerator the code generator to use for embedded values\r\n * @param map the value to generate\r\n * @return the code that represents the specified map or {@code null} if\r\n * the specified map is not supported.\r\n */\r\n@Nullable\r\nprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\r\n    map = orderForCodeConsistency(map);\r\n    boolean useOfEntries = map.size() > 10;\r\n    CodeBlock.Builder code = CodeBlock.builder();\r\n    code.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\r\n    Iterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        Entry<?, ?> entry = iterator.next();\r\n        CodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\r\n        CodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\r\n        if (!useOfEntries) {\r\n            code.add(\"$L, $L\", keyCode, valueCode);\r\n        } else {\r\n            code.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\r\n        }\r\n        if (iterator.hasNext()) {\r\n            code.add(\", \");\r\n        }\r\n    }\r\n    code.add(\")\");\r\n    return code.build();\r\n}\nprivate <K, V> Map<K, V> orderForCodeConsistency(Map<K, V> map) {\r\n    try {\r\n        return new TreeMap<>(map);\r\n    } catch (ClassCastException ex) {\r\n        // If elements are not comparable, just keep the original map\r\n        return map;\r\n    }\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link Map} types.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadataTests",
    "entityType": "class",
    "code": "@Override\r\n@SuppressWarnings(\"deprecation\")\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    return new StandardAnnotationMetadata(source);\r\n}",
    "comment": "\n * Tests for {@link StandardAnnotationMetadata}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.type.StandardAnnotationMetadataTests#get(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"deprecation\")\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    return new StandardAnnotationMetadata(source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MapDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator valueCodeGenerator, Object value) {\r\n    if (value instanceof Map<?, ?> map) {\r\n        if (map.isEmpty()) {\r\n            return EMPTY_RESULT;\r\n        }\r\n        return generateMapCode(valueCodeGenerator, map);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MapDelegate#generateMapCode(ValueCodeGenerator,Map<?,?>)",
    "entityType": "method",
    "code": "/**\r\n * Generate the code for a non-empty {@link Map}.\r\n * @param valueCodeGenerator the code generator to use for embedded values\r\n * @param map the value to generate\r\n * @return the code that represents the specified map or {@code null} if\r\n * the specified map is not supported.\r\n */\r\n@Nullable\r\nprotected CodeBlock generateMapCode(ValueCodeGenerator valueCodeGenerator, Map<?, ?> map) {\r\n    map = orderForCodeConsistency(map);\r\n    boolean useOfEntries = map.size() > 10;\r\n    CodeBlock.Builder code = CodeBlock.builder();\r\n    code.add(\"$T\" + ((!useOfEntries) ? \".of(\" : \".ofEntries(\"), Map.class);\r\n    Iterator<? extends Entry<?, ?>> iterator = map.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        Entry<?, ?> entry = iterator.next();\r\n        CodeBlock keyCode = valueCodeGenerator.generateCode(entry.getKey());\r\n        CodeBlock valueCode = valueCodeGenerator.generateCode(entry.getValue());\r\n        if (!useOfEntries) {\r\n            code.add(\"$L, $L\", keyCode, valueCode);\r\n        } else {\r\n            code.add(\"$T.entry($L,$L)\", Map.class, keyCode, valueCode);\r\n        }\r\n        if (iterator.hasNext()) {\r\n            code.add(\", \");\r\n        }\r\n    }\r\n    code.add(\")\");\r\n    return code.build();\r\n}",
    "comment": "\n\t\t * Generate the code for a non-empty {@link Map}.\n\t\t * @param valueCodeGenerator the code generator to use for embedded values\n\t\t * @param map the value to generate\n\t\t * @return the code that represents the specified map or {@code null} if\n\t\t * the specified map is not supported.\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.generate.MapDelegate#orderForCodeConsistency(Map<K,V>)",
    "entityType": "method",
    "code": "private <K, V> Map<K, V> orderForCodeConsistency(Map<K, V> map) {\r\n    try {\r\n        return new TreeMap<>(map);\r\n    } catch (ClassCastException ex) {\r\n        // If elements are not comparable, just keep the original map\r\n        return map;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.PrimitiveDelegate",
    "entityType": "class",
    "code": "private static final Map<Character, String> CHAR_ESCAPES = Map.of('\\b', \"\\\\b\", '\\t', \"\\\\t\", '\\n', \"\\\\n\", '\\f', \"\\\\f\", '\\r', \"\\\\r\", '\\\"', \"\\\"\", '\\'', \"\\\\'\", '\\\\', \"\\\\\\\\\");\n@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Boolean || value instanceof Integer) {\r\n        return CodeBlock.of(\"$L\", value);\r\n    }\r\n    if (value instanceof Byte) {\r\n        return CodeBlock.of(\"(byte) $L\", value);\r\n    }\r\n    if (value instanceof Short) {\r\n        return CodeBlock.of(\"(short) $L\", value);\r\n    }\r\n    if (value instanceof Long) {\r\n        return CodeBlock.of(\"$LL\", value);\r\n    }\r\n    if (value instanceof Float) {\r\n        return CodeBlock.of(\"$LF\", value);\r\n    }\r\n    if (value instanceof Double) {\r\n        return CodeBlock.of(\"(double) $L\", value);\r\n    }\r\n    if (value instanceof Character character) {\r\n        return CodeBlock.of(\"'$L'\", escape(character));\r\n    }\r\n    return null;\r\n}\nprivate String escape(char ch) {\r\n    String escaped = CHAR_ESCAPES.get(ch);\r\n    if (escaped != null) {\r\n        return escaped;\r\n    }\r\n    return (!Character.isISOControl(ch)) ? Character.toString(ch) : String.format(\"\\\\u%04x\", (int) ch);\r\n}",
    "comment": "\n\t * {@link Delegate} for {@code primitive} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.PrimitiveDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Boolean || value instanceof Integer) {\r\n        return CodeBlock.of(\"$L\", value);\r\n    }\r\n    if (value instanceof Byte) {\r\n        return CodeBlock.of(\"(byte) $L\", value);\r\n    }\r\n    if (value instanceof Short) {\r\n        return CodeBlock.of(\"(short) $L\", value);\r\n    }\r\n    if (value instanceof Long) {\r\n        return CodeBlock.of(\"$LL\", value);\r\n    }\r\n    if (value instanceof Float) {\r\n        return CodeBlock.of(\"$LF\", value);\r\n    }\r\n    if (value instanceof Double) {\r\n        return CodeBlock.of(\"(double) $L\", value);\r\n    }\r\n    if (value instanceof Character character) {\r\n        return CodeBlock.of(\"'$L'\", escape(character));\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.PrimitiveDelegate#escape(char)",
    "entityType": "method",
    "code": "private String escape(char ch) {\r\n    String escaped = CHAR_ESCAPES.get(ch);\r\n    if (escaped != null) {\r\n        return escaped;\r\n    }\r\n    return (!Character.isISOControl(ch)) ? Character.toString(ch) : String.format(\"\\\\u%04x\", (int) ch);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.StringDelegate",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof String) {\r\n        return CodeBlock.of(\"$S\", value);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link String} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.StringDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof String) {\r\n        return CodeBlock.of(\"$S\", value);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.CharsetDelegate",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Charset charset) {\r\n        return CodeBlock.of(\"$T.forName($S)\", Charset.class, charset.name());\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link Charset} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.CharsetDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Charset charset) {\r\n        return CodeBlock.of(\"$T.forName($S)\", Charset.class, charset.name());\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.EnumDelegate",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Enum<?> enumValue) {\r\n        return CodeBlock.of(\"$T.$L\", enumValue.getDeclaringClass(), enumValue.name());\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link Enum} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.EnumDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Enum<?> enumValue) {\r\n        return CodeBlock.of(\"$T.$L\", enumValue.getDeclaringClass(), enumValue.name());\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ClassDelegate",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Class<?> clazz) {\r\n        return CodeBlock.of(\"$T.class\", ClassUtils.getUserClass(clazz));\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link Class} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ClassDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof Class<?> clazz) {\r\n        return CodeBlock.of(\"$T.class\", ClassUtils.getUserClass(clazz));\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeDelegate",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof ResolvableType resolvableType) {\r\n        return generateCode(resolvableType, false);\r\n    }\r\n    return null;\r\n}\nprivate static CodeBlock generateCode(ResolvableType resolvableType, boolean allowClassResult) {\r\n    if (ResolvableType.NONE.equals(resolvableType)) {\r\n        return CodeBlock.of(\"$T.NONE\", ResolvableType.class);\r\n    }\r\n    Class<?> type = ClassUtils.getUserClass(resolvableType.toClass());\r\n    if (resolvableType.hasGenerics() && resolvableType.hasResolvableGenerics()) {\r\n        return generateCodeWithGenerics(resolvableType, type);\r\n    }\r\n    if (allowClassResult) {\r\n        return CodeBlock.of(\"$T.class\", type);\r\n    }\r\n    return CodeBlock.of(\"$T.forClass($T.class)\", ResolvableType.class, type);\r\n}\nprivate static CodeBlock generateCodeWithGenerics(ResolvableType target, Class<?> type) {\r\n    ResolvableType[] generics = target.getGenerics();\r\n    boolean hasNoNestedGenerics = Arrays.stream(generics).noneMatch(ResolvableType::hasGenerics);\r\n    CodeBlock.Builder code = CodeBlock.builder();\r\n    code.add(\"$T.forClassWithGenerics($T.class\", ResolvableType.class, type);\r\n    for (ResolvableType generic : generics) {\r\n        code.add(\", $L\", generateCode(generic, hasNoNestedGenerics));\r\n    }\r\n    code.add(\")\");\r\n    return code.build();\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link ResolvableType} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value instanceof ResolvableType resolvableType) {\r\n        return generateCode(resolvableType, false);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeDelegate#generateCode(ResolvableType,boolean)",
    "entityType": "method",
    "code": "private static CodeBlock generateCode(ResolvableType resolvableType, boolean allowClassResult) {\r\n    if (ResolvableType.NONE.equals(resolvableType)) {\r\n        return CodeBlock.of(\"$T.NONE\", ResolvableType.class);\r\n    }\r\n    Class<?> type = ClassUtils.getUserClass(resolvableType.toClass());\r\n    if (resolvableType.hasGenerics() && resolvableType.hasResolvableGenerics()) {\r\n        return generateCodeWithGenerics(resolvableType, type);\r\n    }\r\n    if (allowClassResult) {\r\n        return CodeBlock.of(\"$T.class\", type);\r\n    }\r\n    return CodeBlock.of(\"$T.forClass($T.class)\", ResolvableType.class, type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeDelegate#generateCodeWithGenerics(ResolvableType,Class<?>)",
    "entityType": "method",
    "code": "private static CodeBlock generateCodeWithGenerics(ResolvableType target, Class<?> type) {\r\n    ResolvableType[] generics = target.getGenerics();\r\n    boolean hasNoNestedGenerics = Arrays.stream(generics).noneMatch(ResolvableType::hasGenerics);\r\n    CodeBlock.Builder code = CodeBlock.builder();\r\n    code.add(\"$T.forClassWithGenerics($T.class\", ResolvableType.class, type);\r\n    for (ResolvableType generic : generics) {\r\n        code.add(\", $L\", generateCode(generic, hasNoNestedGenerics));\r\n    }\r\n    code.add(\")\");\r\n    return code.build();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ArrayDelegate",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value.getClass().isArray()) {\r\n        Stream<CodeBlock> elements = Arrays.stream(ObjectUtils.toObjectArray(value)).map(codeGenerator::generateCode);\r\n        CodeBlock.Builder code = CodeBlock.builder();\r\n        code.add(\"new $T {\", value.getClass());\r\n        code.add(elements.collect(CodeBlock.joining(\", \")));\r\n        code.add(\"}\");\r\n        return code.build();\r\n    }\r\n    return null;\r\n}",
    "comment": "\n\t * {@link Delegate} for {@code array} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.ArrayDelegate#generateCode(ValueCodeGenerator,Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic CodeBlock generateCode(ValueCodeGenerator codeGenerator, Object value) {\r\n    if (value.getClass().isArray()) {\r\n        Stream<CodeBlock> elements = Arrays.stream(ObjectUtils.toObjectArray(value)).map(codeGenerator::generateCode);\r\n        CodeBlock.Builder code = CodeBlock.builder();\r\n        code.add(\"new $T {\", value.getClass());\r\n        code.add(elements.collect(CodeBlock.joining(\", \")));\r\n        code.add(\"}\");\r\n        return code.build();\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ListDelegate",
    "entityType": "class",
    "code": "ListDelegate() {\r\n    super(List.class, CodeBlock.of(\"$T.emptyList()\", Collections.class));\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link List} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.SetDelegate",
    "entityType": "class",
    "code": "SetDelegate() {\r\n    super(Set.class, CodeBlock.of(\"$T.emptySet()\", Collections.class));\r\n}\n@Override\r\nprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection) {\r\n    if (collection instanceof LinkedHashSet) {\r\n        return CodeBlock.of(\"new $T($L)\", LinkedHashSet.class, generateCollectionOf(valueCodeGenerator, collection, List.class));\r\n    }\r\n    return super.generateCollectionCode(valueCodeGenerator, orderForCodeConsistency(collection));\r\n}\nprivate Set<?> orderForCodeConsistency(Set<?> set) {\r\n    try {\r\n        return new TreeSet<Object>(set);\r\n    } catch (ClassCastException ex) {\r\n        // If elements are not comparable, just keep the original set\r\n        return set;\r\n    }\r\n}",
    "comment": "\n\t * {@link Delegate} for {@link Set} types.\n\t "
  },
  {
    "entityId": "org.springframework.aot.generate.SetDelegate#generateCollectionCode(ValueCodeGenerator,Set<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected CodeBlock generateCollectionCode(ValueCodeGenerator valueCodeGenerator, Set<?> collection) {\r\n    if (collection instanceof LinkedHashSet) {\r\n        return CodeBlock.of(\"new $T($L)\", LinkedHashSet.class, generateCollectionOf(valueCodeGenerator, collection, List.class));\r\n    }\r\n    return super.generateCollectionCode(valueCodeGenerator, orderForCodeConsistency(collection));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SetDelegate#orderForCodeConsistency(Set<?>)",
    "entityType": "method",
    "code": "private Set<?> orderForCodeConsistency(Set<?> set) {\r\n    try {\r\n        return new TreeSet<Object>(set);\r\n    } catch (ClassCastException ex) {\r\n        // If elements are not comparable, just keep the original set\r\n        return set;\r\n    }\r\n}",
    "comment": ""
  }
]