[
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getValue(int,Class<T>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate <T> T getValue(int attributeIndex, Class<T> type) {\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    Object value = getValue(attributeIndex, true, false);\r\n    if (value == null) {\r\n        value = attribute.getDefaultValue();\r\n    }\r\n    return adapt(attribute, value, type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getValue(int,boolean,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Object getValue(int attributeIndex, boolean useConventionMapping, boolean forMirrorResolution) {\r\n    AnnotationTypeMapping mapping = this.mapping;\r\n    if (this.useMergedValues) {\r\n        int mappedIndex = this.mapping.getAliasMapping(attributeIndex);\r\n        if (mappedIndex == -1 && useConventionMapping) {\r\n            mappedIndex = this.mapping.getConventionMapping(attributeIndex);\r\n        }\r\n        if (mappedIndex != -1) {\r\n            mapping = mapping.getRoot();\r\n            attributeIndex = mappedIndex;\r\n        }\r\n    }\r\n    if (!forMirrorResolution) {\r\n        attributeIndex = (mapping.getDistance() != 0 ? this.resolvedMirrors : this.resolvedRootMirrors)[attributeIndex];\r\n    }\r\n    if (attributeIndex == -1) {\r\n        return null;\r\n    }\r\n    if (mapping.getDistance() == 0) {\r\n        Method attribute = mapping.getAttributes().get(attributeIndex);\r\n        Object result = this.valueExtractor.extract(attribute, this.rootAttributes);\r\n        return (result != null ? result : attribute.getDefaultValue());\r\n    }\r\n    return getValueFromMetaAnnotation(attributeIndex, forMirrorResolution);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getValueFromMetaAnnotation(int,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Object getValueFromMetaAnnotation(int attributeIndex, boolean forMirrorResolution) {\r\n    Object value = null;\r\n    if (this.useMergedValues || forMirrorResolution) {\r\n        value = this.mapping.getMappedAnnotationValue(attributeIndex, forMirrorResolution);\r\n    }\r\n    if (value == null) {\r\n        Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n        value = AnnotationUtils.invokeAnnotationMethod(attribute, this.mapping.getAnnotation());\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getValueForMirrorResolution(Method,Object)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Object getValueForMirrorResolution(Method attribute, @Nullable Object annotation) {\r\n    int attributeIndex = this.mapping.getAttributes().indexOf(attribute);\r\n    boolean valueAttribute = VALUE.equals(attribute.getName());\r\n    return getValue(attributeIndex, !valueAttribute, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#adapt(Method,Object,Class<T>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate <T> T adapt(Method attribute, @Nullable Object value, Class<T> type) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    value = adaptForAttribute(attribute, value);\r\n    type = getAdaptType(attribute, type);\r\n    if (value instanceof Class<?> clazz && type == String.class) {\r\n        value = clazz.getName();\r\n    } else if (value instanceof String str && type == Class.class) {\r\n        value = ClassUtils.resolveClassName(str, getClassLoader());\r\n    } else if (value instanceof Class<?>[] classes && type == String[].class) {\r\n        String[] names = new String[classes.length];\r\n        for (int i = 0; i < classes.length; i++) {\r\n            names[i] = classes[i].getName();\r\n        }\r\n        value = names;\r\n    } else if (value instanceof String[] names && type == Class[].class) {\r\n        Class<?>[] classes = new Class<?>[names.length];\r\n        for (int i = 0; i < names.length; i++) {\r\n            classes[i] = ClassUtils.resolveClassName(names[i], getClassLoader());\r\n        }\r\n        value = classes;\r\n    } else if (value instanceof MergedAnnotation<?> annotation && type.isAnnotation()) {\r\n        value = annotation.synthesize();\r\n    } else if (value instanceof MergedAnnotation<?>[] annotations && type.isArray() && type.componentType().isAnnotation()) {\r\n        Object array = Array.newInstance(type.componentType(), annotations.length);\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            Array.set(array, i, annotations[i].synthesize());\r\n        }\r\n        value = array;\r\n    }\r\n    if (!type.isInstance(value)) {\r\n        throw new IllegalArgumentException(\"Unable to adapt value of type \" + value.getClass().getName() + \" to \" + type.getName());\r\n    }\r\n    return (T) value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#adaptForAttribute(Method,Object)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nprivate Object adaptForAttribute(Method attribute, Object value) {\r\n    Class<?> attributeType = ClassUtils.resolvePrimitiveIfNecessary(attribute.getReturnType());\r\n    if (attributeType.isArray() && !value.getClass().isArray()) {\r\n        Object array = Array.newInstance(value.getClass(), 1);\r\n        Array.set(array, 0, value);\r\n        return adaptForAttribute(attribute, array);\r\n    }\r\n    if (attributeType.isAnnotation()) {\r\n        return adaptToMergedAnnotation(value, (Class<? extends Annotation>) attributeType);\r\n    }\r\n    if (attributeType.isArray() && attributeType.componentType().isAnnotation()) {\r\n        MergedAnnotation<?>[] result = new MergedAnnotation<?>[Array.getLength(value)];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = adaptToMergedAnnotation(Array.get(value, i), (Class<? extends Annotation>) attributeType.componentType());\r\n        }\r\n        return result;\r\n    }\r\n    if ((attributeType == Class.class && value instanceof String) || (attributeType == Class[].class && value instanceof String[]) || (attributeType == String.class && value instanceof Class) || (attributeType == String[].class && value instanceof Class[])) {\r\n        return value;\r\n    }\r\n    if (attributeType.isArray() && isEmptyObjectArray(value)) {\r\n        return emptyArray(attributeType.componentType());\r\n    }\r\n    if (!attributeType.isInstance(value)) {\r\n        throw new IllegalStateException(\"Attribute '\" + attribute.getName() + \"' in annotation \" + getType().getName() + \" should be compatible with \" + attributeType.getName() + \" but a \" + value.getClass().getName() + \" value was returned\");\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#isEmptyObjectArray(Object)",
    "entityType": "method",
    "code": "private boolean isEmptyObjectArray(Object value) {\r\n    return (value instanceof Object[] objects && objects.length == 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#emptyArray(Class<?>)",
    "entityType": "method",
    "code": "private Object emptyArray(Class<?> componentType) {\r\n    Object result = EMPTY_ARRAYS.get(componentType);\r\n    if (result == null) {\r\n        result = Array.newInstance(componentType, 0);\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#adaptToMergedAnnotation(Object,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private MergedAnnotation<?> adaptToMergedAnnotation(Object value, Class<? extends Annotation> annotationType) {\r\n    if (value instanceof MergedAnnotation<?> mergedAnnotation) {\r\n        return mergedAnnotation;\r\n    }\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\r\n    return new TypeMappedAnnotation<>(mapping, null, this.source, value, getValueExtractor(value), this.aggregateIndex);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getValueExtractor(Object)",
    "entityType": "method",
    "code": "private ValueExtractor getValueExtractor(Object value) {\r\n    if (value instanceof Annotation) {\r\n        return AnnotationUtils::invokeAnnotationMethod;\r\n    }\r\n    if (value instanceof Map) {\r\n        return TypeMappedAnnotation::extractFromMap;\r\n    }\r\n    return this.valueExtractor;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getAdaptType(Method,Class<T>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nprivate <T> Class<T> getAdaptType(Method attribute, Class<T> type) {\r\n    if (type != Object.class) {\r\n        return type;\r\n    }\r\n    Class<?> attributeType = attribute.getReturnType();\r\n    if (attributeType.isAnnotation()) {\r\n        return (Class<T>) MergedAnnotation.class;\r\n    }\r\n    if (attributeType.isArray() && attributeType.componentType().isAnnotation()) {\r\n        return (Class<T>) MergedAnnotation[].class;\r\n    }\r\n    return (Class<T>) ClassUtils.resolvePrimitiveIfNecessary(attributeType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getAttributeIndex(String,boolean)",
    "entityType": "method",
    "code": "private int getAttributeIndex(String attributeName, boolean required) {\r\n    Assert.hasText(attributeName, \"Attribute name must not be null\");\r\n    int attributeIndex = (isFiltered(attributeName) ? -1 : this.mapping.getAttributes().indexOf(attributeName));\r\n    if (attributeIndex == -1 && required) {\r\n        throw new NoSuchElementException(\"No attribute named '\" + attributeName + \"' present in merged annotation \" + getType().getName());\r\n    }\r\n    return attributeIndex;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#isFiltered(String)",
    "entityType": "method",
    "code": "private boolean isFiltered(String attributeName) {\r\n    if (this.attributeFilter != null) {\r\n        return !this.attributeFilter.test(attributeName);\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getClassLoader()",
    "entityType": "method",
    "code": "@Nullable\r\nprivate ClassLoader getClassLoader() {\r\n    if (this.classLoader != null) {\r\n        return this.classLoader;\r\n    }\r\n    if (this.source != null) {\r\n        if (this.source instanceof Class<?> clazz) {\r\n            return clazz.getClassLoader();\r\n        }\r\n        if (this.source instanceof Member member) {\r\n            member.getDeclaringClass().getClassLoader();\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#from(Object,A)",
    "entityType": "method",
    "code": "static <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\r\n    Assert.notNull(annotation, \"Annotation must not be null\");\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType());\r\n    return new TypeMappedAnnotation<>(mappings.get(0), null, source, annotation, AnnotationUtils::invokeAnnotationMethod, 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#of(ClassLoader,Object,Class<A>,Map<String,?>)",
    "entityType": "method",
    "code": "static <A extends Annotation> MergedAnnotation<A> of(@Nullable ClassLoader classLoader, @Nullable Object source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    Assert.notNull(annotationType, \"Annotation type must not be null\");\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotationType);\r\n    return new TypeMappedAnnotation<>(mappings.get(0), classLoader, source, attributes, TypeMappedAnnotation::extractFromMap, 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#createIfPossible(AnnotationTypeMapping,MergedAnnotation<?>,IntrospectionFailureLogger)",
    "entityType": "method",
    "code": "@Nullable\r\nstatic <A extends Annotation> TypeMappedAnnotation<A> createIfPossible(AnnotationTypeMapping mapping, MergedAnnotation<?> annotation, IntrospectionFailureLogger logger) {\r\n    if (annotation instanceof TypeMappedAnnotation<?> typeMappedAnnotation) {\r\n        return createIfPossible(mapping, typeMappedAnnotation.source, typeMappedAnnotation.rootAttributes, typeMappedAnnotation.valueExtractor, typeMappedAnnotation.aggregateIndex, logger);\r\n    }\r\n    return createIfPossible(mapping, annotation.getSource(), annotation.synthesize(), annotation.getAggregateIndex(), logger);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#createIfPossible(AnnotationTypeMapping,Object,Annotation,int,IntrospectionFailureLogger)",
    "entityType": "method",
    "code": "@Nullable\r\nstatic <A extends Annotation> TypeMappedAnnotation<A> createIfPossible(AnnotationTypeMapping mapping, @Nullable Object source, Annotation annotation, int aggregateIndex, IntrospectionFailureLogger logger) {\r\n    return createIfPossible(mapping, source, annotation, AnnotationUtils::invokeAnnotationMethod, aggregateIndex, logger);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#createIfPossible(AnnotationTypeMapping,Object,Object,ValueExtractor,int,IntrospectionFailureLogger)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static <A extends Annotation> TypeMappedAnnotation<A> createIfPossible(AnnotationTypeMapping mapping, @Nullable Object source, @Nullable Object rootAttribute, ValueExtractor valueExtractor, int aggregateIndex, IntrospectionFailureLogger logger) {\r\n    try {\r\n        return new TypeMappedAnnotation<>(mapping, null, source, rootAttribute, valueExtractor, aggregateIndex);\r\n    } catch (Exception ex) {\r\n        AnnotationUtils.rethrowAnnotationConfigurationException(ex);\r\n        if (logger.isEnabled()) {\r\n            String type = mapping.getAnnotationType().getName();\r\n            String item = (mapping.getDistance() == 0 ? \"annotation \" + type : \"meta-annotation \" + type + \" from \" + mapping.getRoot().getAnnotationType().getName());\r\n            logger.log(\"Failed to introspect \" + item, source, ex);\r\n        }\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#extractFromMap(Method,Object)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nstatic Object extractFromMap(Method attribute, @Nullable Object map) {\r\n    return (map != null ? ((Map<String, ?>) map).get(attribute.getName()) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations",
    "entityType": "class",
    "code": "/**\r\n * Shared instance that can be used when there are no annotations.\r\n */\r\nstatic final MergedAnnotations NONE = new TypeMappedAnnotations(null, new Annotation[0], RepeatableContainers.none(), AnnotationFilter.ALL);\n@Nullable\r\nprivate final Object source;\n@Nullable\r\nprivate final AnnotatedElement element;\n@Nullable\r\nprivate final SearchStrategy searchStrategy;\nprivate final Predicate<Class<?>> searchEnclosingClass;\nprivate final Annotation @Nullable [] annotations;\nprivate final RepeatableContainers repeatableContainers;\nprivate final AnnotationFilter annotationFilter;\n@Nullable\r\nprivate volatile List<Aggregate> aggregates;\nprivate TypeMappedAnnotations(AnnotatedElement element, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    this.source = element;\r\n    this.element = element;\r\n    this.searchStrategy = searchStrategy;\r\n    this.searchEnclosingClass = searchEnclosingClass;\r\n    this.annotations = null;\r\n    this.repeatableContainers = repeatableContainers;\r\n    this.annotationFilter = annotationFilter;\r\n}\nprivate TypeMappedAnnotations(@Nullable Object source, Annotation[] annotations, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    this.source = source;\r\n    this.element = null;\r\n    this.searchStrategy = null;\r\n    this.searchEnclosingClass = Search.never;\r\n    this.annotations = annotations;\r\n    this.repeatableContainers = repeatableContainers;\r\n    this.annotationFilter = annotationFilter;\r\n}\n@Override\r\npublic <A extends Annotation> boolean isPresent(Class<A> annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, false)));\r\n}\n@Override\r\npublic boolean isPresent(String annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, false)));\r\n}\n@Override\r\npublic <A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, true)));\r\n}\n@Override\r\npublic boolean isDirectlyPresent(String annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, true)));\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType) {\r\n    return get(annotationType, null, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return MergedAnnotation.missing();\r\n    }\r\n    MergedAnnotation<A> result = scan(annotationType, new MergedAnnotationFinder<>(annotationType, predicate, selector));\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType) {\r\n    return get(annotationType, null, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return MergedAnnotation.missing();\r\n    }\r\n    MergedAnnotation<A> result = scan(annotationType, new MergedAnnotationFinder<>(annotationType, predicate, selector));\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}\n@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType) {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Stream.empty();\r\n    }\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}\n@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Stream.empty();\r\n    }\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}\n@Override\r\npublic Stream<MergedAnnotation<Annotation>> stream() {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Stream.empty();\r\n    }\r\n    return StreamSupport.stream(spliterator(), false);\r\n}\n@Override\r\npublic Iterator<MergedAnnotation<Annotation>> iterator() {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Collections.emptyIterator();\r\n    }\r\n    return Spliterators.iterator(spliterator());\r\n}\n@Override\r\npublic Spliterator<MergedAnnotation<Annotation>> spliterator() {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Spliterators.emptySpliterator();\r\n    }\r\n    return spliterator(null);\r\n}\nprivate <A extends Annotation> Spliterator<MergedAnnotation<A>> spliterator(@Nullable Object annotationType) {\r\n    return new AggregatesSpliterator<>(annotationType, getAggregates());\r\n}\nprivate List<Aggregate> getAggregates() {\r\n    List<Aggregate> aggregates = this.aggregates;\r\n    if (aggregates == null) {\r\n        aggregates = scan(this, new AggregatesCollector());\r\n        if (aggregates == null || aggregates.isEmpty()) {\r\n            aggregates = Collections.emptyList();\r\n        }\r\n        this.aggregates = aggregates;\r\n    }\r\n    return aggregates;\r\n}\n@Nullable\r\nprivate <C, R> R scan(C criteria, AnnotationsProcessor<C, R> processor) {\r\n    if (this.annotations != null) {\r\n        R result = processor.doWithAnnotations(criteria, 0, this.source, this.annotations);\r\n        return processor.finish(result);\r\n    }\r\n    if (this.element != null && this.searchStrategy != null) {\r\n        return AnnotationsScanner.scan(criteria, this.element, this.searchStrategy, this.searchEnclosingClass, processor);\r\n    }\r\n    return null;\r\n}\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    if (AnnotationsScanner.isKnownEmpty(element, searchStrategy, searchEnclosingClass)) {\r\n        return NONE;\r\n    }\r\n    return new TypeMappedAnnotations(element, searchStrategy, searchEnclosingClass, repeatableContainers, annotationFilter);\r\n}\nstatic MergedAnnotations from(@Nullable Object source, Annotation[] annotations, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    if (annotations.length == 0) {\r\n        return NONE;\r\n    }\r\n    return new TypeMappedAnnotations(source, annotations, repeatableContainers, annotationFilter);\r\n}\nprivate static boolean isMappingForType(AnnotationTypeMapping mapping, AnnotationFilter annotationFilter, @Nullable Object requiredType) {\r\n    Class<? extends Annotation> actualType = mapping.getAnnotationType();\r\n    return (!annotationFilter.matches(actualType) && (requiredType == null || actualType == requiredType || actualType.getName().equals(requiredType)));\r\n}\n/**\r\n * {@link AnnotationsProcessor} used to detect if an annotation is directly\r\n * present or meta-present.\r\n */\r\nprivate static final class IsPresent implements AnnotationsProcessor<Object, Boolean> {\r\n\r\n    /**\r\n     * Shared instances that save us needing to create a new processor for\r\n     * the common combinations.\r\n     */\r\n    private static final IsPresent[] SHARED;\r\n\r\n    static {\r\n        SHARED = new IsPresent[4];\r\n        SHARED[0] = new IsPresent(RepeatableContainers.none(), AnnotationFilter.PLAIN, true);\r\n        SHARED[1] = new IsPresent(RepeatableContainers.none(), AnnotationFilter.PLAIN, false);\r\n        SHARED[2] = new IsPresent(RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, true);\r\n        SHARED[3] = new IsPresent(RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, false);\r\n    }\r\n\r\n    private final RepeatableContainers repeatableContainers;\r\n\r\n    private final AnnotationFilter annotationFilter;\r\n\r\n    private final boolean directOnly;\r\n\r\n    private IsPresent(RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, boolean directOnly) {\r\n        this.repeatableContainers = repeatableContainers;\r\n        this.annotationFilter = annotationFilter;\r\n        this.directOnly = directOnly;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Boolean doWithAnnotations(Object requiredType, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n        for (Annotation annotation : annotations) {\r\n            if (annotation != null) {\r\n                Class<? extends Annotation> type = annotation.annotationType();\r\n                if (type != null && !this.annotationFilter.matches(type)) {\r\n                    if (type == requiredType || type.getName().equals(requiredType)) {\r\n                        return Boolean.TRUE;\r\n                    }\r\n                    Annotation[] repeatedAnnotations = this.repeatableContainers.findRepeatedAnnotations(annotation);\r\n                    if (repeatedAnnotations != null) {\r\n                        Boolean result = doWithAnnotations(requiredType, aggregateIndex, source, repeatedAnnotations);\r\n                        if (result != null) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    if (!this.directOnly) {\r\n                        AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(type);\r\n                        for (int i = 0; i < mappings.size(); i++) {\r\n                            AnnotationTypeMapping mapping = mappings.get(i);\r\n                            if (isMappingForType(mapping, this.annotationFilter, requiredType)) {\r\n                                return Boolean.TRUE;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static IsPresent get(RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, boolean directOnly) {\r\n        // Use a single shared instance for common combinations\r\n        if (annotationFilter == AnnotationFilter.PLAIN) {\r\n            if (repeatableContainers == RepeatableContainers.none()) {\r\n                return SHARED[directOnly ? 0 : 1];\r\n            }\r\n            if (repeatableContainers == RepeatableContainers.standardRepeatables()) {\r\n                return SHARED[directOnly ? 2 : 3];\r\n            }\r\n        }\r\n        return new IsPresent(repeatableContainers, annotationFilter, directOnly);\r\n    }\r\n}\n/**\r\n * {@link AnnotationsProcessor} that finds a single {@link MergedAnnotation}.\r\n */\r\nprivate class MergedAnnotationFinder<A extends Annotation> implements AnnotationsProcessor<Object, MergedAnnotation<A>> {\r\n\r\n    private final Object requiredType;\r\n\r\n    @Nullable\r\n    private final Predicate<? super MergedAnnotation<A>> predicate;\r\n\r\n    private final MergedAnnotationSelector<A> selector;\r\n\r\n    @Nullable\r\n    private MergedAnnotation<A> result;\r\n\r\n    MergedAnnotationFinder(Object requiredType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n        this.requiredType = requiredType;\r\n        this.predicate = predicate;\r\n        this.selector = (selector != null ? selector : MergedAnnotationSelectors.nearest());\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {\r\n        return this.result;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n        for (Annotation annotation : annotations) {\r\n            if (annotation != null && !annotationFilter.matches(annotation)) {\r\n                MergedAnnotation<A> result = process(type, aggregateIndex, source, annotation);\r\n                if (result != null) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Nullable\r\n    private MergedAnnotation<A> process(Object type, int aggregateIndex, @Nullable Object source, Annotation annotation) {\r\n        Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\r\n        if (repeatedAnnotations != null) {\r\n            MergedAnnotation<A> result = doWithAnnotations(type, aggregateIndex, source, repeatedAnnotations);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        }\r\n        AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType(), repeatableContainers, annotationFilter);\r\n        for (int i = 0; i < mappings.size(); i++) {\r\n            AnnotationTypeMapping mapping = mappings.get(i);\r\n            if (isMappingForType(mapping, annotationFilter, this.requiredType)) {\r\n                MergedAnnotation<A> candidate = TypeMappedAnnotation.createIfPossible(mapping, source, annotation, aggregateIndex, IntrospectionFailureLogger.INFO);\r\n                if (candidate != null && (this.predicate == null || this.predicate.test(candidate))) {\r\n                    if (this.selector.isBestCandidate(candidate)) {\r\n                        return candidate;\r\n                    }\r\n                    updateLastResult(candidate);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private void updateLastResult(MergedAnnotation<A> candidate) {\r\n        MergedAnnotation<A> lastResult = this.result;\r\n        this.result = (lastResult != null ? this.selector.select(lastResult, candidate) : candidate);\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result) {\r\n        return (result != null ? result : this.result);\r\n    }\r\n}\n/**\r\n * {@link AnnotationsProcessor} that collects {@link Aggregate} instances.\r\n */\r\nprivate class AggregatesCollector implements AnnotationsProcessor<Object, List<Aggregate>> {\r\n\r\n    private final List<Aggregate> aggregates = new ArrayList<>();\r\n\r\n    @Override\r\n    @Nullable\r\n    public List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n        this.aggregates.add(createAggregate(aggregateIndex, source, annotations));\r\n        return null;\r\n    }\r\n\r\n    private Aggregate createAggregate(int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n        List<Annotation> aggregateAnnotations = getAggregateAnnotations(annotations);\r\n        return new Aggregate(aggregateIndex, source, aggregateAnnotations);\r\n    }\r\n\r\n    private List<Annotation> getAggregateAnnotations(@Nullable Annotation[] annotations) {\r\n        List<Annotation> result = new ArrayList<>(annotations.length);\r\n        addAggregateAnnotations(result, annotations);\r\n        return result;\r\n    }\r\n\r\n    private void addAggregateAnnotations(List<Annotation> aggregateAnnotations, @Nullable Annotation[] annotations) {\r\n        for (Annotation annotation : annotations) {\r\n            if (annotation != null && !annotationFilter.matches(annotation)) {\r\n                Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\r\n                if (repeatedAnnotations != null) {\r\n                    addAggregateAnnotations(aggregateAnnotations, repeatedAnnotations);\r\n                } else {\r\n                    aggregateAnnotations.add(annotation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    @NonNull\r\n    public List<Aggregate> finish(@Nullable List<Aggregate> processResult) {\r\n        return this.aggregates;\r\n    }\r\n}\nprivate static class Aggregate {\r\n\r\n    private final int aggregateIndex;\r\n\r\n    @Nullable\r\n    private final Object source;\r\n\r\n    private final List<Annotation> annotations;\r\n\r\n    private final AnnotationTypeMappings[] mappings;\r\n\r\n    Aggregate(int aggregateIndex, @Nullable Object source, List<Annotation> annotations) {\r\n        this.aggregateIndex = aggregateIndex;\r\n        this.source = source;\r\n        this.annotations = annotations;\r\n        this.mappings = new AnnotationTypeMappings[annotations.size()];\r\n        for (int i = 0; i < annotations.size(); i++) {\r\n            this.mappings[i] = AnnotationTypeMappings.forAnnotationType(annotations.get(i).annotationType());\r\n        }\r\n    }\r\n\r\n    int size() {\r\n        return this.annotations.size();\r\n    }\r\n\r\n    @Nullable\r\n    AnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n        AnnotationTypeMappings mappings = getMappings(annotationIndex);\r\n        return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n    }\r\n\r\n    AnnotationTypeMappings getMappings(int annotationIndex) {\r\n        return this.mappings[annotationIndex];\r\n    }\r\n\r\n    @Nullable\r\n    <A extends Annotation> MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex, IntrospectionFailureLogger logger) {\r\n        return TypeMappedAnnotation.createIfPossible(this.mappings[annotationIndex].get(mappingIndex), this.source, this.annotations.get(annotationIndex), this.aggregateIndex, logger);\r\n    }\r\n}\n/**\r\n * {@link Spliterator} used to consume merged annotations from the\r\n * aggregates in distance fist order.\r\n */\r\nprivate class AggregatesSpliterator<A extends Annotation> implements Spliterator<MergedAnnotation<A>> {\r\n\r\n    @Nullable\r\n    private final Object requiredType;\r\n\r\n    private final List<Aggregate> aggregates;\r\n\r\n    private int aggregateCursor;\r\n\r\n    private int @Nullable [] mappingCursors;\r\n\r\n    AggregatesSpliterator(@Nullable Object requiredType, List<Aggregate> aggregates) {\r\n        this.requiredType = requiredType;\r\n        this.aggregates = aggregates;\r\n        this.aggregateCursor = 0;\r\n    }\r\n\r\n    @Override\r\n    public boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n        while (this.aggregateCursor < this.aggregates.size()) {\r\n            Aggregate aggregate = this.aggregates.get(this.aggregateCursor);\r\n            if (tryAdvance(aggregate, action)) {\r\n                return true;\r\n            }\r\n            this.aggregateCursor++;\r\n            this.mappingCursors = null;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean tryAdvance(Aggregate aggregate, Consumer<? super MergedAnnotation<A>> action) {\r\n        if (this.mappingCursors == null) {\r\n            this.mappingCursors = new int[aggregate.size()];\r\n        }\r\n        int lowestDistance = Integer.MAX_VALUE;\r\n        int annotationResult = -1;\r\n        for (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\r\n            AnnotationTypeMapping mapping = getNextSuitableMapping(aggregate, annotationIndex);\r\n            if (mapping != null && mapping.getDistance() < lowestDistance) {\r\n                annotationResult = annotationIndex;\r\n                lowestDistance = mapping.getDistance();\r\n            }\r\n            if (lowestDistance == 0) {\r\n                break;\r\n            }\r\n        }\r\n        if (annotationResult != -1) {\r\n            MergedAnnotation<A> mergedAnnotation = aggregate.createMergedAnnotationIfPossible(annotationResult, this.mappingCursors[annotationResult], this.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\r\n            this.mappingCursors[annotationResult]++;\r\n            if (mergedAnnotation == null) {\r\n                return tryAdvance(aggregate, action);\r\n            }\r\n            action.accept(mergedAnnotation);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Nullable\r\n    private AnnotationTypeMapping getNextSuitableMapping(Aggregate aggregate, int annotationIndex) {\r\n        int[] cursors = this.mappingCursors;\r\n        if (cursors != null) {\r\n            AnnotationTypeMapping mapping;\r\n            do {\r\n                mapping = aggregate.getMapping(annotationIndex, cursors[annotationIndex]);\r\n                if (mapping != null && isMappingForType(mapping, annotationFilter, this.requiredType)) {\r\n                    return mapping;\r\n                }\r\n                cursors[annotationIndex]++;\r\n            } while (mapping != null);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Spliterator<MergedAnnotation<A>> trySplit() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public long estimateSize() {\r\n        int size = 0;\r\n        for (int aggregateIndex = this.aggregateCursor; aggregateIndex < this.aggregates.size(); aggregateIndex++) {\r\n            Aggregate aggregate = this.aggregates.get(aggregateIndex);\r\n            for (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\r\n                AnnotationTypeMappings mappings = aggregate.getMappings(annotationIndex);\r\n                int numberOfMappings = mappings.size();\r\n                if (aggregateIndex == this.aggregateCursor && this.mappingCursors != null) {\r\n                    numberOfMappings -= Math.min(this.mappingCursors[annotationIndex], mappings.size());\r\n                }\r\n                size += numberOfMappings;\r\n            }\r\n        }\r\n        return size;\r\n    }\r\n\r\n    @Override\r\n    public int characteristics() {\r\n        return NONNULL | IMMUTABLE;\r\n    }\r\n}",
    "comment": "\n * {@link MergedAnnotations} implementation that searches for and adapts\n * annotations and meta-annotations using {@link AnnotationTypeMappings}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#isPresent(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> boolean isPresent(Class<A> annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, false)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#isPresent(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isPresent(String annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, false)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#isDirectlyPresent(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, true)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#isDirectlyPresent(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isDirectlyPresent(String annotationType) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return false;\r\n    }\r\n    return Boolean.TRUE.equals(scan(annotationType, IsPresent.get(this.repeatableContainers, this.annotationFilter, true)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#get(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType) {\r\n    return get(annotationType, null, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#get(Class<A>,Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#get(Class<A>,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return MergedAnnotation.missing();\r\n    }\r\n    MergedAnnotation<A> result = scan(annotationType, new MergedAnnotationFinder<>(annotationType, predicate, selector));\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#get(String)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType) {\r\n    return get(annotationType, null, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#get(String,Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#get(String,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    if (this.annotationFilter.matches(annotationType)) {\r\n        return MergedAnnotation.missing();\r\n    }\r\n    MergedAnnotation<A> result = scan(annotationType, new MergedAnnotationFinder<>(annotationType, predicate, selector));\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#stream(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType) {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Stream.empty();\r\n    }\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#stream(String)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Stream.empty();\r\n    }\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#stream()",
    "entityType": "method",
    "code": "@Override\r\npublic Stream<MergedAnnotation<Annotation>> stream() {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Stream.empty();\r\n    }\r\n    return StreamSupport.stream(spliterator(), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<MergedAnnotation<Annotation>> iterator() {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Collections.emptyIterator();\r\n    }\r\n    return Spliterators.iterator(spliterator());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<MergedAnnotation<Annotation>> spliterator() {\r\n    if (this.annotationFilter == AnnotationFilter.ALL) {\r\n        return Spliterators.emptySpliterator();\r\n    }\r\n    return spliterator(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#spliterator(Object)",
    "entityType": "method",
    "code": "private <A extends Annotation> Spliterator<MergedAnnotation<A>> spliterator(@Nullable Object annotationType) {\r\n    return new AggregatesSpliterator<>(annotationType, getAggregates());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#getAggregates()",
    "entityType": "method",
    "code": "private List<Aggregate> getAggregates() {\r\n    List<Aggregate> aggregates = this.aggregates;\r\n    if (aggregates == null) {\r\n        aggregates = scan(this, new AggregatesCollector());\r\n        if (aggregates == null || aggregates.isEmpty()) {\r\n            aggregates = Collections.emptyList();\r\n        }\r\n        this.aggregates = aggregates;\r\n    }\r\n    return aggregates;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#scan(C,AnnotationsProcessor<C,R>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate <C, R> R scan(C criteria, AnnotationsProcessor<C, R> processor) {\r\n    if (this.annotations != null) {\r\n        R result = processor.doWithAnnotations(criteria, 0, this.source, this.annotations);\r\n        return processor.finish(result);\r\n    }\r\n    if (this.element != null && this.searchStrategy != null) {\r\n        return AnnotationsScanner.scan(criteria, this.element, this.searchStrategy, this.searchEnclosingClass, processor);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#from(AnnotatedElement,SearchStrategy,Predicate<Class<?>>,RepeatableContainers,AnnotationFilter)",
    "entityType": "method",
    "code": "static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    if (AnnotationsScanner.isKnownEmpty(element, searchStrategy, searchEnclosingClass)) {\r\n        return NONE;\r\n    }\r\n    return new TypeMappedAnnotations(element, searchStrategy, searchEnclosingClass, repeatableContainers, annotationFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#from(Object,Annotation[],RepeatableContainers,AnnotationFilter)",
    "entityType": "method",
    "code": "static MergedAnnotations from(@Nullable Object source, Annotation[] annotations, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    if (annotations.length == 0) {\r\n        return NONE;\r\n    }\r\n    return new TypeMappedAnnotations(source, annotations, repeatableContainers, annotationFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotations#isMappingForType(AnnotationTypeMapping,AnnotationFilter,Object)",
    "entityType": "method",
    "code": "private static boolean isMappingForType(AnnotationTypeMapping mapping, AnnotationFilter annotationFilter, @Nullable Object requiredType) {\r\n    Class<? extends Annotation> actualType = mapping.getAnnotationType();\r\n    return (!annotationFilter.matches(actualType) && (requiredType == null || actualType == requiredType || actualType.getName().equals(requiredType)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.IsPresent",
    "entityType": "class",
    "code": "/**\r\n * Shared instances that save us needing to create a new processor for\r\n * the common combinations.\r\n */\r\nprivate static final IsPresent[] SHARED;\nstatic {\r\n    SHARED = new IsPresent[4];\r\n    SHARED[0] = new IsPresent(RepeatableContainers.none(), AnnotationFilter.PLAIN, true);\r\n    SHARED[1] = new IsPresent(RepeatableContainers.none(), AnnotationFilter.PLAIN, false);\r\n    SHARED[2] = new IsPresent(RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, true);\r\n    SHARED[3] = new IsPresent(RepeatableContainers.standardRepeatables(), AnnotationFilter.PLAIN, false);\r\n}\nprivate final RepeatableContainers repeatableContainers;\nprivate final AnnotationFilter annotationFilter;\nprivate final boolean directOnly;\nprivate IsPresent(RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, boolean directOnly) {\r\n    this.repeatableContainers = repeatableContainers;\r\n    this.annotationFilter = annotationFilter;\r\n    this.directOnly = directOnly;\r\n}\n@Override\r\n@Nullable\r\npublic Boolean doWithAnnotations(Object requiredType, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null) {\r\n            Class<? extends Annotation> type = annotation.annotationType();\r\n            if (type != null && !this.annotationFilter.matches(type)) {\r\n                if (type == requiredType || type.getName().equals(requiredType)) {\r\n                    return Boolean.TRUE;\r\n                }\r\n                Annotation[] repeatedAnnotations = this.repeatableContainers.findRepeatedAnnotations(annotation);\r\n                if (repeatedAnnotations != null) {\r\n                    Boolean result = doWithAnnotations(requiredType, aggregateIndex, source, repeatedAnnotations);\r\n                    if (result != null) {\r\n                        return result;\r\n                    }\r\n                }\r\n                if (!this.directOnly) {\r\n                    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(type);\r\n                    for (int i = 0; i < mappings.size(); i++) {\r\n                        AnnotationTypeMapping mapping = mappings.get(i);\r\n                        if (isMappingForType(mapping, this.annotationFilter, requiredType)) {\r\n                            return Boolean.TRUE;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\nstatic IsPresent get(RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, boolean directOnly) {\r\n    // Use a single shared instance for common combinations\r\n    if (annotationFilter == AnnotationFilter.PLAIN) {\r\n        if (repeatableContainers == RepeatableContainers.none()) {\r\n            return SHARED[directOnly ? 0 : 1];\r\n        }\r\n        if (repeatableContainers == RepeatableContainers.standardRepeatables()) {\r\n            return SHARED[directOnly ? 2 : 3];\r\n        }\r\n    }\r\n    return new IsPresent(repeatableContainers, annotationFilter, directOnly);\r\n}",
    "comment": "\n\t * {@link AnnotationsProcessor} used to detect if an annotation is directly\n\t * present or meta-present.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.IsPresent#doWithAnnotations(Object,int,Object,Annotation[])",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Boolean doWithAnnotations(Object requiredType, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null) {\r\n            Class<? extends Annotation> type = annotation.annotationType();\r\n            if (type != null && !this.annotationFilter.matches(type)) {\r\n                if (type == requiredType || type.getName().equals(requiredType)) {\r\n                    return Boolean.TRUE;\r\n                }\r\n                Annotation[] repeatedAnnotations = this.repeatableContainers.findRepeatedAnnotations(annotation);\r\n                if (repeatedAnnotations != null) {\r\n                    Boolean result = doWithAnnotations(requiredType, aggregateIndex, source, repeatedAnnotations);\r\n                    if (result != null) {\r\n                        return result;\r\n                    }\r\n                }\r\n                if (!this.directOnly) {\r\n                    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(type);\r\n                    for (int i = 0; i < mappings.size(); i++) {\r\n                        AnnotationTypeMapping mapping = mappings.get(i);\r\n                        if (isMappingForType(mapping, this.annotationFilter, requiredType)) {\r\n                            return Boolean.TRUE;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.IsPresent#get(RepeatableContainers,AnnotationFilter,boolean)",
    "entityType": "method",
    "code": "static IsPresent get(RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter, boolean directOnly) {\r\n    // Use a single shared instance for common combinations\r\n    if (annotationFilter == AnnotationFilter.PLAIN) {\r\n        if (repeatableContainers == RepeatableContainers.none()) {\r\n            return SHARED[directOnly ? 0 : 1];\r\n        }\r\n        if (repeatableContainers == RepeatableContainers.standardRepeatables()) {\r\n            return SHARED[directOnly ? 2 : 3];\r\n        }\r\n    }\r\n    return new IsPresent(repeatableContainers, annotationFilter, directOnly);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationFinder",
    "entityType": "class",
    "code": "private final Object requiredType;\n@Nullable\r\nprivate final Predicate<? super MergedAnnotation<A>> predicate;\nprivate final MergedAnnotationSelector<A> selector;\n@Nullable\r\nprivate MergedAnnotation<A> result;\nMergedAnnotationFinder(Object requiredType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    this.requiredType = requiredType;\r\n    this.predicate = predicate;\r\n    this.selector = (selector != null ? selector : MergedAnnotationSelectors.nearest());\r\n}\n@Override\r\n@Nullable\r\npublic MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {\r\n    return this.result;\r\n}\n@Override\r\n@Nullable\r\npublic MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null && !annotationFilter.matches(annotation)) {\r\n            MergedAnnotation<A> result = process(type, aggregateIndex, source, annotation);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\n@Nullable\r\nprivate MergedAnnotation<A> process(Object type, int aggregateIndex, @Nullable Object source, Annotation annotation) {\r\n    Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\r\n    if (repeatedAnnotations != null) {\r\n        MergedAnnotation<A> result = doWithAnnotations(type, aggregateIndex, source, repeatedAnnotations);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n    }\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType(), repeatableContainers, annotationFilter);\r\n    for (int i = 0; i < mappings.size(); i++) {\r\n        AnnotationTypeMapping mapping = mappings.get(i);\r\n        if (isMappingForType(mapping, annotationFilter, this.requiredType)) {\r\n            MergedAnnotation<A> candidate = TypeMappedAnnotation.createIfPossible(mapping, source, annotation, aggregateIndex, IntrospectionFailureLogger.INFO);\r\n            if (candidate != null && (this.predicate == null || this.predicate.test(candidate))) {\r\n                if (this.selector.isBestCandidate(candidate)) {\r\n                    return candidate;\r\n                }\r\n                updateLastResult(candidate);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\nprivate void updateLastResult(MergedAnnotation<A> candidate) {\r\n    MergedAnnotation<A> lastResult = this.result;\r\n    this.result = (lastResult != null ? this.selector.select(lastResult, candidate) : candidate);\r\n}\n@Override\r\n@Nullable\r\npublic MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result) {\r\n    return (result != null ? result : this.result);\r\n}",
    "comment": "\n\t * {@link AnnotationsProcessor} that finds a single {@link MergedAnnotation}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationFinder#doWithAggregate(Object,int)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic MergedAnnotation<A> doWithAggregate(Object context, int aggregateIndex) {\r\n    return this.result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationFinder#doWithAnnotations(Object,int,Object,Annotation[])",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic MergedAnnotation<A> doWithAnnotations(Object type, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null && !annotationFilter.matches(annotation)) {\r\n            MergedAnnotation<A> result = process(type, aggregateIndex, source, annotation);\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationFinder#process(Object,int,Object,Annotation)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate MergedAnnotation<A> process(Object type, int aggregateIndex, @Nullable Object source, Annotation annotation) {\r\n    Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\r\n    if (repeatedAnnotations != null) {\r\n        MergedAnnotation<A> result = doWithAnnotations(type, aggregateIndex, source, repeatedAnnotations);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n    }\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType(), repeatableContainers, annotationFilter);\r\n    for (int i = 0; i < mappings.size(); i++) {\r\n        AnnotationTypeMapping mapping = mappings.get(i);\r\n        if (isMappingForType(mapping, annotationFilter, this.requiredType)) {\r\n            MergedAnnotation<A> candidate = TypeMappedAnnotation.createIfPossible(mapping, source, annotation, aggregateIndex, IntrospectionFailureLogger.INFO);\r\n            if (candidate != null && (this.predicate == null || this.predicate.test(candidate))) {\r\n                if (this.selector.isBestCandidate(candidate)) {\r\n                    return candidate;\r\n                }\r\n                updateLastResult(candidate);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationFinder#updateLastResult(MergedAnnotation<A>)",
    "entityType": "method",
    "code": "private void updateLastResult(MergedAnnotation<A> candidate) {\r\n    MergedAnnotation<A> lastResult = this.result;\r\n    this.result = (lastResult != null ? this.selector.select(lastResult, candidate) : candidate);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationFinder#finish(MergedAnnotation<A>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic MergedAnnotation<A> finish(@Nullable MergedAnnotation<A> result) {\r\n    return (result != null ? result : this.result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesCollector",
    "entityType": "class",
    "code": "private final List<Aggregate> aggregates = new ArrayList<>();\n@Override\r\n@Nullable\r\npublic List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    this.aggregates.add(createAggregate(aggregateIndex, source, annotations));\r\n    return null;\r\n}\nprivate Aggregate createAggregate(int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    List<Annotation> aggregateAnnotations = getAggregateAnnotations(annotations);\r\n    return new Aggregate(aggregateIndex, source, aggregateAnnotations);\r\n}\nprivate List<Annotation> getAggregateAnnotations(@Nullable Annotation[] annotations) {\r\n    List<Annotation> result = new ArrayList<>(annotations.length);\r\n    addAggregateAnnotations(result, annotations);\r\n    return result;\r\n}\nprivate void addAggregateAnnotations(List<Annotation> aggregateAnnotations, @Nullable Annotation[] annotations) {\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null && !annotationFilter.matches(annotation)) {\r\n            Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\r\n            if (repeatedAnnotations != null) {\r\n                addAggregateAnnotations(aggregateAnnotations, repeatedAnnotations);\r\n            } else {\r\n                aggregateAnnotations.add(annotation);\r\n            }\r\n        }\r\n    }\r\n}\n@Override\r\n@NonNull\r\npublic List<Aggregate> finish(@Nullable List<Aggregate> processResult) {\r\n    return this.aggregates;\r\n}",
    "comment": "\n\t * {@link AnnotationsProcessor} that collects {@link Aggregate} instances.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesCollector#doWithAnnotations(Object,int,Object,Annotation[])",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<Aggregate> doWithAnnotations(Object criteria, int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    this.aggregates.add(createAggregate(aggregateIndex, source, annotations));\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesCollector#createAggregate(int,Object,Annotation[])",
    "entityType": "method",
    "code": "private Aggregate createAggregate(int aggregateIndex, @Nullable Object source, @Nullable Annotation[] annotations) {\r\n    List<Annotation> aggregateAnnotations = getAggregateAnnotations(annotations);\r\n    return new Aggregate(aggregateIndex, source, aggregateAnnotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesCollector#getAggregateAnnotations(Annotation[])",
    "entityType": "method",
    "code": "private List<Annotation> getAggregateAnnotations(@Nullable Annotation[] annotations) {\r\n    List<Annotation> result = new ArrayList<>(annotations.length);\r\n    addAggregateAnnotations(result, annotations);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesCollector#addAggregateAnnotations(List<Annotation>,Annotation[])",
    "entityType": "method",
    "code": "private void addAggregateAnnotations(List<Annotation> aggregateAnnotations, @Nullable Annotation[] annotations) {\r\n    for (Annotation annotation : annotations) {\r\n        if (annotation != null && !annotationFilter.matches(annotation)) {\r\n            Annotation[] repeatedAnnotations = repeatableContainers.findRepeatedAnnotations(annotation);\r\n            if (repeatedAnnotations != null) {\r\n                addAggregateAnnotations(aggregateAnnotations, repeatedAnnotations);\r\n            } else {\r\n                aggregateAnnotations.add(annotation);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesCollector#finish(List<Aggregate>)",
    "entityType": "method",
    "code": "@Override\r\n@NonNull\r\npublic List<Aggregate> finish(@Nullable List<Aggregate> processResult) {\r\n    return this.aggregates;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.Aggregate",
    "entityType": "class",
    "code": "private final int aggregateIndex;\n@Nullable\r\nprivate final Object source;\nprivate final List<Annotation> annotations;\nprivate final AnnotationTypeMappings[] mappings;\nAggregate(int aggregateIndex, @Nullable Object source, List<Annotation> annotations) {\r\n    this.aggregateIndex = aggregateIndex;\r\n    this.source = source;\r\n    this.annotations = annotations;\r\n    this.mappings = new AnnotationTypeMappings[annotations.size()];\r\n    for (int i = 0; i < annotations.size(); i++) {\r\n        this.mappings[i] = AnnotationTypeMappings.forAnnotationType(annotations.get(i).annotationType());\r\n    }\r\n}\nint size() {\r\n    return this.annotations.size();\r\n}\n@Nullable\r\nAnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n    AnnotationTypeMappings mappings = getMappings(annotationIndex);\r\n    return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n}\nAnnotationTypeMappings getMappings(int annotationIndex) {\r\n    return this.mappings[annotationIndex];\r\n}\n@Nullable\r\n<A extends Annotation> MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex, IntrospectionFailureLogger logger) {\r\n    return TypeMappedAnnotation.createIfPossible(this.mappings[annotationIndex].get(mappingIndex), this.source, this.annotations.get(annotationIndex), this.aggregateIndex, logger);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.Aggregate#size()",
    "entityType": "method",
    "code": "int size() {\r\n    return this.annotations.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.Aggregate#getMapping(int,int)",
    "entityType": "method",
    "code": "@Nullable\r\nAnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n    AnnotationTypeMappings mappings = getMappings(annotationIndex);\r\n    return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.Aggregate#getMappings(int)",
    "entityType": "method",
    "code": "AnnotationTypeMappings getMappings(int annotationIndex) {\r\n    return this.mappings[annotationIndex];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.Aggregate#createMergedAnnotationIfPossible(int,int,IntrospectionFailureLogger)",
    "entityType": "method",
    "code": "@Nullable\r\n<A extends Annotation> MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex, IntrospectionFailureLogger logger) {\r\n    return TypeMappedAnnotation.createIfPossible(this.mappings[annotationIndex].get(mappingIndex), this.source, this.annotations.get(annotationIndex), this.aggregateIndex, logger);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object requiredType;\nprivate final List<Aggregate> aggregates;\nprivate int aggregateCursor;\nprivate int @Nullable [] mappingCursors;\nAggregatesSpliterator(@Nullable Object requiredType, List<Aggregate> aggregates) {\r\n    this.requiredType = requiredType;\r\n    this.aggregates = aggregates;\r\n    this.aggregateCursor = 0;\r\n}\n@Override\r\npublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n    while (this.aggregateCursor < this.aggregates.size()) {\r\n        Aggregate aggregate = this.aggregates.get(this.aggregateCursor);\r\n        if (tryAdvance(aggregate, action)) {\r\n            return true;\r\n        }\r\n        this.aggregateCursor++;\r\n        this.mappingCursors = null;\r\n    }\r\n    return false;\r\n}\nprivate boolean tryAdvance(Aggregate aggregate, Consumer<? super MergedAnnotation<A>> action) {\r\n    if (this.mappingCursors == null) {\r\n        this.mappingCursors = new int[aggregate.size()];\r\n    }\r\n    int lowestDistance = Integer.MAX_VALUE;\r\n    int annotationResult = -1;\r\n    for (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\r\n        AnnotationTypeMapping mapping = getNextSuitableMapping(aggregate, annotationIndex);\r\n        if (mapping != null && mapping.getDistance() < lowestDistance) {\r\n            annotationResult = annotationIndex;\r\n            lowestDistance = mapping.getDistance();\r\n        }\r\n        if (lowestDistance == 0) {\r\n            break;\r\n        }\r\n    }\r\n    if (annotationResult != -1) {\r\n        MergedAnnotation<A> mergedAnnotation = aggregate.createMergedAnnotationIfPossible(annotationResult, this.mappingCursors[annotationResult], this.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\r\n        this.mappingCursors[annotationResult]++;\r\n        if (mergedAnnotation == null) {\r\n            return tryAdvance(aggregate, action);\r\n        }\r\n        action.accept(mergedAnnotation);\r\n        return true;\r\n    }\r\n    return false;\r\n}\n@Nullable\r\nprivate AnnotationTypeMapping getNextSuitableMapping(Aggregate aggregate, int annotationIndex) {\r\n    int[] cursors = this.mappingCursors;\r\n    if (cursors != null) {\r\n        AnnotationTypeMapping mapping;\r\n        do {\r\n            mapping = aggregate.getMapping(annotationIndex, cursors[annotationIndex]);\r\n            if (mapping != null && isMappingForType(mapping, annotationFilter, this.requiredType)) {\r\n                return mapping;\r\n            }\r\n            cursors[annotationIndex]++;\r\n        } while (mapping != null);\r\n    }\r\n    return null;\r\n}\n@Override\r\n@Nullable\r\npublic Spliterator<MergedAnnotation<A>> trySplit() {\r\n    return null;\r\n}\n@Override\r\npublic long estimateSize() {\r\n    int size = 0;\r\n    for (int aggregateIndex = this.aggregateCursor; aggregateIndex < this.aggregates.size(); aggregateIndex++) {\r\n        Aggregate aggregate = this.aggregates.get(aggregateIndex);\r\n        for (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\r\n            AnnotationTypeMappings mappings = aggregate.getMappings(annotationIndex);\r\n            int numberOfMappings = mappings.size();\r\n            if (aggregateIndex == this.aggregateCursor && this.mappingCursors != null) {\r\n                numberOfMappings -= Math.min(this.mappingCursors[annotationIndex], mappings.size());\r\n            }\r\n            size += numberOfMappings;\r\n        }\r\n    }\r\n    return size;\r\n}\n@Override\r\npublic int characteristics() {\r\n    return NONNULL | IMMUTABLE;\r\n}",
    "comment": "\n\t * {@link Spliterator} used to consume merged annotations from the\n\t * aggregates in distance fist order.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator#tryAdvance(Consumer<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n    while (this.aggregateCursor < this.aggregates.size()) {\r\n        Aggregate aggregate = this.aggregates.get(this.aggregateCursor);\r\n        if (tryAdvance(aggregate, action)) {\r\n            return true;\r\n        }\r\n        this.aggregateCursor++;\r\n        this.mappingCursors = null;\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator#tryAdvance(Aggregate,Consumer<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "private boolean tryAdvance(Aggregate aggregate, Consumer<? super MergedAnnotation<A>> action) {\r\n    if (this.mappingCursors == null) {\r\n        this.mappingCursors = new int[aggregate.size()];\r\n    }\r\n    int lowestDistance = Integer.MAX_VALUE;\r\n    int annotationResult = -1;\r\n    for (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\r\n        AnnotationTypeMapping mapping = getNextSuitableMapping(aggregate, annotationIndex);\r\n        if (mapping != null && mapping.getDistance() < lowestDistance) {\r\n            annotationResult = annotationIndex;\r\n            lowestDistance = mapping.getDistance();\r\n        }\r\n        if (lowestDistance == 0) {\r\n            break;\r\n        }\r\n    }\r\n    if (annotationResult != -1) {\r\n        MergedAnnotation<A> mergedAnnotation = aggregate.createMergedAnnotationIfPossible(annotationResult, this.mappingCursors[annotationResult], this.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\r\n        this.mappingCursors[annotationResult]++;\r\n        if (mergedAnnotation == null) {\r\n            return tryAdvance(aggregate, action);\r\n        }\r\n        action.accept(mergedAnnotation);\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator#getNextSuitableMapping(Aggregate,int)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate AnnotationTypeMapping getNextSuitableMapping(Aggregate aggregate, int annotationIndex) {\r\n    int[] cursors = this.mappingCursors;\r\n    if (cursors != null) {\r\n        AnnotationTypeMapping mapping;\r\n        do {\r\n            mapping = aggregate.getMapping(annotationIndex, cursors[annotationIndex]);\r\n            if (mapping != null && isMappingForType(mapping, annotationFilter, this.requiredType)) {\r\n                return mapping;\r\n            }\r\n            cursors[annotationIndex]++;\r\n        } while (mapping != null);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator#trySplit()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Spliterator<MergedAnnotation<A>> trySplit() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator#estimateSize()",
    "entityType": "method",
    "code": "@Override\r\npublic long estimateSize() {\r\n    int size = 0;\r\n    for (int aggregateIndex = this.aggregateCursor; aggregateIndex < this.aggregates.size(); aggregateIndex++) {\r\n        Aggregate aggregate = this.aggregates.get(aggregateIndex);\r\n        for (int annotationIndex = 0; annotationIndex < aggregate.size(); annotationIndex++) {\r\n            AnnotationTypeMappings mappings = aggregate.getMappings(annotationIndex);\r\n            int numberOfMappings = mappings.size();\r\n            if (aggregateIndex == this.aggregateCursor && this.mappingCursors != null) {\r\n                numberOfMappings -= Math.min(this.mappingCursors[annotationIndex], mappings.size());\r\n            }\r\n            size += numberOfMappings;\r\n        }\r\n    }\r\n    return size;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AggregatesSpliterator#characteristics()",
    "entityType": "method",
    "code": "@Override\r\npublic int characteristics() {\r\n    return NONNULL | IMMUTABLE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ValueExtractor",
    "entityType": "class",
    "code": "/**\r\n * Extract the annotation attribute represented by the supplied {@link Method}\r\n * from the supplied source {@link Object}.\r\n */\r\n@Nullable\r\nObject extract(Method attribute, @Nullable Object object);",
    "comment": "\n * Strategy API for extracting a value for an annotation attribute from a given\n * source object which is typically an {@link Annotation}, {@link Map}, or\n * {@link TypeMappedAnnotation}.\n *\n * @author Sam Brannen\n * @since 5.2.4\n "
  },
  {
    "entityId": "org.springframework.core.annotation.ValueExtractor#extract(Method,Object)",
    "entityType": "method",
    "code": "/**\r\n * Extract the annotation attribute represented by the supplied {@link Method}\r\n * from the supplied source {@link Object}.\r\n */\r\n@Nullable\r\nObject extract(Method attribute, @Nullable Object object);",
    "comment": "\n\t * Extract the annotation attribute represented by the supplied {@link Method}\n\t * from the supplied source {@link Object}.\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor",
    "entityType": "class",
    "code": "/**\r\n * Set the attribute defined by {@code name} to the supplied {@code value}.\r\n * <p>If {@code value} is {@code null}, the attribute is {@link #removeAttribute removed}.\r\n * <p>In general, users should take care to prevent overlaps with other\r\n * metadata attributes by using fully-qualified names, perhaps using\r\n * class or package names as prefix.\r\n * @param name the unique attribute key\r\n * @param value the attribute value to be attached\r\n */\r\nvoid setAttribute(String name, @Nullable Object value);\n/**\r\n * Get the value of the attribute identified by {@code name}.\r\n * <p>Return {@code null} if the attribute doesn't exist.\r\n * @param name the unique attribute key\r\n * @return the current value of the attribute, if any\r\n */\r\n@Nullable\r\nObject getAttribute(String name);\n/**\r\n * Compute a new value for the attribute identified by {@code name} if\r\n * necessary and {@linkplain #setAttribute set} the new value in this\r\n * {@code AttributeAccessor}.\r\n * <p>If a value for the attribute identified by {@code name} already exists\r\n * in this {@code AttributeAccessor}, the existing value will be returned\r\n * without applying the supplied compute function.\r\n * <p>The default implementation of this method is not thread safe but can\r\n * be overridden by concrete implementations of this interface.\r\n * @param <T> the type of the attribute value\r\n * @param name the unique attribute key\r\n * @param computeFunction a function that computes a new value for the attribute\r\n * name; the function must not return a {@code null} value\r\n * @return the existing value or newly computed value for the named attribute\r\n * @since 5.3.3\r\n * @see #getAttribute(String)\r\n * @see #setAttribute(String, Object)\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\ndefault <T> T computeAttribute(String name, Function<String, T> computeFunction) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(computeFunction, \"Compute function must not be null\");\r\n    Object value = getAttribute(name);\r\n    if (value == null) {\r\n        value = computeFunction.apply(name);\r\n        Assert.state(value != null, () -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\r\n        setAttribute(name, value);\r\n    }\r\n    return (T) value;\r\n}\n/**\r\n * Remove the attribute identified by {@code name} and return its value.\r\n * <p>Return {@code null} if no attribute under {@code name} is found.\r\n * @param name the unique attribute key\r\n * @return the last value of the attribute, if any\r\n */\r\n@Nullable\r\nObject removeAttribute(String name);\n/**\r\n * Return {@code true} if the attribute identified by {@code name} exists.\r\n * <p>Otherwise return {@code false}.\r\n * @param name the unique attribute key\r\n */\r\nboolean hasAttribute(String name);\n/**\r\n * Return the names of all attributes.\r\n */\r\nString[] attributeNames();",
    "comment": "\n * Interface defining a generic contract for attaching and accessing metadata\n * to/from arbitrary objects.\n *\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 2.0\n "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor#setAttribute(String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Set the attribute defined by {@code name} to the supplied {@code value}.\r\n * <p>If {@code value} is {@code null}, the attribute is {@link #removeAttribute removed}.\r\n * <p>In general, users should take care to prevent overlaps with other\r\n * metadata attributes by using fully-qualified names, perhaps using\r\n * class or package names as prefix.\r\n * @param name the unique attribute key\r\n * @param value the attribute value to be attached\r\n */\r\nvoid setAttribute(String name, @Nullable Object value);",
    "comment": "\n\t * Set the attribute defined by {@code name} to the supplied {@code value}.\n\t * <p>If {@code value} is {@code null}, the attribute is {@link #removeAttribute removed}.\n\t * <p>In general, users should take care to prevent overlaps with other\n\t * metadata attributes by using fully-qualified names, perhaps using\n\t * class or package names as prefix.\n\t * @param name the unique attribute key\n\t * @param value the attribute value to be attached\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor#getAttribute(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the value of the attribute identified by {@code name}.\r\n * <p>Return {@code null} if the attribute doesn't exist.\r\n * @param name the unique attribute key\r\n * @return the current value of the attribute, if any\r\n */\r\n@Nullable\r\nObject getAttribute(String name);",
    "comment": "\n\t * Get the value of the attribute identified by {@code name}.\n\t * <p>Return {@code null} if the attribute doesn't exist.\n\t * @param name the unique attribute key\n\t * @return the current value of the attribute, if any\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor#computeAttribute(String,Function<String,T>)",
    "entityType": "method",
    "code": "/**\r\n * Compute a new value for the attribute identified by {@code name} if\r\n * necessary and {@linkplain #setAttribute set} the new value in this\r\n * {@code AttributeAccessor}.\r\n * <p>If a value for the attribute identified by {@code name} already exists\r\n * in this {@code AttributeAccessor}, the existing value will be returned\r\n * without applying the supplied compute function.\r\n * <p>The default implementation of this method is not thread safe but can\r\n * be overridden by concrete implementations of this interface.\r\n * @param <T> the type of the attribute value\r\n * @param name the unique attribute key\r\n * @param computeFunction a function that computes a new value for the attribute\r\n * name; the function must not return a {@code null} value\r\n * @return the existing value or newly computed value for the named attribute\r\n * @since 5.3.3\r\n * @see #getAttribute(String)\r\n * @see #setAttribute(String, Object)\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\ndefault <T> T computeAttribute(String name, Function<String, T> computeFunction) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(computeFunction, \"Compute function must not be null\");\r\n    Object value = getAttribute(name);\r\n    if (value == null) {\r\n        value = computeFunction.apply(name);\r\n        Assert.state(value != null, () -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\r\n        setAttribute(name, value);\r\n    }\r\n    return (T) value;\r\n}",
    "comment": "\n\t * Compute a new value for the attribute identified by {@code name} if\n\t * necessary and {@linkplain #setAttribute set} the new value in this\n\t * {@code AttributeAccessor}.\n\t * <p>If a value for the attribute identified by {@code name} already exists\n\t * in this {@code AttributeAccessor}, the existing value will be returned\n\t * without applying the supplied compute function.\n\t * <p>The default implementation of this method is not thread safe but can\n\t * be overridden by concrete implementations of this interface.\n\t * @param <T> the type of the attribute value\n\t * @param name the unique attribute key\n\t * @param computeFunction a function that computes a new value for the attribute\n\t * name; the function must not return a {@code null} value\n\t * @return the existing value or newly computed value for the named attribute\n\t * @since 5.3.3\n\t * @see #getAttribute(String)\n\t * @see #setAttribute(String, Object)\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor#removeAttribute(String)",
    "entityType": "method",
    "code": "/**\r\n * Remove the attribute identified by {@code name} and return its value.\r\n * <p>Return {@code null} if no attribute under {@code name} is found.\r\n * @param name the unique attribute key\r\n * @return the last value of the attribute, if any\r\n */\r\n@Nullable\r\nObject removeAttribute(String name);",
    "comment": "\n\t * Remove the attribute identified by {@code name} and return its value.\n\t * <p>Return {@code null} if no attribute under {@code name} is found.\n\t * @param name the unique attribute key\n\t * @return the last value of the attribute, if any\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor#hasAttribute(String)",
    "entityType": "method",
    "code": "/**\r\n * Return {@code true} if the attribute identified by {@code name} exists.\r\n * <p>Otherwise return {@code false}.\r\n * @param name the unique attribute key\r\n */\r\nboolean hasAttribute(String name);",
    "comment": "\n\t * Return {@code true} if the attribute identified by {@code name} exists.\n\t * <p>Otherwise return {@code false}.\n\t * @param name the unique attribute key\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessor#attributeNames()",
    "entityType": "method",
    "code": "/**\r\n * Return the names of all attributes.\r\n */\r\nString[] attributeNames();",
    "comment": "\n\t * Return the names of all attributes.\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport",
    "entityType": "class",
    "code": "/**\r\n * Map with String keys and Object values.\r\n */\r\nprivate final Map<String, Object> attributes = new LinkedHashMap<>();\n@Override\r\npublic void setAttribute(String name, @Nullable Object value) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    if (value != null) {\r\n        this.attributes.put(name, value);\r\n    } else {\r\n        removeAttribute(name);\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic Object getAttribute(String name) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    return this.attributes.get(name);\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(computeFunction, \"Compute function must not be null\");\r\n    Object value = this.attributes.computeIfAbsent(name, computeFunction);\r\n    Assert.state(value != null, () -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\r\n    return (T) value;\r\n}\n@Override\r\n@Nullable\r\npublic Object removeAttribute(String name) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    return this.attributes.remove(name);\r\n}\n@Override\r\npublic boolean hasAttribute(String name) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    return this.attributes.containsKey(name);\r\n}\n@Override\r\npublic String[] attributeNames() {\r\n    return StringUtils.toStringArray(this.attributes.keySet());\r\n}\n/**\r\n * Copy the attributes from the supplied AttributeAccessor to this accessor.\r\n * @param source the AttributeAccessor to copy from\r\n */\r\nprotected void copyAttributesFrom(AttributeAccessor source) {\r\n    Assert.notNull(source, \"Source must not be null\");\r\n    String[] attributeNames = source.attributeNames();\r\n    for (String attributeName : attributeNames) {\r\n        setAttribute(attributeName, source.getAttribute(attributeName));\r\n    }\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof AttributeAccessorSupport that && this.attributes.equals(that.attributes)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.attributes.hashCode();\r\n}",
    "comment": "\n * Support class for {@link AttributeAccessor AttributeAccessors}, providing\n * a base implementation of all methods. To be extended by subclasses.\n *\n * <p>{@link Serializable} if subclasses and all attribute values are {@link Serializable}.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.0\n "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#setAttribute(String,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void setAttribute(String name, @Nullable Object value) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    if (value != null) {\r\n        this.attributes.put(name, value);\r\n    } else {\r\n        removeAttribute(name);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#getAttribute(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object getAttribute(String name) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    return this.attributes.get(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#computeAttribute(String,Function<String,T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T> T computeAttribute(String name, Function<String, T> computeFunction) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    Assert.notNull(computeFunction, \"Compute function must not be null\");\r\n    Object value = this.attributes.computeIfAbsent(name, computeFunction);\r\n    Assert.state(value != null, () -> String.format(\"Compute function must not return null for attribute named '%s'\", name));\r\n    return (T) value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#removeAttribute(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object removeAttribute(String name) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    return this.attributes.remove(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#hasAttribute(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasAttribute(String name) {\r\n    Assert.notNull(name, \"Name must not be null\");\r\n    return this.attributes.containsKey(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#attributeNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] attributeNames() {\r\n    return StringUtils.toStringArray(this.attributes.keySet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#copyAttributesFrom(AttributeAccessor)",
    "entityType": "method",
    "code": "/**\r\n * Copy the attributes from the supplied AttributeAccessor to this accessor.\r\n * @param source the AttributeAccessor to copy from\r\n */\r\nprotected void copyAttributesFrom(AttributeAccessor source) {\r\n    Assert.notNull(source, \"Source must not be null\");\r\n    String[] attributeNames = source.attributeNames();\r\n    for (String attributeName : attributeNames) {\r\n        setAttribute(attributeName, source.getAttribute(attributeName));\r\n    }\r\n}",
    "comment": "\n\t * Copy the attributes from the supplied AttributeAccessor to this accessor.\n\t * @param source the AttributeAccessor to copy from\n\t "
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof AttributeAccessorSupport that && this.attributes.equals(that.attributes)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.AttributeAccessorSupport#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.attributes.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver",
    "entityType": "class",
    "code": "private static final Map<Object, Method> cache = new ConcurrentReferenceHashMap<>();\nprivate BridgeMethodResolver() {\r\n}\n/**\r\n * Find the local original method for the supplied {@link Method bridge Method}.\r\n * <p>It is safe to call this method passing in a non-bridge {@link Method} instance.\r\n * In such a case, the supplied {@link Method} instance is returned directly to the caller.\r\n * Callers are <strong>not</strong> required to check for bridging before calling this method.\r\n * @param bridgeMethod the method to introspect against its declaring class\r\n * @return the original method (either the bridged method or the passed-in method\r\n * if no more specific one could be found)\r\n * @see #getMostSpecificMethod(Method, Class)\r\n */\r\npublic static Method findBridgedMethod(Method bridgeMethod) {\r\n    return resolveBridgeMethod(bridgeMethod, bridgeMethod.getDeclaringClass());\r\n}\n/**\r\n * Determine the most specific method for the supplied {@link Method bridge Method}\r\n * in the given class hierarchy, even if not available on the local declaring class.\r\n * <p>This is effectively a combination of {@link ClassUtils#getMostSpecificMethod}\r\n * and {@link #findBridgedMethod}, resolving the original method even if no bridge\r\n * method has been generated at the same class hierarchy level (a known difference\r\n * between the Eclipse compiler and regular javac).\r\n * @param bridgeMethod the method to introspect against the given target class\r\n * @param targetClass the target class to find the most specific method on\r\n * @return the most specific method corresponding to the given bridge method\r\n * (can be the original method if no more specific one could be found)\r\n * @since 6.1.3\r\n * @see #findBridgedMethod\r\n * @see org.springframework.util.ClassUtils#getMostSpecificMethod\r\n */\r\npublic static Method getMostSpecificMethod(Method bridgeMethod, @Nullable Class<?> targetClass) {\r\n    if (targetClass != null && !ClassUtils.getUserClass(bridgeMethod.getDeclaringClass()).isAssignableFrom(targetClass) && !Proxy.isProxyClass(bridgeMethod.getDeclaringClass())) {\r\n        // From a different class hierarchy, and not a JDK or CGLIB proxy either -> return as-is.\r\n        return bridgeMethod;\r\n    }\r\n    Method specificMethod = ClassUtils.getMostSpecificMethod(bridgeMethod, targetClass);\r\n    return resolveBridgeMethod(specificMethod, (targetClass != null ? targetClass : specificMethod.getDeclaringClass()));\r\n}\nprivate static Method resolveBridgeMethod(Method bridgeMethod, Class<?> targetClass) {\r\n    boolean localBridge = (targetClass == bridgeMethod.getDeclaringClass());\r\n    Class<?> userClass = targetClass;\r\n    if (!bridgeMethod.isBridge() && localBridge) {\r\n        userClass = ClassUtils.getUserClass(targetClass);\r\n        if (userClass == targetClass) {\r\n            return bridgeMethod;\r\n        }\r\n    }\r\n    Object cacheKey = (localBridge ? bridgeMethod : new MethodClassKey(bridgeMethod, targetClass));\r\n    Method bridgedMethod = cache.get(cacheKey);\r\n    if (bridgedMethod == null) {\r\n        // Gather all methods with matching name and parameter size.\r\n        List<Method> candidateMethods = new ArrayList<>();\r\n        MethodFilter filter = (candidateMethod -> isBridgedCandidateFor(candidateMethod, bridgeMethod));\r\n        ReflectionUtils.doWithMethods(userClass, candidateMethods::add, filter);\r\n        if (!candidateMethods.isEmpty()) {\r\n            bridgedMethod = (candidateMethods.size() == 1 ? candidateMethods.get(0) : searchCandidates(candidateMethods, bridgeMethod));\r\n        }\r\n        if (bridgedMethod == null) {\r\n            // A bridge method was passed in but we couldn't find the bridged method.\r\n            // Let's proceed with the passed-in method and hope for the best...\r\n            bridgedMethod = bridgeMethod;\r\n        }\r\n        cache.put(cacheKey, bridgedMethod);\r\n    }\r\n    return bridgedMethod;\r\n}\n/**\r\n * Returns {@code true} if the supplied '{@code candidateMethod}' can be\r\n * considered a valid candidate for the {@link Method} that is {@link Method#isBridge() bridged}\r\n * by the supplied {@link Method bridge Method}. This method performs inexpensive\r\n * checks and can be used to quickly filter for a set of possible matches.\r\n */\r\nprivate static boolean isBridgedCandidateFor(Method candidateMethod, Method bridgeMethod) {\r\n    return (!candidateMethod.isBridge() && candidateMethod.getName().equals(bridgeMethod.getName()) && candidateMethod.getParameterCount() == bridgeMethod.getParameterCount());\r\n}\n/**\r\n * Searches for the bridged method in the given candidates.\r\n * @param candidateMethods the List of candidate Methods\r\n * @param bridgeMethod the bridge method\r\n * @return the bridged method, or {@code null} if none found\r\n */\r\n@Nullable\r\nprivate static Method searchCandidates(List<Method> candidateMethods, Method bridgeMethod) {\r\n    if (candidateMethods.isEmpty()) {\r\n        return null;\r\n    }\r\n    Method previousMethod = null;\r\n    boolean sameSig = true;\r\n    for (Method candidateMethod : candidateMethods) {\r\n        if (isBridgeMethodFor(bridgeMethod, candidateMethod, bridgeMethod.getDeclaringClass())) {\r\n            return candidateMethod;\r\n        } else if (previousMethod != null) {\r\n            sameSig = sameSig && Arrays.equals(candidateMethod.getGenericParameterTypes(), previousMethod.getGenericParameterTypes());\r\n        }\r\n        previousMethod = candidateMethod;\r\n    }\r\n    return (sameSig ? candidateMethods.get(0) : null);\r\n}\n/**\r\n * Determines whether the bridge {@link Method} is the bridge for the\r\n * supplied candidate {@link Method}.\r\n */\r\nstatic boolean isBridgeMethodFor(Method bridgeMethod, Method candidateMethod, Class<?> declaringClass) {\r\n    if (isResolvedTypeMatch(candidateMethod, bridgeMethod, declaringClass)) {\r\n        return true;\r\n    }\r\n    Method method = findGenericDeclaration(bridgeMethod);\r\n    return (method != null && isResolvedTypeMatch(method, candidateMethod, declaringClass));\r\n}\n/**\r\n * Returns {@code true} if the {@link Type} signature of both the supplied\r\n * {@link Method#getGenericParameterTypes() generic Method} and concrete {@link Method}\r\n * are equal after resolving all types against the declaringType, otherwise\r\n * returns {@code false}.\r\n */\r\nprivate static boolean isResolvedTypeMatch(Method genericMethod, Method candidateMethod, Class<?> declaringClass) {\r\n    Type[] genericParameters = genericMethod.getGenericParameterTypes();\r\n    if (genericParameters.length != candidateMethod.getParameterCount()) {\r\n        return false;\r\n    }\r\n    Class<?>[] candidateParameters = candidateMethod.getParameterTypes();\r\n    for (int i = 0; i < candidateParameters.length; i++) {\r\n        ResolvableType genericParameter = ResolvableType.forMethodParameter(genericMethod, i, declaringClass);\r\n        Class<?> candidateParameter = candidateParameters[i];\r\n        if (candidateParameter.isArray()) {\r\n            // An array type: compare the component type.\r\n            if (!candidateParameter.componentType().equals(genericParameter.getComponentType().toClass())) {\r\n                return false;\r\n            }\r\n        }\r\n        // A non-array type: compare the type itself.\r\n        if (!ClassUtils.resolvePrimitiveIfNecessary(candidateParameter).equals(ClassUtils.resolvePrimitiveIfNecessary(genericParameter.toClass()))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Searches for the generic {@link Method} declaration whose erased signature\r\n * matches that of the supplied bridge method.\r\n * @throws IllegalStateException if the generic declaration cannot be found\r\n */\r\n@Nullable\r\nprivate static Method findGenericDeclaration(Method bridgeMethod) {\r\n    if (!bridgeMethod.isBridge()) {\r\n        return bridgeMethod;\r\n    }\r\n    // Search parent types for method that has same signature as bridge.\r\n    Class<?> superclass = bridgeMethod.getDeclaringClass().getSuperclass();\r\n    while (superclass != null && Object.class != superclass) {\r\n        Method method = searchForMatch(superclass, bridgeMethod);\r\n        if (method != null && !method.isBridge()) {\r\n            return method;\r\n        }\r\n        superclass = superclass.getSuperclass();\r\n    }\r\n    Class<?>[] interfaces = ClassUtils.getAllInterfacesForClass(bridgeMethod.getDeclaringClass());\r\n    return searchInterfaces(interfaces, bridgeMethod);\r\n}\n@Nullable\r\nprivate static Method searchInterfaces(Class<?>[] interfaces, Method bridgeMethod) {\r\n    for (Class<?> ifc : interfaces) {\r\n        Method method = searchForMatch(ifc, bridgeMethod);\r\n        if (method != null && !method.isBridge()) {\r\n            return method;\r\n        } else {\r\n            method = searchInterfaces(ifc.getInterfaces(), bridgeMethod);\r\n            if (method != null) {\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\n/**\r\n * If the supplied {@link Class} has a declared {@link Method} whose signature matches\r\n * that of the supplied {@link Method}, then this matching {@link Method} is returned,\r\n * otherwise {@code null} is returned.\r\n */\r\n@Nullable\r\nprivate static Method searchForMatch(Class<?> type, Method bridgeMethod) {\r\n    try {\r\n        return type.getDeclaredMethod(bridgeMethod.getName(), bridgeMethod.getParameterTypes());\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}\n/**\r\n * Compare the signatures of the bridge method and the method which it bridges. If\r\n * the parameter and return types are the same, it is a 'visibility' bridge method\r\n * introduced in Java 6 to fix <a href=\"https://bugs.openjdk.org/browse/JDK-6342411\">\r\n * JDK-6342411</a>.\r\n * @return whether signatures match as described\r\n */\r\npublic static boolean isVisibilityBridgeMethodPair(Method bridgeMethod, Method bridgedMethod) {\r\n    if (bridgeMethod == bridgedMethod) {\r\n        // Same method: for common purposes, return true to proceed as if it was a visibility bridge.\r\n        return true;\r\n    }\r\n    if (ClassUtils.getUserClass(bridgeMethod.getDeclaringClass()) != bridgeMethod.getDeclaringClass()) {\r\n        // Method on generated subclass: return false to consistently ignore it for visibility purposes.\r\n        return false;\r\n    }\r\n    return (bridgeMethod.getReturnType().equals(bridgedMethod.getReturnType()) && bridgeMethod.getParameterCount() == bridgedMethod.getParameterCount() && Arrays.equals(bridgeMethod.getParameterTypes(), bridgedMethod.getParameterTypes()));\r\n}",
    "comment": "\n * Helper for resolving synthetic {@link Method#isBridge bridge Methods} to the\n * {@link Method} being bridged.\n *\n * <p>Given a synthetic {@link Method#isBridge bridge Method} returns the {@link Method}\n * being bridged. A bridge method may be created by the compiler when extending a\n * parameterized type whose methods have parameterized arguments. During runtime\n * invocation the bridge {@link Method} may be invoked and/or used via reflection.\n * When attempting to locate annotations on {@link Method Methods}, it is wise to check\n * for bridge {@link Method Methods} as appropriate and find the bridged {@link Method}.\n *\n * <p>See <a href=\"https://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5\">\n * The Java Language Specification</a> for more details on the use of bridge methods.\n *\n * @author Rob Harrop\n * @author Juergen Hoeller\n * @author Phillip Webb\n * @since 2.0\n "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Find the local original method for the supplied {@link Method bridge Method}.\r\n * <p>It is safe to call this method passing in a non-bridge {@link Method} instance.\r\n * In such a case, the supplied {@link Method} instance is returned directly to the caller.\r\n * Callers are <strong>not</strong> required to check for bridging before calling this method.\r\n * @param bridgeMethod the method to introspect against its declaring class\r\n * @return the original method (either the bridged method or the passed-in method\r\n * if no more specific one could be found)\r\n * @see #getMostSpecificMethod(Method, Class)\r\n */\r\npublic static Method findBridgedMethod(Method bridgeMethod) {\r\n    return resolveBridgeMethod(bridgeMethod, bridgeMethod.getDeclaringClass());\r\n}",
    "comment": "\n\t * Find the local original method for the supplied {@link Method bridge Method}.\n\t * <p>It is safe to call this method passing in a non-bridge {@link Method} instance.\n\t * In such a case, the supplied {@link Method} instance is returned directly to the caller.\n\t * Callers are <strong>not</strong> required to check for bridging before calling this method.\n\t * @param bridgeMethod the method to introspect against its declaring class\n\t * @return the original method (either the bridged method or the passed-in method\n\t * if no more specific one could be found)\n\t * @see #getMostSpecificMethod(Method, Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#getMostSpecificMethod(Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine the most specific method for the supplied {@link Method bridge Method}\r\n * in the given class hierarchy, even if not available on the local declaring class.\r\n * <p>This is effectively a combination of {@link ClassUtils#getMostSpecificMethod}\r\n * and {@link #findBridgedMethod}, resolving the original method even if no bridge\r\n * method has been generated at the same class hierarchy level (a known difference\r\n * between the Eclipse compiler and regular javac).\r\n * @param bridgeMethod the method to introspect against the given target class\r\n * @param targetClass the target class to find the most specific method on\r\n * @return the most specific method corresponding to the given bridge method\r\n * (can be the original method if no more specific one could be found)\r\n * @since 6.1.3\r\n * @see #findBridgedMethod\r\n * @see org.springframework.util.ClassUtils#getMostSpecificMethod\r\n */\r\npublic static Method getMostSpecificMethod(Method bridgeMethod, @Nullable Class<?> targetClass) {\r\n    if (targetClass != null && !ClassUtils.getUserClass(bridgeMethod.getDeclaringClass()).isAssignableFrom(targetClass) && !Proxy.isProxyClass(bridgeMethod.getDeclaringClass())) {\r\n        // From a different class hierarchy, and not a JDK or CGLIB proxy either -> return as-is.\r\n        return bridgeMethod;\r\n    }\r\n    Method specificMethod = ClassUtils.getMostSpecificMethod(bridgeMethod, targetClass);\r\n    return resolveBridgeMethod(specificMethod, (targetClass != null ? targetClass : specificMethod.getDeclaringClass()));\r\n}",
    "comment": "\n\t * Determine the most specific method for the supplied {@link Method bridge Method}\n\t * in the given class hierarchy, even if not available on the local declaring class.\n\t * <p>This is effectively a combination of {@link ClassUtils#getMostSpecificMethod}\n\t * and {@link #findBridgedMethod}, resolving the original method even if no bridge\n\t * method has been generated at the same class hierarchy level (a known difference\n\t * between the Eclipse compiler and regular javac).\n\t * @param bridgeMethod the method to introspect against the given target class\n\t * @param targetClass the target class to find the most specific method on\n\t * @return the most specific method corresponding to the given bridge method\n\t * (can be the original method if no more specific one could be found)\n\t * @since 6.1.3\n\t * @see #findBridgedMethod\n\t * @see org.springframework.util.ClassUtils#getMostSpecificMethod\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#resolveBridgeMethod(Method,Class<?>)",
    "entityType": "method",
    "code": "private static Method resolveBridgeMethod(Method bridgeMethod, Class<?> targetClass) {\r\n    boolean localBridge = (targetClass == bridgeMethod.getDeclaringClass());\r\n    Class<?> userClass = targetClass;\r\n    if (!bridgeMethod.isBridge() && localBridge) {\r\n        userClass = ClassUtils.getUserClass(targetClass);\r\n        if (userClass == targetClass) {\r\n            return bridgeMethod;\r\n        }\r\n    }\r\n    Object cacheKey = (localBridge ? bridgeMethod : new MethodClassKey(bridgeMethod, targetClass));\r\n    Method bridgedMethod = cache.get(cacheKey);\r\n    if (bridgedMethod == null) {\r\n        // Gather all methods with matching name and parameter size.\r\n        List<Method> candidateMethods = new ArrayList<>();\r\n        MethodFilter filter = (candidateMethod -> isBridgedCandidateFor(candidateMethod, bridgeMethod));\r\n        ReflectionUtils.doWithMethods(userClass, candidateMethods::add, filter);\r\n        if (!candidateMethods.isEmpty()) {\r\n            bridgedMethod = (candidateMethods.size() == 1 ? candidateMethods.get(0) : searchCandidates(candidateMethods, bridgeMethod));\r\n        }\r\n        if (bridgedMethod == null) {\r\n            // A bridge method was passed in but we couldn't find the bridged method.\r\n            // Let's proceed with the passed-in method and hope for the best...\r\n            bridgedMethod = bridgeMethod;\r\n        }\r\n        cache.put(cacheKey, bridgedMethod);\r\n    }\r\n    return bridgedMethod;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#isBridgedCandidateFor(Method,Method)",
    "entityType": "method",
    "code": "/**\r\n * Returns {@code true} if the supplied '{@code candidateMethod}' can be\r\n * considered a valid candidate for the {@link Method} that is {@link Method#isBridge() bridged}\r\n * by the supplied {@link Method bridge Method}. This method performs inexpensive\r\n * checks and can be used to quickly filter for a set of possible matches.\r\n */\r\nprivate static boolean isBridgedCandidateFor(Method candidateMethod, Method bridgeMethod) {\r\n    return (!candidateMethod.isBridge() && candidateMethod.getName().equals(bridgeMethod.getName()) && candidateMethod.getParameterCount() == bridgeMethod.getParameterCount());\r\n}",
    "comment": "\n\t * Returns {@code true} if the supplied '{@code candidateMethod}' can be\n\t * considered a valid candidate for the {@link Method} that is {@link Method#isBridge() bridged}\n\t * by the supplied {@link Method bridge Method}. This method performs inexpensive\n\t * checks and can be used to quickly filter for a set of possible matches.\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#searchCandidates(List<Method>,Method)",
    "entityType": "method",
    "code": "/**\r\n * Searches for the bridged method in the given candidates.\r\n * @param candidateMethods the List of candidate Methods\r\n * @param bridgeMethod the bridge method\r\n * @return the bridged method, or {@code null} if none found\r\n */\r\n@Nullable\r\nprivate static Method searchCandidates(List<Method> candidateMethods, Method bridgeMethod) {\r\n    if (candidateMethods.isEmpty()) {\r\n        return null;\r\n    }\r\n    Method previousMethod = null;\r\n    boolean sameSig = true;\r\n    for (Method candidateMethod : candidateMethods) {\r\n        if (isBridgeMethodFor(bridgeMethod, candidateMethod, bridgeMethod.getDeclaringClass())) {\r\n            return candidateMethod;\r\n        } else if (previousMethod != null) {\r\n            sameSig = sameSig && Arrays.equals(candidateMethod.getGenericParameterTypes(), previousMethod.getGenericParameterTypes());\r\n        }\r\n        previousMethod = candidateMethod;\r\n    }\r\n    return (sameSig ? candidateMethods.get(0) : null);\r\n}",
    "comment": "\n\t * Searches for the bridged method in the given candidates.\n\t * @param candidateMethods the List of candidate Methods\n\t * @param bridgeMethod the bridge method\n\t * @return the bridged method, or {@code null} if none found\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#isBridgeMethodFor(Method,Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determines whether the bridge {@link Method} is the bridge for the\r\n * supplied candidate {@link Method}.\r\n */\r\nstatic boolean isBridgeMethodFor(Method bridgeMethod, Method candidateMethod, Class<?> declaringClass) {\r\n    if (isResolvedTypeMatch(candidateMethod, bridgeMethod, declaringClass)) {\r\n        return true;\r\n    }\r\n    Method method = findGenericDeclaration(bridgeMethod);\r\n    return (method != null && isResolvedTypeMatch(method, candidateMethod, declaringClass));\r\n}",
    "comment": "\n\t * Determines whether the bridge {@link Method} is the bridge for the\n\t * supplied candidate {@link Method}.\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#isResolvedTypeMatch(Method,Method,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Returns {@code true} if the {@link Type} signature of both the supplied\r\n * {@link Method#getGenericParameterTypes() generic Method} and concrete {@link Method}\r\n * are equal after resolving all types against the declaringType, otherwise\r\n * returns {@code false}.\r\n */\r\nprivate static boolean isResolvedTypeMatch(Method genericMethod, Method candidateMethod, Class<?> declaringClass) {\r\n    Type[] genericParameters = genericMethod.getGenericParameterTypes();\r\n    if (genericParameters.length != candidateMethod.getParameterCount()) {\r\n        return false;\r\n    }\r\n    Class<?>[] candidateParameters = candidateMethod.getParameterTypes();\r\n    for (int i = 0; i < candidateParameters.length; i++) {\r\n        ResolvableType genericParameter = ResolvableType.forMethodParameter(genericMethod, i, declaringClass);\r\n        Class<?> candidateParameter = candidateParameters[i];\r\n        if (candidateParameter.isArray()) {\r\n            // An array type: compare the component type.\r\n            if (!candidateParameter.componentType().equals(genericParameter.getComponentType().toClass())) {\r\n                return false;\r\n            }\r\n        }\r\n        // A non-array type: compare the type itself.\r\n        if (!ClassUtils.resolvePrimitiveIfNecessary(candidateParameter).equals(ClassUtils.resolvePrimitiveIfNecessary(genericParameter.toClass()))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Returns {@code true} if the {@link Type} signature of both the supplied\n\t * {@link Method#getGenericParameterTypes() generic Method} and concrete {@link Method}\n\t * are equal after resolving all types against the declaringType, otherwise\n\t * returns {@code false}.\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#findGenericDeclaration(Method)",
    "entityType": "method",
    "code": "/**\r\n * Searches for the generic {@link Method} declaration whose erased signature\r\n * matches that of the supplied bridge method.\r\n * @throws IllegalStateException if the generic declaration cannot be found\r\n */\r\n@Nullable\r\nprivate static Method findGenericDeclaration(Method bridgeMethod) {\r\n    if (!bridgeMethod.isBridge()) {\r\n        return bridgeMethod;\r\n    }\r\n    // Search parent types for method that has same signature as bridge.\r\n    Class<?> superclass = bridgeMethod.getDeclaringClass().getSuperclass();\r\n    while (superclass != null && Object.class != superclass) {\r\n        Method method = searchForMatch(superclass, bridgeMethod);\r\n        if (method != null && !method.isBridge()) {\r\n            return method;\r\n        }\r\n        superclass = superclass.getSuperclass();\r\n    }\r\n    Class<?>[] interfaces = ClassUtils.getAllInterfacesForClass(bridgeMethod.getDeclaringClass());\r\n    return searchInterfaces(interfaces, bridgeMethod);\r\n}",
    "comment": "\n\t * Searches for the generic {@link Method} declaration whose erased signature\n\t * matches that of the supplied bridge method.\n\t * @throws IllegalStateException if the generic declaration cannot be found\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#searchInterfaces(Class<?>[],Method)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Method searchInterfaces(Class<?>[] interfaces, Method bridgeMethod) {\r\n    for (Class<?> ifc : interfaces) {\r\n        Method method = searchForMatch(ifc, bridgeMethod);\r\n        if (method != null && !method.isBridge()) {\r\n            return method;\r\n        } else {\r\n            method = searchInterfaces(ifc.getInterfaces(), bridgeMethod);\r\n            if (method != null) {\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#searchForMatch(Class<?>,Method)",
    "entityType": "method",
    "code": "/**\r\n * If the supplied {@link Class} has a declared {@link Method} whose signature matches\r\n * that of the supplied {@link Method}, then this matching {@link Method} is returned,\r\n * otherwise {@code null} is returned.\r\n */\r\n@Nullable\r\nprivate static Method searchForMatch(Class<?> type, Method bridgeMethod) {\r\n    try {\r\n        return type.getDeclaredMethod(bridgeMethod.getName(), bridgeMethod.getParameterTypes());\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * If the supplied {@link Class} has a declared {@link Method} whose signature matches\n\t * that of the supplied {@link Method}, then this matching {@link Method} is returned,\n\t * otherwise {@code null} is returned.\n\t "
  },
  {
    "entityId": "org.springframework.core.BridgeMethodResolver#isVisibilityBridgeMethodPair(Method,Method)",
    "entityType": "method",
    "code": "/**\r\n * Compare the signatures of the bridge method and the method which it bridges. If\r\n * the parameter and return types are the same, it is a 'visibility' bridge method\r\n * introduced in Java 6 to fix <a href=\"https://bugs.openjdk.org/browse/JDK-6342411\">\r\n * JDK-6342411</a>.\r\n * @return whether signatures match as described\r\n */\r\npublic static boolean isVisibilityBridgeMethodPair(Method bridgeMethod, Method bridgedMethod) {\r\n    if (bridgeMethod == bridgedMethod) {\r\n        // Same method: for common purposes, return true to proceed as if it was a visibility bridge.\r\n        return true;\r\n    }\r\n    if (ClassUtils.getUserClass(bridgeMethod.getDeclaringClass()) != bridgeMethod.getDeclaringClass()) {\r\n        // Method on generated subclass: return false to consistently ignore it for visibility purposes.\r\n        return false;\r\n    }\r\n    return (bridgeMethod.getReturnType().equals(bridgedMethod.getReturnType()) && bridgeMethod.getParameterCount() == bridgedMethod.getParameterCount() && Arrays.equals(bridgeMethod.getParameterTypes(), bridgedMethod.getParameterTypes()));\r\n}",
    "comment": "\n\t * Compare the signatures of the bridge method and the method which it bridges. If\n\t * the parameter and return types are the same, it is a 'visibility' bridge method\n\t * introduced in Java 6 to fix <a href=\"https://bugs.openjdk.org/browse/JDK-6342411\">\n\t * JDK-6342411</a>.\n\t * @return whether signatures match as described\n\t "
  }
]