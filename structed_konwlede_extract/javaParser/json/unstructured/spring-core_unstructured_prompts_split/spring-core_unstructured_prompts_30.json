[
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#isAllocated()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAllocated() {\r\n    DataBuffer delegate = dataBuffer();\r\n    return delegate instanceof PooledDataBuffer && ((PooledDataBuffer) delegate).isAllocated();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#retain()",
    "entityType": "method",
    "code": "@Override\r\npublic PooledDataBuffer retain() {\r\n    DataBufferUtils.retain(dataBuffer());\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#touch(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic PooledDataBuffer touch(Object hint) {\r\n    DataBufferUtils.touch(dataBuffer(), hint);\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#release()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean release() {\r\n    DataBufferUtils.release(dataBuffer());\r\n    return isAllocated();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#factory()",
    "entityType": "method",
    "code": "@Override\r\npublic LeakAwareDataBufferFactory factory() {\r\n    return this.dataBufferFactory;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return String.format(\"LeakAwareDataBuffer (%s)\", dataBuffer());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Symbol",
    "entityType": "class",
    "code": "// Tag values for the constant pool entries (using the same order as in the JVMS).\r\n/**\r\n * The tag value of CONSTANT_Class_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_CLASS_TAG = 7;\n/**\r\n * The tag value of CONSTANT_Fieldref_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_FIELDREF_TAG = 9;\n/**\r\n * The tag value of CONSTANT_Methodref_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_METHODREF_TAG = 10;\n/**\r\n * The tag value of CONSTANT_InterfaceMethodref_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_INTERFACE_METHODREF_TAG = 11;\n/**\r\n * The tag value of CONSTANT_String_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_STRING_TAG = 8;\n/**\r\n * The tag value of CONSTANT_Integer_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_INTEGER_TAG = 3;\n/**\r\n * The tag value of CONSTANT_Float_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_FLOAT_TAG = 4;\n/**\r\n * The tag value of CONSTANT_Long_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_LONG_TAG = 5;\n/**\r\n * The tag value of CONSTANT_Double_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_DOUBLE_TAG = 6;\n/**\r\n * The tag value of CONSTANT_NameAndType_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_NAME_AND_TYPE_TAG = 12;\n/**\r\n * The tag value of CONSTANT_Utf8_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_UTF8_TAG = 1;\n/**\r\n * The tag value of CONSTANT_MethodHandle_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_METHOD_HANDLE_TAG = 15;\n/**\r\n * The tag value of CONSTANT_MethodType_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_METHOD_TYPE_TAG = 16;\n/**\r\n * The tag value of CONSTANT_Dynamic_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_DYNAMIC_TAG = 17;\n/**\r\n * The tag value of CONSTANT_InvokeDynamic_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_INVOKE_DYNAMIC_TAG = 18;\n/**\r\n * The tag value of CONSTANT_Module_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_MODULE_TAG = 19;\n/**\r\n * The tag value of CONSTANT_Package_info JVMS structures.\r\n */\r\nstatic final int CONSTANT_PACKAGE_TAG = 20;\n// Tag values for the BootstrapMethods attribute entries (ASM specific tag).\r\n/**\r\n * The tag value of the BootstrapMethods attribute entries.\r\n */\r\nstatic final int BOOTSTRAP_METHOD_TAG = 64;\n// Tag values for the type table entries (ASM specific tags).\r\n/**\r\n * The tag value of a normal type entry in the (ASM specific) type table of a class.\r\n */\r\nstatic final int TYPE_TAG = 128;\n/**\r\n * The tag value of an uninitialized type entry in the type table of a class. This type is used\r\n * for the normal case where the NEW instruction is before the &lt;init&gt; constructor call (in\r\n * bytecode offset order), i.e. when the label of the NEW instruction is resolved when the\r\n * constructor call is visited. If the NEW instruction is after the constructor call, use the\r\n * {@link #FORWARD_UNINITIALIZED_TYPE_TAG} tag value instead.\r\n */\r\nstatic final int UNINITIALIZED_TYPE_TAG = 129;\n/**\r\n * The tag value of an uninitialized type entry in the type table of a class. This type is used\r\n * for the unusual case where the NEW instruction is after the &lt;init&gt; constructor call (in\r\n * bytecode offset order), i.e. when the label of the NEW instruction is not resolved when the\r\n * constructor call is visited. If the NEW instruction is before the constructor call, use the\r\n * {@link #UNINITIALIZED_TYPE_TAG} tag value instead.\r\n */\r\nstatic final int FORWARD_UNINITIALIZED_TYPE_TAG = 130;\n/**\r\n * The tag value of a merged type entry in the (ASM specific) type table of a class.\r\n */\r\nstatic final int MERGED_TYPE_TAG = 131;\n// Instance fields.\r\n/**\r\n * The index of this symbol in the constant pool, in the BootstrapMethods attribute, or in the\r\n * (ASM specific) type table of a class (depending on the {@link #tag} value).\r\n */\r\nfinal int index;\n/**\r\n * A tag indicating the type of this symbol. Must be one of the static tag values defined in this\r\n * class.\r\n */\r\nfinal int tag;\n/**\r\n * The internal name of the owner class of this symbol. Only used for {@link\r\n * #CONSTANT_FIELDREF_TAG}, {@link #CONSTANT_METHODREF_TAG}, {@link\r\n * #CONSTANT_INTERFACE_METHODREF_TAG}, and {@link #CONSTANT_METHOD_HANDLE_TAG} symbols.\r\n */\r\nfinal String owner;\n/**\r\n * The name of the class field or method corresponding to this symbol. Only used for {@link\r\n * #CONSTANT_FIELDREF_TAG}, {@link #CONSTANT_METHODREF_TAG}, {@link\r\n * #CONSTANT_INTERFACE_METHODREF_TAG}, {@link #CONSTANT_NAME_AND_TYPE_TAG}, {@link\r\n * #CONSTANT_METHOD_HANDLE_TAG}, {@link #CONSTANT_DYNAMIC_TAG} and {@link\r\n * #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.\r\n */\r\nfinal String name;\n/**\r\n * The string value of this symbol. This is:\r\n *\r\n * <ul>\r\n *   <li>a field or method descriptor for {@link #CONSTANT_FIELDREF_TAG}, {@link\r\n *       #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG}, {@link\r\n *       #CONSTANT_NAME_AND_TYPE_TAG}, {@link #CONSTANT_METHOD_HANDLE_TAG}, {@link\r\n *       #CONSTANT_METHOD_TYPE_TAG}, {@link #CONSTANT_DYNAMIC_TAG} and {@link\r\n *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,\r\n *   <li>an arbitrary string for {@link #CONSTANT_UTF8_TAG} and {@link #CONSTANT_STRING_TAG}\r\n *       symbols,\r\n *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG}, {@link\r\n *       #UNINITIALIZED_TYPE_TAG} and {@link #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,\r\n *   <li>{@literal null} for the other types of symbol.\r\n * </ul>\r\n */\r\nfinal String value;\n/**\r\n * The numeric value of this symbol. This is:\r\n *\r\n * <ul>\r\n *   <li>the symbol's value for {@link #CONSTANT_INTEGER_TAG},{@link #CONSTANT_FLOAT_TAG}, {@link\r\n *       #CONSTANT_LONG_TAG}, {@link #CONSTANT_DOUBLE_TAG},\r\n *   <li>the CONSTANT_MethodHandle_info reference_kind field value for {@link\r\n *       #CONSTANT_METHOD_HANDLE_TAG} symbols (or this value left shifted by 8 bits for\r\n *       reference_kind values larger than or equal to H_INVOKEVIRTUAL and if the method owner is\r\n *       an interface),\r\n *   <li>the CONSTANT_InvokeDynamic_info bootstrap_method_attr_index field value for {@link\r\n *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,\r\n *   <li>the offset of a bootstrap method in the BootstrapMethods boostrap_methods array, for\r\n *       {@link #CONSTANT_DYNAMIC_TAG} or {@link #BOOTSTRAP_METHOD_TAG} symbols,\r\n *   <li>the bytecode offset of the NEW instruction that created an {@link\r\n *       Frame#ITEM_UNINITIALIZED} type for {@link #UNINITIALIZED_TYPE_TAG} symbols,\r\n *   <li>the index of the {@link Label} (in the {@link SymbolTable#labelTable} table) of the NEW\r\n *       instruction that created an {@link Frame#ITEM_UNINITIALIZED} type for {@link\r\n *       #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,\r\n *   <li>the indices (in the class' type table) of two {@link #TYPE_TAG} source types for {@link\r\n *       #MERGED_TYPE_TAG} symbols,\r\n *   <li>0 for the other types of symbol.\r\n * </ul>\r\n */\r\nfinal long data;\n/**\r\n * Additional information about this symbol, generally computed lazily. <i>Warning: the value of\r\n * this field is ignored when comparing Symbol instances</i> (to avoid duplicate entries in a\r\n * SymbolTable). Therefore, this field should only contain data that can be computed from the\r\n * other fields of this class. It contains:\r\n *\r\n * <ul>\r\n *   <li>the {@link Type#getArgumentsAndReturnSizes} of the symbol's method descriptor for {@link\r\n *       #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link\r\n *       #CONSTANT_INVOKE_DYNAMIC_TAG} symbols,\r\n *   <li>the index in the InnerClasses_attribute 'classes' array (plus one) corresponding to this\r\n *       class, for {@link #CONSTANT_CLASS_TAG} symbols,\r\n *   <li>the index (in the class' type table) of the merged type of the two source types for\r\n *       {@link #MERGED_TYPE_TAG} symbols,\r\n *   <li>0 for the other types of symbol, or if this field has not been computed yet.\r\n * </ul>\r\n */\r\nint info;\n/**\r\n * Constructs a new Symbol. This constructor can't be used directly because the Symbol class is\r\n * abstract. Instead, use the factory methods of the {@link SymbolTable} class.\r\n *\r\n * @param index the symbol index in the constant pool, in the BootstrapMethods attribute, or in\r\n *     the (ASM specific) type table of a class (depending on 'tag').\r\n * @param tag the symbol type. Must be one of the static tag values defined in this class.\r\n * @param owner The internal name of the symbol's owner class. Maybe {@literal null}.\r\n * @param name The name of the symbol's corresponding class field or method. Maybe {@literal\r\n *     null}.\r\n * @param value The string value of this symbol. Maybe {@literal null}.\r\n * @param data The numeric value of this symbol.\r\n */\r\nSymbol(final int index, final int tag, final String owner, final String name, final String value, final long data) {\r\n    this.index = index;\r\n    this.tag = tag;\r\n    this.owner = owner;\r\n    this.name = name;\r\n    this.value = value;\r\n    this.data = data;\r\n}\n/**\r\n * Returns the result {@link Type#getArgumentsAndReturnSizes} on {@link #value}.\r\n *\r\n * @return the result {@link Type#getArgumentsAndReturnSizes} on {@link #value} (memoized in\r\n *     {@link #info} for efficiency). This should only be used for {@link\r\n *     #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link\r\n *     #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.\r\n */\r\nint getArgumentsAndReturnSizes() {\r\n    if (info == 0) {\r\n        info = Type.getArgumentsAndReturnSizes(value);\r\n    }\r\n    return info;\r\n}",
    "comment": "\n * An entry of the constant pool, of the BootstrapMethods attribute, or of the (ASM specific) type\n * table of a class.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS\n *     4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n *     4.7.23</a>\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.Symbol#getArgumentsAndReturnSizes()",
    "entityType": "method",
    "code": "/**\r\n * Returns the result {@link Type#getArgumentsAndReturnSizes} on {@link #value}.\r\n *\r\n * @return the result {@link Type#getArgumentsAndReturnSizes} on {@link #value} (memoized in\r\n *     {@link #info} for efficiency). This should only be used for {@link\r\n *     #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link\r\n *     #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.\r\n */\r\nint getArgumentsAndReturnSizes() {\r\n    if (info == 0) {\r\n        info = Type.getArgumentsAndReturnSizes(value);\r\n    }\r\n    return info;\r\n}",
    "comment": "\n   * Returns the result {@link Type#getArgumentsAndReturnSizes} on {@link #value}.\n   *\n   * @return the result {@link Type#getArgumentsAndReturnSizes} on {@link #value} (memoized in\n   *     {@link #info} for efficiency). This should only be used for {@link\n   *     #CONSTANT_METHODREF_TAG}, {@link #CONSTANT_INTERFACE_METHODREF_TAG} and {@link\n   *     #CONSTANT_INVOKE_DYNAMIC_TAG} symbols.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory",
    "entityType": "class",
    "code": "private static final Log logger = LogFactory.getLog(LeakAwareDataBufferFactory.class);\nprivate final DataBufferFactory delegate;\nprivate final List<LeakAwareDataBuffer> created = new ArrayList<>();\nprivate final AtomicBoolean trackCreated = new AtomicBoolean(true);\n/**\r\n * Creates a new {@code LeakAwareDataBufferFactory} by wrapping a\r\n * {@link DefaultDataBufferFactory}.\r\n */\r\npublic LeakAwareDataBufferFactory() {\r\n    this(new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT));\r\n}\n/**\r\n * Creates a new {@code LeakAwareDataBufferFactory} by wrapping the given delegate.\r\n * @param delegate the delegate buffer factory to wrap.\r\n */\r\npublic LeakAwareDataBufferFactory(DataBufferFactory delegate) {\r\n    Assert.notNull(delegate, \"Delegate must not be null\");\r\n    this.delegate = delegate;\r\n}\n/**\r\n * Checks whether all the data buffers allocated by this factory have also been released.\r\n * If not, then an {@link AssertionError} is thrown. Typically used from a JUnit <em>after</em>\r\n * method.\r\n */\r\npublic void checkForLeaks() {\r\n    checkForLeaks(Duration.ofSeconds(0));\r\n}\n/**\r\n * Variant of {@link #checkForLeaks()} with the option to wait for buffer release.\r\n * @param timeout how long to wait for buffers to be released; 0 for no waiting\r\n */\r\npublic void checkForLeaks(Duration timeout) {\r\n    this.trackCreated.set(false);\r\n    Instant start = Instant.now();\r\n    while (true) {\r\n        if (this.created.stream().noneMatch(LeakAwareDataBuffer::isAllocated)) {\r\n            return;\r\n        }\r\n        if (Instant.now().isBefore(start.plus(timeout))) {\r\n            try {\r\n                Thread.sleep(50);\r\n            } catch (InterruptedException ex) {\r\n                // ignore\r\n            }\r\n            continue;\r\n        }\r\n        List<AssertionError> errors = this.created.stream().filter(LeakAwareDataBuffer::isAllocated).map(LeakAwareDataBuffer::leakError).toList();\r\n        errors.forEach(it -> logger.error(\"Leaked error: \", it));\r\n        throw new AssertionError(errors.size() + \" buffer leaks detected (see logs above)\");\r\n    }\r\n}\n@Override\r\n@Deprecated\r\npublic DataBuffer allocateBuffer() {\r\n    return createLeakAwareDataBuffer(this.delegate.allocateBuffer());\r\n}\n@Override\r\npublic DataBuffer allocateBuffer(int initialCapacity) {\r\n    return createLeakAwareDataBuffer(this.delegate.allocateBuffer(initialCapacity));\r\n}\nprivate DataBuffer createLeakAwareDataBuffer(DataBuffer delegateBuffer) {\r\n    LeakAwareDataBuffer dataBuffer = new LeakAwareDataBuffer(delegateBuffer, this);\r\n    if (this.trackCreated.get()) {\r\n        this.created.add(dataBuffer);\r\n    }\r\n    return dataBuffer;\r\n}\n@Override\r\npublic DataBuffer wrap(ByteBuffer byteBuffer) {\r\n    return this.delegate.wrap(byteBuffer);\r\n}\n@Override\r\npublic DataBuffer wrap(byte[] bytes) {\r\n    return this.delegate.wrap(bytes);\r\n}\n@Override\r\npublic DataBuffer join(List<? extends DataBuffer> dataBuffers) {\r\n    // Remove LeakAwareDataBuffer wrapper so delegate can find native buffers\r\n    dataBuffers = dataBuffers.stream().map(o -> o instanceof LeakAwareDataBuffer ? ((LeakAwareDataBuffer) o).dataBuffer() : o).toList();\r\n    return new LeakAwareDataBuffer(this.delegate.join(dataBuffers), this);\r\n}\n@Override\r\npublic boolean isDirect() {\r\n    return this.delegate.isDirect();\r\n}",
    "comment": "\n * Implementation of the {@code DataBufferFactory} interface that keeps track of\n * memory leaks.\n * <p>Useful for unit tests that handle data buffers. Simply inherit from\n * {@link AbstractLeakCheckingTests} or call {@link #checkForLeaks()} in\n * a JUnit <em>after</em> method yourself, and any buffers that have not been\n * released will result in an {@link AssertionError}.\n *\n * @author Arjen Poutsma\n * @see LeakAwareDataBufferFactory\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#checkForLeaks()",
    "entityType": "method",
    "code": "/**\r\n * Checks whether all the data buffers allocated by this factory have also been released.\r\n * If not, then an {@link AssertionError} is thrown. Typically used from a JUnit <em>after</em>\r\n * method.\r\n */\r\npublic void checkForLeaks() {\r\n    checkForLeaks(Duration.ofSeconds(0));\r\n}",
    "comment": "\n\t * Checks whether all the data buffers allocated by this factory have also been released.\n\t * If not, then an {@link AssertionError} is thrown. Typically used from a JUnit <em>after</em>\n\t * method.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#checkForLeaks(Duration)",
    "entityType": "method",
    "code": "/**\r\n * Variant of {@link #checkForLeaks()} with the option to wait for buffer release.\r\n * @param timeout how long to wait for buffers to be released; 0 for no waiting\r\n */\r\npublic void checkForLeaks(Duration timeout) {\r\n    this.trackCreated.set(false);\r\n    Instant start = Instant.now();\r\n    while (true) {\r\n        if (this.created.stream().noneMatch(LeakAwareDataBuffer::isAllocated)) {\r\n            return;\r\n        }\r\n        if (Instant.now().isBefore(start.plus(timeout))) {\r\n            try {\r\n                Thread.sleep(50);\r\n            } catch (InterruptedException ex) {\r\n                // ignore\r\n            }\r\n            continue;\r\n        }\r\n        List<AssertionError> errors = this.created.stream().filter(LeakAwareDataBuffer::isAllocated).map(LeakAwareDataBuffer::leakError).toList();\r\n        errors.forEach(it -> logger.error(\"Leaked error: \", it));\r\n        throw new AssertionError(errors.size() + \" buffer leaks detected (see logs above)\");\r\n    }\r\n}",
    "comment": "\n\t * Variant of {@link #checkForLeaks()} with the option to wait for buffer release.\n\t * @param timeout how long to wait for buffers to be released; 0 for no waiting\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#allocateBuffer()",
    "entityType": "method",
    "code": "@Override\r\n@Deprecated\r\npublic DataBuffer allocateBuffer() {\r\n    return createLeakAwareDataBuffer(this.delegate.allocateBuffer());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#allocateBuffer(int)",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer allocateBuffer(int initialCapacity) {\r\n    return createLeakAwareDataBuffer(this.delegate.allocateBuffer(initialCapacity));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#createLeakAwareDataBuffer(DataBuffer)",
    "entityType": "method",
    "code": "private DataBuffer createLeakAwareDataBuffer(DataBuffer delegateBuffer) {\r\n    LeakAwareDataBuffer dataBuffer = new LeakAwareDataBuffer(delegateBuffer, this);\r\n    if (this.trackCreated.get()) {\r\n        this.created.add(dataBuffer);\r\n    }\r\n    return dataBuffer;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#wrap(ByteBuffer)",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer wrap(ByteBuffer byteBuffer) {\r\n    return this.delegate.wrap(byteBuffer);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#wrap(byte[])",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer wrap(byte[] bytes) {\r\n    return this.delegate.wrap(bytes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#join(List<? extends DataBuffer>)",
    "entityType": "method",
    "code": "@Override\r\npublic DataBuffer join(List<? extends DataBuffer> dataBuffers) {\r\n    // Remove LeakAwareDataBuffer wrapper so delegate can find native buffers\r\n    dataBuffers = dataBuffers.stream().map(o -> o instanceof LeakAwareDataBuffer ? ((LeakAwareDataBuffer) o).dataBuffer() : o).toList();\r\n    return new LeakAwareDataBuffer(this.delegate.join(dataBuffers), this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBufferFactory#isDirect()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isDirect() {\r\n    return this.delegate.isDirect();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.ResourceTestUtils",
    "entityType": "class",
    "code": "/**\r\n * Load a {@link ClassPathResource} qualified by the simple name of clazz,\r\n * and relative to the package for clazz.\r\n * <p>Example: given a clazz 'com.foo.BarTests' and a resourceSuffix of 'context.xml',\r\n * this method will return a ClassPathResource representing com/foo/BarTests-context.xml\r\n * <p>Intended for use loading context configuration XML files within JUnit tests.\r\n */\r\npublic static ClassPathResource qualifiedResource(Class<?> clazz, String resourceSuffix) {\r\n    return new ClassPathResource(String.format(\"%s-%s\", clazz.getSimpleName(), resourceSuffix), clazz);\r\n}",
    "comment": "\n * Convenience utilities for common operations with test resources.\n *\n * @author Chris Beams\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.ResourceTestUtils#qualifiedResource(Class<?>,String)",
    "entityType": "method",
    "code": "/**\r\n * Load a {@link ClassPathResource} qualified by the simple name of clazz,\r\n * and relative to the package for clazz.\r\n * <p>Example: given a clazz 'com.foo.BarTests' and a resourceSuffix of 'context.xml',\r\n * this method will return a ClassPathResource representing com/foo/BarTests-context.xml\r\n * <p>Intended for use loading context configuration XML files within JUnit tests.\r\n */\r\npublic static ClassPathResource qualifiedResource(Class<?> clazz, String resourceSuffix) {\r\n    return new ClassPathResource(String.format(\"%s-%s\", clazz.getSimpleName(), resourceSuffix), clazz);\r\n}",
    "comment": "\n\t * Load a {@link ClassPathResource} qualified by the simple name of clazz,\n\t * and relative to the package for clazz.\n\t * <p>Example: given a clazz 'com.foo.BarTests' and a resourceSuffix of 'context.xml',\n\t * this method will return a ClassPathResource representing com/foo/BarTests-context.xml\n\t * <p>Intended for use loading context configuration XML files within JUnit tests.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.SerializationTestUtils",
    "entityType": "class",
    "code": "public static void testSerialization(Object o) throws IOException {\r\n    OutputStream baos = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(o);\r\n    }\r\n}\npublic static boolean isSerializable(Object o) throws IOException {\r\n    try {\r\n        testSerialization(o);\r\n        return true;\r\n    } catch (NotSerializableException ex) {\r\n        return false;\r\n    }\r\n}\n@SuppressWarnings(\"unchecked\")\r\npublic static <T> T serializeAndDeserialize(T o) throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(o);\r\n        oos.flush();\r\n    }\r\n    byte[] bytes = baos.toByteArray();\r\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\r\n    try (ObjectInputStream ois = new ObjectInputStream(is)) {\r\n        return (T) ois.readObject();\r\n    }\r\n}\npublic static <T> T serializeAndDeserialize(Object o, Class<T> expectedType) throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(o);\r\n        oos.flush();\r\n    }\r\n    byte[] bytes = baos.toByteArray();\r\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\r\n    try (ObjectInputStream ois = new ObjectInputStream(is)) {\r\n        return expectedType.cast(ois.readObject());\r\n    }\r\n}",
    "comment": "\n * Utilities for testing serializability of objects.\n *\n * <p>Exposes static methods for use in other test cases.\n *\n * @author Rod Johnson\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.io.SerializationTestUtils#testSerialization(Object)",
    "entityType": "method",
    "code": "public static void testSerialization(Object o) throws IOException {\r\n    OutputStream baos = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(o);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.SerializationTestUtils#isSerializable(Object)",
    "entityType": "method",
    "code": "public static boolean isSerializable(Object o) throws IOException {\r\n    try {\r\n        testSerialization(o);\r\n        return true;\r\n    } catch (NotSerializableException ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.SerializationTestUtils#serializeAndDeserialize(T)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\npublic static <T> T serializeAndDeserialize(T o) throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(o);\r\n        oos.flush();\r\n    }\r\n    byte[] bytes = baos.toByteArray();\r\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\r\n    try (ObjectInputStream ois = new ObjectInputStream(is)) {\r\n        return (T) ois.readObject();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.io.SerializationTestUtils#serializeAndDeserialize(Object,Class<T>)",
    "entityType": "method",
    "code": "public static <T> T serializeAndDeserialize(Object o, Class<T> expectedType) throws IOException, ClassNotFoundException {\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\r\n        oos.writeObject(o);\r\n        oos.flush();\r\n    }\r\n    byte[] bytes = baos.toByteArray();\r\n    ByteArrayInputStream is = new ByteArrayInputStream(bytes);\r\n    try (ObjectInputStream ois = new ObjectInputStream(is)) {\r\n        return expectedType.cast(ois.readObject());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.JavaUtilLoggingConfigurer",
    "entityType": "class",
    "code": "public static final String JUL_TEST_PROPERTIES_FILE = \"jul-test.properties\";\n@Override\r\npublic void testPlanExecutionStarted(TestPlan testPlan) {\r\n    try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream(JUL_TEST_PROPERTIES_FILE)) {\r\n        LogManager.getLogManager().readConfiguration(inputStream);\r\n    } catch (Exception ex) {\r\n        System.err.println(\"WARNING: failed to configure Java Util Logging from classpath resource \" + JUL_TEST_PROPERTIES_FILE);\r\n        System.err.println(ex);\r\n    }\r\n}",
    "comment": "\n * JUnit Platform {@link TestExecutionListener} that configures Java Util Logging\n * (JUL) from a file named {@code jul-test.properties} in the root of the classpath.\n *\n * <p>This allows for projects to configure JUL for a test suite, analogous to\n * log4j's support via {@code log4j2-test.xml}.\n *\n * <p>This listener can be automatically registered on the JUnit Platform by\n * adding the fully qualified name of this class to a file named\n * {@code /META-INF/services/org.junit.platform.launcher.TestExecutionListener}\n * &mdash; for example, under {@code src/test/resources}.\n *\n * @author Sam Brannen\n * @since 5.2.2\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.JavaUtilLoggingConfigurer#testPlanExecutionStarted(TestPlan)",
    "entityType": "method",
    "code": "@Override\r\npublic void testPlanExecutionStarted(TestPlan testPlan) {\r\n    try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream(JUL_TEST_PROPERTIES_FILE)) {\r\n        LogManager.getLogManager().readConfiguration(inputStream);\r\n    } catch (Exception ex) {\r\n        System.err.println(\"WARNING: failed to configure Java Util Logging from classpath resource \" + JUL_TEST_PROPERTIES_FILE);\r\n        System.err.println(ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable",
    "entityType": "class",
    "code": "/**\r\n * The ClassWriter to which this SymbolTable belongs. This is only used to get access to {@link\r\n * ClassWriter#getCommonSuperClass} and to serialize custom attributes with {@link\r\n * Attribute#write}.\r\n */\r\nfinal ClassWriter classWriter;\n/**\r\n * The ClassReader from which this SymbolTable was constructed, or {@literal null} if it was\r\n * constructed from scratch.\r\n */\r\nprivate final ClassReader sourceClassReader;\n/**\r\n * The major version number of the class to which this symbol table belongs.\r\n */\r\nprivate int majorVersion;\n/**\r\n * The internal name of the class to which this symbol table belongs.\r\n */\r\nprivate String className;\n/**\r\n * The total number of {@link Entry} instances in {@link #entries}. This includes entries that are\r\n * accessible (recursively) via {@link Entry#next}.\r\n */\r\nprivate int entryCount;\n/**\r\n * A hash set of all the entries in this SymbolTable (this includes the constant pool entries, the\r\n * bootstrap method entries and the type table entries). Each {@link Entry} instance is stored at\r\n * the array index given by its hash code modulo the array size. If several entries must be stored\r\n * at the same array index, they are linked together via their {@link Entry#next} field. The\r\n * factory methods of this class make sure that this table does not contain duplicated entries.\r\n */\r\nprivate Entry[] entries;\n/**\r\n * The number of constant pool items in {@link #constantPool}, plus 1. The first constant pool\r\n * item has index 1, and long and double items count for two items.\r\n */\r\nprivate int constantPoolCount;\n/**\r\n * The content of the ClassFile's constant_pool JVMS structure corresponding to this SymbolTable.\r\n * The ClassFile's constant_pool_count field is <i>not</i> included.\r\n */\r\nprivate ByteVector constantPool;\n/**\r\n * The number of bootstrap methods in {@link #bootstrapMethods}. Corresponds to the\r\n * BootstrapMethods_attribute's num_bootstrap_methods field value.\r\n */\r\nprivate int bootstrapMethodCount;\n/**\r\n * The content of the BootstrapMethods attribute 'bootstrap_methods' array corresponding to this\r\n * SymbolTable. Note that the first 6 bytes of the BootstrapMethods_attribute, and its\r\n * num_bootstrap_methods field, are <i>not</i> included.\r\n */\r\nprivate ByteVector bootstrapMethods;\n/**\r\n * The actual number of elements in {@link #typeTable}. These elements are stored from index 0 to\r\n * typeCount (excluded). The other array entries are empty.\r\n */\r\nprivate int typeCount;\n/**\r\n * An ASM specific type table used to temporarily store internal names that will not necessarily\r\n * be stored in the constant pool. This type table is used by the control flow and data flow\r\n * analysis algorithm used to compute stack map frames from scratch. This array stores {@link\r\n * Symbol#TYPE_TAG}, {@link Symbol#UNINITIALIZED_TYPE_TAG},{@link\r\n * Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} and {@link Symbol#MERGED_TYPE_TAG} entries. The type\r\n * symbol at index {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\r\n */\r\nprivate Entry[] typeTable;\n/**\r\n * The actual number of {@link LabelEntry} in {@link #labelTable}. These elements are stored from\r\n * index 0 to labelCount (excluded). The other array entries are empty. These label entries are\r\n * also stored in the {@link #labelEntries} hash set.\r\n */\r\nprivate int labelCount;\n/**\r\n * The labels corresponding to the \"forward uninitialized\" types in the ASM specific {@link\r\n * typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}). The label entry at index {@code\r\n * i} has its {@link LabelEntry#index} equal to {@code i} (and vice versa).\r\n */\r\nprivate LabelEntry[] labelTable;\n/**\r\n * A hash set of all the {@link LabelEntry} elements in the {@link #labelTable}. Each {@link\r\n * LabelEntry} instance is stored at the array index given by its hash code modulo the array size.\r\n * If several entries must be stored at the same array index, they are linked together via their\r\n * {@link LabelEntry#next} field. The {@link #getOrAddLabelEntry(Label)} method ensures that this\r\n * table does not contain duplicated entries.\r\n */\r\nprivate LabelEntry[] labelEntries;\n/**\r\n * Constructs a new, empty SymbolTable for the given ClassWriter.\r\n *\r\n * @param classWriter a ClassWriter.\r\n */\r\nSymbolTable(final ClassWriter classWriter) {\r\n    this.classWriter = classWriter;\r\n    this.sourceClassReader = null;\r\n    this.entries = new Entry[256];\r\n    this.constantPoolCount = 1;\r\n    this.constantPool = new ByteVector();\r\n}\n/**\r\n * Constructs a new SymbolTable for the given ClassWriter, initialized with the constant pool and\r\n * bootstrap methods of the given ClassReader.\r\n *\r\n * @param classWriter a ClassWriter.\r\n * @param classReader the ClassReader whose constant pool and bootstrap methods must be copied to\r\n *     initialize the SymbolTable.\r\n */\r\nSymbolTable(final ClassWriter classWriter, final ClassReader classReader) {\r\n    this.classWriter = classWriter;\r\n    this.sourceClassReader = classReader;\r\n    // Copy the constant pool binary content.\r\n    byte[] inputBytes = classReader.classFileBuffer;\r\n    int constantPoolOffset = classReader.getItem(1) - 1;\r\n    int constantPoolLength = classReader.header - constantPoolOffset;\r\n    constantPoolCount = classReader.getItemCount();\r\n    constantPool = new ByteVector(constantPoolLength);\r\n    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);\r\n    // Add the constant pool items in the symbol table entries. Reserve enough space in 'entries' to\r\n    // avoid too many hash set collisions (entries is not dynamically resized by the addConstant*\r\n    // method calls below), and to account for bootstrap method entries.\r\n    entries = new Entry[constantPoolCount * 2];\r\n    char[] charBuffer = new char[classReader.getMaxStringLength()];\r\n    boolean hasBootstrapMethods = false;\r\n    int itemIndex = 1;\r\n    while (itemIndex < constantPoolCount) {\r\n        int itemOffset = classReader.getItem(itemIndex);\r\n        int itemTag = inputBytes[itemOffset - 1];\r\n        int nameAndTypeItemOffset;\r\n        switch(itemTag) {\r\n            case Symbol.CONSTANT_FIELDREF_TAG:\r\n            case Symbol.CONSTANT_METHODREF_TAG:\r\n            case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:\r\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\r\n                addConstantMemberReference(itemIndex, itemTag, classReader.readClass(itemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer));\r\n                break;\r\n            case Symbol.CONSTANT_INTEGER_TAG:\r\n            case Symbol.CONSTANT_FLOAT_TAG:\r\n                addConstantIntegerOrFloat(itemIndex, itemTag, classReader.readInt(itemOffset));\r\n                break;\r\n            case Symbol.CONSTANT_NAME_AND_TYPE_TAG:\r\n                addConstantNameAndType(itemIndex, classReader.readUTF8(itemOffset, charBuffer), classReader.readUTF8(itemOffset + 2, charBuffer));\r\n                break;\r\n            case Symbol.CONSTANT_LONG_TAG:\r\n            case Symbol.CONSTANT_DOUBLE_TAG:\r\n                addConstantLongOrDouble(itemIndex, itemTag, classReader.readLong(itemOffset));\r\n                break;\r\n            case Symbol.CONSTANT_UTF8_TAG:\r\n                addConstantUtf8(itemIndex, classReader.readUtf(itemIndex, charBuffer));\r\n                break;\r\n            case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n                int memberRefItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 1));\r\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(memberRefItemOffset + 2));\r\n                addConstantMethodHandle(itemIndex, classReader.readByte(itemOffset), classReader.readClass(memberRefItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer), classReader.readByte(memberRefItemOffset - 1) == Symbol.CONSTANT_INTERFACE_METHODREF_TAG);\r\n                break;\r\n            case Symbol.CONSTANT_DYNAMIC_TAG:\r\n            case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:\r\n                hasBootstrapMethods = true;\r\n                nameAndTypeItemOffset = classReader.getItem(classReader.readUnsignedShort(itemOffset + 2));\r\n                addConstantDynamicOrInvokeDynamicReference(itemTag, itemIndex, classReader.readUTF8(nameAndTypeItemOffset, charBuffer), classReader.readUTF8(nameAndTypeItemOffset + 2, charBuffer), classReader.readUnsignedShort(itemOffset));\r\n                break;\r\n            case Symbol.CONSTANT_STRING_TAG:\r\n            case Symbol.CONSTANT_CLASS_TAG:\r\n            case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n            case Symbol.CONSTANT_MODULE_TAG:\r\n            case Symbol.CONSTANT_PACKAGE_TAG:\r\n                addConstantUtf8Reference(itemIndex, itemTag, classReader.readUTF8(itemOffset, charBuffer));\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n        itemIndex += (itemTag == Symbol.CONSTANT_LONG_TAG || itemTag == Symbol.CONSTANT_DOUBLE_TAG) ? 2 : 1;\r\n    }\r\n    // Copy the BootstrapMethods, if any.\r\n    if (hasBootstrapMethods) {\r\n        copyBootstrapMethods(classReader, charBuffer);\r\n    }\r\n}\n/**\r\n * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\r\n * the SymbolTable.\r\n *\r\n * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\r\n *     SymbolTable.\r\n * @param charBuffer a buffer used to read strings in the constant pool.\r\n */\r\nprivate void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\r\n    // Find attributOffset of the 'bootstrap_methods' array.\r\n    byte[] inputBytes = classReader.classFileBuffer;\r\n    int currentAttributeOffset = classReader.getFirstAttributeOffset();\r\n    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\r\n        if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\r\n            break;\r\n        }\r\n        currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\r\n    }\r\n    if (bootstrapMethodCount > 0) {\r\n        // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\r\n        int bootstrapMethodsOffset = currentAttributeOffset + 8;\r\n        int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\r\n        bootstrapMethods = new ByteVector(bootstrapMethodsLength);\r\n        bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\r\n        // Add each bootstrap method in the symbol table entries.\r\n        int currentOffset = bootstrapMethodsOffset;\r\n        for (int i = 0; i < bootstrapMethodCount; i++) {\r\n            int offset = currentOffset - bootstrapMethodsOffset;\r\n            int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\r\n            while (numBootstrapArguments-- > 0) {\r\n                int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\r\n                currentOffset += 2;\r\n                hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\r\n            }\r\n            add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\r\n        }\r\n    }\r\n}\n/**\r\n * Returns the ClassReader from which this SymbolTable was constructed.\r\n *\r\n * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\r\n *     was constructed from scratch.\r\n */\r\nClassReader getSource() {\r\n    return sourceClassReader;\r\n}\n/**\r\n * Returns the major version of the class to which this symbol table belongs.\r\n *\r\n * @return the major version of the class to which this symbol table belongs.\r\n */\r\nint getMajorVersion() {\r\n    return majorVersion;\r\n}\n/**\r\n * Returns the internal name of the class to which this symbol table belongs.\r\n *\r\n * @return the internal name of the class to which this symbol table belongs.\r\n */\r\nString getClassName() {\r\n    return className;\r\n}\n/**\r\n * Sets the major version and the name of the class to which this symbol table belongs. Also adds\r\n * the class name to the constant pool.\r\n *\r\n * @param majorVersion a major ClassFile version number.\r\n * @param className an internal class name.\r\n * @return the constant pool index of a new or already existing Symbol with the given class name.\r\n */\r\nint setMajorVersionAndClassName(final int majorVersion, final String className) {\r\n    this.majorVersion = majorVersion;\r\n    this.className = className;\r\n    return addConstantClass(className).index;\r\n}\n/**\r\n * Returns the number of items in this symbol table's constant_pool array (plus 1).\r\n *\r\n * @return the number of items in this symbol table's constant_pool array (plus 1).\r\n */\r\nint getConstantPoolCount() {\r\n    return constantPoolCount;\r\n}\n/**\r\n * Returns the length in bytes of this symbol table's constant_pool array.\r\n *\r\n * @return the length in bytes of this symbol table's constant_pool array.\r\n */\r\nint getConstantPoolLength() {\r\n    return constantPool.length;\r\n}\n/**\r\n * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\r\n * constant_pool_count value.\r\n *\r\n * @param output where the JVMS ClassFile's constant_pool array must be put.\r\n */\r\nvoid putConstantPool(final ByteVector output) {\r\n    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\r\n}\n/**\r\n * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\r\n * attribute name in the constant pool.\r\n *\r\n * @return the size in bytes of this symbol table's BootstrapMethods attribute.\r\n */\r\nint computeBootstrapMethodsSize() {\r\n    if (bootstrapMethods != null) {\r\n        addConstantUtf8(Constants.BOOTSTRAP_METHODS);\r\n        return 8 + bootstrapMethods.length;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\n/**\r\n * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\r\n * 6 attribute header bytes and the num_bootstrap_methods value.\r\n *\r\n * @param output where the JVMS BootstrapMethods attribute must be put.\r\n */\r\nvoid putBootstrapMethods(final ByteVector output) {\r\n    if (bootstrapMethods != null) {\r\n        output.putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)).putInt(bootstrapMethods.length + 2).putShort(bootstrapMethodCount).putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Generic symbol table entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the list of entries which can potentially have the given hash code.\r\n *\r\n * @param hashCode a {@link Entry#hashCode} value.\r\n * @return the list of entries which can potentially have the given hash code. The list is stored\r\n *     via the {@link Entry#next} field.\r\n */\r\nprivate Entry get(final int hashCode) {\r\n    return entries[hashCode % entries.length];\r\n}\n/**\r\n * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\r\n * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\r\n * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\r\n * #entries} array index) as much as possible, with reasonable memory usage.\r\n *\r\n * @param entry an Entry (which must not already be contained in {@link #entries}).\r\n * @return the given entry\r\n */\r\nprivate Entry put(final Entry entry) {\r\n    if (entryCount > (entries.length * 3) / 4) {\r\n        int currentCapacity = entries.length;\r\n        int newCapacity = currentCapacity * 2 + 1;\r\n        Entry[] newEntries = new Entry[newCapacity];\r\n        for (int i = currentCapacity - 1; i >= 0; --i) {\r\n            Entry currentEntry = entries[i];\r\n            while (currentEntry != null) {\r\n                int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\r\n                Entry nextEntry = currentEntry.next;\r\n                currentEntry.next = newEntries[newCurrentEntryIndex];\r\n                newEntries[newCurrentEntryIndex] = currentEntry;\r\n                currentEntry = nextEntry;\r\n            }\r\n        }\r\n        entries = newEntries;\r\n    }\r\n    entryCount++;\r\n    int index = entry.hashCode % entries.length;\r\n    entry.next = entries[index];\r\n    return entries[index] = entry;\r\n}\n/**\r\n * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\r\n * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\r\n * {@link #entries} if necessary.\r\n *\r\n * @param entry an Entry (which must not already be contained in {@link #entries}).\r\n */\r\nprivate void add(final Entry entry) {\r\n    entryCount++;\r\n    int index = entry.hashCode % entries.length;\r\n    entry.next = entries[index];\r\n    entries[index] = entry;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Constant pool entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value the value of the constant to be added to the constant pool. This parameter must be\r\n *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\r\n *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstant(final Object value) {\r\n    if (value instanceof Integer) {\r\n        return addConstantInteger(((Integer) value).intValue());\r\n    } else if (value instanceof Byte) {\r\n        return addConstantInteger(((Byte) value).intValue());\r\n    } else if (value instanceof Character) {\r\n        return addConstantInteger(((Character) value).charValue());\r\n    } else if (value instanceof Short) {\r\n        return addConstantInteger(((Short) value).intValue());\r\n    } else if (value instanceof Boolean) {\r\n        return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\r\n    } else if (value instanceof Float) {\r\n        return addConstantFloat(((Float) value).floatValue());\r\n    } else if (value instanceof Long) {\r\n        return addConstantLong(((Long) value).longValue());\r\n    } else if (value instanceof Double) {\r\n        return addConstantDouble(((Double) value).doubleValue());\r\n    } else if (value instanceof String) {\r\n        return addConstantString((String) value);\r\n    } else if (value instanceof Type) {\r\n        Type type = (Type) value;\r\n        int typeSort = type.getSort();\r\n        if (typeSort == Type.OBJECT) {\r\n            return addConstantClass(type.getInternalName());\r\n        } else if (typeSort == Type.METHOD) {\r\n            return addConstantMethodType(type.getDescriptor());\r\n        } else {\r\n            // type is a primitive or array type.\r\n            return addConstantClass(type.getDescriptor());\r\n        }\r\n    } else if (value instanceof Handle) {\r\n        Handle handle = (Handle) value;\r\n        return addConstantMethodHandle(handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());\r\n    } else if (value instanceof ConstantDynamic) {\r\n        ConstantDynamic constantDynamic = (ConstantDynamic) value;\r\n        return addConstantDynamic(constantDynamic.getName(), constantDynamic.getDescriptor(), constantDynamic.getBootstrapMethod(), constantDynamic.getBootstrapMethodArgumentsUnsafe());\r\n    } else {\r\n        throw new IllegalArgumentException(\"value \" + value);\r\n    }\r\n}\n/**\r\n * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value the internal name of a class.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantClass(final String value) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\r\n}\n/**\r\n * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param owner the internal name of a class.\r\n * @param name a field name.\r\n * @param descriptor a field descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantFieldref(final String owner, final String name, final String descriptor) {\r\n    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\r\n}\n/**\r\n * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\r\n * symbol table. Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param owner the internal name of a class.\r\n * @param name a method name.\r\n * @param descriptor a method descriptor.\r\n * @param isInterface whether owner is an interface or not.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantMethodref(final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\r\n    return addConstantMemberReference(tag, owner, name, descriptor);\r\n}\n/**\r\n * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\r\n * the constant pool of this symbol table. Does nothing if the constant pool already contains a\r\n * similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\r\n *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\r\n * @param owner the internal name of a class.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Entry addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\r\n    int hashCode = hash(tag, owner, name, descriptor);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put122(tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\r\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\r\n}\n/**\r\n * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\r\n * to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\r\n *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\r\n * @param owner the internal name of a class.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n */\r\nprivate void addConstantMemberReference(final int index, final int tag, final String owner, final String name, final String descriptor) {\r\n    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\r\n}\n/**\r\n * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a string.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantString(final String value) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\r\n}\n/**\r\n * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value an int.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantInteger(final int value) {\r\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\r\n}\n/**\r\n * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a float.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantFloat(final float value) {\r\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\r\n}\n/**\r\n * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\r\n * Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\r\n * @param value an int or float.\r\n * @return a constant pool constant with the given tag and primitive values.\r\n */\r\nprivate Symbol addConstantIntegerOrFloat(final int tag, final int value) {\r\n    int hashCode = hash(tag, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.putByte(tag).putInt(value);\r\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\r\n}\n/**\r\n * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\r\n * table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\r\n * @param value an int or float.\r\n */\r\nprivate void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\r\n    add(new Entry(index, tag, value, hash(tag, value)));\r\n}\n/**\r\n * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a long.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantLong(final long value) {\r\n    return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\r\n}\n/**\r\n * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a double.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantDouble(final double value) {\r\n    return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\r\n}\n/**\r\n * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\r\n * Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\r\n * @param value a long or double.\r\n * @return a constant pool constant with the given tag and primitive values.\r\n */\r\nprivate Symbol addConstantLongOrDouble(final int tag, final long value) {\r\n    int hashCode = hash(tag, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    int index = constantPoolCount;\r\n    constantPool.putByte(tag).putLong(value);\r\n    constantPoolCount += 2;\r\n    return put(new Entry(index, tag, value, hashCode));\r\n}\n/**\r\n * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\r\n * table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\r\n * @param value a long or double.\r\n */\r\nprivate void addConstantLongOrDouble(final int index, final int tag, final long value) {\r\n    add(new Entry(index, tag, value, hash(tag, value)));\r\n}\n/**\r\n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nint addConstantNameAndType(final String name, final String descriptor) {\r\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\r\n    int hashCode = hash(tag, name, descriptor);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\r\n    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\r\n}\n/**\r\n * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n */\r\nprivate void addConstantNameAndType(final int index, final String name, final String descriptor) {\r\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\r\n    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\r\n}\n/**\r\n * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a string.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nint addConstantUtf8(final String value) {\r\n    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\r\n    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\r\n}\n/**\r\n * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param value a string.\r\n */\r\nprivate void addConstantUtf8(final int index, final String value) {\r\n    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\r\n}\n/**\r\n * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\r\n * the constant pool already contains a similar item.\r\n *\r\n * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\r\n *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of a class of interface.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @param isInterface whether owner is an interface or not.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantMethodHandle(final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\r\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\r\n    // Note that we don't need to include isInterface in the hash computation, because it is\r\n    // redundant with owner (we can't have the same owner with different isInterface values).\r\n    int hashCode = hash(tag, owner, name, descriptor, data);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == data && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    if (referenceKind <= Opcodes.H_PUTSTATIC) {\r\n        constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\r\n    } else {\r\n        constantPool.put112(tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\r\n    }\r\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, data, hashCode));\r\n}\n/**\r\n * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\r\n *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of a class of interface.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @param isInterface whether owner is an interface or not.\r\n */\r\nprivate void addConstantMethodHandle(final int index, final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\r\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\r\n    int hashCode = hash(tag, owner, name, descriptor, data);\r\n    add(new Entry(index, tag, owner, name, descriptor, data, hashCode));\r\n}\n/**\r\n * Returns the {@link Symbol#data} field for a CONSTANT_MethodHandle_info Symbol.\r\n *\r\n * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\r\n *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param isInterface whether owner is an interface or not.\r\n */\r\nprivate static int getConstantMethodHandleSymbolData(final int referenceKind, final boolean isInterface) {\r\n    if (referenceKind > Opcodes.H_PUTSTATIC && isInterface) {\r\n        return referenceKind << 8;\r\n    }\r\n    return referenceKind;\r\n}\n/**\r\n * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantMethodType(final String methodDescriptor) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\r\n}\n/**\r\n * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\r\n * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\r\n * pool already contains a similar item.\r\n *\r\n * @param name a method name.\r\n * @param descriptor a field descriptor.\r\n * @param bootstrapMethodHandle a bootstrap method handle.\r\n * @param bootstrapMethodArguments the bootstrap method arguments.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\r\n    return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\r\n}\n/**\r\n * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\r\n * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param name a method name.\r\n * @param descriptor a method descriptor.\r\n * @param bootstrapMethodHandle a bootstrap method handle.\r\n * @param bootstrapMethodArguments the bootstrap method arguments.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\r\n    return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\r\n}\n/**\r\n * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\r\n * table. Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\r\n *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\r\n * @param name a method name.\r\n * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\r\n *     CONSTANT_INVOKE_DYNAMIC_TAG.\r\n * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\r\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\r\n    return put(new Entry(constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\r\n}\n/**\r\n * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\r\n * symbol table.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\r\n *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\r\n * @param index the constant pool index of the new Symbol.\r\n * @param name a method name.\r\n * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\r\n *     CONSTANT_INVOKE_DYNAMIC_TAG.\r\n * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\r\n */\r\nprivate void addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) {\r\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\r\n    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\r\n}\n/**\r\n * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param moduleName a fully qualified name (using dots) of a module.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantModule(final String moduleName) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\r\n}\n/**\r\n * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param packageName the internal name of a package.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantPackage(final String packageName) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\r\n}\n/**\r\n * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\r\n * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\r\n * nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\r\n *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\r\n *     Symbol#CONSTANT_PACKAGE_TAG}.\r\n * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\r\n *     package name, depending on tag.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Symbol addConstantUtf8Reference(final int tag, final String value) {\r\n    int hashCode = hash(tag, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put12(tag, addConstantUtf8(value));\r\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\r\n}\n/**\r\n * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\r\n * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\r\n *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\r\n *     Symbol#CONSTANT_PACKAGE_TAG}.\r\n * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\r\n *     package name, depending on tag.\r\n */\r\nprivate void addConstantUtf8Reference(final int index, final int tag, final String value) {\r\n    add(new Entry(index, tag, value, hash(tag, value)));\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Bootstrap method entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\r\n * the BootstrapMethods already contains a similar bootstrap method.\r\n *\r\n * @param bootstrapMethodHandle a bootstrap method handle.\r\n * @param bootstrapMethodArguments the bootstrap method arguments.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addBootstrapMethod(final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    ByteVector bootstrapMethodsAttribute = bootstrapMethods;\r\n    if (bootstrapMethodsAttribute == null) {\r\n        bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\r\n    }\r\n    // The bootstrap method arguments can be Constant_Dynamic values, which reference other\r\n    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\r\n    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\r\n    // while adding the given bootstrap method to it, in the rest of this method.\r\n    int numBootstrapArguments = bootstrapMethodArguments.length;\r\n    int[] bootstrapMethodArgumentIndexes = new int[numBootstrapArguments];\r\n    for (int i = 0; i < numBootstrapArguments; i++) {\r\n        bootstrapMethodArgumentIndexes[i] = addConstant(bootstrapMethodArguments[i]).index;\r\n    }\r\n    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\r\n    // compare it with existing ones, and will be reverted below if there is already a similar\r\n    // bootstrap method.\r\n    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\r\n    bootstrapMethodsAttribute.putShort(addConstantMethodHandle(bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()).index);\r\n    bootstrapMethodsAttribute.putShort(numBootstrapArguments);\r\n    for (int i = 0; i < numBootstrapArguments; i++) {\r\n        bootstrapMethodsAttribute.putShort(bootstrapMethodArgumentIndexes[i]);\r\n    }\r\n    // Compute the length and the hash code of the bootstrap method.\r\n    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\r\n    int hashCode = bootstrapMethodHandle.hashCode();\r\n    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\r\n        hashCode ^= bootstrapMethodArgument.hashCode();\r\n    }\r\n    hashCode &= 0x7FFFFFFF;\r\n    // Add the bootstrap method to the symbol table or revert the above changes.\r\n    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\r\n}\n/**\r\n * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\r\n * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\r\n * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\r\n *\r\n * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\r\n * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\r\n * @param hashCode the hash code of this bootstrap method.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\r\n    final byte[] bootstrapMethodsData = bootstrapMethods.data;\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\r\n            int otherOffset = (int) entry.data;\r\n            boolean isSameBootstrapMethod = true;\r\n            for (int i = 0; i < length; ++i) {\r\n                if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\r\n                    isSameBootstrapMethod = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isSameBootstrapMethod) {\r\n                // Revert to old position.\r\n                bootstrapMethods.length = offset;\r\n                return entry;\r\n            }\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Type table entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the type table element whose index is given.\r\n *\r\n * @param typeIndex a type table index.\r\n * @return the type table element whose index is given.\r\n */\r\nSymbol getType(final int typeIndex) {\r\n    return typeTable[typeIndex];\r\n}\n/**\r\n * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\r\n * is given.\r\n *\r\n * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\r\n * @return the label corresponding of the NEW instruction which created this \"forward\r\n *     uninitialized\" type.\r\n */\r\nLabel getForwardUninitializedLabel(final int typeIndex) {\r\n    return labelTable[(int) typeTable[typeIndex].data].label;\r\n}\n/**\r\n * Adds a type in the type table of this symbol table. Does nothing if the type table already\r\n * contains a similar type.\r\n *\r\n * @param value an internal class name.\r\n * @return the index of a new or already existing type Symbol with the given value.\r\n */\r\nint addType(final String value) {\r\n    int hashCode = hash(Symbol.TYPE_TAG, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\r\n}\n/**\r\n * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\r\n * table already contains a similar type.\r\n *\r\n * @param value an internal class name.\r\n * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\r\n *     uninitialized type value.\r\n * @return the index of a new or already existing type #@link Symbol} with the given value.\r\n */\r\nint addUninitializedType(final String value, final int bytecodeOffset) {\r\n    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == bytecodeOffset && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\r\n}\n/**\r\n * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\r\n * type table already contains a similar type.\r\n *\r\n * @param value an internal class name.\r\n * @param label the label of the NEW instruction that created this uninitialized type value. If\r\n *     the label is resolved, use the {@link #addUninitializedType} method instead.\r\n * @return the index of a new or already existing type {@link Symbol} with the given value.\r\n */\r\nint addForwardUninitializedType(final String value, final Label label) {\r\n    int labelIndex = getOrAddLabelEntry(label).index;\r\n    int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == labelIndex && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));\r\n}\n/**\r\n * Adds a merged type in the type table of this symbol table. Does nothing if the type table\r\n * already contains a similar type.\r\n *\r\n * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\r\n *     table.\r\n * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\r\n *     table.\r\n * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\r\n *     corresponding to the common super class of the given types.\r\n */\r\nint addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\r\n    long data = typeTableIndex1 < typeTableIndex2 ? typeTableIndex1 | (((long) typeTableIndex2) << 32) : typeTableIndex2 | (((long) typeTableIndex1) << 32);\r\n    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\r\n            return entry.info;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    String type1 = typeTable[typeTableIndex1].value;\r\n    String type2 = typeTable[typeTableIndex2].value;\r\n    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\r\n    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\r\n    return commonSuperTypeIndex;\r\n}\n/**\r\n * Adds the given type Symbol to {@link #typeTable}.\r\n *\r\n * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\r\n *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\r\n * @return the index in {@link #typeTable} where the given type was added, which is also equal to\r\n *     entry's index by hypothesis.\r\n */\r\nprivate int addTypeInternal(final Entry entry) {\r\n    if (typeTable == null) {\r\n        typeTable = new Entry[16];\r\n    }\r\n    if (typeCount == typeTable.length) {\r\n        Entry[] newTypeTable = new Entry[2 * typeTable.length];\r\n        System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\r\n        typeTable = newTypeTable;\r\n    }\r\n    typeTable[typeCount++] = entry;\r\n    return put(entry).index;\r\n}\n/**\r\n * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\r\n * no such entry.\r\n *\r\n * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\r\n *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\r\n *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\r\n * @return the {@link LabelEntry} corresponding to {@code label}.\r\n */\r\nprivate LabelEntry getOrAddLabelEntry(final Label label) {\r\n    if (labelEntries == null) {\r\n        labelEntries = new LabelEntry[16];\r\n        labelTable = new LabelEntry[16];\r\n    }\r\n    int hashCode = System.identityHashCode(label);\r\n    LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];\r\n    while (labelEntry != null && labelEntry.label != label) {\r\n        labelEntry = labelEntry.next;\r\n    }\r\n    if (labelEntry != null) {\r\n        return labelEntry;\r\n    }\r\n    if (labelCount > (labelEntries.length * 3) / 4) {\r\n        int currentCapacity = labelEntries.length;\r\n        int newCapacity = currentCapacity * 2 + 1;\r\n        LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];\r\n        for (int i = currentCapacity - 1; i >= 0; --i) {\r\n            LabelEntry currentEntry = labelEntries[i];\r\n            while (currentEntry != null) {\r\n                int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;\r\n                LabelEntry nextEntry = currentEntry.next;\r\n                currentEntry.next = newLabelEntries[newCurrentEntryIndex];\r\n                newLabelEntries[newCurrentEntryIndex] = currentEntry;\r\n                currentEntry = nextEntry;\r\n            }\r\n        }\r\n        labelEntries = newLabelEntries;\r\n    }\r\n    if (labelCount == labelTable.length) {\r\n        LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];\r\n        System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);\r\n        labelTable = newLabelTable;\r\n    }\r\n    labelEntry = new LabelEntry(labelCount, label);\r\n    int index = hashCode % labelEntries.length;\r\n    labelEntry.next = labelEntries[index];\r\n    labelEntries[index] = labelEntry;\r\n    labelTable[labelCount++] = labelEntry;\r\n    return labelEntry;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Static helper methods to compute hash codes.\r\n// -----------------------------------------------------------------------------------------------\r\nprivate static int hash(final int tag, final int value) {\r\n    return 0x7FFFFFFF & (tag + value);\r\n}\nprivate static int hash(final int tag, final long value) {\r\n    return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\r\n}\nprivate static int hash(final int tag, final String value) {\r\n    return 0x7FFFFFFF & (tag + value.hashCode());\r\n}\nprivate static int hash(final int tag, final String value1, final int value2) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\r\n}\nprivate static int hash(final int tag, final String value1, final String value2) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\r\n}\nprivate static int hash(final int tag, final String value1, final String value2, final int value3) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\r\n}\nprivate static int hash(final int tag, final String value1, final String value2, final String value3) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\r\n}\nprivate static int hash(final int tag, final String value1, final String value2, final String value3, final int value4) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\r\n}\n/**\r\n * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\r\n * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\r\n * duplicate symbols). See {@link #entries}.\r\n *\r\n * @author Eric Bruneton\r\n */\r\nprivate static final class Entry extends Symbol {\r\n\r\n    /**\r\n     * The hash code of this entry.\r\n     */\r\n    final int hashCode;\r\n\r\n    /**\r\n     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\r\n     * #entries}) as this one.\r\n     */\r\n    Entry next;\r\n\r\n    Entry(final int index, final int tag, final String owner, final String name, final String value, final long data, final int hashCode) {\r\n        super(index, tag, owner, name, value, data);\r\n        this.hashCode = hashCode;\r\n    }\r\n\r\n    Entry(final int index, final int tag, final String value, final int hashCode) {\r\n        super(index, tag, /* owner= */\r\n        null, /* name= */\r\n        null, value, /* data= */\r\n        0);\r\n        this.hashCode = hashCode;\r\n    }\r\n\r\n    Entry(final int index, final int tag, final String value, final long data, final int hashCode) {\r\n        super(index, tag, /* owner= */\r\n        null, /* name= */\r\n        null, value, data);\r\n        this.hashCode = hashCode;\r\n    }\r\n\r\n    Entry(final int index, final int tag, final String name, final String value, final int hashCode) {\r\n        super(index, tag, /* owner= */\r\n        null, name, value, /* data= */\r\n        0);\r\n        this.hashCode = hashCode;\r\n    }\r\n\r\n    Entry(final int index, final int tag, final long data, final int hashCode) {\r\n        super(index, tag, /* owner= */\r\n        null, /* name= */\r\n        null, /* value= */\r\n        null, data);\r\n        this.hashCode = hashCode;\r\n    }\r\n}\n/**\r\n * A label corresponding to a \"forward uninitialized\" type in the ASM specific {@link\r\n * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).\r\n *\r\n * @author Eric Bruneton\r\n */\r\nprivate static final class LabelEntry {\r\n\r\n    /**\r\n     * The index of this label entry in the {@link SymbolTable#labelTable} array.\r\n     */\r\n    final int index;\r\n\r\n    /**\r\n     * The value of this label entry.\r\n     */\r\n    final Label label;\r\n\r\n    /**\r\n     * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\r\n     * SymbolTable#labelEntries}}) as this one.\r\n     */\r\n    LabelEntry next;\r\n\r\n    LabelEntry(final int index, final Label label) {\r\n        this.index = index;\r\n        this.label = label;\r\n    }\r\n}",
    "comment": "\n * The constant pool entries, the BootstrapMethods attribute entries and the (ASM specific) type\n * table entries of a class.\n *\n * @author Eric Bruneton\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4\">JVMS\n *     4.4</a>\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23\">JVMS\n *     4.7.23</a>\n "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#copyBootstrapMethods(ClassReader,char[])",
    "entityType": "method",
    "code": "/**\r\n * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\r\n * the SymbolTable.\r\n *\r\n * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\r\n *     SymbolTable.\r\n * @param charBuffer a buffer used to read strings in the constant pool.\r\n */\r\nprivate void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {\r\n    // Find attributOffset of the 'bootstrap_methods' array.\r\n    byte[] inputBytes = classReader.classFileBuffer;\r\n    int currentAttributeOffset = classReader.getFirstAttributeOffset();\r\n    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\r\n        String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\r\n        if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\r\n            bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);\r\n            break;\r\n        }\r\n        currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);\r\n    }\r\n    if (bootstrapMethodCount > 0) {\r\n        // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.\r\n        int bootstrapMethodsOffset = currentAttributeOffset + 8;\r\n        int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;\r\n        bootstrapMethods = new ByteVector(bootstrapMethodsLength);\r\n        bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);\r\n        // Add each bootstrap method in the symbol table entries.\r\n        int currentOffset = bootstrapMethodsOffset;\r\n        for (int i = 0; i < bootstrapMethodCount; i++) {\r\n            int offset = currentOffset - bootstrapMethodsOffset;\r\n            int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);\r\n            currentOffset += 2;\r\n            int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();\r\n            while (numBootstrapArguments-- > 0) {\r\n                int bootstrapArgument = classReader.readUnsignedShort(currentOffset);\r\n                currentOffset += 2;\r\n                hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();\r\n            }\r\n            add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\n   * the SymbolTable.\n   *\n   * @param classReader the ClassReader whose bootstrap methods must be copied to initialize the\n   *     SymbolTable.\n   * @param charBuffer a buffer used to read strings in the constant pool.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getSource()",
    "entityType": "method",
    "code": "/**\r\n * Returns the ClassReader from which this SymbolTable was constructed.\r\n *\r\n * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\r\n *     was constructed from scratch.\r\n */\r\nClassReader getSource() {\r\n    return sourceClassReader;\r\n}",
    "comment": "\n   * Returns the ClassReader from which this SymbolTable was constructed.\n   *\n   * @return the ClassReader from which this SymbolTable was constructed, or {@literal null} if it\n   *     was constructed from scratch.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getMajorVersion()",
    "entityType": "method",
    "code": "/**\r\n * Returns the major version of the class to which this symbol table belongs.\r\n *\r\n * @return the major version of the class to which this symbol table belongs.\r\n */\r\nint getMajorVersion() {\r\n    return majorVersion;\r\n}",
    "comment": "\n   * Returns the major version of the class to which this symbol table belongs.\n   *\n   * @return the major version of the class to which this symbol table belongs.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getClassName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the class to which this symbol table belongs.\r\n *\r\n * @return the internal name of the class to which this symbol table belongs.\r\n */\r\nString getClassName() {\r\n    return className;\r\n}",
    "comment": "\n   * Returns the internal name of the class to which this symbol table belongs.\n   *\n   * @return the internal name of the class to which this symbol table belongs.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#setMajorVersionAndClassName(int,String)",
    "entityType": "method",
    "code": "/**\r\n * Sets the major version and the name of the class to which this symbol table belongs. Also adds\r\n * the class name to the constant pool.\r\n *\r\n * @param majorVersion a major ClassFile version number.\r\n * @param className an internal class name.\r\n * @return the constant pool index of a new or already existing Symbol with the given class name.\r\n */\r\nint setMajorVersionAndClassName(final int majorVersion, final String className) {\r\n    this.majorVersion = majorVersion;\r\n    this.className = className;\r\n    return addConstantClass(className).index;\r\n}",
    "comment": "\n   * Sets the major version and the name of the class to which this symbol table belongs. Also adds\n   * the class name to the constant pool.\n   *\n   * @param majorVersion a major ClassFile version number.\n   * @param className an internal class name.\n   * @return the constant pool index of a new or already existing Symbol with the given class name.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getConstantPoolCount()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of items in this symbol table's constant_pool array (plus 1).\r\n *\r\n * @return the number of items in this symbol table's constant_pool array (plus 1).\r\n */\r\nint getConstantPoolCount() {\r\n    return constantPoolCount;\r\n}",
    "comment": "\n   * Returns the number of items in this symbol table's constant_pool array (plus 1).\n   *\n   * @return the number of items in this symbol table's constant_pool array (plus 1).\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getConstantPoolLength()",
    "entityType": "method",
    "code": "/**\r\n * Returns the length in bytes of this symbol table's constant_pool array.\r\n *\r\n * @return the length in bytes of this symbol table's constant_pool array.\r\n */\r\nint getConstantPoolLength() {\r\n    return constantPool.length;\r\n}",
    "comment": "\n   * Returns the length in bytes of this symbol table's constant_pool array.\n   *\n   * @return the length in bytes of this symbol table's constant_pool array.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#putConstantPool(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\r\n * constant_pool_count value.\r\n *\r\n * @param output where the JVMS ClassFile's constant_pool array must be put.\r\n */\r\nvoid putConstantPool(final ByteVector output) {\r\n    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);\r\n}",
    "comment": "\n   * Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\n   * constant_pool_count value.\n   *\n   * @param output where the JVMS ClassFile's constant_pool array must be put.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#computeBootstrapMethodsSize()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\r\n * attribute name in the constant pool.\r\n *\r\n * @return the size in bytes of this symbol table's BootstrapMethods attribute.\r\n */\r\nint computeBootstrapMethodsSize() {\r\n    if (bootstrapMethods != null) {\r\n        addConstantUtf8(Constants.BOOTSTRAP_METHODS);\r\n        return 8 + bootstrapMethods.length;\r\n    } else {\r\n        return 0;\r\n    }\r\n}",
    "comment": "\n   * Returns the size in bytes of this symbol table's BootstrapMethods attribute. Also adds the\n   * attribute name in the constant pool.\n   *\n   * @return the size in bytes of this symbol table's BootstrapMethods attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#putBootstrapMethods(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\r\n * 6 attribute header bytes and the num_bootstrap_methods value.\r\n *\r\n * @param output where the JVMS BootstrapMethods attribute must be put.\r\n */\r\nvoid putBootstrapMethods(final ByteVector output) {\r\n    if (bootstrapMethods != null) {\r\n        output.putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)).putInt(bootstrapMethods.length + 2).putShort(bootstrapMethodCount).putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\r\n    }\r\n}",
    "comment": "\n   * Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n   * 6 attribute header bytes and the num_bootstrap_methods value.\n   *\n   * @param output where the JVMS BootstrapMethods attribute must be put.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#get(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Generic symbol table entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the list of entries which can potentially have the given hash code.\r\n *\r\n * @param hashCode a {@link Entry#hashCode} value.\r\n * @return the list of entries which can potentially have the given hash code. The list is stored\r\n *     via the {@link Entry#next} field.\r\n */\r\nprivate Entry get(final int hashCode) {\r\n    return entries[hashCode % entries.length];\r\n}",
    "comment": "\n   * Returns the list of entries which can potentially have the given hash code.\n   *\n   * @param hashCode a {@link Entry#hashCode} value.\n   * @return the list of entries which can potentially have the given hash code. The list is stored\n   *     via the {@link Entry#next} field.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#put(Entry)",
    "entityType": "method",
    "code": "/**\r\n * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\r\n * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\r\n * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\r\n * #entries} array index) as much as possible, with reasonable memory usage.\r\n *\r\n * @param entry an Entry (which must not already be contained in {@link #entries}).\r\n * @return the given entry\r\n */\r\nprivate Entry put(final Entry entry) {\r\n    if (entryCount > (entries.length * 3) / 4) {\r\n        int currentCapacity = entries.length;\r\n        int newCapacity = currentCapacity * 2 + 1;\r\n        Entry[] newEntries = new Entry[newCapacity];\r\n        for (int i = currentCapacity - 1; i >= 0; --i) {\r\n            Entry currentEntry = entries[i];\r\n            while (currentEntry != null) {\r\n                int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;\r\n                Entry nextEntry = currentEntry.next;\r\n                currentEntry.next = newEntries[newCurrentEntryIndex];\r\n                newEntries[newCurrentEntryIndex] = currentEntry;\r\n                currentEntry = nextEntry;\r\n            }\r\n        }\r\n        entries = newEntries;\r\n    }\r\n    entryCount++;\r\n    int index = entry.hashCode % entries.length;\r\n    entry.next = entries[index];\r\n    return entries[index] = entry;\r\n}",
    "comment": "\n   * Puts the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n   * whether {@link #entries} already contains a similar entry or not. {@link #entries} is resized\n   * if necessary to avoid hash collisions (multiple entries needing to be stored at the same {@link\n   * #entries} array index) as much as possible, with reasonable memory usage.\n   *\n   * @param entry an Entry (which must not already be contained in {@link #entries}).\n   * @return the given entry\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#add(Entry)",
    "entityType": "method",
    "code": "/**\r\n * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\r\n * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\r\n * {@link #entries} if necessary.\r\n *\r\n * @param entry an Entry (which must not already be contained in {@link #entries}).\r\n */\r\nprivate void add(final Entry entry) {\r\n    entryCount++;\r\n    int index = entry.hashCode % entries.length;\r\n    entry.next = entries[index];\r\n    entries[index] = entry;\r\n}",
    "comment": "\n   * Adds the given entry in the {@link #entries} hash set. This method does <i>not</i> check\n   * whether {@link #entries} already contains a similar entry or not, and does <i>not</i> resize\n   * {@link #entries} if necessary.\n   *\n   * @param entry an Entry (which must not already be contained in {@link #entries}).\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstant(Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Constant pool entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value the value of the constant to be added to the constant pool. This parameter must be\r\n *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\r\n *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstant(final Object value) {\r\n    if (value instanceof Integer) {\r\n        return addConstantInteger(((Integer) value).intValue());\r\n    } else if (value instanceof Byte) {\r\n        return addConstantInteger(((Byte) value).intValue());\r\n    } else if (value instanceof Character) {\r\n        return addConstantInteger(((Character) value).charValue());\r\n    } else if (value instanceof Short) {\r\n        return addConstantInteger(((Short) value).intValue());\r\n    } else if (value instanceof Boolean) {\r\n        return addConstantInteger(((Boolean) value).booleanValue() ? 1 : 0);\r\n    } else if (value instanceof Float) {\r\n        return addConstantFloat(((Float) value).floatValue());\r\n    } else if (value instanceof Long) {\r\n        return addConstantLong(((Long) value).longValue());\r\n    } else if (value instanceof Double) {\r\n        return addConstantDouble(((Double) value).doubleValue());\r\n    } else if (value instanceof String) {\r\n        return addConstantString((String) value);\r\n    } else if (value instanceof Type) {\r\n        Type type = (Type) value;\r\n        int typeSort = type.getSort();\r\n        if (typeSort == Type.OBJECT) {\r\n            return addConstantClass(type.getInternalName());\r\n        } else if (typeSort == Type.METHOD) {\r\n            return addConstantMethodType(type.getDescriptor());\r\n        } else {\r\n            // type is a primitive or array type.\r\n            return addConstantClass(type.getDescriptor());\r\n        }\r\n    } else if (value instanceof Handle) {\r\n        Handle handle = (Handle) value;\r\n        return addConstantMethodHandle(handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());\r\n    } else if (value instanceof ConstantDynamic) {\r\n        ConstantDynamic constantDynamic = (ConstantDynamic) value;\r\n        return addConstantDynamic(constantDynamic.getName(), constantDynamic.getDescriptor(), constantDynamic.getBootstrapMethod(), constantDynamic.getBootstrapMethodArgumentsUnsafe());\r\n    } else {\r\n        throw new IllegalArgumentException(\"value \" + value);\r\n    }\r\n}",
    "comment": "\n   * Adds a number or string constant to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value the value of the constant to be added to the constant pool. This parameter must be\n   *     an {@link Integer}, {@link Byte}, {@link Character}, {@link Short}, {@link Boolean}, {@link\n   *     Float}, {@link Long}, {@link Double}, {@link String}, {@link Type} or {@link Handle}.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value the internal name of a class.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantClass(final String value) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_CLASS_TAG, value);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Class_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value the internal name of a class.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantFieldref(String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param owner the internal name of a class.\r\n * @param name a field name.\r\n * @param descriptor a field descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantFieldref(final String owner, final String name, final String descriptor) {\r\n    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param owner the internal name of a class.\n   * @param name a field name.\n   * @param descriptor a field descriptor.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantMethodref(String,String,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\r\n * symbol table. Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param owner the internal name of a class.\r\n * @param name a method name.\r\n * @param descriptor a method descriptor.\r\n * @param isInterface whether owner is an interface or not.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantMethodref(final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;\r\n    return addConstantMemberReference(tag, owner, name, descriptor);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\n   * symbol table. Does nothing if the constant pool already contains a similar item.\n   *\n   * @param owner the internal name of a class.\n   * @param name a method name.\n   * @param descriptor a method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantMemberReference(int,String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\r\n * the constant pool of this symbol table. Does nothing if the constant pool already contains a\r\n * similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\r\n *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\r\n * @param owner the internal name of a class.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Entry addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\r\n    int hashCode = hash(tag, owner, name, descriptor);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put122(tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\r\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\n   * the constant pool of this symbol table. Does nothing if the constant pool already contains a\n   * similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n   * @param owner the internal name of a class.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantMemberReference(int,int,String,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\r\n * to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\r\n *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\r\n * @param owner the internal name of a class.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n */\r\nprivate void addConstantMemberReference(final int index, final int tag, final String owner, final String name, final String descriptor) {\r\n    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\n   * to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\n   *     or {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n   * @param owner the internal name of a class.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantString(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a string.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantString(final String value) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_STRING_TAG, value);\r\n}",
    "comment": "\n   * Adds a CONSTANT_String_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a string.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantInteger(int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value an int.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantInteger(final int value) {\r\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_INTEGER_TAG, value);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Integer_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value an int.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantFloat(float)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a float.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantFloat(final float value) {\r\n    return addConstantIntegerOrFloat(Symbol.CONSTANT_FLOAT_TAG, Float.floatToRawIntBits(value));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Float_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a float.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantIntegerOrFloat(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\r\n * Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\r\n * @param value an int or float.\r\n * @return a constant pool constant with the given tag and primitive values.\r\n */\r\nprivate Symbol addConstantIntegerOrFloat(final int tag, final int value) {\r\n    int hashCode = hash(tag, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.putByte(tag).putInt(value);\r\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\n   * Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n   * @param value an int or float.\n   * @return a constant pool constant with the given tag and primitive values.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantIntegerOrFloat(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\r\n * table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\r\n * @param value an int or float.\r\n */\r\nprivate void addConstantIntegerOrFloat(final int index, final int tag, final int value) {\r\n    add(new Entry(index, tag, value, hash(tag, value)));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\n   * table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n   * @param value an int or float.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantLong(long)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a long.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantLong(final long value) {\r\n    return addConstantLongOrDouble(Symbol.CONSTANT_LONG_TAG, value);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Long_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a long.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantDouble(double)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a double.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantDouble(final double value) {\r\n    return addConstantLongOrDouble(Symbol.CONSTANT_DOUBLE_TAG, Double.doubleToRawLongBits(value));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Double_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a double.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantLongOrDouble(int,long)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\r\n * Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\r\n * @param value a long or double.\r\n * @return a constant pool constant with the given tag and primitive values.\r\n */\r\nprivate Symbol addConstantLongOrDouble(final int tag, final long value) {\r\n    int hashCode = hash(tag, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    int index = constantPoolCount;\r\n    constantPool.putByte(tag).putLong(value);\r\n    constantPoolCount += 2;\r\n    return put(new Entry(index, tag, value, hashCode));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\n   * Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n   * @param value a long or double.\n   * @return a constant pool constant with the given tag and primitive values.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantLongOrDouble(int,int,long)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\r\n * table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\r\n * @param value a long or double.\r\n */\r\nprivate void addConstantLongOrDouble(final int index, final int tag, final long value) {\r\n    add(new Entry(index, tag, value, hash(tag, value)));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\n   * table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n   * @param value a long or double.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantNameAndType(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nint addConstantNameAndType(final String name, final String descriptor) {\r\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\r\n    int hashCode = hash(tag, name, descriptor);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\r\n    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;\r\n}",
    "comment": "\n   * Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantNameAndType(int,String,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n */\r\nprivate void addConstantNameAndType(final int index, final String name, final String descriptor) {\r\n    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\r\n    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantUtf8(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param value a string.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nint addConstantUtf8(final String value) {\r\n    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\r\n    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\r\n}",
    "comment": "\n   * Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param value a string.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantUtf8(int,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param value a string.\r\n */\r\nprivate void addConstantUtf8(final int index, final String value) {\r\n    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param value a string.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantMethodHandle(int,String,String,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\r\n * the constant pool already contains a similar item.\r\n *\r\n * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\r\n *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of a class of interface.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @param isInterface whether owner is an interface or not.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantMethodHandle(final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\r\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\r\n    // Note that we don't need to include isInterface in the hash computation, because it is\r\n    // redundant with owner (we can't have the same owner with different isInterface values).\r\n    int hashCode = hash(tag, owner, name, descriptor, data);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == data && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    if (referenceKind <= Opcodes.H_PUTSTATIC) {\r\n        constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);\r\n    } else {\r\n        constantPool.put112(tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);\r\n    }\r\n    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, data, hashCode));\r\n}",
    "comment": "\n   * Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\n   * the constant pool already contains a similar item.\n   *\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of a class of interface.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantMethodHandle(int,int,String,String,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\r\n *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param owner the internal name of a class of interface.\r\n * @param name a field or method name.\r\n * @param descriptor a field or method descriptor.\r\n * @param isInterface whether owner is an interface or not.\r\n */\r\nprivate void addConstantMethodHandle(final int index, final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\r\n    final int data = getConstantMethodHandleSymbolData(referenceKind, isInterface);\r\n    int hashCode = hash(tag, owner, name, descriptor, data);\r\n    add(new Entry(index, tag, owner, name, descriptor, data, hashCode));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param owner the internal name of a class of interface.\n   * @param name a field or method name.\n   * @param descriptor a field or method descriptor.\n   * @param isInterface whether owner is an interface or not.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getConstantMethodHandleSymbolData(int,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Symbol#data} field for a CONSTANT_MethodHandle_info Symbol.\r\n *\r\n * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\r\n *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\r\n *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\r\n *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\r\n * @param isInterface whether owner is an interface or not.\r\n */\r\nprivate static int getConstantMethodHandleSymbolData(final int referenceKind, final boolean isInterface) {\r\n    if (referenceKind > Opcodes.H_PUTSTATIC && isInterface) {\r\n        return referenceKind << 8;\r\n    }\r\n    return referenceKind;\r\n}",
    "comment": "\n   * Returns the {@link Symbol#data} field for a CONSTANT_MethodHandle_info Symbol.\n   *\n   * @param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\n   *     Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\n   *     Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\n   *     Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n   * @param isInterface whether owner is an interface or not.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantMethodType(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantMethodType(final String methodDescriptor) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_METHOD_TYPE_TAG, methodDescriptor);\r\n}",
    "comment": "\n   * Adds a CONSTANT_MethodType_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantDynamic(String,String,Handle,Object)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\r\n * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\r\n * pool already contains a similar item.\r\n *\r\n * @param name a method name.\r\n * @param descriptor a field descriptor.\r\n * @param bootstrapMethodHandle a bootstrap method handle.\r\n * @param bootstrapMethodArguments the bootstrap method arguments.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\r\n    return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\n   * bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\n   * pool already contains a similar item.\n   *\n   * @param name a method name.\n   * @param descriptor a field descriptor.\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantInvokeDynamic(String,String,Handle,Object)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\r\n * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param name a method name.\r\n * @param descriptor a method descriptor.\r\n * @param bootstrapMethodHandle a bootstrap method handle.\r\n * @param bootstrapMethodArguments the bootstrap method arguments.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\r\n    return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\r\n}",
    "comment": "\n   * Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\n   * related bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param name a method name.\n   * @param descriptor a method descriptor.\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantDynamicOrInvokeDynamicReference(int,String,String,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\r\n * table. Does nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\r\n *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\r\n * @param name a method name.\r\n * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\r\n *     CONSTANT_INVOKE_DYNAMIC_TAG.\r\n * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\r\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));\r\n    return put(new Entry(constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\n   * table. Does nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n   * @param name a method name.\n   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\n   *     CONSTANT_INVOKE_DYNAMIC_TAG.\n   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantDynamicOrInvokeDynamicReference(int,int,String,String,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\r\n * symbol table.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\r\n *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\r\n * @param index the constant pool index of the new Symbol.\r\n * @param name a method name.\r\n * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\r\n *     CONSTANT_INVOKE_DYNAMIC_TAG.\r\n * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\r\n */\r\nprivate void addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) {\r\n    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\r\n    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\n   * symbol table.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\n   *     Symbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n   * @param index the constant pool index of the new Symbol.\n   * @param name a method name.\n   * @param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\n   *     CONSTANT_INVOKE_DYNAMIC_TAG.\n   * @param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantModule(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param moduleName a fully qualified name (using dots) of a module.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantModule(final String moduleName) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_MODULE_TAG, moduleName);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Module_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param moduleName a fully qualified name (using dots) of a module.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantPackage(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\r\n * constant pool already contains a similar item.\r\n *\r\n * @param packageName the internal name of a package.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addConstantPackage(final String packageName) {\r\n    return addConstantUtf8Reference(Symbol.CONSTANT_PACKAGE_TAG, packageName);\r\n}",
    "comment": "\n   * Adds a CONSTANT_Package_info to the constant pool of this symbol table. Does nothing if the\n   * constant pool already contains a similar item.\n   *\n   * @param packageName the internal name of a package.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantUtf8Reference(int,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\r\n * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\r\n * nothing if the constant pool already contains a similar item.\r\n *\r\n * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\r\n *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\r\n *     Symbol#CONSTANT_PACKAGE_TAG}.\r\n * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\r\n *     package name, depending on tag.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Symbol addConstantUtf8Reference(final int tag, final String value) {\r\n    int hashCode = hash(tag, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    constantPool.put12(tag, addConstantUtf8(value));\r\n    return put(new Entry(constantPoolCount++, tag, value, hashCode));\r\n}",
    "comment": "\n   * Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\n   * nothing if the constant pool already contains a similar item.\n   *\n   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n   *     Symbol#CONSTANT_PACKAGE_TAG}.\n   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n   *     package name, depending on tag.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addConstantUtf8Reference(int,int,String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\r\n * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\r\n *\r\n * @param index the constant pool index of the new Symbol.\r\n * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\r\n *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\r\n *     Symbol#CONSTANT_PACKAGE_TAG}.\r\n * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\r\n *     package name, depending on tag.\r\n */\r\nprivate void addConstantUtf8Reference(final int index, final int tag, final String value) {\r\n    add(new Entry(index, tag, value, hash(tag, value)));\r\n}",
    "comment": "\n   * Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\n   * CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n   *\n   * @param index the constant pool index of the new Symbol.\n   * @param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\n   *     Symbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\n   *     Symbol#CONSTANT_PACKAGE_TAG}.\n   * @param value an internal class name, an arbitrary string, a method descriptor, a module or a\n   *     package name, depending on tag.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addBootstrapMethod(Handle,Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Bootstrap method entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\r\n * the BootstrapMethods already contains a similar bootstrap method.\r\n *\r\n * @param bootstrapMethodHandle a bootstrap method handle.\r\n * @param bootstrapMethodArguments the bootstrap method arguments.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nSymbol addBootstrapMethod(final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n    ByteVector bootstrapMethodsAttribute = bootstrapMethods;\r\n    if (bootstrapMethodsAttribute == null) {\r\n        bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\r\n    }\r\n    // The bootstrap method arguments can be Constant_Dynamic values, which reference other\r\n    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\r\n    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\r\n    // while adding the given bootstrap method to it, in the rest of this method.\r\n    int numBootstrapArguments = bootstrapMethodArguments.length;\r\n    int[] bootstrapMethodArgumentIndexes = new int[numBootstrapArguments];\r\n    for (int i = 0; i < numBootstrapArguments; i++) {\r\n        bootstrapMethodArgumentIndexes[i] = addConstant(bootstrapMethodArguments[i]).index;\r\n    }\r\n    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to\r\n    // compare it with existing ones, and will be reverted below if there is already a similar\r\n    // bootstrap method.\r\n    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;\r\n    bootstrapMethodsAttribute.putShort(addConstantMethodHandle(bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()).index);\r\n    bootstrapMethodsAttribute.putShort(numBootstrapArguments);\r\n    for (int i = 0; i < numBootstrapArguments; i++) {\r\n        bootstrapMethodsAttribute.putShort(bootstrapMethodArgumentIndexes[i]);\r\n    }\r\n    // Compute the length and the hash code of the bootstrap method.\r\n    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;\r\n    int hashCode = bootstrapMethodHandle.hashCode();\r\n    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\r\n        hashCode ^= bootstrapMethodArgument.hashCode();\r\n    }\r\n    hashCode &= 0x7FFFFFFF;\r\n    // Add the bootstrap method to the symbol table or revert the above changes.\r\n    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);\r\n}",
    "comment": "\n   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n   * the BootstrapMethods already contains a similar bootstrap method.\n   *\n   * @param bootstrapMethodHandle a bootstrap method handle.\n   * @param bootstrapMethodArguments the bootstrap method arguments.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addBootstrapMethod(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\r\n * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\r\n * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\r\n *\r\n * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\r\n * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\r\n * @param hashCode the hash code of this bootstrap method.\r\n * @return a new or already existing Symbol with the given value.\r\n */\r\nprivate Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {\r\n    final byte[] bootstrapMethodsData = bootstrapMethods.data;\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {\r\n            int otherOffset = (int) entry.data;\r\n            boolean isSameBootstrapMethod = true;\r\n            for (int i = 0; i < length; ++i) {\r\n                if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {\r\n                    isSameBootstrapMethod = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isSameBootstrapMethod) {\r\n                // Revert to old position.\r\n                bootstrapMethods.length = offset;\r\n                return entry;\r\n            }\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));\r\n}",
    "comment": "\n   * Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\n   * the BootstrapMethods already contains a similar bootstrap method (more precisely, reverts the\n   * content of {@link #bootstrapMethods} to remove the last, duplicate bootstrap method).\n   *\n   * @param offset the offset of the last bootstrap method in {@link #bootstrapMethods}, in bytes.\n   * @param length the length of this bootstrap method in {@link #bootstrapMethods}, in bytes.\n   * @param hashCode the hash code of this bootstrap method.\n   * @return a new or already existing Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getType(int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Type table entries management.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the type table element whose index is given.\r\n *\r\n * @param typeIndex a type table index.\r\n * @return the type table element whose index is given.\r\n */\r\nSymbol getType(final int typeIndex) {\r\n    return typeTable[typeIndex];\r\n}",
    "comment": "\n   * Returns the type table element whose index is given.\n   *\n   * @param typeIndex a type table index.\n   * @return the type table element whose index is given.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getForwardUninitializedLabel(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\r\n * is given.\r\n *\r\n * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\r\n * @return the label corresponding of the NEW instruction which created this \"forward\r\n *     uninitialized\" type.\r\n */\r\nLabel getForwardUninitializedLabel(final int typeIndex) {\r\n    return labelTable[(int) typeTable[typeIndex].data].label;\r\n}",
    "comment": "\n   * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\n   * is given.\n   *\n   * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\n   * @return the label corresponding of the NEW instruction which created this \"forward\n   *     uninitialized\" type.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addType(String)",
    "entityType": "method",
    "code": "/**\r\n * Adds a type in the type table of this symbol table. Does nothing if the type table already\r\n * contains a similar type.\r\n *\r\n * @param value an internal class name.\r\n * @return the index of a new or already existing type Symbol with the given value.\r\n */\r\nint addType(final String value) {\r\n    int hashCode = hash(Symbol.TYPE_TAG, value);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.TYPE_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.TYPE_TAG, value, hashCode));\r\n}",
    "comment": "\n   * Adds a type in the type table of this symbol table. Does nothing if the type table already\n   * contains a similar type.\n   *\n   * @param value an internal class name.\n   * @return the index of a new or already existing type Symbol with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addUninitializedType(String,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\r\n * table already contains a similar type.\r\n *\r\n * @param value an internal class name.\r\n * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\r\n *     uninitialized type value.\r\n * @return the index of a new or already existing type #@link Symbol} with the given value.\r\n */\r\nint addUninitializedType(final String value, final int bytecodeOffset) {\r\n    int hashCode = hash(Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == bytecodeOffset && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.UNINITIALIZED_TYPE_TAG, value, bytecodeOffset, hashCode));\r\n}",
    "comment": "\n   * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\n   * table already contains a similar type.\n   *\n   * @param value an internal class name.\n   * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\n   *     uninitialized type value.\n   * @return the index of a new or already existing type #@link Symbol} with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addForwardUninitializedType(String,Label)",
    "entityType": "method",
    "code": "/**\r\n * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\r\n * type table already contains a similar type.\r\n *\r\n * @param value an internal class name.\r\n * @param label the label of the NEW instruction that created this uninitialized type value. If\r\n *     the label is resolved, use the {@link #addUninitializedType} method instead.\r\n * @return the index of a new or already existing type {@link Symbol} with the given value.\r\n */\r\nint addForwardUninitializedType(final String value, final Label label) {\r\n    int labelIndex = getOrAddLabelEntry(label).index;\r\n    int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG && entry.hashCode == hashCode && entry.data == labelIndex && entry.value.equals(value)) {\r\n            return entry.index;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    return addTypeInternal(new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));\r\n}",
    "comment": "\n   * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\n   * type table already contains a similar type.\n   *\n   * @param value an internal class name.\n   * @param label the label of the NEW instruction that created this uninitialized type value. If\n   *     the label is resolved, use the {@link #addUninitializedType} method instead.\n   * @return the index of a new or already existing type {@link Symbol} with the given value.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addMergedType(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Adds a merged type in the type table of this symbol table. Does nothing if the type table\r\n * already contains a similar type.\r\n *\r\n * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\r\n *     table.\r\n * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\r\n *     table.\r\n * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\r\n *     corresponding to the common super class of the given types.\r\n */\r\nint addMergedType(final int typeTableIndex1, final int typeTableIndex2) {\r\n    long data = typeTableIndex1 < typeTableIndex2 ? typeTableIndex1 | (((long) typeTableIndex2) << 32) : typeTableIndex2 | (((long) typeTableIndex1) << 32);\r\n    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);\r\n    Entry entry = get(hashCode);\r\n    while (entry != null) {\r\n        if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {\r\n            return entry.info;\r\n        }\r\n        entry = entry.next;\r\n    }\r\n    String type1 = typeTable[typeTableIndex1].value;\r\n    String type2 = typeTable[typeTableIndex2].value;\r\n    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));\r\n    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;\r\n    return commonSuperTypeIndex;\r\n}",
    "comment": "\n   * Adds a merged type in the type table of this symbol table. Does nothing if the type table\n   * already contains a similar type.\n   *\n   * @param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\n   *     table.\n   * @param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\n   *     table.\n   * @return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\n   *     corresponding to the common super class of the given types.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#addTypeInternal(Entry)",
    "entityType": "method",
    "code": "/**\r\n * Adds the given type Symbol to {@link #typeTable}.\r\n *\r\n * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\r\n *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\r\n * @return the index in {@link #typeTable} where the given type was added, which is also equal to\r\n *     entry's index by hypothesis.\r\n */\r\nprivate int addTypeInternal(final Entry entry) {\r\n    if (typeTable == null) {\r\n        typeTable = new Entry[16];\r\n    }\r\n    if (typeCount == typeTable.length) {\r\n        Entry[] newTypeTable = new Entry[2 * typeTable.length];\r\n        System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);\r\n        typeTable = newTypeTable;\r\n    }\r\n    typeTable[typeCount++] = entry;\r\n    return put(entry).index;\r\n}",
    "comment": "\n   * Adds the given type Symbol to {@link #typeTable}.\n   *\n   * @param entry a {@link Symbol#TYPE_TAG} or {@link Symbol#UNINITIALIZED_TYPE_TAG} type symbol.\n   *     The index of this Symbol must be equal to the current value of {@link #typeCount}.\n   * @return the index in {@link #typeTable} where the given type was added, which is also equal to\n   *     entry's index by hypothesis.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#getOrAddLabelEntry(Label)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\r\n * no such entry.\r\n *\r\n * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\r\n *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\r\n *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\r\n * @return the {@link LabelEntry} corresponding to {@code label}.\r\n */\r\nprivate LabelEntry getOrAddLabelEntry(final Label label) {\r\n    if (labelEntries == null) {\r\n        labelEntries = new LabelEntry[16];\r\n        labelTable = new LabelEntry[16];\r\n    }\r\n    int hashCode = System.identityHashCode(label);\r\n    LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];\r\n    while (labelEntry != null && labelEntry.label != label) {\r\n        labelEntry = labelEntry.next;\r\n    }\r\n    if (labelEntry != null) {\r\n        return labelEntry;\r\n    }\r\n    if (labelCount > (labelEntries.length * 3) / 4) {\r\n        int currentCapacity = labelEntries.length;\r\n        int newCapacity = currentCapacity * 2 + 1;\r\n        LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];\r\n        for (int i = currentCapacity - 1; i >= 0; --i) {\r\n            LabelEntry currentEntry = labelEntries[i];\r\n            while (currentEntry != null) {\r\n                int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;\r\n                LabelEntry nextEntry = currentEntry.next;\r\n                currentEntry.next = newLabelEntries[newCurrentEntryIndex];\r\n                newLabelEntries[newCurrentEntryIndex] = currentEntry;\r\n                currentEntry = nextEntry;\r\n            }\r\n        }\r\n        labelEntries = newLabelEntries;\r\n    }\r\n    if (labelCount == labelTable.length) {\r\n        LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];\r\n        System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);\r\n        labelTable = newLabelTable;\r\n    }\r\n    labelEntry = new LabelEntry(labelCount, label);\r\n    int index = hashCode % labelEntries.length;\r\n    labelEntry.next = labelEntries[index];\r\n    labelEntries[index] = labelEntry;\r\n    labelTable[labelCount++] = labelEntry;\r\n    return labelEntry;\r\n}",
    "comment": "\n   * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\n   * no such entry.\n   *\n   * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\n   *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\n   *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\n   * @return the {@link LabelEntry} corresponding to {@code label}.\n   "
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,int)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Static helper methods to compute hash codes.\r\n// -----------------------------------------------------------------------------------------------\r\nprivate static int hash(final int tag, final int value) {\r\n    return 0x7FFFFFFF & (tag + value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,long)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final long value) {\r\n    return 0x7FFFFFFF & (tag + (int) value + (int) (value >>> 32));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,String)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final String value) {\r\n    return 0x7FFFFFFF & (tag + value.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,String,int)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final String value1, final int value2) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() + value2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,String,String)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final String value1, final String value2) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,String,String,int)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final String value1, final String value2, final int value3) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * (value3 + 1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,String,String,String)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final String value1, final String value2, final String value3) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.SymbolTable#hash(int,String,String,String,int)",
    "entityType": "method",
    "code": "private static int hash(final int tag, final String value1, final String value2, final String value3, final int value4) {\r\n    return 0x7FFFFFFF & (tag + value1.hashCode() * value2.hashCode() * value3.hashCode() * value4);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Entry",
    "entityType": "class",
    "code": "/**\r\n * The hash code of this entry.\r\n */\r\nfinal int hashCode;\n/**\r\n * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\r\n * #entries}) as this one.\r\n */\r\nEntry next;\nEntry(final int index, final int tag, final String owner, final String name, final String value, final long data, final int hashCode) {\r\n    super(index, tag, owner, name, value, data);\r\n    this.hashCode = hashCode;\r\n}\nEntry(final int index, final int tag, final String value, final int hashCode) {\r\n    super(index, tag, /* owner= */\r\n    null, /* name= */\r\n    null, value, /* data= */\r\n    0);\r\n    this.hashCode = hashCode;\r\n}\nEntry(final int index, final int tag, final String value, final long data, final int hashCode) {\r\n    super(index, tag, /* owner= */\r\n    null, /* name= */\r\n    null, value, data);\r\n    this.hashCode = hashCode;\r\n}\nEntry(final int index, final int tag, final String name, final String value, final int hashCode) {\r\n    super(index, tag, /* owner= */\r\n    null, name, value, /* data= */\r\n    0);\r\n    this.hashCode = hashCode;\r\n}\nEntry(final int index, final int tag, final long data, final int hashCode) {\r\n    super(index, tag, /* owner= */\r\n    null, /* name= */\r\n    null, /* value= */\r\n    null, data);\r\n    this.hashCode = hashCode;\r\n}",
    "comment": "\n   * An entry of a SymbolTable. This concrete and private subclass of {@link Symbol} adds two fields\n   * which are only used inside SymbolTable, to implement hash sets of symbols (in order to avoid\n   * duplicate symbols). See {@link #entries}.\n   *\n   * @author Eric Bruneton\n   "
  },
  {
    "entityId": "org.springframework.asm.LabelEntry",
    "entityType": "class",
    "code": "/**\r\n * The index of this label entry in the {@link SymbolTable#labelTable} array.\r\n */\r\nfinal int index;\n/**\r\n * The value of this label entry.\r\n */\r\nfinal Label label;\n/**\r\n * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\r\n * SymbolTable#labelEntries}}) as this one.\r\n */\r\nLabelEntry next;\nLabelEntry(final int index, final Label label) {\r\n    this.index = index;\r\n    this.label = label;\r\n}",
    "comment": "\n   * A label corresponding to a \"forward uninitialized\" type in the ASM specific {@link\n   * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).\n   *\n   * @author Eric Bruneton\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.net.TestSocketUtils",
    "entityType": "class",
    "code": "/**\r\n * The minimum value for port ranges used when finding an available TCP port.\r\n */\r\nprivate static final int PORT_RANGE_MIN = 1024;\n/**\r\n * The maximum value for port ranges used when finding an available TCP port.\r\n */\r\nprivate static final int PORT_RANGE_MAX = 65535;\nprivate static final int PORT_RANGE = PORT_RANGE_MAX - PORT_RANGE_MIN;\nprivate static final int MAX_ATTEMPTS = 1_000;\nprivate static final Random random = new Random(System.nanoTime());\n/**\r\n * Find an available TCP port randomly selected from the range [1024, 65535].\r\n * @return an available TCP port number\r\n * @throws IllegalStateException if no available port could be found\r\n */\r\npublic static int findAvailableTcpPort() {\r\n    int candidatePort;\r\n    int searchCounter = 0;\r\n    do {\r\n        if (searchCounter > MAX_ATTEMPTS) {\r\n            throw new IllegalStateException(String.format(\"Could not find an available TCP port in the range [%d, %d] after %d attempts\", PORT_RANGE_MIN, PORT_RANGE_MAX, MAX_ATTEMPTS));\r\n        }\r\n        candidatePort = PORT_RANGE_MIN + random.nextInt(PORT_RANGE + 1);\r\n        searchCounter++;\r\n    } while (!isPortAvailable(candidatePort));\r\n    return candidatePort;\r\n}\n/**\r\n * Determine if the specified TCP port is currently available on {@code localhost}.\r\n */\r\nprivate static boolean isPortAvailable(int port) {\r\n    try {\r\n        ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket(port, 1, InetAddress.getByName(\"localhost\"));\r\n        serverSocket.close();\r\n        return true;\r\n    } catch (Exception ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": "\n * Simple utility for finding available TCP ports on {@code localhost} for use in\n * integration testing scenarios.\n *\n * <p>{@code SocketUtils} was removed from the public API in {@code spring-core}\n * in Spring Framework 6.0 and reintroduced as {@code TestSocketUtils}, which is\n * made available to all tests in Spring Framework's test suite as a Gradle\n * <em>test fixture</em>.\n *\n * <p>{@code SocketUtils} was introduced in Spring Framework 4.0, primarily to\n * assist in writing integration tests which start an external server on an\n * available random port. However, these utilities make no guarantee about the\n * subsequent availability of a given port and are therefore unreliable. Instead\n * of using {@code TestSocketUtils} to find an available local port for a server,\n * it is recommended that you rely on a server's ability to start on a random port\n * that it selects or is assigned by the operating system. To interact with that\n * server, you should query the server for the port it is currently using.\n *\n * @author Sam Brannen\n * @author Ben Hale\n * @author Arjen Poutsma\n * @author Gunnar Hillert\n * @author Gary Russell\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.core.testfixture.net.TestSocketUtils#findAvailableTcpPort()",
    "entityType": "method",
    "code": "/**\r\n * Find an available TCP port randomly selected from the range [1024, 65535].\r\n * @return an available TCP port number\r\n * @throws IllegalStateException if no available port could be found\r\n */\r\npublic static int findAvailableTcpPort() {\r\n    int candidatePort;\r\n    int searchCounter = 0;\r\n    do {\r\n        if (searchCounter > MAX_ATTEMPTS) {\r\n            throw new IllegalStateException(String.format(\"Could not find an available TCP port in the range [%d, %d] after %d attempts\", PORT_RANGE_MIN, PORT_RANGE_MAX, MAX_ATTEMPTS));\r\n        }\r\n        candidatePort = PORT_RANGE_MIN + random.nextInt(PORT_RANGE + 1);\r\n        searchCounter++;\r\n    } while (!isPortAvailable(candidatePort));\r\n    return candidatePort;\r\n}",
    "comment": "\n\t * Find an available TCP port randomly selected from the range [1024, 65535].\n\t * @return an available TCP port number\n\t * @throws IllegalStateException if no available port could be found\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.net.TestSocketUtils#isPortAvailable(int)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified TCP port is currently available on {@code localhost}.\r\n */\r\nprivate static boolean isPortAvailable(int port) {\r\n    try {\r\n        ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket(port, 1, InetAddress.getByName(\"localhost\"));\r\n        serverSocket.close();\r\n        return true;\r\n    } catch (Exception ex) {\r\n        return false;\r\n    }\r\n}",
    "comment": "\n\t * Determine if the specified TCP port is currently available on {@code localhost}.\n\t "
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor",
    "entityType": "class",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n@Nullable\r\nString nullableProcess();\n@NonNull\r\nString nonNullProcess();\n@NullUnmarked\r\nString unmarkedProcess(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#process(String,String,String)",
    "entityType": "method",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nullableProcess()",
    "entityType": "method",
    "code": "@Nullable\r\nString nullableProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#nonNullProcess()",
    "entityType": "method",
    "code": "@NonNull\r\nString nonNullProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.ClassMarkedJSpecifyProcessor#unmarkedProcess(String,String,String)",
    "entityType": "method",
    "code": "@NullUnmarked\r\nString unmarkedProcess(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  }
]