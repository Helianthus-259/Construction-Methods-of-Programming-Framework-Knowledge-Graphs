[
  {
    "entityId": "org.springframework.util.CommonsLogWriter",
    "entityType": "class",
    "code": "private final Log logger;\nprivate final StringBuilder buffer = new StringBuilder();\n/**\r\n * Create a new CommonsLogWriter for the given Commons Logging logger.\r\n * @param logger the Commons Logging logger to write to\r\n */\r\npublic CommonsLogWriter(Log logger) {\r\n    Assert.notNull(logger, \"Logger must not be null\");\r\n    this.logger = logger;\r\n}\npublic void write(char ch) {\r\n    if (ch == '\\n' && this.buffer.length() > 0) {\r\n        logger.debug(this.buffer.toString());\r\n        this.buffer.setLength(0);\r\n    } else {\r\n        this.buffer.append(ch);\r\n    }\r\n}\n@Override\r\npublic void write(char[] buffer, int offset, int length) {\r\n    for (int i = 0; i < length; i++) {\r\n        write(buffer[offset + i]);\r\n    }\r\n}\n@Override\r\npublic void flush() ;\n@Override\r\npublic void close() ;",
    "comment": "\n * {@code java.io.Writer} adapter for a Commons Logging {@code Log}.\n *\n * @author Juergen Hoeller\n * @since 2.5.1\n "
  },
  {
    "entityId": "org.springframework.util.CommonsLogWriter#write(char)",
    "entityType": "method",
    "code": "public void write(char ch) {\r\n    if (ch == '\\n' && this.buffer.length() > 0) {\r\n        logger.debug(this.buffer.toString());\r\n        this.buffer.setLength(0);\r\n    } else {\r\n        this.buffer.append(ch);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CommonsLogWriter#write(char[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void write(char[] buffer, int offset, int length) {\r\n    for (int i = 0; i < length; i++) {\r\n        write(buffer[offset + i]);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CommonsLogWriter#flush()",
    "entityType": "method",
    "code": "@Override\r\npublic void flush() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CommonsLogWriter#close()",
    "entityType": "method",
    "code": "@Override\r\npublic void close() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparator",
    "entityType": "class",
    "code": "/**\r\n * A shared default instance of this comparator,\r\n * treating {@code true} lower than {@code false}.\r\n */\r\npublic static final BooleanComparator TRUE_LOW = new BooleanComparator(true);\n/**\r\n * A shared default instance of this comparator,\r\n * treating {@code true} higher than {@code false}.\r\n */\r\npublic static final BooleanComparator TRUE_HIGH = new BooleanComparator(false);\nprivate final boolean trueLow;\n/**\r\n * Create a BooleanComparator that sorts boolean values based on\r\n * the provided flag.\r\n * <p>Alternatively, you can use the default shared instances:\r\n * {@code BooleanComparator.TRUE_LOW} and\r\n * {@code BooleanComparator.TRUE_HIGH}.\r\n * @param trueLow whether to treat true as lower or higher than false\r\n * @see #TRUE_LOW\r\n * @see #TRUE_HIGH\r\n */\r\npublic BooleanComparator(boolean trueLow) {\r\n    this.trueLow = trueLow;\r\n}\n@Override\r\npublic int compare(Boolean left, Boolean right) {\r\n    int multiplier = this.trueLow ? -1 : 1;\r\n    return multiplier * Boolean.compare(left, right);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof BooleanComparator that && this.trueLow == that.trueLow));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Boolean.hashCode(this.trueLow);\r\n}\n@Override\r\npublic String toString() {\r\n    return \"BooleanComparator: \" + (this.trueLow ? \"true low\" : \"true high\");\r\n}",
    "comment": "\n * A {@link Comparator} for {@link Boolean} objects that can sort either\n * {@code true} or {@code false} first.\n *\n * @author Keith Donald\n * @author Eugene Rabii\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(Boolean left, Boolean right) {\r\n    int multiplier = this.trueLow ? -1 : 1;\r\n    return multiplier * Boolean.compare(left, right);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparator#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof BooleanComparator that && this.trueLow == that.trueLow));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparator#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Boolean.hashCode(this.trueLow);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.BooleanComparator#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"BooleanComparator: \" + (this.trueLow ? \"true low\" : \"true high\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.ComparableComparator",
    "entityType": "class",
    "code": "/**\r\n * A shared instance of this default comparator.\r\n * @see Comparators#comparable()\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static final ComparableComparator INSTANCE = new ComparableComparator();\n@Override\r\npublic int compare(T o1, T o2) {\r\n    return o1.compareTo(o2);\r\n}",
    "comment": "\n * Comparator that adapts Comparables to the Comparator interface.\n * Mainly for internal use in other Comparators, when supposed\n * to work on Comparables.\n *\n * @author Keith Donald\n * @since 1.2.2\n * @param <T> the type of comparable objects that may be compared by this comparator\n * @see Comparable\n * @deprecated as of 6.1 in favor of {@link Comparator#naturalOrder()}\n "
  },
  {
    "entityId": "org.springframework.util.comparator.ComparableComparator#compare(T,T)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(T o1, T o2) {\r\n    return o1.compareTo(o2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.Comparators",
    "entityType": "class",
    "code": "/**\r\n * Return a {@link Comparable} adapter.\r\n * @see Comparator#naturalOrder()\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T> Comparator<T> comparable() {\r\n    return (Comparator<T>) Comparator.naturalOrder();\r\n}\n/**\r\n * Return a {@link Comparable} adapter which accepts\r\n * null values and sorts them lower than non-null values.\r\n * @see Comparator#nullsFirst(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsLow() {\r\n    return nullsLow(comparable());\r\n}\n/**\r\n * Return a decorator for the given comparator which accepts\r\n * null values and sorts them lower than non-null values.\r\n * @see Comparator#nullsFirst(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsLow(Comparator<T> comparator) {\r\n    return Comparator.nullsFirst(comparator);\r\n}\n/**\r\n * Return a {@link Comparable} adapter which accepts\r\n * null values and sorts them higher than non-null values.\r\n * @see Comparator#nullsLast(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsHigh() {\r\n    return nullsHigh(comparable());\r\n}\n/**\r\n * Return a decorator for the given comparator which accepts\r\n * null values and sorts them higher than non-null values.\r\n * @see Comparator#nullsLast(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsHigh(Comparator<T> comparator) {\r\n    return Comparator.nullsLast(comparator);\r\n}",
    "comment": "\n * Convenient entry point with generically typed factory methods\n * for common Spring {@link Comparator} variants.\n *\n * @author Juergen Hoeller\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.util.comparator.Comparators#comparable()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Comparable} adapter.\r\n * @see Comparator#naturalOrder()\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T> Comparator<T> comparable() {\r\n    return (Comparator<T>) Comparator.naturalOrder();\r\n}",
    "comment": "\n\t * Return a {@link Comparable} adapter.\n\t * @see Comparator#naturalOrder()\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.Comparators#nullsLow()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Comparable} adapter which accepts\r\n * null values and sorts them lower than non-null values.\r\n * @see Comparator#nullsFirst(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsLow() {\r\n    return nullsLow(comparable());\r\n}",
    "comment": "\n\t * Return a {@link Comparable} adapter which accepts\n\t * null values and sorts them lower than non-null values.\n\t * @see Comparator#nullsFirst(Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
    "entityType": "method",
    "code": "/**\r\n * Return a decorator for the given comparator which accepts\r\n * null values and sorts them lower than non-null values.\r\n * @see Comparator#nullsFirst(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsLow(Comparator<T> comparator) {\r\n    return Comparator.nullsFirst(comparator);\r\n}",
    "comment": "\n\t * Return a decorator for the given comparator which accepts\n\t * null values and sorts them lower than non-null values.\n\t * @see Comparator#nullsFirst(Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.Comparators#nullsHigh()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Comparable} adapter which accepts\r\n * null values and sorts them higher than non-null values.\r\n * @see Comparator#nullsLast(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsHigh() {\r\n    return nullsHigh(comparable());\r\n}",
    "comment": "\n\t * Return a {@link Comparable} adapter which accepts\n\t * null values and sorts them higher than non-null values.\n\t * @see Comparator#nullsLast(Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.Comparators#nullsHigh(Comparator<T>)",
    "entityType": "method",
    "code": "/**\r\n * Return a decorator for the given comparator which accepts\r\n * null values and sorts them higher than non-null values.\r\n * @see Comparator#nullsLast(Comparator)\r\n */\r\npublic static <T> Comparator<T> nullsHigh(Comparator<T> comparator) {\r\n    return Comparator.nullsLast(comparator);\r\n}",
    "comment": "\n\t * Return a decorator for the given comparator which accepts\n\t * null values and sorts them higher than non-null values.\n\t * @see Comparator#nullsLast(Comparator)\n\t "
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparator",
    "entityType": "class",
    "code": "private final Class<?>[] instanceOrder;\n/**\r\n * Create a new {@link InstanceComparator} instance.\r\n * @param instanceOrder the ordered list of classes that should be used when comparing\r\n * objects. Classes earlier in the list will be given a higher priority.\r\n */\r\npublic InstanceComparator(Class<?>... instanceOrder) {\r\n    Assert.notNull(instanceOrder, \"'instanceOrder' array must not be null\");\r\n    this.instanceOrder = instanceOrder;\r\n}\n@Override\r\npublic int compare(T o1, T o2) {\r\n    int i1 = getOrder(o1);\r\n    int i2 = getOrder(o2);\r\n    return (Integer.compare(i1, i2));\r\n}\nprivate int getOrder(@Nullable T object) {\r\n    if (object != null) {\r\n        for (int i = 0; i < this.instanceOrder.length; i++) {\r\n            if (this.instanceOrder[i].isInstance(object)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return this.instanceOrder.length;\r\n}",
    "comment": "\n * Compares objects based on an arbitrary class order. Allows objects to be sorted based\n * on the types of class that they inherit &mdash; for example, this comparator can be used\n * to sort a list of {@code Number}s such that {@code Long}s occur before {@code Integer}s.\n *\n * <p>Only the specified {@code instanceOrder} classes are considered during comparison.\n * If two objects are both instances of the ordered type this comparator will return a\n * value of {@code 0}. Consider combining with {@link Comparator#thenComparing(Comparator)}\n * if additional sorting is required.\n *\n * @author Phillip Webb\n * @since 3.2\n * @param <T> the type of objects that may be compared by this comparator\n * @see Comparator#thenComparing(Comparator)\n "
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparator#compare(T,T)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(T o1, T o2) {\r\n    int i1 = getOrder(o1);\r\n    int i2 = getOrder(o2);\r\n    return (Integer.compare(i1, i2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.InstanceComparator#getOrder(T)",
    "entityType": "method",
    "code": "private int getOrder(@Nullable T object) {\r\n    if (object != null) {\r\n        for (int i = 0; i < this.instanceOrder.length; i++) {\r\n            if (this.instanceOrder[i].isInstance(object)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return this.instanceOrder.length;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparator",
    "entityType": "class",
    "code": "/**\r\n * A shared default instance of this comparator, treating nulls lower\r\n * than non-null objects.\r\n * @see Comparators#nullsLow()\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static final NullSafeComparator NULLS_LOW = new NullSafeComparator<>(true);\n/**\r\n * A shared default instance of this comparator, treating nulls higher\r\n * than non-null objects.\r\n * @see Comparators#nullsHigh()\r\n */\r\n@SuppressWarnings(\"rawtypes\")\r\npublic static final NullSafeComparator NULLS_HIGH = new NullSafeComparator<>(false);\nprivate final Comparator<T> nonNullComparator;\nprivate final boolean nullsLow;\n/**\r\n * Create a NullSafeComparator that sorts {@code null} based on\r\n * the provided flag, working on Comparables.\r\n * <p>When comparing two non-null objects, their Comparable implementation\r\n * will be used: this means that non-null elements (that this Comparator\r\n * will be applied to) need to implement Comparable.\r\n * <p>As a convenience, you can use the default shared instances:\r\n * {@code NullSafeComparator.NULLS_LOW} and\r\n * {@code NullSafeComparator.NULLS_HIGH}.\r\n * @param nullsLow whether to treat nulls lower or higher than non-null objects\r\n * @see Comparable\r\n * @see #NULLS_LOW\r\n * @see #NULLS_HIGH\r\n */\r\nprivate NullSafeComparator(boolean nullsLow) {\r\n    this.nonNullComparator = Comparators.comparable();\r\n    this.nullsLow = nullsLow;\r\n}\n/**\r\n * Create a NullSafeComparator that sorts {@code null} based on the\r\n * provided flag, decorating the given Comparator.\r\n * <p>When comparing two non-null objects, the specified Comparator will be used.\r\n * The given underlying Comparator must be able to handle the elements that this\r\n * Comparator will be applied to.\r\n * @param comparator the comparator to use when comparing two non-null objects\r\n * @param nullsLow whether to treat nulls lower or higher than non-null objects\r\n */\r\npublic NullSafeComparator(Comparator<T> comparator, boolean nullsLow) {\r\n    Assert.notNull(comparator, \"Comparator must not be null\");\r\n    this.nonNullComparator = comparator;\r\n    this.nullsLow = nullsLow;\r\n}\n@Override\r\npublic int compare(@Nullable T left, @Nullable T right) {\r\n    Comparator<T> comparator = this.nullsLow ? Comparator.nullsFirst(this.nonNullComparator) : Comparator.nullsLast(this.nonNullComparator);\r\n    return comparator.compare(left, right);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof NullSafeComparator<?> that && this.nonNullComparator.equals(that.nonNullComparator) && this.nullsLow == that.nullsLow));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Boolean.hashCode(this.nullsLow);\r\n}\n@Override\r\npublic String toString() {\r\n    return \"NullSafeComparator: non-null comparator [\" + this.nonNullComparator + \"]; \" + (this.nullsLow ? \"nulls low\" : \"nulls high\");\r\n}",
    "comment": "\n * A Comparator that will safely compare nulls to be lower or higher than\n * other objects. Can decorate a given Comparator or work on Comparables.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 1.2.2\n * @param <T> the type of objects that may be compared by this comparator\n * @see Comparable\n * @see Comparators\n * @deprecated as of 6.1 in favor of {@link Comparator#nullsLast} and {@link Comparator#nullsFirst}\n "
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
    "entityType": "method",
    "code": "@Override\r\npublic int compare(@Nullable T left, @Nullable T right) {\r\n    Comparator<T> comparator = this.nullsLow ? Comparator.nullsFirst(this.nonNullComparator) : Comparator.nullsLast(this.nonNullComparator);\r\n    return comparator.compare(left, right);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparator#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof NullSafeComparator<?> that && this.nonNullComparator.equals(that.nonNullComparator) && this.nullsLow == that.nullsLow));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparator#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Boolean.hashCode(this.nullsLow);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.comparator.NullSafeComparator#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"NullSafeComparator: non-null comparator [\" + this.nonNullComparator + \"]; \" + (this.nullsLow ? \"nulls low\" : \"nulls high\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection",
    "entityType": "class",
    "code": "private final Collection<E> first;\nprivate final Collection<E> second;\nCompositeCollection(Collection<E> first, Collection<E> second) {\r\n    Assert.notNull(first, \"First must not be null\");\r\n    Assert.notNull(second, \"Second must not be null\");\r\n    this.first = first;\r\n    this.second = second;\r\n}\n@Override\r\npublic int size() {\r\n    return this.first.size() + this.second.size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.first.isEmpty() && this.second.isEmpty();\r\n}\n@Override\r\npublic boolean contains(Object o) {\r\n    if (this.first.contains(o)) {\r\n        return true;\r\n    } else {\r\n        return this.second.contains(o);\r\n    }\r\n}\n@Override\r\npublic Iterator<E> iterator() {\r\n    CompositeIterator<E> iterator = new CompositeIterator<>();\r\n    iterator.add(this.first.iterator());\r\n    iterator.add(this.second.iterator());\r\n    return iterator;\r\n}\n@Override\r\npublic Object[] toArray() {\r\n    Object[] result = new Object[size()];\r\n    Object[] firstArray = this.first.toArray();\r\n    Object[] secondArray = this.second.toArray();\r\n    System.arraycopy(firstArray, 0, result, 0, firstArray.length);\r\n    System.arraycopy(secondArray, 0, result, firstArray.length, secondArray.length);\r\n    return result;\r\n}\n@Override\r\n// Overridden method does not define nullness\r\n@SuppressWarnings({ \"unchecked\", \"NullAway\" })\r\n@Nullable\r\npublic <T> T[] toArray(@Nullable T[] a) {\r\n    int size = this.size();\r\n    @Nullable\r\n    T[] result;\r\n    if (a.length >= size) {\r\n        result = a;\r\n    } else {\r\n        result = (T[]) Array.newInstance(a.getClass().getComponentType(), size);\r\n    }\r\n    int idx = 0;\r\n    for (E e : this) {\r\n        result[idx++] = (T) e;\r\n    }\r\n    if (result.length > size) {\r\n        result[size] = null;\r\n    }\r\n    return result;\r\n}\n@Override\r\npublic boolean add(E e) {\r\n    throw new UnsupportedOperationException();\r\n}\n@Override\r\npublic boolean remove(Object o) {\r\n    boolean firstResult = this.first.remove(o);\r\n    boolean secondResult = this.second.remove(o);\r\n    return firstResult || secondResult;\r\n}\n@Override\r\npublic boolean containsAll(Collection<?> c) {\r\n    for (Object o : c) {\r\n        if (!contains(o)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Override\r\npublic boolean addAll(Collection<? extends E> c) {\r\n    boolean changed = false;\r\n    for (E e : c) {\r\n        if (add(e)) {\r\n            changed = true;\r\n        }\r\n    }\r\n    return changed;\r\n}\n@Override\r\npublic boolean removeAll(Collection<?> c) {\r\n    if (c.isEmpty()) {\r\n        return false;\r\n    }\r\n    boolean firstResult = this.first.removeAll(c);\r\n    boolean secondResult = this.second.removeAll(c);\r\n    return firstResult || secondResult;\r\n}\n@Override\r\npublic boolean retainAll(Collection<?> c) {\r\n    boolean firstResult = this.first.retainAll(c);\r\n    boolean secondResult = this.second.retainAll(c);\r\n    return firstResult || secondResult;\r\n}\n@Override\r\npublic void clear() {\r\n    this.first.clear();\r\n    this.second.clear();\r\n}",
    "comment": "\n * Composite collection that combines two other collections. This type is only\n * exposed through {@link CompositeMap#values()}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <E> the type of elements maintained by this collection\n "
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.first.size() + this.second.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.first.isEmpty() && this.second.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(Object o) {\r\n    if (this.first.contains(o)) {\r\n        return true;\r\n    } else {\r\n        return this.second.contains(o);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<E> iterator() {\r\n    CompositeIterator<E> iterator = new CompositeIterator<>();\r\n    iterator.add(this.first.iterator());\r\n    iterator.add(this.second.iterator());\r\n    return iterator;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#toArray()",
    "entityType": "method",
    "code": "@Override\r\npublic Object[] toArray() {\r\n    Object[] result = new Object[size()];\r\n    Object[] firstArray = this.first.toArray();\r\n    Object[] secondArray = this.second.toArray();\r\n    System.arraycopy(firstArray, 0, result, 0, firstArray.length);\r\n    System.arraycopy(secondArray, 0, result, firstArray.length, secondArray.length);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#toArray(T[])",
    "entityType": "method",
    "code": "@Override\r\n// Overridden method does not define nullness\r\n@SuppressWarnings({ \"unchecked\", \"NullAway\" })\r\n@Nullable\r\npublic <T> T[] toArray(@Nullable T[] a) {\r\n    int size = this.size();\r\n    @Nullable\r\n    T[] result;\r\n    if (a.length >= size) {\r\n        result = a;\r\n    } else {\r\n        result = (T[]) Array.newInstance(a.getClass().getComponentType(), size);\r\n    }\r\n    int idx = 0;\r\n    for (E e : this) {\r\n        result[idx++] = (T) e;\r\n    }\r\n    if (result.length > size) {\r\n        result[size] = null;\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#add(E)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean add(E e) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean remove(Object o) {\r\n    boolean firstResult = this.first.remove(o);\r\n    boolean secondResult = this.second.remove(o);\r\n    return firstResult || secondResult;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#containsAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsAll(Collection<?> c) {\r\n    for (Object o : c) {\r\n        if (!contains(o)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#addAll(Collection<? extends E>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean addAll(Collection<? extends E> c) {\r\n    boolean changed = false;\r\n    for (E e : c) {\r\n        if (add(e)) {\r\n            changed = true;\r\n        }\r\n    }\r\n    return changed;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#removeAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean removeAll(Collection<?> c) {\r\n    if (c.isEmpty()) {\r\n        return false;\r\n    }\r\n    boolean firstResult = this.first.removeAll(c);\r\n    boolean secondResult = this.second.removeAll(c);\r\n    return firstResult || secondResult;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#retainAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean retainAll(Collection<?> c) {\r\n    boolean firstResult = this.first.retainAll(c);\r\n    boolean secondResult = this.second.retainAll(c);\r\n    return firstResult || secondResult;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollection#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.first.clear();\r\n    this.second.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIterator",
    "entityType": "class",
    "code": "private final Set<Iterator<E>> iterators = new LinkedHashSet<>();\nprivate boolean inUse = false;\n/**\r\n * Add given iterator to this composite.\r\n */\r\npublic void add(Iterator<E> iterator) {\r\n    Assert.state(!this.inUse, \"You can no longer add iterators to a composite iterator that's already in use\");\r\n    if (this.iterators.contains(iterator)) {\r\n        throw new IllegalArgumentException(\"You cannot add the same iterator twice\");\r\n    }\r\n    this.iterators.add(iterator);\r\n}\n@Override\r\npublic boolean hasNext() {\r\n    this.inUse = true;\r\n    for (Iterator<E> iterator : this.iterators) {\r\n        if (iterator.hasNext()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic E next() {\r\n    this.inUse = true;\r\n    for (Iterator<E> iterator : this.iterators) {\r\n        if (iterator.hasNext()) {\r\n            return iterator.next();\r\n        }\r\n    }\r\n    throw new NoSuchElementException(\"All iterators exhausted\");\r\n}\n@Override\r\npublic void remove() {\r\n    throw new UnsupportedOperationException(\"CompositeIterator does not support remove()\");\r\n}",
    "comment": "\n * Composite iterator that combines multiple other iterators,\n * as registered via {@link #add(Iterator)}.\n *\n * <p>This implementation maintains a linked set of iterators\n * which are invoked in sequence until all iterators are exhausted.\n *\n * @author Erwin Vervaet\n * @author Juergen Hoeller\n * @since 3.0\n * @param <E> the element type\n "
  },
  {
    "entityId": "org.springframework.util.CompositeIterator#add(Iterator<E>)",
    "entityType": "method",
    "code": "/**\r\n * Add given iterator to this composite.\r\n */\r\npublic void add(Iterator<E> iterator) {\r\n    Assert.state(!this.inUse, \"You can no longer add iterators to a composite iterator that's already in use\");\r\n    if (this.iterators.contains(iterator)) {\r\n        throw new IllegalArgumentException(\"You cannot add the same iterator twice\");\r\n    }\r\n    this.iterators.add(iterator);\r\n}",
    "comment": "\n\t * Add given iterator to this composite.\n\t "
  },
  {
    "entityId": "org.springframework.util.CompositeIterator#hasNext()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNext() {\r\n    this.inUse = true;\r\n    for (Iterator<E> iterator : this.iterators) {\r\n        if (iterator.hasNext()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic E next() {\r\n    this.inUse = true;\r\n    for (Iterator<E> iterator : this.iterators) {\r\n        if (iterator.hasNext()) {\r\n            return iterator.next();\r\n        }\r\n    }\r\n    throw new NoSuchElementException(\"All iterators exhausted\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIterator#remove()",
    "entityType": "method",
    "code": "@Override\r\npublic void remove() {\r\n    throw new UnsupportedOperationException(\"CompositeIterator does not support remove()\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap",
    "entityType": "class",
    "code": "private final Map<K, V> first;\nprivate final Map<K, V> second;\n@Nullable\r\nprivate final BiFunction<K, V, V> putFunction;\n@Nullable\r\nprivate final Consumer<Map<K, V>> putAllFunction;\nCompositeMap(Map<K, V> first, Map<K, V> second) {\r\n    this(first, second, null, null);\r\n}\nCompositeMap(Map<K, V> first, Map<K, V> second, @Nullable BiFunction<K, V, V> putFunction, @Nullable Consumer<Map<K, V>> putAllFunction) {\r\n    Assert.notNull(first, \"First must not be null\");\r\n    Assert.notNull(second, \"Second must not be null\");\r\n    this.first = first;\r\n    this.second = new FilteredMap<>(second, key -> !this.first.containsKey(key));\r\n    this.putFunction = putFunction;\r\n    this.putAllFunction = putAllFunction;\r\n}\n@Override\r\npublic int size() {\r\n    return this.first.size() + this.second.size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.first.isEmpty() && this.second.isEmpty();\r\n}\n@Override\r\npublic boolean containsKey(Object key) {\r\n    if (this.first.containsKey(key)) {\r\n        return true;\r\n    } else {\r\n        return this.second.containsKey(key);\r\n    }\r\n}\n@Override\r\npublic boolean containsValue(Object value) {\r\n    if (this.first.containsValue(value)) {\r\n        return true;\r\n    } else {\r\n        return this.second.containsValue(value);\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic V get(Object key) {\r\n    V firstResult = this.first.get(key);\r\n    if (firstResult != null) {\r\n        return firstResult;\r\n    } else {\r\n        return this.second.get(key);\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic V put(K key, V value) {\r\n    if (this.putFunction == null) {\r\n        throw new UnsupportedOperationException();\r\n    } else {\r\n        return this.putFunction.apply(key, value);\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic V remove(Object key) {\r\n    V firstResult = this.first.remove(key);\r\n    V secondResult = this.second.remove(key);\r\n    if (firstResult != null) {\r\n        return firstResult;\r\n    } else {\r\n        return secondResult;\r\n    }\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void putAll(Map<? extends K, ? extends V> m) {\r\n    if (this.putAllFunction != null) {\r\n        this.putAllFunction.accept((Map<K, V>) m);\r\n    } else {\r\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\r\n            put(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n}\n@Override\r\npublic void clear() {\r\n    this.first.clear();\r\n    this.second.clear();\r\n}\n@Override\r\npublic Set<K> keySet() {\r\n    return new CompositeSet<>(this.first.keySet(), this.second.keySet());\r\n}\n@Override\r\npublic Collection<V> values() {\r\n    return new CompositeCollection<>(this.first.values(), this.second.values());\r\n}\n@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    return new CompositeSet<>(this.first.entrySet(), this.second.entrySet());\r\n}\n@Override\r\npublic String toString() {\r\n    Iterator<Entry<K, V>> i = entrySet().iterator();\r\n    if (!i.hasNext()) {\r\n        return \";\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append('{');\r\n    while (true) {\r\n        Entry<K, V> e = i.next();\r\n        K key = e.getKey();\r\n        V value = e.getValue();\r\n        sb.append(key == this ? \"(this Map)\" : key);\r\n        sb.append('=');\r\n        sb.append(value == this ? \"(this Map)\" : value);\r\n        if (!i.hasNext()) {\r\n            return sb.append('}').toString();\r\n        }\r\n        sb.append(',').append(' ');\r\n    }\r\n}",
    "comment": "\n * Composite map that combines two other maps.\n *\n * <p>This type is created via\n * {@link CollectionUtils#compositeMap(Map, Map, BiFunction, Consumer)}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <K> the type of keys maintained by this map\n * @param <V> the type of mapped values\n "
  },
  {
    "entityId": "org.springframework.util.CompositeMap#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return this.first.size() + this.second.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.first.isEmpty() && this.second.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    if (this.first.containsKey(key)) {\r\n        return true;\r\n    } else {\r\n        return this.second.containsKey(key);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#containsValue(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsValue(Object value) {\r\n    if (this.first.containsValue(value)) {\r\n        return true;\r\n    } else {\r\n        return this.second.containsValue(value);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V get(Object key) {\r\n    V firstResult = this.first.get(key);\r\n    if (firstResult != null) {\r\n        return firstResult;\r\n    } else {\r\n        return this.second.get(key);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#put(K,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V put(K key, V value) {\r\n    if (this.putFunction == null) {\r\n        throw new UnsupportedOperationException();\r\n    } else {\r\n        return this.putFunction.apply(key, value);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V remove(Object key) {\r\n    V firstResult = this.first.remove(key);\r\n    V secondResult = this.second.remove(key);\r\n    if (firstResult != null) {\r\n        return firstResult;\r\n    } else {\r\n        return secondResult;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#putAll(Map<? extends K,? extends V>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void putAll(Map<? extends K, ? extends V> m) {\r\n    if (this.putAllFunction != null) {\r\n        this.putAllFunction.accept((Map<K, V>) m);\r\n    } else {\r\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\r\n            put(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.first.clear();\r\n    this.second.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#keySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<K> keySet() {\r\n    return new CompositeSet<>(this.first.keySet(), this.second.keySet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#values()",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<V> values() {\r\n    return new CompositeCollection<>(this.first.values(), this.second.values());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    return new CompositeSet<>(this.first.entrySet(), this.second.entrySet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMap#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    Iterator<Entry<K, V>> i = entrySet().iterator();\r\n    if (!i.hasNext()) {\r\n        return \";\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append('{');\r\n    while (true) {\r\n        Entry<K, V> e = i.next();\r\n        K key = e.getKey();\r\n        V value = e.getValue();\r\n        sb.append(key == this ? \"(this Map)\" : key);\r\n        sb.append('=');\r\n        sb.append(value == this ? \"(this Map)\" : value);\r\n        if (!i.hasNext()) {\r\n            return sb.append('}').toString();\r\n        }\r\n        sb.append(',').append(' ');\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeSet",
    "entityType": "class",
    "code": "CompositeSet(Set<E> first, Set<E> second) {\r\n    super(first, second);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Set<?> otherSet && size() == otherSet.size()) {\r\n        try {\r\n            return containsAll(otherSet);\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic int hashCode() {\r\n    int hashCode = 0;\r\n    for (E obj : this) {\r\n        if (obj != null) {\r\n            hashCode += obj.hashCode();\r\n        }\r\n    }\r\n    return hashCode;\r\n}",
    "comment": "\n * Composite set that combines two other sets. This type is only exposed through\n * {@link CompositeMap#keySet()} and {@link CompositeMap#entrySet()}.\n *\n * @author Arjen Poutsma\n * @since 6.2\n * @param <E> the type of elements maintained by this set\n "
  },
  {
    "entityId": "org.springframework.util.CompositeSet#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Set<?> otherSet && size() == otherSet.size()) {\r\n        try {\r\n            return containsAll(otherSet);\r\n        } catch (ClassCastException | NullPointerException ignored) {\r\n            // fall through\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeSet#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    int hashCode = 0;\r\n    for (E obj : this) {\r\n        if (obj != null) {\r\n            hashCode += obj.hashCode();\r\n        }\r\n    }\r\n    return hashCode;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport",
    "entityType": "class",
    "code": "/**\r\n * Permit any number of concurrent invocations: that is, don't throttle concurrency.\r\n */\r\npublic static final int UNBOUNDED_CONCURRENCY = -1;\n/**\r\n * Switch concurrency 'off': that is, don't allow any concurrent invocations.\r\n */\r\npublic static final int NO_CONCURRENCY = 0;\n/**\r\n * Transient to optimize serialization.\r\n */\r\nprotected transient Log logger = LogFactory.getLog(getClass());\nprivate final Lock concurrencyLock = new ReentrantLock();\nprivate final Condition concurrencyCondition = this.concurrencyLock.newCondition();\nprivate int concurrencyLimit = UNBOUNDED_CONCURRENCY;\nprivate int concurrencyCount = 0;\n/**\r\n * Set the maximum number of concurrent access attempts allowed.\r\n * The default of -1 indicates no concurrency limit at all.\r\n * <p>In principle, this limit can be changed at runtime,\r\n * although it is generally designed as a config time setting.\r\n * <p>NOTE: Do not switch between -1 and any concrete limit at runtime,\r\n * as this will lead to inconsistent concurrency counts: A limit\r\n * of -1 effectively turns off concurrency counting completely.\r\n */\r\npublic void setConcurrencyLimit(int concurrencyLimit) {\r\n    this.concurrencyLimit = concurrencyLimit;\r\n}\n/**\r\n * Return the maximum number of concurrent access attempts allowed.\r\n */\r\npublic int getConcurrencyLimit() {\r\n    return this.concurrencyLimit;\r\n}\n/**\r\n * Return whether this throttle is currently active.\r\n * @return {@code true} if the concurrency limit for this instance is active\r\n * @see #getConcurrencyLimit()\r\n */\r\npublic boolean isThrottleActive() {\r\n    return (this.concurrencyLimit >= 0);\r\n}\n/**\r\n * To be invoked before the main execution logic of concrete subclasses.\r\n * <p>This implementation applies the concurrency throttle.\r\n * @see #afterAccess()\r\n */\r\nprotected void beforeAccess() {\r\n    if (this.concurrencyLimit == NO_CONCURRENCY) {\r\n        throw new IllegalStateException(\"Currently no invocations allowed - concurrency limit set to NO_CONCURRENCY\");\r\n    }\r\n    if (this.concurrencyLimit > 0) {\r\n        boolean debug = logger.isDebugEnabled();\r\n        this.concurrencyLock.lock();\r\n        try {\r\n            boolean interrupted = false;\r\n            while (this.concurrencyCount >= this.concurrencyLimit) {\r\n                if (interrupted) {\r\n                    throw new IllegalStateException(\"Thread was interrupted while waiting for invocation access, \" + \"but concurrency limit still does not allow for entering\");\r\n                }\r\n                if (debug) {\r\n                    logger.debug(\"Concurrency count \" + this.concurrencyCount + \" has reached limit \" + this.concurrencyLimit + \" - blocking\");\r\n                }\r\n                try {\r\n                    this.concurrencyCondition.await();\r\n                } catch (InterruptedException ex) {\r\n                    // Re-interrupt current thread, to allow other threads to react.\r\n                    Thread.currentThread().interrupt();\r\n                    interrupted = true;\r\n                }\r\n            }\r\n            if (debug) {\r\n                logger.debug(\"Entering throttle at concurrency count \" + this.concurrencyCount);\r\n            }\r\n            this.concurrencyCount++;\r\n        } finally {\r\n            this.concurrencyLock.unlock();\r\n        }\r\n    }\r\n}\n/**\r\n * To be invoked after the main execution logic of concrete subclasses.\r\n * @see #beforeAccess()\r\n */\r\nprotected void afterAccess() {\r\n    if (this.concurrencyLimit >= 0) {\r\n        boolean debug = logger.isDebugEnabled();\r\n        this.concurrencyLock.lock();\r\n        try {\r\n            this.concurrencyCount--;\r\n            if (debug) {\r\n                logger.debug(\"Returning from throttle at concurrency count \" + this.concurrencyCount);\r\n            }\r\n            this.concurrencyCondition.signal();\r\n        } finally {\r\n            this.concurrencyLock.unlock();\r\n        }\r\n    }\r\n}\n//---------------------------------------------------------------------\r\n// Serialization support\r\n//---------------------------------------------------------------------\r\nprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\r\n    // Rely on default serialization, just initialize state after deserialization.\r\n    ois.defaultReadObject();\r\n    // Initialize transient fields.\r\n    this.logger = LogFactory.getLog(getClass());\r\n}",
    "comment": "\n * Support class for throttling concurrent access to a specific resource.\n *\n * <p>Designed for use as a base class, with the subclass invoking\n * the {@link #beforeAccess()} and {@link #afterAccess()} methods at\n * appropriate points of its workflow. Note that {@code afterAccess}\n * should usually be called in a {@code finally} block!\n *\n * <p>The default concurrency limit of this support class is -1\n * (\"unbounded concurrency\"). Subclasses may override this default;\n * check the javadoc of the concrete class that you're using.\n *\n * @author Juergen Hoeller\n * @since 1.2.5\n * @see #setConcurrencyLimit\n * @see #beforeAccess()\n * @see #afterAccess()\n * @see org.springframework.aop.interceptor.ConcurrencyThrottleInterceptor\n * @see java.io.Serializable\n "
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport#setConcurrencyLimit(int)",
    "entityType": "method",
    "code": "/**\r\n * Set the maximum number of concurrent access attempts allowed.\r\n * The default of -1 indicates no concurrency limit at all.\r\n * <p>In principle, this limit can be changed at runtime,\r\n * although it is generally designed as a config time setting.\r\n * <p>NOTE: Do not switch between -1 and any concrete limit at runtime,\r\n * as this will lead to inconsistent concurrency counts: A limit\r\n * of -1 effectively turns off concurrency counting completely.\r\n */\r\npublic void setConcurrencyLimit(int concurrencyLimit) {\r\n    this.concurrencyLimit = concurrencyLimit;\r\n}",
    "comment": "\n\t * Set the maximum number of concurrent access attempts allowed.\n\t * The default of -1 indicates no concurrency limit at all.\n\t * <p>In principle, this limit can be changed at runtime,\n\t * although it is generally designed as a config time setting.\n\t * <p>NOTE: Do not switch between -1 and any concrete limit at runtime,\n\t * as this will lead to inconsistent concurrency counts: A limit\n\t * of -1 effectively turns off concurrency counting completely.\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport#getConcurrencyLimit()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum number of concurrent access attempts allowed.\r\n */\r\npublic int getConcurrencyLimit() {\r\n    return this.concurrencyLimit;\r\n}",
    "comment": "\n\t * Return the maximum number of concurrent access attempts allowed.\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
    "entityType": "method",
    "code": "/**\r\n * Return whether this throttle is currently active.\r\n * @return {@code true} if the concurrency limit for this instance is active\r\n * @see #getConcurrencyLimit()\r\n */\r\npublic boolean isThrottleActive() {\r\n    return (this.concurrencyLimit >= 0);\r\n}",
    "comment": "\n\t * Return whether this throttle is currently active.\n\t * @return {@code true} if the concurrency limit for this instance is active\n\t * @see #getConcurrencyLimit()\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
    "entityType": "method",
    "code": "/**\r\n * To be invoked before the main execution logic of concrete subclasses.\r\n * <p>This implementation applies the concurrency throttle.\r\n * @see #afterAccess()\r\n */\r\nprotected void beforeAccess() {\r\n    if (this.concurrencyLimit == NO_CONCURRENCY) {\r\n        throw new IllegalStateException(\"Currently no invocations allowed - concurrency limit set to NO_CONCURRENCY\");\r\n    }\r\n    if (this.concurrencyLimit > 0) {\r\n        boolean debug = logger.isDebugEnabled();\r\n        this.concurrencyLock.lock();\r\n        try {\r\n            boolean interrupted = false;\r\n            while (this.concurrencyCount >= this.concurrencyLimit) {\r\n                if (interrupted) {\r\n                    throw new IllegalStateException(\"Thread was interrupted while waiting for invocation access, \" + \"but concurrency limit still does not allow for entering\");\r\n                }\r\n                if (debug) {\r\n                    logger.debug(\"Concurrency count \" + this.concurrencyCount + \" has reached limit \" + this.concurrencyLimit + \" - blocking\");\r\n                }\r\n                try {\r\n                    this.concurrencyCondition.await();\r\n                } catch (InterruptedException ex) {\r\n                    // Re-interrupt current thread, to allow other threads to react.\r\n                    Thread.currentThread().interrupt();\r\n                    interrupted = true;\r\n                }\r\n            }\r\n            if (debug) {\r\n                logger.debug(\"Entering throttle at concurrency count \" + this.concurrencyCount);\r\n            }\r\n            this.concurrencyCount++;\r\n        } finally {\r\n            this.concurrencyLock.unlock();\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * To be invoked before the main execution logic of concrete subclasses.\n\t * <p>This implementation applies the concurrency throttle.\n\t * @see #afterAccess()\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
    "entityType": "method",
    "code": "/**\r\n * To be invoked after the main execution logic of concrete subclasses.\r\n * @see #beforeAccess()\r\n */\r\nprotected void afterAccess() {\r\n    if (this.concurrencyLimit >= 0) {\r\n        boolean debug = logger.isDebugEnabled();\r\n        this.concurrencyLock.lock();\r\n        try {\r\n            this.concurrencyCount--;\r\n            if (debug) {\r\n                logger.debug(\"Returning from throttle at concurrency count \" + this.concurrencyCount);\r\n            }\r\n            this.concurrencyCondition.signal();\r\n        } finally {\r\n            this.concurrencyLock.unlock();\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * To be invoked after the main execution logic of concrete subclasses.\n\t * @see #beforeAccess()\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Serialization support\r\n//---------------------------------------------------------------------\r\nprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\r\n    // Rely on default serialization, just initialize state after deserialization.\r\n    ois.defaultReadObject();\r\n    // Initialize transient fields.\r\n    this.logger = LogFactory.getLog(getClass());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.DelegatingCompletableFuture",
    "entityType": "class",
    "code": "private final Future<T> delegate;\npublic DelegatingCompletableFuture(Future<T> delegate) {\r\n    Assert.notNull(delegate, \"Delegate must not be null\");\r\n    this.delegate = delegate;\r\n}\n@Override\r\npublic boolean cancel(boolean mayInterruptIfRunning) {\r\n    boolean result = this.delegate.cancel(mayInterruptIfRunning);\r\n    super.cancel(mayInterruptIfRunning);\r\n    return result;\r\n}",
    "comment": "\n * Extension of {@link CompletableFuture} which allows for cancelling\n * a delegate along with the {@link CompletableFuture} itself.\n *\n * @author Juergen Hoeller\n * @since 5.0\n * @param <T> the result type returned by this Future's {@code get} method\n "
  },
  {
    "entityId": "org.springframework.util.concurrent.DelegatingCompletableFuture#cancel(boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean cancel(boolean mayInterruptIfRunning) {\r\n    boolean result = this.delegate.cancel(mayInterruptIfRunning);\r\n    super.cancel(mayInterruptIfRunning);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter",
    "entityType": "class",
    "code": "private final Future<S> adaptee;\n@Nullable\r\nprivate Object result;\nprivate State state = State.NEW;\nprivate final Object mutex = new Object();\n/**\r\n * Constructs a new {@code FutureAdapter} with the given adaptee.\r\n * @param adaptee the future to delegate to\r\n */\r\nprotected FutureAdapter(Future<S> adaptee) {\r\n    Assert.notNull(adaptee, \"Delegate must not be null\");\r\n    this.adaptee = adaptee;\r\n}\n/**\r\n * Returns the adaptee.\r\n */\r\nprotected Future<S> getAdaptee() {\r\n    return this.adaptee;\r\n}\n@Override\r\npublic boolean cancel(boolean mayInterruptIfRunning) {\r\n    return this.adaptee.cancel(mayInterruptIfRunning);\r\n}\n@Override\r\npublic boolean isCancelled() {\r\n    return this.adaptee.isCancelled();\r\n}\n@Override\r\npublic boolean isDone() {\r\n    return this.adaptee.isDone();\r\n}\n@Override\r\n@Nullable\r\npublic T get() throws InterruptedException, ExecutionException {\r\n    return adaptInternal(this.adaptee.get());\r\n}\n@Override\r\n@Nullable\r\npublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\r\n    return adaptInternal(this.adaptee.get(timeout, unit));\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nfinal T adaptInternal(S adapteeResult) throws ExecutionException {\r\n    synchronized (this.mutex) {\r\n        return switch(this.state) {\r\n            case SUCCESS ->\r\n                (T) this.result;\r\n            case FAILURE ->\r\n                {\r\n                    Assert.state(this.result instanceof ExecutionException, \"Failure without exception\");\r\n                    throw (ExecutionException) this.result;\r\n                }\r\n            case NEW ->\r\n                {\r\n                    try {\r\n                        T adapted = adapt(adapteeResult);\r\n                        this.result = adapted;\r\n                        this.state = State.SUCCESS;\r\n                        yield adapted;\r\n                    } catch (ExecutionException ex) {\r\n                        this.result = ex;\r\n                        this.state = State.FAILURE;\r\n                        throw ex;\r\n                    } catch (Throwable ex) {\r\n                        ExecutionException execEx = new ExecutionException(ex);\r\n                        this.result = execEx;\r\n                        this.state = State.FAILURE;\r\n                        throw execEx;\r\n                    }\r\n                }\r\n        };\r\n    }\r\n}\n/**\r\n * Adapts the given adaptee's result into T.\r\n * @return the adapted result\r\n */\r\n@Nullable\r\nprotected abstract T adapt(S adapteeResult) throws ExecutionException;\nprivate enum State {\r\n\r\n    NEW, SUCCESS, FAILURE\r\n}",
    "comment": "\n * Abstract class that adapts a {@link Future} parameterized over S into a {@code Future}\n * parameterized over T. All methods are delegated to the adaptee, where {@link #get()}\n * and {@link #get(long, TimeUnit)} call {@link #adapt(Object)} on the adaptee's result.\n *\n * @author Arjen Poutsma\n * @since 4.0\n * @param <T> the type of this {@code Future}\n * @param <S> the type of the adaptee's {@code Future}\n * @deprecated as of 6.0, with no concrete replacement\n "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#getAdaptee()",
    "entityType": "method",
    "code": "/**\r\n * Returns the adaptee.\r\n */\r\nprotected Future<S> getAdaptee() {\r\n    return this.adaptee;\r\n}",
    "comment": "\n\t * Returns the adaptee.\n\t "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#cancel(boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean cancel(boolean mayInterruptIfRunning) {\r\n    return this.adaptee.cancel(mayInterruptIfRunning);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#isCancelled()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isCancelled() {\r\n    return this.adaptee.isCancelled();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#isDone()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isDone() {\r\n    return this.adaptee.isDone();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#get()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic T get() throws InterruptedException, ExecutionException {\r\n    return adaptInternal(this.adaptee.get());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#get(long,TimeUnit)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\r\n    return adaptInternal(this.adaptee.get(timeout, unit));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nfinal T adaptInternal(S adapteeResult) throws ExecutionException {\r\n    synchronized (this.mutex) {\r\n        return switch(this.state) {\r\n            case SUCCESS ->\r\n                (T) this.result;\r\n            case FAILURE ->\r\n                {\r\n                    Assert.state(this.result instanceof ExecutionException, \"Failure without exception\");\r\n                    throw (ExecutionException) this.result;\r\n                }\r\n            case NEW ->\r\n                {\r\n                    try {\r\n                        T adapted = adapt(adapteeResult);\r\n                        this.result = adapted;\r\n                        this.state = State.SUCCESS;\r\n                        yield adapted;\r\n                    } catch (ExecutionException ex) {\r\n                        this.result = ex;\r\n                        this.state = State.FAILURE;\r\n                        throw ex;\r\n                    } catch (Throwable ex) {\r\n                        ExecutionException execEx = new ExecutionException(ex);\r\n                        this.result = execEx;\r\n                        this.state = State.FAILURE;\r\n                        throw execEx;\r\n                    }\r\n                }\r\n        };\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapter#adapt(S)",
    "entityType": "method",
    "code": "/**\r\n * Adapts the given adaptee's result into T.\r\n * @return the adapted result\r\n */\r\n@Nullable\r\nprotected abstract T adapt(S adapteeResult) throws ExecutionException;",
    "comment": "\n\t * Adapts the given adaptee's result into T.\n\t * @return the adapted result\n\t "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtils",
    "entityType": "class",
    "code": "/**\r\n * Return a new {@code CompletableFuture} that is asynchronously completed\r\n * by a task running in the {@link ForkJoinPool#commonPool()} with\r\n * the value obtained by calling the given {@code Callable}.\r\n * @param callable a function that returns the value to be used, or throws\r\n * an exception\r\n * @return the new CompletableFuture\r\n * @see CompletableFuture#supplyAsync(Supplier)\r\n */\r\npublic static <T> CompletableFuture<T> callAsync(Callable<T> callable) {\r\n    Assert.notNull(callable, \"Callable must not be null\");\r\n    CompletableFuture<T> result = new CompletableFuture<>();\r\n    return result.completeAsync(toSupplier(callable, result));\r\n}\n/**\r\n * Return a new {@code CompletableFuture} that is asynchronously completed\r\n * by a task running in the given executor with the value obtained\r\n * by calling the given {@code Callable}.\r\n * @param callable a function that returns the value to be used, or throws\r\n * an exception\r\n * @param executor the executor to use for asynchronous execution\r\n * @return the new CompletableFuture\r\n * @see CompletableFuture#supplyAsync(Supplier, Executor)\r\n */\r\npublic static <T> CompletableFuture<T> callAsync(Callable<T> callable, Executor executor) {\r\n    Assert.notNull(callable, \"Callable must not be null\");\r\n    Assert.notNull(executor, \"Executor must not be null\");\r\n    CompletableFuture<T> result = new CompletableFuture<>();\r\n    return result.completeAsync(toSupplier(callable, result), executor);\r\n}\nprivate static <T> Supplier<T> toSupplier(Callable<T> callable, CompletableFuture<T> result) {\r\n    return () -> {\r\n        try {\r\n            return callable.call();\r\n        } catch (Exception ex) {\r\n            // wrap the exception just like CompletableFuture::supplyAsync does\r\n            result.completeExceptionally((ex instanceof CompletionException) ? ex : new CompletionException(ex));\r\n            return null;\r\n        }\r\n    };\r\n}",
    "comment": "\n * Convenience utilities for working with {@link java.util.concurrent.Future}\n * and implementations.\n *\n * @author Arjen Poutsma\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
    "entityType": "method",
    "code": "/**\r\n * Return a new {@code CompletableFuture} that is asynchronously completed\r\n * by a task running in the {@link ForkJoinPool#commonPool()} with\r\n * the value obtained by calling the given {@code Callable}.\r\n * @param callable a function that returns the value to be used, or throws\r\n * an exception\r\n * @return the new CompletableFuture\r\n * @see CompletableFuture#supplyAsync(Supplier)\r\n */\r\npublic static <T> CompletableFuture<T> callAsync(Callable<T> callable) {\r\n    Assert.notNull(callable, \"Callable must not be null\");\r\n    CompletableFuture<T> result = new CompletableFuture<>();\r\n    return result.completeAsync(toSupplier(callable, result));\r\n}",
    "comment": "\n\t * Return a new {@code CompletableFuture} that is asynchronously completed\n\t * by a task running in the {@link ForkJoinPool#commonPool()} with\n\t * the value obtained by calling the given {@code Callable}.\n\t * @param callable a function that returns the value to be used, or throws\n\t * an exception\n\t * @return the new CompletableFuture\n\t * @see CompletableFuture#supplyAsync(Supplier)\n\t "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
    "entityType": "method",
    "code": "/**\r\n * Return a new {@code CompletableFuture} that is asynchronously completed\r\n * by a task running in the given executor with the value obtained\r\n * by calling the given {@code Callable}.\r\n * @param callable a function that returns the value to be used, or throws\r\n * an exception\r\n * @param executor the executor to use for asynchronous execution\r\n * @return the new CompletableFuture\r\n * @see CompletableFuture#supplyAsync(Supplier, Executor)\r\n */\r\npublic static <T> CompletableFuture<T> callAsync(Callable<T> callable, Executor executor) {\r\n    Assert.notNull(callable, \"Callable must not be null\");\r\n    Assert.notNull(executor, \"Executor must not be null\");\r\n    CompletableFuture<T> result = new CompletableFuture<>();\r\n    return result.completeAsync(toSupplier(callable, result), executor);\r\n}",
    "comment": "\n\t * Return a new {@code CompletableFuture} that is asynchronously completed\n\t * by a task running in the given executor with the value obtained\n\t * by calling the given {@code Callable}.\n\t * @param callable a function that returns the value to be used, or throws\n\t * an exception\n\t * @param executor the executor to use for asynchronous execution\n\t * @return the new CompletableFuture\n\t * @see CompletableFuture#supplyAsync(Supplier, Executor)\n\t "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
    "entityType": "method",
    "code": "private static <T> Supplier<T> toSupplier(Callable<T> callable, CompletableFuture<T> result) {\r\n    return () -> {\r\n        try {\r\n            return callable.call();\r\n        } catch (Exception ex) {\r\n            // wrap the exception just like CompletableFuture::supplyAsync does\r\n            result.completeExceptionally((ex instanceof CompletionException) ? ex : new CompletionException(ex));\r\n            return null;\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache",
    "entityType": "class",
    "code": "private final int capacity;\nprivate final AtomicInteger currentSize = new AtomicInteger();\nprivate final ConcurrentMap<K, Node<K, V>> cache;\nprivate final Function<K, V> generator;\nprivate final ReadOperations<K, V> readOperations;\nprivate final WriteOperations writeOperations;\nprivate final Lock evictionLock = new ReentrantLock();\n/*\r\n\t * Queue that contains all ACTIVE cache entries, ordered with least recently used entries first.\r\n\t * Read and write operations are buffered and periodically processed to reorder the queue.\r\n\t */\r\nprivate final EvictionQueue<K, V> evictionQueue = new EvictionQueue<>();\nprivate final AtomicReference<DrainStatus> drainStatus = new AtomicReference<>(DrainStatus.IDLE);\n/**\r\n * Create a new cache instance with the given capacity and generator function.\r\n * @param capacity the maximum number of entries in the cache\r\n * (0 indicates no caching, always generating a new value)\r\n * @param generator a function to generate a new value for a given key\r\n */\r\npublic ConcurrentLruCache(int capacity, Function<K, V> generator) {\r\n    this(capacity, generator, 16);\r\n}\nprivate ConcurrentLruCache(int capacity, Function<K, V> generator, int concurrencyLevel) {\r\n    Assert.isTrue(capacity >= 0, \"Capacity must be >= 0\");\r\n    this.capacity = capacity;\r\n    this.cache = new ConcurrentHashMap<>(16, 0.75f, concurrencyLevel);\r\n    this.generator = generator;\r\n    this.readOperations = new ReadOperations<>(this.evictionQueue);\r\n    this.writeOperations = new WriteOperations();\r\n}\n/**\r\n * Retrieve an entry from the cache, potentially triggering generation of the value.\r\n * @param key the key to retrieve the entry for\r\n * @return the cached or newly generated value\r\n */\r\npublic V get(K key) {\r\n    if (this.capacity == 0) {\r\n        return this.generator.apply(key);\r\n    }\r\n    final Node<K, V> node = this.cache.get(key);\r\n    if (node == null) {\r\n        V value = this.generator.apply(key);\r\n        put(key, value);\r\n        return value;\r\n    }\r\n    processRead(node);\r\n    return node.getValue();\r\n}\nprivate void put(K key, V value) {\r\n    Assert.notNull(key, \"key must not be null\");\r\n    Assert.notNull(value, \"value must not be null\");\r\n    final CacheEntry<V> cacheEntry = new CacheEntry<>(value, CacheEntryState.ACTIVE);\r\n    final Node<K, V> node = new Node<>(key, cacheEntry);\r\n    final Node<K, V> prior = this.cache.putIfAbsent(node.key, node);\r\n    if (prior == null) {\r\n        processWrite(new AddTask(node));\r\n    } else {\r\n        processRead(prior);\r\n    }\r\n}\nprivate void processRead(Node<K, V> node) {\r\n    boolean drainRequested = this.readOperations.recordRead(node);\r\n    final DrainStatus status = this.drainStatus.get();\r\n    if (status.shouldDrainBuffers(drainRequested)) {\r\n        drainOperations();\r\n    }\r\n}\nprivate void processWrite(Runnable task) {\r\n    this.writeOperations.add(task);\r\n    this.drainStatus.lazySet(DrainStatus.REQUIRED);\r\n    drainOperations();\r\n}\nprivate void drainOperations() {\r\n    if (this.evictionLock.tryLock()) {\r\n        try {\r\n            this.drainStatus.lazySet(DrainStatus.PROCESSING);\r\n            this.readOperations.drain();\r\n            this.writeOperations.drain();\r\n        } finally {\r\n            this.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE);\r\n            this.evictionLock.unlock();\r\n        }\r\n    }\r\n}\n/**\r\n * Return the maximum number of entries in the cache.\r\n * @see #size()\r\n */\r\npublic int capacity() {\r\n    return this.capacity;\r\n}\n/**\r\n * Return the maximum number of entries in the cache.\r\n * @deprecated in favor of {@link #capacity()} as of 6.0.\r\n */\r\n@Deprecated(since = \"6.0\")\r\npublic int sizeLimit() {\r\n    return this.capacity;\r\n}\n/**\r\n * Return the current size of the cache.\r\n * @see #capacity()\r\n */\r\npublic int size() {\r\n    return this.cache.size();\r\n}\n/**\r\n * Immediately remove all entries from this cache.\r\n */\r\npublic void clear() {\r\n    this.evictionLock.lock();\r\n    try {\r\n        Node<K, V> node;\r\n        while ((node = this.evictionQueue.poll()) != null) {\r\n            this.cache.remove(node.key, node);\r\n            markAsRemoved(node);\r\n        }\r\n        this.readOperations.clear();\r\n        this.writeOperations.drainAll();\r\n    } finally {\r\n        this.evictionLock.unlock();\r\n    }\r\n}\n/*\r\n\t * Transition the node to the {@code removed} state and decrement the current size of the cache.\r\n\t */\r\nprivate void markAsRemoved(Node<K, V> node) {\r\n    for (; ; ) {\r\n        CacheEntry<V> current = node.get();\r\n        CacheEntry<V> removed = new CacheEntry<>(current.value, CacheEntryState.REMOVED);\r\n        if (node.compareAndSet(current, removed)) {\r\n            this.currentSize.lazySet(this.currentSize.get() - 1);\r\n            return;\r\n        }\r\n    }\r\n}\n/**\r\n * Determine whether the given key is present in this cache.\r\n * @param key the key to check for\r\n * @return {@code true} if the key is present, {@code false} if there was no matching key\r\n */\r\npublic boolean contains(K key) {\r\n    return this.cache.containsKey(key);\r\n}\n/**\r\n * Immediately remove the given key and any associated value.\r\n * @param key the key to evict the entry for\r\n * @return {@code true} if the key was present before,\r\n * {@code false} if there was no matching key\r\n */\r\npublic boolean remove(K key) {\r\n    final Node<K, V> node = this.cache.remove(key);\r\n    if (node == null) {\r\n        return false;\r\n    }\r\n    markForRemoval(node);\r\n    processWrite(new RemovalTask(node));\r\n    return true;\r\n}\n/*\r\n\t * Transition the node from the {@code active} state to the {@code pending removal} state,\r\n\t * if the transition is valid.\r\n\t */\r\nprivate void markForRemoval(Node<K, V> node) {\r\n    for (; ; ) {\r\n        final CacheEntry<V> current = node.get();\r\n        if (!current.isActive()) {\r\n            return;\r\n        }\r\n        final CacheEntry<V> pendingRemoval = new CacheEntry<>(current.value, CacheEntryState.PENDING_REMOVAL);\r\n        if (node.compareAndSet(current, pendingRemoval)) {\r\n            return;\r\n        }\r\n    }\r\n}\n/**\r\n * Write operation recorded when a new entry is added to the cache.\r\n */\r\nprivate final class AddTask implements Runnable {\r\n\r\n    final Node<K, V> node;\r\n\r\n    AddTask(Node<K, V> node) {\r\n        this.node = node;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        currentSize.lazySet(currentSize.get() + 1);\r\n        if (this.node.get().isActive()) {\r\n            evictionQueue.add(this.node);\r\n            evictEntries();\r\n        }\r\n    }\r\n\r\n    private void evictEntries() {\r\n        while (currentSize.get() > capacity) {\r\n            final Node<K, V> node = evictionQueue.poll();\r\n            if (node == null) {\r\n                return;\r\n            }\r\n            cache.remove(node.key, node);\r\n            markAsRemoved(node);\r\n        }\r\n    }\r\n}\n/**\r\n * Write operation recorded when an entry is removed to the cache.\r\n */\r\nprivate final class RemovalTask implements Runnable {\r\n\r\n    final Node<K, V> node;\r\n\r\n    RemovalTask(Node<K, V> node) {\r\n        this.node = node;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        evictionQueue.remove(this.node);\r\n        markAsRemoved(this.node);\r\n    }\r\n}\n/*\r\n\t * Draining status for the read/write buffers.\r\n\t */\r\nprivate enum DrainStatus {\r\n\r\n    /*\r\n\t\t * No drain operation currently running.\r\n\t\t */\r\n    IDLE {\r\n\r\n        @Override\r\n        boolean shouldDrainBuffers(boolean delayable) {\r\n            return !delayable;\r\n        }\r\n    }\r\n    ,\r\n    /*\r\n\t\t * A drain operation is required due to a pending write modification.\r\n\t\t */\r\n    REQUIRED {\r\n\r\n        @Override\r\n        boolean shouldDrainBuffers(boolean delayable) {\r\n            return true;\r\n        }\r\n    }\r\n    ,\r\n    /*\r\n\t\t * A drain operation is in progress.\r\n\t\t */\r\n    PROCESSING {\r\n\r\n        @Override\r\n        boolean shouldDrainBuffers(boolean delayable) {\r\n            return false;\r\n        }\r\n    }\r\n    ;\r\n\r\n    /**\r\n     * Determine whether the buffers should be drained.\r\n     * @param delayable if a drain should be delayed until required\r\n     * @return if a drain should be attempted\r\n     */\r\n    abstract boolean shouldDrainBuffers(boolean delayable);\r\n}\nprivate enum CacheEntryState {\r\n\r\n    ACTIVE, PENDING_REMOVAL, REMOVED\r\n}\nprivate record CacheEntry<V>(V value, CacheEntryState state) {\r\n\r\n    boolean isActive() {\r\n        return this.state == CacheEntryState.ACTIVE;\r\n    }\r\n}\nprivate static final class ReadOperations<K, V> {\r\n\r\n    private static final int BUFFER_COUNT = detectNumberOfBuffers();\r\n\r\n    private static int detectNumberOfBuffers() {\r\n        int availableProcessors = Runtime.getRuntime().availableProcessors();\r\n        int nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1));\r\n        return Math.min(4, nextPowerOfTwo);\r\n    }\r\n\r\n    private static final int BUFFERS_MASK = BUFFER_COUNT - 1;\r\n\r\n    private static final int MAX_PENDING_OPERATIONS = 32;\r\n\r\n    private static final int MAX_DRAIN_COUNT = 2 * MAX_PENDING_OPERATIONS;\r\n\r\n    private static final int BUFFER_SIZE = 2 * MAX_DRAIN_COUNT;\r\n\r\n    private static final int BUFFER_INDEX_MASK = BUFFER_SIZE - 1;\r\n\r\n    /*\r\n\t\t * Number of operations recorded, for each buffer\r\n\t\t */\r\n    private final AtomicLongArray recordedCount = new AtomicLongArray(BUFFER_COUNT);\r\n\r\n    /*\r\n\t\t * Number of operations read, for each buffer\r\n\t\t */\r\n    private final long[] readCount = new long[BUFFER_COUNT];\r\n\r\n    /*\r\n\t\t * Number of operations processed, for each buffer\r\n\t\t */\r\n    private final AtomicLongArray processedCount = new AtomicLongArray(BUFFER_COUNT);\r\n\r\n    @SuppressWarnings(\"rawtypes\")\r\n    private final AtomicReferenceArray<Node<K, V>>[] buffers = new AtomicReferenceArray[BUFFER_COUNT];\r\n\r\n    private final EvictionQueue<K, V> evictionQueue;\r\n\r\n    ReadOperations(EvictionQueue<K, V> evictionQueue) {\r\n        this.evictionQueue = evictionQueue;\r\n        for (int i = 0; i < BUFFER_COUNT; i++) {\r\n            this.buffers[i] = new AtomicReferenceArray<>(BUFFER_SIZE);\r\n        }\r\n    }\r\n\r\n    // for Thread.getId() on JDK 19\r\n    @SuppressWarnings(\"deprecation\")\r\n    private static int getBufferIndex() {\r\n        return ((int) Thread.currentThread().getId()) & BUFFERS_MASK;\r\n    }\r\n\r\n    boolean recordRead(Node<K, V> node) {\r\n        int bufferIndex = getBufferIndex();\r\n        final long writeCount = this.recordedCount.get(bufferIndex);\r\n        this.recordedCount.lazySet(bufferIndex, writeCount + 1);\r\n        final int index = (int) (writeCount & BUFFER_INDEX_MASK);\r\n        this.buffers[bufferIndex].lazySet(index, node);\r\n        final long pending = (writeCount - this.processedCount.get(bufferIndex));\r\n        return (pending < MAX_PENDING_OPERATIONS);\r\n    }\r\n\r\n    // for Thread.getId() on JDK 19\r\n    @SuppressWarnings(\"deprecation\")\r\n    void drain() {\r\n        final int start = (int) Thread.currentThread().getId();\r\n        final int end = start + BUFFER_COUNT;\r\n        for (int i = start; i < end; i++) {\r\n            drainReadBuffer(i & BUFFERS_MASK);\r\n        }\r\n    }\r\n\r\n    void clear() {\r\n        for (int i = 0; i < BUFFER_COUNT; i++) {\r\n            AtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\r\n            for (int j = 0; j < BUFFER_SIZE; j++) {\r\n                buffer.lazySet(j, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void drainReadBuffer(int bufferIndex) {\r\n        final long writeCount = this.recordedCount.get(bufferIndex);\r\n        for (int i = 0; i < MAX_DRAIN_COUNT; i++) {\r\n            final int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK);\r\n            final AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex];\r\n            final Node<K, V> node = buffer.get(index);\r\n            if (node == null) {\r\n                break;\r\n            }\r\n            buffer.lazySet(index, null);\r\n            this.evictionQueue.moveToBack(node);\r\n            this.readCount[bufferIndex]++;\r\n        }\r\n        this.processedCount.lazySet(bufferIndex, writeCount);\r\n    }\r\n}\nprivate static final class WriteOperations {\r\n\r\n    private static final int DRAIN_THRESHOLD = 16;\r\n\r\n    private final Queue<Runnable> operations = new ConcurrentLinkedQueue<>();\r\n\r\n    public void add(Runnable task) {\r\n        this.operations.add(task);\r\n    }\r\n\r\n    public void drain() {\r\n        for (int i = 0; i < DRAIN_THRESHOLD; i++) {\r\n            final Runnable task = this.operations.poll();\r\n            if (task == null) {\r\n                break;\r\n            }\r\n            task.run();\r\n        }\r\n    }\r\n\r\n    public void drainAll() {\r\n        Runnable task;\r\n        while ((task = this.operations.poll()) != null) {\r\n            task.run();\r\n        }\r\n    }\r\n}\n@SuppressWarnings(\"serial\")\r\nprivate static final class Node<K, V> extends AtomicReference<CacheEntry<V>> {\r\n\r\n    final K key;\r\n\r\n    @Nullable\r\n    Node<K, V> prev;\r\n\r\n    @Nullable\r\n    Node<K, V> next;\r\n\r\n    Node(K key, CacheEntry<V> cacheEntry) {\r\n        super(cacheEntry);\r\n        this.key = key;\r\n    }\r\n\r\n    @Nullable\r\n    public Node<K, V> getPrevious() {\r\n        return this.prev;\r\n    }\r\n\r\n    public void setPrevious(@Nullable Node<K, V> prev) {\r\n        this.prev = prev;\r\n    }\r\n\r\n    @Nullable\r\n    public Node<K, V> getNext() {\r\n        return this.next;\r\n    }\r\n\r\n    public void setNext(@Nullable Node<K, V> next) {\r\n        this.next = next;\r\n    }\r\n\r\n    V getValue() {\r\n        return get().value;\r\n    }\r\n}\nprivate static final class EvictionQueue<K, V> {\r\n\r\n    @Nullable\r\n    Node<K, V> first;\r\n\r\n    @Nullable\r\n    Node<K, V> last;\r\n\r\n    @Nullable\r\n    Node<K, V> poll() {\r\n        if (this.first == null) {\r\n            return null;\r\n        }\r\n        final Node<K, V> f = this.first;\r\n        final Node<K, V> next = f.getNext();\r\n        f.setNext(null);\r\n        this.first = next;\r\n        if (next == null) {\r\n            this.last = null;\r\n        } else {\r\n            next.setPrevious(null);\r\n        }\r\n        return f;\r\n    }\r\n\r\n    void add(Node<K, V> e) {\r\n        if (contains(e)) {\r\n            return;\r\n        }\r\n        linkLast(e);\r\n    }\r\n\r\n    private boolean contains(Node<K, V> e) {\r\n        return (e.getPrevious() != null) || (e.getNext() != null) || (e == this.first);\r\n    }\r\n\r\n    private void linkLast(final Node<K, V> e) {\r\n        final Node<K, V> l = this.last;\r\n        this.last = e;\r\n        if (l == null) {\r\n            this.first = e;\r\n        } else {\r\n            l.setNext(e);\r\n            e.setPrevious(l);\r\n        }\r\n    }\r\n\r\n    private void unlink(Node<K, V> e) {\r\n        final Node<K, V> prev = e.getPrevious();\r\n        final Node<K, V> next = e.getNext();\r\n        if (prev == null) {\r\n            this.first = next;\r\n        } else {\r\n            prev.setNext(next);\r\n            e.setPrevious(null);\r\n        }\r\n        if (next == null) {\r\n            this.last = prev;\r\n        } else {\r\n            next.setPrevious(prev);\r\n            e.setNext(null);\r\n        }\r\n    }\r\n\r\n    void moveToBack(Node<K, V> e) {\r\n        if (contains(e) && e != this.last) {\r\n            unlink(e);\r\n            linkLast(e);\r\n        }\r\n    }\r\n\r\n    void remove(Node<K, V> e) {\r\n        if (contains(e)) {\r\n            unlink(e);\r\n        }\r\n    }\r\n}",
    "comment": "\n * Simple LRU (Least Recently Used) cache, bounded by a specified cache capacity.\n * <p>This is a simplified, opinionated implementation of an LRU cache for internal\n * use in Spring Framework. It is inspired from\n * <a href=\"https://github.com/ben-manes/concurrentlinkedhashmap\">ConcurrentLinkedHashMap</a>.\n * <p>Read and write operations are internally recorded in dedicated buffers,\n * then drained at chosen times to avoid contention.\n *\n * @author Brian Clozel\n * @author Ben Manes\n * @since 5.3\n * @param <K> the type of the key used for cache retrieval\n * @param <V> the type of the cached values, does not allow null values\n * @see #get(Object)\n "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#get(K)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve an entry from the cache, potentially triggering generation of the value.\r\n * @param key the key to retrieve the entry for\r\n * @return the cached or newly generated value\r\n */\r\npublic V get(K key) {\r\n    if (this.capacity == 0) {\r\n        return this.generator.apply(key);\r\n    }\r\n    final Node<K, V> node = this.cache.get(key);\r\n    if (node == null) {\r\n        V value = this.generator.apply(key);\r\n        put(key, value);\r\n        return value;\r\n    }\r\n    processRead(node);\r\n    return node.getValue();\r\n}",
    "comment": "\n\t * Retrieve an entry from the cache, potentially triggering generation of the value.\n\t * @param key the key to retrieve the entry for\n\t * @return the cached or newly generated value\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#put(K,V)",
    "entityType": "method",
    "code": "private void put(K key, V value) {\r\n    Assert.notNull(key, \"key must not be null\");\r\n    Assert.notNull(value, \"value must not be null\");\r\n    final CacheEntry<V> cacheEntry = new CacheEntry<>(value, CacheEntryState.ACTIVE);\r\n    final Node<K, V> node = new Node<>(key, cacheEntry);\r\n    final Node<K, V> prior = this.cache.putIfAbsent(node.key, node);\r\n    if (prior == null) {\r\n        processWrite(new AddTask(node));\r\n    } else {\r\n        processRead(prior);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#processRead(Node<K,V>)",
    "entityType": "method",
    "code": "private void processRead(Node<K, V> node) {\r\n    boolean drainRequested = this.readOperations.recordRead(node);\r\n    final DrainStatus status = this.drainStatus.get();\r\n    if (status.shouldDrainBuffers(drainRequested)) {\r\n        drainOperations();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#processWrite(Runnable)",
    "entityType": "method",
    "code": "private void processWrite(Runnable task) {\r\n    this.writeOperations.add(task);\r\n    this.drainStatus.lazySet(DrainStatus.REQUIRED);\r\n    drainOperations();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#drainOperations()",
    "entityType": "method",
    "code": "private void drainOperations() {\r\n    if (this.evictionLock.tryLock()) {\r\n        try {\r\n            this.drainStatus.lazySet(DrainStatus.PROCESSING);\r\n            this.readOperations.drain();\r\n            this.writeOperations.drain();\r\n        } finally {\r\n            this.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE);\r\n            this.evictionLock.unlock();\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#capacity()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum number of entries in the cache.\r\n * @see #size()\r\n */\r\npublic int capacity() {\r\n    return this.capacity;\r\n}",
    "comment": "\n\t * Return the maximum number of entries in the cache.\n\t * @see #size()\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#sizeLimit()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum number of entries in the cache.\r\n * @deprecated in favor of {@link #capacity()} as of 6.0.\r\n */\r\n@Deprecated(since = \"6.0\")\r\npublic int sizeLimit() {\r\n    return this.capacity;\r\n}",
    "comment": "\n\t * Return the maximum number of entries in the cache.\n\t * @deprecated in favor of {@link #capacity()} as of 6.0.\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#size()",
    "entityType": "method",
    "code": "/**\r\n * Return the current size of the cache.\r\n * @see #capacity()\r\n */\r\npublic int size() {\r\n    return this.cache.size();\r\n}",
    "comment": "\n\t * Return the current size of the cache.\n\t * @see #capacity()\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#clear()",
    "entityType": "method",
    "code": "/**\r\n * Immediately remove all entries from this cache.\r\n */\r\npublic void clear() {\r\n    this.evictionLock.lock();\r\n    try {\r\n        Node<K, V> node;\r\n        while ((node = this.evictionQueue.poll()) != null) {\r\n            this.cache.remove(node.key, node);\r\n            markAsRemoved(node);\r\n        }\r\n        this.readOperations.clear();\r\n        this.writeOperations.drainAll();\r\n    } finally {\r\n        this.evictionLock.unlock();\r\n    }\r\n}",
    "comment": "\n\t * Immediately remove all entries from this cache.\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#markAsRemoved(Node<K,V>)",
    "entityType": "method",
    "code": "/*\r\n\t * Transition the node to the {@code removed} state and decrement the current size of the cache.\r\n\t */\r\nprivate void markAsRemoved(Node<K, V> node) {\r\n    for (; ; ) {\r\n        CacheEntry<V> current = node.get();\r\n        CacheEntry<V> removed = new CacheEntry<>(current.value, CacheEntryState.REMOVED);\r\n        if (node.compareAndSet(current, removed)) {\r\n            this.currentSize.lazySet(this.currentSize.get() - 1);\r\n            return;\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Transition the node to the {@code removed} state and decrement the current size of the cache.\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#contains(K)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given key is present in this cache.\r\n * @param key the key to check for\r\n * @return {@code true} if the key is present, {@code false} if there was no matching key\r\n */\r\npublic boolean contains(K key) {\r\n    return this.cache.containsKey(key);\r\n}",
    "comment": "\n\t * Determine whether the given key is present in this cache.\n\t * @param key the key to check for\n\t * @return {@code true} if the key is present, {@code false} if there was no matching key\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#remove(K)",
    "entityType": "method",
    "code": "/**\r\n * Immediately remove the given key and any associated value.\r\n * @param key the key to evict the entry for\r\n * @return {@code true} if the key was present before,\r\n * {@code false} if there was no matching key\r\n */\r\npublic boolean remove(K key) {\r\n    final Node<K, V> node = this.cache.remove(key);\r\n    if (node == null) {\r\n        return false;\r\n    }\r\n    markForRemoval(node);\r\n    processWrite(new RemovalTask(node));\r\n    return true;\r\n}",
    "comment": "\n\t * Immediately remove the given key and any associated value.\n\t * @param key the key to evict the entry for\n\t * @return {@code true} if the key was present before,\n\t * {@code false} if there was no matching key\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
    "entityType": "method",
    "code": "/*\r\n\t * Transition the node from the {@code active} state to the {@code pending removal} state,\r\n\t * if the transition is valid.\r\n\t */\r\nprivate void markForRemoval(Node<K, V> node) {\r\n    for (; ; ) {\r\n        final CacheEntry<V> current = node.get();\r\n        if (!current.isActive()) {\r\n            return;\r\n        }\r\n        final CacheEntry<V> pendingRemoval = new CacheEntry<>(current.value, CacheEntryState.PENDING_REMOVAL);\r\n        if (node.compareAndSet(current, pendingRemoval)) {\r\n            return;\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Transition the node from the {@code active} state to the {@code pending removal} state,\n\t * if the transition is valid.\n\t "
  },
  {
    "entityId": "org.springframework.util.AddTask",
    "entityType": "class",
    "code": "final Node<K, V> node;\nAddTask(Node<K, V> node) {\r\n    this.node = node;\r\n}\n@Override\r\npublic void run() {\r\n    currentSize.lazySet(currentSize.get() + 1);\r\n    if (this.node.get().isActive()) {\r\n        evictionQueue.add(this.node);\r\n        evictEntries();\r\n    }\r\n}\nprivate void evictEntries() {\r\n    while (currentSize.get() > capacity) {\r\n        final Node<K, V> node = evictionQueue.poll();\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        cache.remove(node.key, node);\r\n        markAsRemoved(node);\r\n    }\r\n}",
    "comment": "\n\t * Write operation recorded when a new entry is added to the cache.\n\t "
  },
  {
    "entityId": "org.springframework.util.AddTask#run()",
    "entityType": "method",
    "code": "@Override\r\npublic void run() {\r\n    currentSize.lazySet(currentSize.get() + 1);\r\n    if (this.node.get().isActive()) {\r\n        evictionQueue.add(this.node);\r\n        evictEntries();\r\n    }\r\n}",
    "comment": ""
  }
]