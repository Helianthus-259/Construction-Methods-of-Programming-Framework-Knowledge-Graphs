[
  {
    "entityId": "org.springframework.aot.generate.ClassTests#generateWhenClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenClass() {\r\n    assertThat(resolve(generateCode(InputStream.class))).hasImport(InputStream.class).hasValueCode(\"InputStream.class\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ClassTests#generateWhenCglibClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenCglibClass() {\r\n    assertThat(resolve(generateCode(ExampleClass$$GeneratedBy.class))).hasImport(ExampleClass.class).hasValueCode(\"ExampleClass.class\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests",
    "entityType": "class",
    "code": "@Test\r\nvoid generateWhenSimpleResolvableType() {\r\n    ResolvableType resolvableType = ResolvableType.forClass(String.class);\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class).hasValueCode(\"ResolvableType.forClass(String.class)\");\r\n}\n@Test\r\nvoid generateWhenNoneResolvableType() {\r\n    ResolvableType resolvableType = ResolvableType.NONE;\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class).hasValueCode(\"ResolvableType.NONE\");\r\n}\n@Test\r\nvoid generateWhenGenericResolvableType() {\r\n    ResolvableType resolvableType = ResolvableType.forClassWithGenerics(List.class, String.class);\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class).hasValueCode(\"ResolvableType.forClassWithGenerics(List.class, String.class)\");\r\n}\n@Test\r\nvoid generateWhenNestedGenericResolvableType() {\r\n    ResolvableType stringList = ResolvableType.forClassWithGenerics(List.class, String.class);\r\n    ResolvableType resolvableType = ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(Integer.class), stringList);\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class, Map.class).hasValueCode(\"ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(Integer.class), \" + \"ResolvableType.forClassWithGenerics(List.class, String.class))\");\r\n}\n@Test\r\nvoid generateWhenUnresolvedGenericType() throws NoSuchFieldException {\r\n    ResolvableType resolvableType = ResolvableType.forField(SampleTypes.class.getField(\"genericList\"));\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class).hasValueCode(\"ResolvableType.forClass(List.class)\");\r\n}\n@Test\r\nvoid generateWhenUnresolvedNestedGenericType() throws NoSuchFieldException {\r\n    ResolvableType resolvableType = ResolvableType.forField(SampleTypes.class.getField(\"mapWithNestedGenericInValueType\"));\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class).hasValueCode(\"\"\"\r\n        ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(String.class), \\\r\n        ResolvableType.forClass(List.class))\"\"\");\r\n}\nstatic class SampleTypes<A> {\r\n\r\n    public List<A> genericList;\r\n\r\n    public Map<String, List<A>> mapWithNestedGenericInValueType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenSimpleResolvableType() {\r\n    ResolvableType resolvableType = ResolvableType.forClass(String.class);\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class).hasValueCode(\"ResolvableType.forClass(String.class)\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNoneResolvableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenNoneResolvableType() {\r\n    ResolvableType resolvableType = ResolvableType.NONE;\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class).hasValueCode(\"ResolvableType.NONE\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenGenericResolvableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenGenericResolvableType() {\r\n    ResolvableType resolvableType = ResolvableType.forClassWithGenerics(List.class, String.class);\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class).hasValueCode(\"ResolvableType.forClassWithGenerics(List.class, String.class)\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNestedGenericResolvableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenNestedGenericResolvableType() {\r\n    ResolvableType stringList = ResolvableType.forClassWithGenerics(List.class, String.class);\r\n    ResolvableType resolvableType = ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(Integer.class), stringList);\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class, Map.class).hasValueCode(\"ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(Integer.class), \" + \"ResolvableType.forClassWithGenerics(List.class, String.class))\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenUnresolvedGenericType() throws NoSuchFieldException {\r\n    ResolvableType resolvableType = ResolvableType.forField(SampleTypes.class.getField(\"genericList\"));\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class).hasValueCode(\"ResolvableType.forClass(List.class)\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedNestedGenericType()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenUnresolvedNestedGenericType() throws NoSuchFieldException {\r\n    ResolvableType resolvableType = ResolvableType.forField(SampleTypes.class.getField(\"mapWithNestedGenericInValueType\"));\r\n    assertThat(resolve(generateCode(resolvableType))).hasImport(ResolvableType.class, List.class).hasValueCode(\"\"\"\r\n        ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(String.class), \\\r\n        ResolvableType.forClass(List.class))\"\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SampleTypes",
    "entityType": "class",
    "code": "public List<A> genericList;\npublic Map<String, List<A>> mapWithNestedGenericInValueType;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ArrayTests",
    "entityType": "class",
    "code": "@Test\r\nvoid generateWhenPrimitiveArray() {\r\n    int[] array = { 0, 1, 2 };\r\n    assertThat(generateCode(array)).hasToString(\"new int[] {0, 1, 2}\");\r\n}\n@Test\r\nvoid generateWhenWrapperArray() {\r\n    Integer[] array = { 0, 1, 2 };\r\n    assertThat(resolve(generateCode(array))).hasValueCode(\"new Integer[] {0, 1, 2}\");\r\n}\n@Test\r\nvoid generateWhenClassArray() {\r\n    Class<?>[] array = new Class<?>[] { InputStream.class, OutputStream.class };\r\n    assertThat(resolve(generateCode(array))).hasImport(InputStream.class, OutputStream.class).hasValueCode(\"new Class[] {InputStream.class, OutputStream.class}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ArrayTests#generateWhenPrimitiveArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenPrimitiveArray() {\r\n    int[] array = { 0, 1, 2 };\r\n    assertThat(generateCode(array)).hasToString(\"new int[] {0, 1, 2}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ArrayTests#generateWhenWrapperArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenWrapperArray() {\r\n    Integer[] array = { 0, 1, 2 };\r\n    assertThat(resolve(generateCode(array))).hasValueCode(\"new Integer[] {0, 1, 2}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ArrayTests#generateWhenClassArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenClassArray() {\r\n    Class<?>[] array = new Class<?>[] { InputStream.class, OutputStream.class };\r\n    assertThat(resolve(generateCode(array))).hasImport(InputStream.class, OutputStream.class).hasValueCode(\"new Class[] {InputStream.class, OutputStream.class}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ListTests",
    "entityType": "class",
    "code": "@Test\r\nvoid generateWhenStringList() {\r\n    List<String> list = List.of(\"a\", \"b\", \"c\");\r\n    assertThat(resolve(generateCode(list))).hasImport(List.class).hasValueCode(\"List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\")\");\r\n}\n@Test\r\nvoid generateWhenEmptyList() {\r\n    List<String> list = List.of();\r\n    assertThat(resolve(generateCode(list))).hasImport(Collections.class).hasValueCode(\"Collections.emptyList()\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ListTests#generateWhenStringList()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenStringList() {\r\n    List<String> list = List.of(\"a\", \"b\", \"c\");\r\n    assertThat(resolve(generateCode(list))).hasImport(List.class).hasValueCode(\"List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\")\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ListTests#generateWhenEmptyList()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenEmptyList() {\r\n    List<String> list = List.of();\r\n    assertThat(resolve(generateCode(list))).hasImport(Collections.class).hasValueCode(\"Collections.emptyList()\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SetTests",
    "entityType": "class",
    "code": "@Test\r\nvoid generateWhenStringSet() {\r\n    Set<String> set = Set.of(\"a\", \"b\", \"c\");\r\n    assertThat(resolve(generateCode(set))).hasImport(Set.class).hasValueCode(\"Set.of(\\\"a\\\", \\\"b\\\", \\\"c\\\")\");\r\n}\n@Test\r\nvoid generateWhenEmptySet() {\r\n    Set<String> set = Set.of();\r\n    assertThat(resolve(generateCode(set))).hasImport(Collections.class).hasValueCode(\"Collections.emptySet()\");\r\n}\n@Test\r\nvoid generateWhenLinkedHashSet() {\r\n    Set<String> set = new LinkedHashSet<>(List.of(\"a\", \"b\", \"c\"));\r\n    assertThat(resolve(generateCode(set))).hasImport(List.class, LinkedHashSet.class).hasValueCode(\"new LinkedHashSet(List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\"))\");\r\n}\n@Test\r\nvoid generateWhenSetOfClass() {\r\n    Set<Class<?>> set = Set.of(InputStream.class, OutputStream.class);\r\n    assertThat(resolve(generateCode(set))).hasImport(Set.class, InputStream.class, OutputStream.class).valueCode().contains(\"Set.of(\", \"InputStream.class\", \"OutputStream.class\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SetTests#generateWhenStringSet()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenStringSet() {\r\n    Set<String> set = Set.of(\"a\", \"b\", \"c\");\r\n    assertThat(resolve(generateCode(set))).hasImport(Set.class).hasValueCode(\"Set.of(\\\"a\\\", \\\"b\\\", \\\"c\\\")\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SetTests#generateWhenEmptySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenEmptySet() {\r\n    Set<String> set = Set.of();\r\n    assertThat(resolve(generateCode(set))).hasImport(Collections.class).hasValueCode(\"Collections.emptySet()\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenLinkedHashSet() {\r\n    Set<String> set = new LinkedHashSet<>(List.of(\"a\", \"b\", \"c\"));\r\n    assertThat(resolve(generateCode(set))).hasImport(List.class, LinkedHashSet.class).hasValueCode(\"new LinkedHashSet(List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\"))\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenSetOfClass() {\r\n    Set<Class<?>> set = Set.of(InputStream.class, OutputStream.class);\r\n    assertThat(resolve(generateCode(set))).hasImport(Set.class, InputStream.class, OutputStream.class).valueCode().contains(\"Set.of(\", \"InputStream.class\", \"OutputStream.class\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MapTests",
    "entityType": "class",
    "code": "@Test\r\nvoid generateWhenSmallMap() {\r\n    Map<String, String> map = Map.of(\"k1\", \"v1\", \"k2\", \"v2\");\r\n    assertThat(resolve(generateCode(map))).hasImport(Map.class).hasValueCode(\"Map.of(\\\"k1\\\", \\\"v1\\\", \\\"k2\\\", \\\"v2\\\")\");\r\n}\n@Test\r\nvoid generateWhenMapWithOverTenElements() {\r\n    Map<String, String> map = new HashMap<>();\r\n    for (int i = 1; i <= 11; i++) {\r\n        map.put(\"k\" + i, \"v\" + i);\r\n    }\r\n    assertThat(resolve(generateCode(map))).hasImport(Map.class).valueCode().startsWith(\"Map.ofEntries(\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MapTests#generateWhenSmallMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenSmallMap() {\r\n    Map<String, String> map = Map.of(\"k1\", \"v1\", \"k2\", \"v2\");\r\n    assertThat(resolve(generateCode(map))).hasImport(Map.class).hasValueCode(\"Map.of(\\\"k1\\\", \\\"v1\\\", \\\"k2\\\", \\\"v2\\\")\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.MapTests#generateWhenMapWithOverTenElements()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenMapWithOverTenElements() {\r\n    Map<String, String> map = new HashMap<>();\r\n    for (int i = 1; i <= 11; i++) {\r\n        map.put(\"k\" + i, \"v\" + i);\r\n    }\r\n    assertThat(resolve(generateCode(map))).hasImport(Map.class).valueCode().startsWith(\"Map.ofEntries(\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ExceptionTests",
    "entityType": "class",
    "code": "@Test\r\nvoid generateWhenUnsupportedValue() {\r\n    StringWriter sw = new StringWriter();\r\n    assertThatExceptionOfType(ValueCodeGenerationException.class).isThrownBy(() -> generateCode(sw)).withCauseInstanceOf(UnsupportedTypeValueCodeGenerationException.class).satisfies(ex -> assertThat(ex.getValue()).isEqualTo(sw));\r\n}\n@Test\r\nvoid generateWhenUnsupportedDataTypeThrowsException() {\r\n    StringWriter sampleValue = new StringWriter();\r\n    assertThatExceptionOfType(ValueCodeGenerationException.class).isThrownBy(() -> generateCode(sampleValue)).withMessageContaining(\"Failed to generate code for\").withMessageContaining(sampleValue.toString()).withMessageContaining(StringWriter.class.getName()).havingCause().withMessageContaining(\"Code generation does not support\").withMessageContaining(StringWriter.class.getName());\r\n}\n@Test\r\nvoid generateWhenListOfUnsupportedElement() {\r\n    StringWriter one = new StringWriter();\r\n    StringWriter two = new StringWriter();\r\n    List<StringWriter> list = List.of(one, two);\r\n    assertThatExceptionOfType(ValueCodeGenerationException.class).isThrownBy(() -> generateCode(list)).withMessageContaining(\"Failed to generate code for\").withMessageContaining(list.toString()).withMessageContaining(list.getClass().getName()).havingCause().withMessageContaining(\"Failed to generate code for\").withMessageContaining(one.toString()).withMessageContaining(StringWriter.class.getName()).havingCause().withMessageContaining(\"Code generation does not support \" + StringWriter.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenUnsupportedValue() {\r\n    StringWriter sw = new StringWriter();\r\n    assertThatExceptionOfType(ValueCodeGenerationException.class).isThrownBy(() -> generateCode(sw)).withCauseInstanceOf(UnsupportedTypeValueCodeGenerationException.class).satisfies(ex -> assertThat(ex.getValue()).isEqualTo(sw));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenUnsupportedDataTypeThrowsException() {\r\n    StringWriter sampleValue = new StringWriter();\r\n    assertThatExceptionOfType(ValueCodeGenerationException.class).isThrownBy(() -> generateCode(sampleValue)).withMessageContaining(\"Failed to generate code for\").withMessageContaining(sampleValue.toString()).withMessageContaining(StringWriter.class.getName()).havingCause().withMessageContaining(\"Code generation does not support\").withMessageContaining(StringWriter.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
    "entityType": "method",
    "code": "@Test\r\nvoid generateWhenListOfUnsupportedElement() {\r\n    StringWriter one = new StringWriter();\r\n    StringWriter two = new StringWriter();\r\n    List<StringWriter> list = List.of(one, two);\r\n    assertThatExceptionOfType(ValueCodeGenerationException.class).isThrownBy(() -> generateCode(list)).withMessageContaining(\"Failed to generate code for\").withMessageContaining(list.toString()).withMessageContaining(list.getClass().getName()).havingCause().withMessageContaining(\"Failed to generate code for\").withMessageContaining(one.toString()).withMessageContaining(StringWriter.class.getName()).havingCause().withMessageContaining(\"Code generation does not support \" + StringWriter.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeAssert",
    "entityType": "class",
    "code": "public ValueCodeAssert(ValueCode actual) {\r\n    super(actual, ValueCodeAssert.class);\r\n}\nValueCodeAssert hasImport(Class<?>... imports) {\r\n    for (Class<?> anImport : imports) {\r\n        assertThat(this.actual.imports).contains(anImport.getName());\r\n    }\r\n    return this;\r\n}\nValueCodeAssert hasValueCode(String code) {\r\n    assertThat(this.actual.code).isEqualTo(code);\r\n    return this;\r\n}\nStringAssert valueCode() {\r\n    return new StringAssert(this.actual.code);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeAssert#hasImport(Class<?>)",
    "entityType": "method",
    "code": "ValueCodeAssert hasImport(Class<?>... imports) {\r\n    for (Class<?> anImport : imports) {\r\n        assertThat(this.actual.imports).contains(anImport.getName());\r\n    }\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeAssert#hasValueCode(String)",
    "entityType": "method",
    "code": "ValueCodeAssert hasValueCode(String code) {\r\n    assertThat(this.actual.code).isEqualTo(code);\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.generate.ValueCodeAssert#valueCode()",
    "entityType": "method",
    "code": "StringAssert valueCode() {\r\n    return new StringAssert(this.actual.code);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
    "entityType": "class",
    "code": "private final ReflectiveRuntimeHintsRegistrar registrar = new ReflectiveRuntimeHintsRegistrar();\nprivate final RuntimeHints runtimeHints = new RuntimeHints();\n@ParameterizedTest\r\n@ValueSource(classes = { SampleTypeAnnotatedBean.class, SampleFieldAnnotatedBean.class, SampleConstructorAnnotatedBean.class, SampleMethodAnnotatedBean.class, SampleInterface.class, SampleMethodMetaAnnotatedBeanWithAlias.class, SampleMethodAnnotatedBeanWithInterface.class })\r\nvoid isCandidateWithMatchingAnnotatedElement(Class<?> candidate) {\r\n    assertThat(this.registrar.isCandidate(candidate)).isTrue();\r\n}\n@ParameterizedTest\r\n@ValueSource(classes = { String.class, Closeable.class })\r\nvoid isCandidateWithNonMatchingAnnotatedElement(Class<?> candidate) {\r\n    assertThat(this.registrar.isCandidate(candidate)).isFalse();\r\n}\n@Test\r\nvoid shouldIgnoreNonAnnotatedType() {\r\n    RuntimeHints mock = mock();\r\n    this.registrar.registerRuntimeHints(mock, String.class);\r\n    verifyNoInteractions(mock);\r\n}\n@Test\r\nvoid shouldProcessAnnotationOnType() {\r\n    process(SampleTypeAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleTypeAnnotatedBean.class)).isNotNull();\r\n}\n@Test\r\nvoid shouldProcessWithMultipleProcessorsWithAnnotationOnType() {\r\n    process(SampleMultipleCustomProcessors.class);\r\n    TypeHint typeHint = this.runtimeHints.reflection().getTypeHint(SampleMultipleCustomProcessors.class);\r\n    assertThat(typeHint).isNotNull();\r\n    assertThat(typeHint.getMemberCategories()).containsExactly(MemberCategory.INVOKE_DECLARED_METHODS);\r\n}\n@Test\r\nvoid shouldProcessAnnotationOnConstructor() {\r\n    process(SampleConstructorAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleConstructorAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.constructors()).singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class))));\r\n}\n@Test\r\nvoid shouldProcessAnnotationOnField() {\r\n    process(SampleFieldAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleFieldAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.fields()).singleElement().satisfies(fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"managed\")));\r\n}\n@Test\r\nvoid shouldProcessAnnotationOnMethod() {\r\n    process(SampleMethodAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleMethodAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n}\n@Test\r\nvoid shouldProcessAnnotationOnInterface() {\r\n    process(SampleMethodAnnotatedBeanWithInterface.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleInterface.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleMethodAnnotatedBeanWithInterface.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n}\n@Test\r\nvoid shouldProcessAnnotationOnInheritedClass() {\r\n    process(SampleMethodAnnotatedBeanWithInheritance.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleInheritedClass.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleMethodAnnotatedBeanWithInheritance.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n}\n@Test\r\nvoid shouldProcessDifferentAnnotationsOnTypeAndField() {\r\n    process(SampleTypeAndFieldAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleTypeAndFieldAnnotatedBean.class)).satisfies(typeHint -> {\r\n        assertThat(typeHint.fields().map(FieldHint::getName)).containsOnly(\"MESSAGE\");\r\n        assertThat(typeHint.getMemberCategories()).containsOnly(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.methods()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n    });\r\n}\n@Test\r\nvoid shouldInvokeCustomProcessor() {\r\n    process(SampleCustomProcessor.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleCustomProcessor.class, \"managed\")).accepts(this.runtimeHints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS)).accepts(this.runtimeHints);\r\n}\nprivate void process(Class<?> beanClass) {\r\n    this.registrar.registerRuntimeHints(this.runtimeHints, beanClass);\r\n}\n@Reflective\r\n@SuppressWarnings(\"unused\")\r\nstatic class SampleTypeAnnotatedBean {\r\n\r\n    private String notManaged;\r\n\r\n    public void notManaged() {\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nstatic class SampleConstructorAnnotatedBean {\r\n\r\n    @Reflective\r\n    SampleConstructorAnnotatedBean(String name) {\r\n    }\r\n\r\n    SampleConstructorAnnotatedBean(Integer nameAsNumber) {\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nstatic class SampleFieldAnnotatedBean {\r\n\r\n    @Reflective\r\n    String managed;\r\n\r\n    String notManaged;\r\n}\n@SuppressWarnings(\"unused\")\r\nstatic class SampleMethodAnnotatedBean {\r\n\r\n    @Reflective\r\n    void managed() {\r\n    }\r\n\r\n    void notManaged() {\r\n    }\r\n}\n@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\r\nstatic class SampleTypeAndFieldAnnotatedBean {\r\n\r\n    @Reflective\r\n    private static final String MESSAGE = \"Hello\";\r\n}\n@SuppressWarnings(\"unused\")\r\nstatic class SampleMethodMetaAnnotatedBean {\r\n\r\n    @SampleInvoker\r\n    void invoke() {\r\n    }\r\n\r\n    void notManaged() {\r\n    }\r\n}\n@SuppressWarnings(\"unused\")\r\nstatic class SampleMethodMetaAnnotatedBeanWithAlias {\r\n\r\n    @RetryInvoker\r\n    void invoke() {\r\n    }\r\n\r\n    void notManaged() {\r\n    }\r\n}\nstatic class SampleMethodAnnotatedBeanWithInterface implements SampleInterface {\r\n\r\n    @Override\r\n    public void managed() {\r\n    }\r\n\r\n    public void notManaged() {\r\n    }\r\n}\nstatic class SampleMethodAnnotatedBeanWithInheritance extends SampleInheritedClass {\r\n\r\n    @Override\r\n    public void managed() {\r\n    }\r\n\r\n    public void notManaged() {\r\n    }\r\n}\n@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Reflective\r\n@interface SampleInvoker {\r\n\r\n    int retries() default 0;\r\n}\n@Target({ ElementType.METHOD })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@SampleInvoker\r\n@interface RetryInvoker {\r\n\r\n    @AliasFor(attribute = \"retries\", annotation = SampleInvoker.class)\r\n    int value() default 1;\r\n}\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Reflective(TestTypeHintReflectiveProcessor.class)\r\n@interface ReflectiveWithCustomProcessor {\r\n}\ninterface SampleInterface {\r\n\r\n    @Reflective\r\n    void managed();\r\n}\nstatic class SampleInheritedClass {\r\n\r\n    @Reflective\r\n    void managed() {\r\n    }\r\n}\nstatic class SampleCustomProcessor {\r\n\r\n    @Reflective(TestMethodHintReflectiveProcessor.class)\r\n    public String managed() {\r\n        return \"test\";\r\n    }\r\n}\n@Reflective\r\n@ReflectiveWithCustomProcessor\r\nstatic class SampleMultipleCustomProcessors {\r\n\r\n    public String managed() {\r\n        return \"test\";\r\n    }\r\n}\nprivate static class TestMethodHintReflectiveProcessor extends SimpleReflectiveProcessor {\r\n\r\n    @Override\r\n    protected void registerMethodHint(ReflectionHints hints, Method method) {\r\n        super.registerMethodHint(hints, method);\r\n        hints.registerType(method.getReturnType(), MemberCategory.INVOKE_DECLARED_METHODS);\r\n    }\r\n}\nprivate static class TestTypeHintReflectiveProcessor extends SimpleReflectiveProcessor {\r\n\r\n    @Override\r\n    protected void registerTypeHint(ReflectionHints hints, Class<?> type) {\r\n        super.registerTypeHint(hints, type);\r\n        hints.registerType(type, MemberCategory.INVOKE_DECLARED_METHODS);\r\n    }\r\n}",
    "comment": "\n * Tests for {@link ReflectiveRuntimeHintsRegistrar}.\n *\n * @author Stephane Nicoll\n * @author Andy Wilkinson\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@ValueSource(classes = { SampleTypeAnnotatedBean.class, SampleFieldAnnotatedBean.class, SampleConstructorAnnotatedBean.class, SampleMethodAnnotatedBean.class, SampleInterface.class, SampleMethodMetaAnnotatedBeanWithAlias.class, SampleMethodAnnotatedBeanWithInterface.class })\r\nvoid isCandidateWithMatchingAnnotatedElement(Class<?> candidate) {\r\n    assertThat(this.registrar.isCandidate(candidate)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
    "entityType": "method",
    "code": "@ParameterizedTest\r\n@ValueSource(classes = { String.class, Closeable.class })\r\nvoid isCandidateWithNonMatchingAnnotatedElement(Class<?> candidate) {\r\n    assertThat(this.registrar.isCandidate(candidate)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldIgnoreNonAnnotatedType()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldIgnoreNonAnnotatedType() {\r\n    RuntimeHints mock = mock();\r\n    this.registrar.registerRuntimeHints(mock, String.class);\r\n    verifyNoInteractions(mock);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessAnnotationOnType() {\r\n    process(SampleTypeAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleTypeAnnotatedBean.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessWithMultipleProcessorsWithAnnotationOnType() {\r\n    process(SampleMultipleCustomProcessors.class);\r\n    TypeHint typeHint = this.runtimeHints.reflection().getTypeHint(SampleMultipleCustomProcessors.class);\r\n    assertThat(typeHint).isNotNull();\r\n    assertThat(typeHint.getMemberCategories()).containsExactly(MemberCategory.INVOKE_DECLARED_METHODS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessAnnotationOnConstructor() {\r\n    process(SampleConstructorAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleConstructorAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.constructors()).singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class))));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessAnnotationOnField() {\r\n    process(SampleFieldAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleFieldAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.fields()).singleElement().satisfies(fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"managed\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessAnnotationOnMethod() {\r\n    process(SampleMethodAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleMethodAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessAnnotationOnInterface() {\r\n    process(SampleMethodAnnotatedBeanWithInterface.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleInterface.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleMethodAnnotatedBeanWithInterface.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessAnnotationOnInheritedClass() {\r\n    process(SampleMethodAnnotatedBeanWithInheritance.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleInheritedClass.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleMethodAnnotatedBeanWithInheritance.class)).satisfies(typeHint -> assertThat(typeHint.methods()).singleElement().satisfies(methodHint -> assertThat(methodHint.getName()).isEqualTo(\"managed\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessDifferentAnnotationsOnTypeAndField()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldProcessDifferentAnnotationsOnTypeAndField() {\r\n    process(SampleTypeAndFieldAnnotatedBean.class);\r\n    assertThat(this.runtimeHints.reflection().getTypeHint(SampleTypeAndFieldAnnotatedBean.class)).satisfies(typeHint -> {\r\n        assertThat(typeHint.fields().map(FieldHint::getName)).containsOnly(\"MESSAGE\");\r\n        assertThat(typeHint.getMemberCategories()).containsOnly(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n        assertThat(typeHint.methods()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldInvokeCustomProcessor() {\r\n    process(SampleCustomProcessor.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleCustomProcessor.class, \"managed\")).accepts(this.runtimeHints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS)).accepts(this.runtimeHints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#process(Class<?>)",
    "entityType": "method",
    "code": "private void process(Class<?> beanClass) {\r\n    this.registrar.registerRuntimeHints(this.runtimeHints, beanClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleTypeAnnotatedBean",
    "entityType": "class",
    "code": "private String notManaged;\npublic void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleTypeAnnotatedBean#notManaged()",
    "entityType": "method",
    "code": "public void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleConstructorAnnotatedBean",
    "entityType": "class",
    "code": "@Reflective\r\nSampleConstructorAnnotatedBean(String name) {\r\n}\nSampleConstructorAnnotatedBean(Integer nameAsNumber) {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleFieldAnnotatedBean",
    "entityType": "class",
    "code": "@Reflective\r\nString managed;\nString notManaged;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean",
    "entityType": "class",
    "code": "@Reflective\r\nvoid managed() ;\nvoid notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean#managed()",
    "entityType": "method",
    "code": "@Reflective\r\nvoid managed() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean#notManaged()",
    "entityType": "method",
    "code": "void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleTypeAndFieldAnnotatedBean",
    "entityType": "class",
    "code": "@Reflective\r\nprivate static final String MESSAGE = \"Hello\";",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean",
    "entityType": "class",
    "code": "@SampleInvoker\r\nvoid invoke() ;\nvoid notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#invoke()",
    "entityType": "method",
    "code": "@SampleInvoker\r\nvoid invoke() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#notManaged()",
    "entityType": "method",
    "code": "void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias",
    "entityType": "class",
    "code": "@RetryInvoker\r\nvoid invoke() ;\nvoid notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias#invoke()",
    "entityType": "method",
    "code": "@RetryInvoker\r\nvoid invoke() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias#notManaged()",
    "entityType": "method",
    "code": "void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
    "entityType": "class",
    "code": "@Override\r\npublic void managed() ;\npublic void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#managed()",
    "entityType": "method",
    "code": "@Override\r\npublic void managed() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#notManaged()",
    "entityType": "method",
    "code": "public void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
    "entityType": "class",
    "code": "@Override\r\npublic void managed() ;\npublic void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#managed()",
    "entityType": "method",
    "code": "@Override\r\npublic void managed() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#notManaged()",
    "entityType": "method",
    "code": "public void notManaged() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleInterface",
    "entityType": "class",
    "code": "@Reflective\r\nvoid managed();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleInterface#managed()",
    "entityType": "method",
    "code": "@Reflective\r\nvoid managed();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleInheritedClass",
    "entityType": "class",
    "code": "@Reflective\r\nvoid managed() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleInheritedClass#managed()",
    "entityType": "method",
    "code": "@Reflective\r\nvoid managed() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
    "entityType": "class",
    "code": "@Reflective(TestMethodHintReflectiveProcessor.class)\r\npublic String managed() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleCustomProcessor#managed()",
    "entityType": "method",
    "code": "@Reflective(TestMethodHintReflectiveProcessor.class)\r\npublic String managed() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMultipleCustomProcessors",
    "entityType": "class",
    "code": "public String managed() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleMultipleCustomProcessors#managed()",
    "entityType": "method",
    "code": "public String managed() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.TestMethodHintReflectiveProcessor",
    "entityType": "class",
    "code": "@Override\r\nprotected void registerMethodHint(ReflectionHints hints, Method method) {\r\n    super.registerMethodHint(hints, method);\r\n    hints.registerType(method.getReturnType(), MemberCategory.INVOKE_DECLARED_METHODS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.TestMethodHintReflectiveProcessor#registerMethodHint(ReflectionHints,Method)",
    "entityType": "method",
    "code": "@Override\r\nprotected void registerMethodHint(ReflectionHints hints, Method method) {\r\n    super.registerMethodHint(hints, method);\r\n    hints.registerType(method.getReturnType(), MemberCategory.INVOKE_DECLARED_METHODS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor",
    "entityType": "class",
    "code": "@Override\r\nprotected void registerTypeHint(ReflectionHints hints, Class<?> type) {\r\n    super.registerTypeHint(hints, type);\r\n    hints.registerType(type, MemberCategory.INVOKE_DECLARED_METHODS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected void registerTypeHint(ReflectionHints hints, Class<?> type) {\r\n    super.registerTypeHint(hints, type);\r\n    hints.registerType(type, MemberCategory.INVOKE_DECLARED_METHODS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
    "entityType": "class",
    "code": "private final RegisterReflectionForBindingProcessor processor = new RegisterReflectionForBindingProcessor();\nprivate final RuntimeHints hints = new RuntimeHints();\n@Test\r\nvoid registerReflectionForBindingOnClass() {\r\n    processor.registerReflectionHints(hints.reflection(), ClassLevelAnnotatedBean.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleClassWithGetter.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithGetter.class, \"getName\")).accepts(hints);\r\n}\n@Test\r\nvoid registerReflectionForBindingOnMethod() throws NoSuchMethodException {\r\n    processor.registerReflectionHints(hints.reflection(), MethodLevelAnnotatedBean.class.getMethod(\"method\"));\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleClassWithGetter.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithGetter.class, \"getName\")).accepts(hints);\r\n}\n@Test\r\nvoid registerReflectionForBindingOnClassItself() {\r\n    processor.registerReflectionHints(hints.reflection(), SampleClassWithoutAnnotationAttribute.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleClassWithoutAnnotationAttribute.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithoutAnnotationAttribute.class, \"getName\")).accepts(hints);\r\n}\n@Test\r\nvoid throwExceptionWithoutAnnotationAttributeOnMethod() {\r\n    assertThatThrownBy(() -> processor.registerReflectionHints(hints.reflection(), SampleClassWithoutMethodLevelAnnotationAttribute.class.getMethod(\"method\"))).isInstanceOf(IllegalStateException.class);\r\n}\n@RegisterReflectionForBinding(SampleClassWithGetter.class)\r\nstatic class ClassLevelAnnotatedBean {\r\n}\nstatic class MethodLevelAnnotatedBean {\r\n\r\n    @RegisterReflectionForBinding(SampleClassWithGetter.class)\r\n    public void method() {\r\n    }\r\n}\nstatic class SampleClassWithGetter {\r\n\r\n    public String getName() {\r\n        return \"test\";\r\n    }\r\n}\n@RegisterReflectionForBinding\r\nstatic class SampleClassWithoutAnnotationAttribute {\r\n\r\n    public String getName() {\r\n        return \"test\";\r\n    }\r\n}\nstatic class SampleClassWithoutMethodLevelAnnotationAttribute {\r\n\r\n    @RegisterReflectionForBinding\r\n    public void method() {\r\n    }\r\n}",
    "comment": "\n * Tests for {@link RegisterReflectionForBindingProcessor}.\n *\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionForBindingOnClass() {\r\n    processor.registerReflectionHints(hints.reflection(), ClassLevelAnnotatedBean.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleClassWithGetter.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithGetter.class, \"getName\")).accepts(hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionForBindingOnMethod() throws NoSuchMethodException {\r\n    processor.registerReflectionHints(hints.reflection(), MethodLevelAnnotatedBean.class.getMethod(\"method\"));\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleClassWithGetter.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithGetter.class, \"getName\")).accepts(hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionForBindingOnClassItself() {\r\n    processor.registerReflectionHints(hints.reflection(), SampleClassWithoutAnnotationAttribute.class);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(SampleClassWithoutAnnotationAttribute.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class)).accepts(hints);\r\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithoutAnnotationAttribute.class, \"getName\")).accepts(hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#throwExceptionWithoutAnnotationAttributeOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid throwExceptionWithoutAnnotationAttributeOnMethod() {\r\n    assertThatThrownBy(() -> processor.registerReflectionHints(hints.reflection(), SampleClassWithoutMethodLevelAnnotationAttribute.class.getMethod(\"method\"))).isInstanceOf(IllegalStateException.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.MethodLevelAnnotatedBean",
    "entityType": "class",
    "code": "@RegisterReflectionForBinding(SampleClassWithGetter.class)\r\npublic void method() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.MethodLevelAnnotatedBean#method()",
    "entityType": "method",
    "code": "@RegisterReflectionForBinding(SampleClassWithGetter.class)\r\npublic void method() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleClassWithGetter",
    "entityType": "class",
    "code": "public String getName() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleClassWithGetter#getName()",
    "entityType": "method",
    "code": "public String getName() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleClassWithoutAnnotationAttribute",
    "entityType": "class",
    "code": "public String getName() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleClassWithoutAnnotationAttribute#getName()",
    "entityType": "method",
    "code": "public String getName() {\r\n    return \"test\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute",
    "entityType": "class",
    "code": "@RegisterReflectionForBinding\r\npublic void method() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute#method()",
    "entityType": "method",
    "code": "@RegisterReflectionForBinding\r\npublic void method() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
    "entityType": "class",
    "code": "private static final List<String> NO_METHODS = Collections.emptyList();\nprivate final RegisterReflectionReflectiveProcessor processor = new RegisterReflectionReflectiveProcessor();\nprivate final RuntimeHints hints = new RuntimeHints();\n@Nested\r\nclass AnnotatedTypeTests {\r\n\r\n    @Test\r\n    void registerReflectionWithMemberCategory() {\r\n        registerReflectionHints(RegistrationSimple.class);\r\n        assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_PUBLIC_METHODS));\r\n    }\r\n\r\n    @Test\r\n    void registerReflectionForMultipleTargets() {\r\n        registerReflectionHints(RegistrationMultipleTargets.class);\r\n        assertThat(hints.reflection().typeHints()).allSatisfy(hasOnlyMemberCategories(MemberCategory.INVOKE_PUBLIC_METHODS));\r\n        assertThat(hints.reflection().typeHints().map(TypeHint::getType)).hasSameElementsAs(TypeReference.listOf(Number.class, Double.class, Integer.class, Float.class));\r\n    }\r\n\r\n    @Test\r\n    void registerReflectionOnTargetClass() {\r\n        registerReflectionHints(AnnotatedSimplePojo.class);\r\n        assertBasicTypeHint(AnnotatedSimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));\r\n    }\r\n}\n@Nested\r\nclass AnnotatedMethodTests {\r\n\r\n    @Test\r\n    void registerReflectionForStaticField() throws NoSuchMethodException {\r\n        Method method = RegistrationMethod.class.getDeclaredMethod(\"doReflection\");\r\n        registerReflectionHints(method);\r\n        assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_METHODS));\r\n    }\r\n\r\n    @Test\r\n    void registerReflectionWithoutTarget() throws NoSuchMethodException {\r\n        Method method = RegistrationMethodWithoutTarget.class.getDeclaredMethod(\"doReflection\");\r\n        assertThatIllegalStateException().isThrownBy(() -> registerReflectionHints(method)).withMessageContaining(\"At least one class must be specified\").withMessageContaining(method.toString());\r\n    }\r\n}\nprivate void assertBasicTypeHint(Class<?> type, List<String> methodNames, List<MemberCategory> memberCategories) {\r\n    TypeHint typeHint = getTypeHint(type);\r\n    assertThat(typeHint.methods()).map(ExecutableHint::getName).hasSameElementsAs(methodNames);\r\n    assertThat(typeHint.getMemberCategories()).hasSameElementsAs(memberCategories);\r\n    assertThat(typeHint.fields()).isEmpty();\r\n    assertThat(typeHint.constructors()).isEmpty();\r\n}\nprivate Consumer<TypeHint> hasOnlyMemberCategories(MemberCategory... categories) {\r\n    return typeHint -> {\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.getMemberCategories()).containsOnly(categories);\r\n    };\r\n}\nprivate TypeHint getTypeHint(Class<?> target) {\r\n    TypeHint typeHint = hints.reflection().getTypeHint(target);\r\n    assertThat(typeHint).isNotNull();\r\n    return typeHint;\r\n}\nprivate void registerReflectionHints(AnnotatedElement annotatedElement) {\r\n    this.processor.registerReflectionHints(this.hints.reflection(), annotatedElement);\r\n}\n@RegisterReflection(classes = SimplePojo.class, memberCategories = MemberCategory.INVOKE_PUBLIC_METHODS)\r\nstatic class RegistrationSimple {\r\n}\n@RegisterReflection(classes = { Number.class, Double.class }, classNames = { \"java.lang.Integer\", \"java.lang.Float\" }, memberCategories = MemberCategory.INVOKE_PUBLIC_METHODS)\r\nstatic class RegistrationMultipleTargets {\r\n}\nstatic class RegistrationMethod {\r\n\r\n    @RegisterReflection(classes = SimplePojo.class, memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)\r\n    private void doReflection() {\r\n    }\r\n}\nstatic class RegistrationMethodWithoutTarget {\r\n\r\n    @RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\r\n    private void doReflection() {\r\n    }\r\n}\nstatic class SimplePojo {\r\n\r\n    private String name;\r\n\r\n    private String description;\r\n\r\n    public String getName() {\r\n        return this.name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return this.description;\r\n    }\r\n\r\n    public void setDescription(String description) {\r\n        this.description = description;\r\n    }\r\n}\n@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)\r\nstatic class AnnotatedSimplePojo {\r\n\r\n    AnnotatedSimplePojo(String test) {\r\n    }\r\n}",
    "comment": "\n * Tests for {@link RegisterReflectionReflectiveProcessor}.\n *\n * @author Stephane Nicoll\n * @since 6.2\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#assertBasicTypeHint(Class<?>,List<String>,List<MemberCategory>)",
    "entityType": "method",
    "code": "private void assertBasicTypeHint(Class<?> type, List<String> methodNames, List<MemberCategory> memberCategories) {\r\n    TypeHint typeHint = getTypeHint(type);\r\n    assertThat(typeHint.methods()).map(ExecutableHint::getName).hasSameElementsAs(methodNames);\r\n    assertThat(typeHint.getMemberCategories()).hasSameElementsAs(memberCategories);\r\n    assertThat(typeHint.fields()).isEmpty();\r\n    assertThat(typeHint.constructors()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#hasOnlyMemberCategories(MemberCategory)",
    "entityType": "method",
    "code": "private Consumer<TypeHint> hasOnlyMemberCategories(MemberCategory... categories) {\r\n    return typeHint -> {\r\n        assertThat(typeHint.fields()).isEmpty();\r\n        assertThat(typeHint.methods()).isEmpty();\r\n        assertThat(typeHint.constructors()).isEmpty();\r\n        assertThat(typeHint.getMemberCategories()).containsOnly(categories);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#getTypeHint(Class<?>)",
    "entityType": "method",
    "code": "private TypeHint getTypeHint(Class<?> target) {\r\n    TypeHint typeHint = hints.reflection().getTypeHint(target);\r\n    assertThat(typeHint).isNotNull();\r\n    return typeHint;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#registerReflectionHints(AnnotatedElement)",
    "entityType": "method",
    "code": "private void registerReflectionHints(AnnotatedElement annotatedElement) {\r\n    this.processor.registerReflectionHints(this.hints.reflection(), annotatedElement);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedTypeTests",
    "entityType": "class",
    "code": "@Test\r\nvoid registerReflectionWithMemberCategory() {\r\n    registerReflectionHints(RegistrationSimple.class);\r\n    assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_PUBLIC_METHODS));\r\n}\n@Test\r\nvoid registerReflectionForMultipleTargets() {\r\n    registerReflectionHints(RegistrationMultipleTargets.class);\r\n    assertThat(hints.reflection().typeHints()).allSatisfy(hasOnlyMemberCategories(MemberCategory.INVOKE_PUBLIC_METHODS));\r\n    assertThat(hints.reflection().typeHints().map(TypeHint::getType)).hasSameElementsAs(TypeReference.listOf(Number.class, Double.class, Integer.class, Float.class));\r\n}\n@Test\r\nvoid registerReflectionOnTargetClass() {\r\n    registerReflectionHints(AnnotatedSimplePojo.class);\r\n    assertBasicTypeHint(AnnotatedSimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
    "entityType": "method",
    "code": "@Test\r\nvoid registerReflectionWithMemberCategory() {\r\n    registerReflectionHints(RegistrationSimple.class);\r\n    assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_PUBLIC_METHODS));\r\n}",
    "comment": ""
  }
]