[
  {
    "entityId": "org.springframework.core.type.StandardClassMetadataMemberClassTests",
    "entityType": "class",
    "code": "@Override\r\n@SuppressWarnings(\"deprecation\")\r\npublic ClassMetadata getClassMetadataFor(Class<?> clazz) {\r\n    return new StandardClassMetadata(clazz);\r\n}",
    "comment": "\n * @author Chris Beams\n * @since 3.1\n * @see AbstractClassMetadataMemberClassTests\n "
  },
  {
    "entityId": "org.springframework.core.type.StandardClassMetadataMemberClassTests#getClassMetadataFor(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"deprecation\")\r\npublic ClassMetadata getClassMetadataFor(Class<?> clazz) {\r\n    return new StandardClassMetadata(clazz);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference",
    "entityType": "class",
    "code": "private final String packageName;\nprivate final String simpleName;\n@Nullable\r\nprivate final TypeReference enclosingType;\nprotected AbstractTypeReference(String packageName, String simpleName, @Nullable TypeReference enclosingType) {\r\n    this.packageName = packageName;\r\n    this.simpleName = simpleName;\r\n    this.enclosingType = enclosingType;\r\n}\n@Override\r\npublic String getName() {\r\n    TypeReference enclosingType = getEnclosingType();\r\n    String simpleName = getSimpleName();\r\n    return (enclosingType != null ? (enclosingType.getName() + '$' + simpleName) : addPackageIfNecessary(simpleName));\r\n}\n@Override\r\npublic String getPackageName() {\r\n    return this.packageName;\r\n}\n@Override\r\npublic String getSimpleName() {\r\n    return this.simpleName;\r\n}\n@Override\r\n@Nullable\r\npublic TypeReference getEnclosingType() {\r\n    return this.enclosingType;\r\n}\nprotected String addPackageIfNecessary(String part) {\r\n    if (this.packageName.isEmpty() || (this.packageName.equals(\"java.lang\") && isPrimitive())) {\r\n        return part;\r\n    }\r\n    return this.packageName + '.' + part;\r\n}\nprotected abstract boolean isPrimitive();\n@Override\r\npublic int compareTo(TypeReference other) {\r\n    return this.getCanonicalName().compareToIgnoreCase(other.getCanonicalName());\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof TypeReference that && getCanonicalName().equals(that.getCanonicalName())));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hash(getCanonicalName());\r\n}\n@Override\r\npublic String toString() {\r\n    return getCanonicalName();\r\n}",
    "comment": "\n * Base {@link TypeReference} implementation that ensures consistent behaviour\n * for {@code equals()}, {@code hashCode()}, and {@code toString()} based on\n * the {@linkplain #getCanonicalName() canonical name}.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#getName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getName() {\r\n    TypeReference enclosingType = getEnclosingType();\r\n    String simpleName = getSimpleName();\r\n    return (enclosingType != null ? (enclosingType.getName() + '$' + simpleName) : addPackageIfNecessary(simpleName));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#getPackageName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPackageName() {\r\n    return this.packageName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#getSimpleName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getSimpleName() {\r\n    return this.simpleName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#getEnclosingType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic TypeReference getEnclosingType() {\r\n    return this.enclosingType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#addPackageIfNecessary(String)",
    "entityType": "method",
    "code": "protected String addPackageIfNecessary(String part) {\r\n    if (this.packageName.isEmpty() || (this.packageName.equals(\"java.lang\") && isPrimitive())) {\r\n        return part;\r\n    }\r\n    return this.packageName + '.' + part;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#isPrimitive()",
    "entityType": "method",
    "code": "protected abstract boolean isPrimitive();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#compareTo(TypeReference)",
    "entityType": "method",
    "code": "@Override\r\npublic int compareTo(TypeReference other) {\r\n    return this.getCanonicalName().compareToIgnoreCase(other.getCanonicalName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof TypeReference that && getCanonicalName().equals(that.getCanonicalName())));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(getCanonicalName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.AbstractTypeReference#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return getCanonicalName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadataTests",
    "entityType": "class",
    "code": "@Override\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    return AnnotationMetadata.introspect(source);\r\n}",
    "comment": "\n * Tests for {@link StandardMethodMetadata}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.type.StandardMethodMetadataTests#get(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected AnnotationMetadata get(Class<?> source) {\r\n    return AnnotationMetadata.introspect(source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveProcessor",
    "entityType": "class",
    "code": "/**\r\n * Register {@link ReflectionHints} against the specified {@link AnnotatedElement}.\r\n * @param hints the reflection hints instance to use\r\n * @param element the element to process\r\n */\r\nvoid registerReflectionHints(ReflectionHints hints, AnnotatedElement element);",
    "comment": "\n * Process an {@link AnnotatedElement} and register the necessary reflection\n * hints for it.\n *\n * <p>{@code ReflectiveProcessor} implementations are registered via\n * {@link Reflective#processors() @Reflective(processors = ...)}.\n *\n * @author Stephane Nicoll\n * @since 6.0\n * @see Reflective @Reflective\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveProcessor#registerReflectionHints(ReflectionHints,AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * Register {@link ReflectionHints} against the specified {@link AnnotatedElement}.\r\n * @param hints the reflection hints instance to use\r\n * @param element the element to process\r\n */\r\nvoid registerReflectionHints(ReflectionHints hints, AnnotatedElement element);",
    "comment": "\n\t * Register {@link ReflectionHints} against the specified {@link AnnotatedElement}.\n\t * @param hints the reflection hints instance to use\n\t * @param element the element to process\n\t "
  },
  {
    "entityId": "org.springframework.SpringCoreTestSuite",
    "entityType": "class",
    "code": "",
    "comment": "\n * JUnit Platform based test suite for tests in the spring-core module.\n *\n * <p><strong>This suite is only intended to be used manually within an IDE.</strong>\n *\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.tests.MockitoUtils",
    "entityType": "class",
    "code": "/**\r\n * Verify the same invocations have been applied to two mocks. This is generally not\r\n * the preferred way test with mockito and should be avoided if possible.\r\n * @param expected the mock containing expected invocations\r\n * @param actual the mock containing actual invocations\r\n * @param argumentAdapters adapters that can be used to change argument values before they are compared\r\n */\r\npublic static <T> void verifySameInvocations(T expected, T actual, InvocationArgumentsAdapter... argumentAdapters) {\r\n    List<Invocation> expectedInvocations = ((InvocationContainerImpl) MockUtil.getMockHandler(expected).getInvocationContainer()).getInvocations();\r\n    List<Invocation> actualInvocations = ((InvocationContainerImpl) MockUtil.getMockHandler(actual).getInvocationContainer()).getInvocations();\r\n    verifySameInvocations(expectedInvocations, actualInvocations, argumentAdapters);\r\n}\nprivate static void verifySameInvocations(List<Invocation> expectedInvocations, List<Invocation> actualInvocations, InvocationArgumentsAdapter... argumentAdapters) {\r\n    assertThat(expectedInvocations).hasSameSizeAs(actualInvocations);\r\n    for (int i = 0; i < expectedInvocations.size(); i++) {\r\n        verifySameInvocation(expectedInvocations.get(i), actualInvocations.get(i), argumentAdapters);\r\n    }\r\n}\nprivate static void verifySameInvocation(Invocation expectedInvocation, Invocation actualInvocation, InvocationArgumentsAdapter... argumentAdapters) {\r\n    assertThat(expectedInvocation.getMethod()).isEqualTo(actualInvocation.getMethod());\r\n    Object[] expectedArguments = getInvocationArguments(expectedInvocation, argumentAdapters);\r\n    Object[] actualArguments = getInvocationArguments(actualInvocation, argumentAdapters);\r\n    assertThat(expectedArguments).isEqualTo(actualArguments);\r\n}\nprivate static Object[] getInvocationArguments(Invocation invocation, InvocationArgumentsAdapter... argumentAdapters) {\r\n    Object[] arguments = invocation.getArguments();\r\n    for (InvocationArgumentsAdapter adapter : argumentAdapters) {\r\n        arguments = adapter.adaptArguments(arguments);\r\n    }\r\n    return arguments;\r\n}\n/**\r\n * Adapter strategy that can be used to change invocation arguments.\r\n */\r\npublic interface InvocationArgumentsAdapter {\r\n\r\n    /**\r\n     * Change the arguments if required.\r\n     * @param arguments the source arguments\r\n     * @return updated or original arguments (never {@code null})\r\n     */\r\n    Object[] adaptArguments(Object[] arguments);\r\n}",
    "comment": "\n * General test utilities for use with {@link Mockito}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.tests.MockitoUtils#verifySameInvocations(T,T,InvocationArgumentsAdapter)",
    "entityType": "method",
    "code": "/**\r\n * Verify the same invocations have been applied to two mocks. This is generally not\r\n * the preferred way test with mockito and should be avoided if possible.\r\n * @param expected the mock containing expected invocations\r\n * @param actual the mock containing actual invocations\r\n * @param argumentAdapters adapters that can be used to change argument values before they are compared\r\n */\r\npublic static <T> void verifySameInvocations(T expected, T actual, InvocationArgumentsAdapter... argumentAdapters) {\r\n    List<Invocation> expectedInvocations = ((InvocationContainerImpl) MockUtil.getMockHandler(expected).getInvocationContainer()).getInvocations();\r\n    List<Invocation> actualInvocations = ((InvocationContainerImpl) MockUtil.getMockHandler(actual).getInvocationContainer()).getInvocations();\r\n    verifySameInvocations(expectedInvocations, actualInvocations, argumentAdapters);\r\n}",
    "comment": "\n\t * Verify the same invocations have been applied to two mocks. This is generally not\n\t * the preferred way test with mockito and should be avoided if possible.\n\t * @param expected the mock containing expected invocations\n\t * @param actual the mock containing actual invocations\n\t * @param argumentAdapters adapters that can be used to change argument values before they are compared\n\t "
  },
  {
    "entityId": "org.springframework.tests.MockitoUtils#verifySameInvocations(List<Invocation>,List<Invocation>,InvocationArgumentsAdapter)",
    "entityType": "method",
    "code": "private static void verifySameInvocations(List<Invocation> expectedInvocations, List<Invocation> actualInvocations, InvocationArgumentsAdapter... argumentAdapters) {\r\n    assertThat(expectedInvocations).hasSameSizeAs(actualInvocations);\r\n    for (int i = 0; i < expectedInvocations.size(); i++) {\r\n        verifySameInvocation(expectedInvocations.get(i), actualInvocations.get(i), argumentAdapters);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.MockitoUtils#verifySameInvocation(Invocation,Invocation,InvocationArgumentsAdapter)",
    "entityType": "method",
    "code": "private static void verifySameInvocation(Invocation expectedInvocation, Invocation actualInvocation, InvocationArgumentsAdapter... argumentAdapters) {\r\n    assertThat(expectedInvocation.getMethod()).isEqualTo(actualInvocation.getMethod());\r\n    Object[] expectedArguments = getInvocationArguments(expectedInvocation, argumentAdapters);\r\n    Object[] actualArguments = getInvocationArguments(actualInvocation, argumentAdapters);\r\n    assertThat(expectedArguments).isEqualTo(actualArguments);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.MockitoUtils#getInvocationArguments(Invocation,InvocationArgumentsAdapter)",
    "entityType": "method",
    "code": "private static Object[] getInvocationArguments(Invocation invocation, InvocationArgumentsAdapter... argumentAdapters) {\r\n    Object[] arguments = invocation.getArguments();\r\n    for (InvocationArgumentsAdapter adapter : argumentAdapters) {\r\n        arguments = adapter.adaptArguments(arguments);\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.InvocationArgumentsAdapter",
    "entityType": "class",
    "code": "/**\r\n * Change the arguments if required.\r\n * @param arguments the source arguments\r\n * @return updated or original arguments (never {@code null})\r\n */\r\nObject[] adaptArguments(Object[] arguments);",
    "comment": "\n\t * Adapter strategy that can be used to change invocation arguments.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar",
    "entityType": "class",
    "code": "private final Map<Class<? extends ReflectiveProcessor>, ReflectiveProcessor> processors = new HashMap<>();\n/**\r\n * Register the relevant runtime hints for elements that are annotated with\r\n * {@link Reflective}.\r\n * @param runtimeHints the runtime hints instance to use\r\n * @param types the types to process\r\n */\r\npublic void registerRuntimeHints(RuntimeHints runtimeHints, Class<?>... types) {\r\n    Set<Entry> entries = new HashSet<>();\r\n    for (Class<?> type : types) {\r\n        processType(entries, type);\r\n        for (Class<?> implementedInterface : ClassUtils.getAllInterfacesForClass(type)) {\r\n            processType(entries, implementedInterface);\r\n        }\r\n    }\r\n    entries.forEach(entry -> {\r\n        AnnotatedElement element = entry.element();\r\n        entry.processor().registerReflectionHints(runtimeHints.reflection(), element);\r\n    });\r\n}\n/**\r\n * Specify if the given {@code type} is a valid candidate.\r\n * @param type the type to inspect\r\n * @return {@code true} if the type uses {@link Reflective} in a way that\r\n * is supported by this registrar\r\n * @since 6.2\r\n */\r\npublic boolean isCandidate(Class<?> type) {\r\n    if (isReflective(type)) {\r\n        return true;\r\n    }\r\n    AtomicBoolean candidate = new AtomicBoolean(false);\r\n    doWithReflectiveConstructors(type, constructor -> candidate.set(true));\r\n    if (!candidate.get()) {\r\n        ReflectionUtils.doWithFields(type, field -> candidate.set(true), this::isReflective);\r\n    }\r\n    if (!candidate.get()) {\r\n        ReflectionUtils.doWithMethods(type, method -> candidate.set(true), this::isReflective);\r\n    }\r\n    return candidate.get();\r\n}\nprivate void processType(Set<Entry> entries, Class<?> typeToProcess) {\r\n    if (isReflective(typeToProcess)) {\r\n        entries.add(createEntry(typeToProcess));\r\n    }\r\n    doWithReflectiveConstructors(typeToProcess, constructor -> entries.add(createEntry(constructor)));\r\n    ReflectionUtils.doWithFields(typeToProcess, field -> entries.add(createEntry(field)), this::isReflective);\r\n    ReflectionUtils.doWithMethods(typeToProcess, method -> entries.add(createEntry(method)), this::isReflective);\r\n}\nprivate void doWithReflectiveConstructors(Class<?> typeToProcess, Consumer<Constructor<?>> consumer) {\r\n    for (Constructor<?> constructor : typeToProcess.getDeclaredConstructors()) {\r\n        if (isReflective(constructor)) {\r\n            consumer.accept(constructor);\r\n        }\r\n    }\r\n}\nprivate boolean isReflective(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, TYPE_HIERARCHY).isPresent(Reflective.class);\r\n}\n@SuppressWarnings(\"unchecked\")\r\nprivate Entry createEntry(AnnotatedElement element) {\r\n    List<ReflectiveProcessor> processors = MergedAnnotations.from(element, TYPE_HIERARCHY).stream(Reflective.class).map(annotation -> annotation.getClassArray(\"value\")).flatMap(Arrays::stream).distinct().map(type -> (Class<? extends ReflectiveProcessor>) type).map(processorClass -> this.processors.computeIfAbsent(processorClass, this::instantiateClass)).toList();\r\n    ReflectiveProcessor processorToUse = (processors.size() == 1 ? processors.get(0) : new DelegatingReflectiveProcessor(processors));\r\n    return new Entry(element, processorToUse);\r\n}\nprivate ReflectiveProcessor instantiateClass(Class<? extends ReflectiveProcessor> type) {\r\n    try {\r\n        Constructor<? extends ReflectiveProcessor> constructor = type.getDeclaredConstructor();\r\n        ReflectionUtils.makeAccessible(constructor);\r\n        return constructor.newInstance();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Failed to instantiate \" + type, ex);\r\n    }\r\n}\nprivate static class DelegatingReflectiveProcessor implements ReflectiveProcessor {\r\n\r\n    private final Iterable<ReflectiveProcessor> processors;\r\n\r\n    DelegatingReflectiveProcessor(Iterable<ReflectiveProcessor> processors) {\r\n        this.processors = processors;\r\n    }\r\n\r\n    @Override\r\n    public void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n        this.processors.forEach(processor -> processor.registerReflectionHints(hints, element));\r\n    }\r\n}\nprivate record Entry(AnnotatedElement element, ReflectiveProcessor processor) {\r\n}",
    "comment": "\n * Process {@link Reflective @Reflective} annotated elements.\n *\n * @author Stephane Nicoll\n * @author Andy Wilkinson\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.tests.InvocationArgumentsAdapter#adaptArguments(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Change the arguments if required.\r\n * @param arguments the source arguments\r\n * @return updated or original arguments (never {@code null})\r\n */\r\nObject[] adaptArguments(Object[] arguments);",
    "comment": "\n\t\t * Change the arguments if required.\n\t\t * @param arguments the source arguments\n\t\t * @return updated or original arguments (never {@code null})\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#registerRuntimeHints(RuntimeHints,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Register the relevant runtime hints for elements that are annotated with\r\n * {@link Reflective}.\r\n * @param runtimeHints the runtime hints instance to use\r\n * @param types the types to process\r\n */\r\npublic void registerRuntimeHints(RuntimeHints runtimeHints, Class<?>... types) {\r\n    Set<Entry> entries = new HashSet<>();\r\n    for (Class<?> type : types) {\r\n        processType(entries, type);\r\n        for (Class<?> implementedInterface : ClassUtils.getAllInterfacesForClass(type)) {\r\n            processType(entries, implementedInterface);\r\n        }\r\n    }\r\n    entries.forEach(entry -> {\r\n        AnnotatedElement element = entry.element();\r\n        entry.processor().registerReflectionHints(runtimeHints.reflection(), element);\r\n    });\r\n}",
    "comment": "\n\t * Register the relevant runtime hints for elements that are annotated with\n\t * {@link Reflective}.\n\t * @param runtimeHints the runtime hints instance to use\n\t * @param types the types to process\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#isCandidate(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Specify if the given {@code type} is a valid candidate.\r\n * @param type the type to inspect\r\n * @return {@code true} if the type uses {@link Reflective} in a way that\r\n * is supported by this registrar\r\n * @since 6.2\r\n */\r\npublic boolean isCandidate(Class<?> type) {\r\n    if (isReflective(type)) {\r\n        return true;\r\n    }\r\n    AtomicBoolean candidate = new AtomicBoolean(false);\r\n    doWithReflectiveConstructors(type, constructor -> candidate.set(true));\r\n    if (!candidate.get()) {\r\n        ReflectionUtils.doWithFields(type, field -> candidate.set(true), this::isReflective);\r\n    }\r\n    if (!candidate.get()) {\r\n        ReflectionUtils.doWithMethods(type, method -> candidate.set(true), this::isReflective);\r\n    }\r\n    return candidate.get();\r\n}",
    "comment": "\n\t * Specify if the given {@code type} is a valid candidate.\n\t * @param type the type to inspect\n\t * @return {@code true} if the type uses {@link Reflective} in a way that\n\t * is supported by this registrar\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#processType(Set<Entry>,Class<?>)",
    "entityType": "method",
    "code": "private void processType(Set<Entry> entries, Class<?> typeToProcess) {\r\n    if (isReflective(typeToProcess)) {\r\n        entries.add(createEntry(typeToProcess));\r\n    }\r\n    doWithReflectiveConstructors(typeToProcess, constructor -> entries.add(createEntry(constructor)));\r\n    ReflectionUtils.doWithFields(typeToProcess, field -> entries.add(createEntry(field)), this::isReflective);\r\n    ReflectionUtils.doWithMethods(typeToProcess, method -> entries.add(createEntry(method)), this::isReflective);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#doWithReflectiveConstructors(Class<?>,Consumer<Constructor<?>>)",
    "entityType": "method",
    "code": "private void doWithReflectiveConstructors(Class<?> typeToProcess, Consumer<Constructor<?>> consumer) {\r\n    for (Constructor<?> constructor : typeToProcess.getDeclaredConstructors()) {\r\n        if (isReflective(constructor)) {\r\n            consumer.accept(constructor);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#isReflective(AnnotatedElement)",
    "entityType": "method",
    "code": "private boolean isReflective(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, TYPE_HIERARCHY).isPresent(Reflective.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#createEntry(AnnotatedElement)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nprivate Entry createEntry(AnnotatedElement element) {\r\n    List<ReflectiveProcessor> processors = MergedAnnotations.from(element, TYPE_HIERARCHY).stream(Reflective.class).map(annotation -> annotation.getClassArray(\"value\")).flatMap(Arrays::stream).distinct().map(type -> (Class<? extends ReflectiveProcessor>) type).map(processorClass -> this.processors.computeIfAbsent(processorClass, this::instantiateClass)).toList();\r\n    ReflectiveProcessor processorToUse = (processors.size() == 1 ? processors.get(0) : new DelegatingReflectiveProcessor(processors));\r\n    return new Entry(element, processorToUse);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar#instantiateClass(Class<? extends ReflectiveProcessor>)",
    "entityType": "method",
    "code": "private ReflectiveProcessor instantiateClass(Class<? extends ReflectiveProcessor> type) {\r\n    try {\r\n        Constructor<? extends ReflectiveProcessor> constructor = type.getDeclaredConstructor();\r\n        ReflectionUtils.makeAccessible(constructor);\r\n        return constructor.newInstance();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Failed to instantiate \" + type, ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.DelegatingReflectiveProcessor",
    "entityType": "class",
    "code": "private final Iterable<ReflectiveProcessor> processors;\nDelegatingReflectiveProcessor(Iterable<ReflectiveProcessor> processors) {\r\n    this.processors = processors;\r\n}\n@Override\r\npublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n    this.processors.forEach(processor -> processor.registerReflectionHints(hints, element));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.DelegatingReflectiveProcessor#registerReflectionHints(ReflectionHints,AnnotatedElement)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n    this.processors.forEach(processor -> processor.registerReflectionHints(hints, element));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.DerivedTestObject",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.GenericObject",
    "entityType": "class",
    "code": "private List<Resource> resourceList;\npublic List<Resource> getResourceList() {\r\n    return this.resourceList;\r\n}\npublic void setResourceList(List<Resource> resourceList) {\r\n    this.resourceList = resourceList;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.GenericObject#getResourceList()",
    "entityType": "method",
    "code": "public List<Resource> getResourceList() {\r\n    return this.resourceList;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.GenericObject#setResourceList(List<Resource>)",
    "entityType": "method",
    "code": "public void setResourceList(List<Resource> resourceList) {\r\n    this.resourceList = resourceList;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessor",
    "entityType": "class",
    "code": "private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();\n@Override\r\nprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\r\n    this.bindingRegistrar.registerReflectionHints(hints, target);\r\n}",
    "comment": "\n * A {@link ReflectiveProcessor} implementation that registers reflection hints\n * for data binding purpose, that is class, constructors, fields, properties,\n * record components, including types transitively used on properties and record\n * components.\n *\n * @author Sebastien Deleuze\n * @author Stephane Nicoll\n * @since 6.0\n * @see RegisterReflectionForBinding @RegisterReflectionForBinding\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessor#registerReflectionHints(ReflectionHints,Class<?>,MemberCategory[])",
    "entityType": "method",
    "code": "@Override\r\nprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\r\n    this.bindingRegistrar.registerReflectionHints(hints, target);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestInterface",
    "entityType": "class",
    "code": "void absquatulate();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestInterface#absquatulate()",
    "entityType": "method",
    "code": "void absquatulate();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject",
    "entityType": "class",
    "code": "String getName();\nvoid setName(String name);\nint getAge();\nvoid setAge(int age);\nTestObject getSpouse();\nvoid setSpouse(TestObject spouse);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject#getName()",
    "entityType": "method",
    "code": "String getName();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject#setName(String)",
    "entityType": "method",
    "code": "void setName(String name);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject#getAge()",
    "entityType": "method",
    "code": "int getAge();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject#setAge(int)",
    "entityType": "method",
    "code": "void setAge(int age);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject#getSpouse()",
    "entityType": "method",
    "code": "TestObject getSpouse();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.ITestObject#setSpouse(TestObject)",
    "entityType": "method",
    "code": "void setSpouse(TestObject spouse);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor",
    "entityType": "class",
    "code": "private static final Log logger = LogFactory.getLog(RegisterReflectionReflectiveProcessor.class);\n@Override\r\npublic final void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n    RegisterReflection annotation = AnnotatedElementUtils.getMergedAnnotation(element, RegisterReflection.class);\r\n    Assert.notNull(annotation, () -> \"Element must be annotated with @RegisterReflection: \" + element);\r\n    ReflectionRegistration registration = parse(element, annotation);\r\n    registerReflectionHints(hints, registration);\r\n}\nprotected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\r\n    List<Class<?>> allClassNames = new ArrayList<>();\r\n    allClassNames.addAll(Arrays.asList(annotation.classes()));\r\n    allClassNames.addAll(Arrays.stream(annotation.classNames()).map(this::loadClass).filter(Objects::nonNull).toList());\r\n    if (allClassNames.isEmpty()) {\r\n        if (element instanceof Class<?> clazz) {\r\n            allClassNames.add(clazz);\r\n        } else {\r\n            throw new IllegalStateException(\"At least one class must be specified: \" + element);\r\n        }\r\n    }\r\n    return new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]), annotation.memberCategories());\r\n}\nprotected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\r\n    for (Class<?> target : registration.classes) {\r\n        registerReflectionHints(hints, target, registration.memberCategories);\r\n    }\r\n}\nprotected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\r\n    hints.registerType(target, type -> type.withMembers(memberCategories));\r\n}\n@Nullable\r\nprivate Class<?> loadClass(String className) {\r\n    try {\r\n        return ClassUtils.forName(className, getClass().getClassLoader());\r\n    } catch (Exception ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Ignoring '\" + className + \"': \" + ex);\r\n        }\r\n        return null;\r\n    }\r\n}\nprotected record ReflectionRegistration(Class<?>[] classes, MemberCategory[] memberCategories) {\r\n}",
    "comment": "\n * A {@link ReflectiveProcessor} implementation that pairs with\n * {@link RegisterReflection @RegisterReflection}. Can be used as a base\n * implementation for composed annotations that are meta-annotated with\n * {@link RegisterReflection}.\n *\n * @author Stephane Nicoll\n * @since 6.2\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(ReflectionHints,AnnotatedElement)",
    "entityType": "method",
    "code": "@Override\r\npublic final void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n    RegisterReflection annotation = AnnotatedElementUtils.getMergedAnnotation(element, RegisterReflection.class);\r\n    Assert.notNull(annotation, () -> \"Element must be annotated with @RegisterReflection: \" + element);\r\n    ReflectionRegistration registration = parse(element, annotation);\r\n    registerReflectionHints(hints, registration);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#parse(AnnotatedElement,RegisterReflection)",
    "entityType": "method",
    "code": "protected ReflectionRegistration parse(AnnotatedElement element, RegisterReflection annotation) {\r\n    List<Class<?>> allClassNames = new ArrayList<>();\r\n    allClassNames.addAll(Arrays.asList(annotation.classes()));\r\n    allClassNames.addAll(Arrays.stream(annotation.classNames()).map(this::loadClass).filter(Objects::nonNull).toList());\r\n    if (allClassNames.isEmpty()) {\r\n        if (element instanceof Class<?> clazz) {\r\n            allClassNames.add(clazz);\r\n        } else {\r\n            throw new IllegalStateException(\"At least one class must be specified: \" + element);\r\n        }\r\n    }\r\n    return new ReflectionRegistration(allClassNames.toArray(new Class<?>[0]), annotation.memberCategories());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(ReflectionHints,ReflectionRegistration)",
    "entityType": "method",
    "code": "protected void registerReflectionHints(ReflectionHints hints, ReflectionRegistration registration) {\r\n    for (Class<?> target : registration.classes) {\r\n        registerReflectionHints(hints, target, registration.memberCategories);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#registerReflectionHints(ReflectionHints,Class<?>,MemberCategory[])",
    "entityType": "method",
    "code": "protected void registerReflectionHints(ReflectionHints hints, Class<?> target, MemberCategory[] memberCategories) {\r\n    hints.registerType(target, type -> type.withMembers(memberCategories));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessor#loadClass(String)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Class<?> loadClass(String className) {\r\n    try {\r\n        return ClassUtils.forName(className, getClass().getClassLoader());\r\n    } catch (Exception ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Ignoring '\" + className + \"': \" + ex);\r\n        }\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor",
    "entityType": "class",
    "code": "@Override\r\npublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n    if (element instanceof Class<?> type) {\r\n        registerTypeHint(hints, type);\r\n    } else if (element instanceof Constructor<?> constructor) {\r\n        registerConstructorHint(hints, constructor);\r\n    } else if (element instanceof Field field) {\r\n        registerFieldHint(hints, field);\r\n    } else if (element instanceof Method method) {\r\n        registerMethodHint(hints, method);\r\n    }\r\n}\n/**\r\n * Register {@link ReflectionHints} against the specified {@link Class}.\r\n * @param hints the reflection hints instance to use\r\n * @param type the class to process\r\n */\r\nprotected void registerTypeHint(ReflectionHints hints, Class<?> type) {\r\n    hints.registerType(type);\r\n}\n/**\r\n * Register {@link ReflectionHints} against the specified {@link Constructor}.\r\n * @param hints the reflection hints instance to use\r\n * @param constructor the constructor to process\r\n */\r\nprotected void registerConstructorHint(ReflectionHints hints, Constructor<?> constructor) {\r\n    hints.registerConstructor(constructor, ExecutableMode.INVOKE);\r\n}\n/**\r\n * Register {@link ReflectionHints} against the specified {@link Field}.\r\n * @param hints the reflection hints instance to use\r\n * @param field the field to process\r\n */\r\nprotected void registerFieldHint(ReflectionHints hints, Field field) {\r\n    hints.registerField(field);\r\n}\n/**\r\n * Register {@link ReflectionHints} against the specified {@link Method}.\r\n * @param hints the reflection hints instance to use\r\n * @param method the method to process\r\n */\r\nprotected void registerMethodHint(ReflectionHints hints, Method method) {\r\n    hints.registerMethod(method, ExecutableMode.INVOKE);\r\n}",
    "comment": "\n * A simple {@link ReflectiveProcessor} implementation that registers only a\n * reflection hint for the annotated type. Can be sub-classed to customize\n * processing for a given {@link AnnotatedElement} type.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor#registerReflectionHints(ReflectionHints,AnnotatedElement)",
    "entityType": "method",
    "code": "@Override\r\npublic void registerReflectionHints(ReflectionHints hints, AnnotatedElement element) {\r\n    if (element instanceof Class<?> type) {\r\n        registerTypeHint(hints, type);\r\n    } else if (element instanceof Constructor<?> constructor) {\r\n        registerConstructorHint(hints, constructor);\r\n    } else if (element instanceof Field field) {\r\n        registerFieldHint(hints, field);\r\n    } else if (element instanceof Method method) {\r\n        registerMethodHint(hints, method);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Register {@link ReflectionHints} against the specified {@link Class}.\r\n * @param hints the reflection hints instance to use\r\n * @param type the class to process\r\n */\r\nprotected void registerTypeHint(ReflectionHints hints, Class<?> type) {\r\n    hints.registerType(type);\r\n}",
    "comment": "\n\t * Register {@link ReflectionHints} against the specified {@link Class}.\n\t * @param hints the reflection hints instance to use\n\t * @param type the class to process\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor#registerConstructorHint(ReflectionHints,Constructor<?>)",
    "entityType": "method",
    "code": "/**\r\n * Register {@link ReflectionHints} against the specified {@link Constructor}.\r\n * @param hints the reflection hints instance to use\r\n * @param constructor the constructor to process\r\n */\r\nprotected void registerConstructorHint(ReflectionHints hints, Constructor<?> constructor) {\r\n    hints.registerConstructor(constructor, ExecutableMode.INVOKE);\r\n}",
    "comment": "\n\t * Register {@link ReflectionHints} against the specified {@link Constructor}.\n\t * @param hints the reflection hints instance to use\n\t * @param constructor the constructor to process\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor#registerFieldHint(ReflectionHints,Field)",
    "entityType": "method",
    "code": "/**\r\n * Register {@link ReflectionHints} against the specified {@link Field}.\r\n * @param hints the reflection hints instance to use\r\n * @param field the field to process\r\n */\r\nprotected void registerFieldHint(ReflectionHints hints, Field field) {\r\n    hints.registerField(field);\r\n}",
    "comment": "\n\t * Register {@link ReflectionHints} against the specified {@link Field}.\n\t * @param hints the reflection hints instance to use\n\t * @param field the field to process\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.annotation.SimpleReflectiveProcessor#registerMethodHint(ReflectionHints,Method)",
    "entityType": "method",
    "code": "/**\r\n * Register {@link ReflectionHints} against the specified {@link Method}.\r\n * @param hints the reflection hints instance to use\r\n * @param method the method to process\r\n */\r\nprotected void registerMethodHint(ReflectionHints hints, Method method) {\r\n    hints.registerMethod(method, ExecutableMode.INVOKE);\r\n}",
    "comment": "\n\t * Register {@link ReflectionHints} against the specified {@link Method}.\n\t * @param hints the reflection hints instance to use\n\t * @param method the method to process\n\t "
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject",
    "entityType": "class",
    "code": "private String name;\nprivate int age;\nprivate TestObject spouse;\npublic TestObject() {\r\n}\npublic TestObject(String name, int age) {\r\n    this.name = name;\r\n    this.age = age;\r\n}\n@Override\r\npublic String getName() {\r\n    return name;\r\n}\n@Override\r\npublic void setName(String name) {\r\n    this.name = name;\r\n}\n@Override\r\npublic int getAge() {\r\n    return this.age;\r\n}\n@Override\r\npublic void setAge(int age) {\r\n    this.age = age;\r\n}\n@Override\r\npublic TestObject getSpouse() {\r\n    return this.spouse;\r\n}\n@Override\r\npublic void setSpouse(TestObject spouse) {\r\n    this.spouse = spouse;\r\n}\n@Override\r\npublic void absquatulate() ;\n@Override\r\npublic int compareTo(Object o) {\r\n    if (this.name != null && o instanceof TestObject) {\r\n        return this.name.compareTo(((TestObject) o).getName());\r\n    } else {\r\n        return 1;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#getName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getName() {\r\n    return name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#setName(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void setName(String name) {\r\n    this.name = name;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#getAge()",
    "entityType": "method",
    "code": "@Override\r\npublic int getAge() {\r\n    return this.age;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#setAge(int)",
    "entityType": "method",
    "code": "@Override\r\npublic void setAge(int age) {\r\n    this.age = age;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#getSpouse()",
    "entityType": "method",
    "code": "@Override\r\npublic TestObject getSpouse() {\r\n    return this.spouse;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#setSpouse(TestObject)",
    "entityType": "method",
    "code": "@Override\r\npublic void setSpouse(TestObject spouse) {\r\n    this.spouse = spouse;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#absquatulate()",
    "entityType": "method",
    "code": "@Override\r\npublic void absquatulate() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.tests.sample.objects.TestObject#compareTo(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic int compareTo(Object o) {\r\n    if (this.name != null && o instanceof TestObject) {\r\n        return this.name.compareTo(((TestObject) o).getName());\r\n    } else {\r\n        return 1;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar",
    "entityType": "class",
    "code": "private static final String KOTLIN_COMPANION_SUFFIX = \"$Companion\";\nprivate static final String JACKSON_ANNOTATION = \"com.fasterxml.jackson.annotation.JacksonAnnotation\";\nprivate static final boolean jacksonAnnotationPresent = ClassUtils.isPresent(JACKSON_ANNOTATION, BindingReflectionHintsRegistrar.class.getClassLoader());\n/**\r\n * Register the necessary reflection hints to bind the specified types.\r\n * @param hints the hints instance to use\r\n * @param types the types to register\r\n */\r\npublic void registerReflectionHints(ReflectionHints hints, Type... types) {\r\n    Set<Type> seen = new HashSet<>();\r\n    for (Type type : types) {\r\n        registerReflectionHints(hints, seen, type);\r\n    }\r\n}\nprivate boolean shouldSkipType(Class<?> type) {\r\n    return type.isPrimitive() || type == Object.class;\r\n}\nprivate boolean shouldSkipMembers(Class<?> type) {\r\n    return type.getCanonicalName().startsWith(\"java.\") || type.isArray();\r\n}\nprivate void registerReflectionHints(ReflectionHints hints, Set<Type> seen, Type type) {\r\n    if (seen.contains(type)) {\r\n        return;\r\n    }\r\n    seen.add(type);\r\n    if (type instanceof Class<?> clazz) {\r\n        if (shouldSkipType(clazz)) {\r\n            return;\r\n        }\r\n        hints.registerType(clazz, typeHint -> {\r\n            if (!shouldSkipMembers(clazz)) {\r\n                if (clazz.isRecord()) {\r\n                    typeHint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n                    for (RecordComponent recordComponent : clazz.getRecordComponents()) {\r\n                        registerRecordHints(hints, seen, recordComponent.getAccessor());\r\n                    }\r\n                }\r\n                if (clazz.isEnum()) {\r\n                    typeHint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS);\r\n                }\r\n                typeHint.withMembers(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n                for (Method method : clazz.getMethods()) {\r\n                    String methodName = method.getName();\r\n                    if (methodName.startsWith(\"set\") && method.getParameterCount() == 1) {\r\n                        registerPropertyHints(hints, seen, method, 0);\r\n                    } else if ((methodName.startsWith(\"get\") && method.getParameterCount() == 0 && method.getReturnType() != void.class) || (methodName.startsWith(\"is\") && method.getParameterCount() == 0 && ClassUtils.resolvePrimitiveIfNecessary(method.getReturnType()) == Boolean.class)) {\r\n                        registerPropertyHints(hints, seen, method, -1);\r\n                    }\r\n                }\r\n                if (jacksonAnnotationPresent) {\r\n                    registerJacksonHints(hints, clazz);\r\n                }\r\n            }\r\n            if (KotlinDetector.isKotlinType(clazz)) {\r\n                KotlinDelegate.registerComponentHints(hints, clazz);\r\n                registerKotlinSerializationHints(hints, clazz);\r\n            }\r\n        });\r\n    }\r\n    Set<Class<?>> referencedTypes = new LinkedHashSet<>();\r\n    collectReferencedTypes(referencedTypes, ResolvableType.forType(type));\r\n    referencedTypes.forEach(referencedType -> registerReflectionHints(hints, seen, referencedType));\r\n}\nprivate void registerRecordHints(ReflectionHints hints, Set<Type> seen, Method method) {\r\n    hints.registerMethod(method, ExecutableMode.INVOKE);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\r\n    Type methodParameterType = methodParameter.getGenericParameterType();\r\n    registerReflectionHints(hints, seen, methodParameterType);\r\n}\nprivate void registerPropertyHints(ReflectionHints hints, Set<Type> seen, @Nullable Method method, int parameterIndex) {\r\n    if (method != null && method.getDeclaringClass() != Object.class && method.getDeclaringClass() != Enum.class) {\r\n        hints.registerMethod(method, ExecutableMode.INVOKE);\r\n        MethodParameter methodParameter = MethodParameter.forExecutable(method, parameterIndex);\r\n        Type methodParameterType = methodParameter.getGenericParameterType();\r\n        registerReflectionHints(hints, seen, methodParameterType);\r\n    }\r\n}\nprivate void registerKotlinSerializationHints(ReflectionHints hints, Class<?> clazz) {\r\n    String companionClassName = clazz.getCanonicalName() + KOTLIN_COMPANION_SUFFIX;\r\n    if (ClassUtils.isPresent(companionClassName, null)) {\r\n        Class<?> companionClass = ClassUtils.resolveClassName(companionClassName, null);\r\n        Method serializerMethod = ClassUtils.getMethodIfAvailable(companionClass, \"serializer\");\r\n        if (serializerMethod != null) {\r\n            hints.registerMethod(serializerMethod, ExecutableMode.INVOKE);\r\n        }\r\n    }\r\n}\nprivate void collectReferencedTypes(Set<Class<?>> types, ResolvableType resolvableType) {\r\n    Class<?> clazz = resolvableType.resolve();\r\n    if (clazz != null && !types.contains(clazz)) {\r\n        types.add(clazz);\r\n        for (ResolvableType genericResolvableType : resolvableType.getGenerics()) {\r\n            collectReferencedTypes(types, genericResolvableType);\r\n        }\r\n        Class<?> superClass = clazz.getSuperclass();\r\n        if (superClass != null && superClass != Object.class && superClass != Record.class && superClass != Enum.class) {\r\n            types.add(superClass);\r\n        }\r\n    }\r\n}\nprivate void registerJacksonHints(ReflectionHints hints, Class<?> clazz) {\r\n    ReflectionUtils.doWithFields(clazz, field -> forEachJacksonAnnotation(field, annotation -> {\r\n        Field sourceField = (Field) annotation.getSource();\r\n        if (sourceField != null) {\r\n            hints.registerField(sourceField);\r\n        }\r\n        registerHintsForClassAttributes(hints, annotation);\r\n    }));\r\n    ReflectionUtils.doWithMethods(clazz, method -> forEachJacksonAnnotation(method, annotation -> {\r\n        Method sourceMethod = (Method) annotation.getSource();\r\n        if (sourceMethod != null) {\r\n            hints.registerMethod(sourceMethod, ExecutableMode.INVOKE);\r\n        }\r\n        registerHintsForClassAttributes(hints, annotation);\r\n    }));\r\n    forEachJacksonAnnotation(clazz, annotation -> registerHintsForClassAttributes(hints, annotation));\r\n}\nprivate void forEachJacksonAnnotation(AnnotatedElement element, Consumer<MergedAnnotation<Annotation>> action) {\r\n    MergedAnnotations.from(element, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY).stream(JACKSON_ANNOTATION).filter(MergedAnnotation::isMetaPresent).forEach(action);\r\n}\nprivate void registerHintsForClassAttributes(ReflectionHints hints, MergedAnnotation<Annotation> annotation) {\r\n    annotation.getRoot().asMap().forEach((attributeName, value) -> {\r\n        if (value instanceof Class<?> classValue && value != Void.class) {\r\n            if (attributeName.equals(\"builder\")) {\r\n                hints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS);\r\n            } else {\r\n                hints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n            }\r\n        }\r\n    });\r\n}\n/**\r\n * Inner class to avoid a hard dependency on Kotlin at runtime.\r\n */\r\nprivate static class KotlinDelegate {\r\n\r\n    public static void registerComponentHints(ReflectionHints hints, Class<?> type) {\r\n        KClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\r\n        if (kClass.isData()) {\r\n            for (Method method : type.getMethods()) {\r\n                String methodName = method.getName();\r\n                if (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\r\n                    hints.registerMethod(method, ExecutableMode.INVOKE);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n * Register the necessary reflection hints so that the specified type can be\n * bound at runtime. Fields, constructors, properties, and record components\n * are registered, except for a set of types like those in the {@code java.}\n * package where just the type is registered. Types are discovered transitively\n * on properties and record components, and generic types are registered as well.\n *\n * @author Sebastien Deleuze\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerReflectionHints(ReflectionHints,Type)",
    "entityType": "method",
    "code": "/**\r\n * Register the necessary reflection hints to bind the specified types.\r\n * @param hints the hints instance to use\r\n * @param types the types to register\r\n */\r\npublic void registerReflectionHints(ReflectionHints hints, Type... types) {\r\n    Set<Type> seen = new HashSet<>();\r\n    for (Type type : types) {\r\n        registerReflectionHints(hints, seen, type);\r\n    }\r\n}",
    "comment": "\n\t * Register the necessary reflection hints to bind the specified types.\n\t * @param hints the hints instance to use\n\t * @param types the types to register\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#shouldSkipType(Class<?>)",
    "entityType": "method",
    "code": "private boolean shouldSkipType(Class<?> type) {\r\n    return type.isPrimitive() || type == Object.class;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#shouldSkipMembers(Class<?>)",
    "entityType": "method",
    "code": "private boolean shouldSkipMembers(Class<?> type) {\r\n    return type.getCanonicalName().startsWith(\"java.\") || type.isArray();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerReflectionHints(ReflectionHints,Set<Type>,Type)",
    "entityType": "method",
    "code": "private void registerReflectionHints(ReflectionHints hints, Set<Type> seen, Type type) {\r\n    if (seen.contains(type)) {\r\n        return;\r\n    }\r\n    seen.add(type);\r\n    if (type instanceof Class<?> clazz) {\r\n        if (shouldSkipType(clazz)) {\r\n            return;\r\n        }\r\n        hints.registerType(clazz, typeHint -> {\r\n            if (!shouldSkipMembers(clazz)) {\r\n                if (clazz.isRecord()) {\r\n                    typeHint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n                    for (RecordComponent recordComponent : clazz.getRecordComponents()) {\r\n                        registerRecordHints(hints, seen, recordComponent.getAccessor());\r\n                    }\r\n                }\r\n                if (clazz.isEnum()) {\r\n                    typeHint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS, MemberCategory.INVOKE_PUBLIC_METHODS);\r\n                }\r\n                typeHint.withMembers(MemberCategory.ACCESS_DECLARED_FIELDS, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n                for (Method method : clazz.getMethods()) {\r\n                    String methodName = method.getName();\r\n                    if (methodName.startsWith(\"set\") && method.getParameterCount() == 1) {\r\n                        registerPropertyHints(hints, seen, method, 0);\r\n                    } else if ((methodName.startsWith(\"get\") && method.getParameterCount() == 0 && method.getReturnType() != void.class) || (methodName.startsWith(\"is\") && method.getParameterCount() == 0 && ClassUtils.resolvePrimitiveIfNecessary(method.getReturnType()) == Boolean.class)) {\r\n                        registerPropertyHints(hints, seen, method, -1);\r\n                    }\r\n                }\r\n                if (jacksonAnnotationPresent) {\r\n                    registerJacksonHints(hints, clazz);\r\n                }\r\n            }\r\n            if (KotlinDetector.isKotlinType(clazz)) {\r\n                KotlinDelegate.registerComponentHints(hints, clazz);\r\n                registerKotlinSerializationHints(hints, clazz);\r\n            }\r\n        });\r\n    }\r\n    Set<Class<?>> referencedTypes = new LinkedHashSet<>();\r\n    collectReferencedTypes(referencedTypes, ResolvableType.forType(type));\r\n    referencedTypes.forEach(referencedType -> registerReflectionHints(hints, seen, referencedType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerRecordHints(ReflectionHints,Set<Type>,Method)",
    "entityType": "method",
    "code": "private void registerRecordHints(ReflectionHints hints, Set<Type> seen, Method method) {\r\n    hints.registerMethod(method, ExecutableMode.INVOKE);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\r\n    Type methodParameterType = methodParameter.getGenericParameterType();\r\n    registerReflectionHints(hints, seen, methodParameterType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerPropertyHints(ReflectionHints,Set<Type>,Method,int)",
    "entityType": "method",
    "code": "private void registerPropertyHints(ReflectionHints hints, Set<Type> seen, @Nullable Method method, int parameterIndex) {\r\n    if (method != null && method.getDeclaringClass() != Object.class && method.getDeclaringClass() != Enum.class) {\r\n        hints.registerMethod(method, ExecutableMode.INVOKE);\r\n        MethodParameter methodParameter = MethodParameter.forExecutable(method, parameterIndex);\r\n        Type methodParameterType = methodParameter.getGenericParameterType();\r\n        registerReflectionHints(hints, seen, methodParameterType);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerKotlinSerializationHints(ReflectionHints,Class<?>)",
    "entityType": "method",
    "code": "private void registerKotlinSerializationHints(ReflectionHints hints, Class<?> clazz) {\r\n    String companionClassName = clazz.getCanonicalName() + KOTLIN_COMPANION_SUFFIX;\r\n    if (ClassUtils.isPresent(companionClassName, null)) {\r\n        Class<?> companionClass = ClassUtils.resolveClassName(companionClassName, null);\r\n        Method serializerMethod = ClassUtils.getMethodIfAvailable(companionClass, \"serializer\");\r\n        if (serializerMethod != null) {\r\n            hints.registerMethod(serializerMethod, ExecutableMode.INVOKE);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#collectReferencedTypes(Set<Class<?>>,ResolvableType)",
    "entityType": "method",
    "code": "private void collectReferencedTypes(Set<Class<?>> types, ResolvableType resolvableType) {\r\n    Class<?> clazz = resolvableType.resolve();\r\n    if (clazz != null && !types.contains(clazz)) {\r\n        types.add(clazz);\r\n        for (ResolvableType genericResolvableType : resolvableType.getGenerics()) {\r\n            collectReferencedTypes(types, genericResolvableType);\r\n        }\r\n        Class<?> superClass = clazz.getSuperclass();\r\n        if (superClass != null && superClass != Object.class && superClass != Record.class && superClass != Enum.class) {\r\n            types.add(superClass);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerJacksonHints(ReflectionHints,Class<?>)",
    "entityType": "method",
    "code": "private void registerJacksonHints(ReflectionHints hints, Class<?> clazz) {\r\n    ReflectionUtils.doWithFields(clazz, field -> forEachJacksonAnnotation(field, annotation -> {\r\n        Field sourceField = (Field) annotation.getSource();\r\n        if (sourceField != null) {\r\n            hints.registerField(sourceField);\r\n        }\r\n        registerHintsForClassAttributes(hints, annotation);\r\n    }));\r\n    ReflectionUtils.doWithMethods(clazz, method -> forEachJacksonAnnotation(method, annotation -> {\r\n        Method sourceMethod = (Method) annotation.getSource();\r\n        if (sourceMethod != null) {\r\n            hints.registerMethod(sourceMethod, ExecutableMode.INVOKE);\r\n        }\r\n        registerHintsForClassAttributes(hints, annotation);\r\n    }));\r\n    forEachJacksonAnnotation(clazz, annotation -> registerHintsForClassAttributes(hints, annotation));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#forEachJacksonAnnotation(AnnotatedElement,Consumer<MergedAnnotation<Annotation>>)",
    "entityType": "method",
    "code": "private void forEachJacksonAnnotation(AnnotatedElement element, Consumer<MergedAnnotation<Annotation>> action) {\r\n    MergedAnnotations.from(element, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY).stream(JACKSON_ANNOTATION).filter(MergedAnnotation::isMetaPresent).forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.BindingReflectionHintsRegistrar#registerHintsForClassAttributes(ReflectionHints,MergedAnnotation<Annotation>)",
    "entityType": "method",
    "code": "private void registerHintsForClassAttributes(ReflectionHints hints, MergedAnnotation<Annotation> annotation) {\r\n    annotation.getRoot().asMap().forEach((attributeName, value) -> {\r\n        if (value instanceof Class<?> classValue && value != Void.class) {\r\n            if (attributeName.equals(\"builder\")) {\r\n                hints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS, MemberCategory.INVOKE_DECLARED_METHODS);\r\n            } else {\r\n                hints.registerType(classValue, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);\r\n            }\r\n        }\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.KotlinDelegate",
    "entityType": "class",
    "code": "public static void registerComponentHints(ReflectionHints hints, Class<?> type) {\r\n    KClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\r\n    if (kClass.isData()) {\r\n        for (Method method : type.getMethods()) {\r\n            String methodName = method.getName();\r\n            if (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\r\n                hints.registerMethod(method, ExecutableMode.INVOKE);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Inner class to avoid a hard dependency on Kotlin at runtime.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.KotlinDelegate#registerComponentHints(ReflectionHints,Class<?>)",
    "entityType": "method",
    "code": "public static void registerComponentHints(ReflectionHints hints, Class<?> type) {\r\n    KClass<?> kClass = JvmClassMappingKt.getKotlinClass(type);\r\n    if (kClass.isData()) {\r\n        for (Method method : type.getMethods()) {\r\n            String methodName = method.getName();\r\n            if (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {\r\n                hints.registerMethod(method, ExecutableMode.INVOKE);\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ConditionalHint",
    "entityType": "class",
    "code": "/**\r\n * Return the type that should be reachable for this hint to apply, or\r\n * {@code null} if this hint should always been applied.\r\n * @return the reachable type, if any\r\n */\r\n@Nullable\r\nTypeReference getReachableType();\n/**\r\n * Whether the condition described for this hint is met. If it is not,\r\n * the hint does not apply.\r\n * <p>Instead of checking for actual reachability of a type in the\r\n * application, the classpath is checked for the presence of this\r\n * type as a simple heuristic.\r\n * @param classLoader the current classloader\r\n * @return whether the condition is met and the hint applies\r\n */\r\ndefault boolean conditionMatches(ClassLoader classLoader) {\r\n    TypeReference reachableType = getReachableType();\r\n    if (reachableType != null) {\r\n        return ClassUtils.isPresent(reachableType.getCanonicalName(), classLoader);\r\n    }\r\n    return true;\r\n}",
    "comment": "\n * Contract for {@link RuntimeHints runtime hints} that only apply\n * if the described condition is met.\n *\n * @author Brian Clozel\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ConditionalHint#getReachableType()",
    "entityType": "method",
    "code": "/**\r\n * Return the type that should be reachable for this hint to apply, or\r\n * {@code null} if this hint should always been applied.\r\n * @return the reachable type, if any\r\n */\r\n@Nullable\r\nTypeReference getReachableType();",
    "comment": "\n\t * Return the type that should be reachable for this hint to apply, or\n\t * {@code null} if this hint should always been applied.\n\t * @return the reachable type, if any\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ConditionalHint#conditionMatches(ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Whether the condition described for this hint is met. If it is not,\r\n * the hint does not apply.\r\n * <p>Instead of checking for actual reachability of a type in the\r\n * application, the classpath is checked for the presence of this\r\n * type as a simple heuristic.\r\n * @param classLoader the current classloader\r\n * @return whether the condition is met and the hint applies\r\n */\r\ndefault boolean conditionMatches(ClassLoader classLoader) {\r\n    TypeReference reachableType = getReachableType();\r\n    if (reachableType != null) {\r\n        return ClassUtils.isPresent(reachableType.getCanonicalName(), classLoader);\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * Whether the condition described for this hint is met. If it is not,\n\t * the hint does not apply.\n\t * <p>Instead of checking for actual reachability of a type in the\n\t * application, the classpath is checked for the presence of this\n\t * type as a simple heuristic.\n\t * @param classLoader the current classloader\n\t * @return whether the condition is met and the hint applies\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests",
    "entityType": "class",
    "code": "private final AntPathMatcher pathMatcher = new AntPathMatcher();\nprivate final AntPathMatcher dotSeparatedPathMatcher = new AntPathMatcher(\".\");\n@Test\r\nvoid match() {\r\n    // test exact matching\r\n    assertThat(pathMatcher.match(\"test\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/test\", \"/test\")).isTrue();\r\n    // SPR-14141\r\n    assertThat(pathMatcher.match(\"https://example.org\", \"https://example.org\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/test.jpg\", \"test.jpg\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test\", \"/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/test\", \"test\")).isFalse();\r\n    // test matching with ?'s\r\n    assertThat(pathMatcher.match(\"t?st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"??st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"te??\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"?es?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tes\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"testt\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tsst\")).isFalse();\r\n    // test matching with *'s\r\n    assertThat(pathMatcher.match(\"*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"testTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test/Test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test/t\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test*\", \"AnothertestTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test\", \"Anothertest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*.*\", \"test.\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*.*\", \"test.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*.*\", \"test.test.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaaa\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"tst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"tsttest\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"test/\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"test/t\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*.*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaab\")).isFalse();\r\n    // test matching with ?'s and /'s\r\n    assertThat(pathMatcher.match(\"/?\", \"/a\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/?/a\", \"/a/a\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/a/?\", \"/a/b\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/??/a\", \"/aa/a\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/a/??\", \"/a/bb\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/?\", \"/a\")).isTrue();\r\n    // test matching with **'s\r\n    assertThat(pathMatcher.match(\"/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/**/*\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla/**/bla\", \"/bla/testing/testing/bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla/**/bla\", \"/bla/testing/testing/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/**/test\", \"/bla/bla/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla/**/**/bla\", \"/bla/bla/bla/bla/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla*bla/test\", \"/blaXXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla/test\", \"/XXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla*bla/test\", \"/blaXXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/*bla/test\", \"XXXblab/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/*bla/test\", \"XXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/????\", \"/bala/bla\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/**/*bla\", \"/bla/bla/bla/bbb\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/*\", \"/XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing.jpg\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/x/x/**/bla\", \"/x/x/x/\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/foo/bar/**\", \"/foo/bar\")).isTrue();\r\n    assertThat(pathMatcher.match(\"\", \"\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/{bla}.*\", \"/testing.html\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/{bla}\", \"//x\\ny\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/{var:.*}\", \"/x\\ny\")).isTrue();\r\n}\n@Test\r\nvoid matchWithNullPath() {\r\n    assertThat(pathMatcher.match(\"/test\", null)).isFalse();\r\n    assertThat(pathMatcher.match(\"/\", null)).isFalse();\r\n    assertThat(pathMatcher.match(null, null)).isFalse();\r\n}\n// SPR-14247\r\n@Test\r\nvoid matchWithTrimTokensEnabled() {\r\n    pathMatcher.setTrimTokens(true);\r\n    assertThat(pathMatcher.match(\"/foo/bar\", \"/foo /bar\")).isTrue();\r\n}\n@Test\r\nvoid matchStart() {\r\n    // test exact matching\r\n    assertThat(pathMatcher.matchStart(\"test\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/test\", \"/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/test.jpg\", \"test.jpg\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test\", \"/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/test\", \"test\")).isFalse();\r\n    // test matching with ?'s\r\n    assertThat(pathMatcher.matchStart(\"t?st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"??st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"te??\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"?es?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"tes\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"testt\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"tsst\")).isFalse();\r\n    // test matching with *'s\r\n    assertThat(pathMatcher.matchStart(\"*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"testTest\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test/Test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test/t\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*test*\", \"AnothertestTest\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*test\", \"Anothertest\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"test.\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"test.test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"test.test.test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*aaa\", \"testblaaaa\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"tst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test/\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"tsttest\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test/\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test/t\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/t*.txt\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*test*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"*test\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*aaa\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*aaa\", \"testblaaab\")).isFalse();\r\n    // test matching with ?'s and /'s\r\n    assertThat(pathMatcher.matchStart(\"/?\", \"/a\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/?/a\", \"/a/a\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/a/?\", \"/a/b\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/??/a\", \"/aa/a\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/a/??\", \"/a/bb\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/?\", \"/a\")).isTrue();\r\n    // test matching with **'s\r\n    assertThat(pathMatcher.matchStart(\"/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/**/*\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*/**\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*/**\", \"test/t\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla/**/bla\", \"/bla/testing/testing/bla\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla/**/bla\", \"/bla/testing/testing/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/**/test\", \"/bla/bla/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla/**/**/bla\", \"/bla/bla/bla/bla/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla*bla/test\", \"/blaXXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla/test\", \"/XXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla*bla/test\", \"/blaXXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/*bla/test\", \"XXXblab/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/*bla/test\", \"XXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/????\", \"/bala/bla\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/**/*bla\", \"/bla/bla/bla/bbb\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/*\", \"/XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing.jpg\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/x/x/**/bla\", \"/x/x/x/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"\", \"\")).isTrue();\r\n}\n@Test\r\nvoid uniqueDeliminator() {\r\n    pathMatcher.setPathSeparator(\".\");\r\n    // test exact matching\r\n    assertThat(pathMatcher.match(\"test\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".test\", \".test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".test/jpg\", \"test/jpg\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test\", \".test\")).isFalse();\r\n    assertThat(pathMatcher.match(\".test\", \"test\")).isFalse();\r\n    // test matching with ?'s\r\n    assertThat(pathMatcher.match(\"t?st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"??st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"te??\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"?es?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tes\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"testt\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tsst\")).isFalse();\r\n    // test matching with *'s\r\n    assertThat(pathMatcher.match(\"*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"testTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test*\", \"AnothertestTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test\", \"Anothertest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*/*\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*/*\", \"test/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*/*\", \"test/test/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaaa\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"tst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"tsttest\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*/*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaab\")).isFalse();\r\n    // test matching with ?'s and .'s\r\n    assertThat(pathMatcher.match(\".?\", \".a\")).isTrue();\r\n    assertThat(pathMatcher.match(\".?.a\", \".a.a\")).isTrue();\r\n    assertThat(pathMatcher.match(\".a.?\", \".a.b\")).isTrue();\r\n    assertThat(pathMatcher.match(\".??.a\", \".aa.a\")).isTrue();\r\n    assertThat(pathMatcher.match(\".a.??\", \".a.bb\")).isTrue();\r\n    assertThat(pathMatcher.match(\".?\", \".a\")).isTrue();\r\n    // test matching with **'s\r\n    assertThat(pathMatcher.match(\".**\", \".testing.testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\".*.**\", \".testing.testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\".**.*\", \".testing.testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla.**.bla\", \".bla.testing.testing.bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla.**.bla\", \".bla.testing.testing.bla.bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\".**.test\", \".bla.bla.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla.**.**.bla\", \".bla.bla.bla.bla.bla.bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla*bla.test\", \".blaXXXbla.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".*bla.test\", \".XXXbla.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla*bla.test\", \".blaXXXbl.test\")).isFalse();\r\n    assertThat(pathMatcher.match(\".*bla.test\", \"XXXblab.test\")).isFalse();\r\n    assertThat(pathMatcher.match(\".*bla.test\", \"XXXbl.test\")).isFalse();\r\n}\n@Test\r\nvoid extractPathWithinPattern() {\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/commit.html\", \"/docs/commit.html\")).isEmpty();\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/*\", \"/docs/cvs/commit\")).isEqualTo(\"cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/cvs/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**\", \"/docs/cvs/commit\")).isEqualTo(\"cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"cvs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/*.html\", \"/docs/commit.html\")).isEqualTo(\"commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/*.html\", \"/commit.html\")).isEqualTo(\"commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/*.html\", \"/docs/commit.html\")).isEqualTo(\"docs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"*.html\", \"/commit.html\")).isEqualTo(\"/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"*.html\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"**/*.*\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"*\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\r\n    // SPR-10515\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"**/commit.html\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"/docs/cvs/other/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/commit.html\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"cvs/other/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/**/**/**\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"cvs/other/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/*\", \"/docs/cvs/commit\")).isEqualTo(\"docs/cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/c?s/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"cvs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/**\", \"/docs/cvs/commit\")).isEqualTo(\"docs/cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/**/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"docs/cvs/commit.html\");\r\n}\n@Test\r\nvoid extractUriTemplateVariables() {\r\n    Map<String, String> result = pathMatcher.extractUriTemplateVariables(\"/hotels/{hotel}\", \"/hotels/1\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/h?tels/{hotel}\", \"/hotels/1\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/hotels/{hotel}/bookings/{booking}\", \"/hotels/1/bookings/2\");\r\n    Map<String, String> expected = new LinkedHashMap<>();\r\n    expected.put(\"hotel\", \"1\");\r\n    expected.put(\"booking\", \"2\");\r\n    assertThat(result).isEqualTo(expected);\r\n    result = pathMatcher.extractUriTemplateVariables(\"/**/hotels/**/{hotel}\", \"/foo/hotels/bar/1\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/{page}.html\", \"/42.html\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"page\", \"42\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/{page}.*\", \"/42.html\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"page\", \"42\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/A-{B}-C\", \"/A-b-C\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"B\", \"b\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/{name}.{extension}\", \"/test.html\");\r\n    expected = new LinkedHashMap<>();\r\n    expected.put(\"name\", \"test\");\r\n    expected.put(\"extension\", \"html\");\r\n    assertThat(result).isEqualTo(expected);\r\n}\n// gh-26264\r\n@Test\r\nvoid extractUriTemplateVariablesFromDotSeparatedPath() {\r\n    Map<String, String> result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"price.stock.{tickerSymbol}\", \"price.stock.aaa\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"tickerSymbol\", \"aaa\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"price.stock.{ticker/symbol}\", \"price.stock.aaa\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"ticker/symbol\", \"aaa\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"notification.**.{operation}\", \"notification.foo.update\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"operation\", \"update\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"news.sports.feed/{type}\", \"news.sports.feed/xml\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"type\", \"xml\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"news.sports.{operation}/*\", \"news.sports.feed/xml\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"operation\", \"feed\"));\r\n}\n@Test\r\nvoid extractUriTemplateVariablesRegex() {\r\n    Map<String, String> result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-{version:[\\\\w\\\\.]+}.jar\", \"com.example-1.0.0.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n    result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-sources-{version:[\\\\w\\\\.]+}.jar\", \"com.example-sources-1.0.0.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n}\n/**\r\n * SPR-7787\r\n */\r\n@Test\r\nvoid extractUriTemplateVarsRegexQualifiers() {\r\n    Map<String, String> result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\p{L}\\\\.]+}-sources-{version:[\\\\p{N}\\\\.]+}.jar\", \"com.example-sources-1.0.0.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n    result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-sources-{version:[\\\\d\\\\.]+}-{year:\\\\d{4}}{month:\\\\d{2}}{day:\\\\d{2}}.jar\", \"com.example-sources-1.0.0-20100220.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n    assertThat(result.get(\"year\")).isEqualTo(\"2010\");\r\n    assertThat(result.get(\"month\")).isEqualTo(\"02\");\r\n    assertThat(result.get(\"day\")).isEqualTo(\"20\");\r\n    result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\p{L}\\\\.]+}-sources-{version:[\\\\p{N}\\\\.\\\\{\\\\}]+}.jar\", \"com.example-sources-1.0.0.{12}.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0.{12}\");\r\n}\n/**\r\n * SPR-8455\r\n */\r\n@Test\r\nvoid extractUriTemplateVarsRegexCapturingGroups() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> pathMatcher.extractUriTemplateVariables(\"/web/{id:foo(bar)?}\", \"/web/foobar\")).withMessageContaining(\"The number of capturing groups in the pattern\");\r\n}\n@Test\r\nvoid combine() {\r\n    assertThat(pathMatcher.combine(null, null)).isEmpty();\r\n    assertThat(pathMatcher.combine(\"/hotels\", null)).isEqualTo(\"/hotels\");\r\n    assertThat(pathMatcher.combine(null, \"/hotels\")).isEqualTo(\"/hotels\");\r\n    assertThat(pathMatcher.combine(\"/hotels/*\", \"booking\")).isEqualTo(\"/hotels/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels/*\", \"/booking\")).isEqualTo(\"/hotels/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels/**\", \"booking\")).isEqualTo(\"/hotels/**/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels/**\", \"/booking\")).isEqualTo(\"/hotels/**/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels\", \"/booking\")).isEqualTo(\"/hotels/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels\", \"booking\")).isEqualTo(\"/hotels/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels/\", \"booking\")).isEqualTo(\"/hotels/booking\");\r\n    assertThat(pathMatcher.combine(\"/hotels/*\", \"{hotel}\")).isEqualTo(\"/hotels/{hotel}\");\r\n    assertThat(pathMatcher.combine(\"/hotels/**\", \"{hotel}\")).isEqualTo(\"/hotels/**/{hotel}\");\r\n    assertThat(pathMatcher.combine(\"/hotels\", \"{hotel}\")).isEqualTo(\"/hotels/{hotel}\");\r\n    assertThat(pathMatcher.combine(\"/hotels\", \"{hotel}.*\")).isEqualTo(\"/hotels/{hotel}.*\");\r\n    assertThat(pathMatcher.combine(\"/hotels/*/booking\", \"{booking}\")).isEqualTo(\"/hotels/*/booking/{booking}\");\r\n    assertThat(pathMatcher.combine(\"/*.html\", \"/hotel.html\")).isEqualTo(\"/hotel.html\");\r\n    assertThat(pathMatcher.combine(\"/*.html\", \"/hotel\")).isEqualTo(\"/hotel.html\");\r\n    assertThat(pathMatcher.combine(\"/*.html\", \"/hotel.*\")).isEqualTo(\"/hotel.html\");\r\n    assertThat(pathMatcher.combine(\"/**\", \"/*.html\")).isEqualTo(\"/*.html\");\r\n    assertThat(pathMatcher.combine(\"/*\", \"/*.html\")).isEqualTo(\"/*.html\");\r\n    assertThat(pathMatcher.combine(\"/*.*\", \"/*.html\")).isEqualTo(\"/*.html\");\r\n    // SPR-8858\r\n    assertThat(pathMatcher.combine(\"/{foo}\", \"/bar\")).isEqualTo(\"/{foo}/bar\");\r\n    // SPR-7970\r\n    assertThat(pathMatcher.combine(\"/user\", \"/user\")).isEqualTo(\"/user/user\");\r\n    // SPR-10062\r\n    assertThat(pathMatcher.combine(\"/{foo:.*[^0-9].*}\", \"/edit/\")).isEqualTo(\"/{foo:.*[^0-9].*}/edit/\");\r\n    // SPR-10554\r\n    assertThat(pathMatcher.combine(\"/1.0\", \"/foo/test\")).isEqualTo(\"/1.0/foo/test\");\r\n    // SPR-12975\r\n    assertThat(pathMatcher.combine(\"/\", \"/hotel\")).isEqualTo(\"/hotel\");\r\n    // SPR-12975\r\n    assertThat(pathMatcher.combine(\"/hotel/\", \"/booking\")).isEqualTo(\"/hotel/booking\");\r\n}\n@Test\r\nvoid combineWithTwoFileExtensionPatterns() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> pathMatcher.combine(\"/*.html\", \"/*.txt\"));\r\n}\n@Test\r\nvoid patternComparator() {\r\n    Comparator<String> comparator = pathMatcher.getPatternComparator(\"/hotels/new\");\r\n    assertThat(comparator.compare(null, null)).isEqualTo(0);\r\n    assertThat(comparator.compare(null, \"/hotels/new\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/new\", null)).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/new\", \"/hotels/new\")).isEqualTo(0);\r\n    assertThat(comparator.compare(\"/hotels/new\", \"/hotels/*\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/*\", \"/hotels/new\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/*\", \"/hotels/*\")).isEqualTo(0);\r\n    assertThat(comparator.compare(\"/hotels/new\", \"/hotels/{hotel}\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/new\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/{hotel}\")).isEqualTo(0);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}/booking\", \"/hotels/{hotel}/bookings/{booking}\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}/bookings/{booking}\", \"/hotels/{hotel}/booking\")).isEqualTo(1);\r\n    // SPR-10550\r\n    assertThat(comparator.compare(\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\", \"/**\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/**\", \"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/**\", \"/**\")).isEqualTo(0);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/*\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/*\", \"/hotels/{hotel}\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/*\", \"/hotels/*/**\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/*/**\", \"/hotels/*\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/new\", \"/hotels/new.*\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/{hotel}.*\")).isEqualTo(2);\r\n    // SPR-6741\r\n    assertThat(comparator.compare(\"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\", \"/hotels/**\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"/hotels/**\", \"/hotels/{hotel}/bookings/{booking}/cutomers/{customer}\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/foo/bar/**\", \"/hotels/{hotel}\")).isEqualTo(1);\r\n    assertThat(comparator.compare(\"/hotels/{hotel}\", \"/hotels/foo/bar/**\")).isEqualTo(-1);\r\n    // gh-23125\r\n    assertThat(comparator.compare(\"/hotels/*/bookings/**\", \"/hotels/**\")).isEqualTo(-11);\r\n    // SPR-8683\r\n    assertThat(comparator.compare(\"/**\", \"/hotels/{hotel}\")).isEqualTo(1);\r\n    // longer is better\r\n    assertThat(comparator.compare(\"/hotels\", \"/hotels2\")).isEqualTo(1);\r\n    // SPR-13139\r\n    assertThat(comparator.compare(\"*\", \"*/**\")).isEqualTo(-1);\r\n    assertThat(comparator.compare(\"*/**\", \"*\")).isEqualTo(1);\r\n}\n@Test\r\nvoid patternComparatorWithDotSeparator() {\r\n    Comparator<String> comparator = dotSeparatedPathMatcher.getPatternComparator(\"price.stock.spring\");\r\n    assertThat(comparator.compare(null, null)).isEqualTo(0);\r\n    assertThat(comparator.compare(\"price.stock.ticker/symbol\", \"price.stock.ticker/symbol\")).isEqualTo(0);\r\n    assertThat(comparator.compare(\"price.stock.**\", \"price.stock.ticker\")).isEqualTo(1);\r\n}\n@Test\r\nvoid patternComparatorSort() {\r\n    Comparator<String> comparator = pathMatcher.getPatternComparator(\"/hotels/new\");\r\n    List<String> paths = new ArrayList<>(3);\r\n    paths.add(null);\r\n    paths.add(\"/hotels/new\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", null);\r\n    paths.clear();\r\n    paths.add(\"/hotels/new\");\r\n    paths.add(null);\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", null);\r\n    paths.clear();\r\n    paths.add(\"/hotels/*\");\r\n    paths.add(\"/hotels/new\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/*\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/new\");\r\n    paths.add(\"/hotels/*\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/*\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/**\");\r\n    paths.add(\"/hotels/*\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/*\", \"/hotels/**\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/*\");\r\n    paths.add(\"/hotels/**\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/*\", \"/hotels/**\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/{hotel}\");\r\n    paths.add(\"/hotels/new\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/{hotel}\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/new\");\r\n    paths.add(\"/hotels/{hotel}\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/{hotel}\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/*\");\r\n    paths.add(\"/hotels/{hotel}\");\r\n    paths.add(\"/hotels/new\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new\", \"/hotels/{hotel}\", \"/hotels/*\");\r\n    paths.clear();\r\n    paths.add(\"/hotels/ne*\");\r\n    paths.add(\"/hotels/n*\");\r\n    Collections.shuffle(paths);\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/ne*\", \"/hotels/n*\");\r\n    paths.clear();\r\n    comparator = pathMatcher.getPatternComparator(\"/hotels/new.html\");\r\n    paths.add(\"/hotels/new.*\");\r\n    paths.add(\"/hotels/{hotel}\");\r\n    Collections.shuffle(paths);\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/hotels/new.*\", \"/hotels/{hotel}\");\r\n    paths.clear();\r\n    comparator = pathMatcher.getPatternComparator(\"/web/endUser/action/login.html\");\r\n    paths.add(\"/**/login.*\");\r\n    paths.add(\"/**/endUser/action/login.*\");\r\n    paths.sort(comparator);\r\n    assertThat(paths).containsExactly(\"/**/endUser/action/login.*\", \"/**/login.*\");\r\n    paths.clear();\r\n}\n// SPR-8687\r\n@Test\r\nvoid trimTokensOff() {\r\n    pathMatcher.setTrimTokens(false);\r\n    assertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/group/sales/members\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/group/  sales/members\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/Group/  Sales/Members\")).isFalse();\r\n}\n// SPR-13286\r\n@Test\r\nvoid caseInsensitive() {\r\n    pathMatcher.setCaseSensitive(false);\r\n    assertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/group/sales/members\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/group/{groupName}/members\", \"/Group/Sales/Members\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/Group/{groupName}/Members\", \"/group/Sales/members\")).isTrue();\r\n}\n@Test\r\nvoid defaultCacheSetting() {\r\n    match();\r\n    assertThat(pathMatcher.stringMatcherCache).hasSizeGreaterThan(20);\r\n    for (int i = 0; i < 65536; i++) {\r\n        pathMatcher.match(\"test\" + i, \"test\");\r\n    }\r\n    // Cache turned off because it went beyond the threshold\r\n    assertThat(pathMatcher.stringMatcherCache).isEmpty();\r\n}\n@Test\r\nvoid cachePatternsSetToTrue() {\r\n    pathMatcher.setCachePatterns(true);\r\n    match();\r\n    assertThat(pathMatcher.stringMatcherCache).hasSizeGreaterThan(20);\r\n    for (int i = 0; i < 65536; i++) {\r\n        pathMatcher.match(\"test\" + i, \"test\" + i);\r\n    }\r\n    // Cache keeps being alive due to the explicit cache setting\r\n    assertThat(pathMatcher.stringMatcherCache).hasSizeGreaterThan(65536);\r\n}\n@Test\r\nvoid preventCreatingStringMatchersIfPathDoesNotStartsWithPatternPrefix() {\r\n    pathMatcher.setCachePatterns(true);\r\n    assertThat(pathMatcher.stringMatcherCache).isEmpty();\r\n    pathMatcher.match(\"test?\", \"test\");\r\n    assertThat(pathMatcher.stringMatcherCache).hasSize(1);\r\n    pathMatcher.match(\"test?\", \"best\");\r\n    pathMatcher.match(\"test/*\", \"view/test.jpg\");\r\n    pathMatcher.match(\"test/**/test.jpg\", \"view/test.jpg\");\r\n    pathMatcher.match(\"test/{name}.jpg\", \"view/test.jpg\");\r\n    assertThat(pathMatcher.stringMatcherCache).hasSize(1);\r\n}\n@Test\r\nvoid creatingStringMatchersIfPatternPrefixCannotDetermineIfPathMatch() {\r\n    pathMatcher.setCachePatterns(true);\r\n    assertThat(pathMatcher.stringMatcherCache).isEmpty();\r\n    pathMatcher.match(\"test\", \"testian\");\r\n    pathMatcher.match(\"test?\", \"testFf\");\r\n    pathMatcher.match(\"test/*\", \"test/dir/name.jpg\");\r\n    pathMatcher.match(\"test/{name}.jpg\", \"test/lorem.jpg\");\r\n    pathMatcher.match(\"bla/**/test.jpg\", \"bla/test.jpg\");\r\n    pathMatcher.match(\"**/{name}.jpg\", \"test/lorem.jpg\");\r\n    pathMatcher.match(\"/**/{name}.jpg\", \"/test/lorem.jpg\");\r\n    pathMatcher.match(\"/*/dir/{name}.jpg\", \"/*/dir/lorem.jpg\");\r\n    assertThat(pathMatcher.stringMatcherCache).hasSize(7);\r\n}\n@Test\r\nvoid cachePatternsSetToFalse() {\r\n    pathMatcher.setCachePatterns(false);\r\n    match();\r\n    assertThat(pathMatcher.stringMatcherCache).isEmpty();\r\n}\n@Test\r\nvoid extensionMappingWithDotPathSeparator() {\r\n    pathMatcher.setPathSeparator(\".\");\r\n    assertThat(pathMatcher.combine(\"/*.html\", \"hotel.*\")).as(\"Extension mapping should be disabled with \\\".\\\" as path separator\").isEqualTo(\"/*.html.hotel.*\");\r\n}\n// gh-22959\r\n@Test\r\nvoid isPattern() {\r\n    assertThat(pathMatcher.isPattern(\"/test/*\")).isTrue();\r\n    assertThat(pathMatcher.isPattern(\"/test/**/name\")).isTrue();\r\n    assertThat(pathMatcher.isPattern(\"/test?\")).isTrue();\r\n    assertThat(pathMatcher.isPattern(\"/test/{name}\")).isTrue();\r\n    assertThat(pathMatcher.isPattern(\"/test/name\")).isFalse();\r\n    assertThat(pathMatcher.isPattern(\"/test/foo{bar\")).isFalse();\r\n}\n// gh-23297\r\n@Test\r\nvoid isPatternWithNullPath() {\r\n    assertThat(pathMatcher.isPattern(null)).isFalse();\r\n}\n// gh-27506\r\n@Test\r\nvoid consistentMatchWithWildcardsAndTrailingSlash() {\r\n    assertThat(pathMatcher.match(\"/*/foo\", \"/en/foo\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*/foo\", \"/en/foo/\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/**/foo\", \"/en/foo\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/**/foo\", \"/en/foo/\")).isFalse();\r\n}",
    "comment": "\n * Tests for {@link AntPathMatcher}.\n *\n * @author Alef Arendsen\n * @author Seth Ladd\n * @author Juergen Hoeller\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#match()",
    "entityType": "method",
    "code": "@Test\r\nvoid match() {\r\n    // test exact matching\r\n    assertThat(pathMatcher.match(\"test\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/test\", \"/test\")).isTrue();\r\n    // SPR-14141\r\n    assertThat(pathMatcher.match(\"https://example.org\", \"https://example.org\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/test.jpg\", \"test.jpg\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test\", \"/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/test\", \"test\")).isFalse();\r\n    // test matching with ?'s\r\n    assertThat(pathMatcher.match(\"t?st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"??st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"te??\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"?es?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tes\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"testt\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tsst\")).isFalse();\r\n    // test matching with *'s\r\n    assertThat(pathMatcher.match(\"*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"testTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test/Test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test/t\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test*\", \"AnothertestTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test\", \"Anothertest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*.*\", \"test.\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*.*\", \"test.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*.*\", \"test.test.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaaa\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"tst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"tsttest\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"test/\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"test/t\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test/*\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*.*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaab\")).isFalse();\r\n    // test matching with ?'s and /'s\r\n    assertThat(pathMatcher.match(\"/?\", \"/a\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/?/a\", \"/a/a\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/a/?\", \"/a/b\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/??/a\", \"/aa/a\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/a/??\", \"/a/bb\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/?\", \"/a\")).isTrue();\r\n    // test matching with **'s\r\n    assertThat(pathMatcher.match(\"/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/**/*\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla/**/bla\", \"/bla/testing/testing/bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla/**/bla\", \"/bla/testing/testing/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/**/test\", \"/bla/bla/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla/**/**/bla\", \"/bla/bla/bla/bla/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla*bla/test\", \"/blaXXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla/test\", \"/XXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/bla*bla/test\", \"/blaXXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/*bla/test\", \"XXXblab/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/*bla/test\", \"XXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/????\", \"/bala/bla\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/**/*bla\", \"/bla/bla/bla/bbb\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/*\", \"/XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing.jpg\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/x/x/**/bla\", \"/x/x/x/\")).isFalse();\r\n    assertThat(pathMatcher.match(\"/foo/bar/**\", \"/foo/bar\")).isTrue();\r\n    assertThat(pathMatcher.match(\"\", \"\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/{bla}.*\", \"/testing.html\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/{bla}\", \"//x\\ny\")).isTrue();\r\n    assertThat(pathMatcher.match(\"/{var:.*}\", \"/x\\ny\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#matchWithNullPath()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchWithNullPath() {\r\n    assertThat(pathMatcher.match(\"/test\", null)).isFalse();\r\n    assertThat(pathMatcher.match(\"/\", null)).isFalse();\r\n    assertThat(pathMatcher.match(null, null)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#matchWithTrimTokensEnabled()",
    "entityType": "method",
    "code": "// SPR-14247\r\n@Test\r\nvoid matchWithTrimTokensEnabled() {\r\n    pathMatcher.setTrimTokens(true);\r\n    assertThat(pathMatcher.match(\"/foo/bar\", \"/foo /bar\")).isTrue();\r\n}",
    "comment": " SPR-14247"
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#matchStart()",
    "entityType": "method",
    "code": "@Test\r\nvoid matchStart() {\r\n    // test exact matching\r\n    assertThat(pathMatcher.matchStart(\"test\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/test\", \"/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/test.jpg\", \"test.jpg\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test\", \"/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/test\", \"test\")).isFalse();\r\n    // test matching with ?'s\r\n    assertThat(pathMatcher.matchStart(\"t?st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"??st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"te??\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"?es?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"tes\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"testt\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"tes?\", \"tsst\")).isFalse();\r\n    // test matching with *'s\r\n    assertThat(pathMatcher.matchStart(\"*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"testTest\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test/Test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test/t\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*test*\", \"AnothertestTest\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*test\", \"Anothertest\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"test.\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"test.test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"test.test.test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*aaa\", \"testblaaaa\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"tst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test/\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"tsttest\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test/\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*\", \"test/t\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test/*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test/t*.txt\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*test*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"*test\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"*.*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*aaa\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"test*aaa\", \"testblaaab\")).isFalse();\r\n    // test matching with ?'s and /'s\r\n    assertThat(pathMatcher.matchStart(\"/?\", \"/a\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/?/a\", \"/a/a\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/a/?\", \"/a/b\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/??/a\", \"/aa/a\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/a/??\", \"/a/bb\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/?\", \"/a\")).isTrue();\r\n    // test matching with **'s\r\n    assertThat(pathMatcher.matchStart(\"/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*/**\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/**/*\", \"/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*/**\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"test*/**\", \"test/t\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla/**/bla\", \"/bla/testing/testing/bla\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla/**/bla\", \"/bla/testing/testing/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/**/test\", \"/bla/bla/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla/**/**/bla\", \"/bla/bla/bla/bla/bla/bla\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla*bla/test\", \"/blaXXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla/test\", \"/XXXbla/test\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/bla*bla/test\", \"/blaXXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/*bla/test\", \"XXXblab/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/*bla/test\", \"XXXbl/test\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/????\", \"/bala/bla\")).isFalse();\r\n    assertThat(pathMatcher.matchStart(\"/**/*bla\", \"/bla/bla/bla/bbb\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/*\", \"/XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/*bla*/**/bla/**\", \"/XXXblaXXXX/testing/testing/bla/testing/testing.jpg\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/**\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"*bla*/**/bla/*\", \"XXXblaXXXX/testing/testing/bla/testing/testing\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"/x/x/**/bla\", \"/x/x/x/\")).isTrue();\r\n    assertThat(pathMatcher.matchStart(\"\", \"\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#uniqueDeliminator()",
    "entityType": "method",
    "code": "@Test\r\nvoid uniqueDeliminator() {\r\n    pathMatcher.setPathSeparator(\".\");\r\n    // test exact matching\r\n    assertThat(pathMatcher.match(\"test\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".test\", \".test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".test/jpg\", \"test/jpg\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test\", \".test\")).isFalse();\r\n    assertThat(pathMatcher.match(\".test\", \"test\")).isFalse();\r\n    // test matching with ?'s\r\n    assertThat(pathMatcher.match(\"t?st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"??st\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"te??\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"?es?\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tes\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"testt\")).isFalse();\r\n    assertThat(pathMatcher.match(\"tes?\", \"tsst\")).isFalse();\r\n    // test matching with *'s\r\n    assertThat(pathMatcher.match(\"*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"testTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test*\", \"AnothertestTest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*test\", \"Anothertest\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*/*\", \"test/\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*/*\", \"test/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"*/*\", \"test/test/test\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaaa\")).isTrue();\r\n    assertThat(pathMatcher.match(\"test*\", \"tst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*\", \"tsttest\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*test\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"*/*\", \"tsttst\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"test\")).isFalse();\r\n    assertThat(pathMatcher.match(\"test*aaa\", \"testblaaab\")).isFalse();\r\n    // test matching with ?'s and .'s\r\n    assertThat(pathMatcher.match(\".?\", \".a\")).isTrue();\r\n    assertThat(pathMatcher.match(\".?.a\", \".a.a\")).isTrue();\r\n    assertThat(pathMatcher.match(\".a.?\", \".a.b\")).isTrue();\r\n    assertThat(pathMatcher.match(\".??.a\", \".aa.a\")).isTrue();\r\n    assertThat(pathMatcher.match(\".a.??\", \".a.bb\")).isTrue();\r\n    assertThat(pathMatcher.match(\".?\", \".a\")).isTrue();\r\n    // test matching with **'s\r\n    assertThat(pathMatcher.match(\".**\", \".testing.testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\".*.**\", \".testing.testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\".**.*\", \".testing.testing\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla.**.bla\", \".bla.testing.testing.bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla.**.bla\", \".bla.testing.testing.bla.bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\".**.test\", \".bla.bla.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla.**.**.bla\", \".bla.bla.bla.bla.bla.bla\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla*bla.test\", \".blaXXXbla.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".*bla.test\", \".XXXbla.test\")).isTrue();\r\n    assertThat(pathMatcher.match(\".bla*bla.test\", \".blaXXXbl.test\")).isFalse();\r\n    assertThat(pathMatcher.match(\".*bla.test\", \"XXXblab.test\")).isFalse();\r\n    assertThat(pathMatcher.match(\".*bla.test\", \"XXXbl.test\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#extractPathWithinPattern()",
    "entityType": "method",
    "code": "@Test\r\nvoid extractPathWithinPattern() {\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/commit.html\", \"/docs/commit.html\")).isEmpty();\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/*\", \"/docs/cvs/commit\")).isEqualTo(\"cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/cvs/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**\", \"/docs/cvs/commit\")).isEqualTo(\"cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"cvs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/*.html\", \"/docs/commit.html\")).isEqualTo(\"commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/*.html\", \"/commit.html\")).isEqualTo(\"commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/*.html\", \"/docs/commit.html\")).isEqualTo(\"docs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"*.html\", \"/commit.html\")).isEqualTo(\"/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"*.html\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"**/*.*\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"*\", \"/docs/commit.html\")).isEqualTo(\"/docs/commit.html\");\r\n    // SPR-10515\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"**/commit.html\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"/docs/cvs/other/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/commit.html\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"cvs/other/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/**/**/**/**\", \"/docs/cvs/other/commit.html\")).isEqualTo(\"cvs/other/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/*\", \"/docs/cvs/commit\")).isEqualTo(\"docs/cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/docs/c?s/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"cvs/commit.html\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/**\", \"/docs/cvs/commit\")).isEqualTo(\"docs/cvs/commit\");\r\n    assertThat(pathMatcher.extractPathWithinPattern(\"/d?cs/**/*.html\", \"/docs/cvs/commit.html\")).isEqualTo(\"docs/cvs/commit.html\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#extractUriTemplateVariables()",
    "entityType": "method",
    "code": "@Test\r\nvoid extractUriTemplateVariables() {\r\n    Map<String, String> result = pathMatcher.extractUriTemplateVariables(\"/hotels/{hotel}\", \"/hotels/1\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/h?tels/{hotel}\", \"/hotels/1\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/hotels/{hotel}/bookings/{booking}\", \"/hotels/1/bookings/2\");\r\n    Map<String, String> expected = new LinkedHashMap<>();\r\n    expected.put(\"hotel\", \"1\");\r\n    expected.put(\"booking\", \"2\");\r\n    assertThat(result).isEqualTo(expected);\r\n    result = pathMatcher.extractUriTemplateVariables(\"/**/hotels/**/{hotel}\", \"/foo/hotels/bar/1\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"hotel\", \"1\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/{page}.html\", \"/42.html\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"page\", \"42\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/{page}.*\", \"/42.html\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"page\", \"42\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/A-{B}-C\", \"/A-b-C\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"B\", \"b\"));\r\n    result = pathMatcher.extractUriTemplateVariables(\"/{name}.{extension}\", \"/test.html\");\r\n    expected = new LinkedHashMap<>();\r\n    expected.put(\"name\", \"test\");\r\n    expected.put(\"extension\", \"html\");\r\n    assertThat(result).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#extractUriTemplateVariablesFromDotSeparatedPath()",
    "entityType": "method",
    "code": "// gh-26264\r\n@Test\r\nvoid extractUriTemplateVariablesFromDotSeparatedPath() {\r\n    Map<String, String> result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"price.stock.{tickerSymbol}\", \"price.stock.aaa\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"tickerSymbol\", \"aaa\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"price.stock.{ticker/symbol}\", \"price.stock.aaa\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"ticker/symbol\", \"aaa\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"notification.**.{operation}\", \"notification.foo.update\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"operation\", \"update\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"news.sports.feed/{type}\", \"news.sports.feed/xml\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"type\", \"xml\"));\r\n    result = dotSeparatedPathMatcher.extractUriTemplateVariables(\"news.sports.{operation}/*\", \"news.sports.feed/xml\");\r\n    assertThat(result).isEqualTo(Collections.singletonMap(\"operation\", \"feed\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#extractUriTemplateVariablesRegex()",
    "entityType": "method",
    "code": "@Test\r\nvoid extractUriTemplateVariablesRegex() {\r\n    Map<String, String> result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-{version:[\\\\w\\\\.]+}.jar\", \"com.example-1.0.0.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n    result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-sources-{version:[\\\\w\\\\.]+}.jar\", \"com.example-sources-1.0.0.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#extractUriTemplateVarsRegexQualifiers()",
    "entityType": "method",
    "code": "/**\r\n * SPR-7787\r\n */\r\n@Test\r\nvoid extractUriTemplateVarsRegexQualifiers() {\r\n    Map<String, String> result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\p{L}\\\\.]+}-sources-{version:[\\\\p{N}\\\\.]+}.jar\", \"com.example-sources-1.0.0.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n    result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\w\\\\.]+}-sources-{version:[\\\\d\\\\.]+}-{year:\\\\d{4}}{month:\\\\d{2}}{day:\\\\d{2}}.jar\", \"com.example-sources-1.0.0-20100220.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0\");\r\n    assertThat(result.get(\"year\")).isEqualTo(\"2010\");\r\n    assertThat(result.get(\"month\")).isEqualTo(\"02\");\r\n    assertThat(result.get(\"day\")).isEqualTo(\"20\");\r\n    result = pathMatcher.extractUriTemplateVariables(\"{symbolicName:[\\\\p{L}\\\\.]+}-sources-{version:[\\\\p{N}\\\\.\\\\{\\\\}]+}.jar\", \"com.example-sources-1.0.0.{12}.jar\");\r\n    assertThat(result.get(\"symbolicName\")).isEqualTo(\"com.example\");\r\n    assertThat(result.get(\"version\")).isEqualTo(\"1.0.0.{12}\");\r\n}",
    "comment": "\n\t * SPR-7787\n\t "
  },
  {
    "entityId": "org.springframework.util.AntPathMatcherTests#extractUriTemplateVarsRegexCapturingGroups()",
    "entityType": "method",
    "code": "/**\r\n * SPR-8455\r\n */\r\n@Test\r\nvoid extractUriTemplateVarsRegexCapturingGroups() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> pathMatcher.extractUriTemplateVariables(\"/web/{id:foo(bar)?}\", \"/web/foobar\")).withMessageContaining(\"The number of capturing groups in the pattern\");\r\n}",
    "comment": "\n\t * SPR-8455\n\t "
  }
]