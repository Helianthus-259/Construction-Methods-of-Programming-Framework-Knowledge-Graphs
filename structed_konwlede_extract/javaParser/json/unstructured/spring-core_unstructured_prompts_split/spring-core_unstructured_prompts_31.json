[
  {
    "entityId": "org.springframework.asm.Type",
    "entityType": "class",
    "code": "/**\r\n * The sort of the {@code void} type. See {@link #getSort}.\r\n */\r\npublic static final int VOID = 0;\n/**\r\n * The sort of the {@code boolean} type. See {@link #getSort}.\r\n */\r\npublic static final int BOOLEAN = 1;\n/**\r\n * The sort of the {@code char} type. See {@link #getSort}.\r\n */\r\npublic static final int CHAR = 2;\n/**\r\n * The sort of the {@code byte} type. See {@link #getSort}.\r\n */\r\npublic static final int BYTE = 3;\n/**\r\n * The sort of the {@code short} type. See {@link #getSort}.\r\n */\r\npublic static final int SHORT = 4;\n/**\r\n * The sort of the {@code int} type. See {@link #getSort}.\r\n */\r\npublic static final int INT = 5;\n/**\r\n * The sort of the {@code float} type. See {@link #getSort}.\r\n */\r\npublic static final int FLOAT = 6;\n/**\r\n * The sort of the {@code long} type. See {@link #getSort}.\r\n */\r\npublic static final int LONG = 7;\n/**\r\n * The sort of the {@code double} type. See {@link #getSort}.\r\n */\r\npublic static final int DOUBLE = 8;\n/**\r\n * The sort of array reference types. See {@link #getSort}.\r\n */\r\npublic static final int ARRAY = 9;\n/**\r\n * The sort of object reference types. See {@link #getSort}.\r\n */\r\npublic static final int OBJECT = 10;\n/**\r\n * The sort of method types. See {@link #getSort}.\r\n */\r\npublic static final int METHOD = 11;\n/**\r\n * The (private) sort of object reference types represented with an internal name.\r\n */\r\nprivate static final int INTERNAL = 12;\n/**\r\n * The descriptors of the primitive types.\r\n */\r\nprivate static final String PRIMITIVE_DESCRIPTORS = \"VZCBSIFJD\";\n/**\r\n * The {@code void} type.\r\n */\r\npublic static final Type VOID_TYPE = new Type(VOID, PRIMITIVE_DESCRIPTORS, VOID, VOID + 1);\n/**\r\n * The {@code boolean} type.\r\n */\r\npublic static final Type BOOLEAN_TYPE = new Type(BOOLEAN, PRIMITIVE_DESCRIPTORS, BOOLEAN, BOOLEAN + 1);\n/**\r\n * The {@code char} type.\r\n */\r\npublic static final Type CHAR_TYPE = new Type(CHAR, PRIMITIVE_DESCRIPTORS, CHAR, CHAR + 1);\n/**\r\n * The {@code byte} type.\r\n */\r\npublic static final Type BYTE_TYPE = new Type(BYTE, PRIMITIVE_DESCRIPTORS, BYTE, BYTE + 1);\n/**\r\n * The {@code short} type.\r\n */\r\npublic static final Type SHORT_TYPE = new Type(SHORT, PRIMITIVE_DESCRIPTORS, SHORT, SHORT + 1);\n/**\r\n * The {@code int} type.\r\n */\r\npublic static final Type INT_TYPE = new Type(INT, PRIMITIVE_DESCRIPTORS, INT, INT + 1);\n/**\r\n * The {@code float} type.\r\n */\r\npublic static final Type FLOAT_TYPE = new Type(FLOAT, PRIMITIVE_DESCRIPTORS, FLOAT, FLOAT + 1);\n/**\r\n * The {@code long} type.\r\n */\r\npublic static final Type LONG_TYPE = new Type(LONG, PRIMITIVE_DESCRIPTORS, LONG, LONG + 1);\n/**\r\n * The {@code double} type.\r\n */\r\npublic static final Type DOUBLE_TYPE = new Type(DOUBLE, PRIMITIVE_DESCRIPTORS, DOUBLE, DOUBLE + 1);\n// -----------------------------------------------------------------------------------------------\r\n// Fields\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * The sort of this type. Either {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE},\r\n * {@link #SHORT}, {@link #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY},\r\n * {@link #OBJECT}, {@link #METHOD} or {@link #INTERNAL}.\r\n */\r\nprivate final int sort;\n/**\r\n * A buffer containing the value of this field or method type. This value is an internal name for\r\n * {@link #OBJECT} and {@link #INTERNAL} types, and a field or method descriptor in the other\r\n * cases.\r\n *\r\n * <p>For {@link #OBJECT} types, this field also contains the descriptor: the characters in\r\n * [{@link #valueBegin},{@link #valueEnd}) contain the internal name, and those in [{@link\r\n * #valueBegin} - 1, {@link #valueEnd} + 1) contain the descriptor.\r\n */\r\nprivate final String valueBuffer;\n/**\r\n * The beginning index, inclusive, of the value of this Java field or method type in {@link\r\n * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,\r\n * and a field or method descriptor in the other cases.\r\n */\r\nprivate final int valueBegin;\n/**\r\n * The end index, exclusive, of the value of this Java field or method type in {@link\r\n * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,\r\n * and a field or method descriptor in the other cases.\r\n */\r\nprivate final int valueEnd;\n/**\r\n * Constructs a reference type.\r\n *\r\n * @param sort the sort of this type, see {@link #sort}.\r\n * @param valueBuffer a buffer containing the value of this field or method type.\r\n * @param valueBegin the beginning index, inclusive, of the value of this field or method type in\r\n *     valueBuffer.\r\n * @param valueEnd the end index, exclusive, of the value of this field or method type in\r\n *     valueBuffer.\r\n */\r\nprivate Type(final int sort, final String valueBuffer, final int valueBegin, final int valueEnd) {\r\n    this.sort = sort;\r\n    this.valueBuffer = valueBuffer;\r\n    this.valueBegin = valueBegin;\r\n    this.valueEnd = valueEnd;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the {@link Type} corresponding to the given type descriptor.\r\n *\r\n * @param typeDescriptor a field or method type descriptor.\r\n * @return the {@link Type} corresponding to the given type descriptor.\r\n */\r\npublic static Type getType(final String typeDescriptor) {\r\n    return getTypeInternal(typeDescriptor, 0, typeDescriptor.length());\r\n}\n/**\r\n * Returns the {@link Type} corresponding to the given class.\r\n *\r\n * @param clazz a class.\r\n * @return the {@link Type} corresponding to the given class.\r\n */\r\npublic static Type getType(final Class<?> clazz) {\r\n    if (clazz.isPrimitive()) {\r\n        if (clazz == Integer.TYPE) {\r\n            return INT_TYPE;\r\n        } else if (clazz == Void.TYPE) {\r\n            return VOID_TYPE;\r\n        } else if (clazz == Boolean.TYPE) {\r\n            return BOOLEAN_TYPE;\r\n        } else if (clazz == Byte.TYPE) {\r\n            return BYTE_TYPE;\r\n        } else if (clazz == Character.TYPE) {\r\n            return CHAR_TYPE;\r\n        } else if (clazz == Short.TYPE) {\r\n            return SHORT_TYPE;\r\n        } else if (clazz == Double.TYPE) {\r\n            return DOUBLE_TYPE;\r\n        } else if (clazz == Float.TYPE) {\r\n            return FLOAT_TYPE;\r\n        } else if (clazz == Long.TYPE) {\r\n            return LONG_TYPE;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else {\r\n        return getType(getDescriptor(clazz));\r\n    }\r\n}\n/**\r\n * Returns the method {@link Type} corresponding to the given constructor.\r\n *\r\n * @param constructor a {@link Constructor} object.\r\n * @return the method {@link Type} corresponding to the given constructor.\r\n */\r\npublic static Type getType(final Constructor<?> constructor) {\r\n    return getType(getConstructorDescriptor(constructor));\r\n}\n/**\r\n * Returns the method {@link Type} corresponding to the given method.\r\n *\r\n * @param method a {@link Method} object.\r\n * @return the method {@link Type} corresponding to the given method.\r\n */\r\npublic static Type getType(final Method method) {\r\n    return getType(getMethodDescriptor(method));\r\n}\n/**\r\n * Returns the type of the elements of this array type. This method should only be used for an\r\n * array type.\r\n *\r\n * @return Returns the type of the elements of this array type.\r\n */\r\npublic Type getElementType() {\r\n    final int numDimensions = getDimensions();\r\n    return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);\r\n}\n/**\r\n * Returns the {@link Type} corresponding to the given internal name.\r\n *\r\n * @param internalName an internal name (see {@link Type#getInternalName()}).\r\n * @return the {@link Type} corresponding to the given internal name.\r\n */\r\npublic static Type getObjectType(final String internalName) {\r\n    return new Type(internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length());\r\n}\n/**\r\n * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>\r\n * Type.getType(methodDescriptor)</code>.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the {@link Type} corresponding to the given method descriptor.\r\n */\r\npublic static Type getMethodType(final String methodDescriptor) {\r\n    return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());\r\n}\n/**\r\n * Returns the method {@link Type} corresponding to the given argument and return types.\r\n *\r\n * @param returnType the return type of the method.\r\n * @param argumentTypes the argument types of the method.\r\n * @return the method {@link Type} corresponding to the given argument and return types.\r\n */\r\npublic static Type getMethodType(final Type returnType, final Type... argumentTypes) {\r\n    return getType(getMethodDescriptor(returnType, argumentTypes));\r\n}\n/**\r\n * Returns the argument types of methods of this type. This method should only be used for method\r\n * types.\r\n *\r\n * @return the argument types of methods of this type.\r\n */\r\npublic Type[] getArgumentTypes() {\r\n    return getArgumentTypes(getDescriptor());\r\n}\n/**\r\n * Returns the {@link Type} values corresponding to the argument types of the given method\r\n * descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the {@link Type} values corresponding to the argument types of the given method\r\n *     descriptor.\r\n */\r\npublic static Type[] getArgumentTypes(final String methodDescriptor) {\r\n    // First step: compute the number of argument types in methodDescriptor.\r\n    int numArgumentTypes = getArgumentCount(methodDescriptor);\r\n    // Second step: create a Type instance for each argument type.\r\n    Type[] argumentTypes = new Type[numArgumentTypes];\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    // Parse and create the argument types, one at each loop iteration.\r\n    int currentArgumentTypeIndex = 0;\r\n    while (methodDescriptor.charAt(currentOffset) != ')') {\r\n        final int currentArgumentTypeOffset = currentOffset;\r\n        while (methodDescriptor.charAt(currentOffset) == '[') {\r\n            currentOffset++;\r\n        }\r\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n            // Skip the argument descriptor content.\r\n            int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n        }\r\n        argumentTypes[currentArgumentTypeIndex++] = getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);\r\n    }\r\n    return argumentTypes;\r\n}\n/**\r\n * Returns the {@link Type} values corresponding to the argument types of the given method.\r\n *\r\n * @param method a method.\r\n * @return the {@link Type} values corresponding to the argument types of the given method.\r\n */\r\npublic static Type[] getArgumentTypes(final Method method) {\r\n    Class<?>[] classes = method.getParameterTypes();\r\n    Type[] types = new Type[classes.length];\r\n    for (int i = classes.length - 1; i >= 0; --i) {\r\n        types[i] = getType(classes[i]);\r\n    }\r\n    return types;\r\n}\n/**\r\n * Returns the return type of methods of this type. This method should only be used for method\r\n * types.\r\n *\r\n * @return the return type of methods of this type.\r\n */\r\npublic Type getReturnType() {\r\n    return getReturnType(getDescriptor());\r\n}\n/**\r\n * Returns the {@link Type} corresponding to the return type of the given method descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the {@link Type} corresponding to the return type of the given method descriptor.\r\n */\r\npublic static Type getReturnType(final String methodDescriptor) {\r\n    return getTypeInternal(methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());\r\n}\n/**\r\n * Returns the {@link Type} corresponding to the return type of the given method.\r\n *\r\n * @param method a method.\r\n * @return the {@link Type} corresponding to the return type of the given method.\r\n */\r\npublic static Type getReturnType(final Method method) {\r\n    return getType(method.getReturnType());\r\n}\n/**\r\n * Returns the start index of the return type of the given method descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the start index of the return type of the given method descriptor.\r\n */\r\nstatic int getReturnTypeOffset(final String methodDescriptor) {\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    // Skip the argument types, one at a each loop iteration.\r\n    while (methodDescriptor.charAt(currentOffset) != ')') {\r\n        while (methodDescriptor.charAt(currentOffset) == '[') {\r\n            currentOffset++;\r\n        }\r\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n            // Skip the argument descriptor content.\r\n            int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n        }\r\n    }\r\n    return currentOffset + 1;\r\n}\n/**\r\n * Returns the {@link Type} corresponding to the given field or method descriptor.\r\n *\r\n * @param descriptorBuffer a buffer containing the field or method descriptor.\r\n * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in\r\n *     descriptorBuffer.\r\n * @param descriptorEnd the end index, exclusive, of the field or method descriptor in\r\n *     descriptorBuffer.\r\n * @return the {@link Type} corresponding to the given type descriptor.\r\n */\r\nprivate static Type getTypeInternal(final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {\r\n    switch(descriptorBuffer.charAt(descriptorBegin)) {\r\n        case 'V':\r\n            return VOID_TYPE;\r\n        case 'Z':\r\n            return BOOLEAN_TYPE;\r\n        case 'C':\r\n            return CHAR_TYPE;\r\n        case 'B':\r\n            return BYTE_TYPE;\r\n        case 'S':\r\n            return SHORT_TYPE;\r\n        case 'I':\r\n            return INT_TYPE;\r\n        case 'F':\r\n            return FLOAT_TYPE;\r\n        case 'J':\r\n            return LONG_TYPE;\r\n        case 'D':\r\n            return DOUBLE_TYPE;\r\n        case '[':\r\n            return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);\r\n        case 'L':\r\n            return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);\r\n        case '(':\r\n            return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptorBuffer);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods to get class names, internal names or descriptors.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the binary name of the class corresponding to this type. This method must not be used\r\n * on method types.\r\n *\r\n * @return the binary name of the class corresponding to this type.\r\n */\r\npublic String getClassName() {\r\n    switch(sort) {\r\n        case VOID:\r\n            return \"void\";\r\n        case BOOLEAN:\r\n            return \"boolean\";\r\n        case CHAR:\r\n            return \"char\";\r\n        case BYTE:\r\n            return \"byte\";\r\n        case SHORT:\r\n            return \"short\";\r\n        case INT:\r\n            return \"int\";\r\n        case FLOAT:\r\n            return \"float\";\r\n        case LONG:\r\n            return \"long\";\r\n        case DOUBLE:\r\n            return \"double\";\r\n        case ARRAY:\r\n            StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());\r\n            for (int i = getDimensions(); i > 0; --i) {\r\n                stringBuilder.append(\"[]\");\r\n            }\r\n            return stringBuilder.toString();\r\n        case OBJECT:\r\n        case INTERNAL:\r\n            return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}\n/**\r\n * Returns the internal name of the class corresponding to this object or array type. The internal\r\n * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are\r\n * replaced by '/'). This method should only be used for an object or array type.\r\n *\r\n * @return the internal name of the class corresponding to this object type.\r\n */\r\npublic String getInternalName() {\r\n    return valueBuffer.substring(valueBegin, valueEnd);\r\n}\n/**\r\n * Returns the internal name of the given class. The internal name of a class is its fully\r\n * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.\r\n *\r\n * @param clazz an object or array class.\r\n * @return the internal name of the given class.\r\n */\r\npublic static String getInternalName(final Class<?> clazz) {\r\n    return clazz.getName().replace('.', '/');\r\n}\n/**\r\n * Returns the descriptor corresponding to this type.\r\n *\r\n * @return the descriptor corresponding to this type.\r\n */\r\npublic String getDescriptor() {\r\n    if (sort == OBJECT) {\r\n        return valueBuffer.substring(valueBegin - 1, valueEnd + 1);\r\n    } else if (sort == INTERNAL) {\r\n        return 'L' + valueBuffer.substring(valueBegin, valueEnd) + ';';\r\n    } else {\r\n        return valueBuffer.substring(valueBegin, valueEnd);\r\n    }\r\n}\n/**\r\n * Returns the descriptor corresponding to the given class.\r\n *\r\n * @param clazz an object class, a primitive class or an array class.\r\n * @return the descriptor corresponding to the given class.\r\n */\r\npublic static String getDescriptor(final Class<?> clazz) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    appendDescriptor(clazz, stringBuilder);\r\n    return stringBuilder.toString();\r\n}\n/**\r\n * Returns the descriptor corresponding to the given constructor.\r\n *\r\n * @param constructor a {@link Constructor} object.\r\n * @return the descriptor of the given constructor.\r\n */\r\npublic static String getConstructorDescriptor(final Constructor<?> constructor) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    Class<?>[] parameters = constructor.getParameterTypes();\r\n    for (Class<?> parameter : parameters) {\r\n        appendDescriptor(parameter, stringBuilder);\r\n    }\r\n    return stringBuilder.append(\")V\").toString();\r\n}\n/**\r\n * Returns the descriptor corresponding to the given argument and return types.\r\n *\r\n * @param returnType the return type of the method.\r\n * @param argumentTypes the argument types of the method.\r\n * @return the descriptor corresponding to the given argument and return types.\r\n */\r\npublic static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    for (Type argumentType : argumentTypes) {\r\n        argumentType.appendDescriptor(stringBuilder);\r\n    }\r\n    stringBuilder.append(')');\r\n    returnType.appendDescriptor(stringBuilder);\r\n    return stringBuilder.toString();\r\n}\n/**\r\n * Returns the descriptor corresponding to the given method.\r\n *\r\n * @param method a {@link Method} object.\r\n * @return the descriptor of the given method.\r\n */\r\npublic static String getMethodDescriptor(final Method method) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    Class<?>[] parameters = method.getParameterTypes();\r\n    for (Class<?> parameter : parameters) {\r\n        appendDescriptor(parameter, stringBuilder);\r\n    }\r\n    stringBuilder.append(')');\r\n    appendDescriptor(method.getReturnType(), stringBuilder);\r\n    return stringBuilder.toString();\r\n}\n/**\r\n * Appends the descriptor corresponding to this type to the given string buffer.\r\n *\r\n * @param stringBuilder the string builder to which the descriptor must be appended.\r\n */\r\nprivate void appendDescriptor(final StringBuilder stringBuilder) {\r\n    if (sort == OBJECT) {\r\n        stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);\r\n    } else if (sort == INTERNAL) {\r\n        stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');\r\n    } else {\r\n        stringBuilder.append(valueBuffer, valueBegin, valueEnd);\r\n    }\r\n}\n/**\r\n * Appends the descriptor of the given class to the given string builder.\r\n *\r\n * @param clazz the class whose descriptor must be computed.\r\n * @param stringBuilder the string builder to which the descriptor must be appended.\r\n */\r\nprivate static void appendDescriptor(final Class<?> clazz, final StringBuilder stringBuilder) {\r\n    Class<?> currentClass = clazz;\r\n    while (currentClass.isArray()) {\r\n        stringBuilder.append('[');\r\n        currentClass = currentClass.componentType();\r\n    }\r\n    if (currentClass.isPrimitive()) {\r\n        char descriptor;\r\n        if (currentClass == Integer.TYPE) {\r\n            descriptor = 'I';\r\n        } else if (currentClass == Void.TYPE) {\r\n            descriptor = 'V';\r\n        } else if (currentClass == Boolean.TYPE) {\r\n            descriptor = 'Z';\r\n        } else if (currentClass == Byte.TYPE) {\r\n            descriptor = 'B';\r\n        } else if (currentClass == Character.TYPE) {\r\n            descriptor = 'C';\r\n        } else if (currentClass == Short.TYPE) {\r\n            descriptor = 'S';\r\n        } else if (currentClass == Double.TYPE) {\r\n            descriptor = 'D';\r\n        } else if (currentClass == Float.TYPE) {\r\n            descriptor = 'F';\r\n        } else if (currentClass == Long.TYPE) {\r\n            descriptor = 'J';\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n        stringBuilder.append(descriptor);\r\n    } else {\r\n        stringBuilder.append('L').append(getInternalName(currentClass)).append(';');\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the sort of this type.\r\n *\r\n * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link\r\n *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or\r\n *     {@link #METHOD}.\r\n */\r\npublic int getSort() {\r\n    return sort == INTERNAL ? OBJECT : sort;\r\n}\n/**\r\n * Returns the number of dimensions of this array type. This method should only be used for an\r\n * array type.\r\n *\r\n * @return the number of dimensions of this array type.\r\n */\r\npublic int getDimensions() {\r\n    int numDimensions = 1;\r\n    while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {\r\n        numDimensions++;\r\n    }\r\n    return numDimensions;\r\n}\n/**\r\n * Returns the size of values of this type. This method must not be used for method types.\r\n *\r\n * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\r\n *     {@code void} and 1 otherwise.\r\n */\r\npublic int getSize() {\r\n    switch(sort) {\r\n        case VOID:\r\n            return 0;\r\n        case BOOLEAN:\r\n        case CHAR:\r\n        case BYTE:\r\n        case SHORT:\r\n        case INT:\r\n        case FLOAT:\r\n        case ARRAY:\r\n        case OBJECT:\r\n        case INTERNAL:\r\n            return 1;\r\n        case LONG:\r\n        case DOUBLE:\r\n            return 2;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}\n/**\r\n * Returns the number of arguments of this method type. This method should only be used for method\r\n * types.\r\n *\r\n * @return the number of arguments of this method type. Each argument counts for 1, even long and\r\n *     double ones. The implicit @literal{this} argument is not counted.\r\n */\r\npublic int getArgumentCount() {\r\n    return getArgumentCount(getDescriptor());\r\n}\n/**\r\n * Returns the number of arguments in the given method descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the number of arguments in the given method descriptor. Each argument counts for 1,\r\n *     even long and double ones. The implicit @literal{this} argument is not counted.\r\n */\r\npublic static int getArgumentCount(final String methodDescriptor) {\r\n    int argumentCount = 0;\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    // Parse the argument types, one at a each loop iteration.\r\n    while (methodDescriptor.charAt(currentOffset) != ')') {\r\n        while (methodDescriptor.charAt(currentOffset) == '[') {\r\n            currentOffset++;\r\n        }\r\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n            // Skip the argument descriptor content.\r\n            int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n        }\r\n        ++argumentCount;\r\n    }\r\n    return argumentCount;\r\n}\n/**\r\n * Returns the size of the arguments and of the return value of methods of this type. This method\r\n * should only be used for method types.\r\n *\r\n * @return the size of the arguments of the method (plus one for the implicit this argument),\r\n *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\r\n *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\r\n *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\r\n *     the others have size 1.\r\n */\r\npublic int getArgumentsAndReturnSizes() {\r\n    return getArgumentsAndReturnSizes(getDescriptor());\r\n}\n/**\r\n * Computes the size of the arguments and of the return value of a method.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the size of the arguments of the method (plus one for the implicit this argument),\r\n *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\r\n *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\r\n *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\r\n *     the others have size 1.\r\n */\r\npublic static int getArgumentsAndReturnSizes(final String methodDescriptor) {\r\n    int argumentsSize = 1;\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    int currentChar = methodDescriptor.charAt(currentOffset);\r\n    // Parse the argument types and compute their size, one at a each loop iteration.\r\n    while (currentChar != ')') {\r\n        if (currentChar == 'J' || currentChar == 'D') {\r\n            currentOffset++;\r\n            argumentsSize += 2;\r\n        } else {\r\n            while (methodDescriptor.charAt(currentOffset) == '[') {\r\n                currentOffset++;\r\n            }\r\n            if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n                // Skip the argument descriptor content.\r\n                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n            }\r\n            argumentsSize += 1;\r\n        }\r\n        currentChar = methodDescriptor.charAt(currentOffset);\r\n    }\r\n    currentChar = methodDescriptor.charAt(currentOffset + 1);\r\n    if (currentChar == 'V') {\r\n        return argumentsSize << 2;\r\n    } else {\r\n        int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;\r\n        return argumentsSize << 2 | returnSize;\r\n    }\r\n}\n/**\r\n * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for\r\n * method types.\r\n *\r\n * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,\r\n *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and\r\n *     IRETURN.\r\n * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For\r\n *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns\r\n *     FRETURN.\r\n */\r\npublic int getOpcode(final int opcode) {\r\n    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\r\n        switch(sort) {\r\n            case BOOLEAN:\r\n            case BYTE:\r\n                return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);\r\n            case CHAR:\r\n                return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);\r\n            case SHORT:\r\n                return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);\r\n            case INT:\r\n                return opcode;\r\n            case FLOAT:\r\n                return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);\r\n            case LONG:\r\n                return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);\r\n            case DOUBLE:\r\n                return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);\r\n            case ARRAY:\r\n            case OBJECT:\r\n            case INTERNAL:\r\n                return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);\r\n            case METHOD:\r\n            case VOID:\r\n                throw new UnsupportedOperationException();\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    } else {\r\n        switch(sort) {\r\n            case VOID:\r\n                if (opcode != Opcodes.IRETURN) {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n                return Opcodes.RETURN;\r\n            case BOOLEAN:\r\n            case BYTE:\r\n            case CHAR:\r\n            case SHORT:\r\n            case INT:\r\n                return opcode;\r\n            case FLOAT:\r\n                return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);\r\n            case LONG:\r\n                return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);\r\n            case DOUBLE:\r\n                return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);\r\n            case ARRAY:\r\n            case OBJECT:\r\n            case INTERNAL:\r\n                if (opcode != Opcodes.ILOAD && opcode != Opcodes.ISTORE && opcode != Opcodes.IRETURN) {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n                return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);\r\n            case METHOD:\r\n                throw new UnsupportedOperationException();\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Equals, hashCode and toString.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Tests if the given object is equal to this type.\r\n *\r\n * @param object the object to be compared to this type.\r\n * @return {@literal true} if the given object is equal to this type.\r\n */\r\n@Override\r\npublic boolean equals(final Object object) {\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof Type)) {\r\n        return false;\r\n    }\r\n    Type other = (Type) object;\r\n    if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {\r\n        return false;\r\n    }\r\n    int begin = valueBegin;\r\n    int end = valueEnd;\r\n    int otherBegin = other.valueBegin;\r\n    int otherEnd = other.valueEnd;\r\n    // Compare the values.\r\n    if (end - begin != otherEnd - otherBegin) {\r\n        return false;\r\n    }\r\n    for (int i = begin, j = otherBegin; i < end; i++, j++) {\r\n        if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * Returns a hash code value for this type.\r\n *\r\n * @return a hash code value for this type.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);\r\n    if (sort >= ARRAY) {\r\n        for (int i = valueBegin, end = valueEnd; i < end; i++) {\r\n            hashCode = 17 * (hashCode + valueBuffer.charAt(i));\r\n        }\r\n    }\r\n    return hashCode;\r\n}\n/**\r\n * Returns a string representation of this type.\r\n *\r\n * @return the descriptor of this type.\r\n */\r\n@Override\r\npublic String toString() {\r\n    return getDescriptor();\r\n}",
    "comment": "\n * A Java field or method type. This class can be used to make it easier to manipulate type and\n * method descriptors.\n *\n * @author Eric Bruneton\n * @author Chris Nokleberg\n "
  },
  {
    "entityId": "org.springframework.asm.Type#getType(String)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the {@link Type} corresponding to the given type descriptor.\r\n *\r\n * @param typeDescriptor a field or method type descriptor.\r\n * @return the {@link Type} corresponding to the given type descriptor.\r\n */\r\npublic static Type getType(final String typeDescriptor) {\r\n    return getTypeInternal(typeDescriptor, 0, typeDescriptor.length());\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the given type descriptor.\n   *\n   * @param typeDescriptor a field or method type descriptor.\n   * @return the {@link Type} corresponding to the given type descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} corresponding to the given class.\r\n *\r\n * @param clazz a class.\r\n * @return the {@link Type} corresponding to the given class.\r\n */\r\npublic static Type getType(final Class<?> clazz) {\r\n    if (clazz.isPrimitive()) {\r\n        if (clazz == Integer.TYPE) {\r\n            return INT_TYPE;\r\n        } else if (clazz == Void.TYPE) {\r\n            return VOID_TYPE;\r\n        } else if (clazz == Boolean.TYPE) {\r\n            return BOOLEAN_TYPE;\r\n        } else if (clazz == Byte.TYPE) {\r\n            return BYTE_TYPE;\r\n        } else if (clazz == Character.TYPE) {\r\n            return CHAR_TYPE;\r\n        } else if (clazz == Short.TYPE) {\r\n            return SHORT_TYPE;\r\n        } else if (clazz == Double.TYPE) {\r\n            return DOUBLE_TYPE;\r\n        } else if (clazz == Float.TYPE) {\r\n            return FLOAT_TYPE;\r\n        } else if (clazz == Long.TYPE) {\r\n            return LONG_TYPE;\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n    } else {\r\n        return getType(getDescriptor(clazz));\r\n    }\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the given class.\n   *\n   * @param clazz a class.\n   * @return the {@link Type} corresponding to the given class.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getType(Constructor<?>)",
    "entityType": "method",
    "code": "/**\r\n * Returns the method {@link Type} corresponding to the given constructor.\r\n *\r\n * @param constructor a {@link Constructor} object.\r\n * @return the method {@link Type} corresponding to the given constructor.\r\n */\r\npublic static Type getType(final Constructor<?> constructor) {\r\n    return getType(getConstructorDescriptor(constructor));\r\n}",
    "comment": "\n   * Returns the method {@link Type} corresponding to the given constructor.\n   *\n   * @param constructor a {@link Constructor} object.\n   * @return the method {@link Type} corresponding to the given constructor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getType(Method)",
    "entityType": "method",
    "code": "/**\r\n * Returns the method {@link Type} corresponding to the given method.\r\n *\r\n * @param method a {@link Method} object.\r\n * @return the method {@link Type} corresponding to the given method.\r\n */\r\npublic static Type getType(final Method method) {\r\n    return getType(getMethodDescriptor(method));\r\n}",
    "comment": "\n   * Returns the method {@link Type} corresponding to the given method.\n   *\n   * @param method a {@link Method} object.\n   * @return the method {@link Type} corresponding to the given method.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getElementType()",
    "entityType": "method",
    "code": "/**\r\n * Returns the type of the elements of this array type. This method should only be used for an\r\n * array type.\r\n *\r\n * @return Returns the type of the elements of this array type.\r\n */\r\npublic Type getElementType() {\r\n    final int numDimensions = getDimensions();\r\n    return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);\r\n}",
    "comment": "\n   * Returns the type of the elements of this array type. This method should only be used for an\n   * array type.\n   *\n   * @return Returns the type of the elements of this array type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getObjectType(String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} corresponding to the given internal name.\r\n *\r\n * @param internalName an internal name (see {@link Type#getInternalName()}).\r\n * @return the {@link Type} corresponding to the given internal name.\r\n */\r\npublic static Type getObjectType(final String internalName) {\r\n    return new Type(internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length());\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the given internal name.\n   *\n   * @param internalName an internal name (see {@link Type#getInternalName()}).\n   * @return the {@link Type} corresponding to the given internal name.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getMethodType(String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>\r\n * Type.getType(methodDescriptor)</code>.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the {@link Type} corresponding to the given method descriptor.\r\n */\r\npublic static Type getMethodType(final String methodDescriptor) {\r\n    return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to <code>\n   * Type.getType(methodDescriptor)</code>.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the {@link Type} corresponding to the given method descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getMethodType(Type,Type)",
    "entityType": "method",
    "code": "/**\r\n * Returns the method {@link Type} corresponding to the given argument and return types.\r\n *\r\n * @param returnType the return type of the method.\r\n * @param argumentTypes the argument types of the method.\r\n * @return the method {@link Type} corresponding to the given argument and return types.\r\n */\r\npublic static Type getMethodType(final Type returnType, final Type... argumentTypes) {\r\n    return getType(getMethodDescriptor(returnType, argumentTypes));\r\n}",
    "comment": "\n   * Returns the method {@link Type} corresponding to the given argument and return types.\n   *\n   * @param returnType the return type of the method.\n   * @param argumentTypes the argument types of the method.\n   * @return the method {@link Type} corresponding to the given argument and return types.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentTypes()",
    "entityType": "method",
    "code": "/**\r\n * Returns the argument types of methods of this type. This method should only be used for method\r\n * types.\r\n *\r\n * @return the argument types of methods of this type.\r\n */\r\npublic Type[] getArgumentTypes() {\r\n    return getArgumentTypes(getDescriptor());\r\n}",
    "comment": "\n   * Returns the argument types of methods of this type. This method should only be used for method\n   * types.\n   *\n   * @return the argument types of methods of this type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentTypes(String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} values corresponding to the argument types of the given method\r\n * descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the {@link Type} values corresponding to the argument types of the given method\r\n *     descriptor.\r\n */\r\npublic static Type[] getArgumentTypes(final String methodDescriptor) {\r\n    // First step: compute the number of argument types in methodDescriptor.\r\n    int numArgumentTypes = getArgumentCount(methodDescriptor);\r\n    // Second step: create a Type instance for each argument type.\r\n    Type[] argumentTypes = new Type[numArgumentTypes];\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    // Parse and create the argument types, one at each loop iteration.\r\n    int currentArgumentTypeIndex = 0;\r\n    while (methodDescriptor.charAt(currentOffset) != ')') {\r\n        final int currentArgumentTypeOffset = currentOffset;\r\n        while (methodDescriptor.charAt(currentOffset) == '[') {\r\n            currentOffset++;\r\n        }\r\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n            // Skip the argument descriptor content.\r\n            int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n        }\r\n        argumentTypes[currentArgumentTypeIndex++] = getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);\r\n    }\r\n    return argumentTypes;\r\n}",
    "comment": "\n   * Returns the {@link Type} values corresponding to the argument types of the given method\n   * descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the {@link Type} values corresponding to the argument types of the given method\n   *     descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentTypes(Method)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} values corresponding to the argument types of the given method.\r\n *\r\n * @param method a method.\r\n * @return the {@link Type} values corresponding to the argument types of the given method.\r\n */\r\npublic static Type[] getArgumentTypes(final Method method) {\r\n    Class<?>[] classes = method.getParameterTypes();\r\n    Type[] types = new Type[classes.length];\r\n    for (int i = classes.length - 1; i >= 0; --i) {\r\n        types[i] = getType(classes[i]);\r\n    }\r\n    return types;\r\n}",
    "comment": "\n   * Returns the {@link Type} values corresponding to the argument types of the given method.\n   *\n   * @param method a method.\n   * @return the {@link Type} values corresponding to the argument types of the given method.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getReturnType()",
    "entityType": "method",
    "code": "/**\r\n * Returns the return type of methods of this type. This method should only be used for method\r\n * types.\r\n *\r\n * @return the return type of methods of this type.\r\n */\r\npublic Type getReturnType() {\r\n    return getReturnType(getDescriptor());\r\n}",
    "comment": "\n   * Returns the return type of methods of this type. This method should only be used for method\n   * types.\n   *\n   * @return the return type of methods of this type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getReturnType(String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} corresponding to the return type of the given method descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the {@link Type} corresponding to the return type of the given method descriptor.\r\n */\r\npublic static Type getReturnType(final String methodDescriptor) {\r\n    return getTypeInternal(methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the return type of the given method descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the {@link Type} corresponding to the return type of the given method descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getReturnType(Method)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} corresponding to the return type of the given method.\r\n *\r\n * @param method a method.\r\n * @return the {@link Type} corresponding to the return type of the given method.\r\n */\r\npublic static Type getReturnType(final Method method) {\r\n    return getType(method.getReturnType());\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the return type of the given method.\n   *\n   * @param method a method.\n   * @return the {@link Type} corresponding to the return type of the given method.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getReturnTypeOffset(String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the start index of the return type of the given method descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the start index of the return type of the given method descriptor.\r\n */\r\nstatic int getReturnTypeOffset(final String methodDescriptor) {\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    // Skip the argument types, one at a each loop iteration.\r\n    while (methodDescriptor.charAt(currentOffset) != ')') {\r\n        while (methodDescriptor.charAt(currentOffset) == '[') {\r\n            currentOffset++;\r\n        }\r\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n            // Skip the argument descriptor content.\r\n            int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n        }\r\n    }\r\n    return currentOffset + 1;\r\n}",
    "comment": "\n   * Returns the start index of the return type of the given method descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the start index of the return type of the given method descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getTypeInternal(String,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the {@link Type} corresponding to the given field or method descriptor.\r\n *\r\n * @param descriptorBuffer a buffer containing the field or method descriptor.\r\n * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in\r\n *     descriptorBuffer.\r\n * @param descriptorEnd the end index, exclusive, of the field or method descriptor in\r\n *     descriptorBuffer.\r\n * @return the {@link Type} corresponding to the given type descriptor.\r\n */\r\nprivate static Type getTypeInternal(final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {\r\n    switch(descriptorBuffer.charAt(descriptorBegin)) {\r\n        case 'V':\r\n            return VOID_TYPE;\r\n        case 'Z':\r\n            return BOOLEAN_TYPE;\r\n        case 'C':\r\n            return CHAR_TYPE;\r\n        case 'B':\r\n            return BYTE_TYPE;\r\n        case 'S':\r\n            return SHORT_TYPE;\r\n        case 'I':\r\n            return INT_TYPE;\r\n        case 'F':\r\n            return FLOAT_TYPE;\r\n        case 'J':\r\n            return LONG_TYPE;\r\n        case 'D':\r\n            return DOUBLE_TYPE;\r\n        case '[':\r\n            return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);\r\n        case 'L':\r\n            return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);\r\n        case '(':\r\n            return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + descriptorBuffer);\r\n    }\r\n}",
    "comment": "\n   * Returns the {@link Type} corresponding to the given field or method descriptor.\n   *\n   * @param descriptorBuffer a buffer containing the field or method descriptor.\n   * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in\n   *     descriptorBuffer.\n   * @param descriptorEnd the end index, exclusive, of the field or method descriptor in\n   *     descriptorBuffer.\n   * @return the {@link Type} corresponding to the given type descriptor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getClassName()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods to get class names, internal names or descriptors.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the binary name of the class corresponding to this type. This method must not be used\r\n * on method types.\r\n *\r\n * @return the binary name of the class corresponding to this type.\r\n */\r\npublic String getClassName() {\r\n    switch(sort) {\r\n        case VOID:\r\n            return \"void\";\r\n        case BOOLEAN:\r\n            return \"boolean\";\r\n        case CHAR:\r\n            return \"char\";\r\n        case BYTE:\r\n            return \"byte\";\r\n        case SHORT:\r\n            return \"short\";\r\n        case INT:\r\n            return \"int\";\r\n        case FLOAT:\r\n            return \"float\";\r\n        case LONG:\r\n            return \"long\";\r\n        case DOUBLE:\r\n            return \"double\";\r\n        case ARRAY:\r\n            StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());\r\n            for (int i = getDimensions(); i > 0; --i) {\r\n                stringBuilder.append(\"[]\");\r\n            }\r\n            return stringBuilder.toString();\r\n        case OBJECT:\r\n        case INTERNAL:\r\n            return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "comment": "\n   * Returns the binary name of the class corresponding to this type. This method must not be used\n   * on method types.\n   *\n   * @return the binary name of the class corresponding to this type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getInternalName()",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the class corresponding to this object or array type. The internal\r\n * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are\r\n * replaced by '/'). This method should only be used for an object or array type.\r\n *\r\n * @return the internal name of the class corresponding to this object type.\r\n */\r\npublic String getInternalName() {\r\n    return valueBuffer.substring(valueBegin, valueEnd);\r\n}",
    "comment": "\n   * Returns the internal name of the class corresponding to this object or array type. The internal\n   * name of a class is its fully qualified name (as returned by Class.getName(), where '.' are\n   * replaced by '/'). This method should only be used for an object or array type.\n   *\n   * @return the internal name of the class corresponding to this object type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getInternalName(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Returns the internal name of the given class. The internal name of a class is its fully\r\n * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.\r\n *\r\n * @param clazz an object or array class.\r\n * @return the internal name of the given class.\r\n */\r\npublic static String getInternalName(final Class<?> clazz) {\r\n    return clazz.getName().replace('.', '/');\r\n}",
    "comment": "\n   * Returns the internal name of the given class. The internal name of a class is its fully\n   * qualified name, as returned by Class.getName(), where '.' are replaced by '/'.\n   *\n   * @param clazz an object or array class.\n   * @return the internal name of the given class.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getDescriptor()",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor corresponding to this type.\r\n *\r\n * @return the descriptor corresponding to this type.\r\n */\r\npublic String getDescriptor() {\r\n    if (sort == OBJECT) {\r\n        return valueBuffer.substring(valueBegin - 1, valueEnd + 1);\r\n    } else if (sort == INTERNAL) {\r\n        return 'L' + valueBuffer.substring(valueBegin, valueEnd) + ';';\r\n    } else {\r\n        return valueBuffer.substring(valueBegin, valueEnd);\r\n    }\r\n}",
    "comment": "\n   * Returns the descriptor corresponding to this type.\n   *\n   * @return the descriptor corresponding to this type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getDescriptor(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor corresponding to the given class.\r\n *\r\n * @param clazz an object class, a primitive class or an array class.\r\n * @return the descriptor corresponding to the given class.\r\n */\r\npublic static String getDescriptor(final Class<?> clazz) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    appendDescriptor(clazz, stringBuilder);\r\n    return stringBuilder.toString();\r\n}",
    "comment": "\n   * Returns the descriptor corresponding to the given class.\n   *\n   * @param clazz an object class, a primitive class or an array class.\n   * @return the descriptor corresponding to the given class.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getConstructorDescriptor(Constructor<?>)",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor corresponding to the given constructor.\r\n *\r\n * @param constructor a {@link Constructor} object.\r\n * @return the descriptor of the given constructor.\r\n */\r\npublic static String getConstructorDescriptor(final Constructor<?> constructor) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    Class<?>[] parameters = constructor.getParameterTypes();\r\n    for (Class<?> parameter : parameters) {\r\n        appendDescriptor(parameter, stringBuilder);\r\n    }\r\n    return stringBuilder.append(\")V\").toString();\r\n}",
    "comment": "\n   * Returns the descriptor corresponding to the given constructor.\n   *\n   * @param constructor a {@link Constructor} object.\n   * @return the descriptor of the given constructor.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getMethodDescriptor(Type,Type)",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor corresponding to the given argument and return types.\r\n *\r\n * @param returnType the return type of the method.\r\n * @param argumentTypes the argument types of the method.\r\n * @return the descriptor corresponding to the given argument and return types.\r\n */\r\npublic static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    for (Type argumentType : argumentTypes) {\r\n        argumentType.appendDescriptor(stringBuilder);\r\n    }\r\n    stringBuilder.append(')');\r\n    returnType.appendDescriptor(stringBuilder);\r\n    return stringBuilder.toString();\r\n}",
    "comment": "\n   * Returns the descriptor corresponding to the given argument and return types.\n   *\n   * @param returnType the return type of the method.\n   * @param argumentTypes the argument types of the method.\n   * @return the descriptor corresponding to the given argument and return types.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getMethodDescriptor(Method)",
    "entityType": "method",
    "code": "/**\r\n * Returns the descriptor corresponding to the given method.\r\n *\r\n * @param method a {@link Method} object.\r\n * @return the descriptor of the given method.\r\n */\r\npublic static String getMethodDescriptor(final Method method) {\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append('(');\r\n    Class<?>[] parameters = method.getParameterTypes();\r\n    for (Class<?> parameter : parameters) {\r\n        appendDescriptor(parameter, stringBuilder);\r\n    }\r\n    stringBuilder.append(')');\r\n    appendDescriptor(method.getReturnType(), stringBuilder);\r\n    return stringBuilder.toString();\r\n}",
    "comment": "\n   * Returns the descriptor corresponding to the given method.\n   *\n   * @param method a {@link Method} object.\n   * @return the descriptor of the given method.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#appendDescriptor(StringBuilder)",
    "entityType": "method",
    "code": "/**\r\n * Appends the descriptor corresponding to this type to the given string buffer.\r\n *\r\n * @param stringBuilder the string builder to which the descriptor must be appended.\r\n */\r\nprivate void appendDescriptor(final StringBuilder stringBuilder) {\r\n    if (sort == OBJECT) {\r\n        stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);\r\n    } else if (sort == INTERNAL) {\r\n        stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');\r\n    } else {\r\n        stringBuilder.append(valueBuffer, valueBegin, valueEnd);\r\n    }\r\n}",
    "comment": "\n   * Appends the descriptor corresponding to this type to the given string buffer.\n   *\n   * @param stringBuilder the string builder to which the descriptor must be appended.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.CustomNullableProcessor",
    "entityType": "class",
    "code": "@org.springframework.core.testfixture.nullness.custom.Nullable\r\nString process(@org.springframework.core.testfixture.nullness.custom.Nullable String nullable);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.CustomNullableProcessor#process(String)",
    "entityType": "method",
    "code": "@org.springframework.core.testfixture.nullness.custom.Nullable\r\nString process(@org.springframework.core.testfixture.nullness.custom.Nullable String nullable);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Type#appendDescriptor(Class<?>,StringBuilder)",
    "entityType": "method",
    "code": "/**\r\n * Appends the descriptor of the given class to the given string builder.\r\n *\r\n * @param clazz the class whose descriptor must be computed.\r\n * @param stringBuilder the string builder to which the descriptor must be appended.\r\n */\r\nprivate static void appendDescriptor(final Class<?> clazz, final StringBuilder stringBuilder) {\r\n    Class<?> currentClass = clazz;\r\n    while (currentClass.isArray()) {\r\n        stringBuilder.append('[');\r\n        currentClass = currentClass.componentType();\r\n    }\r\n    if (currentClass.isPrimitive()) {\r\n        char descriptor;\r\n        if (currentClass == Integer.TYPE) {\r\n            descriptor = 'I';\r\n        } else if (currentClass == Void.TYPE) {\r\n            descriptor = 'V';\r\n        } else if (currentClass == Boolean.TYPE) {\r\n            descriptor = 'Z';\r\n        } else if (currentClass == Byte.TYPE) {\r\n            descriptor = 'B';\r\n        } else if (currentClass == Character.TYPE) {\r\n            descriptor = 'C';\r\n        } else if (currentClass == Short.TYPE) {\r\n            descriptor = 'S';\r\n        } else if (currentClass == Double.TYPE) {\r\n            descriptor = 'D';\r\n        } else if (currentClass == Float.TYPE) {\r\n            descriptor = 'F';\r\n        } else if (currentClass == Long.TYPE) {\r\n            descriptor = 'J';\r\n        } else {\r\n            throw new AssertionError();\r\n        }\r\n        stringBuilder.append(descriptor);\r\n    } else {\r\n        stringBuilder.append('L').append(getInternalName(currentClass)).append(';');\r\n    }\r\n}",
    "comment": "\n   * Appends the descriptor of the given class to the given string builder.\n   *\n   * @param clazz the class whose descriptor must be computed.\n   * @param stringBuilder the string builder to which the descriptor must be appended.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getSort()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the sort of this type.\r\n *\r\n * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link\r\n *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or\r\n *     {@link #METHOD}.\r\n */\r\npublic int getSort() {\r\n    return sort == INTERNAL ? OBJECT : sort;\r\n}",
    "comment": "\n   * Returns the sort of this type.\n   *\n   * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link\n   *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or\n   *     {@link #METHOD}.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getDimensions()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of dimensions of this array type. This method should only be used for an\r\n * array type.\r\n *\r\n * @return the number of dimensions of this array type.\r\n */\r\npublic int getDimensions() {\r\n    int numDimensions = 1;\r\n    while (valueBuffer.charAt(valueBegin + numDimensions) == '[') {\r\n        numDimensions++;\r\n    }\r\n    return numDimensions;\r\n}",
    "comment": "\n   * Returns the number of dimensions of this array type. This method should only be used for an\n   * array type.\n   *\n   * @return the number of dimensions of this array type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getSize()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size of values of this type. This method must not be used for method types.\r\n *\r\n * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\r\n *     {@code void} and 1 otherwise.\r\n */\r\npublic int getSize() {\r\n    switch(sort) {\r\n        case VOID:\r\n            return 0;\r\n        case BOOLEAN:\r\n        case CHAR:\r\n        case BYTE:\r\n        case SHORT:\r\n        case INT:\r\n        case FLOAT:\r\n        case ARRAY:\r\n        case OBJECT:\r\n        case INTERNAL:\r\n            return 1;\r\n        case LONG:\r\n        case DOUBLE:\r\n            return 2;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "comment": "\n   * Returns the size of values of this type. This method must not be used for method types.\n   *\n   * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\n   *     {@code void} and 1 otherwise.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentCount()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of arguments of this method type. This method should only be used for method\r\n * types.\r\n *\r\n * @return the number of arguments of this method type. Each argument counts for 1, even long and\r\n *     double ones. The implicit @literal{this} argument is not counted.\r\n */\r\npublic int getArgumentCount() {\r\n    return getArgumentCount(getDescriptor());\r\n}",
    "comment": "\n   * Returns the number of arguments of this method type. This method should only be used for method\n   * types.\n   *\n   * @return the number of arguments of this method type. Each argument counts for 1, even long and\n   *     double ones. The implicit @literal{this} argument is not counted.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentCount(String)",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of arguments in the given method descriptor.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the number of arguments in the given method descriptor. Each argument counts for 1,\r\n *     even long and double ones. The implicit @literal{this} argument is not counted.\r\n */\r\npublic static int getArgumentCount(final String methodDescriptor) {\r\n    int argumentCount = 0;\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    // Parse the argument types, one at a each loop iteration.\r\n    while (methodDescriptor.charAt(currentOffset) != ')') {\r\n        while (methodDescriptor.charAt(currentOffset) == '[') {\r\n            currentOffset++;\r\n        }\r\n        if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n            // Skip the argument descriptor content.\r\n            int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n            currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n        }\r\n        ++argumentCount;\r\n    }\r\n    return argumentCount;\r\n}",
    "comment": "\n   * Returns the number of arguments in the given method descriptor.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the number of arguments in the given method descriptor. Each argument counts for 1,\n   *     even long and double ones. The implicit @literal{this} argument is not counted.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentsAndReturnSizes()",
    "entityType": "method",
    "code": "/**\r\n * Returns the size of the arguments and of the return value of methods of this type. This method\r\n * should only be used for method types.\r\n *\r\n * @return the size of the arguments of the method (plus one for the implicit this argument),\r\n *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\r\n *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\r\n *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\r\n *     the others have size 1.\r\n */\r\npublic int getArgumentsAndReturnSizes() {\r\n    return getArgumentsAndReturnSizes(getDescriptor());\r\n}",
    "comment": "\n   * Returns the size of the arguments and of the return value of methods of this type. This method\n   * should only be used for method types.\n   *\n   * @return the size of the arguments of the method (plus one for the implicit this argument),\n   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\n   *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\n   *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n   *     the others have size 1.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getArgumentsAndReturnSizes(String)",
    "entityType": "method",
    "code": "/**\r\n * Computes the size of the arguments and of the return value of a method.\r\n *\r\n * @param methodDescriptor a method descriptor.\r\n * @return the size of the arguments of the method (plus one for the implicit this argument),\r\n *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\r\n *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\r\n *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\r\n *     the others have size 1.\r\n */\r\npublic static int getArgumentsAndReturnSizes(final String methodDescriptor) {\r\n    int argumentsSize = 1;\r\n    // Skip the first character, which is always a '('.\r\n    int currentOffset = 1;\r\n    int currentChar = methodDescriptor.charAt(currentOffset);\r\n    // Parse the argument types and compute their size, one at a each loop iteration.\r\n    while (currentChar != ')') {\r\n        if (currentChar == 'J' || currentChar == 'D') {\r\n            currentOffset++;\r\n            argumentsSize += 2;\r\n        } else {\r\n            while (methodDescriptor.charAt(currentOffset) == '[') {\r\n                currentOffset++;\r\n            }\r\n            if (methodDescriptor.charAt(currentOffset++) == 'L') {\r\n                // Skip the argument descriptor content.\r\n                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\r\n                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\r\n            }\r\n            argumentsSize += 1;\r\n        }\r\n        currentChar = methodDescriptor.charAt(currentOffset);\r\n    }\r\n    currentChar = methodDescriptor.charAt(currentOffset + 1);\r\n    if (currentChar == 'V') {\r\n        return argumentsSize << 2;\r\n    } else {\r\n        int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;\r\n        return argumentsSize << 2 | returnSize;\r\n    }\r\n}",
    "comment": "\n   * Computes the size of the arguments and of the return value of a method.\n   *\n   * @param methodDescriptor a method descriptor.\n   * @return the size of the arguments of the method (plus one for the implicit this argument),\n   *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =\n   *     {@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\n   *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n   *     the others have size 1.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#getOpcode(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for\r\n * method types.\r\n *\r\n * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,\r\n *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and\r\n *     IRETURN.\r\n * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For\r\n *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns\r\n *     FRETURN.\r\n */\r\npublic int getOpcode(final int opcode) {\r\n    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\r\n        switch(sort) {\r\n            case BOOLEAN:\r\n            case BYTE:\r\n                return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);\r\n            case CHAR:\r\n                return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);\r\n            case SHORT:\r\n                return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);\r\n            case INT:\r\n                return opcode;\r\n            case FLOAT:\r\n                return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);\r\n            case LONG:\r\n                return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);\r\n            case DOUBLE:\r\n                return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);\r\n            case ARRAY:\r\n            case OBJECT:\r\n            case INTERNAL:\r\n                return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);\r\n            case METHOD:\r\n            case VOID:\r\n                throw new UnsupportedOperationException();\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    } else {\r\n        switch(sort) {\r\n            case VOID:\r\n                if (opcode != Opcodes.IRETURN) {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n                return Opcodes.RETURN;\r\n            case BOOLEAN:\r\n            case BYTE:\r\n            case CHAR:\r\n            case SHORT:\r\n            case INT:\r\n                return opcode;\r\n            case FLOAT:\r\n                return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);\r\n            case LONG:\r\n                return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);\r\n            case DOUBLE:\r\n                return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);\r\n            case ARRAY:\r\n            case OBJECT:\r\n            case INTERNAL:\r\n                if (opcode != Opcodes.ILOAD && opcode != Opcodes.ISTORE && opcode != Opcodes.IRETURN) {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n                return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);\r\n            case METHOD:\r\n                throw new UnsupportedOperationException();\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    }\r\n}",
    "comment": "\n   * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for\n   * method types.\n   *\n   * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,\n   *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and\n   *     IRETURN.\n   * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For\n   *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns\n   *     FRETURN.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#equals(Object)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Equals, hashCode and toString.\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Tests if the given object is equal to this type.\r\n *\r\n * @param object the object to be compared to this type.\r\n * @return {@literal true} if the given object is equal to this type.\r\n */\r\n@Override\r\npublic boolean equals(final Object object) {\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof Type)) {\r\n        return false;\r\n    }\r\n    Type other = (Type) object;\r\n    if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {\r\n        return false;\r\n    }\r\n    int begin = valueBegin;\r\n    int end = valueEnd;\r\n    int otherBegin = other.valueBegin;\r\n    int otherEnd = other.valueEnd;\r\n    // Compare the values.\r\n    if (end - begin != otherEnd - otherBegin) {\r\n        return false;\r\n    }\r\n    for (int i = begin, j = otherBegin; i < end; i++, j++) {\r\n        if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n   * Tests if the given object is equal to this type.\n   *\n   * @param object the object to be compared to this type.\n   * @return {@literal true} if the given object is equal to this type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * Returns a hash code value for this type.\r\n *\r\n * @return a hash code value for this type.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);\r\n    if (sort >= ARRAY) {\r\n        for (int i = valueBegin, end = valueEnd; i < end; i++) {\r\n            hashCode = 17 * (hashCode + valueBuffer.charAt(i));\r\n        }\r\n    }\r\n    return hashCode;\r\n}",
    "comment": "\n   * Returns a hash code value for this type.\n   *\n   * @return a hash code value for this type.\n   "
  },
  {
    "entityId": "org.springframework.asm.Type#toString()",
    "entityType": "method",
    "code": "/**\r\n * Returns a string representation of this type.\r\n *\r\n * @return the descriptor of this type.\r\n */\r\n@Override\r\npublic String toString() {\r\n    return getDescriptor();\r\n}",
    "comment": "\n   * Returns a string representation of this type.\n   *\n   * @return the descriptor of this type.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor",
    "entityType": "class",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n@Nullable\r\nString nullableProcess();\n@NonNull\r\nString nonNullProcess();\n@NullMarked\r\nString markedProcess(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n@NullMarked\r\n@Nullable\r\nString nullableMarkedProcess();\n@NullMarked\r\n@NonNull\r\nString nonNullMarkedProcess();\nvoid voidProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#process(String,String,String)",
    "entityType": "method",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#nullableProcess()",
    "entityType": "method",
    "code": "@Nullable\r\nString nullableProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#nonNullProcess()",
    "entityType": "method",
    "code": "@NonNull\r\nString nonNullProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#markedProcess(String,String,String)",
    "entityType": "method",
    "code": "@NullMarked\r\nString markedProcess(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#nullableMarkedProcess()",
    "entityType": "method",
    "code": "@NullMarked\r\n@Nullable\r\nString nullableMarkedProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#nonNullMarkedProcess()",
    "entityType": "method",
    "code": "@NullMarked\r\n@NonNull\r\nString nonNullMarkedProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.JSpecifyProcessor#voidProcess()",
    "entityType": "method",
    "code": "void voidProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.TypePath",
    "entityType": "class",
    "code": "/**\r\n * A type path step that steps into the element type of an array type. See {@link #getStep}.\r\n */\r\npublic static final int ARRAY_ELEMENT = 0;\n/**\r\n * A type path step that steps into the nested type of a class type. See {@link #getStep}.\r\n */\r\npublic static final int INNER_TYPE = 1;\n/**\r\n * A type path step that steps into the bound of a wildcard type. See {@link #getStep}.\r\n */\r\npublic static final int WILDCARD_BOUND = 2;\n/**\r\n * A type path step that steps into a type argument of a generic type. See {@link #getStep}.\r\n */\r\npublic static final int TYPE_ARGUMENT = 3;\n/**\r\n * The byte array where the 'type_path' structure - as defined in the Java Virtual Machine\r\n * Specification (JVMS) - corresponding to this TypePath is stored. The first byte of the\r\n * structure in this array is given by {@link #typePathOffset}.\r\n *\r\n * @see <a\r\n *     href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.2\">JVMS\r\n *     4.7.20.2</a>\r\n */\r\nprivate final byte[] typePathContainer;\n/**\r\n * The offset of the first byte of the type_path JVMS structure in {@link #typePathContainer}.\r\n */\r\nprivate final int typePathOffset;\n/**\r\n * Constructs a new TypePath.\r\n *\r\n * @param typePathContainer a byte array containing a type_path JVMS structure.\r\n * @param typePathOffset the offset of the first byte of the type_path structure in\r\n *     typePathContainer.\r\n */\r\nTypePath(final byte[] typePathContainer, final int typePathOffset) {\r\n    this.typePathContainer = typePathContainer;\r\n    this.typePathOffset = typePathOffset;\r\n}\n/**\r\n * Returns the length of this path, i.e. its number of steps.\r\n *\r\n * @return the length of this path.\r\n */\r\npublic int getLength() {\r\n    // path_length is stored in the first byte of a type_path.\r\n    return typePathContainer[typePathOffset];\r\n}\n/**\r\n * Returns the value of the given step of this path.\r\n *\r\n * @param index an index between 0 and {@link #getLength()}, exclusive.\r\n * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link\r\n *     #TYPE_ARGUMENT}.\r\n */\r\npublic int getStep(final int index) {\r\n    // Returns the type_path_kind of the path element of the given index.\r\n    return typePathContainer[typePathOffset + 2 * index + 1];\r\n}\n/**\r\n * Returns the index of the type argument that the given step is stepping into. This method should\r\n * only be used for steps whose value is {@link #TYPE_ARGUMENT}.\r\n *\r\n * @param index an index between 0 and {@link #getLength()}, exclusive.\r\n * @return the index of the type argument that the given step is stepping into.\r\n */\r\npublic int getStepArgument(final int index) {\r\n    // Returns the type_argument_index of the path element of the given index.\r\n    return typePathContainer[typePathOffset + 2 * index + 2];\r\n}\n/**\r\n * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath\r\n * object.\r\n *\r\n * @param typePath a type path in string form, in the format used by {@link #toString()}. May be\r\n *     {@literal null} or empty.\r\n * @return the corresponding TypePath object, or {@literal null} if the path is empty.\r\n */\r\npublic static TypePath fromString(final String typePath) {\r\n    if (typePath == null || typePath.length() == 0) {\r\n        return null;\r\n    }\r\n    int typePathLength = typePath.length();\r\n    ByteVector output = new ByteVector(typePathLength);\r\n    output.putByte(0);\r\n    int typePathIndex = 0;\r\n    while (typePathIndex < typePathLength) {\r\n        char c = typePath.charAt(typePathIndex++);\r\n        if (c == '[') {\r\n            output.put11(ARRAY_ELEMENT, 0);\r\n        } else if (c == '.') {\r\n            output.put11(INNER_TYPE, 0);\r\n        } else if (c == '*') {\r\n            output.put11(WILDCARD_BOUND, 0);\r\n        } else if (c >= '0' && c <= '9') {\r\n            int typeArg = c - '0';\r\n            while (typePathIndex < typePathLength) {\r\n                c = typePath.charAt(typePathIndex++);\r\n                if (c >= '0' && c <= '9') {\r\n                    typeArg = typeArg * 10 + c - '0';\r\n                } else if (c == ';') {\r\n                    break;\r\n                } else {\r\n                    throw new IllegalArgumentException();\r\n                }\r\n            }\r\n            output.put11(TYPE_ARGUMENT, typeArg);\r\n        } else {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    }\r\n    output.data[0] = (byte) (output.length / 2);\r\n    return new TypePath(output.data, 0);\r\n}\n/**\r\n * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented\r\n * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link\r\n * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by ';'.\r\n */\r\n@Override\r\npublic String toString() {\r\n    int length = getLength();\r\n    StringBuilder result = new StringBuilder(length * 2);\r\n    for (int i = 0; i < length; ++i) {\r\n        switch(getStep(i)) {\r\n            case ARRAY_ELEMENT:\r\n                result.append('[');\r\n                break;\r\n            case INNER_TYPE:\r\n                result.append('.');\r\n                break;\r\n            case WILDCARD_BOUND:\r\n                result.append('*');\r\n                break;\r\n            case TYPE_ARGUMENT:\r\n                result.append(getStepArgument(i)).append(';');\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    }\r\n    return result.toString();\r\n}\n/**\r\n * Puts the type_path JVMS structure corresponding to the given TypePath into the given\r\n * ByteVector.\r\n *\r\n * @param typePath a TypePath instance, or {@literal null} for empty paths.\r\n * @param output where the type path must be put.\r\n */\r\nstatic void put(final TypePath typePath, final ByteVector output) {\r\n    if (typePath == null) {\r\n        output.putByte(0);\r\n    } else {\r\n        int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1;\r\n        output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length);\r\n    }\r\n}",
    "comment": "\n * The path to a type argument, wildcard bound, array element type, or static inner type within an\n * enclosing type.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.TypePath#getLength()",
    "entityType": "method",
    "code": "/**\r\n * Returns the length of this path, i.e. its number of steps.\r\n *\r\n * @return the length of this path.\r\n */\r\npublic int getLength() {\r\n    // path_length is stored in the first byte of a type_path.\r\n    return typePathContainer[typePathOffset];\r\n}",
    "comment": "\n   * Returns the length of this path, i.e. its number of steps.\n   *\n   * @return the length of this path.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypePath#getStep(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the value of the given step of this path.\r\n *\r\n * @param index an index between 0 and {@link #getLength()}, exclusive.\r\n * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link\r\n *     #TYPE_ARGUMENT}.\r\n */\r\npublic int getStep(final int index) {\r\n    // Returns the type_path_kind of the path element of the given index.\r\n    return typePathContainer[typePathOffset + 2 * index + 1];\r\n}",
    "comment": "\n   * Returns the value of the given step of this path.\n   *\n   * @param index an index between 0 and {@link #getLength()}, exclusive.\n   * @return one of {@link #ARRAY_ELEMENT}, {@link #INNER_TYPE}, {@link #WILDCARD_BOUND}, or {@link\n   *     #TYPE_ARGUMENT}.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypePath#getStepArgument(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the type argument that the given step is stepping into. This method should\r\n * only be used for steps whose value is {@link #TYPE_ARGUMENT}.\r\n *\r\n * @param index an index between 0 and {@link #getLength()}, exclusive.\r\n * @return the index of the type argument that the given step is stepping into.\r\n */\r\npublic int getStepArgument(final int index) {\r\n    // Returns the type_argument_index of the path element of the given index.\r\n    return typePathContainer[typePathOffset + 2 * index + 2];\r\n}",
    "comment": "\n   * Returns the index of the type argument that the given step is stepping into. This method should\n   * only be used for steps whose value is {@link #TYPE_ARGUMENT}.\n   *\n   * @param index an index between 0 and {@link #getLength()}, exclusive.\n   * @return the index of the type argument that the given step is stepping into.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypePath#fromString(String)",
    "entityType": "method",
    "code": "/**\r\n * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath\r\n * object.\r\n *\r\n * @param typePath a type path in string form, in the format used by {@link #toString()}. May be\r\n *     {@literal null} or empty.\r\n * @return the corresponding TypePath object, or {@literal null} if the path is empty.\r\n */\r\npublic static TypePath fromString(final String typePath) {\r\n    if (typePath == null || typePath.length() == 0) {\r\n        return null;\r\n    }\r\n    int typePathLength = typePath.length();\r\n    ByteVector output = new ByteVector(typePathLength);\r\n    output.putByte(0);\r\n    int typePathIndex = 0;\r\n    while (typePathIndex < typePathLength) {\r\n        char c = typePath.charAt(typePathIndex++);\r\n        if (c == '[') {\r\n            output.put11(ARRAY_ELEMENT, 0);\r\n        } else if (c == '.') {\r\n            output.put11(INNER_TYPE, 0);\r\n        } else if (c == '*') {\r\n            output.put11(WILDCARD_BOUND, 0);\r\n        } else if (c >= '0' && c <= '9') {\r\n            int typeArg = c - '0';\r\n            while (typePathIndex < typePathLength) {\r\n                c = typePath.charAt(typePathIndex++);\r\n                if (c >= '0' && c <= '9') {\r\n                    typeArg = typeArg * 10 + c - '0';\r\n                } else if (c == ';') {\r\n                    break;\r\n                } else {\r\n                    throw new IllegalArgumentException();\r\n                }\r\n            }\r\n            output.put11(TYPE_ARGUMENT, typeArg);\r\n        } else {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    }\r\n    output.data[0] = (byte) (output.length / 2);\r\n    return new TypePath(output.data, 0);\r\n}",
    "comment": "\n   * Converts a type path in string form, in the format used by {@link #toString()}, into a TypePath\n   * object.\n   *\n   * @param typePath a type path in string form, in the format used by {@link #toString()}. May be\n   *     {@literal null} or empty.\n   * @return the corresponding TypePath object, or {@literal null} if the path is empty.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypePath#toString()",
    "entityType": "method",
    "code": "/**\r\n * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented\r\n * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link\r\n * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by ';'.\r\n */\r\n@Override\r\npublic String toString() {\r\n    int length = getLength();\r\n    StringBuilder result = new StringBuilder(length * 2);\r\n    for (int i = 0; i < length; ++i) {\r\n        switch(getStep(i)) {\r\n            case ARRAY_ELEMENT:\r\n                result.append('[');\r\n                break;\r\n            case INNER_TYPE:\r\n                result.append('.');\r\n                break;\r\n            case WILDCARD_BOUND:\r\n                result.append('*');\r\n                break;\r\n            case TYPE_ARGUMENT:\r\n                result.append(getStepArgument(i)).append(';');\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    }\r\n    return result.toString();\r\n}",
    "comment": "\n   * Returns a string representation of this type path. {@link #ARRAY_ELEMENT} steps are represented\n   * with '[', {@link #INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND} steps with '*' and {@link\n   * #TYPE_ARGUMENT} steps with their type argument index in decimal form followed by ';'.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypePath#put(TypePath,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the type_path JVMS structure corresponding to the given TypePath into the given\r\n * ByteVector.\r\n *\r\n * @param typePath a TypePath instance, or {@literal null} for empty paths.\r\n * @param output where the type path must be put.\r\n */\r\nstatic void put(final TypePath typePath, final ByteVector output) {\r\n    if (typePath == null) {\r\n        output.putByte(0);\r\n    } else {\r\n        int length = typePath.typePathContainer[typePath.typePathOffset] * 2 + 1;\r\n        output.putByteArray(typePath.typePathContainer, typePath.typePathOffset, length);\r\n    }\r\n}",
    "comment": "\n   * Puts the type_path JVMS structure corresponding to the given TypePath into the given\n   * ByteVector.\n   *\n   * @param typePath a TypePath instance, or {@literal null} for empty paths.\n   * @param output where the type path must be put.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.PackageMarkedJSpecifyProcessor",
    "entityType": "class",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n@Nullable\r\nString nullableProcess();\n@NonNull\r\nString nonNullProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.PackageMarkedJSpecifyProcessor#process(String,String,String)",
    "entityType": "method",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.PackageMarkedJSpecifyProcessor#nullableProcess()",
    "entityType": "method",
    "code": "@Nullable\r\nString nullableProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.PackageMarkedJSpecifyProcessor#nonNullProcess()",
    "entityType": "method",
    "code": "@NonNull\r\nString nonNullProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.TypeReference",
    "entityType": "class",
    "code": "/**\r\n * The sort of type references that target a type parameter of a generic class. See {@link\r\n * #getSort}.\r\n */\r\npublic static final int CLASS_TYPE_PARAMETER = 0x00;\n/**\r\n * The sort of type references that target a type parameter of a generic method. See {@link\r\n * #getSort}.\r\n */\r\npublic static final int METHOD_TYPE_PARAMETER = 0x01;\n/**\r\n * The sort of type references that target the super class of a class or one of the interfaces it\r\n * implements. See {@link #getSort}.\r\n */\r\npublic static final int CLASS_EXTENDS = 0x10;\n/**\r\n * The sort of type references that target a bound of a type parameter of a generic class. See\r\n * {@link #getSort}.\r\n */\r\npublic static final int CLASS_TYPE_PARAMETER_BOUND = 0x11;\n/**\r\n * The sort of type references that target a bound of a type parameter of a generic method. See\r\n * {@link #getSort}.\r\n */\r\npublic static final int METHOD_TYPE_PARAMETER_BOUND = 0x12;\n/**\r\n * The sort of type references that target the type of a field. See {@link #getSort}.\r\n */\r\npublic static final int FIELD = 0x13;\n/**\r\n * The sort of type references that target the return type of a method. See {@link #getSort}.\r\n */\r\npublic static final int METHOD_RETURN = 0x14;\n/**\r\n * The sort of type references that target the receiver type of a method. See {@link #getSort}.\r\n */\r\npublic static final int METHOD_RECEIVER = 0x15;\n/**\r\n * The sort of type references that target the type of a formal parameter of a method. See {@link\r\n * #getSort}.\r\n */\r\npublic static final int METHOD_FORMAL_PARAMETER = 0x16;\n/**\r\n * The sort of type references that target the type of an exception declared in the throws clause\r\n * of a method. See {@link #getSort}.\r\n */\r\npublic static final int THROWS = 0x17;\n/**\r\n * The sort of type references that target the type of a local variable in a method. See {@link\r\n * #getSort}.\r\n */\r\npublic static final int LOCAL_VARIABLE = 0x40;\n/**\r\n * The sort of type references that target the type of a resource variable in a method. See {@link\r\n * #getSort}.\r\n */\r\npublic static final int RESOURCE_VARIABLE = 0x41;\n/**\r\n * The sort of type references that target the type of the exception of a 'catch' clause in a\r\n * method. See {@link #getSort}.\r\n */\r\npublic static final int EXCEPTION_PARAMETER = 0x42;\n/**\r\n * The sort of type references that target the type declared in an 'instanceof' instruction. See\r\n * {@link #getSort}.\r\n */\r\npublic static final int INSTANCEOF = 0x43;\n/**\r\n * The sort of type references that target the type of the object created by a 'new' instruction.\r\n * See {@link #getSort}.\r\n */\r\npublic static final int NEW = 0x44;\n/**\r\n * The sort of type references that target the receiver type of a constructor reference. See\r\n * {@link #getSort}.\r\n */\r\npublic static final int CONSTRUCTOR_REFERENCE = 0x45;\n/**\r\n * The sort of type references that target the receiver type of a method reference. See {@link\r\n * #getSort}.\r\n */\r\npublic static final int METHOD_REFERENCE = 0x46;\n/**\r\n * The sort of type references that target the type declared in an explicit or implicit cast\r\n * instruction. See {@link #getSort}.\r\n */\r\npublic static final int CAST = 0x47;\n/**\r\n * The sort of type references that target a type parameter of a generic constructor in a\r\n * constructor call. See {@link #getSort}.\r\n */\r\npublic static final int CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;\n/**\r\n * The sort of type references that target a type parameter of a generic method in a method call.\r\n * See {@link #getSort}.\r\n */\r\npublic static final int METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;\n/**\r\n * The sort of type references that target a type parameter of a generic constructor in a\r\n * constructor reference. See {@link #getSort}.\r\n */\r\npublic static final int CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;\n/**\r\n * The sort of type references that target a type parameter of a generic method in a method\r\n * reference. See {@link #getSort}.\r\n */\r\npublic static final int METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;\n/**\r\n * The target_type and target_info structures - as defined in the Java Virtual Machine\r\n * Specification (JVMS) - corresponding to this type reference. target_type uses one byte, and all\r\n * the target_info union fields use up to 3 bytes (except localvar_target, handled with the\r\n * specific method {@link MethodVisitor#visitLocalVariableAnnotation}). Thus, both structures can\r\n * be stored in an int.\r\n *\r\n * <p>This int field stores target_type (called the TypeReference 'sort' in the public API of this\r\n * class) in its most significant byte, followed by the target_info fields. Depending on\r\n * target_type, 1, 2 or even 3 least significant bytes of this field are unused. target_info\r\n * fields which reference bytecode offsets are set to 0 (these offsets are ignored in ClassReader,\r\n * and recomputed in MethodWriter).\r\n *\r\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20\">JVMS\r\n *     4.7.20</a>\r\n * @see <a\r\n *     href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1\">JVMS\r\n *     4.7.20.1</a>\r\n */\r\nprivate final int targetTypeAndInfo;\n/**\r\n * Constructs a new TypeReference.\r\n *\r\n * @param typeRef the int encoded value of the type reference, as received in a visit method\r\n *     related to type annotations, such as {@link ClassVisitor#visitTypeAnnotation}.\r\n */\r\npublic TypeReference(final int typeRef) {\r\n    this.targetTypeAndInfo = typeRef;\r\n}\n/**\r\n * Returns a type reference of the given sort.\r\n *\r\n * @param sort one of {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link\r\n *     #LOCAL_VARIABLE}, {@link #RESOURCE_VARIABLE}, {@link #INSTANCEOF}, {@link #NEW}, {@link\r\n *     #CONSTRUCTOR_REFERENCE}, or {@link #METHOD_REFERENCE}.\r\n * @return a type reference of the given sort.\r\n */\r\npublic static TypeReference newTypeReference(final int sort) {\r\n    return new TypeReference(sort << 24);\r\n}\n/**\r\n * Returns a reference to a type parameter of a generic class or method.\r\n *\r\n * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.\r\n * @param paramIndex the type parameter index.\r\n * @return a reference to the given generic class or method type parameter.\r\n */\r\npublic static TypeReference newTypeParameterReference(final int sort, final int paramIndex) {\r\n    return new TypeReference((sort << 24) | (paramIndex << 16));\r\n}\n/**\r\n * Returns a reference to a type parameter bound of a generic class or method.\r\n *\r\n * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.\r\n * @param paramIndex the type parameter index.\r\n * @param boundIndex the type bound index within the above type parameters.\r\n * @return a reference to the given generic class or method type parameter bound.\r\n */\r\npublic static TypeReference newTypeParameterBoundReference(final int sort, final int paramIndex, final int boundIndex) {\r\n    return new TypeReference((sort << 24) | (paramIndex << 16) | (boundIndex << 8));\r\n}\n/**\r\n * Returns a reference to the super class or to an interface of the 'implements' clause of a\r\n * class.\r\n *\r\n * @param itfIndex the index of an interface in the 'implements' clause of a class, or -1 to\r\n *     reference the super class of the class.\r\n * @return a reference to the given super type of a class.\r\n */\r\npublic static TypeReference newSuperTypeReference(final int itfIndex) {\r\n    return new TypeReference((CLASS_EXTENDS << 24) | ((itfIndex & 0xFFFF) << 8));\r\n}\n/**\r\n * Returns a reference to the type of a formal parameter of a method.\r\n *\r\n * @param paramIndex the formal parameter index.\r\n * @return a reference to the type of the given method formal parameter.\r\n */\r\npublic static TypeReference newFormalParameterReference(final int paramIndex) {\r\n    return new TypeReference((METHOD_FORMAL_PARAMETER << 24) | (paramIndex << 16));\r\n}\n/**\r\n * Returns a reference to the type of an exception, in a 'throws' clause of a method.\r\n *\r\n * @param exceptionIndex the index of an exception in a 'throws' clause of a method.\r\n * @return a reference to the type of the given exception.\r\n */\r\npublic static TypeReference newExceptionReference(final int exceptionIndex) {\r\n    return new TypeReference((THROWS << 24) | (exceptionIndex << 8));\r\n}\n/**\r\n * Returns a reference to the type of the exception declared in a 'catch' clause of a method.\r\n *\r\n * @param tryCatchBlockIndex the index of a try catch block (using the order in which they are\r\n *     visited with visitTryCatchBlock).\r\n * @return a reference to the type of the given exception.\r\n */\r\npublic static TypeReference newTryCatchReference(final int tryCatchBlockIndex) {\r\n    return new TypeReference((EXCEPTION_PARAMETER << 24) | (tryCatchBlockIndex << 8));\r\n}\n/**\r\n * Returns a reference to the type of a type argument in a constructor or method call or\r\n * reference.\r\n *\r\n * @param sort one of {@link #CAST}, {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\r\n *     #METHOD_REFERENCE_TYPE_ARGUMENT}.\r\n * @param argIndex the type argument index.\r\n * @return a reference to the type of the given type argument.\r\n */\r\npublic static TypeReference newTypeArgumentReference(final int sort, final int argIndex) {\r\n    return new TypeReference((sort << 24) | argIndex);\r\n}\n/**\r\n * Returns the sort of this type reference.\r\n *\r\n * @return one of {@link #CLASS_TYPE_PARAMETER}, {@link #METHOD_TYPE_PARAMETER}, {@link\r\n *     #CLASS_EXTENDS}, {@link #CLASS_TYPE_PARAMETER_BOUND}, {@link #METHOD_TYPE_PARAMETER_BOUND},\r\n *     {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link\r\n *     #METHOD_FORMAL_PARAMETER}, {@link #THROWS}, {@link #LOCAL_VARIABLE}, {@link\r\n *     #RESOURCE_VARIABLE}, {@link #EXCEPTION_PARAMETER}, {@link #INSTANCEOF}, {@link #NEW},\r\n *     {@link #CONSTRUCTOR_REFERENCE}, {@link #METHOD_REFERENCE}, {@link #CAST}, {@link\r\n *     #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.\r\n */\r\npublic int getSort() {\r\n    return targetTypeAndInfo >>> 24;\r\n}\n/**\r\n * Returns the index of the type parameter referenced by this type reference. This method must\r\n * only be used for type references whose sort is {@link #CLASS_TYPE_PARAMETER}, {@link\r\n * #METHOD_TYPE_PARAMETER}, {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link\r\n * #METHOD_TYPE_PARAMETER_BOUND}.\r\n *\r\n * @return a type parameter index.\r\n */\r\npublic int getTypeParameterIndex() {\r\n    return (targetTypeAndInfo & 0x00FF0000) >> 16;\r\n}\n/**\r\n * Returns the index of the type parameter bound, within the type parameter {@link\r\n * #getTypeParameterIndex}, referenced by this type reference. This method must only be used for\r\n * type references whose sort is {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link\r\n * #METHOD_TYPE_PARAMETER_BOUND}.\r\n *\r\n * @return a type parameter bound index.\r\n */\r\npublic int getTypeParameterBoundIndex() {\r\n    return (targetTypeAndInfo & 0x0000FF00) >> 8;\r\n}\n/**\r\n * Returns the index of the \"super type\" of a class that is referenced by this type reference.\r\n * This method must only be used for type references whose sort is {@link #CLASS_EXTENDS}.\r\n *\r\n * @return the index of an interface in the 'implements' clause of a class, or -1 if this type\r\n *     reference references the type of the super class.\r\n */\r\npublic int getSuperTypeIndex() {\r\n    return (short) ((targetTypeAndInfo & 0x00FFFF00) >> 8);\r\n}\n/**\r\n * Returns the index of the formal parameter whose type is referenced by this type reference. This\r\n * method must only be used for type references whose sort is {@link #METHOD_FORMAL_PARAMETER}.\r\n *\r\n * @return a formal parameter index.\r\n */\r\npublic int getFormalParameterIndex() {\r\n    return (targetTypeAndInfo & 0x00FF0000) >> 16;\r\n}\n/**\r\n * Returns the index of the exception, in a 'throws' clause of a method, whose type is referenced\r\n * by this type reference. This method must only be used for type references whose sort is {@link\r\n * #THROWS}.\r\n *\r\n * @return the index of an exception in the 'throws' clause of a method.\r\n */\r\npublic int getExceptionIndex() {\r\n    return (targetTypeAndInfo & 0x00FFFF00) >> 8;\r\n}\n/**\r\n * Returns the index of the try catch block (using the order in which they are visited with\r\n * visitTryCatchBlock), whose 'catch' type is referenced by this type reference. This method must\r\n * only be used for type references whose sort is {@link #EXCEPTION_PARAMETER} .\r\n *\r\n * @return the index of an exception in the 'throws' clause of a method.\r\n */\r\npublic int getTryCatchBlockIndex() {\r\n    return (targetTypeAndInfo & 0x00FFFF00) >> 8;\r\n}\n/**\r\n * Returns the index of the type argument referenced by this type reference. This method must only\r\n * be used for type references whose sort is {@link #CAST}, {@link\r\n * #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\r\n * #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.\r\n *\r\n * @return a type parameter index.\r\n */\r\npublic int getTypeArgumentIndex() {\r\n    return targetTypeAndInfo & 0xFF;\r\n}\n/**\r\n * Returns the int encoded value of this type reference, suitable for use in visit methods related\r\n * to type annotations, like visitTypeAnnotation.\r\n *\r\n * @return the int encoded value of this type reference.\r\n */\r\npublic int getValue() {\r\n    return targetTypeAndInfo;\r\n}\n/**\r\n * Puts the given target_type and target_info JVMS structures into the given ByteVector.\r\n *\r\n * @param targetTypeAndInfo a target_type and a target_info structures encoded as in {@link\r\n *     #targetTypeAndInfo}. LOCAL_VARIABLE and RESOURCE_VARIABLE target types are not supported.\r\n * @param output where the type reference must be put.\r\n */\r\nstatic void putTarget(final int targetTypeAndInfo, final ByteVector output) {\r\n    switch(targetTypeAndInfo >>> 24) {\r\n        case CLASS_TYPE_PARAMETER:\r\n        case METHOD_TYPE_PARAMETER:\r\n        case METHOD_FORMAL_PARAMETER:\r\n            output.putShort(targetTypeAndInfo >>> 16);\r\n            break;\r\n        case FIELD:\r\n        case METHOD_RETURN:\r\n        case METHOD_RECEIVER:\r\n            output.putByte(targetTypeAndInfo >>> 24);\r\n            break;\r\n        case CAST:\r\n        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n        case METHOD_INVOCATION_TYPE_ARGUMENT:\r\n        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n        case METHOD_REFERENCE_TYPE_ARGUMENT:\r\n            output.putInt(targetTypeAndInfo);\r\n            break;\r\n        case CLASS_EXTENDS:\r\n        case CLASS_TYPE_PARAMETER_BOUND:\r\n        case METHOD_TYPE_PARAMETER_BOUND:\r\n        case THROWS:\r\n        case EXCEPTION_PARAMETER:\r\n        case INSTANCEOF:\r\n        case NEW:\r\n        case CONSTRUCTOR_REFERENCE:\r\n        case METHOD_REFERENCE:\r\n            output.put12(targetTypeAndInfo >>> 24, (targetTypeAndInfo & 0xFFFF00) >> 8);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "comment": "\n * A reference to a type appearing in a class, field or method declaration, or on an instruction.\n * Such a reference designates the part of the class where the referenced type is appearing (for example, an\n * 'extends', 'implements' or 'throws' clause, a 'new' instruction, a 'catch' clause, a type cast, a\n * local variable declaration, etc).\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newTypeReference(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a type reference of the given sort.\r\n *\r\n * @param sort one of {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link\r\n *     #LOCAL_VARIABLE}, {@link #RESOURCE_VARIABLE}, {@link #INSTANCEOF}, {@link #NEW}, {@link\r\n *     #CONSTRUCTOR_REFERENCE}, or {@link #METHOD_REFERENCE}.\r\n * @return a type reference of the given sort.\r\n */\r\npublic static TypeReference newTypeReference(final int sort) {\r\n    return new TypeReference(sort << 24);\r\n}",
    "comment": "\n   * Returns a type reference of the given sort.\n   *\n   * @param sort one of {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link\n   *     #LOCAL_VARIABLE}, {@link #RESOURCE_VARIABLE}, {@link #INSTANCEOF}, {@link #NEW}, {@link\n   *     #CONSTRUCTOR_REFERENCE}, or {@link #METHOD_REFERENCE}.\n   * @return a type reference of the given sort.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newTypeParameterReference(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to a type parameter of a generic class or method.\r\n *\r\n * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.\r\n * @param paramIndex the type parameter index.\r\n * @return a reference to the given generic class or method type parameter.\r\n */\r\npublic static TypeReference newTypeParameterReference(final int sort, final int paramIndex) {\r\n    return new TypeReference((sort << 24) | (paramIndex << 16));\r\n}",
    "comment": "\n   * Returns a reference to a type parameter of a generic class or method.\n   *\n   * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.\n   * @param paramIndex the type parameter index.\n   * @return a reference to the given generic class or method type parameter.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newTypeParameterBoundReference(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to a type parameter bound of a generic class or method.\r\n *\r\n * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.\r\n * @param paramIndex the type parameter index.\r\n * @param boundIndex the type bound index within the above type parameters.\r\n * @return a reference to the given generic class or method type parameter bound.\r\n */\r\npublic static TypeReference newTypeParameterBoundReference(final int sort, final int paramIndex, final int boundIndex) {\r\n    return new TypeReference((sort << 24) | (paramIndex << 16) | (boundIndex << 8));\r\n}",
    "comment": "\n   * Returns a reference to a type parameter bound of a generic class or method.\n   *\n   * @param sort one of {@link #CLASS_TYPE_PARAMETER} or {@link #METHOD_TYPE_PARAMETER}.\n   * @param paramIndex the type parameter index.\n   * @param boundIndex the type bound index within the above type parameters.\n   * @return a reference to the given generic class or method type parameter bound.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newSuperTypeReference(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to the super class or to an interface of the 'implements' clause of a\r\n * class.\r\n *\r\n * @param itfIndex the index of an interface in the 'implements' clause of a class, or -1 to\r\n *     reference the super class of the class.\r\n * @return a reference to the given super type of a class.\r\n */\r\npublic static TypeReference newSuperTypeReference(final int itfIndex) {\r\n    return new TypeReference((CLASS_EXTENDS << 24) | ((itfIndex & 0xFFFF) << 8));\r\n}",
    "comment": "\n   * Returns a reference to the super class or to an interface of the 'implements' clause of a\n   * class.\n   *\n   * @param itfIndex the index of an interface in the 'implements' clause of a class, or -1 to\n   *     reference the super class of the class.\n   * @return a reference to the given super type of a class.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newFormalParameterReference(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to the type of a formal parameter of a method.\r\n *\r\n * @param paramIndex the formal parameter index.\r\n * @return a reference to the type of the given method formal parameter.\r\n */\r\npublic static TypeReference newFormalParameterReference(final int paramIndex) {\r\n    return new TypeReference((METHOD_FORMAL_PARAMETER << 24) | (paramIndex << 16));\r\n}",
    "comment": "\n   * Returns a reference to the type of a formal parameter of a method.\n   *\n   * @param paramIndex the formal parameter index.\n   * @return a reference to the type of the given method formal parameter.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newExceptionReference(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to the type of an exception, in a 'throws' clause of a method.\r\n *\r\n * @param exceptionIndex the index of an exception in a 'throws' clause of a method.\r\n * @return a reference to the type of the given exception.\r\n */\r\npublic static TypeReference newExceptionReference(final int exceptionIndex) {\r\n    return new TypeReference((THROWS << 24) | (exceptionIndex << 8));\r\n}",
    "comment": "\n   * Returns a reference to the type of an exception, in a 'throws' clause of a method.\n   *\n   * @param exceptionIndex the index of an exception in a 'throws' clause of a method.\n   * @return a reference to the type of the given exception.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newTryCatchReference(int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to the type of the exception declared in a 'catch' clause of a method.\r\n *\r\n * @param tryCatchBlockIndex the index of a try catch block (using the order in which they are\r\n *     visited with visitTryCatchBlock).\r\n * @return a reference to the type of the given exception.\r\n */\r\npublic static TypeReference newTryCatchReference(final int tryCatchBlockIndex) {\r\n    return new TypeReference((EXCEPTION_PARAMETER << 24) | (tryCatchBlockIndex << 8));\r\n}",
    "comment": "\n   * Returns a reference to the type of the exception declared in a 'catch' clause of a method.\n   *\n   * @param tryCatchBlockIndex the index of a try catch block (using the order in which they are\n   *     visited with visitTryCatchBlock).\n   * @return a reference to the type of the given exception.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#newTypeArgumentReference(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns a reference to the type of a type argument in a constructor or method call or\r\n * reference.\r\n *\r\n * @param sort one of {@link #CAST}, {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\r\n *     #METHOD_REFERENCE_TYPE_ARGUMENT}.\r\n * @param argIndex the type argument index.\r\n * @return a reference to the type of the given type argument.\r\n */\r\npublic static TypeReference newTypeArgumentReference(final int sort, final int argIndex) {\r\n    return new TypeReference((sort << 24) | argIndex);\r\n}",
    "comment": "\n   * Returns a reference to the type of a type argument in a constructor or method call or\n   * reference.\n   *\n   * @param sort one of {@link #CAST}, {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n   *     #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n   *     #METHOD_REFERENCE_TYPE_ARGUMENT}.\n   * @param argIndex the type argument index.\n   * @return a reference to the type of the given type argument.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getSort()",
    "entityType": "method",
    "code": "/**\r\n * Returns the sort of this type reference.\r\n *\r\n * @return one of {@link #CLASS_TYPE_PARAMETER}, {@link #METHOD_TYPE_PARAMETER}, {@link\r\n *     #CLASS_EXTENDS}, {@link #CLASS_TYPE_PARAMETER_BOUND}, {@link #METHOD_TYPE_PARAMETER_BOUND},\r\n *     {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link\r\n *     #METHOD_FORMAL_PARAMETER}, {@link #THROWS}, {@link #LOCAL_VARIABLE}, {@link\r\n *     #RESOURCE_VARIABLE}, {@link #EXCEPTION_PARAMETER}, {@link #INSTANCEOF}, {@link #NEW},\r\n *     {@link #CONSTRUCTOR_REFERENCE}, {@link #METHOD_REFERENCE}, {@link #CAST}, {@link\r\n *     #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\r\n *     #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.\r\n */\r\npublic int getSort() {\r\n    return targetTypeAndInfo >>> 24;\r\n}",
    "comment": "\n   * Returns the sort of this type reference.\n   *\n   * @return one of {@link #CLASS_TYPE_PARAMETER}, {@link #METHOD_TYPE_PARAMETER}, {@link\n   *     #CLASS_EXTENDS}, {@link #CLASS_TYPE_PARAMETER_BOUND}, {@link #METHOD_TYPE_PARAMETER_BOUND},\n   *     {@link #FIELD}, {@link #METHOD_RETURN}, {@link #METHOD_RECEIVER}, {@link\n   *     #METHOD_FORMAL_PARAMETER}, {@link #THROWS}, {@link #LOCAL_VARIABLE}, {@link\n   *     #RESOURCE_VARIABLE}, {@link #EXCEPTION_PARAMETER}, {@link #INSTANCEOF}, {@link #NEW},\n   *     {@link #CONSTRUCTOR_REFERENCE}, {@link #METHOD_REFERENCE}, {@link #CAST}, {@link\n   *     #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n   *     #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getTypeParameterIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the type parameter referenced by this type reference. This method must\r\n * only be used for type references whose sort is {@link #CLASS_TYPE_PARAMETER}, {@link\r\n * #METHOD_TYPE_PARAMETER}, {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link\r\n * #METHOD_TYPE_PARAMETER_BOUND}.\r\n *\r\n * @return a type parameter index.\r\n */\r\npublic int getTypeParameterIndex() {\r\n    return (targetTypeAndInfo & 0x00FF0000) >> 16;\r\n}",
    "comment": "\n   * Returns the index of the type parameter referenced by this type reference. This method must\n   * only be used for type references whose sort is {@link #CLASS_TYPE_PARAMETER}, {@link\n   * #METHOD_TYPE_PARAMETER}, {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link\n   * #METHOD_TYPE_PARAMETER_BOUND}.\n   *\n   * @return a type parameter index.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getTypeParameterBoundIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the type parameter bound, within the type parameter {@link\r\n * #getTypeParameterIndex}, referenced by this type reference. This method must only be used for\r\n * type references whose sort is {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link\r\n * #METHOD_TYPE_PARAMETER_BOUND}.\r\n *\r\n * @return a type parameter bound index.\r\n */\r\npublic int getTypeParameterBoundIndex() {\r\n    return (targetTypeAndInfo & 0x0000FF00) >> 8;\r\n}",
    "comment": "\n   * Returns the index of the type parameter bound, within the type parameter {@link\n   * #getTypeParameterIndex}, referenced by this type reference. This method must only be used for\n   * type references whose sort is {@link #CLASS_TYPE_PARAMETER_BOUND} or {@link\n   * #METHOD_TYPE_PARAMETER_BOUND}.\n   *\n   * @return a type parameter bound index.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getSuperTypeIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the \"super type\" of a class that is referenced by this type reference.\r\n * This method must only be used for type references whose sort is {@link #CLASS_EXTENDS}.\r\n *\r\n * @return the index of an interface in the 'implements' clause of a class, or -1 if this type\r\n *     reference references the type of the super class.\r\n */\r\npublic int getSuperTypeIndex() {\r\n    return (short) ((targetTypeAndInfo & 0x00FFFF00) >> 8);\r\n}",
    "comment": "\n   * Returns the index of the \"super type\" of a class that is referenced by this type reference.\n   * This method must only be used for type references whose sort is {@link #CLASS_EXTENDS}.\n   *\n   * @return the index of an interface in the 'implements' clause of a class, or -1 if this type\n   *     reference references the type of the super class.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getFormalParameterIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the formal parameter whose type is referenced by this type reference. This\r\n * method must only be used for type references whose sort is {@link #METHOD_FORMAL_PARAMETER}.\r\n *\r\n * @return a formal parameter index.\r\n */\r\npublic int getFormalParameterIndex() {\r\n    return (targetTypeAndInfo & 0x00FF0000) >> 16;\r\n}",
    "comment": "\n   * Returns the index of the formal parameter whose type is referenced by this type reference. This\n   * method must only be used for type references whose sort is {@link #METHOD_FORMAL_PARAMETER}.\n   *\n   * @return a formal parameter index.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getExceptionIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the exception, in a 'throws' clause of a method, whose type is referenced\r\n * by this type reference. This method must only be used for type references whose sort is {@link\r\n * #THROWS}.\r\n *\r\n * @return the index of an exception in the 'throws' clause of a method.\r\n */\r\npublic int getExceptionIndex() {\r\n    return (targetTypeAndInfo & 0x00FFFF00) >> 8;\r\n}",
    "comment": "\n   * Returns the index of the exception, in a 'throws' clause of a method, whose type is referenced\n   * by this type reference. This method must only be used for type references whose sort is {@link\n   * #THROWS}.\n   *\n   * @return the index of an exception in the 'throws' clause of a method.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getTryCatchBlockIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the try catch block (using the order in which they are visited with\r\n * visitTryCatchBlock), whose 'catch' type is referenced by this type reference. This method must\r\n * only be used for type references whose sort is {@link #EXCEPTION_PARAMETER} .\r\n *\r\n * @return the index of an exception in the 'throws' clause of a method.\r\n */\r\npublic int getTryCatchBlockIndex() {\r\n    return (targetTypeAndInfo & 0x00FFFF00) >> 8;\r\n}",
    "comment": "\n   * Returns the index of the try catch block (using the order in which they are visited with\n   * visitTryCatchBlock), whose 'catch' type is referenced by this type reference. This method must\n   * only be used for type references whose sort is {@link #EXCEPTION_PARAMETER} .\n   *\n   * @return the index of an exception in the 'throws' clause of a method.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getTypeArgumentIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the index of the type argument referenced by this type reference. This method must only\r\n * be used for type references whose sort is {@link #CAST}, {@link\r\n * #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\r\n * #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.\r\n *\r\n * @return a type parameter index.\r\n */\r\npublic int getTypeArgumentIndex() {\r\n    return targetTypeAndInfo & 0xFF;\r\n}",
    "comment": "\n   * Returns the index of the type argument referenced by this type reference. This method must only\n   * be used for type references whose sort is {@link #CAST}, {@link\n   * #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link #METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n   * #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link #METHOD_REFERENCE_TYPE_ARGUMENT}.\n   *\n   * @return a type parameter index.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#getValue()",
    "entityType": "method",
    "code": "/**\r\n * Returns the int encoded value of this type reference, suitable for use in visit methods related\r\n * to type annotations, like visitTypeAnnotation.\r\n *\r\n * @return the int encoded value of this type reference.\r\n */\r\npublic int getValue() {\r\n    return targetTypeAndInfo;\r\n}",
    "comment": "\n   * Returns the int encoded value of this type reference, suitable for use in visit methods related\n   * to type annotations, like visitTypeAnnotation.\n   *\n   * @return the int encoded value of this type reference.\n   "
  },
  {
    "entityId": "org.springframework.asm.TypeReference#putTarget(int,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the given target_type and target_info JVMS structures into the given ByteVector.\r\n *\r\n * @param targetTypeAndInfo a target_type and a target_info structures encoded as in {@link\r\n *     #targetTypeAndInfo}. LOCAL_VARIABLE and RESOURCE_VARIABLE target types are not supported.\r\n * @param output where the type reference must be put.\r\n */\r\nstatic void putTarget(final int targetTypeAndInfo, final ByteVector output) {\r\n    switch(targetTypeAndInfo >>> 24) {\r\n        case CLASS_TYPE_PARAMETER:\r\n        case METHOD_TYPE_PARAMETER:\r\n        case METHOD_FORMAL_PARAMETER:\r\n            output.putShort(targetTypeAndInfo >>> 16);\r\n            break;\r\n        case FIELD:\r\n        case METHOD_RETURN:\r\n        case METHOD_RECEIVER:\r\n            output.putByte(targetTypeAndInfo >>> 24);\r\n            break;\r\n        case CAST:\r\n        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\r\n        case METHOD_INVOCATION_TYPE_ARGUMENT:\r\n        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\r\n        case METHOD_REFERENCE_TYPE_ARGUMENT:\r\n            output.putInt(targetTypeAndInfo);\r\n            break;\r\n        case CLASS_EXTENDS:\r\n        case CLASS_TYPE_PARAMETER_BOUND:\r\n        case METHOD_TYPE_PARAMETER_BOUND:\r\n        case THROWS:\r\n        case EXCEPTION_PARAMETER:\r\n        case INSTANCEOF:\r\n        case NEW:\r\n        case CONSTRUCTOR_REFERENCE:\r\n        case METHOD_REFERENCE:\r\n            output.put12(targetTypeAndInfo >>> 24, (targetTypeAndInfo & 0xFFFF00) >> 8);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}",
    "comment": "\n   * Puts the given target_type and target_info JVMS structures into the given ByteVector.\n   *\n   * @param targetTypeAndInfo a target_type and a target_info structures encoded as in {@link\n   *     #targetTypeAndInfo}. LOCAL_VARIABLE and RESOURCE_VARIABLE target types are not supported.\n   * @param output where the type reference must be put.\n   "
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.unmarked.PackageUnmarkedJSpecifyProcessor",
    "entityType": "class",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);\n@Nullable\r\nString nullableProcess();\n@NonNull\r\nString nonNullProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.unmarked.PackageUnmarkedJSpecifyProcessor#process(String,String,String)",
    "entityType": "method",
    "code": "String process(String unspecified, @Nullable String nullable, @NonNull String nonNull);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.unmarked.PackageUnmarkedJSpecifyProcessor#nullableProcess()",
    "entityType": "method",
    "code": "@Nullable\r\nString nullableProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.marked.unmarked.PackageUnmarkedJSpecifyProcessor#nonNullProcess()",
    "entityType": "method",
    "code": "@NonNull\r\nString nonNullProcess();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanCopier",
    "entityType": "class",
    "code": "private static final BeanCopierKey KEY_FACTORY = (BeanCopierKey) KeyFactory.create(BeanCopierKey.class);\nprivate static final Type CONVERTER = TypeUtils.parseType(\"org.springframework.cglib.core.Converter\");\nprivate static final Type BEAN_COPIER = TypeUtils.parseType(\"org.springframework.cglib.beans.BeanCopier\");\nprivate static final Signature COPY = new Signature(\"copy\", Type.VOID_TYPE, new Type[] { Constants.TYPE_OBJECT, Constants.TYPE_OBJECT, CONVERTER });\nprivate static final Signature CONVERT = TypeUtils.parseSignature(\"Object convert(Object, Class, Object)\");\ninterface BeanCopierKey {\r\n\r\n    public Object newInstance(String source, String target, boolean useConverter);\r\n}\npublic static BeanCopier create(Class source, Class target, boolean useConverter) {\r\n    Generator gen = new Generator();\r\n    gen.setSource(source);\r\n    gen.setTarget(target);\r\n    gen.setUseConverter(useConverter);\r\n    return gen.create();\r\n}\nabstract public void copy(Object from, Object to, Converter converter);\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(BeanCopier.class.getName());\r\n\r\n    private Class source;\r\n\r\n    private Class target;\r\n\r\n    private boolean useConverter;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    public void setSource(Class source) {\r\n        this.source = source;\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(source);\r\n        setNamePrefix(source.getName());\r\n        // SPRING PATCH END\r\n    }\r\n\r\n    public void setTarget(Class target) {\r\n        this.target = target;\r\n        // SPRING PATCH BEGIN\r\n        setContextClass(target);\r\n        setNamePrefix(target.getName());\r\n        // SPRING PATCH END\r\n    }\r\n\r\n    public void setUseConverter(boolean useConverter) {\r\n        this.useConverter = useConverter;\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return source.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(source);\r\n    }\r\n\r\n    public BeanCopier create() {\r\n        Object key = KEY_FACTORY.newInstance(source.getName(), target.getName(), useConverter);\r\n        return (BeanCopier) super.create(key);\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) {\r\n        Type sourceType = Type.getType(source);\r\n        Type targetType = Type.getType(target);\r\n        ClassEmitter ce = new ClassEmitter(v);\r\n        ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), BEAN_COPIER, null, Constants.SOURCE_FILE);\r\n        EmitUtils.null_constructor(ce);\r\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);\r\n        PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);\r\n        PropertyDescriptor[] setters = ReflectUtils.getBeanSetters(target);\r\n        Map names = new HashMap();\r\n        for (PropertyDescriptor getter : getters) {\r\n            names.put(getter.getName(), getter);\r\n        }\r\n        Local targetLocal = e.make_local();\r\n        Local sourceLocal = e.make_local();\r\n        if (useConverter) {\r\n            e.load_arg(1);\r\n            e.checkcast(targetType);\r\n            e.store_local(targetLocal);\r\n            e.load_arg(0);\r\n            e.checkcast(sourceType);\r\n            e.store_local(sourceLocal);\r\n        } else {\r\n            e.load_arg(1);\r\n            e.checkcast(targetType);\r\n            e.load_arg(0);\r\n            e.checkcast(sourceType);\r\n        }\r\n        for (PropertyDescriptor setter : setters) {\r\n            PropertyDescriptor getter = (PropertyDescriptor) names.get(setter.getName());\r\n            if (getter != null) {\r\n                MethodInfo read = ReflectUtils.getMethodInfo(getter.getReadMethod());\r\n                MethodInfo write = ReflectUtils.getMethodInfo(setter.getWriteMethod());\r\n                if (useConverter) {\r\n                    Type setterType = write.getSignature().getArgumentTypes()[0];\r\n                    e.load_local(targetLocal);\r\n                    e.load_arg(2);\r\n                    e.load_local(sourceLocal);\r\n                    e.invoke(read);\r\n                    e.box(read.getSignature().getReturnType());\r\n                    EmitUtils.load_class(e, setterType);\r\n                    e.push(write.getSignature().getName());\r\n                    e.invoke_interface(CONVERTER, CONVERT);\r\n                    e.unbox_or_zero(setterType);\r\n                    e.invoke(write);\r\n                } else if (compatible(getter, setter)) {\r\n                    e.dup2();\r\n                    e.invoke(read);\r\n                    e.invoke(write);\r\n                }\r\n            }\r\n        }\r\n        e.return_value();\r\n        e.end_method();\r\n        ce.end_class();\r\n    }\r\n\r\n    private static boolean compatible(PropertyDescriptor getter, PropertyDescriptor setter) {\r\n        // TODO: allow automatic widening conversions?\r\n        return setter.getPropertyType().isAssignableFrom(getter.getPropertyType());\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ReflectUtils.newInstance(type);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return instance;\r\n    }\r\n}",
    "comment": "\n * @author Chris Nokleberg\n "
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanCopier#create(Class,Class,boolean)",
    "entityType": "method",
    "code": "public static BeanCopier create(Class source, Class target, boolean useConverter) {\r\n    Generator gen = new Generator();\r\n    gen.setSource(source);\r\n    gen.setTarget(target);\r\n    gen.setUseConverter(useConverter);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanCopier#copy(Object,Object,Converter)",
    "entityType": "method",
    "code": "abstract public void copy(Object from, Object to, Converter converter);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanCopierKey",
    "entityType": "class",
    "code": "public Object newInstance(String source, String target, boolean useConverter);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanCopierKey#newInstance(String,String,boolean)",
    "entityType": "method",
    "code": "public Object newInstance(String source, String target, boolean useConverter);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(BeanCopier.class.getName());\nprivate Class source;\nprivate Class target;\nprivate boolean useConverter;\npublic Generator() {\r\n    super(SOURCE);\r\n}\npublic void setSource(Class source) {\r\n    this.source = source;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(source);\r\n    setNamePrefix(source.getName());\r\n    // SPRING PATCH END\r\n}\npublic void setTarget(Class target) {\r\n    this.target = target;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(target);\r\n    setNamePrefix(target.getName());\r\n    // SPRING PATCH END\r\n}\npublic void setUseConverter(boolean useConverter) {\r\n    this.useConverter = useConverter;\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return source.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(source);\r\n}\npublic BeanCopier create() {\r\n    Object key = KEY_FACTORY.newInstance(source.getName(), target.getName(), useConverter);\r\n    return (BeanCopier) super.create(key);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) {\r\n    Type sourceType = Type.getType(source);\r\n    Type targetType = Type.getType(target);\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), BEAN_COPIER, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(ce);\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);\r\n    PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);\r\n    PropertyDescriptor[] setters = ReflectUtils.getBeanSetters(target);\r\n    Map names = new HashMap();\r\n    for (PropertyDescriptor getter : getters) {\r\n        names.put(getter.getName(), getter);\r\n    }\r\n    Local targetLocal = e.make_local();\r\n    Local sourceLocal = e.make_local();\r\n    if (useConverter) {\r\n        e.load_arg(1);\r\n        e.checkcast(targetType);\r\n        e.store_local(targetLocal);\r\n        e.load_arg(0);\r\n        e.checkcast(sourceType);\r\n        e.store_local(sourceLocal);\r\n    } else {\r\n        e.load_arg(1);\r\n        e.checkcast(targetType);\r\n        e.load_arg(0);\r\n        e.checkcast(sourceType);\r\n    }\r\n    for (PropertyDescriptor setter : setters) {\r\n        PropertyDescriptor getter = (PropertyDescriptor) names.get(setter.getName());\r\n        if (getter != null) {\r\n            MethodInfo read = ReflectUtils.getMethodInfo(getter.getReadMethod());\r\n            MethodInfo write = ReflectUtils.getMethodInfo(setter.getWriteMethod());\r\n            if (useConverter) {\r\n                Type setterType = write.getSignature().getArgumentTypes()[0];\r\n                e.load_local(targetLocal);\r\n                e.load_arg(2);\r\n                e.load_local(sourceLocal);\r\n                e.invoke(read);\r\n                e.box(read.getSignature().getReturnType());\r\n                EmitUtils.load_class(e, setterType);\r\n                e.push(write.getSignature().getName());\r\n                e.invoke_interface(CONVERTER, CONVERT);\r\n                e.unbox_or_zero(setterType);\r\n                e.invoke(write);\r\n            } else if (compatible(getter, setter)) {\r\n                e.dup2();\r\n                e.invoke(read);\r\n                e.invoke(write);\r\n            }\r\n        }\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}\nprivate static boolean compatible(PropertyDescriptor getter, PropertyDescriptor setter) {\r\n    // TODO: allow automatic widening conversions?\r\n    return setter.getPropertyType().isAssignableFrom(getter.getPropertyType());\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setSource(Class)",
    "entityType": "method",
    "code": "public void setSource(Class source) {\r\n    this.source = source;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(source);\r\n    setNamePrefix(source.getName());\r\n    // SPRING PATCH END\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setTarget(Class)",
    "entityType": "method",
    "code": "public void setTarget(Class target) {\r\n    this.target = target;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(target);\r\n    setNamePrefix(target.getName());\r\n    // SPRING PATCH END\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#setUseConverter(boolean)",
    "entityType": "method",
    "code": "public void setUseConverter(boolean useConverter) {\r\n    this.useConverter = useConverter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return source.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(source);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#create()",
    "entityType": "method",
    "code": "public BeanCopier create() {\r\n    Object key = KEY_FACTORY.newInstance(source.getName(), target.getName(), useConverter);\r\n    return (BeanCopier) super.create(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) {\r\n    Type sourceType = Type.getType(source);\r\n    Type targetType = Type.getType(target);\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), BEAN_COPIER, null, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(ce);\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);\r\n    PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);\r\n    PropertyDescriptor[] setters = ReflectUtils.getBeanSetters(target);\r\n    Map names = new HashMap();\r\n    for (PropertyDescriptor getter : getters) {\r\n        names.put(getter.getName(), getter);\r\n    }\r\n    Local targetLocal = e.make_local();\r\n    Local sourceLocal = e.make_local();\r\n    if (useConverter) {\r\n        e.load_arg(1);\r\n        e.checkcast(targetType);\r\n        e.store_local(targetLocal);\r\n        e.load_arg(0);\r\n        e.checkcast(sourceType);\r\n        e.store_local(sourceLocal);\r\n    } else {\r\n        e.load_arg(1);\r\n        e.checkcast(targetType);\r\n        e.load_arg(0);\r\n        e.checkcast(sourceType);\r\n    }\r\n    for (PropertyDescriptor setter : setters) {\r\n        PropertyDescriptor getter = (PropertyDescriptor) names.get(setter.getName());\r\n        if (getter != null) {\r\n            MethodInfo read = ReflectUtils.getMethodInfo(getter.getReadMethod());\r\n            MethodInfo write = ReflectUtils.getMethodInfo(setter.getWriteMethod());\r\n            if (useConverter) {\r\n                Type setterType = write.getSignature().getArgumentTypes()[0];\r\n                e.load_local(targetLocal);\r\n                e.load_arg(2);\r\n                e.load_local(sourceLocal);\r\n                e.invoke(read);\r\n                e.box(read.getSignature().getReturnType());\r\n                EmitUtils.load_class(e, setterType);\r\n                e.push(write.getSignature().getName());\r\n                e.invoke_interface(CONVERTER, CONVERT);\r\n                e.unbox_or_zero(setterType);\r\n                e.invoke(write);\r\n            } else if (compatible(getter, setter)) {\r\n                e.dup2();\r\n                e.invoke(read);\r\n                e.invoke(write);\r\n            }\r\n        }\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#compatible(PropertyDescriptor,PropertyDescriptor)",
    "entityType": "method",
    "code": "private static boolean compatible(PropertyDescriptor getter, PropertyDescriptor setter) {\r\n    // TODO: allow automatic widening conversions?\r\n    return setter.getPropertyType().isAssignableFrom(getter.getPropertyType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.testfixture.nullness.NullnessFields",
    "entityType": "class",
    "code": "public String unannotatedField = \"\";\n@org.jspecify.annotations.Nullable\r\npublic String jspecifyNullableField;\n@org.jspecify.annotations.NonNull\r\npublic String jspecifyNonNullField = \"\";\n@org.springframework.core.testfixture.nullness.custom.Nullable\r\npublic String customNullableField;\npublic int primitiveField = 0;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.beans.BeanGenerator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(BeanGenerator.class.getName());\nprivate static final BeanGeneratorKey KEY_FACTORY = (BeanGeneratorKey) KeyFactory.create(BeanGeneratorKey.class);\ninterface BeanGeneratorKey {\r\n\r\n    public Object newInstance(String superclass, Map props);\r\n}\nprivate Class superclass;\nprivate Map props = new HashMap();\nprivate boolean classOnly;\npublic BeanGenerator() {\r\n    super(SOURCE);\r\n}\n/**\r\n * Set the class which the generated class will extend. The class\r\n * must not be declared as final, and must have a non-private\r\n * no-argument constructor.\r\n * @param superclass class to extend, or null to extend Object\r\n */\r\npublic void setSuperclass(Class superclass) {\r\n    if (superclass != null && superclass.equals(Object.class)) {\r\n        superclass = null;\r\n    }\r\n    this.superclass = superclass;\r\n    // SPRING PATCH BEGIN\r\n    setContextClass(superclass);\r\n    // SPRING PATCH END\r\n}\npublic void addProperty(String name, Class type) {\r\n    if (props.containsKey(name)) {\r\n        throw new IllegalArgumentException(\"Duplicate property name \\\"\" + name + \"\\\"\");\r\n    }\r\n    props.put(name, Type.getType(type));\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    if (superclass != null) {\r\n        return superclass.getClassLoader();\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(superclass);\r\n}\npublic Object create() {\r\n    classOnly = false;\r\n    return createHelper();\r\n}\npublic Object createClass() {\r\n    classOnly = true;\r\n    return createHelper();\r\n}\nprivate Object createHelper() {\r\n    if (superclass != null) {\r\n        setNamePrefix(superclass.getName());\r\n    }\r\n    String superName = (superclass != null) ? superclass.getName() : \"java.lang.Object\";\r\n    Object key = KEY_FACTORY.newInstance(superName, props);\r\n    return super.create(key);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    int size = props.size();\r\n    String[] names = (String[]) props.keySet().toArray(new String[size]);\r\n    Type[] types = new Type[size];\r\n    for (int i = 0; i < size; i++) {\r\n        types[i] = (Type) props.get(names[i]);\r\n    }\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), superclass != null ? Type.getType(superclass) : Constants.TYPE_OBJECT, null, null);\r\n    EmitUtils.null_constructor(ce);\r\n    EmitUtils.add_properties(ce, names, types);\r\n    ce.end_class();\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    if (classOnly) {\r\n        return type;\r\n    } else {\r\n        return ReflectUtils.newInstance(type);\r\n    }\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    Class protoclass = (instance instanceof Class<?> clazz) ? clazz : instance.getClass();\r\n    if (classOnly) {\r\n        return protoclass;\r\n    } else {\r\n        return ReflectUtils.newInstance(protoclass);\r\n    }\r\n}\npublic static void addProperties(BeanGenerator gen, Map props) {\r\n    for (Iterator it = props.keySet().iterator(); it.hasNext(); ) {\r\n        String name = (String) it.next();\r\n        gen.addProperty(name, (Class) props.get(name));\r\n    }\r\n}\npublic static void addProperties(BeanGenerator gen, Class type) {\r\n    addProperties(gen, ReflectUtils.getBeanProperties(type));\r\n}\npublic static void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors) {\r\n    for (PropertyDescriptor descriptor : descriptors) {\r\n        gen.addProperty(descriptor.getName(), descriptor.getPropertyType());\r\n    }\r\n}",
    "comment": "\n * @author Juozas Baliuka, Chris Nokleberg\n "
  }
]