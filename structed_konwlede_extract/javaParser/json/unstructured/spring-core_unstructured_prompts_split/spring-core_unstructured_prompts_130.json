[
  {
    "entityId": "org.springframework.core.PrioritizedParameterNameDiscovererTests",
    "entityType": "class",
    "code": "private static final String[] FOO_BAR = new String[] { \"foo\", \"bar\" };\nprivate static final String[] SOMETHING_ELSE = new String[] { \"something\", \"else\" };\nprivate final ParameterNameDiscoverer returnsFooBar = new ParameterNameDiscoverer() {\r\n\r\n    @Override\r\n    public String[] getParameterNames(Method m) {\r\n        return FOO_BAR;\r\n    }\r\n\r\n    @Override\r\n    public String[] getParameterNames(Constructor<?> ctor) {\r\n        return FOO_BAR;\r\n    }\r\n};\nprivate final ParameterNameDiscoverer returnsSomethingElse = new ParameterNameDiscoverer() {\r\n\r\n    @Override\r\n    public String[] getParameterNames(Method m) {\r\n        return SOMETHING_ELSE;\r\n    }\r\n\r\n    @Override\r\n    public String[] getParameterNames(Constructor<?> ctor) {\r\n        return SOMETHING_ELSE;\r\n    }\r\n};\nprivate final Method anyMethod;\npublic PrioritizedParameterNameDiscovererTests() throws SecurityException, NoSuchMethodException {\r\n    anyMethod = TestObject.class.getMethod(\"getAge\");\r\n}\n@Test\r\nvoid noParametersDiscoverers() {\r\n    ParameterNameDiscoverer pnd = new PrioritizedParameterNameDiscoverer();\r\n    assertThat(pnd.getParameterNames(anyMethod)).isNull();\r\n    assertThat(pnd.getParameterNames((Constructor<?>) null)).isNull();\r\n}\n@Test\r\nvoid orderedParameterDiscoverers1() {\r\n    PrioritizedParameterNameDiscoverer pnd = new PrioritizedParameterNameDiscoverer();\r\n    pnd.addDiscoverer(returnsFooBar);\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n    pnd.addDiscoverer(returnsSomethingElse);\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n}\n@Test\r\nvoid orderedParameterDiscoverers2() {\r\n    PrioritizedParameterNameDiscoverer pnd = new PrioritizedParameterNameDiscoverer();\r\n    pnd.addDiscoverer(returnsSomethingElse);\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n    pnd.addDiscoverer(returnsFooBar);\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.PrioritizedParameterNameDiscovererTests#noParametersDiscoverers()",
    "entityType": "method",
    "code": "@Test\r\nvoid noParametersDiscoverers() {\r\n    ParameterNameDiscoverer pnd = new PrioritizedParameterNameDiscoverer();\r\n    assertThat(pnd.getParameterNames(anyMethod)).isNull();\r\n    assertThat(pnd.getParameterNames((Constructor<?>) null)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.PrioritizedParameterNameDiscovererTests#orderedParameterDiscoverers1()",
    "entityType": "method",
    "code": "@Test\r\nvoid orderedParameterDiscoverers1() {\r\n    PrioritizedParameterNameDiscoverer pnd = new PrioritizedParameterNameDiscoverer();\r\n    pnd.addDiscoverer(returnsFooBar);\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n    pnd.addDiscoverer(returnsSomethingElse);\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(FOO_BAR, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.PrioritizedParameterNameDiscovererTests#orderedParameterDiscoverers2()",
    "entityType": "method",
    "code": "@Test\r\nvoid orderedParameterDiscoverers2() {\r\n    PrioritizedParameterNameDiscoverer pnd = new PrioritizedParameterNameDiscoverer();\r\n    pnd.addDiscoverer(returnsSomethingElse);\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n    pnd.addDiscoverer(returnsFooBar);\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames(anyMethod))).isTrue();\r\n    assertThat(Arrays.equals(SOMETHING_ELSE, pnd.getParameterNames((Constructor<?>) null))).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistryTests",
    "entityType": "class",
    "code": "private static final Duration FIVE_SECONDS = Duration.ofSeconds(5);\nprivate final ReactiveAdapterRegistry registry = ReactiveAdapterRegistry.getSharedInstance();\n@Test\r\nvoid getAdapterForReactiveSubType() {\r\n    ReactiveAdapter adapter1 = getAdapter(Flux.class);\r\n    ReactiveAdapter adapter2 = getAdapter(ExtendedFlux.class);\r\n    assertThat(adapter2).isSameAs(adapter1);\r\n    // Register regular reactive type (after existing adapters)\r\n    this.registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(ExtendedFlux.class, ExtendedFlux::empty), o -> (ExtendedFlux<?>) o, ExtendedFlux::from);\r\n    // Matches for ExtendedFlux itself\r\n    ReactiveAdapter adapter3 = getAdapter(ExtendedFlux.class);\r\n    assertThat(adapter3).isNotNull();\r\n    assertThat(adapter3).isNotSameAs(adapter1);\r\n    // Does not match for ExtendedFlux subclass since the default Flux adapter\r\n    // is being assignability-checked first when no specific match was found\r\n    ReactiveAdapter adapter4 = getAdapter(ExtendedExtendedFlux.class);\r\n    assertThat(adapter4).isSameAs(adapter1);\r\n    // Register reactive type override (before existing adapters)\r\n    this.registry.registerReactiveTypeOverride(ReactiveTypeDescriptor.multiValue(Flux.class, ExtendedFlux::empty), o -> (ExtendedFlux<?>) o, ExtendedFlux::from);\r\n    // Override match for Flux\r\n    ReactiveAdapter adapter5 = getAdapter(Flux.class);\r\n    assertThat(adapter5).isNotNull();\r\n    assertThat(adapter5).isNotSameAs(adapter1);\r\n    // Initially registered adapter specifically matches for ExtendedFlux\r\n    ReactiveAdapter adapter6 = getAdapter(ExtendedFlux.class);\r\n    assertThat(adapter6).isSameAs(adapter3);\r\n    // Override match for ExtendedFlux subclass\r\n    ReactiveAdapter adapter7 = getAdapter(ExtendedExtendedFlux.class);\r\n    assertThat(adapter7).isSameAs(adapter5);\r\n}\nprivate ReactiveAdapter getAdapter(Class<?> reactiveType) {\r\n    ReactiveAdapter adapter = this.registry.getAdapter(reactiveType);\r\n    assertThat(adapter).isNotNull();\r\n    return adapter;\r\n}\nprivate static class ExtendedFlux<T> extends Flux<T> {\r\n\r\n    @Override\r\n    public void subscribe(CoreSubscriber<? super T> actual) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\nprivate static class ExtendedExtendedFlux<T> extends ExtendedFlux<T> {\r\n}\n@Nested\r\nclass Reactor {\r\n\r\n    @Test\r\n    void defaultAdapterRegistrations() {\r\n        // Reactor\r\n        assertThat(getAdapter(Mono.class)).isNotNull();\r\n        assertThat(getAdapter(Flux.class)).isNotNull();\r\n        // Publisher\r\n        assertThat(getAdapter(Publisher.class)).isNotNull();\r\n        // Completable\r\n        assertThat(getAdapter(CompletableFuture.class)).isNotNull();\r\n    }\r\n\r\n    @Test\r\n    void toFlux() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n        Object target = getAdapter(Flux.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(Flux.class);\r\n        assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void toMono() {\r\n        Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromArray(1, 2, 3);\r\n        Object target = getAdapter(Mono.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(Mono.class);\r\n        assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n    }\r\n\r\n    @Test\r\n    void toFlowPublisher() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n        Object target = getAdapter(Flow.Publisher.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(Flow.Publisher.class);\r\n        assertThat(JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void toCompletableFuture() throws Exception {\r\n        Publisher<Integer> source = Flux.fromArray(new Integer[] { 1, 2, 3 });\r\n        Object target = getAdapter(CompletableFuture.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(CompletableFuture.class);\r\n        assertThat(((CompletableFuture<Integer>) target).get()).isEqualTo(Integer.valueOf(1));\r\n    }\r\n\r\n    @Test\r\n    void fromCompletableFuture() {\r\n        CompletableFuture<Integer> future = new CompletableFuture<>();\r\n        future.complete(1);\r\n        Object target = getAdapter(CompletableFuture.class).toPublisher(future);\r\n        assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n        assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n    }\r\n}\n@Nested\r\nclass RxJava3 {\r\n\r\n    @Test\r\n    void defaultAdapterRegistrations() {\r\n        // RxJava 3\r\n        assertThat(getAdapter(io.reactivex.rxjava3.core.Flowable.class)).isNotNull();\r\n        assertThat(getAdapter(io.reactivex.rxjava3.core.Observable.class)).isNotNull();\r\n        assertThat(getAdapter(io.reactivex.rxjava3.core.Single.class)).isNotNull();\r\n        assertThat(getAdapter(io.reactivex.rxjava3.core.Maybe.class)).isNotNull();\r\n        assertThat(getAdapter(io.reactivex.rxjava3.core.Completable.class)).isNotNull();\r\n    }\r\n\r\n    @Test\r\n    void toFlowable() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Publisher<Integer> source = Flux.fromIterable(sequence);\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Flowable.class);\r\n        assertThat(((io.reactivex.rxjava3.core.Flowable<?>) target).toList().blockingGet()).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void toObservable() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Publisher<Integer> source = Flux.fromIterable(sequence);\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Observable.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Observable.class);\r\n        assertThat(((io.reactivex.rxjava3.core.Observable<?>) target).toList().blockingGet()).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void toSingle() {\r\n        Publisher<Integer> source = Flux.fromArray(new Integer[] { 1 });\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Single.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Single.class);\r\n        assertThat(((io.reactivex.rxjava3.core.Single<Integer>) target).blockingGet()).isEqualTo(Integer.valueOf(1));\r\n    }\r\n\r\n    @Test\r\n    void toCompletable() {\r\n        Publisher<Integer> source = Flux.fromArray(new Integer[] { 1, 2, 3 });\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Completable.class);\r\n        ((io.reactivex.rxjava3.core.Completable) target).blockingAwait();\r\n    }\r\n\r\n    @Test\r\n    void fromFlowable() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Object source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).toPublisher(source);\r\n        assertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\r\n        assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void fromObservable() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Object source = io.reactivex.rxjava3.core.Observable.fromIterable(sequence);\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Observable.class).toPublisher(source);\r\n        assertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\r\n        assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void fromSingle() {\r\n        Object source = io.reactivex.rxjava3.core.Single.just(1);\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Single.class).toPublisher(source);\r\n        assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n        assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n    }\r\n\r\n    @Test\r\n    void fromCompletable() {\r\n        Object source = io.reactivex.rxjava3.core.Completable.complete();\r\n        Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).toPublisher(source);\r\n        assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n        ((Mono<Void>) target).block(FIVE_SECONDS);\r\n    }\r\n}\n@Nested\r\nclass Kotlin {\r\n\r\n    @Test\r\n    void defaultAdapterRegistrations() {\r\n        // Coroutines\r\n        assertThat(getAdapter(Deferred.class)).isNotNull();\r\n    }\r\n\r\n    @Test\r\n    void deferred() {\r\n        assertThat(getAdapter(CompletableFuture.class).getDescriptor().isDeferred()).isFalse();\r\n        assertThat(getAdapter(Deferred.class).getDescriptor().isDeferred()).isTrue();\r\n        assertThat(getAdapter(kotlinx.coroutines.flow.Flow.class).getDescriptor().isDeferred()).isTrue();\r\n    }\r\n}\n@Nested\r\nclass Mutiny {\r\n\r\n    @Test\r\n    void defaultAdapterRegistrations() {\r\n        assertThat(getAdapter(io.smallrye.mutiny.Uni.class)).isNotNull();\r\n        assertThat(getAdapter(io.smallrye.mutiny.Multi.class)).isNotNull();\r\n    }\r\n\r\n    @Test\r\n    void toUni() {\r\n        Publisher<Integer> source = Mono.just(1);\r\n        Object target = getAdapter(Uni.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(Uni.class);\r\n        assertThat(((Uni<Integer>) target).await().atMost(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n    }\r\n\r\n    @Test\r\n    void fromUni() {\r\n        Uni<Integer> source = Uni.createFrom().item(1);\r\n        Object target = getAdapter(Uni.class).toPublisher(source);\r\n        assertThat(target).isInstanceOf(Mono.class);\r\n        assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n    }\r\n\r\n    @Test\r\n    void toMulti() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Publisher<Integer> source = Flux.fromIterable(sequence);\r\n        Object target = getAdapter(Multi.class).fromPublisher(source);\r\n        assertThat(target).isInstanceOf(Multi.class);\r\n        assertThat(((Multi<Integer>) target).collect().asList().await().atMost(FIVE_SECONDS)).isEqualTo(sequence);\r\n    }\r\n\r\n    @Test\r\n    void fromMulti() {\r\n        List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n        Multi<Integer> source = Multi.createFrom().iterable(sequence);\r\n        Object target = getAdapter(Multi.class).toPublisher(source);\r\n        assertThat(target).isInstanceOf(Flux.class);\r\n        assertThat(((Flux<Integer>) target).blockLast(FIVE_SECONDS)).isEqualTo(Integer.valueOf(3));\r\n    }\r\n}",
    "comment": "\n * Tests for {@link ReactiveAdapterRegistry}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistryTests#getAdapterForReactiveSubType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAdapterForReactiveSubType() {\r\n    ReactiveAdapter adapter1 = getAdapter(Flux.class);\r\n    ReactiveAdapter adapter2 = getAdapter(ExtendedFlux.class);\r\n    assertThat(adapter2).isSameAs(adapter1);\r\n    // Register regular reactive type (after existing adapters)\r\n    this.registry.registerReactiveType(ReactiveTypeDescriptor.multiValue(ExtendedFlux.class, ExtendedFlux::empty), o -> (ExtendedFlux<?>) o, ExtendedFlux::from);\r\n    // Matches for ExtendedFlux itself\r\n    ReactiveAdapter adapter3 = getAdapter(ExtendedFlux.class);\r\n    assertThat(adapter3).isNotNull();\r\n    assertThat(adapter3).isNotSameAs(adapter1);\r\n    // Does not match for ExtendedFlux subclass since the default Flux adapter\r\n    // is being assignability-checked first when no specific match was found\r\n    ReactiveAdapter adapter4 = getAdapter(ExtendedExtendedFlux.class);\r\n    assertThat(adapter4).isSameAs(adapter1);\r\n    // Register reactive type override (before existing adapters)\r\n    this.registry.registerReactiveTypeOverride(ReactiveTypeDescriptor.multiValue(Flux.class, ExtendedFlux::empty), o -> (ExtendedFlux<?>) o, ExtendedFlux::from);\r\n    // Override match for Flux\r\n    ReactiveAdapter adapter5 = getAdapter(Flux.class);\r\n    assertThat(adapter5).isNotNull();\r\n    assertThat(adapter5).isNotSameAs(adapter1);\r\n    // Initially registered adapter specifically matches for ExtendedFlux\r\n    ReactiveAdapter adapter6 = getAdapter(ExtendedFlux.class);\r\n    assertThat(adapter6).isSameAs(adapter3);\r\n    // Override match for ExtendedFlux subclass\r\n    ReactiveAdapter adapter7 = getAdapter(ExtendedExtendedFlux.class);\r\n    assertThat(adapter7).isSameAs(adapter5);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ReactiveAdapterRegistryTests#getAdapter(Class<?>)",
    "entityType": "method",
    "code": "private ReactiveAdapter getAdapter(Class<?> reactiveType) {\r\n    ReactiveAdapter adapter = this.registry.getAdapter(reactiveType);\r\n    assertThat(adapter).isNotNull();\r\n    return adapter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendedFlux",
    "entityType": "class",
    "code": "@Override\r\npublic void subscribe(CoreSubscriber<? super T> actual) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendedFlux#subscribe(CoreSubscriber<? super T>)",
    "entityType": "method",
    "code": "@Override\r\npublic void subscribe(CoreSubscriber<? super T> actual) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ExtendedExtendedFlux",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor",
    "entityType": "class",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // Reactor\r\n    assertThat(getAdapter(Mono.class)).isNotNull();\r\n    assertThat(getAdapter(Flux.class)).isNotNull();\r\n    // Publisher\r\n    assertThat(getAdapter(Publisher.class)).isNotNull();\r\n    // Completable\r\n    assertThat(getAdapter(CompletableFuture.class)).isNotNull();\r\n}\n@Test\r\nvoid toFlux() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n    Object target = getAdapter(Flux.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}\n@Test\r\nvoid toMono() {\r\n    Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromArray(1, 2, 3);\r\n    Object target = getAdapter(Mono.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}\n@Test\r\nvoid toFlowPublisher() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n    Object target = getAdapter(Flow.Publisher.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Flow.Publisher.class);\r\n    assertThat(JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}\n@Test\r\nvoid toCompletableFuture() throws Exception {\r\n    Publisher<Integer> source = Flux.fromArray(new Integer[] { 1, 2, 3 });\r\n    Object target = getAdapter(CompletableFuture.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(CompletableFuture.class);\r\n    assertThat(((CompletableFuture<Integer>) target).get()).isEqualTo(Integer.valueOf(1));\r\n}\n@Test\r\nvoid fromCompletableFuture() {\r\n    CompletableFuture<Integer> future = new CompletableFuture<>();\r\n    future.complete(1);\r\n    Object target = getAdapter(CompletableFuture.class).toPublisher(future);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor#defaultAdapterRegistrations()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // Reactor\r\n    assertThat(getAdapter(Mono.class)).isNotNull();\r\n    assertThat(getAdapter(Flux.class)).isNotNull();\r\n    // Publisher\r\n    assertThat(getAdapter(Publisher.class)).isNotNull();\r\n    // Completable\r\n    assertThat(getAdapter(CompletableFuture.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor#toFlux()",
    "entityType": "method",
    "code": "@Test\r\nvoid toFlux() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n    Object target = getAdapter(Flux.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor#toMono()",
    "entityType": "method",
    "code": "@Test\r\nvoid toMono() {\r\n    Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromArray(1, 2, 3);\r\n    Object target = getAdapter(Mono.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor#toFlowPublisher()",
    "entityType": "method",
    "code": "@Test\r\nvoid toFlowPublisher() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n    Object target = getAdapter(Flow.Publisher.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Flow.Publisher.class);\r\n    assertThat(JdkFlowAdapter.flowPublisherToFlux((Flow.Publisher<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor#toCompletableFuture()",
    "entityType": "method",
    "code": "@Test\r\nvoid toCompletableFuture() throws Exception {\r\n    Publisher<Integer> source = Flux.fromArray(new Integer[] { 1, 2, 3 });\r\n    Object target = getAdapter(CompletableFuture.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(CompletableFuture.class);\r\n    assertThat(((CompletableFuture<Integer>) target).get()).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Reactor#fromCompletableFuture()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromCompletableFuture() {\r\n    CompletableFuture<Integer> future = new CompletableFuture<>();\r\n    future.complete(1);\r\n    Object target = getAdapter(CompletableFuture.class).toPublisher(future);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3",
    "entityType": "class",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // RxJava 3\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Flowable.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Observable.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Single.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Maybe.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Completable.class)).isNotNull();\r\n}\n@Test\r\nvoid toFlowable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = Flux.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Flowable.class);\r\n    assertThat(((io.reactivex.rxjava3.core.Flowable<?>) target).toList().blockingGet()).isEqualTo(sequence);\r\n}\n@Test\r\nvoid toObservable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = Flux.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Observable.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Observable.class);\r\n    assertThat(((io.reactivex.rxjava3.core.Observable<?>) target).toList().blockingGet()).isEqualTo(sequence);\r\n}\n@Test\r\nvoid toSingle() {\r\n    Publisher<Integer> source = Flux.fromArray(new Integer[] { 1 });\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Single.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Single.class);\r\n    assertThat(((io.reactivex.rxjava3.core.Single<Integer>) target).blockingGet()).isEqualTo(Integer.valueOf(1));\r\n}\n@Test\r\nvoid toCompletable() {\r\n    Publisher<Integer> source = Flux.fromArray(new Integer[] { 1, 2, 3 });\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Completable.class);\r\n    ((io.reactivex.rxjava3.core.Completable) target).blockingAwait();\r\n}\n@Test\r\nvoid fromFlowable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Object source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}\n@Test\r\nvoid fromObservable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Object source = io.reactivex.rxjava3.core.Observable.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Observable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}\n@Test\r\nvoid fromSingle() {\r\n    Object source = io.reactivex.rxjava3.core.Single.just(1);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Single.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}\n@Test\r\nvoid fromCompletable() {\r\n    Object source = io.reactivex.rxjava3.core.Completable.complete();\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    ((Mono<Void>) target).block(FIVE_SECONDS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#defaultAdapterRegistrations()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // RxJava 3\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Flowable.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Observable.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Single.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Maybe.class)).isNotNull();\r\n    assertThat(getAdapter(io.reactivex.rxjava3.core.Completable.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#toFlowable()",
    "entityType": "method",
    "code": "@Test\r\nvoid toFlowable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = Flux.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Flowable.class);\r\n    assertThat(((io.reactivex.rxjava3.core.Flowable<?>) target).toList().blockingGet()).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#toObservable()",
    "entityType": "method",
    "code": "@Test\r\nvoid toObservable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = Flux.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Observable.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Observable.class);\r\n    assertThat(((io.reactivex.rxjava3.core.Observable<?>) target).toList().blockingGet()).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#toSingle()",
    "entityType": "method",
    "code": "@Test\r\nvoid toSingle() {\r\n    Publisher<Integer> source = Flux.fromArray(new Integer[] { 1 });\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Single.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Single.class);\r\n    assertThat(((io.reactivex.rxjava3.core.Single<Integer>) target).blockingGet()).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#toCompletable()",
    "entityType": "method",
    "code": "@Test\r\nvoid toCompletable() {\r\n    Publisher<Integer> source = Flux.fromArray(new Integer[] { 1, 2, 3 });\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(io.reactivex.rxjava3.core.Completable.class);\r\n    ((io.reactivex.rxjava3.core.Completable) target).blockingAwait();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#fromFlowable()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromFlowable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Object source = io.reactivex.rxjava3.core.Flowable.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Flowable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#fromObservable()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromObservable() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Object source = io.reactivex.rxjava3.core.Observable.fromIterable(sequence);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Observable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Flux Publisher: \" + target.getClass().getName()).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).collectList().block(FIVE_SECONDS)).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#fromSingle()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromSingle() {\r\n    Object source = io.reactivex.rxjava3.core.Single.just(1);\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Single.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.RxJava3#fromCompletable()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromCompletable() {\r\n    Object source = io.reactivex.rxjava3.core.Completable.complete();\r\n    Object target = getAdapter(io.reactivex.rxjava3.core.Completable.class).toPublisher(source);\r\n    assertThat(target).as(\"Expected Mono Publisher: \" + target.getClass().getName()).isInstanceOf(Mono.class);\r\n    ((Mono<Void>) target).block(FIVE_SECONDS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Kotlin",
    "entityType": "class",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // Coroutines\r\n    assertThat(getAdapter(Deferred.class)).isNotNull();\r\n}\n@Test\r\nvoid deferred() {\r\n    assertThat(getAdapter(CompletableFuture.class).getDescriptor().isDeferred()).isFalse();\r\n    assertThat(getAdapter(Deferred.class).getDescriptor().isDeferred()).isTrue();\r\n    assertThat(getAdapter(kotlinx.coroutines.flow.Flow.class).getDescriptor().isDeferred()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Kotlin#defaultAdapterRegistrations()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    // Coroutines\r\n    assertThat(getAdapter(Deferred.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Kotlin#deferred()",
    "entityType": "method",
    "code": "@Test\r\nvoid deferred() {\r\n    assertThat(getAdapter(CompletableFuture.class).getDescriptor().isDeferred()).isFalse();\r\n    assertThat(getAdapter(Deferred.class).getDescriptor().isDeferred()).isTrue();\r\n    assertThat(getAdapter(kotlinx.coroutines.flow.Flow.class).getDescriptor().isDeferred()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Mutiny",
    "entityType": "class",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    assertThat(getAdapter(io.smallrye.mutiny.Uni.class)).isNotNull();\r\n    assertThat(getAdapter(io.smallrye.mutiny.Multi.class)).isNotNull();\r\n}\n@Test\r\nvoid toUni() {\r\n    Publisher<Integer> source = Mono.just(1);\r\n    Object target = getAdapter(Uni.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Uni.class);\r\n    assertThat(((Uni<Integer>) target).await().atMost(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}\n@Test\r\nvoid fromUni() {\r\n    Uni<Integer> source = Uni.createFrom().item(1);\r\n    Object target = getAdapter(Uni.class).toPublisher(source);\r\n    assertThat(target).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}\n@Test\r\nvoid toMulti() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = Flux.fromIterable(sequence);\r\n    Object target = getAdapter(Multi.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Multi.class);\r\n    assertThat(((Multi<Integer>) target).collect().asList().await().atMost(FIVE_SECONDS)).isEqualTo(sequence);\r\n}\n@Test\r\nvoid fromMulti() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Multi<Integer> source = Multi.createFrom().iterable(sequence);\r\n    Object target = getAdapter(Multi.class).toPublisher(source);\r\n    assertThat(target).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).blockLast(FIVE_SECONDS)).isEqualTo(Integer.valueOf(3));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Mutiny#defaultAdapterRegistrations()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultAdapterRegistrations() {\r\n    assertThat(getAdapter(io.smallrye.mutiny.Uni.class)).isNotNull();\r\n    assertThat(getAdapter(io.smallrye.mutiny.Multi.class)).isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Mutiny#toUni()",
    "entityType": "method",
    "code": "@Test\r\nvoid toUni() {\r\n    Publisher<Integer> source = Mono.just(1);\r\n    Object target = getAdapter(Uni.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Uni.class);\r\n    assertThat(((Uni<Integer>) target).await().atMost(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Mutiny#fromUni()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromUni() {\r\n    Uni<Integer> source = Uni.createFrom().item(1);\r\n    Object target = getAdapter(Uni.class).toPublisher(source);\r\n    assertThat(target).isInstanceOf(Mono.class);\r\n    assertThat(((Mono<Integer>) target).block(FIVE_SECONDS)).isEqualTo(Integer.valueOf(1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Mutiny#toMulti()",
    "entityType": "method",
    "code": "@Test\r\nvoid toMulti() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Publisher<Integer> source = Flux.fromIterable(sequence);\r\n    Object target = getAdapter(Multi.class).fromPublisher(source);\r\n    assertThat(target).isInstanceOf(Multi.class);\r\n    assertThat(((Multi<Integer>) target).collect().asList().await().atMost(FIVE_SECONDS)).isEqualTo(sequence);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.Mutiny#fromMulti()",
    "entityType": "method",
    "code": "@Test\r\nvoid fromMulti() {\r\n    List<Integer> sequence = Arrays.asList(1, 2, 3);\r\n    Multi<Integer> source = Multi.createFrom().iterable(sequence);\r\n    Object target = getAdapter(Multi.class).toPublisher(source);\r\n    assertThat(target).isInstanceOf(Flux.class);\r\n    assertThat(((Flux<Integer>) target).blockLast(FIVE_SECONDS)).isEqualTo(Integer.valueOf(3));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests",
    "entityType": "class",
    "code": "@Captor\r\nprivate ArgumentCaptor<TypeVariable<?>> typeVariableCaptor;\n@Test\r\nvoid noneReturnValues() {\r\n    ResolvableType none = ResolvableType.NONE;\r\n    assertThat(none.as(Object.class)).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.asCollection()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.asMap()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getComponentType()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getGeneric(0)).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getGenerics()).isEmpty();\r\n    assertThat(none.getInterfaces()).isEmpty();\r\n    assertThat(none.getSuperType()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getType()).isEqualTo(ResolvableType.EmptyType.INSTANCE);\r\n    assertThat(none.hasGenerics()).isFalse();\r\n    assertThat(none.isArray()).isFalse();\r\n    assertThat(none.resolve()).isNull();\r\n    assertThat(none.resolve(String.class)).isEqualTo(String.class);\r\n    assertThat(none.resolveGeneric(0)).isNull();\r\n    assertThat(none.resolveGenerics()).isEmpty();\r\n    assertThat(none.toString()).isEqualTo(\"?\");\r\n    assertThat(none.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(none.isAssignableFrom(ResolvableType.forClass(Object.class))).isFalse();\r\n}\n@Test\r\nvoid forClass() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.getType()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.getRawClass()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.isAssignableFrom(ExtendsList.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(ArrayList.class)).isFalse();\r\n}\n@Test\r\nvoid forClassWithNull() {\r\n    ResolvableType type = ResolvableType.forClass(null);\r\n    assertThat(type.getType()).isEqualTo(Object.class);\r\n    assertThat(type.getRawClass()).isEqualTo(Object.class);\r\n    assertThat(type.isAssignableFrom(Object.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(String.class)).isTrue();\r\n}\n@Test\r\nvoid forRawClass() {\r\n    ResolvableType type = ResolvableType.forRawClass(ExtendsList.class);\r\n    assertThat(type.getType()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.getRawClass()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.isAssignableFrom(ExtendsList.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(ArrayList.class)).isFalse();\r\n    assertThat(type).isNotEqualTo(ResolvableType.forClass(ExtendsList.class));\r\n}\n@Test\r\nvoid forRawClassWithNull() {\r\n    ResolvableType type = ResolvableType.forRawClass(null);\r\n    assertThat(type.getType()).isEqualTo(Object.class);\r\n    assertThat(type.getRawClass()).isEqualTo(Object.class);\r\n    assertThat(type.isAssignableFrom(Object.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(type).isNotEqualTo(ResolvableType.forClass(null));\r\n}\n// gh-23321\r\n@Test\r\nvoid forRawClassAssignableFromTypeVariable() {\r\n    ResolvableType typeVariable = ResolvableType.forClass(ExtendsList.class).as(List.class).getGeneric();\r\n    ResolvableType raw = ResolvableType.forRawClass(CharSequence.class);\r\n    assertThat(raw.resolve()).isEqualTo(CharSequence.class);\r\n    assertThat(typeVariable.resolve()).isEqualTo(CharSequence.class);\r\n    assertThat(raw.resolve().isAssignableFrom(typeVariable.resolve())).isTrue();\r\n    assertThat(typeVariable.resolve().isAssignableFrom(raw.resolve())).isTrue();\r\n    assertThat(raw.isAssignableFrom(typeVariable)).isTrue();\r\n    assertThat(typeVariable.isAssignableFrom(raw)).isTrue();\r\n}\n// gh-28776\r\n@Test\r\nvoid forInstanceNull() {\r\n    assertThat(ResolvableType.forInstance(null)).isEqualTo(ResolvableType.NONE);\r\n}\n@Test\r\nvoid forInstanceNoProvider() {\r\n    ResolvableType type = ResolvableType.forInstance(new Object());\r\n    assertThat(type.getType()).isEqualTo(Object.class);\r\n    assertThat(type.resolve()).isEqualTo(Object.class);\r\n}\n@Test\r\nvoid forInstanceProvider() {\r\n    ResolvableType type = ResolvableType.forInstance(new MyGenericInterfaceType<>(String.class));\r\n    assertThat(type.getRawClass()).isEqualTo(MyGenericInterfaceType.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid forInstanceProviderNull() {\r\n    ResolvableType type = ResolvableType.forInstance(new MyGenericInterfaceType<>(null));\r\n    assertThat(type.getType()).isEqualTo(MyGenericInterfaceType.class);\r\n    assertThat(type.resolve()).isEqualTo(MyGenericInterfaceType.class);\r\n}\n@Test\r\nvoid forField() throws Exception {\r\n    Field field = Fields.class.getField(\"charSequenceList\");\r\n    ResolvableType type = ResolvableType.forField(field);\r\n    assertThat(type.getType()).isEqualTo(field.getGenericType());\r\n}\n@Test\r\nvoid forPrivateField() throws Exception {\r\n    Field field = Fields.class.getDeclaredField(\"privateField\");\r\n    ResolvableType type = ResolvableType.forField(field);\r\n    assertThat(type.getType()).isEqualTo(field.getGenericType());\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getSource()).isSameAs(field);\r\n    Field field2 = Fields.class.getDeclaredField(\"otherPrivateField\");\r\n    ResolvableType type2 = ResolvableType.forField(field2);\r\n    assertThat(type2.getType()).isEqualTo(field2.getGenericType());\r\n    assertThat(type2.resolve()).isEqualTo(List.class);\r\n    assertThat(type2.getSource()).isSameAs(field2);\r\n    assertThat(type2).isEqualTo(type);\r\n    assertThat(type2.hashCode()).isEqualTo(type.hashCode());\r\n}\n@Test\r\nvoid forFieldMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forField(null)).withMessage(\"Field must not be null\");\r\n}\n@Test\r\nvoid forConstructorParameter() throws Exception {\r\n    Constructor<Constructors> constructor = Constructors.class.getConstructor(List.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\r\n    assertThat(type.getType()).isEqualTo(constructor.getGenericParameterTypes()[0]);\r\n}\n@Test\r\nvoid forConstructorParameterMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forConstructorParameter(null, 0)).withMessage(\"Constructor must not be null\");\r\n}\n@Test\r\nvoid forMethodParameterByIndex() throws Exception {\r\n    Method method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(method, 0);\r\n    assertThat(type.getType()).isEqualTo(method.getGenericParameterTypes()[0]);\r\n}\n@Test\r\nvoid forMethodParameterByIndexMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forMethodParameter(null, 0)).withMessage(\"Method must not be null\");\r\n}\n@Test\r\nvoid forMethodParameter() throws Exception {\r\n    Method method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.getType()).isEqualTo(method.getGenericParameterTypes()[0]);\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid forMethodParameterWithNesting() throws Exception {\r\n    Method method = Methods.class.getMethod(\"nested\", Map.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    methodParameter.increaseNestingLevel();\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(Byte.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Long.class);\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid forMethodParameterWithNestingAndLevels() throws Exception {\r\n    Method method = Methods.class.getMethod(\"nested\", Map.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    methodParameter.increaseNestingLevel();\r\n    methodParameter.setTypeIndexForCurrentLevel(0);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid forMethodParameterMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forMethodParameter(null)).withMessage(\"MethodParameter must not be null\");\r\n}\n// SPR-16210\r\n@Test\r\nvoid forMethodParameterWithSameSignatureAndGenerics() throws Exception {\r\n    Method method = Methods.class.getMethod(\"list1\");\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(((MethodParameter) type.getSource()).getMethod()).isEqualTo(method);\r\n    method = Methods.class.getMethod(\"list2\");\r\n    methodParameter = MethodParameter.forExecutable(method, -1);\r\n    type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(((MethodParameter) type.getSource()).getMethod()).isEqualTo(method);\r\n}\n@Test\r\nvoid forMethodReturn() throws Exception {\r\n    Method method = Methods.class.getMethod(\"charSequenceReturn\");\r\n    ResolvableType type = ResolvableType.forMethodReturnType(method);\r\n    assertThat(type.getType()).isEqualTo(method.getGenericReturnType());\r\n}\n@Test\r\nvoid forMethodReturnMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forMethodReturnType(null)).withMessage(\"Method must not be null\");\r\n}\n// gh-27748\r\n@Test\r\nvoid genericMatchesReturnType() throws Exception {\r\n    Method method = SomeRepository.class.getMethod(\"someMethod\", Class.class, Class.class, Class.class);\r\n    ResolvableType returnType = ResolvableType.forMethodReturnType(method, SomeRepository.class);\r\n    // generic[0]=T\r\n    ResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, SomeRepository.class);\r\n    // generic[0]=?\r\n    ResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, SomeRepository.class);\r\n    // generic[0]=java.lang.Object\r\n    ResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, SomeRepository.class);\r\n    assertThat(returnType.equalsType(arg0.as(Class.class).getGeneric(0))).isTrue();\r\n    assertThat(returnType.equalsType(arg1.as(Class.class).getGeneric(0))).isFalse();\r\n    assertThat(returnType.equalsType(arg2.as(Class.class).getGeneric(0))).isFalse();\r\n}\n@Test\r\nvoid classType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"classType\"));\r\n    assertThat(type.getType().getClass()).isEqualTo(Class.class);\r\n}\n@Test\r\nvoid parameterizedType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.getType()).isInstanceOf(ParameterizedType.class);\r\n}\n@Test\r\nvoid arrayClassType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"arrayClassType\"));\r\n    assertThat(type.getType()).isInstanceOf(Class.class);\r\n    assertThat(((Class) type.getType()).isArray()).isTrue();\r\n}\n@Test\r\nvoid genericArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    assertThat(type.getType()).isInstanceOf(GenericArrayType.class);\r\n}\n@Test\r\nvoid wildcardType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\r\n    assertThat(type.getType()).isInstanceOf(ParameterizedType.class);\r\n    assertThat(type.getGeneric().getType()).isInstanceOf(WildcardType.class);\r\n}\n@Test\r\nvoid typeVariableType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"typeVariableType\"));\r\n    assertThat(type.getType()).isInstanceOf(TypeVariable.class);\r\n}\n@Test\r\nvoid getComponentTypeForClassArray() throws Exception {\r\n    Field field = Fields.class.getField(\"arrayClassType\");\r\n    ResolvableType type = ResolvableType.forField(field);\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.getComponentType().getType()).isEqualTo(((Class) field.getGenericType()).componentType());\r\n}\n@Test\r\nvoid getComponentTypeForGenericArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.getComponentType().getType()).isEqualTo(((GenericArrayType) type.getType()).getGenericComponentType());\r\n}\n@Test\r\nvoid getComponentTypeForVariableThatResolvesToGenericArray() {\r\n    ResolvableType type = ResolvableType.forClass(ListOfGenericArray.class).asCollection().getGeneric();\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.getType()).isInstanceOf(TypeVariable.class);\r\n    assertThat(type.getComponentType().getType().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n}\n@Test\r\nvoid getComponentTypeForNonArray() {\r\n    ResolvableType type = ResolvableType.forClass(String.class);\r\n    assertThat(type.isArray()).isFalse();\r\n    assertThat(type.getComponentType()).isEqualTo(ResolvableType.NONE);\r\n}\n@Test\r\nvoid asCollection() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).asCollection();\r\n    assertThat(type.resolve()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid asMap() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsMap.class).asMap();\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.resolveGeneric(0)).isEqualTo(String.class);\r\n    assertThat(type.resolveGeneric(1)).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid asFromInterface() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(List.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.List<E>\");\r\n}\n@Test\r\nvoid asFromInheritedInterface() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(Collection.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.Collection<E>\");\r\n}\n@Test\r\nvoid asFromSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(ArrayList.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.ArrayList<java.lang.CharSequence>\");\r\n}\n@Test\r\nvoid asFromInheritedSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(List.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.List<E>\");\r\n}\n@Test\r\nvoid asNotFound() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(Map.class);\r\n    assertThat(type).isSameAs(ResolvableType.NONE);\r\n}\n@Test\r\nvoid asSelf() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.as(ExtendsList.class)).isEqualTo(type);\r\n}\n@Test\r\nvoid getSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(ArrayList.class);\r\n    type = type.getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(AbstractList.class);\r\n    type = type.getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(AbstractCollection.class);\r\n    type = type.getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(Object.class);\r\n}\n@Test\r\nvoid getInterfaces() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.getInterfaces()).isEmpty();\r\n    SortedSet<String> interfaces = new TreeSet<>();\r\n    for (ResolvableType interfaceType : type.getSuperType().getInterfaces()) {\r\n        interfaces.add(interfaceType.toString());\r\n    }\r\n    assertThat(interfaces.toString()).isEqualTo(\"[java.io.Serializable, java.lang.Cloneable, \" + \"java.util.List<java.lang.CharSequence>, java.util.RandomAccess]\");\r\n}\n@Test\r\nvoid noSuperType() {\r\n    assertThat(ResolvableType.forClass(Object.class).getSuperType()).isEqualTo(ResolvableType.NONE);\r\n}\n@Test\r\nvoid noInterfaces() {\r\n    assertThat(ResolvableType.forClass(Object.class).getInterfaces()).isEmpty();\r\n}\n@Test\r\nvoid nested() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"nested\"));\r\n    type = type.getNested(2);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(Byte.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Long.class);\r\n}\n@Test\r\nvoid nestedWithIndexes() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"nested\"));\r\n    type = type.getNested(2, Collections.singletonMap(2, 0));\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid nestedWithArray() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    type = type.getNested(2);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid getGeneric() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.getGeneric().getType()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid getGenericByIndex() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMap\"));\r\n    assertThat(type.getGeneric(0).getType()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).getType()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid getGenericOfGeneric() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\"));\r\n    assertThat(type.getGeneric().getType().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n    assertThat(type.getGeneric().getGeneric().getType()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid genericOfGenericWithAs() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\")).asCollection();\r\n    assertThat(type.toString()).isEqualTo(\"java.util.Collection<java.util.List<java.lang.String>>\");\r\n    assertThat(type.getGeneric().asCollection().toString()).isEqualTo(\"java.util.Collection<java.lang.String>\");\r\n}\n@Test\r\nvoid getGenericOfGenericByIndexes() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\"));\r\n    assertThat(type.getGeneric(0, 0).getType()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid getGenericOutOfBounds() {\r\n    ResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\r\n    assertThat(type.getGeneric(0)).isNotEqualTo(ResolvableType.NONE);\r\n    assertThat(type.getGeneric(1)).isEqualTo(ResolvableType.NONE);\r\n    assertThat(type.getGeneric(0, 1)).isEqualTo(ResolvableType.NONE);\r\n}\n@Test\r\nvoid hasGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.hasGenerics()).isFalse();\r\n    assertThat(type.asCollection().hasGenerics()).isTrue();\r\n}\n@Test\r\nvoid getGenericsFromParameterizedType() {\r\n    ResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\r\n    ResolvableType[] generics = type.getGenerics();\r\n    assertThat(generics).hasSize(1);\r\n    assertThat(generics[0].resolve()).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid getGenericsFromClass() {\r\n    ResolvableType type = ResolvableType.forClass(List.class);\r\n    ResolvableType[] generics = type.getGenerics();\r\n    assertThat(generics).hasSize(1);\r\n    assertThat(generics[0].getType().toString()).isEqualTo(\"E\");\r\n}\n@Test\r\nvoid noGetGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    ResolvableType[] generics = type.getGenerics();\r\n    assertThat(generics).isEmpty();\r\n}\n@Test\r\nvoid getResolvedGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\r\n    Class<?>[] generics = type.resolveGenerics();\r\n    assertThat(generics).hasSize(1);\r\n    assertThat(generics[0]).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid resolveClassType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"classType\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n}\n@Test\r\nvoid resolveParameterizedType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n}\n@Test\r\nvoid resolveArrayClassType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"arrayClassType\"));\r\n    assertThat(type.resolve()).isEqualTo(List[].class);\r\n}\n@Test\r\nvoid resolveGenericArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    assertThat(type.resolve()).isEqualTo(List[].class);\r\n    assertThat(type.getComponentType().resolve()).isEqualTo(List.class);\r\n    assertThat(type.getComponentType().getGeneric().resolve()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveGenericMultiArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericMultiArrayType\"));\r\n    assertThat(type.resolve()).isEqualTo(List[][][].class);\r\n    assertThat(type.getComponentType().resolve()).isEqualTo(List[][].class);\r\n}\n@Test\r\nvoid resolveGenericArrayFromGeneric() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringArrayList\"));\r\n    ResolvableType generic = type.asCollection().getGeneric();\r\n    assertThat(generic.getType().toString()).isEqualTo(\"E\");\r\n    assertThat(generic.isArray()).isTrue();\r\n    assertThat(generic.resolve()).isEqualTo(String[].class);\r\n}\n@Test\r\nvoid resolveVariableGenericArray() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"), TypedFields.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T[]\");\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.resolve()).isEqualTo(String[].class);\r\n}\n@Test\r\nvoid resolveVariableGenericArrayUnknown() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"));\r\n    assertThat(type.getType().toString()).isEqualTo(\"T[]\");\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.resolve()).isNull();\r\n}\n@Test\r\nvoid resolveVariableGenericArrayUnknownWithFallback() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"variableTypeGenericArray\"));\r\n    assertThat(type.getType().toString()).isEqualTo(\"T[]\");\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.toClass()).isEqualTo(Object.class);\r\n}\n@Test\r\nvoid resolveWildcardTypeUpperBounds() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(Number.class);\r\n}\n@Test\r\nvoid resolveWildcardLowerBounds() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardSuperType\"));\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(Number.class);\r\n}\n@Test\r\nvoid resolveVariableFromFieldType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveVariableFromFieldTypeUnknown() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isNull();\r\n}\n@Test\r\nvoid resolveVariableFromInheritedField() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMap\")).as(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric(1, 0).resolve()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid resolveVariableFromInheritedFieldSwitched() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMapSwitched\")).as(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric(1, 0).resolve()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid doesResolveFromOuterOwner() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"listOfListOfUnknown\")).as(Collection.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric(0).as(Collection.class).getGeneric(0).as(Collection.class).resolve()).isNull();\r\n}\n@Test\r\nvoid intArrayNotAssignableToIntegerArray() throws Exception {\r\n    ResolvableType integerArray = ResolvableType.forField(Fields.class.getField(\"integerArray\"));\r\n    ResolvableType intArray = ResolvableType.forField(Fields.class.getField(\"intArray\"));\r\n    assertThat(integerArray.isAssignableFrom(intArray)).isFalse();\r\n    assertThat(intArray.isAssignableFrom(integerArray)).isFalse();\r\n}\n@Test\r\nvoid resolveBoundedTypeVariableResult() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"boundedTypeVariableResult\"));\r\n    assertThat(type.resolve()).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid resolveBoundedTypeVariableWildcardResult() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"boundedTypeVariableWildcardResult\"));\r\n    assertThat(type.getGeneric(1).asCollection().resolveGeneric()).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid resolveVariableNotFound() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"typedReturn\"));\r\n    assertThat(type.resolve()).isNull();\r\n}\n@Test\r\nvoid resolveTypeVariableFromSimpleInterfaceType() {\r\n    ResolvableType type = ResolvableType.forClass(MySimpleInterfaceType.class).as(MyInterfaceType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromSimpleCollectionInterfaceType() {\r\n    ResolvableType type = ResolvableType.forClass(MyCollectionInterfaceType.class).as(MyInterfaceType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromSimpleSuperclassType() {\r\n    ResolvableType type = ResolvableType.forClass(MySimpleSuperclassType.class).as(MySuperclassType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromSimpleCollectionSuperclassType() {\r\n    ResolvableType type = ResolvableType.forClass(MyCollectionSuperclassType.class).as(MySuperclassType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromFieldTypeWithImplementsClass() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"), TypedFields.class);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromFieldTypeWithImplementsType() throws Exception {\r\n    ResolvableType implementationType = ResolvableType.forClassWithGenerics(Fields.class, Integer.class);\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"), implementationType);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.resolve()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.asCollection().resolveGeneric()).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromClassWithImplementsClass() {\r\n    ResolvableType type = ResolvableType.forClass(MySuperclassType.class, MyCollectionSuperclassType.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric(0, 0)).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromConstructorParameter() throws Exception {\r\n    Constructor<?> constructor = Constructors.class.getConstructor(List.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.resolveGeneric(0)).isEqualTo(CharSequence.class);\r\n}\n@Test\r\nvoid resolveUnknownTypeVariableFromConstructorParameter() throws Exception {\r\n    Constructor<?> constructor = Constructors.class.getConstructor(Map.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.resolveGeneric(0)).isNull();\r\n}\n@Test\r\nvoid resolveTypeVariableFromConstructorParameterWithImplementsClass() throws Exception {\r\n    Constructor<?> constructor = Constructors.class.getConstructor(Map.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0, TypedConstructors.class);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.resolveGeneric(0)).isEqualTo(String.class);\r\n}\n@Test\r\nvoid resolveTypeVariableFromMethodParameter() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(method, 0);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromMethodParameterWithImplementsClass() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(method, 0, TypedMethods.class);\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromMethodParameterType() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid resolveTypeVariableFromMethodParameterTypeWithImplementsClass() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    methodParameter.setContainingClass(TypedMethods.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromMethodParameterTypeWithImplementsType() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedParameter\", Object.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    ResolvableType implementationType = ResolvableType.forClassWithGenerics(Methods.class, Integer.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter, implementationType);\r\n    assertThat(type.resolve()).isEqualTo(Integer.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromMethodReturn() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedReturn\");\r\n    ResolvableType type = ResolvableType.forMethodReturnType(method);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromMethodReturnWithImplementsClass() throws Exception {\r\n    Method method = Methods.class.getMethod(\"typedReturn\");\r\n    ResolvableType type = ResolvableType.forMethodReturnType(method, TypedMethods.class);\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromType() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\r\n    ResolvableType type = ResolvableType.forType(sourceType);\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromTypeWithVariableResolver() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\r\n    ResolvableType type = ResolvableType.forType(sourceType, ResolvableType.forClass(TypedMethods.class).as(Methods.class).asVariableResolver());\r\n    assertThat(type.resolve()).isEqualTo(String.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeWithCustomVariableResolver() throws Exception {\r\n    VariableResolver variableResolver = mock();\r\n    given(variableResolver.getSource()).willReturn(this);\r\n    ResolvableType longType = ResolvableType.forClass(Long.class);\r\n    given(variableResolver.resolveVariable(any())).willReturn(longType);\r\n    ResolvableType variable = ResolvableType.forType(Fields.class.getField(\"typeVariableType\").getGenericType(), variableResolver);\r\n    ResolvableType parameterized = ResolvableType.forType(Fields.class.getField(\"parameterizedType\").getGenericType(), variableResolver);\r\n    assertThat(variable.resolve()).isEqualTo(Long.class);\r\n    assertThat(parameterized.resolve()).isEqualTo(List.class);\r\n    assertThat(parameterized.resolveGeneric()).isEqualTo(Long.class);\r\n    verify(variableResolver, atLeastOnce()).resolveVariable(this.typeVariableCaptor.capture());\r\n    assertThat(this.typeVariableCaptor.getValue().getName()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromReflectiveParameterizedTypeReference() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"typedReturn\").getGenericReturnType();\r\n    ResolvableType type = ResolvableType.forType(ParameterizedTypeReference.forType(sourceType));\r\n    assertThat(type.resolve()).isNull();\r\n    assertThat(type.getType().toString()).isEqualTo(\"T\");\r\n}\n@Test\r\nvoid resolveTypeVariableFromDeclaredParameterizedTypeReference() throws Exception {\r\n    Type sourceType = Methods.class.getMethod(\"charSequenceReturn\").getGenericReturnType();\r\n    ResolvableType reflectiveType = ResolvableType.forType(sourceType);\r\n    ResolvableType declaredType = ResolvableType.forType(new ParameterizedTypeReference<List<CharSequence>>() ;);\r\n    assertThat(declaredType).isEqualTo(reflectiveType);\r\n}\n@Test\r\nvoid toStrings() throws Exception {\r\n    assertThat(ResolvableType.NONE.toString()).isEqualTo(\"?\");\r\n    assertThat(forField(\"classType\")).hasToString(\"java.util.List<?>\");\r\n    assertThat(forField(\"typeVariableType\")).hasToString(\"?\");\r\n    assertThat(forField(\"parameterizedType\")).hasToString(\"java.util.List<?>\");\r\n    assertThat(forField(\"arrayClassType\")).hasToString(\"java.util.List<?>[]\");\r\n    assertThat(forField(\"genericArrayType\")).hasToString(\"java.util.List<java.lang.String>[]\");\r\n    assertThat(forField(\"genericMultiArrayType\")).hasToString(\"java.util.List<java.lang.String>[][][]\");\r\n    assertThat(forField(\"wildcardType\")).hasToString(\"java.util.List<java.lang.Number>\");\r\n    assertThat(forField(\"wildcardSuperType\")).hasToString(\"java.util.List<java.lang.Number>\");\r\n    assertThat(forField(\"charSequenceList\")).hasToString(\"java.util.List<java.lang.CharSequence>\");\r\n    assertThat(forField(\"stringList\")).hasToString(\"java.util.List<java.lang.String>\");\r\n    assertThat(forField(\"stringListList\")).hasToString(\"java.util.List<java.util.List<java.lang.String>>\");\r\n    assertThat(forField(\"stringArrayList\")).hasToString(\"java.util.List<java.lang.String[]>\");\r\n    assertThat(forField(\"stringIntegerMultiValueMap\")).hasToString(\"org.springframework.util.MultiValueMap<java.lang.String, java.lang.Integer>\");\r\n    assertThat(forField(\"stringIntegerMultiValueMapSwitched\")).hasToString(VariableNameSwitch.class.getName() + \"<java.lang.Integer, java.lang.String>\");\r\n    assertThat(forField(\"listOfListOfUnknown\")).hasToString(\"java.util.List<java.util.List<?>>\");\r\n    assertThat(forTypedField(\"typeVariableType\")).hasToString(\"java.lang.String\");\r\n    assertThat(forTypedField(\"parameterizedType\")).hasToString(\"java.util.List<java.lang.String>\");\r\n    assertThat(ResolvableType.forClass(ListOfGenericArray.class).toString()).isEqualTo(ListOfGenericArray.class.getName());\r\n    assertThat(ResolvableType.forClass(List.class, ListOfGenericArray.class).toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>[]>\");\r\n}\n@Test\r\nvoid getSource() throws Exception {\r\n    Class<?> classType = MySimpleInterfaceType.class;\r\n    Field basicField = Fields.class.getField(\"classType\");\r\n    Field field = Fields.class.getField(\"charSequenceList\");\r\n    Method method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    assertThat(ResolvableType.forField(basicField).getSource()).isEqualTo(basicField);\r\n    assertThat(ResolvableType.forField(field).getSource()).isEqualTo(field);\r\n    assertThat(ResolvableType.forMethodParameter(methodParameter).getSource()).isEqualTo(methodParameter);\r\n    assertThat(ResolvableType.forMethodParameter(method, 0).getSource()).isEqualTo(methodParameter);\r\n    assertThat(ResolvableType.forClass(classType).getSource()).isEqualTo(classType);\r\n    assertThat(ResolvableType.forClass(classType).getSuperType().getSource()).isEqualTo(classType.getGenericSuperclass());\r\n}\n@Test\r\nvoid resolveFromOuterClass() throws Exception {\r\n    Field field = EnclosedInParameterizedType.InnerTyped.class.getField(\"field\");\r\n    ResolvableType type = ResolvableType.forField(field, TypedEnclosedInParameterizedType.TypedInnerTyped.class);\r\n    assertThat(type.resolve()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid resolveFromClassWithGenerics() {\r\n    ResolvableType type = ResolvableType.forClassWithGenerics(List.class, ResolvableType.forClassWithGenerics(List.class, String.class));\r\n    assertThat(type.asCollection().toString()).isEqualTo(\"java.util.Collection<java.util.List<java.lang.String>>\");\r\n    assertThat(type.asCollection().getGeneric().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n    assertThat(type.asCollection().getGeneric().asCollection().toString()).isEqualTo(\"java.util.Collection<java.lang.String>\");\r\n    assertThat(type.toString()).isEqualTo(\"java.util.List<java.util.List<java.lang.String>>\");\r\n    assertThat(type.asCollection().getGeneric().getGeneric().resolve()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid isAssignableFromMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forClass(Object.class).isAssignableFrom((ResolvableType) null)).withMessage(\"ResolvableType must not be null\");\r\n}\n@Test\r\nvoid isAssignableFromForNone() {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    assertThat(objectType.isAssignableFrom(ResolvableType.NONE)).isFalse();\r\n    assertThat(ResolvableType.NONE.isAssignableFrom(objectType)).isFalse();\r\n}\n@Test\r\nvoid isAssignableFromForClassAndClass() {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    ResolvableType charSequenceType = ResolvableType.forClass(CharSequence.class);\r\n    ResolvableType stringType = ResolvableType.forClass(String.class);\r\n    assertThatResolvableType(objectType).isAssignableFrom(objectType, charSequenceType, stringType);\r\n    assertThatResolvableType(charSequenceType).isAssignableFrom(charSequenceType, stringType).isNotAssignableFrom(objectType);\r\n    assertThatResolvableType(stringType).isAssignableFrom(stringType).isNotAssignableFrom(objectType, charSequenceType);\r\n    assertThat(objectType.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(objectType.isAssignableFrom(StringBuilder.class)).isTrue();\r\n    assertThat(charSequenceType.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(charSequenceType.isAssignableFrom(StringBuilder.class)).isTrue();\r\n    assertThat(stringType.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(stringType.isAssignableFrom(StringBuilder.class)).isFalse();\r\n    assertThat(objectType.isInstance(\"a String\")).isTrue();\r\n    assertThat(objectType.isInstance(new StringBuilder(\"a StringBuilder\"))).isTrue();\r\n    assertThat(charSequenceType.isInstance(\"a String\")).isTrue();\r\n    assertThat(charSequenceType.isInstance(new StringBuilder(\"a StringBuilder\"))).isTrue();\r\n    assertThat(stringType.isInstance(\"a String\")).isTrue();\r\n    assertThat(stringType.isInstance(new StringBuilder(\"a StringBuilder\"))).isFalse();\r\n}\n@Test\r\nvoid isAssignableFromCannotBeResolved() throws Exception {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    ResolvableType unresolvableVariable1 = ResolvableType.forField(AssignmentBase.class.getField(\"o\"));\r\n    ResolvableType unresolvableVariable2 = ResolvableType.forField(AssignmentBase.class.getField(\"c\"));\r\n    ResolvableType unresolvableVariable3 = ResolvableType.forField(AssignmentBase.class.getField(\"s\"));\r\n    assertThat(unresolvableVariable1.resolve()).isNull();\r\n    assertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable1);\r\n    assertThatResolvableType(unresolvableVariable1).isAssignableFrom(objectType);\r\n    assertThat(unresolvableVariable2.resolve()).isNull();\r\n    assertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable2);\r\n    assertThatResolvableType(unresolvableVariable2).isAssignableFrom(objectType);\r\n    assertThat(unresolvableVariable3.resolve()).isEqualTo(Serializable.class);\r\n    assertThatResolvableType(objectType).isAssignableFrom(unresolvableVariable3);\r\n    assertThatResolvableType(unresolvableVariable3).isNotAssignableFrom(objectType);\r\n}\n@Test\r\nvoid isAssignableFromForClassAndSimpleVariable() throws Exception {\r\n    ResolvableType objectType = ResolvableType.forClass(Object.class);\r\n    ResolvableType charSequenceType = ResolvableType.forClass(CharSequence.class);\r\n    ResolvableType stringType = ResolvableType.forClass(String.class);\r\n    ResolvableType objectVariable = ResolvableType.forField(AssignmentBase.class.getField(\"o\"), Assignment.class);\r\n    ResolvableType charSequenceVariable = ResolvableType.forField(AssignmentBase.class.getField(\"c\"), Assignment.class);\r\n    ResolvableType stringVariable = ResolvableType.forField(AssignmentBase.class.getField(\"s\"), Assignment.class);\r\n    assertThatResolvableType(objectType).isAssignableFrom(objectVariable, charSequenceVariable, stringVariable);\r\n    assertThatResolvableType(charSequenceType).isAssignableFrom(charSequenceVariable, stringVariable).isNotAssignableFrom(objectVariable);\r\n    assertThatResolvableType(stringType).isAssignableFrom(stringVariable).isNotAssignableFrom(objectVariable, charSequenceVariable);\r\n    assertThatResolvableType(objectVariable).isAssignableFrom(objectType, charSequenceType, stringType);\r\n    assertThatResolvableType(charSequenceVariable).isAssignableFrom(charSequenceType, stringType).isNotAssignableFrom(objectType);\r\n    assertThatResolvableType(stringVariable).isAssignableFrom(stringType).isNotAssignableFrom(objectType, charSequenceType);\r\n    assertThatResolvableType(objectVariable).isAssignableFrom(objectVariable, charSequenceVariable, stringVariable);\r\n    assertThatResolvableType(charSequenceVariable).isAssignableFrom(charSequenceVariable, stringVariable).isNotAssignableFrom(objectVariable);\r\n    assertThatResolvableType(stringVariable).isAssignableFrom(stringVariable).isNotAssignableFrom(objectVariable, charSequenceVariable);\r\n}\n@Test\r\nvoid isAssignableFromForSameClassNonExtendsGenerics() throws Exception {\r\n    ResolvableType objectList = ResolvableType.forField(AssignmentBase.class.getField(\"listo\"), Assignment.class);\r\n    ResolvableType stringList = ResolvableType.forField(AssignmentBase.class.getField(\"lists\"), Assignment.class);\r\n    assertThatResolvableType(stringList).isNotAssignableFrom(objectList);\r\n    assertThatResolvableType(objectList).isNotAssignableFrom(stringList);\r\n    assertThatResolvableType(stringList).isAssignableFrom(stringList);\r\n}\n@Test\r\nvoid isAssignableFromForSameClassExtendsGenerics() throws Exception {\r\n    // Generic assignment can be a little confusing, given:\r\n    //\r\n    // List<CharSequence> c1, List<? extends CharSequence> c2, List<String> s;\r\n    //\r\n    // c2 = s; is allowed and is often used for argument input, for example\r\n    // see List.addAll(). You can get items from c2 but you cannot add items without\r\n    // getting a generic type 'is not applicable for the arguments' error. This makes\r\n    // sense since if you added a StringBuffer to c2 it would break the rules on s.\r\n    //\r\n    // c1 = s; not allowed. Since there is no '? extends' to cause the generic\r\n    // 'is not applicable for the arguments' error when adding (which would pollute\r\n    // s).\r\n    ResolvableType objectList = ResolvableType.forField(AssignmentBase.class.getField(\"listo\"), Assignment.class);\r\n    ResolvableType charSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listc\"), Assignment.class);\r\n    ResolvableType stringList = ResolvableType.forField(AssignmentBase.class.getField(\"lists\"), Assignment.class);\r\n    ResolvableType extendsObjectList = ResolvableType.forField(AssignmentBase.class.getField(\"listxo\"), Assignment.class);\r\n    ResolvableType extendsCharSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class);\r\n    ResolvableType extendsStringList = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class);\r\n    assertThatResolvableType(objectList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(charSequenceList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(stringList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(extendsObjectList).isAssignableFrom(objectList, charSequenceList, stringList);\r\n    assertThatResolvableType(extendsObjectList).isAssignableFrom(extendsObjectList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(extendsCharSequenceList).isAssignableFrom(extendsCharSequenceList, extendsStringList).isNotAssignableFrom(extendsObjectList);\r\n    assertThatResolvableType(extendsCharSequenceList).isAssignableFrom(charSequenceList, stringList).isNotAssignableFrom(objectList);\r\n    assertThatResolvableType(extendsStringList).isAssignableFrom(extendsStringList).isNotAssignableFrom(extendsObjectList, extendsCharSequenceList);\r\n    assertThatResolvableType(extendsStringList).isAssignableFrom(stringList).isNotAssignableFrom(objectList, charSequenceList);\r\n}\n@Test\r\nvoid isAssignableFromForDifferentClassesWithGenerics() throws Exception {\r\n    ResolvableType extendsCharSequenceCollection = ResolvableType.forField(AssignmentBase.class.getField(\"collectionxc\"), Assignment.class);\r\n    ResolvableType charSequenceCollection = ResolvableType.forField(AssignmentBase.class.getField(\"collectionc\"), Assignment.class);\r\n    ResolvableType charSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listc\"), Assignment.class);\r\n    ResolvableType extendsCharSequenceList = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class);\r\n    ResolvableType extendsStringList = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class);\r\n    assertThatResolvableType(extendsCharSequenceCollection).isAssignableFrom(charSequenceCollection, charSequenceList, extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(charSequenceCollection).isAssignableFrom(charSequenceList).isNotAssignableFrom(extendsCharSequenceList, extendsStringList);\r\n    assertThatResolvableType(charSequenceList).isNotAssignableFrom(extendsCharSequenceCollection, charSequenceCollection);\r\n    assertThatResolvableType(extendsCharSequenceList).isNotAssignableFrom(extendsCharSequenceCollection, charSequenceCollection);\r\n    assertThatResolvableType(extendsStringList).isNotAssignableFrom(charSequenceCollection, charSequenceList, extendsCharSequenceList);\r\n}\n@Test\r\nvoid isAssignableFromForArrays() throws Exception {\r\n    ResolvableType object = ResolvableType.forField(AssignmentBase.class.getField(\"o\"), Assignment.class);\r\n    ResolvableType objectArray = ResolvableType.forField(AssignmentBase.class.getField(\"oarray\"), Assignment.class);\r\n    ResolvableType charSequenceArray = ResolvableType.forField(AssignmentBase.class.getField(\"carray\"), Assignment.class);\r\n    ResolvableType stringArray = ResolvableType.forField(AssignmentBase.class.getField(\"sarray\"), Assignment.class);\r\n    assertThatResolvableType(object).isAssignableFrom(objectArray, charSequenceArray, stringArray);\r\n    assertThatResolvableType(objectArray).isAssignableFrom(objectArray, charSequenceArray, stringArray).isNotAssignableFrom(object);\r\n    assertThatResolvableType(charSequenceArray).isAssignableFrom(charSequenceArray, stringArray).isNotAssignableFrom(object, objectArray);\r\n    assertThatResolvableType(stringArray).isAssignableFrom(stringArray).isNotAssignableFrom(object, objectArray, charSequenceArray);\r\n}\n@Test\r\nvoid isAssignableFromForWildcards() throws Exception {\r\n    ResolvableType object = ResolvableType.forClass(Object.class);\r\n    ResolvableType charSequence = ResolvableType.forClass(CharSequence.class);\r\n    ResolvableType string = ResolvableType.forClass(String.class);\r\n    ResolvableType extendsAnon = ResolvableType.forField(AssignmentBase.class.getField(\"listAnon\"), Assignment.class).getGeneric();\r\n    ResolvableType extendsObject = ResolvableType.forField(AssignmentBase.class.getField(\"listxo\"), Assignment.class).getGeneric();\r\n    ResolvableType extendsCharSequence = ResolvableType.forField(AssignmentBase.class.getField(\"listxc\"), Assignment.class).getGeneric();\r\n    ResolvableType extendsString = ResolvableType.forField(AssignmentBase.class.getField(\"listxs\"), Assignment.class).getGeneric();\r\n    ResolvableType superObject = ResolvableType.forField(AssignmentBase.class.getField(\"listso\"), Assignment.class).getGeneric();\r\n    ResolvableType superCharSequence = ResolvableType.forField(AssignmentBase.class.getField(\"listsc\"), Assignment.class).getGeneric();\r\n    ResolvableType superString = ResolvableType.forField(AssignmentBase.class.getField(\"listss\"), Assignment.class).getGeneric();\r\n    // Language Spec 4.5.1. Type Arguments and Wildcards\r\n    // ? extends T <= ? extends S if T <: S\r\n    assertThatResolvableType(extendsCharSequence).isAssignableFrom(extendsCharSequence, extendsString).isNotAssignableFrom(extendsObject);\r\n    assertThatResolvableType(extendsCharSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\r\n    // ? super T <= ? super S if S <: T\r\n    assertThatResolvableType(superCharSequence).isAssignableFrom(superObject, superCharSequence).isNotAssignableFrom(superString);\r\n    assertThatResolvableType(superCharSequence).isAssignableFrom(object, charSequence).isNotAssignableFrom(string);\r\n    // [Implied] super / extends cannot be mixed\r\n    assertThatResolvableType(superCharSequence).isNotAssignableFrom(extendsObject, extendsCharSequence, extendsString);\r\n    assertThatResolvableType(extendsCharSequence).isNotAssignableFrom(superObject, superCharSequence, superString);\r\n    // T <= T\r\n    assertThatResolvableType(charSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\r\n    // T <= ? extends T\r\n    assertThatResolvableType(extendsCharSequence).isAssignableFrom(charSequence, string).isNotAssignableFrom(object);\r\n    assertThatResolvableType(charSequence).isAssignableFrom(extendsCharSequence, extendsString).isNotAssignableFrom(extendsObject);\r\n    assertThatResolvableType(extendsAnon).isAssignableFrom(object, charSequence, string);\r\n    // T <= ? super T\r\n    assertThatResolvableType(superCharSequence).isAssignableFrom(object, charSequence).isNotAssignableFrom(string);\r\n    assertThatResolvableType(charSequence).isNotAssignableFrom(superObject, superCharSequence, superString);\r\n}\n@Test\r\nvoid isAssignableFromForComplexWildcards() throws Exception {\r\n    ResolvableType complex1 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard1\"));\r\n    ResolvableType complex2 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard2\"));\r\n    ResolvableType complex3 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard3\"));\r\n    ResolvableType complex4 = ResolvableType.forField(AssignmentBase.class.getField(\"complexWildcard4\"));\r\n    assertThatResolvableType(complex1).isAssignableFrom(complex2);\r\n    assertThatResolvableType(complex2).isNotAssignableFrom(complex1);\r\n    assertThatResolvableType(complex3).isAssignableFrom(complex4);\r\n    assertThatResolvableType(complex4).isNotAssignableFrom(complex3);\r\n}\n@Test\r\nvoid isAssignableFromForUnresolvedWildcard() {\r\n    ResolvableType wildcard = ResolvableType.forInstance(new Wildcard<>());\r\n    ResolvableType wildcardFixed = ResolvableType.forInstance(new WildcardFixed());\r\n    ResolvableType wildcardConcrete = ResolvableType.forClassWithGenerics(Wildcard.class, CharSequence.class);\r\n    ResolvableType wildcardConsumer = ResolvableType.forInstance(new WildcardConsumer<>());\r\n    assertThat(wildcard.isAssignableFrom(wildcardFixed)).isTrue();\r\n    assertThat(wildcard.isAssignableFromResolvedPart(wildcardFixed)).isTrue();\r\n    assertThat(wildcard.isAssignableFrom(wildcardConcrete)).isTrue();\r\n    assertThat(wildcard.isAssignableFromResolvedPart(wildcardConcrete)).isTrue();\r\n    assertThat(wildcardFixed.isAssignableFrom(wildcard)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFromResolvedPart(wildcard)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFrom(wildcardConcrete)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFromResolvedPart(wildcardConcrete)).isFalse();\r\n    assertThat(wildcardConcrete.isAssignableFrom(wildcard)).isTrue();\r\n    assertThat(wildcardConcrete.isAssignableFromResolvedPart(wildcard)).isTrue();\r\n    assertThat(wildcardConcrete.isAssignableFrom(wildcardFixed)).isFalse();\r\n    assertThat(wildcardConcrete.isAssignableFromResolvedPart(wildcardFixed)).isFalse();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFrom(wildcard)).isFalse();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFromResolvedPart(wildcard)).isTrue();\r\n}\n@Test\r\nvoid isAssignableFromForUnresolvedDoubleWildcard() {\r\n    ResolvableType wildcard = ResolvableType.forInstance(new DoubleWildcard<>());\r\n    ResolvableType wildcardFixed = ResolvableType.forInstance(new DoubleWildcardFixed());\r\n    ResolvableType wildcardConsumer = ResolvableType.forInstance(new DoubleWildcardConsumer<>());\r\n    assertThat(wildcard.isAssignableFrom(wildcardFixed)).isTrue();\r\n    assertThat(wildcard.isAssignableFromResolvedPart(wildcardFixed)).isTrue();\r\n    assertThat(wildcardFixed.isAssignableFrom(wildcard)).isFalse();\r\n    assertThat(wildcardFixed.isAssignableFromResolvedPart(wildcard)).isFalse();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFrom(wildcard)).isTrue();\r\n    assertThat(wildcardConsumer.as(Consumer.class).getGeneric().isAssignableFromResolvedPart(wildcard)).isTrue();\r\n}\n@Test\r\nvoid strictGenericsMatching() {\r\n    ResolvableType consumerUnresolved = ResolvableType.forClass(Consumer.class);\r\n    ResolvableType consumerObject = ResolvableType.forClassWithGenerics(Consumer.class, Object.class);\r\n    ResolvableType consumerNestedUnresolved = ResolvableType.forClassWithGenerics(Consumer.class, ResolvableType.forClass(Consumer.class));\r\n    ResolvableType consumerNumber = ResolvableType.forClassWithGenerics(Consumer.class, Number.class);\r\n    ResolvableType consumerExtendsNumber = ResolvableType.forClass(SubConsumer.class);\r\n    assertThat(consumerUnresolved.isAssignableFrom(consumerObject)).isTrue();\r\n    assertThat(consumerUnresolved.isAssignableFromResolvedPart(consumerObject)).isTrue();\r\n    assertThat(consumerObject.isAssignableFrom(consumerUnresolved)).isTrue();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerUnresolved)).isTrue();\r\n    assertThat(consumerUnresolved.isAssignableFrom(consumerNestedUnresolved)).isTrue();\r\n    assertThat(consumerUnresolved.isAssignableFromResolvedPart(consumerNestedUnresolved)).isTrue();\r\n    assertThat(consumerObject.isAssignableFrom(consumerNestedUnresolved)).isFalse();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerNestedUnresolved)).isFalse();\r\n    assertThat(consumerObject.isAssignableFrom(consumerNumber)).isFalse();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerNumber)).isFalse();\r\n    assertThat(consumerObject.isAssignableFrom(consumerExtendsNumber)).isFalse();\r\n    assertThat(consumerObject.isAssignableFromResolvedPart(consumerExtendsNumber)).isTrue();\r\n}\n@Test\r\nvoid identifyTypeVariable() throws Exception {\r\n    Method method = ClassArguments.class.getMethod(\"typedArgumentFirst\", Class.class, Class.class, Class.class);\r\n    ResolvableType returnType = ResolvableType.forMethodReturnType(method, ClassArguments.class);\r\n    ResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, ClassArguments.class);\r\n    ResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, ClassArguments.class);\r\n    ResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, ClassArguments.class);\r\n    assertThat(returnType.getType().equals(arg0.as(Class.class).getGeneric(0).getType())).isTrue();\r\n    assertThat(returnType.getType().equals(arg1.as(Class.class).getGeneric(0).getType())).isFalse();\r\n    assertThat(returnType.getType().equals(arg2.as(Class.class).getGeneric(0).getType())).isFalse();\r\n}\n@Test\r\nvoid hashCodeAndEquals() throws Exception {\r\n    ResolvableType forClass = ResolvableType.forClass(List.class);\r\n    ResolvableType forFieldDirect = ResolvableType.forField(Fields.class.getDeclaredField(\"stringList\"));\r\n    ResolvableType forFieldViaType = ResolvableType.forType(Fields.class.getDeclaredField(\"stringList\").getGenericType(), (VariableResolver) null);\r\n    ResolvableType forFieldWithImplementation = ResolvableType.forField(Fields.class.getDeclaredField(\"stringList\"), TypedFields.class);\r\n    assertThat(forClass).isEqualTo(forClass);\r\n    assertThat(forClass.hashCode()).isEqualTo(forClass.hashCode());\r\n    assertThat(forClass).isNotEqualTo(forFieldDirect);\r\n    assertThat(forClass).isNotEqualTo(forFieldWithImplementation);\r\n    assertThat(forFieldDirect).isEqualTo(forFieldDirect);\r\n    assertThat(forFieldDirect).isNotEqualTo(forFieldViaType);\r\n    assertThat(forFieldDirect).isNotEqualTo(forFieldWithImplementation);\r\n}\n@Test\r\nvoid javaDocSample() throws Exception {\r\n    ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\"myMap\"));\r\n    assertThat(t.toString()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getType().getTypeName()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getType().toString()).isEqualTo(\"java.util.HashMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getSuperType().toString()).isEqualTo(\"java.util.AbstractMap<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.asMap().toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n    assertThat(t.getGeneric(0).resolve()).isEqualTo(Integer.class);\r\n    assertThat(t.getGeneric(1).resolve()).isEqualTo(List.class);\r\n    assertThat(t.getGeneric(1).toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n    assertThat(t.resolveGeneric(1, 0)).isEqualTo(String.class);\r\n}\n@Test\r\nvoid forClassWithGenerics() {\r\n    ResolvableType elementType = ResolvableType.forClassWithGenerics(Map.class, Integer.class, String.class);\r\n    ResolvableType listType = ResolvableType.forClassWithGenerics(List.class, elementType);\r\n    assertThat(listType.toString()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\r\n    assertThat(listType.getType().getTypeName()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\r\n    assertThat(listType.getType().toString()).isEqualTo(\"java.util.List<java.util.Map<java.lang.Integer, java.lang.String>>\");\r\n}\n@Test\r\nvoid classWithGenericsAs() {\r\n    ResolvableType type = ResolvableType.forClassWithGenerics(MultiValueMap.class, Integer.class, String.class);\r\n    assertThat(type.asMap().toString()).isEqualTo(\"java.util.Map<java.lang.Integer, java.util.List<java.lang.String>>\");\r\n}\n@Test\r\nvoid forClassWithMismatchedGenerics() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forClassWithGenerics(Map.class, Integer.class)).withMessageContaining(\"Mismatched number of generics specified for\").withMessageContaining(\"java.util.Map<K,V>\");\r\n}\n@Test\r\nvoid forArrayComponent() throws Exception {\r\n    ResolvableType elementType = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    ResolvableType type = ResolvableType.forArrayComponent(elementType);\r\n    assertThat(type.toString()).isEqualTo(\"java.util.List<java.lang.String>[]\");\r\n    assertThat(type.resolve()).isEqualTo(List[].class);\r\n}\n@Test\r\nvoid serialize() throws Exception {\r\n    testSerialization(ResolvableType.forClass(List.class));\r\n    testSerialization(ResolvableType.forField(Fields.class.getField(\"charSequenceList\")));\r\n    testSerialization(ResolvableType.forMethodParameter(Methods.class.getMethod(\"charSequenceParameter\", List.class), 0));\r\n    testSerialization(ResolvableType.forMethodReturnType(Methods.class.getMethod(\"charSequenceReturn\")));\r\n    testSerialization(ResolvableType.forConstructorParameter(Constructors.class.getConstructor(List.class), 0));\r\n    testSerialization(ResolvableType.forField(Fields.class.getField(\"charSequenceList\")).getGeneric());\r\n    ResolvableType deserializedNone = testSerialization(ResolvableType.NONE);\r\n    assertThat(deserializedNone).isSameAs(ResolvableType.NONE);\r\n}\n@Test\r\nvoid canResolveVoid() {\r\n    ResolvableType type = ResolvableType.forClass(void.class);\r\n    assertThat(type.resolve()).isEqualTo(void.class);\r\n}\n@Test\r\nvoid narrow() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    ResolvableType narrow = ResolvableType.forType(ArrayList.class, type);\r\n    assertThat(narrow.getGeneric().resolve()).isEqualTo(String.class);\r\n}\n@Test\r\nvoid hasResolvableGenerics() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.hasResolvableGenerics()).isTrue();\r\n}\n@Test\r\nvoid hasResolvableGenericsWithSingleBoundedWildcard() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\r\n    assertThat(type.hasResolvableGenerics()).isTrue();\r\n}\n@Test\r\nvoid hasResolvableGenericsWithSingleParameterizedType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.hasResolvableGenerics()).isFalse();\r\n}\n@Test\r\nvoid hasResolvableGenericsWithSingleWildcard() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"anyListElement\"));\r\n    assertThat(type.hasResolvableGenerics()).isFalse();\r\n}\n@Test\r\nvoid hasUnresolvableGenerics() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsBasedOnOwnGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(List.class);\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsWhenSelfNotResolvable() {\r\n    ResolvableType type = ResolvableType.forClass(List.class).getGeneric();\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsWhenImplementingRawInterface() {\r\n    ResolvableType type = ResolvableType.forClass(MySimpleInterfaceTypeWithImplementsRaw.class);\r\n    for (ResolvableType generic : type.getGenerics()) {\r\n        assertThat(generic.resolve()).isNotNull();\r\n    }\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsWhenExtends() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsMySimpleInterfaceTypeWithImplementsRaw.class);\r\n    for (ResolvableType generic : type.getGenerics()) {\r\n        assertThat(generic.resolve()).isNotNull();\r\n    }\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsWhenNested() throws Exception {\r\n    ResolvableType type = ResolvableType.forMethodReturnType(ListOfListSupplier.class.getMethod(\"get\"));\r\n    assertThat(type.hasUnresolvableGenerics()).isTrue();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsWhenSelfReferring() {\r\n    ResolvableType type = ResolvableType.forInstance(new Bar());\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}\n@Test\r\nvoid hasUnresolvableGenericsWithEnum() {\r\n    ResolvableType type = ResolvableType.forType(SimpleEnum.class.getGenericSuperclass());\r\n    assertThat(type.hasUnresolvableGenerics()).isFalse();\r\n}\n// gh-33932\r\n@Test\r\nvoid recursiveType() {\r\n    assertThat(ResolvableType.forClass(RecursiveMap.class)).isEqualTo(ResolvableType.forClass(RecursiveMap.class));\r\n    ResolvableType resolvableType1 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMap.class);\r\n    ResolvableType resolvableType2 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMap.class);\r\n    assertThat(resolvableType1).isEqualTo(resolvableType2);\r\n}\n// gh-33932\r\n@Test\r\nvoid recursiveTypeWithInterface() {\r\n    assertThat(ResolvableType.forClass(RecursiveMapWithInterface.class)).isEqualTo(ResolvableType.forClass(RecursiveMapWithInterface.class));\r\n    ResolvableType resolvableType1 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMapWithInterface.class);\r\n    ResolvableType resolvableType2 = ResolvableType.forClassWithGenerics(Map.class, String.class, RecursiveMapWithInterface.class);\r\n    assertThat(resolvableType1).isEqualTo(resolvableType2);\r\n}\n@Test\r\nvoid spr11219() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(BaseProvider.class.getField(\"stuff\"), BaseProvider.class);\r\n    assertThat(type.getNested(2).isAssignableFrom(ResolvableType.forClass(BaseImplementation.class))).isTrue();\r\n    assertThat(type.toString()).isEqualTo(\"java.util.Collection<org.springframework.core.ResolvableTypeTests$IBase<?>>\");\r\n}\n@Test\r\nvoid spr12701() {\r\n    ResolvableType resolvableType = ResolvableType.forClassWithGenerics(Callable.class, String.class);\r\n    Type type = resolvableType.getType();\r\n    assertThat(type).isInstanceOf(ParameterizedType.class);\r\n    assertThat(((ParameterizedType) type).getRawType()).isEqualTo(Callable.class);\r\n    assertThat(((ParameterizedType) type).getActualTypeArguments()).hasSize(1);\r\n    assertThat(((ParameterizedType) type).getActualTypeArguments()[0]).isEqualTo(String.class);\r\n}\n@Test\r\nvoid spr14648() throws Exception {\r\n    ResolvableType collectionClass = ResolvableType.forRawClass(Collection.class);\r\n    ResolvableType setClass = ResolvableType.forRawClass(Set.class);\r\n    ResolvableType fromReturnType = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"wildcardSet\"));\r\n    assertThat(collectionClass.isAssignableFrom(fromReturnType)).isTrue();\r\n    assertThat(setClass.isAssignableFrom(fromReturnType)).isTrue();\r\n}\n@Test\r\nvoid spr16456() throws Exception {\r\n    ResolvableType genericType = ResolvableType.forField(UnresolvedWithGenerics.class.getDeclaredField(\"set\")).asCollection();\r\n    ResolvableType type = ResolvableType.forClassWithGenerics(ArrayList.class, genericType.getGeneric());\r\n    assertThat(type.resolveGeneric()).isEqualTo(Integer.class);\r\n}\n@Test\r\nvoid gh22902() throws Exception {\r\n    ResolvableType ab = ResolvableType.forField(ABClient.class.getField(\"field\"));\r\n    assertThat(ab.isAssignableFrom(Object.class)).isFalse();\r\n    assertThat(ab.isAssignableFrom(AwithB.class)).isTrue();\r\n    assertThat(ab.isAssignableFrom(AwithoutB.class)).isFalse();\r\n}\n@Test\r\nvoid gh32327() throws Exception {\r\n    ResolvableType repository1 = ResolvableType.forField(Fields.class.getField(\"repository\"));\r\n    ResolvableType repository2 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"someRepository\"));\r\n    ResolvableType repository3 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"subRepository\"));\r\n    assertThat(repository1.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(repository1.isAssignableFrom(repository2)).isFalse();\r\n    assertThat(repository1.isAssignableFromResolvedPart(repository2)).isTrue();\r\n    assertThat(repository1.isAssignableFrom(repository3)).isTrue();\r\n    assertThat(repository1.isAssignableFromResolvedPart(repository3)).isTrue();\r\n    assertThat(repository2.hasUnresolvableGenerics()).isTrue();\r\n    assertThat(repository2.isAssignableFrom(repository1)).isTrue();\r\n    assertThat(repository2.isAssignableFromResolvedPart(repository1)).isTrue();\r\n    assertThat(repository3.hasUnresolvableGenerics()).isTrue();\r\n    assertThat(repository3.isAssignableFrom(repository1)).isFalse();\r\n    assertThat(repository3.isAssignableFromResolvedPart(repository1)).isFalse();\r\n}\n@Test\r\nvoid gh33535() throws Exception {\r\n    ResolvableType repository1 = ResolvableType.forField(Fields.class.getField(\"stringRepository\"));\r\n    ResolvableType repository2 = ResolvableType.forField(Fields.class.getField(\"arrayRepository\"));\r\n    ResolvableType repository3 = ResolvableType.forMethodReturnType(Methods.class.getMethod(\"someRepository\"));\r\n    assertThat(repository1.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(repository1.isAssignableFrom(repository3)).isFalse();\r\n    assertThat(repository1.isAssignableFromResolvedPart(repository3)).isTrue();\r\n    assertThat(repository3.isAssignableFrom(repository1)).isTrue();\r\n    assertThat(repository3.isAssignableFromResolvedPart(repository1)).isTrue();\r\n    assertThat(repository2.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(repository2.isAssignableFrom(repository3)).isFalse();\r\n    assertThat(repository2.isAssignableFromResolvedPart(repository3)).isTrue();\r\n    assertThat(repository3.isAssignableFrom(repository2)).isTrue();\r\n    assertThat(repository3.isAssignableFromResolvedPart(repository2)).isTrue();\r\n}\nprivate ResolvableType testSerialization(ResolvableType type) throws Exception {\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    ObjectOutputStream oos = new ObjectOutputStream(bos);\r\n    oos.writeObject(type);\r\n    oos.close();\r\n    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\r\n    ResolvableType read = (ResolvableType) ois.readObject();\r\n    assertThat(read).isEqualTo(type);\r\n    assertThat(read.getType()).isEqualTo(type.getType());\r\n    assertThat(read.resolve()).isEqualTo(type.resolve());\r\n    return read;\r\n}\nprivate ResolvableType forField(String field) throws NoSuchFieldException {\r\n    return ResolvableType.forField(Fields.class.getField(field));\r\n}\nprivate ResolvableType forTypedField(String field) throws NoSuchFieldException {\r\n    return ResolvableType.forField(Fields.class.getField(field), TypedFields.class);\r\n}\nprivate static ResolvableTypeAssert assertThatResolvableType(ResolvableType type) {\r\n    return new ResolvableTypeAssert(type);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate HashMap<Integer, List<String>> myMap;\n@SuppressWarnings(\"serial\")\r\nstatic class ExtendsList extends ArrayList<CharSequence> {\r\n}\n@SuppressWarnings(\"serial\")\r\nstatic class ExtendsMap extends HashMap<String, Integer> {\r\n}\ninterface SomeRepository<S extends Serializable> {\r\n\r\n    <T> T someMethod(Class<T> arg0, Class<?> arg1, Class<Object> arg2);\r\n}\ninterface SubRepository<S extends Serializable> extends SomeRepository {\r\n}\nstatic class Fields<T> {\r\n\r\n    public List classType;\r\n\r\n    public T typeVariableType;\r\n\r\n    public List<T> parameterizedType;\r\n\r\n    public List[] arrayClassType;\r\n\r\n    public List<String>[] genericArrayType;\r\n\r\n    public List<String>[][][] genericMultiArrayType;\r\n\r\n    public List<?> anyListElement;\r\n\r\n    public List<? extends Number> wildcardType;\r\n\r\n    public List<? super Number> wildcardSuperType = new ArrayList<Object>();\r\n\r\n    public List<CharSequence> charSequenceList;\r\n\r\n    public List<String> stringList;\r\n\r\n    public List<List<String>> stringListList;\r\n\r\n    public List<String[]> stringArrayList;\r\n\r\n    public MultiValueMap<String, Integer> stringIntegerMultiValueMap;\r\n\r\n    public VariableNameSwitch<Integer, String> stringIntegerMultiValueMapSwitched;\r\n\r\n    public List<List> listOfListOfUnknown;\r\n\r\n    @SuppressWarnings(\"unused\")\r\n    private List<String> privateField;\r\n\r\n    @SuppressWarnings(\"unused\")\r\n    private List<String> otherPrivateField;\r\n\r\n    public Map<Map<String, Integer>, Map<Byte, Long>> nested;\r\n\r\n    public T[] variableTypeGenericArray;\r\n\r\n    public Integer[] integerArray;\r\n\r\n    public int[] intArray;\r\n\r\n    public SomeRepository<? extends Serializable> repository;\r\n\r\n    public SomeRepository<String> stringRepository;\r\n\r\n    public SomeRepository<String[]> arrayRepository;\r\n}\nstatic class TypedFields extends Fields<String> {\r\n}\ninterface Methods<T> {\r\n\r\n    List<CharSequence> charSequenceReturn();\r\n\r\n    void charSequenceParameter(List<CharSequence> cs);\r\n\r\n    <R extends CharSequence & Serializable> R boundedTypeVariableResult();\r\n\r\n    Map<String, ? extends List<? extends CharSequence>> boundedTypeVariableWildcardResult();\r\n\r\n    void nested(Map<Map<String, Integer>, Map<Byte, Long>> p);\r\n\r\n    void typedParameter(T p);\r\n\r\n    T typedReturn();\r\n\r\n    Set<?> wildcardSet();\r\n\r\n    List<String> list1();\r\n\r\n    List<String> list2();\r\n\r\n    SomeRepository<?> someRepository();\r\n\r\n    SubRepository<?> subRepository();\r\n}\ninterface TypedMethods extends Methods<String> {\r\n}\nstatic class AssignmentBase<O, C, S extends Serializable> {\r\n\r\n    public O o;\r\n\r\n    public C c;\r\n\r\n    public S s;\r\n\r\n    public List<O> listo;\r\n\r\n    public List<C> listc;\r\n\r\n    public List<S> lists;\r\n\r\n    public List<?> listAnon;\r\n\r\n    public List<? extends O> listxo;\r\n\r\n    public List<? extends C> listxc;\r\n\r\n    public List<? extends S> listxs;\r\n\r\n    public List<? super O> listso;\r\n\r\n    public List<? super C> listsc;\r\n\r\n    public List<? super S> listss;\r\n\r\n    public O[] oarray;\r\n\r\n    public C[] carray;\r\n\r\n    public S[] sarray;\r\n\r\n    public Collection<C> collectionc;\r\n\r\n    public Collection<? extends C> collectionxc;\r\n\r\n    public Map<? super Integer, List<String>> complexWildcard1;\r\n\r\n    public MultiValueMap<Number, String> complexWildcard2;\r\n\r\n    public Collection<? extends Collection<? extends CharSequence>> complexWildcard3;\r\n\r\n    public List<List<String>> complexWildcard4;\r\n}\nstatic class Assignment extends AssignmentBase<Object, CharSequence, String> {\r\n}\ninterface ClassArguments {\r\n\r\n    <T> T typedArgumentFirst(Class<T> arg0, Class<?> arg1, Class<Object> arg2);\r\n}\nstatic class Constructors<T> {\r\n\r\n    public Constructors(List<CharSequence> p) {\r\n    }\r\n\r\n    public Constructors(Map<T, Long> p) {\r\n    }\r\n}\nstatic class TypedConstructors extends Constructors<String> {\r\n\r\n    public TypedConstructors(List<CharSequence> p) {\r\n        super(p);\r\n    }\r\n\r\n    public TypedConstructors(Map<String, Long> p) {\r\n        super(p);\r\n    }\r\n}\npublic interface MyInterfaceType<T> {\r\n}\npublic class MyGenericInterfaceType<T> implements MyInterfaceType<T>, ResolvableTypeProvider {\r\n\r\n    private final Class<T> type;\r\n\r\n    public MyGenericInterfaceType(Class<T> type) {\r\n        this.type = type;\r\n    }\r\n\r\n    @Override\r\n    public ResolvableType getResolvableType() {\r\n        if (this.type == null) {\r\n            return null;\r\n        }\r\n        return ResolvableType.forClassWithGenerics(getClass(), this.type);\r\n    }\r\n}\npublic class MySimpleInterfaceType implements MyInterfaceType<String> {\r\n}\npublic abstract class MySimpleInterfaceTypeWithImplementsRaw implements MyInterfaceType<String>, List {\r\n}\npublic abstract class ExtendsMySimpleInterfaceTypeWithImplementsRaw extends MySimpleInterfaceTypeWithImplementsRaw {\r\n}\npublic class MyCollectionInterfaceType implements MyInterfaceType<Collection<String>> {\r\n}\npublic abstract class MySuperclassType<T> {\r\n}\npublic class MySimpleSuperclassType extends MySuperclassType<String> {\r\n}\npublic class MyCollectionSuperclassType extends MySuperclassType<Collection<String>> {\r\n}\npublic interface Consumer<T> {\r\n}\nprivate static class SubConsumer<N extends Number> implements Consumer<N> {\r\n}\npublic class Wildcard<T extends CharSequence> {\r\n}\npublic class WildcardFixed extends Wildcard<String> {\r\n}\npublic class WildcardConsumer<T extends CharSequence & Serializable> implements Consumer<Wildcard<T>> {\r\n}\npublic class DoubleWildcard<T extends CharSequence & Serializable> {\r\n}\npublic class DoubleWildcardFixed extends DoubleWildcard<String> {\r\n}\npublic class DoubleWildcardConsumer<T extends CharSequence & Serializable> implements Consumer<DoubleWildcard<T>> {\r\n}\ninterface VariableNameSwitch<V, K> extends MultiValueMap<K, V> {\r\n}\ninterface ListOfGenericArray extends List<List<String>[]> {\r\n}\ninterface ListOfListSupplier<T> {\r\n\r\n    List<List<T>> get();\r\n}\nclass Foo<T extends Foo<T>> {\r\n}\nclass Bar extends Foo<Bar> {\r\n}\nenum SimpleEnum {\r\n\r\n    VALUE\r\n}\nstatic class EnclosedInParameterizedType<T> {\r\n\r\n    static class InnerRaw {\r\n    }\r\n\r\n    class InnerTyped<Y> {\r\n\r\n        public T field;\r\n    }\r\n}\nstatic class TypedEnclosedInParameterizedType extends EnclosedInParameterizedType<Integer> {\r\n\r\n    class TypedInnerTyped extends InnerTyped<Long> {\r\n    }\r\n}\npublic interface IProvider<P> {\r\n}\npublic interface IBase<BT extends IBase<BT>> {\r\n}\npublic abstract class AbstractBase<BT extends IBase<BT>> implements IBase<BT> {\r\n}\npublic class BaseImplementation extends AbstractBase<BaseImplementation> {\r\n}\npublic class BaseProvider<BT extends IBase<BT>> implements IProvider<IBase<BT>> {\r\n\r\n    public Collection<IBase<BT>> stuff;\r\n}\npublic abstract class UnresolvedWithGenerics {\r\n\r\n    Set<Integer> set;\r\n}\ninterface A {\r\n\r\n    void doA();\r\n}\ninterface B {\r\n\r\n    void doB();\r\n}\nstatic class ABClient<T extends A & B> {\r\n\r\n    public T field;\r\n}\nstatic class AwithB implements A, B {\r\n\r\n    @Override\r\n    public void doA() {\r\n    }\r\n\r\n    @Override\r\n    public void doB() {\r\n    }\r\n}\nstatic class AwithoutB implements A {\r\n\r\n    @Override\r\n    public void doA() {\r\n    }\r\n}\n@SuppressWarnings(\"serial\")\r\nstatic class RecursiveMap extends HashMap<String, RecursiveMap> {\r\n}\n@SuppressWarnings(\"serial\")\r\nstatic class RecursiveMapWithInterface extends HashMap<String, RecursiveMapWithInterface> implements Map<String, RecursiveMapWithInterface> {\r\n}\nprivate static class ResolvableTypeAssert extends AbstractAssert<ResolvableTypeAssert, ResolvableType> {\r\n\r\n    public ResolvableTypeAssert(ResolvableType actual) {\r\n        super(actual, ResolvableTypeAssert.class);\r\n    }\r\n\r\n    public ResolvableTypeAssert isAssignableFrom(ResolvableType... types) {\r\n        for (ResolvableType type : types) {\r\n            if (!actual.isAssignableFrom(type)) {\r\n                throw new AssertionError(\"Expecting \" + describe(actual) + \" to be assignable from \" + describe(type));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public ResolvableTypeAssert isNotAssignableFrom(ResolvableType... types) {\r\n        for (ResolvableType type : types) {\r\n            if (actual.isAssignableFrom(type)) {\r\n                throw new AssertionError(\"Expecting \" + describe(actual) + \" to not be assignable from \" + describe(type));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private String describe(ResolvableType type) {\r\n        if (type == ResolvableType.NONE) {\r\n            return \"NONE\";\r\n        }\r\n        if (type.getType().getClass().equals(Class.class)) {\r\n            return type.toString();\r\n        }\r\n        return type.getType() + \":\" + type;\r\n    }\r\n}",
    "comment": "\n * Tests for {@link ResolvableType}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sebastien Deleuze\n * @author Yanming Zhou\n "
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#noneReturnValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid noneReturnValues() {\r\n    ResolvableType none = ResolvableType.NONE;\r\n    assertThat(none.as(Object.class)).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.asCollection()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.asMap()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getComponentType()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getGeneric(0)).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getGenerics()).isEmpty();\r\n    assertThat(none.getInterfaces()).isEmpty();\r\n    assertThat(none.getSuperType()).isEqualTo(ResolvableType.NONE);\r\n    assertThat(none.getType()).isEqualTo(ResolvableType.EmptyType.INSTANCE);\r\n    assertThat(none.hasGenerics()).isFalse();\r\n    assertThat(none.isArray()).isFalse();\r\n    assertThat(none.resolve()).isNull();\r\n    assertThat(none.resolve(String.class)).isEqualTo(String.class);\r\n    assertThat(none.resolveGeneric(0)).isNull();\r\n    assertThat(none.resolveGenerics()).isEmpty();\r\n    assertThat(none.toString()).isEqualTo(\"?\");\r\n    assertThat(none.hasUnresolvableGenerics()).isFalse();\r\n    assertThat(none.isAssignableFrom(ResolvableType.forClass(Object.class))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid forClass() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.getType()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.getRawClass()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.isAssignableFrom(ExtendsList.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(ArrayList.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forClassWithNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forClassWithNull() {\r\n    ResolvableType type = ResolvableType.forClass(null);\r\n    assertThat(type.getType()).isEqualTo(Object.class);\r\n    assertThat(type.getRawClass()).isEqualTo(Object.class);\r\n    assertThat(type.isAssignableFrom(Object.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(String.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forRawClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid forRawClass() {\r\n    ResolvableType type = ResolvableType.forRawClass(ExtendsList.class);\r\n    assertThat(type.getType()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.getRawClass()).isEqualTo(ExtendsList.class);\r\n    assertThat(type.isAssignableFrom(ExtendsList.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(ArrayList.class)).isFalse();\r\n    assertThat(type).isNotEqualTo(ResolvableType.forClass(ExtendsList.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forRawClassWithNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forRawClassWithNull() {\r\n    ResolvableType type = ResolvableType.forRawClass(null);\r\n    assertThat(type.getType()).isEqualTo(Object.class);\r\n    assertThat(type.getRawClass()).isEqualTo(Object.class);\r\n    assertThat(type.isAssignableFrom(Object.class)).isTrue();\r\n    assertThat(type.isAssignableFrom(String.class)).isTrue();\r\n    assertThat(type).isNotEqualTo(ResolvableType.forClass(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forRawClassAssignableFromTypeVariable()",
    "entityType": "method",
    "code": "// gh-23321\r\n@Test\r\nvoid forRawClassAssignableFromTypeVariable() {\r\n    ResolvableType typeVariable = ResolvableType.forClass(ExtendsList.class).as(List.class).getGeneric();\r\n    ResolvableType raw = ResolvableType.forRawClass(CharSequence.class);\r\n    assertThat(raw.resolve()).isEqualTo(CharSequence.class);\r\n    assertThat(typeVariable.resolve()).isEqualTo(CharSequence.class);\r\n    assertThat(raw.resolve().isAssignableFrom(typeVariable.resolve())).isTrue();\r\n    assertThat(typeVariable.resolve().isAssignableFrom(raw.resolve())).isTrue();\r\n    assertThat(raw.isAssignableFrom(typeVariable)).isTrue();\r\n    assertThat(typeVariable.isAssignableFrom(raw)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forInstanceNull()",
    "entityType": "method",
    "code": "// gh-28776\r\n@Test\r\nvoid forInstanceNull() {\r\n    assertThat(ResolvableType.forInstance(null)).isEqualTo(ResolvableType.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forInstanceNoProvider()",
    "entityType": "method",
    "code": "@Test\r\nvoid forInstanceNoProvider() {\r\n    ResolvableType type = ResolvableType.forInstance(new Object());\r\n    assertThat(type.getType()).isEqualTo(Object.class);\r\n    assertThat(type.resolve()).isEqualTo(Object.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forInstanceProvider()",
    "entityType": "method",
    "code": "@Test\r\nvoid forInstanceProvider() {\r\n    ResolvableType type = ResolvableType.forInstance(new MyGenericInterfaceType<>(String.class));\r\n    assertThat(type.getRawClass()).isEqualTo(MyGenericInterfaceType.class);\r\n    assertThat(type.getGeneric().resolve()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forInstanceProviderNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forInstanceProviderNull() {\r\n    ResolvableType type = ResolvableType.forInstance(new MyGenericInterfaceType<>(null));\r\n    assertThat(type.getType()).isEqualTo(MyGenericInterfaceType.class);\r\n    assertThat(type.resolve()).isEqualTo(MyGenericInterfaceType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forField()",
    "entityType": "method",
    "code": "@Test\r\nvoid forField() throws Exception {\r\n    Field field = Fields.class.getField(\"charSequenceList\");\r\n    ResolvableType type = ResolvableType.forField(field);\r\n    assertThat(type.getType()).isEqualTo(field.getGenericType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forPrivateField()",
    "entityType": "method",
    "code": "@Test\r\nvoid forPrivateField() throws Exception {\r\n    Field field = Fields.class.getDeclaredField(\"privateField\");\r\n    ResolvableType type = ResolvableType.forField(field);\r\n    assertThat(type.getType()).isEqualTo(field.getGenericType());\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.getSource()).isSameAs(field);\r\n    Field field2 = Fields.class.getDeclaredField(\"otherPrivateField\");\r\n    ResolvableType type2 = ResolvableType.forField(field2);\r\n    assertThat(type2.getType()).isEqualTo(field2.getGenericType());\r\n    assertThat(type2.resolve()).isEqualTo(List.class);\r\n    assertThat(type2.getSource()).isSameAs(field2);\r\n    assertThat(type2).isEqualTo(type);\r\n    assertThat(type2.hashCode()).isEqualTo(type.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forFieldMustNotBeNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forFieldMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forField(null)).withMessage(\"Field must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forConstructorParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid forConstructorParameter() throws Exception {\r\n    Constructor<Constructors> constructor = Constructors.class.getConstructor(List.class);\r\n    ResolvableType type = ResolvableType.forConstructorParameter(constructor, 0);\r\n    assertThat(type.getType()).isEqualTo(constructor.getGenericParameterTypes()[0]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forConstructorParameterMustNotBeNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forConstructorParameterMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forConstructorParameter(null, 0)).withMessage(\"Constructor must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameterByIndex()",
    "entityType": "method",
    "code": "@Test\r\nvoid forMethodParameterByIndex() throws Exception {\r\n    Method method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\r\n    ResolvableType type = ResolvableType.forMethodParameter(method, 0);\r\n    assertThat(type.getType()).isEqualTo(method.getGenericParameterTypes()[0]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameterByIndexMustNotBeNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forMethodParameterByIndexMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forMethodParameter(null, 0)).withMessage(\"Method must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameter()",
    "entityType": "method",
    "code": "@Test\r\nvoid forMethodParameter() throws Exception {\r\n    Method method = Methods.class.getMethod(\"charSequenceParameter\", List.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.getType()).isEqualTo(method.getGenericParameterTypes()[0]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameterWithNesting()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid forMethodParameterWithNesting() throws Exception {\r\n    Method method = Methods.class.getMethod(\"nested\", Map.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    methodParameter.increaseNestingLevel();\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(Byte.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Long.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameterWithNestingAndLevels()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid forMethodParameterWithNestingAndLevels() throws Exception {\r\n    Method method = Methods.class.getMethod(\"nested\", Map.class);\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, 0);\r\n    methodParameter.increaseNestingLevel();\r\n    methodParameter.setTypeIndexForCurrentLevel(0);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameterMustNotBeNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forMethodParameterMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forMethodParameter(null)).withMessage(\"MethodParameter must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodParameterWithSameSignatureAndGenerics()",
    "entityType": "method",
    "code": "// SPR-16210\r\n@Test\r\nvoid forMethodParameterWithSameSignatureAndGenerics() throws Exception {\r\n    Method method = Methods.class.getMethod(\"list1\");\r\n    MethodParameter methodParameter = MethodParameter.forExecutable(method, -1);\r\n    ResolvableType type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(((MethodParameter) type.getSource()).getMethod()).isEqualTo(method);\r\n    method = Methods.class.getMethod(\"list2\");\r\n    methodParameter = MethodParameter.forExecutable(method, -1);\r\n    type = ResolvableType.forMethodParameter(methodParameter);\r\n    assertThat(((MethodParameter) type.getSource()).getMethod()).isEqualTo(method);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodReturn()",
    "entityType": "method",
    "code": "@Test\r\nvoid forMethodReturn() throws Exception {\r\n    Method method = Methods.class.getMethod(\"charSequenceReturn\");\r\n    ResolvableType type = ResolvableType.forMethodReturnType(method);\r\n    assertThat(type.getType()).isEqualTo(method.getGenericReturnType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#forMethodReturnMustNotBeNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid forMethodReturnMustNotBeNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> ResolvableType.forMethodReturnType(null)).withMessage(\"Method must not be null\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#genericMatchesReturnType()",
    "entityType": "method",
    "code": "// gh-27748\r\n@Test\r\nvoid genericMatchesReturnType() throws Exception {\r\n    Method method = SomeRepository.class.getMethod(\"someMethod\", Class.class, Class.class, Class.class);\r\n    ResolvableType returnType = ResolvableType.forMethodReturnType(method, SomeRepository.class);\r\n    // generic[0]=T\r\n    ResolvableType arg0 = ResolvableType.forMethodParameter(method, 0, SomeRepository.class);\r\n    // generic[0]=?\r\n    ResolvableType arg1 = ResolvableType.forMethodParameter(method, 1, SomeRepository.class);\r\n    // generic[0]=java.lang.Object\r\n    ResolvableType arg2 = ResolvableType.forMethodParameter(method, 2, SomeRepository.class);\r\n    assertThat(returnType.equalsType(arg0.as(Class.class).getGeneric(0))).isTrue();\r\n    assertThat(returnType.equalsType(arg1.as(Class.class).getGeneric(0))).isFalse();\r\n    assertThat(returnType.equalsType(arg2.as(Class.class).getGeneric(0))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#classType()",
    "entityType": "method",
    "code": "@Test\r\nvoid classType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"classType\"));\r\n    assertThat(type.getType().getClass()).isEqualTo(Class.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#parameterizedType()",
    "entityType": "method",
    "code": "@Test\r\nvoid parameterizedType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.getType()).isInstanceOf(ParameterizedType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#arrayClassType()",
    "entityType": "method",
    "code": "@Test\r\nvoid arrayClassType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"arrayClassType\"));\r\n    assertThat(type.getType()).isInstanceOf(Class.class);\r\n    assertThat(((Class) type.getType()).isArray()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#genericArrayType()",
    "entityType": "method",
    "code": "@Test\r\nvoid genericArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    assertThat(type.getType()).isInstanceOf(GenericArrayType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#wildcardType()",
    "entityType": "method",
    "code": "@Test\r\nvoid wildcardType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"wildcardType\"));\r\n    assertThat(type.getType()).isInstanceOf(ParameterizedType.class);\r\n    assertThat(type.getGeneric().getType()).isInstanceOf(WildcardType.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#typeVariableType()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeVariableType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"typeVariableType\"));\r\n    assertThat(type.getType()).isInstanceOf(TypeVariable.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getComponentTypeForClassArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComponentTypeForClassArray() throws Exception {\r\n    Field field = Fields.class.getField(\"arrayClassType\");\r\n    ResolvableType type = ResolvableType.forField(field);\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.getComponentType().getType()).isEqualTo(((Class) field.getGenericType()).componentType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getComponentTypeForGenericArrayType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComponentTypeForGenericArrayType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.getComponentType().getType()).isEqualTo(((GenericArrayType) type.getType()).getGenericComponentType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getComponentTypeForVariableThatResolvesToGenericArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComponentTypeForVariableThatResolvesToGenericArray() {\r\n    ResolvableType type = ResolvableType.forClass(ListOfGenericArray.class).asCollection().getGeneric();\r\n    assertThat(type.isArray()).isTrue();\r\n    assertThat(type.getType()).isInstanceOf(TypeVariable.class);\r\n    assertThat(type.getComponentType().getType().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getComponentTypeForNonArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComponentTypeForNonArray() {\r\n    ResolvableType type = ResolvableType.forClass(String.class);\r\n    assertThat(type.isArray()).isFalse();\r\n    assertThat(type.getComponentType()).isEqualTo(ResolvableType.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asCollection()",
    "entityType": "method",
    "code": "@Test\r\nvoid asCollection() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).asCollection();\r\n    assertThat(type.resolve()).isEqualTo(Collection.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid asMap() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsMap.class).asMap();\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.resolveGeneric(0)).isEqualTo(String.class);\r\n    assertThat(type.resolveGeneric(1)).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asFromInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid asFromInterface() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(List.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.List<E>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asFromInheritedInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid asFromInheritedInterface() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(Collection.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.Collection<E>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asFromSuperType()",
    "entityType": "method",
    "code": "@Test\r\nvoid asFromSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(ArrayList.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.ArrayList<java.lang.CharSequence>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asFromInheritedSuperType()",
    "entityType": "method",
    "code": "@Test\r\nvoid asFromInheritedSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(List.class);\r\n    assertThat(type.getType().toString()).isEqualTo(\"java.util.List<E>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asNotFound()",
    "entityType": "method",
    "code": "@Test\r\nvoid asNotFound() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).as(Map.class);\r\n    assertThat(type).isSameAs(ResolvableType.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#asSelf()",
    "entityType": "method",
    "code": "@Test\r\nvoid asSelf() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.as(ExtendsList.class)).isEqualTo(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getSuperType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSuperType() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class).getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(ArrayList.class);\r\n    type = type.getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(AbstractList.class);\r\n    type = type.getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(AbstractCollection.class);\r\n    type = type.getSuperType();\r\n    assertThat(type.resolve()).isEqualTo(Object.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getInterfaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInterfaces() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.getInterfaces()).isEmpty();\r\n    SortedSet<String> interfaces = new TreeSet<>();\r\n    for (ResolvableType interfaceType : type.getSuperType().getInterfaces()) {\r\n        interfaces.add(interfaceType.toString());\r\n    }\r\n    assertThat(interfaces.toString()).isEqualTo(\"[java.io.Serializable, java.lang.Cloneable, \" + \"java.util.List<java.lang.CharSequence>, java.util.RandomAccess]\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#noSuperType()",
    "entityType": "method",
    "code": "@Test\r\nvoid noSuperType() {\r\n    assertThat(ResolvableType.forClass(Object.class).getSuperType()).isEqualTo(ResolvableType.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#noInterfaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid noInterfaces() {\r\n    assertThat(ResolvableType.forClass(Object.class).getInterfaces()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#nested()",
    "entityType": "method",
    "code": "@Test\r\nvoid nested() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"nested\"));\r\n    type = type.getNested(2);\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(Byte.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Long.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#nestedWithIndexes()",
    "entityType": "method",
    "code": "@Test\r\nvoid nestedWithIndexes() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"nested\"));\r\n    type = type.getNested(2, Collections.singletonMap(2, 0));\r\n    assertThat(type.resolve()).isEqualTo(Map.class);\r\n    assertThat(type.getGeneric(0).resolve()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).resolve()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#nestedWithArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid nestedWithArray() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"genericArrayType\"));\r\n    type = type.getNested(2);\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n    assertThat(type.resolveGeneric()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGeneric()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGeneric() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringList\"));\r\n    assertThat(type.getGeneric().getType()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGenericByIndex()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGenericByIndex() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringIntegerMultiValueMap\"));\r\n    assertThat(type.getGeneric(0).getType()).isEqualTo(String.class);\r\n    assertThat(type.getGeneric(1).getType()).isEqualTo(Integer.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGenericOfGeneric()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGenericOfGeneric() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\"));\r\n    assertThat(type.getGeneric().getType().toString()).isEqualTo(\"java.util.List<java.lang.String>\");\r\n    assertThat(type.getGeneric().getGeneric().getType()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#genericOfGenericWithAs()",
    "entityType": "method",
    "code": "@Test\r\nvoid genericOfGenericWithAs() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\")).asCollection();\r\n    assertThat(type.toString()).isEqualTo(\"java.util.Collection<java.util.List<java.lang.String>>\");\r\n    assertThat(type.getGeneric().asCollection().toString()).isEqualTo(\"java.util.Collection<java.lang.String>\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGenericOfGenericByIndexes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGenericOfGenericByIndexes() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"stringListList\"));\r\n    assertThat(type.getGeneric(0, 0).getType()).isEqualTo(String.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGenericOutOfBounds()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGenericOutOfBounds() {\r\n    ResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\r\n    assertThat(type.getGeneric(0)).isNotEqualTo(ResolvableType.NONE);\r\n    assertThat(type.getGeneric(1)).isEqualTo(ResolvableType.NONE);\r\n    assertThat(type.getGeneric(0, 1)).isEqualTo(ResolvableType.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#hasGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    assertThat(type.hasGenerics()).isFalse();\r\n    assertThat(type.asCollection().hasGenerics()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGenericsFromParameterizedType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGenericsFromParameterizedType() {\r\n    ResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\r\n    ResolvableType[] generics = type.getGenerics();\r\n    assertThat(generics).hasSize(1);\r\n    assertThat(generics[0].resolve()).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getGenericsFromClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getGenericsFromClass() {\r\n    ResolvableType type = ResolvableType.forClass(List.class);\r\n    ResolvableType[] generics = type.getGenerics();\r\n    assertThat(generics).hasSize(1);\r\n    assertThat(generics[0].getType().toString()).isEqualTo(\"E\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#noGetGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid noGetGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(ExtendsList.class);\r\n    ResolvableType[] generics = type.getGenerics();\r\n    assertThat(generics).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#getResolvedGenerics()",
    "entityType": "method",
    "code": "@Test\r\nvoid getResolvedGenerics() {\r\n    ResolvableType type = ResolvableType.forClass(List.class, ExtendsList.class);\r\n    Class<?>[] generics = type.resolveGenerics();\r\n    assertThat(generics).hasSize(1);\r\n    assertThat(generics[0]).isEqualTo(CharSequence.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveClassType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveClassType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"classType\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.ResolvableTypeTests#resolveParameterizedType()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveParameterizedType() throws Exception {\r\n    ResolvableType type = ResolvableType.forField(Fields.class.getField(\"parameterizedType\"));\r\n    assertThat(type.resolve()).isEqualTo(List.class);\r\n}",
    "comment": ""
  }
]