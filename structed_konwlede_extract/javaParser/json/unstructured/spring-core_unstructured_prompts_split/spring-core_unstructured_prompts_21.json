[
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid nullAndEmptyValues() {\r\n    assertDoesNotMatch((String) null, null);\r\n    assertDoesNotMatch((String) null, \"\");\r\n    assertDoesNotMatch(\"123\", null);\r\n    assertDoesNotMatch((String[]) null, null);\r\n    assertDoesNotMatch((String[]) null, \"\");\r\n    assertDoesNotMatch(new String[] ;, null);\r\n}\n@Test\r\nvoid trivial() {\r\n    assertMatches(\"\", \"\");\r\n    assertMatches(\"123\", \"123\");\r\n    assertMatches(\"*\", \"123\");\r\n    assertMatches(new String[] { \"\" }, \"\");\r\n    assertMatches(new String[] { \"123\" }, \"123\");\r\n    assertMatches(new String[] { \"*\" }, \"123\");\r\n    assertMatches(new String[] { null, \"\" }, \"\");\r\n    assertMatches(new String[] { null, \"123\" }, \"123\");\r\n    assertMatches(new String[] { null, \"*\" }, \"123\");\r\n}\n@Test\r\nvoid startsWith() {\r\n    assertMatches(\"get*\", \"getMe\");\r\n    assertDoesNotMatch(\"get*\", \"setMe\");\r\n}\n@Test\r\nvoid endsWith() {\r\n    assertMatches(\"*Test\", \"getMeTest\");\r\n    assertDoesNotMatch(\"*Test\", \"setMe\");\r\n}\n@Test\r\nvoid between() {\r\n    assertDoesNotMatch(\"*stuff*\", \"getMeTest\");\r\n    assertMatches(\"*stuff*\", \"getstuffTest\");\r\n    assertMatches(\"*stuff*\", \"stuffTest\");\r\n    assertMatches(\"*stuff*\", \"getstuff\");\r\n    assertMatches(\"*stuff*\", \"stuff\");\r\n}\n@Test\r\nvoid startsEnds() {\r\n    assertMatches(\"on*Event\", \"onMyEvent\");\r\n    assertMatches(\"on*Event\", \"onEvent\");\r\n    assertDoesNotMatch(\"3*3\", \"3\");\r\n    assertMatches(\"3*3\", \"33\");\r\n}\n@Test\r\nvoid startsEndsBetween() {\r\n    assertMatches(\"12*45*78\", \"12345678\");\r\n    assertDoesNotMatch(\"12*45*78\", \"123456789\");\r\n    assertDoesNotMatch(\"12*45*78\", \"012345678\");\r\n    assertMatches(\"12*45*78\", \"124578\");\r\n    assertMatches(\"12*45*78\", \"1245457878\");\r\n    assertDoesNotMatch(\"3*3*3\", \"33\");\r\n    assertMatches(\"3*3*3\", \"333\");\r\n}\n@Test\r\nvoid ridiculous() {\r\n    assertMatches(\"*1*2*3*\", \"0011002001010030020201030\");\r\n    assertDoesNotMatch(\"1*2*3*4\", \"10300204\");\r\n    assertDoesNotMatch(\"1*2*3*3\", \"10300203\");\r\n    assertMatches(\"*1*2*3*\", \"123\");\r\n    assertDoesNotMatch(\"*1*2*3*\", \"132\");\r\n}\n@Test\r\nvoid patternVariants() {\r\n    assertDoesNotMatch(\"*a\", \"*\");\r\n    assertMatches(\"*a\", \"a\");\r\n    assertDoesNotMatch(\"*a\", \"b\");\r\n    assertMatches(\"*a\", \"aa\");\r\n    assertMatches(\"*a\", \"ba\");\r\n    assertDoesNotMatch(\"*a\", \"ab\");\r\n    assertDoesNotMatch(\"**a\", \"*\");\r\n    assertMatches(\"**a\", \"a\");\r\n    assertDoesNotMatch(\"**a\", \"b\");\r\n    assertMatches(\"**a\", \"aa\");\r\n    assertMatches(\"**a\", \"ba\");\r\n    assertDoesNotMatch(\"**a\", \"ab\");\r\n}\nprivate void assertMatches(String pattern, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(pattern, str)).isTrue();\r\n}\nprivate void assertDoesNotMatch(String pattern, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(pattern, str)).isFalse();\r\n}\nprivate void assertMatches(String[] patterns, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(patterns, str)).isTrue();\r\n}\nprivate void assertDoesNotMatch(String[] patterns, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(patterns, str)).isFalse();\r\n}",
    "comment": "\n * Tests for {@link PatternMatchUtils}.\n *\n * @author Juergen Hoeller\n * @author Johan Gorter\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#nullAndEmptyValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullAndEmptyValues() {\r\n    assertDoesNotMatch((String) null, null);\r\n    assertDoesNotMatch((String) null, \"\");\r\n    assertDoesNotMatch(\"123\", null);\r\n    assertDoesNotMatch((String[]) null, null);\r\n    assertDoesNotMatch((String[]) null, \"\");\r\n    assertDoesNotMatch(new String[] ;, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#trivial()",
    "entityType": "method",
    "code": "@Test\r\nvoid trivial() {\r\n    assertMatches(\"\", \"\");\r\n    assertMatches(\"123\", \"123\");\r\n    assertMatches(\"*\", \"123\");\r\n    assertMatches(new String[] { \"\" }, \"\");\r\n    assertMatches(new String[] { \"123\" }, \"123\");\r\n    assertMatches(new String[] { \"*\" }, \"123\");\r\n    assertMatches(new String[] { null, \"\" }, \"\");\r\n    assertMatches(new String[] { null, \"123\" }, \"123\");\r\n    assertMatches(new String[] { null, \"*\" }, \"123\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#startsWith()",
    "entityType": "method",
    "code": "@Test\r\nvoid startsWith() {\r\n    assertMatches(\"get*\", \"getMe\");\r\n    assertDoesNotMatch(\"get*\", \"setMe\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#endsWith()",
    "entityType": "method",
    "code": "@Test\r\nvoid endsWith() {\r\n    assertMatches(\"*Test\", \"getMeTest\");\r\n    assertDoesNotMatch(\"*Test\", \"setMe\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#between()",
    "entityType": "method",
    "code": "@Test\r\nvoid between() {\r\n    assertDoesNotMatch(\"*stuff*\", \"getMeTest\");\r\n    assertMatches(\"*stuff*\", \"getstuffTest\");\r\n    assertMatches(\"*stuff*\", \"stuffTest\");\r\n    assertMatches(\"*stuff*\", \"getstuff\");\r\n    assertMatches(\"*stuff*\", \"stuff\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#startsEnds()",
    "entityType": "method",
    "code": "@Test\r\nvoid startsEnds() {\r\n    assertMatches(\"on*Event\", \"onMyEvent\");\r\n    assertMatches(\"on*Event\", \"onEvent\");\r\n    assertDoesNotMatch(\"3*3\", \"3\");\r\n    assertMatches(\"3*3\", \"33\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#startsEndsBetween()",
    "entityType": "method",
    "code": "@Test\r\nvoid startsEndsBetween() {\r\n    assertMatches(\"12*45*78\", \"12345678\");\r\n    assertDoesNotMatch(\"12*45*78\", \"123456789\");\r\n    assertDoesNotMatch(\"12*45*78\", \"012345678\");\r\n    assertMatches(\"12*45*78\", \"124578\");\r\n    assertMatches(\"12*45*78\", \"1245457878\");\r\n    assertDoesNotMatch(\"3*3*3\", \"33\");\r\n    assertMatches(\"3*3*3\", \"333\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#ridiculous()",
    "entityType": "method",
    "code": "@Test\r\nvoid ridiculous() {\r\n    assertMatches(\"*1*2*3*\", \"0011002001010030020201030\");\r\n    assertDoesNotMatch(\"1*2*3*4\", \"10300204\");\r\n    assertDoesNotMatch(\"1*2*3*3\", \"10300203\");\r\n    assertMatches(\"*1*2*3*\", \"123\");\r\n    assertDoesNotMatch(\"*1*2*3*\", \"132\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#patternVariants()",
    "entityType": "method",
    "code": "@Test\r\nvoid patternVariants() {\r\n    assertDoesNotMatch(\"*a\", \"*\");\r\n    assertMatches(\"*a\", \"a\");\r\n    assertDoesNotMatch(\"*a\", \"b\");\r\n    assertMatches(\"*a\", \"aa\");\r\n    assertMatches(\"*a\", \"ba\");\r\n    assertDoesNotMatch(\"*a\", \"ab\");\r\n    assertDoesNotMatch(\"**a\", \"*\");\r\n    assertMatches(\"**a\", \"a\");\r\n    assertDoesNotMatch(\"**a\", \"b\");\r\n    assertMatches(\"**a\", \"aa\");\r\n    assertMatches(\"**a\", \"ba\");\r\n    assertDoesNotMatch(\"**a\", \"ab\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#assertMatches(String,String)",
    "entityType": "method",
    "code": "private void assertMatches(String pattern, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(pattern, str)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#assertDoesNotMatch(String,String)",
    "entityType": "method",
    "code": "private void assertDoesNotMatch(String pattern, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(pattern, str)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#assertMatches(String[],String)",
    "entityType": "method",
    "code": "private void assertMatches(String[] patterns, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(patterns, str)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtilsTests#assertDoesNotMatch(String[],String)",
    "entityType": "method",
    "code": "private void assertDoesNotMatch(String[] patterns, String str) {\r\n    assertThat(PatternMatchUtils.simpleMatch(patterns, str)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Attribute",
    "entityType": "class",
    "code": "/**\r\n * The type of this attribute, also called its name in the JVMS.\r\n */\r\npublic final String type;\n/**\r\n * The raw content of this attribute, as returned by {@link\r\n * #write(ClassWriter,byte[],int,int,int)}. The 6 header bytes of the attribute\r\n * (attribute_name_index and attribute_length) are <i>not</i> included.\r\n */\r\nprivate ByteVector cachedContent;\n/**\r\n * The next attribute in this attribute list (Attribute instances can be linked via this field to\r\n * store a list of class, field, method or Code attributes). May be {@literal null}.\r\n */\r\nAttribute nextAttribute;\n/**\r\n * Constructs a new empty attribute.\r\n *\r\n * @param type the type of the attribute.\r\n */\r\nprotected Attribute(final String type) {\r\n    this.type = type;\r\n}\n/**\r\n * Returns {@literal true} if this type of attribute is unknown. This means that the attribute\r\n * content can't be parsed to extract constant pool references, labels, etc. Instead, the\r\n * attribute content is read as an opaque byte array, and written back as is. This can lead to\r\n * invalid attributes, if the content actually contains constant pool references, labels, or other\r\n * symbolic references that need to be updated when there are changes to the constant pool, the\r\n * method bytecode, etc. The default implementation of this method always returns {@literal true}.\r\n *\r\n * @return {@literal true} if this type of attribute is unknown.\r\n */\r\npublic boolean isUnknown() {\r\n    return true;\r\n}\n/**\r\n * Returns {@literal true} if this type of attribute is a Code attribute.\r\n *\r\n * @return {@literal true} if this type of attribute is a Code attribute.\r\n */\r\npublic boolean isCodeAttribute() {\r\n    return false;\r\n}\n/**\r\n * Returns the labels corresponding to this attribute.\r\n *\r\n * @return the labels corresponding to this attribute, or {@literal null} if this attribute is not\r\n *     a Code attribute that contains labels.\r\n * @deprecated no longer used by ASM.\r\n */\r\n@Deprecated\r\nprotected Label[] getLabels() {\r\n    return new Label[0];\r\n}\n/**\r\n * Reads a {@link #type} attribute. This method must return a <i>new</i> {@link Attribute} object,\r\n * of type {@link #type}, corresponding to the 'length' bytes starting at 'offset', in the given\r\n * ClassReader.\r\n *\r\n * @param classReader the class that contains the attribute to be read.\r\n * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\r\n *     'charBuffer' parameter.\r\n * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\r\n *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a Code attribute. Labels defined in the attribute must be created and added to this\r\n *     array, if not already present, by calling the {@link #readLabel} method (do not create\r\n *     {@link Label} instances directly).\r\n * @return a <i>new</i> {@link Attribute} object corresponding to the specified bytes.\r\n */\r\nprotected Attribute read(final ClassReader classReader, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    Attribute attribute = new Attribute(type);\r\n    attribute.cachedContent = new ByteVector(classReader.readBytes(offset, length));\r\n    return attribute;\r\n}\n/**\r\n * Reads an attribute with the same {@link #type} as the given attribute. This method returns a\r\n * new {@link Attribute} object, corresponding to the 'length' bytes starting at 'offset', in the\r\n * given ClassReader.\r\n *\r\n * @param attribute The attribute prototype that is used for reading.\r\n * @param classReader the class that contains the attribute to be read.\r\n * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\r\n *     'charBuffer' parameter.\r\n * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\r\n *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a Code attribute. Labels defined in the attribute are added to this array, if not\r\n *     already present.\r\n * @return a new {@link Attribute} object corresponding to the specified bytes.\r\n */\r\npublic static Attribute read(final Attribute attribute, final ClassReader classReader, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    return attribute.read(classReader, offset, length, charBuffer, codeAttributeOffset, labels);\r\n}\n/**\r\n * Returns the label corresponding to the given bytecode offset by calling {@link\r\n * ClassReader#readLabel}. This creates and adds the label to the given array if it is not already\r\n * present. Note that this created label may be a {@link Label} subclass instance, if the given\r\n * ClassReader overrides {@link ClassReader#readLabel}. Hence {@link #read(ClassReader, int, int,\r\n * char[], int, Label[])} must not manually create {@link Label} instances.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset. If a label already exists\r\n *     for bytecodeOffset this method does not create a new one. Otherwise it stores the new label\r\n *     in this array.\r\n * @return a label for the given bytecode offset.\r\n */\r\npublic static Label readLabel(final ClassReader classReader, final int bytecodeOffset, final Label[] labels) {\r\n    return classReader.readLabel(bytecodeOffset, labels);\r\n}\n/**\r\n * Calls {@link #write(ClassWriter,byte[],int,int,int)} if it has not already been called and\r\n * returns its result or its (cached) previous result.\r\n *\r\n * @param classWriter the class to which this attribute must be added. This parameter can be used\r\n *     to add the items that corresponds to this attribute to the constant pool of this class.\r\n * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\r\n *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to this code\r\n *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\r\n *     field of the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\r\n *     -1 if this attribute is not a Code attribute.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to this code\r\n *     attribute, or -1 if this attribute is not a Code attribute.\r\n * @return the byte array form of this attribute.\r\n */\r\nprivate ByteVector maybeWrite(final ClassWriter classWriter, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    if (cachedContent == null) {\r\n        cachedContent = write(classWriter, code, codeLength, maxStack, maxLocals);\r\n    }\r\n    return cachedContent;\r\n}\n/**\r\n * Returns the byte array form of the content of this attribute. The 6 header bytes\r\n * (attribute_name_index and attribute_length) must <i>not</i> be added in the returned\r\n * ByteVector.\r\n *\r\n * <p>This method is only invoked once to compute the binary form of this attribute. Subsequent\r\n * changes to the attribute after it was written for the first time will not be considered.\r\n *\r\n * @param classWriter the class to which this attribute must be added. This parameter can be used\r\n *     to add the items that corresponds to this attribute to the constant pool of this class.\r\n * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\r\n *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to this code\r\n *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\r\n *     field of the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\r\n *     -1 if this attribute is not a Code attribute.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to this code\r\n *     attribute, or -1 if this attribute is not a Code attribute.\r\n * @return the byte array form of this attribute.\r\n */\r\nprotected ByteVector write(final ClassWriter classWriter, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    return cachedContent;\r\n}\n/**\r\n * Returns the byte array form of the content of the given attribute. The 6 header bytes\r\n * (attribute_name_index and attribute_length) are <i>not</i> added in the returned byte array.\r\n *\r\n * @param attribute The attribute that should be written.\r\n * @param classWriter the class to which this attribute must be added. This parameter can be used\r\n *     to add the items that corresponds to this attribute to the constant pool of this class.\r\n * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\r\n *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to this code\r\n *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\r\n *     field of the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\r\n *     -1 if this attribute is not a Code attribute.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to this code\r\n *     attribute, or -1 if this attribute is not a Code attribute.\r\n * @return the byte array form of this attribute.\r\n */\r\npublic static byte[] write(final Attribute attribute, final ClassWriter classWriter, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    ByteVector content = attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);\r\n    byte[] result = new byte[content.length];\r\n    System.arraycopy(content.data, 0, result, 0, content.length);\r\n    return result;\r\n}\n/**\r\n * Returns the number of attributes of the attribute list that begins with this attribute.\r\n *\r\n * @return the number of attributes of the attribute list that begins with this attribute.\r\n */\r\nfinal int getAttributeCount() {\r\n    int count = 0;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        count += 1;\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n    return count;\r\n}\n/**\r\n * Returns the total size in bytes of all the attributes in the attribute list that begins with\r\n * this attribute. This size includes the 6 header bytes (attribute_name_index and\r\n * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @return the size of all the attributes in this attribute list. This size includes the size of\r\n *     the attribute headers.\r\n */\r\nfinal int computeAttributesSize(final SymbolTable symbolTable) {\r\n    final byte[] code = null;\r\n    final int codeLength = 0;\r\n    final int maxStack = -1;\r\n    final int maxLocals = -1;\r\n    return computeAttributesSize(symbolTable, code, codeLength, maxStack, maxLocals);\r\n}\n/**\r\n * Returns the total size in bytes of all the attributes in the attribute list that begins with\r\n * this attribute. This size includes the 6 header bytes (attribute_name_index and\r\n * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\r\n *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to these code\r\n *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\r\n *     the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\r\n *     -1 if they are not Code attributes.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to these\r\n *     Code attributes, or -1 if they are not Code attribute.\r\n * @return the size of all the attributes in this attribute list. This size includes the size of\r\n *     the attribute headers.\r\n */\r\nfinal int computeAttributesSize(final SymbolTable symbolTable, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    final ClassWriter classWriter = symbolTable.classWriter;\r\n    int size = 0;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        symbolTable.addConstantUtf8(attribute.type);\r\n        size += 6 + attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals).length;\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n    return size;\r\n}\n/**\r\n * Returns the total size in bytes of all the attributes that correspond to the given field,\r\n * method or class access flags and signature. This size includes the 6 header bytes\r\n * (attribute_name_index and attribute_length) per attribute. Also adds the attribute type names\r\n * to the constant pool.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param accessFlags some field, method or class access flags.\r\n * @param signatureIndex the constant pool index of a field, method of class signature.\r\n * @return the size of all the attributes in bytes. This size includes the size of the attribute\r\n *     headers.\r\n */\r\nstatic int computeAttributesSize(final SymbolTable symbolTable, final int accessFlags, final int signatureIndex) {\r\n    int size = 0;\r\n    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) {\r\n        // Synthetic attributes always use 6 bytes.\r\n        symbolTable.addConstantUtf8(Constants.SYNTHETIC);\r\n        size += 6;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        // Signature attributes always use 8 bytes.\r\n        symbolTable.addConstantUtf8(Constants.SIGNATURE);\r\n        size += 8;\r\n    }\r\n    // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        // Deprecated attributes always use 6 bytes.\r\n        symbolTable.addConstantUtf8(Constants.DEPRECATED);\r\n        size += 6;\r\n    }\r\n    return size;\r\n}\n/**\r\n * Puts all the attributes of the attribute list that begins with this attribute, in the given\r\n * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\r\n * attribute.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param output where the attributes must be written.\r\n */\r\nfinal void putAttributes(final SymbolTable symbolTable, final ByteVector output) {\r\n    final byte[] code = null;\r\n    final int codeLength = 0;\r\n    final int maxStack = -1;\r\n    final int maxLocals = -1;\r\n    putAttributes(symbolTable, code, codeLength, maxStack, maxLocals, output);\r\n}\n/**\r\n * Puts all the attributes of the attribute list that begins with this attribute, in the given\r\n * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\r\n * attribute.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\r\n *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to these code\r\n *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\r\n *     the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\r\n *     -1 if they are not Code attributes.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to these\r\n *     Code attributes, or -1 if they are not Code attribute.\r\n * @param output where the attributes must be written.\r\n */\r\nfinal void putAttributes(final SymbolTable symbolTable, final byte[] code, final int codeLength, final int maxStack, final int maxLocals, final ByteVector output) {\r\n    final ClassWriter classWriter = symbolTable.classWriter;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        ByteVector attributeContent = attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);\r\n        // Put attribute_name_index and attribute_length.\r\n        output.putShort(symbolTable.addConstantUtf8(attribute.type)).putInt(attributeContent.length);\r\n        output.putByteArray(attributeContent.data, 0, attributeContent.length);\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n}\n/**\r\n * Puts all the attributes that correspond to the given field, method or class access flags and\r\n * signature, in the given byte vector. This includes the 6 header bytes (attribute_name_index and\r\n * attribute_length) per attribute.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param accessFlags some field, method or class access flags.\r\n * @param signatureIndex the constant pool index of a field, method of class signature.\r\n * @param output where the attributes must be written.\r\n */\r\nstatic void putAttributes(final SymbolTable symbolTable, final int accessFlags, final int signatureIndex, final ByteVector output) {\r\n    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)).putInt(2).putShort(signatureIndex);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\r\n    }\r\n}\n/**\r\n * A set of attribute prototypes (attributes with the same type are considered equal).\r\n */\r\nstatic final class Set {\r\n\r\n    private static final int SIZE_INCREMENT = 6;\r\n\r\n    private int size;\r\n\r\n    private Attribute[] data = new Attribute[SIZE_INCREMENT];\r\n\r\n    void addAttributes(final Attribute attributeList) {\r\n        Attribute attribute = attributeList;\r\n        while (attribute != null) {\r\n            if (!contains(attribute)) {\r\n                add(attribute);\r\n            }\r\n            attribute = attribute.nextAttribute;\r\n        }\r\n    }\r\n\r\n    Attribute[] toArray() {\r\n        Attribute[] result = new Attribute[size];\r\n        System.arraycopy(data, 0, result, 0, size);\r\n        return result;\r\n    }\r\n\r\n    private boolean contains(final Attribute attribute) {\r\n        for (int i = 0; i < size; ++i) {\r\n            if (data[i].type.equals(attribute.type)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private void add(final Attribute attribute) {\r\n        if (size >= data.length) {\r\n            Attribute[] newData = new Attribute[data.length + SIZE_INCREMENT];\r\n            System.arraycopy(data, 0, newData, 0, size);\r\n            data = newData;\r\n        }\r\n        data[size++] = attribute;\r\n    }\r\n}",
    "comment": "\n * A non standard class, field, method or Code attribute, as defined in the Java Virtual Machine\n * Specification (JVMS).\n *\n * @see <a href= \"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7\">JVMS\n *     4.7</a>\n * @see <a href= \"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3\">JVMS\n *     4.7.3</a>\n * @author Eric Bruneton\n * @author Eugene Kuleshov\n "
  },
  {
    "entityId": "org.springframework.asm.Attribute#isUnknown()",
    "entityType": "method",
    "code": "/**\r\n * Returns {@literal true} if this type of attribute is unknown. This means that the attribute\r\n * content can't be parsed to extract constant pool references, labels, etc. Instead, the\r\n * attribute content is read as an opaque byte array, and written back as is. This can lead to\r\n * invalid attributes, if the content actually contains constant pool references, labels, or other\r\n * symbolic references that need to be updated when there are changes to the constant pool, the\r\n * method bytecode, etc. The default implementation of this method always returns {@literal true}.\r\n *\r\n * @return {@literal true} if this type of attribute is unknown.\r\n */\r\npublic boolean isUnknown() {\r\n    return true;\r\n}",
    "comment": "\n   * Returns {@literal true} if this type of attribute is unknown. This means that the attribute\n   * content can't be parsed to extract constant pool references, labels, etc. Instead, the\n   * attribute content is read as an opaque byte array, and written back as is. This can lead to\n   * invalid attributes, if the content actually contains constant pool references, labels, or other\n   * symbolic references that need to be updated when there are changes to the constant pool, the\n   * method bytecode, etc. The default implementation of this method always returns {@literal true}.\n   *\n   * @return {@literal true} if this type of attribute is unknown.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#isCodeAttribute()",
    "entityType": "method",
    "code": "/**\r\n * Returns {@literal true} if this type of attribute is a Code attribute.\r\n *\r\n * @return {@literal true} if this type of attribute is a Code attribute.\r\n */\r\npublic boolean isCodeAttribute() {\r\n    return false;\r\n}",
    "comment": "\n   * Returns {@literal true} if this type of attribute is a Code attribute.\n   *\n   * @return {@literal true} if this type of attribute is a Code attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#getLabels()",
    "entityType": "method",
    "code": "/**\r\n * Returns the labels corresponding to this attribute.\r\n *\r\n * @return the labels corresponding to this attribute, or {@literal null} if this attribute is not\r\n *     a Code attribute that contains labels.\r\n * @deprecated no longer used by ASM.\r\n */\r\n@Deprecated\r\nprotected Label[] getLabels() {\r\n    return new Label[0];\r\n}",
    "comment": "\n   * Returns the labels corresponding to this attribute.\n   *\n   * @return the labels corresponding to this attribute, or {@literal null} if this attribute is not\n   *     a Code attribute that contains labels.\n   * @deprecated no longer used by ASM.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#read(ClassReader,int,int,char[],int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Reads a {@link #type} attribute. This method must return a <i>new</i> {@link Attribute} object,\r\n * of type {@link #type}, corresponding to the 'length' bytes starting at 'offset', in the given\r\n * ClassReader.\r\n *\r\n * @param classReader the class that contains the attribute to be read.\r\n * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\r\n *     'charBuffer' parameter.\r\n * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\r\n *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a Code attribute. Labels defined in the attribute must be created and added to this\r\n *     array, if not already present, by calling the {@link #readLabel} method (do not create\r\n *     {@link Label} instances directly).\r\n * @return a <i>new</i> {@link Attribute} object corresponding to the specified bytes.\r\n */\r\nprotected Attribute read(final ClassReader classReader, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    Attribute attribute = new Attribute(type);\r\n    attribute.cachedContent = new ByteVector(classReader.readBytes(offset, length));\r\n    return attribute;\r\n}",
    "comment": "\n   * Reads a {@link #type} attribute. This method must return a <i>new</i> {@link Attribute} object,\n   * of type {@link #type}, corresponding to the 'length' bytes starting at 'offset', in the given\n   * ClassReader.\n   *\n   * @param classReader the class that contains the attribute to be read.\n   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\n   *     'charBuffer' parameter.\n   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\n   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n   *     is not a Code attribute. Labels defined in the attribute must be created and added to this\n   *     array, if not already present, by calling the {@link #readLabel} method (do not create\n   *     {@link Label} instances directly).\n   * @return a <i>new</i> {@link Attribute} object corresponding to the specified bytes.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#read(Attribute,ClassReader,int,int,char[],int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Reads an attribute with the same {@link #type} as the given attribute. This method returns a\r\n * new {@link Attribute} object, corresponding to the 'length' bytes starting at 'offset', in the\r\n * given ClassReader.\r\n *\r\n * @param attribute The attribute prototype that is used for reading.\r\n * @param classReader the class that contains the attribute to be read.\r\n * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\r\n * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\r\n *     'charBuffer' parameter.\r\n * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\r\n *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\r\n *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\r\n *     account here.\r\n * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\r\n *     is not a Code attribute. Labels defined in the attribute are added to this array, if not\r\n *     already present.\r\n * @return a new {@link Attribute} object corresponding to the specified bytes.\r\n */\r\npublic static Attribute read(final Attribute attribute, final ClassReader classReader, final int offset, final int length, final char[] charBuffer, final int codeAttributeOffset, final Label[] labels) {\r\n    return attribute.read(classReader, offset, length, charBuffer, codeAttributeOffset, labels);\r\n}",
    "comment": "\n   * Reads an attribute with the same {@link #type} as the given attribute. This method returns a\n   * new {@link Attribute} object, corresponding to the 'length' bytes starting at 'offset', in the\n   * given ClassReader.\n   *\n   * @param attribute The attribute prototype that is used for reading.\n   * @param classReader the class that contains the attribute to be read.\n   * @param offset index of the first byte of the attribute's content in {@link ClassReader}. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param length the length of the attribute's content (excluding the 6 attribute header bytes).\n   * @param charBuffer the buffer to be used to call the ClassReader methods requiring a\n   *     'charBuffer' parameter.\n   * @param codeAttributeOffset index of the first byte of content of the enclosing Code attribute\n   *     in {@link ClassReader}, or -1 if the attribute to be read is not a Code attribute. The 6\n   *     attribute header bytes (attribute_name_index and attribute_length) are not taken into\n   *     account here.\n   * @param labels the labels of the method's code, or {@literal null} if the attribute to be read\n   *     is not a Code attribute. Labels defined in the attribute are added to this array, if not\n   *     already present.\n   * @return a new {@link Attribute} object corresponding to the specified bytes.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#readLabel(ClassReader,int,Label[])",
    "entityType": "method",
    "code": "/**\r\n * Returns the label corresponding to the given bytecode offset by calling {@link\r\n * ClassReader#readLabel}. This creates and adds the label to the given array if it is not already\r\n * present. Note that this created label may be a {@link Label} subclass instance, if the given\r\n * ClassReader overrides {@link ClassReader#readLabel}. Hence {@link #read(ClassReader, int, int,\r\n * char[], int, Label[])} must not manually create {@link Label} instances.\r\n *\r\n * @param bytecodeOffset a bytecode offset in a method.\r\n * @param labels the already created labels, indexed by their offset. If a label already exists\r\n *     for bytecodeOffset this method does not create a new one. Otherwise it stores the new label\r\n *     in this array.\r\n * @return a label for the given bytecode offset.\r\n */\r\npublic static Label readLabel(final ClassReader classReader, final int bytecodeOffset, final Label[] labels) {\r\n    return classReader.readLabel(bytecodeOffset, labels);\r\n}",
    "comment": "\n   * Returns the label corresponding to the given bytecode offset by calling {@link\n   * ClassReader#readLabel}. This creates and adds the label to the given array if it is not already\n   * present. Note that this created label may be a {@link Label} subclass instance, if the given\n   * ClassReader overrides {@link ClassReader#readLabel}. Hence {@link #read(ClassReader, int, int,\n   * char[], int, Label[])} must not manually create {@link Label} instances.\n   *\n   * @param bytecodeOffset a bytecode offset in a method.\n   * @param labels the already created labels, indexed by their offset. If a label already exists\n   *     for bytecodeOffset this method does not create a new one. Otherwise it stores the new label\n   *     in this array.\n   * @return a label for the given bytecode offset.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#maybeWrite(ClassWriter,byte[],int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Calls {@link #write(ClassWriter,byte[],int,int,int)} if it has not already been called and\r\n * returns its result or its (cached) previous result.\r\n *\r\n * @param classWriter the class to which this attribute must be added. This parameter can be used\r\n *     to add the items that corresponds to this attribute to the constant pool of this class.\r\n * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\r\n *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to this code\r\n *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\r\n *     field of the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\r\n *     -1 if this attribute is not a Code attribute.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to this code\r\n *     attribute, or -1 if this attribute is not a Code attribute.\r\n * @return the byte array form of this attribute.\r\n */\r\nprivate ByteVector maybeWrite(final ClassWriter classWriter, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    if (cachedContent == null) {\r\n        cachedContent = write(classWriter, code, codeLength, maxStack, maxLocals);\r\n    }\r\n    return cachedContent;\r\n}",
    "comment": "\n   * Calls {@link #write(ClassWriter,byte[],int,int,int)} if it has not already been called and\n   * returns its result or its (cached) previous result.\n   *\n   * @param classWriter the class to which this attribute must be added. This parameter can be used\n   *     to add the items that corresponds to this attribute to the constant pool of this class.\n   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\n   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to this code\n   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\n   *     field of the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\n   *     -1 if this attribute is not a Code attribute.\n   * @param maxLocals the maximum number of local variables of the method corresponding to this code\n   *     attribute, or -1 if this attribute is not a Code attribute.\n   * @return the byte array form of this attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#write(ClassWriter,byte[],int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the byte array form of the content of this attribute. The 6 header bytes\r\n * (attribute_name_index and attribute_length) must <i>not</i> be added in the returned\r\n * ByteVector.\r\n *\r\n * <p>This method is only invoked once to compute the binary form of this attribute. Subsequent\r\n * changes to the attribute after it was written for the first time will not be considered.\r\n *\r\n * @param classWriter the class to which this attribute must be added. This parameter can be used\r\n *     to add the items that corresponds to this attribute to the constant pool of this class.\r\n * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\r\n *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to this code\r\n *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\r\n *     field of the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\r\n *     -1 if this attribute is not a Code attribute.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to this code\r\n *     attribute, or -1 if this attribute is not a Code attribute.\r\n * @return the byte array form of this attribute.\r\n */\r\nprotected ByteVector write(final ClassWriter classWriter, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    return cachedContent;\r\n}",
    "comment": "\n   * Returns the byte array form of the content of this attribute. The 6 header bytes\n   * (attribute_name_index and attribute_length) must <i>not</i> be added in the returned\n   * ByteVector.\n   *\n   * <p>This method is only invoked once to compute the binary form of this attribute. Subsequent\n   * changes to the attribute after it was written for the first time will not be considered.\n   *\n   * @param classWriter the class to which this attribute must be added. This parameter can be used\n   *     to add the items that corresponds to this attribute to the constant pool of this class.\n   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\n   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to this code\n   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\n   *     field of the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\n   *     -1 if this attribute is not a Code attribute.\n   * @param maxLocals the maximum number of local variables of the method corresponding to this code\n   *     attribute, or -1 if this attribute is not a Code attribute.\n   * @return the byte array form of this attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#write(Attribute,ClassWriter,byte[],int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the byte array form of the content of the given attribute. The 6 header bytes\r\n * (attribute_name_index and attribute_length) are <i>not</i> added in the returned byte array.\r\n *\r\n * @param attribute The attribute that should be written.\r\n * @param classWriter the class to which this attribute must be added. This parameter can be used\r\n *     to add the items that corresponds to this attribute to the constant pool of this class.\r\n * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\r\n *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to this code\r\n *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\r\n *     field of the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\r\n *     -1 if this attribute is not a Code attribute.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to this code\r\n *     attribute, or -1 if this attribute is not a Code attribute.\r\n * @return the byte array form of this attribute.\r\n */\r\npublic static byte[] write(final Attribute attribute, final ClassWriter classWriter, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    ByteVector content = attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);\r\n    byte[] result = new byte[content.length];\r\n    System.arraycopy(content.data, 0, result, 0, content.length);\r\n    return result;\r\n}",
    "comment": "\n   * Returns the byte array form of the content of the given attribute. The 6 header bytes\n   * (attribute_name_index and attribute_length) are <i>not</i> added in the returned byte array.\n   *\n   * @param attribute The attribute that should be written.\n   * @param classWriter the class to which this attribute must be added. This parameter can be used\n   *     to add the items that corresponds to this attribute to the constant pool of this class.\n   * @param code the bytecode of the method corresponding to this Code attribute, or {@literal null}\n   *     if this attribute is not a Code attribute. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to this code\n   *     attribute, or 0 if this attribute is not a Code attribute. Corresponds to the 'code_length'\n   *     field of the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to this Code attribute, or\n   *     -1 if this attribute is not a Code attribute.\n   * @param maxLocals the maximum number of local variables of the method corresponding to this code\n   *     attribute, or -1 if this attribute is not a Code attribute.\n   * @return the byte array form of this attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#getAttributeCount()",
    "entityType": "method",
    "code": "/**\r\n * Returns the number of attributes of the attribute list that begins with this attribute.\r\n *\r\n * @return the number of attributes of the attribute list that begins with this attribute.\r\n */\r\nfinal int getAttributeCount() {\r\n    int count = 0;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        count += 1;\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n    return count;\r\n}",
    "comment": "\n   * Returns the number of attributes of the attribute list that begins with this attribute.\n   *\n   * @return the number of attributes of the attribute list that begins with this attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#computeAttributesSize(SymbolTable)",
    "entityType": "method",
    "code": "/**\r\n * Returns the total size in bytes of all the attributes in the attribute list that begins with\r\n * this attribute. This size includes the 6 header bytes (attribute_name_index and\r\n * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @return the size of all the attributes in this attribute list. This size includes the size of\r\n *     the attribute headers.\r\n */\r\nfinal int computeAttributesSize(final SymbolTable symbolTable) {\r\n    final byte[] code = null;\r\n    final int codeLength = 0;\r\n    final int maxStack = -1;\r\n    final int maxLocals = -1;\r\n    return computeAttributesSize(symbolTable, code, codeLength, maxStack, maxLocals);\r\n}",
    "comment": "\n   * Returns the total size in bytes of all the attributes in the attribute list that begins with\n   * this attribute. This size includes the 6 header bytes (attribute_name_index and\n   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @return the size of all the attributes in this attribute list. This size includes the size of\n   *     the attribute headers.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#computeAttributesSize(SymbolTable,byte[],int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the total size in bytes of all the attributes in the attribute list that begins with\r\n * this attribute. This size includes the 6 header bytes (attribute_name_index and\r\n * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\r\n *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to these code\r\n *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\r\n *     the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\r\n *     -1 if they are not Code attributes.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to these\r\n *     Code attributes, or -1 if they are not Code attribute.\r\n * @return the size of all the attributes in this attribute list. This size includes the size of\r\n *     the attribute headers.\r\n */\r\nfinal int computeAttributesSize(final SymbolTable symbolTable, final byte[] code, final int codeLength, final int maxStack, final int maxLocals) {\r\n    final ClassWriter classWriter = symbolTable.classWriter;\r\n    int size = 0;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        symbolTable.addConstantUtf8(attribute.type);\r\n        size += 6 + attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals).length;\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n    return size;\r\n}",
    "comment": "\n   * Returns the total size in bytes of all the attributes in the attribute list that begins with\n   * this attribute. This size includes the 6 header bytes (attribute_name_index and\n   * attribute_length) per attribute. Also adds the attribute type names to the constant pool.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\n   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to these code\n   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\n   *     the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\n   *     -1 if they are not Code attributes.\n   * @param maxLocals the maximum number of local variables of the method corresponding to these\n   *     Code attributes, or -1 if they are not Code attribute.\n   * @return the size of all the attributes in this attribute list. This size includes the size of\n   *     the attribute headers.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#computeAttributesSize(SymbolTable,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Returns the total size in bytes of all the attributes that correspond to the given field,\r\n * method or class access flags and signature. This size includes the 6 header bytes\r\n * (attribute_name_index and attribute_length) per attribute. Also adds the attribute type names\r\n * to the constant pool.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param accessFlags some field, method or class access flags.\r\n * @param signatureIndex the constant pool index of a field, method of class signature.\r\n * @return the size of all the attributes in bytes. This size includes the size of the attribute\r\n *     headers.\r\n */\r\nstatic int computeAttributesSize(final SymbolTable symbolTable, final int accessFlags, final int signatureIndex) {\r\n    int size = 0;\r\n    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) {\r\n        // Synthetic attributes always use 6 bytes.\r\n        symbolTable.addConstantUtf8(Constants.SYNTHETIC);\r\n        size += 6;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        // Signature attributes always use 8 bytes.\r\n        symbolTable.addConstantUtf8(Constants.SIGNATURE);\r\n        size += 8;\r\n    }\r\n    // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        // Deprecated attributes always use 6 bytes.\r\n        symbolTable.addConstantUtf8(Constants.DEPRECATED);\r\n        size += 6;\r\n    }\r\n    return size;\r\n}",
    "comment": "\n   * Returns the total size in bytes of all the attributes that correspond to the given field,\n   * method or class access flags and signature. This size includes the 6 header bytes\n   * (attribute_name_index and attribute_length) per attribute. Also adds the attribute type names\n   * to the constant pool.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param accessFlags some field, method or class access flags.\n   * @param signatureIndex the constant pool index of a field, method of class signature.\n   * @return the size of all the attributes in bytes. This size includes the size of the attribute\n   *     headers.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#putAttributes(SymbolTable,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts all the attributes of the attribute list that begins with this attribute, in the given\r\n * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\r\n * attribute.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param output where the attributes must be written.\r\n */\r\nfinal void putAttributes(final SymbolTable symbolTable, final ByteVector output) {\r\n    final byte[] code = null;\r\n    final int codeLength = 0;\r\n    final int maxStack = -1;\r\n    final int maxLocals = -1;\r\n    putAttributes(symbolTable, code, codeLength, maxStack, maxLocals, output);\r\n}",
    "comment": "\n   * Puts all the attributes of the attribute list that begins with this attribute, in the given\n   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\n   * attribute.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param output where the attributes must be written.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#putAttributes(SymbolTable,byte[],int,int,int,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts all the attributes of the attribute list that begins with this attribute, in the given\r\n * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\r\n * attribute.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\r\n *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\r\n *     attribute.\r\n * @param codeLength the length of the bytecode of the method corresponding to these code\r\n *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\r\n *     the Code attribute.\r\n * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\r\n *     -1 if they are not Code attributes.\r\n * @param maxLocals the maximum number of local variables of the method corresponding to these\r\n *     Code attributes, or -1 if they are not Code attribute.\r\n * @param output where the attributes must be written.\r\n */\r\nfinal void putAttributes(final SymbolTable symbolTable, final byte[] code, final int codeLength, final int maxStack, final int maxLocals, final ByteVector output) {\r\n    final ClassWriter classWriter = symbolTable.classWriter;\r\n    Attribute attribute = this;\r\n    while (attribute != null) {\r\n        ByteVector attributeContent = attribute.maybeWrite(classWriter, code, codeLength, maxStack, maxLocals);\r\n        // Put attribute_name_index and attribute_length.\r\n        output.putShort(symbolTable.addConstantUtf8(attribute.type)).putInt(attributeContent.length);\r\n        output.putByteArray(attributeContent.data, 0, attributeContent.length);\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n}",
    "comment": "\n   * Puts all the attributes of the attribute list that begins with this attribute, in the given\n   * byte vector. This includes the 6 header bytes (attribute_name_index and attribute_length) per\n   * attribute.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param code the bytecode of the method corresponding to these Code attributes, or {@literal\n   *     null} if they are not Code attributes. Corresponds to the 'code' field of the Code\n   *     attribute.\n   * @param codeLength the length of the bytecode of the method corresponding to these code\n   *     attributes, or 0 if they are not Code attributes. Corresponds to the 'code_length' field of\n   *     the Code attribute.\n   * @param maxStack the maximum stack size of the method corresponding to these Code attributes, or\n   *     -1 if they are not Code attributes.\n   * @param maxLocals the maximum number of local variables of the method corresponding to these\n   *     Code attributes, or -1 if they are not Code attribute.\n   * @param output where the attributes must be written.\n   "
  },
  {
    "entityId": "org.springframework.asm.Attribute#putAttributes(SymbolTable,int,int,ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts all the attributes that correspond to the given field, method or class access flags and\r\n * signature, in the given byte vector. This includes the 6 header bytes (attribute_name_index and\r\n * attribute_length) per attribute.\r\n *\r\n * @param symbolTable where the constants used in the attributes must be stored.\r\n * @param accessFlags some field, method or class access flags.\r\n * @param signatureIndex the constant pool index of a field, method of class signature.\r\n * @param output where the attributes must be written.\r\n */\r\nstatic void putAttributes(final SymbolTable symbolTable, final int accessFlags, final int signatureIndex, final ByteVector output) {\r\n    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);\r\n    }\r\n    if (signatureIndex != 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)).putInt(2).putShort(signatureIndex);\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);\r\n    }\r\n}",
    "comment": "\n   * Puts all the attributes that correspond to the given field, method or class access flags and\n   * signature, in the given byte vector. This includes the 6 header bytes (attribute_name_index and\n   * attribute_length) per attribute.\n   *\n   * @param symbolTable where the constants used in the attributes must be stored.\n   * @param accessFlags some field, method or class access flags.\n   * @param signatureIndex the constant pool index of a field, method of class signature.\n   * @param output where the attributes must be written.\n   "
  },
  {
    "entityId": "org.springframework.asm.Set",
    "entityType": "class",
    "code": "private static final int SIZE_INCREMENT = 6;\nprivate int size;\nprivate Attribute[] data = new Attribute[SIZE_INCREMENT];\nvoid addAttributes(final Attribute attributeList) {\r\n    Attribute attribute = attributeList;\r\n    while (attribute != null) {\r\n        if (!contains(attribute)) {\r\n            add(attribute);\r\n        }\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n}\nAttribute[] toArray() {\r\n    Attribute[] result = new Attribute[size];\r\n    System.arraycopy(data, 0, result, 0, size);\r\n    return result;\r\n}\nprivate boolean contains(final Attribute attribute) {\r\n    for (int i = 0; i < size; ++i) {\r\n        if (data[i].type.equals(attribute.type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\nprivate void add(final Attribute attribute) {\r\n    if (size >= data.length) {\r\n        Attribute[] newData = new Attribute[data.length + SIZE_INCREMENT];\r\n        System.arraycopy(data, 0, newData, 0, size);\r\n        data = newData;\r\n    }\r\n    data[size++] = attribute;\r\n}",
    "comment": " A set of attribute prototypes (attributes with the same type are considered equal). "
  },
  {
    "entityId": "org.springframework.asm.Set#addAttributes(Attribute)",
    "entityType": "method",
    "code": "void addAttributes(final Attribute attributeList) {\r\n    Attribute attribute = attributeList;\r\n    while (attribute != null) {\r\n        if (!contains(attribute)) {\r\n            add(attribute);\r\n        }\r\n        attribute = attribute.nextAttribute;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Set#toArray()",
    "entityType": "method",
    "code": "Attribute[] toArray() {\r\n    Attribute[] result = new Attribute[size];\r\n    System.arraycopy(data, 0, result, 0, size);\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Set#contains(Attribute)",
    "entityType": "method",
    "code": "private boolean contains(final Attribute attribute) {\r\n    for (int i = 0; i < size; ++i) {\r\n        if (data[i].type.equals(attribute.type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Set#add(Attribute)",
    "entityType": "method",
    "code": "private void add(final Attribute attribute) {\r\n    if (size >= data.length) {\r\n        Attribute[] newData = new Attribute[data.length + SIZE_INCREMENT];\r\n        System.arraycopy(data, 0, newData, 0, size);\r\n        data = newData;\r\n    }\r\n    data[size++] = attribute;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParserTests",
    "entityType": "class",
    "code": "// Tests with only the basic placeholder feature enabled\r\n@Nested\r\nclass OnlyPlaceholderTests {\r\n\r\n    private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", null, null, true);\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"placeholders\")\r\n    void placeholderIsReplaced(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"firstName\", \"John\");\r\n        properties.setProperty(\"nested0\", \"first\");\r\n        properties.setProperty(\"nested1\", \"Name\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> placeholders() {\r\n        return Stream.of(Arguments.of(\"${firstName}\", \"John\"), Arguments.of(\"$${firstName}\", \"$John\"), Arguments.of(\"}${firstName}\", \"}John\"), Arguments.of(\"${firstName}$\", \"John$\"), Arguments.of(\"${firstName}}\", \"John}\"), Arguments.of(\"${firstName} ${firstName}\", \"John John\"), Arguments.of(\"First name: ${firstName}\", \"First name: John\"), Arguments.of(\"${firstName} is the first name\", \"John is the first name\"), Arguments.of(\"${first${nested1}}\", \"John\"), Arguments.of(\"${${nested0}${nested1}}\", \"John\"));\r\n    }\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"nestedPlaceholders\")\r\n    void nestedPlaceholdersAreReplaced(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"p1\", \"v1\");\r\n        properties.setProperty(\"p2\", \"v2\");\r\n        // nested placeholders\r\n        properties.setProperty(\"p3\", \"${p1}:${p2}\");\r\n        // deeply nested placeholders\r\n        properties.setProperty(\"p4\", \"${p3}\");\r\n        // unresolvable placeholder\r\n        properties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> nestedPlaceholders() {\r\n        return Stream.of(Arguments.of(\"${p1}:${p2}\", \"v1:v2\"), Arguments.of(\"${p3}\", \"v1:v2\"), Arguments.of(\"${p4}\", \"v1:v2\"), Arguments.of(\"${p5}\", \"v1:v2:${bogus}\"), Arguments.of(\"${p0${p0}}\", \"${p0${p0}}\"));\r\n    }\r\n\r\n    @Test\r\n    void parseWithSinglePlaceholder() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n        assertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver)).isEqualTo(\"John\");\r\n        verify(resolver).resolvePlaceholder(\"firstName\");\r\n        verifyNoMoreInteractions(resolver);\r\n    }\r\n\r\n    @Test\r\n    void parseWithPlaceholderAndPrefixText() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n        assertThat(this.parser.replacePlaceholders(\"This is ${firstName}\", resolver)).isEqualTo(\"This is John\");\r\n        verify(resolver).resolvePlaceholder(\"firstName\");\r\n        verifyNoMoreInteractions(resolver);\r\n    }\r\n\r\n    @Test\r\n    void parseWithMultiplePlaceholdersAndText() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"lastName\", \"Smith\");\r\n        assertThat(this.parser.replacePlaceholders(\"User: ${firstName} - ${lastName}.\", resolver)).isEqualTo(\"User: John - Smith.\");\r\n        verify(resolver).resolvePlaceholder(\"firstName\");\r\n        verify(resolver).resolvePlaceholder(\"lastName\");\r\n        verifyNoMoreInteractions(resolver);\r\n    }\r\n\r\n    @Test\r\n    void parseWithNestedPlaceholderInKey() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"nested\", \"Name\", \"firstName\", \"John\");\r\n        assertThat(this.parser.replacePlaceholders(\"${first${nested}}\", resolver)).isEqualTo(\"John\");\r\n        verifyPlaceholderResolutions(resolver, \"nested\", \"firstName\");\r\n    }\r\n\r\n    @Test\r\n    void parseWithMultipleNestedPlaceholdersInKey() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"nested0\", \"first\", \"nested1\", \"Name\", \"firstName\", \"John\");\r\n        assertThat(this.parser.replacePlaceholders(\"${${nested0}${nested1}}\", resolver)).isEqualTo(\"John\");\r\n        verifyPlaceholderResolutions(resolver, \"nested0\", \"nested1\", \"firstName\");\r\n    }\r\n\r\n    @Test\r\n    void placeholdersWithSeparatorAreHandledAsIs() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"my:test\", \"value\");\r\n        assertThat(this.parser.replacePlaceholders(\"${my:test}\", resolver)).isEqualTo(\"value\");\r\n        verifyPlaceholderResolutions(resolver, \"my:test\");\r\n    }\r\n\r\n    @Test\r\n    void placeholdersWithoutEscapeCharAreNotEscaped() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"test\", \"value\");\r\n        assertThat(this.parser.replacePlaceholders(\"\\\\${test}\", resolver)).isEqualTo(\"\\\\value\");\r\n        verifyPlaceholderResolutions(resolver, \"test\");\r\n    }\r\n\r\n    @Test\r\n    void textWithInvalidPlaceholderIsMerged() {\r\n        String text = \"test${of${with${and${\";\r\n        ParsedValue parsedValue = this.parser.parse(text);\r\n        assertThat(parsedValue.parts()).singleElement().isInstanceOfSatisfying(TextPart.class, textPart -> assertThat(textPart.text()).isEqualTo(text));\r\n    }\r\n}\n// Tests with the use of a separator\r\n@Nested\r\nclass DefaultValueTests {\r\n\r\n    private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", null, true);\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"placeholders\")\r\n    void placeholderIsReplaced(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"firstName\", \"John\");\r\n        properties.setProperty(\"nested0\", \"first\");\r\n        properties.setProperty(\"nested1\", \"Name\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> placeholders() {\r\n        return Stream.of(Arguments.of(\"${invalid:John}\", \"John\"), Arguments.of(\"${first${invalid:Name}}\", \"John\"), Arguments.of(\"${invalid:${firstName}}\", \"John\"), Arguments.of(\"${invalid:${${nested0}${nested1}}}\", \"John\"), Arguments.of(\"${invalid:$${firstName}}\", \"$John\"), Arguments.of(\"${invalid: }${firstName}\", \" John\"), Arguments.of(\"${invalid:}\", \"\"), Arguments.of(\"${:}\", \"\"));\r\n    }\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"nestedPlaceholders\")\r\n    void nestedPlaceholdersAreReplaced(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"p1\", \"v1\");\r\n        properties.setProperty(\"p2\", \"v2\");\r\n        // nested placeholders\r\n        properties.setProperty(\"p3\", \"${p1}:${p2}\");\r\n        // deeply nested placeholders\r\n        properties.setProperty(\"p4\", \"${p3}\");\r\n        // unresolvable placeholder\r\n        properties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");\r\n        // unresolvable w/ default\r\n        properties.setProperty(\"p6\", \"${p1}:${p2}:${bogus:def}\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> nestedPlaceholders() {\r\n        return Stream.of(Arguments.of(\"${p6}\", \"v1:v2:def\"), Arguments.of(\"${p6:not-used}\", \"v1:v2:def\"), Arguments.of(\"${p6:${invalid}}\", \"v1:v2:def\"), Arguments.of(\"${invalid:${p1}:${p2}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p3}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p4}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p5}}\", \"v1:v2:${bogus}\"), Arguments.of(\"${invalid:${p6}}\", \"v1:v2:def\"));\r\n    }\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"exactMatchPlaceholders\")\r\n    void placeholdersWithExactMatchAreConsidered(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"prefix://my-service\", \"example-service\");\r\n        properties.setProperty(\"px\", \"prefix\");\r\n        properties.setProperty(\"p1\", \"${prefix://my-service}\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> exactMatchPlaceholders() {\r\n        return Stream.of(Arguments.of(\"${prefix://my-service}\", \"example-service\"), Arguments.of(\"${p1}\", \"example-service\"));\r\n    }\r\n\r\n    @Test\r\n    void parseWithKeyEqualsToText() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"Steve\");\r\n        assertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver)).isEqualTo(\"Steve\");\r\n        verifyPlaceholderResolutions(resolver, \"firstName\");\r\n    }\r\n\r\n    @Test\r\n    void parseWithHardcodedFallback() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver();\r\n        assertThat(this.parser.replacePlaceholders(\"${firstName:Steve}\", resolver)).isEqualTo(\"Steve\");\r\n        verifyPlaceholderResolutions(resolver, \"firstName:Steve\", \"firstName\");\r\n    }\r\n\r\n    @Test\r\n    void parseWithNestedPlaceholderInKeyUsingFallback() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n        assertThat(this.parser.replacePlaceholders(\"${first${invalid:Name}}\", resolver)).isEqualTo(\"John\");\r\n        verifyPlaceholderResolutions(resolver, \"invalid:Name\", \"invalid\", \"firstName\");\r\n    }\r\n\r\n    @Test\r\n    void parseWithFallbackUsingPlaceholder() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n        assertThat(this.parser.replacePlaceholders(\"${invalid:${firstName}}\", resolver)).isEqualTo(\"John\");\r\n        verifyPlaceholderResolutions(resolver, \"invalid\", \"firstName\");\r\n    }\r\n}\n// Tests with the use of the escape character\r\n@Nested\r\nclass EscapedTests {\r\n\r\n    private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", '\\\\', true);\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"escapedInNestedPlaceholders\")\r\n    void escapedSeparatorInNestedPlaceholder(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"app.environment\", \"qa\");\r\n        properties.setProperty(\"app.service\", \"protocol\");\r\n        properties.setProperty(\"protocol://host/qa/name\", \"protocol://example.com/qa/name\");\r\n        properties.setProperty(\"service/host/qa/name\", \"https://example.com/qa/name\");\r\n        properties.setProperty(\"service/host/qa/name:value\", \"https://example.com/qa/name-value\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> escapedInNestedPlaceholders() {\r\n        return Stream.of(Arguments.of(\"${protocol\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"), Arguments.of(\"${${app.service}\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"), Arguments.of(\"${service/host/${app.environment}/name:\\\\value}\", \"https://example.com/qa/name\"), Arguments.of(\"${service/host/${name\\\\:value}/}\", \"${service/host/${name:value}/}\"));\r\n    }\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"escapedPlaceholders\")\r\n    void escapedPlaceholderIsNotReplaced(String text, String expected) {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"nested0\", \"first\", \"nested1\", \"Name\", \"${test}\", \"John\", \"p1\", \"v1\", \"p2\", \"\\\\${p1:default}\", \"p3\", \"${p2}\", \"p4\", \"adc${p0:\\\\${p1}}\", \"p5\", \"adc${\\\\${p0}:${p1}}\", \"p6\", \"adc${p0:def\\\\${p1}}\", \"p7\", \"adc\\\\${\");\r\n        assertThat(this.parser.replacePlaceholders(text, resolver)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> escapedPlaceholders() {\r\n        return Stream.of(Arguments.of(\"\\\\${firstName}\", \"${firstName}\"), Arguments.of(\"First name: \\\\${firstName}\", \"First name: ${firstName}\"), Arguments.of(\"$\\\\${firstName}\", \"$${firstName}\"), Arguments.of(\"\\\\}${firstName}\", \"\\\\}John\"), Arguments.of(\"${\\\\${test}}\", \"John\"), Arguments.of(\"${p2}\", \"${p1:default}\"), Arguments.of(\"${p3}\", \"${p1:default}\"), Arguments.of(\"${p4}\", \"adc${p1}\"), Arguments.of(\"${p5}\", \"adcv1\"), Arguments.of(\"${p6}\", \"adcdef${p1}\"), Arguments.of(\"${p7}\", \"adc\\\\${\"));\r\n    }\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"escapedSeparators\")\r\n    void escapedSeparatorIsNotReplaced(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"first:Name\", \"John\");\r\n        properties.setProperty(\"nested0\", \"first\");\r\n        properties.setProperty(\"nested1\", \"Name\");\r\n        assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> escapedSeparators() {\r\n        return Stream.of(Arguments.of(\"${first\\\\:Name}\", \"John\"), Arguments.of(\"${last\\\\:Name}\", \"${last:Name}\"));\r\n    }\r\n}\n@Nested\r\nclass ExceptionTests {\r\n\r\n    private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", null, false);\r\n\r\n    @Test\r\n    void textWithCircularReference() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"pL\", \"${pR}\", \"pR\", \"${pL}\");\r\n        assertThatThrownBy(() -> this.parser.replacePlaceholders(\"${pL}\", resolver)).isInstanceOf(PlaceholderResolutionException.class).hasMessage(\"Circular placeholder reference 'pL' in value \\\"${pL}\\\" <-- \\\"${pR}\\\" <-- \\\"${pL}\\\"\");\r\n    }\r\n\r\n    @Test\r\n    void unresolvablePlaceholderIsReported() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver();\r\n        assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${bogus}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${bogus}\\\"\").withNoCause();\r\n    }\r\n\r\n    @Test\r\n    void unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"p1\", \"v1\", \"p2\", \"v2\", \"p3\", \"${p1}:${p2}:${bogus}\");\r\n        assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${p3}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\" <-- \\\"${p3}\\\"\").withNoCause();\r\n    }\r\n}\nPlaceholderResolver mockPlaceholderResolver(String... pairs) {\r\n    if (pairs.length % 2 == 1) {\r\n        throw new IllegalArgumentException(\"size must be even, it is a set of key=value pairs\");\r\n    }\r\n    PlaceholderResolver resolver = mock();\r\n    for (int i = 0; i < pairs.length; i += 2) {\r\n        String key = pairs[i];\r\n        String value = pairs[i + 1];\r\n        given(resolver.resolvePlaceholder(key)).willReturn(value);\r\n    }\r\n    return resolver;\r\n}\nvoid verifyPlaceholderResolutions(PlaceholderResolver mock, String... placeholders) {\r\n    InOrder ordered = inOrder(mock);\r\n    for (String placeholder : placeholders) {\r\n        ordered.verify(mock).resolvePlaceholder(placeholder);\r\n    }\r\n    verifyNoMoreInteractions(mock);\r\n}",
    "comment": "\n * Tests for {@link PlaceholderParser}.\n *\n * @author Stephane Nicoll\n "
  },
  {
    "entityId": "org.springframework.util.PlaceholderParserTests#mockPlaceholderResolver(String)",
    "entityType": "method",
    "code": "PlaceholderResolver mockPlaceholderResolver(String... pairs) {\r\n    if (pairs.length % 2 == 1) {\r\n        throw new IllegalArgumentException(\"size must be even, it is a set of key=value pairs\");\r\n    }\r\n    PlaceholderResolver resolver = mock();\r\n    for (int i = 0; i < pairs.length; i += 2) {\r\n        String key = pairs[i];\r\n        String value = pairs[i + 1];\r\n        given(resolver.resolvePlaceholder(key)).willReturn(value);\r\n    }\r\n    return resolver;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PlaceholderParserTests#verifyPlaceholderResolutions(PlaceholderResolver,String)",
    "entityType": "method",
    "code": "void verifyPlaceholderResolutions(PlaceholderResolver mock, String... placeholders) {\r\n    InOrder ordered = inOrder(mock);\r\n    for (String placeholder : placeholders) {\r\n        ordered.verify(mock).resolvePlaceholder(placeholder);\r\n    }\r\n    verifyNoMoreInteractions(mock);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests",
    "entityType": "class",
    "code": "private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", null, null, true);\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"placeholders\")\r\nvoid placeholderIsReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"firstName\", \"John\");\r\n    properties.setProperty(\"nested0\", \"first\");\r\n    properties.setProperty(\"nested1\", \"Name\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> placeholders() {\r\n    return Stream.of(Arguments.of(\"${firstName}\", \"John\"), Arguments.of(\"$${firstName}\", \"$John\"), Arguments.of(\"}${firstName}\", \"}John\"), Arguments.of(\"${firstName}$\", \"John$\"), Arguments.of(\"${firstName}}\", \"John}\"), Arguments.of(\"${firstName} ${firstName}\", \"John John\"), Arguments.of(\"First name: ${firstName}\", \"First name: John\"), Arguments.of(\"${firstName} is the first name\", \"John is the first name\"), Arguments.of(\"${first${nested1}}\", \"John\"), Arguments.of(\"${${nested0}${nested1}}\", \"John\"));\r\n}\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"nestedPlaceholders\")\r\nvoid nestedPlaceholdersAreReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"p1\", \"v1\");\r\n    properties.setProperty(\"p2\", \"v2\");\r\n    // nested placeholders\r\n    properties.setProperty(\"p3\", \"${p1}:${p2}\");\r\n    // deeply nested placeholders\r\n    properties.setProperty(\"p4\", \"${p3}\");\r\n    // unresolvable placeholder\r\n    properties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> nestedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${p1}:${p2}\", \"v1:v2\"), Arguments.of(\"${p3}\", \"v1:v2\"), Arguments.of(\"${p4}\", \"v1:v2\"), Arguments.of(\"${p5}\", \"v1:v2:${bogus}\"), Arguments.of(\"${p0${p0}}\", \"${p0${p0}}\"));\r\n}\n@Test\r\nvoid parseWithSinglePlaceholder() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver)).isEqualTo(\"John\");\r\n    verify(resolver).resolvePlaceholder(\"firstName\");\r\n    verifyNoMoreInteractions(resolver);\r\n}\n@Test\r\nvoid parseWithPlaceholderAndPrefixText() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"This is ${firstName}\", resolver)).isEqualTo(\"This is John\");\r\n    verify(resolver).resolvePlaceholder(\"firstName\");\r\n    verifyNoMoreInteractions(resolver);\r\n}\n@Test\r\nvoid parseWithMultiplePlaceholdersAndText() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"lastName\", \"Smith\");\r\n    assertThat(this.parser.replacePlaceholders(\"User: ${firstName} - ${lastName}.\", resolver)).isEqualTo(\"User: John - Smith.\");\r\n    verify(resolver).resolvePlaceholder(\"firstName\");\r\n    verify(resolver).resolvePlaceholder(\"lastName\");\r\n    verifyNoMoreInteractions(resolver);\r\n}\n@Test\r\nvoid parseWithNestedPlaceholderInKey() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"nested\", \"Name\", \"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${first${nested}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"nested\", \"firstName\");\r\n}\n@Test\r\nvoid parseWithMultipleNestedPlaceholdersInKey() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"nested0\", \"first\", \"nested1\", \"Name\", \"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${${nested0}${nested1}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"nested0\", \"nested1\", \"firstName\");\r\n}\n@Test\r\nvoid placeholdersWithSeparatorAreHandledAsIs() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"my:test\", \"value\");\r\n    assertThat(this.parser.replacePlaceholders(\"${my:test}\", resolver)).isEqualTo(\"value\");\r\n    verifyPlaceholderResolutions(resolver, \"my:test\");\r\n}\n@Test\r\nvoid placeholdersWithoutEscapeCharAreNotEscaped() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"test\", \"value\");\r\n    assertThat(this.parser.replacePlaceholders(\"\\\\${test}\", resolver)).isEqualTo(\"\\\\value\");\r\n    verifyPlaceholderResolutions(resolver, \"test\");\r\n}\n@Test\r\nvoid textWithInvalidPlaceholderIsMerged() {\r\n    String text = \"test${of${with${and${\";\r\n    ParsedValue parsedValue = this.parser.parse(text);\r\n    assertThat(parsedValue.parts()).singleElement().isInstanceOfSatisfying(TextPart.class, textPart -> assertThat(textPart.text()).isEqualTo(text));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#placeholderIsReplaced(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"placeholders\")\r\nvoid placeholderIsReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"firstName\", \"John\");\r\n    properties.setProperty(\"nested0\", \"first\");\r\n    properties.setProperty(\"nested1\", \"Name\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#placeholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> placeholders() {\r\n    return Stream.of(Arguments.of(\"${firstName}\", \"John\"), Arguments.of(\"$${firstName}\", \"$John\"), Arguments.of(\"}${firstName}\", \"}John\"), Arguments.of(\"${firstName}$\", \"John$\"), Arguments.of(\"${firstName}}\", \"John}\"), Arguments.of(\"${firstName} ${firstName}\", \"John John\"), Arguments.of(\"First name: ${firstName}\", \"First name: John\"), Arguments.of(\"${firstName} is the first name\", \"John is the first name\"), Arguments.of(\"${first${nested1}}\", \"John\"), Arguments.of(\"${${nested0}${nested1}}\", \"John\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#nestedPlaceholdersAreReplaced(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"nestedPlaceholders\")\r\nvoid nestedPlaceholdersAreReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"p1\", \"v1\");\r\n    properties.setProperty(\"p2\", \"v2\");\r\n    // nested placeholders\r\n    properties.setProperty(\"p3\", \"${p1}:${p2}\");\r\n    // deeply nested placeholders\r\n    properties.setProperty(\"p4\", \"${p3}\");\r\n    // unresolvable placeholder\r\n    properties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#nestedPlaceholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> nestedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${p1}:${p2}\", \"v1:v2\"), Arguments.of(\"${p3}\", \"v1:v2\"), Arguments.of(\"${p4}\", \"v1:v2\"), Arguments.of(\"${p5}\", \"v1:v2:${bogus}\"), Arguments.of(\"${p0${p0}}\", \"${p0${p0}}\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#parseWithSinglePlaceholder()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithSinglePlaceholder() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver)).isEqualTo(\"John\");\r\n    verify(resolver).resolvePlaceholder(\"firstName\");\r\n    verifyNoMoreInteractions(resolver);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#parseWithPlaceholderAndPrefixText()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithPlaceholderAndPrefixText() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"This is ${firstName}\", resolver)).isEqualTo(\"This is John\");\r\n    verify(resolver).resolvePlaceholder(\"firstName\");\r\n    verifyNoMoreInteractions(resolver);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#parseWithMultiplePlaceholdersAndText()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithMultiplePlaceholdersAndText() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"lastName\", \"Smith\");\r\n    assertThat(this.parser.replacePlaceholders(\"User: ${firstName} - ${lastName}.\", resolver)).isEqualTo(\"User: John - Smith.\");\r\n    verify(resolver).resolvePlaceholder(\"firstName\");\r\n    verify(resolver).resolvePlaceholder(\"lastName\");\r\n    verifyNoMoreInteractions(resolver);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#parseWithNestedPlaceholderInKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNestedPlaceholderInKey() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"nested\", \"Name\", \"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${first${nested}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"nested\", \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#parseWithMultipleNestedPlaceholdersInKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithMultipleNestedPlaceholdersInKey() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"nested0\", \"first\", \"nested1\", \"Name\", \"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${${nested0}${nested1}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"nested0\", \"nested1\", \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#placeholdersWithSeparatorAreHandledAsIs()",
    "entityType": "method",
    "code": "@Test\r\nvoid placeholdersWithSeparatorAreHandledAsIs() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"my:test\", \"value\");\r\n    assertThat(this.parser.replacePlaceholders(\"${my:test}\", resolver)).isEqualTo(\"value\");\r\n    verifyPlaceholderResolutions(resolver, \"my:test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#placeholdersWithoutEscapeCharAreNotEscaped()",
    "entityType": "method",
    "code": "@Test\r\nvoid placeholdersWithoutEscapeCharAreNotEscaped() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"test\", \"value\");\r\n    assertThat(this.parser.replacePlaceholders(\"\\\\${test}\", resolver)).isEqualTo(\"\\\\value\");\r\n    verifyPlaceholderResolutions(resolver, \"test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.OnlyPlaceholderTests#textWithInvalidPlaceholderIsMerged()",
    "entityType": "method",
    "code": "@Test\r\nvoid textWithInvalidPlaceholderIsMerged() {\r\n    String text = \"test${of${with${and${\";\r\n    ParsedValue parsedValue = this.parser.parse(text);\r\n    assertThat(parsedValue.parts()).singleElement().isInstanceOfSatisfying(TextPart.class, textPart -> assertThat(textPart.text()).isEqualTo(text));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests",
    "entityType": "class",
    "code": "private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", null, true);\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"placeholders\")\r\nvoid placeholderIsReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"firstName\", \"John\");\r\n    properties.setProperty(\"nested0\", \"first\");\r\n    properties.setProperty(\"nested1\", \"Name\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> placeholders() {\r\n    return Stream.of(Arguments.of(\"${invalid:John}\", \"John\"), Arguments.of(\"${first${invalid:Name}}\", \"John\"), Arguments.of(\"${invalid:${firstName}}\", \"John\"), Arguments.of(\"${invalid:${${nested0}${nested1}}}\", \"John\"), Arguments.of(\"${invalid:$${firstName}}\", \"$John\"), Arguments.of(\"${invalid: }${firstName}\", \" John\"), Arguments.of(\"${invalid:}\", \"\"), Arguments.of(\"${:}\", \"\"));\r\n}\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"nestedPlaceholders\")\r\nvoid nestedPlaceholdersAreReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"p1\", \"v1\");\r\n    properties.setProperty(\"p2\", \"v2\");\r\n    // nested placeholders\r\n    properties.setProperty(\"p3\", \"${p1}:${p2}\");\r\n    // deeply nested placeholders\r\n    properties.setProperty(\"p4\", \"${p3}\");\r\n    // unresolvable placeholder\r\n    properties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");\r\n    // unresolvable w/ default\r\n    properties.setProperty(\"p6\", \"${p1}:${p2}:${bogus:def}\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> nestedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${p6}\", \"v1:v2:def\"), Arguments.of(\"${p6:not-used}\", \"v1:v2:def\"), Arguments.of(\"${p6:${invalid}}\", \"v1:v2:def\"), Arguments.of(\"${invalid:${p1}:${p2}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p3}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p4}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p5}}\", \"v1:v2:${bogus}\"), Arguments.of(\"${invalid:${p6}}\", \"v1:v2:def\"));\r\n}\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"exactMatchPlaceholders\")\r\nvoid placeholdersWithExactMatchAreConsidered(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"prefix://my-service\", \"example-service\");\r\n    properties.setProperty(\"px\", \"prefix\");\r\n    properties.setProperty(\"p1\", \"${prefix://my-service}\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> exactMatchPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${prefix://my-service}\", \"example-service\"), Arguments.of(\"${p1}\", \"example-service\"));\r\n}\n@Test\r\nvoid parseWithKeyEqualsToText() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"Steve\");\r\n    assertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver)).isEqualTo(\"Steve\");\r\n    verifyPlaceholderResolutions(resolver, \"firstName\");\r\n}\n@Test\r\nvoid parseWithHardcodedFallback() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver();\r\n    assertThat(this.parser.replacePlaceholders(\"${firstName:Steve}\", resolver)).isEqualTo(\"Steve\");\r\n    verifyPlaceholderResolutions(resolver, \"firstName:Steve\", \"firstName\");\r\n}\n@Test\r\nvoid parseWithNestedPlaceholderInKeyUsingFallback() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${first${invalid:Name}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"invalid:Name\", \"invalid\", \"firstName\");\r\n}\n@Test\r\nvoid parseWithFallbackUsingPlaceholder() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${invalid:${firstName}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"invalid\", \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#placeholderIsReplaced(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"placeholders\")\r\nvoid placeholderIsReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"firstName\", \"John\");\r\n    properties.setProperty(\"nested0\", \"first\");\r\n    properties.setProperty(\"nested1\", \"Name\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#placeholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> placeholders() {\r\n    return Stream.of(Arguments.of(\"${invalid:John}\", \"John\"), Arguments.of(\"${first${invalid:Name}}\", \"John\"), Arguments.of(\"${invalid:${firstName}}\", \"John\"), Arguments.of(\"${invalid:${${nested0}${nested1}}}\", \"John\"), Arguments.of(\"${invalid:$${firstName}}\", \"$John\"), Arguments.of(\"${invalid: }${firstName}\", \" John\"), Arguments.of(\"${invalid:}\", \"\"), Arguments.of(\"${:}\", \"\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#nestedPlaceholdersAreReplaced(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"nestedPlaceholders\")\r\nvoid nestedPlaceholdersAreReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"p1\", \"v1\");\r\n    properties.setProperty(\"p2\", \"v2\");\r\n    // nested placeholders\r\n    properties.setProperty(\"p3\", \"${p1}:${p2}\");\r\n    // deeply nested placeholders\r\n    properties.setProperty(\"p4\", \"${p3}\");\r\n    // unresolvable placeholder\r\n    properties.setProperty(\"p5\", \"${p1}:${p2}:${bogus}\");\r\n    // unresolvable w/ default\r\n    properties.setProperty(\"p6\", \"${p1}:${p2}:${bogus:def}\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#nestedPlaceholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> nestedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${p6}\", \"v1:v2:def\"), Arguments.of(\"${p6:not-used}\", \"v1:v2:def\"), Arguments.of(\"${p6:${invalid}}\", \"v1:v2:def\"), Arguments.of(\"${invalid:${p1}:${p2}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p3}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p4}}\", \"v1:v2\"), Arguments.of(\"${invalid:${p5}}\", \"v1:v2:${bogus}\"), Arguments.of(\"${invalid:${p6}}\", \"v1:v2:def\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#placeholdersWithExactMatchAreConsidered(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"exactMatchPlaceholders\")\r\nvoid placeholdersWithExactMatchAreConsidered(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"prefix://my-service\", \"example-service\");\r\n    properties.setProperty(\"px\", \"prefix\");\r\n    properties.setProperty(\"p1\", \"${prefix://my-service}\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#exactMatchPlaceholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> exactMatchPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${prefix://my-service}\", \"example-service\"), Arguments.of(\"${p1}\", \"example-service\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#parseWithKeyEqualsToText()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithKeyEqualsToText() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"Steve\");\r\n    assertThat(this.parser.replacePlaceholders(\"${firstName}\", resolver)).isEqualTo(\"Steve\");\r\n    verifyPlaceholderResolutions(resolver, \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#parseWithHardcodedFallback()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithHardcodedFallback() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver();\r\n    assertThat(this.parser.replacePlaceholders(\"${firstName:Steve}\", resolver)).isEqualTo(\"Steve\");\r\n    verifyPlaceholderResolutions(resolver, \"firstName:Steve\", \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#parseWithNestedPlaceholderInKeyUsingFallback()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithNestedPlaceholderInKeyUsingFallback() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${first${invalid:Name}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"invalid:Name\", \"invalid\", \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DefaultValueTests#parseWithFallbackUsingPlaceholder()",
    "entityType": "method",
    "code": "@Test\r\nvoid parseWithFallbackUsingPlaceholder() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\");\r\n    assertThat(this.parser.replacePlaceholders(\"${invalid:${firstName}}\", resolver)).isEqualTo(\"John\");\r\n    verifyPlaceholderResolutions(resolver, \"invalid\", \"firstName\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests",
    "entityType": "class",
    "code": "private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", '\\\\', true);\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"escapedInNestedPlaceholders\")\r\nvoid escapedSeparatorInNestedPlaceholder(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"app.environment\", \"qa\");\r\n    properties.setProperty(\"app.service\", \"protocol\");\r\n    properties.setProperty(\"protocol://host/qa/name\", \"protocol://example.com/qa/name\");\r\n    properties.setProperty(\"service/host/qa/name\", \"https://example.com/qa/name\");\r\n    properties.setProperty(\"service/host/qa/name:value\", \"https://example.com/qa/name-value\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> escapedInNestedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${protocol\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"), Arguments.of(\"${${app.service}\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"), Arguments.of(\"${service/host/${app.environment}/name:\\\\value}\", \"https://example.com/qa/name\"), Arguments.of(\"${service/host/${name\\\\:value}/}\", \"${service/host/${name:value}/}\"));\r\n}\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"escapedPlaceholders\")\r\nvoid escapedPlaceholderIsNotReplaced(String text, String expected) {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"nested0\", \"first\", \"nested1\", \"Name\", \"${test}\", \"John\", \"p1\", \"v1\", \"p2\", \"\\\\${p1:default}\", \"p3\", \"${p2}\", \"p4\", \"adc${p0:\\\\${p1}}\", \"p5\", \"adc${\\\\${p0}:${p1}}\", \"p6\", \"adc${p0:def\\\\${p1}}\", \"p7\", \"adc\\\\${\");\r\n    assertThat(this.parser.replacePlaceholders(text, resolver)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> escapedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"\\\\${firstName}\", \"${firstName}\"), Arguments.of(\"First name: \\\\${firstName}\", \"First name: ${firstName}\"), Arguments.of(\"$\\\\${firstName}\", \"$${firstName}\"), Arguments.of(\"\\\\}${firstName}\", \"\\\\}John\"), Arguments.of(\"${\\\\${test}}\", \"John\"), Arguments.of(\"${p2}\", \"${p1:default}\"), Arguments.of(\"${p3}\", \"${p1:default}\"), Arguments.of(\"${p4}\", \"adc${p1}\"), Arguments.of(\"${p5}\", \"adcv1\"), Arguments.of(\"${p6}\", \"adcdef${p1}\"), Arguments.of(\"${p7}\", \"adc\\\\${\"));\r\n}\n@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"escapedSeparators\")\r\nvoid escapedSeparatorIsNotReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"first:Name\", \"John\");\r\n    properties.setProperty(\"nested0\", \"first\");\r\n    properties.setProperty(\"nested1\", \"Name\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}\nstatic Stream<Arguments> escapedSeparators() {\r\n    return Stream.of(Arguments.of(\"${first\\\\:Name}\", \"John\"), Arguments.of(\"${last\\\\:Name}\", \"${last:Name}\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests#escapedSeparatorInNestedPlaceholder(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"escapedInNestedPlaceholders\")\r\nvoid escapedSeparatorInNestedPlaceholder(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"app.environment\", \"qa\");\r\n    properties.setProperty(\"app.service\", \"protocol\");\r\n    properties.setProperty(\"protocol://host/qa/name\", \"protocol://example.com/qa/name\");\r\n    properties.setProperty(\"service/host/qa/name\", \"https://example.com/qa/name\");\r\n    properties.setProperty(\"service/host/qa/name:value\", \"https://example.com/qa/name-value\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests#escapedInNestedPlaceholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> escapedInNestedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"${protocol\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"), Arguments.of(\"${${app.service}\\\\://host/${app.environment}/name}\", \"protocol://example.com/qa/name\"), Arguments.of(\"${service/host/${app.environment}/name:\\\\value}\", \"https://example.com/qa/name\"), Arguments.of(\"${service/host/${name\\\\:value}/}\", \"${service/host/${name:value}/}\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests#escapedPlaceholderIsNotReplaced(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"escapedPlaceholders\")\r\nvoid escapedPlaceholderIsNotReplaced(String text, String expected) {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"firstName\", \"John\", \"nested0\", \"first\", \"nested1\", \"Name\", \"${test}\", \"John\", \"p1\", \"v1\", \"p2\", \"\\\\${p1:default}\", \"p3\", \"${p2}\", \"p4\", \"adc${p0:\\\\${p1}}\", \"p5\", \"adc${\\\\${p0}:${p1}}\", \"p6\", \"adc${p0:def\\\\${p1}}\", \"p7\", \"adc\\\\${\");\r\n    assertThat(this.parser.replacePlaceholders(text, resolver)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests#escapedPlaceholders()",
    "entityType": "method",
    "code": "static Stream<Arguments> escapedPlaceholders() {\r\n    return Stream.of(Arguments.of(\"\\\\${firstName}\", \"${firstName}\"), Arguments.of(\"First name: \\\\${firstName}\", \"First name: ${firstName}\"), Arguments.of(\"$\\\\${firstName}\", \"$${firstName}\"), Arguments.of(\"\\\\}${firstName}\", \"\\\\}John\"), Arguments.of(\"${\\\\${test}}\", \"John\"), Arguments.of(\"${p2}\", \"${p1:default}\"), Arguments.of(\"${p3}\", \"${p1:default}\"), Arguments.of(\"${p4}\", \"adc${p1}\"), Arguments.of(\"${p5}\", \"adcv1\"), Arguments.of(\"${p6}\", \"adcdef${p1}\"), Arguments.of(\"${p7}\", \"adc\\\\${\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests#escapedSeparatorIsNotReplaced(String,String)",
    "entityType": "method",
    "code": "@ParameterizedTest(name = \"{0} -> {1}\")\r\n@MethodSource(\"escapedSeparators\")\r\nvoid escapedSeparatorIsNotReplaced(String text, String expected) {\r\n    Properties properties = new Properties();\r\n    properties.setProperty(\"first:Name\", \"John\");\r\n    properties.setProperty(\"nested0\", \"first\");\r\n    properties.setProperty(\"nested1\", \"Name\");\r\n    assertThat(this.parser.replacePlaceholders(text, properties::getProperty)).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EscapedTests#escapedSeparators()",
    "entityType": "method",
    "code": "static Stream<Arguments> escapedSeparators() {\r\n    return Stream.of(Arguments.of(\"${first\\\\:Name}\", \"John\"), Arguments.of(\"${last\\\\:Name}\", \"${last:Name}\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExceptionTests",
    "entityType": "class",
    "code": "private final PlaceholderParser parser = new PlaceholderParser(\"${\", \"}\", \":\", null, false);\n@Test\r\nvoid textWithCircularReference() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"pL\", \"${pR}\", \"pR\", \"${pL}\");\r\n    assertThatThrownBy(() -> this.parser.replacePlaceholders(\"${pL}\", resolver)).isInstanceOf(PlaceholderResolutionException.class).hasMessage(\"Circular placeholder reference 'pL' in value \\\"${pL}\\\" <-- \\\"${pR}\\\" <-- \\\"${pL}\\\"\");\r\n}\n@Test\r\nvoid unresolvablePlaceholderIsReported() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver();\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${bogus}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${bogus}\\\"\").withNoCause();\r\n}\n@Test\r\nvoid unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"p1\", \"v1\", \"p2\", \"v2\", \"p3\", \"${p1}:${p2}:${bogus}\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${p3}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\" <-- \\\"${p3}\\\"\").withNoCause();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExceptionTests#textWithCircularReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid textWithCircularReference() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"pL\", \"${pR}\", \"pR\", \"${pL}\");\r\n    assertThatThrownBy(() -> this.parser.replacePlaceholders(\"${pL}\", resolver)).isInstanceOf(PlaceholderResolutionException.class).hasMessage(\"Circular placeholder reference 'pL' in value \\\"${pL}\\\" <-- \\\"${pR}\\\" <-- \\\"${pL}\\\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExceptionTests#unresolvablePlaceholderIsReported()",
    "entityType": "method",
    "code": "@Test\r\nvoid unresolvablePlaceholderIsReported() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver();\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${bogus}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${bogus}\\\"\").withNoCause();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ExceptionTests#unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain()",
    "entityType": "method",
    "code": "@Test\r\nvoid unresolvablePlaceholderInNestedPlaceholderIsReportedWithChain() {\r\n    PlaceholderResolver resolver = mockPlaceholderResolver(\"p1\", \"v1\", \"p2\", \"v2\", \"p3\", \"${p1}:${p2}:${bogus}\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> this.parser.replacePlaceholders(\"${p3}\", resolver)).withMessage(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\" <-- \\\"${p3}\\\"\").withNoCause();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.ByteVector",
    "entityType": "class",
    "code": "/**\r\n * The content of this vector. Only the first {@link #length} bytes contain real data.\r\n */\r\nbyte[] data;\n/**\r\n * The actual number of bytes in this vector.\r\n */\r\nint length;\n/**\r\n * Constructs a new {@link ByteVector} with a default initial capacity.\r\n */\r\npublic ByteVector() {\r\n    data = new byte[64];\r\n}\n/**\r\n * Constructs a new {@link ByteVector} with the given initial capacity.\r\n *\r\n * @param initialCapacity the initial capacity of the byte vector to be constructed.\r\n */\r\npublic ByteVector(final int initialCapacity) {\r\n    data = new byte[initialCapacity];\r\n}\n/**\r\n * Constructs a new {@link ByteVector} from the given initial data.\r\n *\r\n * @param data the initial data of the new byte vector.\r\n */\r\nByteVector(final byte[] data) {\r\n    this.data = data;\r\n    this.length = data.length;\r\n}\n/**\r\n * Returns the actual number of bytes in this vector.\r\n *\r\n * @return the actual number of bytes in this vector.\r\n */\r\npublic int size() {\r\n    return length;\r\n}\n/**\r\n * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param byteValue a byte.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putByte(final int byteValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 1 > data.length) {\r\n        enlarge(1);\r\n    }\r\n    data[currentLength++] = (byte) byteValue;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param byteValue1 a byte.\r\n * @param byteValue2 another byte.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put11(final int byteValue1, final int byteValue2) {\r\n    int currentLength = length;\r\n    if (currentLength + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue1;\r\n    currentData[currentLength++] = (byte) byteValue2;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param shortValue a short.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putShort(final int shortValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param byteValue a byte.\r\n * @param shortValue a short.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put12(final int byteValue, final int shortValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 3 > data.length) {\r\n        enlarge(3);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param byteValue1 a byte.\r\n * @param byteValue2 another byte.\r\n * @param shortValue a short.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 4 > data.length) {\r\n        enlarge(4);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue1;\r\n    currentData[currentLength++] = (byte) byteValue2;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param intValue an int.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putInt(final int intValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 4 > data.length) {\r\n        enlarge(4);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\r\n * if necessary.\r\n *\r\n * @param byteValue a byte.\r\n * @param shortValue1 a short.\r\n * @param shortValue2 another short.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\r\n    int currentLength = length;\r\n    if (currentLength + 5 > data.length) {\r\n        enlarge(5);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue;\r\n    currentData[currentLength++] = (byte) (shortValue1 >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue1;\r\n    currentData[currentLength++] = (byte) (shortValue2 >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue2;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param longValue a long.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putLong(final long longValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 8 > data.length) {\r\n        enlarge(8);\r\n    }\r\n    byte[] currentData = data;\r\n    int intValue = (int) (longValue >>> 32);\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    intValue = (int) longValue;\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param stringValue a String whose UTF8 encoded length must be less than 65536.\r\n * @return this byte vector.\r\n */\r\n// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\r\npublic ByteVector putUTF8(final String stringValue) {\r\n    int charLength = stringValue.length();\r\n    if (charLength > 65535) {\r\n        throw new IllegalArgumentException(\"UTF8 string too large\");\r\n    }\r\n    int currentLength = length;\r\n    if (currentLength + 2 + charLength > data.length) {\r\n        enlarge(2 + charLength);\r\n    }\r\n    byte[] currentData = data;\r\n    // Optimistic algorithm: instead of computing the byte length and then serializing the string\r\n    // (which requires two loops), we assume the byte length is equal to char length (which is the\r\n    // most frequent case), and we start serializing the string right away. During the\r\n    // serialization, if we find that this assumption is wrong, we continue with the general method.\r\n    currentData[currentLength++] = (byte) (charLength >>> 8);\r\n    currentData[currentLength++] = (byte) charLength;\r\n    for (int i = 0; i < charLength; ++i) {\r\n        char charValue = stringValue.charAt(i);\r\n        if (charValue >= '\\u0001' && charValue <= '\\u007F') {\r\n            currentData[currentLength++] = (byte) charValue;\r\n        } else {\r\n            length = currentLength;\r\n            return encodeUtf8(stringValue, i, 65535);\r\n        }\r\n    }\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\r\n * necessary. The string length is encoded in two bytes before the encoded characters, if there is\r\n * space for that (i.e. if this.length - offset - 2 &gt;= 0).\r\n *\r\n * @param stringValue the String to encode.\r\n * @param offset the index of the first character to encode. The previous characters are supposed\r\n *     to have already been encoded, using only one byte per character.\r\n * @param maxByteLength the maximum byte length of the encoded string, including the already\r\n *     encoded characters.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\r\n    int charLength = stringValue.length();\r\n    int byteLength = offset;\r\n    for (int i = offset; i < charLength; ++i) {\r\n        char charValue = stringValue.charAt(i);\r\n        if (charValue >= 0x0001 && charValue <= 0x007F) {\r\n            byteLength++;\r\n        } else if (charValue <= 0x07FF) {\r\n            byteLength += 2;\r\n        } else {\r\n            byteLength += 3;\r\n        }\r\n    }\r\n    if (byteLength > maxByteLength) {\r\n        throw new IllegalArgumentException(\"UTF8 string too large\");\r\n    }\r\n    // Compute where 'byteLength' must be stored in 'data', and store it at this location.\r\n    int byteLengthOffset = length - offset - 2;\r\n    if (byteLengthOffset >= 0) {\r\n        data[byteLengthOffset] = (byte) (byteLength >>> 8);\r\n        data[byteLengthOffset + 1] = (byte) byteLength;\r\n    }\r\n    if (length + byteLength - offset > data.length) {\r\n        enlarge(byteLength - offset);\r\n    }\r\n    int currentLength = length;\r\n    for (int i = offset; i < charLength; ++i) {\r\n        char charValue = stringValue.charAt(i);\r\n        if (charValue >= 0x0001 && charValue <= 0x007F) {\r\n            data[currentLength++] = (byte) charValue;\r\n        } else if (charValue <= 0x07FF) {\r\n            data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\r\n            data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\r\n        } else {\r\n            data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\r\n            data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\r\n            data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\r\n        }\r\n    }\r\n    length = currentLength;\r\n    return this;\r\n}\n/**\r\n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\r\n *     bytes into this byte vector.\r\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\r\n * @param byteLength number of bytes of byteArrayValue that must be copied.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\r\n    if (length + byteLength > data.length) {\r\n        enlarge(byteLength);\r\n    }\r\n    if (byteArrayValue != null) {\r\n        System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\r\n    }\r\n    length += byteLength;\r\n    return this;\r\n}\n/**\r\n * Enlarges this byte vector so that it can receive 'size' more bytes.\r\n *\r\n * @param size number of additional bytes that this byte vector should be able to receive.\r\n */\r\nprivate void enlarge(final int size) {\r\n    if (length > data.length) {\r\n        throw new AssertionError(\"Internal error\");\r\n    }\r\n    int doubleCapacity = 2 * data.length;\r\n    int minimalCapacity = length + size;\r\n    byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\r\n    System.arraycopy(data, 0, newData, 0, length);\r\n    data = newData;\r\n}",
    "comment": "\n * A dynamically extensible vector of bytes. This class is roughly equivalent to a DataOutputStream\n * on top of a ByteArrayOutputStream, but is more efficient.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#size()",
    "entityType": "method",
    "code": "/**\r\n * Returns the actual number of bytes in this vector.\r\n *\r\n * @return the actual number of bytes in this vector.\r\n */\r\npublic int size() {\r\n    return length;\r\n}",
    "comment": "\n   * Returns the actual number of bytes in this vector.\n   *\n   * @return the actual number of bytes in this vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#putByte(int)",
    "entityType": "method",
    "code": "/**\r\n * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param byteValue a byte.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putByte(final int byteValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 1 > data.length) {\r\n        enlarge(1);\r\n    }\r\n    data[currentLength++] = (byte) byteValue;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param byteValue a byte.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#put11(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param byteValue1 a byte.\r\n * @param byteValue2 another byte.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put11(final int byteValue1, final int byteValue2) {\r\n    int currentLength = length;\r\n    if (currentLength + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue1;\r\n    currentData[currentLength++] = (byte) byteValue2;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param byteValue1 a byte.\n   * @param byteValue2 another byte.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#putShort(int)",
    "entityType": "method",
    "code": "/**\r\n * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param shortValue a short.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putShort(final int shortValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param shortValue a short.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#put12(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param byteValue a byte.\r\n * @param shortValue a short.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put12(final int byteValue, final int shortValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 3 > data.length) {\r\n        enlarge(3);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param byteValue a byte.\n   * @param shortValue a short.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#put112(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param byteValue1 a byte.\r\n * @param byteValue2 another byte.\r\n * @param shortValue a short.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 4 > data.length) {\r\n        enlarge(4);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue1;\r\n    currentData[currentLength++] = (byte) byteValue2;\r\n    currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param byteValue1 a byte.\n   * @param byteValue2 another byte.\n   * @param shortValue a short.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#putInt(int)",
    "entityType": "method",
    "code": "/**\r\n * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param intValue an int.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putInt(final int intValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 4 > data.length) {\r\n        enlarge(4);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param intValue an int.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#put122(int,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\r\n * if necessary.\r\n *\r\n * @param byteValue a byte.\r\n * @param shortValue1 a short.\r\n * @param shortValue2 another short.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\r\n    int currentLength = length;\r\n    if (currentLength + 5 > data.length) {\r\n        enlarge(5);\r\n    }\r\n    byte[] currentData = data;\r\n    currentData[currentLength++] = (byte) byteValue;\r\n    currentData[currentLength++] = (byte) (shortValue1 >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue1;\r\n    currentData[currentLength++] = (byte) (shortValue2 >>> 8);\r\n    currentData[currentLength++] = (byte) shortValue2;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\n   * if necessary.\n   *\n   * @param byteValue a byte.\n   * @param shortValue1 a short.\n   * @param shortValue2 another short.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#putLong(long)",
    "entityType": "method",
    "code": "/**\r\n * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\r\n *\r\n * @param longValue a long.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putLong(final long longValue) {\r\n    int currentLength = length;\r\n    if (currentLength + 8 > data.length) {\r\n        enlarge(8);\r\n    }\r\n    byte[] currentData = data;\r\n    int intValue = (int) (longValue >>> 32);\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    intValue = (int) longValue;\r\n    currentData[currentLength++] = (byte) (intValue >>> 24);\r\n    currentData[currentLength++] = (byte) (intValue >>> 16);\r\n    currentData[currentLength++] = (byte) (intValue >>> 8);\r\n    currentData[currentLength++] = (byte) intValue;\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n   *\n   * @param longValue a long.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#putUTF8(String)",
    "entityType": "method",
    "code": "/**\r\n * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param stringValue a String whose UTF8 encoded length must be less than 65536.\r\n * @return this byte vector.\r\n */\r\n// DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).\r\npublic ByteVector putUTF8(final String stringValue) {\r\n    int charLength = stringValue.length();\r\n    if (charLength > 65535) {\r\n        throw new IllegalArgumentException(\"UTF8 string too large\");\r\n    }\r\n    int currentLength = length;\r\n    if (currentLength + 2 + charLength > data.length) {\r\n        enlarge(2 + charLength);\r\n    }\r\n    byte[] currentData = data;\r\n    // Optimistic algorithm: instead of computing the byte length and then serializing the string\r\n    // (which requires two loops), we assume the byte length is equal to char length (which is the\r\n    // most frequent case), and we start serializing the string right away. During the\r\n    // serialization, if we find that this assumption is wrong, we continue with the general method.\r\n    currentData[currentLength++] = (byte) (charLength >>> 8);\r\n    currentData[currentLength++] = (byte) charLength;\r\n    for (int i = 0; i < charLength; ++i) {\r\n        char charValue = stringValue.charAt(i);\r\n        if (charValue >= '\\u0001' && charValue <= '\\u007F') {\r\n            currentData[currentLength++] = (byte) charValue;\r\n        } else {\r\n            length = currentLength;\r\n            return encodeUtf8(stringValue, i, 65535);\r\n        }\r\n    }\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": " DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility)."
  },
  {
    "entityId": "org.springframework.asm.ByteVector#encodeUtf8(String,int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\r\n * necessary. The string length is encoded in two bytes before the encoded characters, if there is\r\n * space for that (i.e. if this.length - offset - 2 &gt;= 0).\r\n *\r\n * @param stringValue the String to encode.\r\n * @param offset the index of the first character to encode. The previous characters are supposed\r\n *     to have already been encoded, using only one byte per character.\r\n * @param maxByteLength the maximum byte length of the encoded string, including the already\r\n *     encoded characters.\r\n * @return this byte vector.\r\n */\r\nfinal ByteVector encodeUtf8(final String stringValue, final int offset, final int maxByteLength) {\r\n    int charLength = stringValue.length();\r\n    int byteLength = offset;\r\n    for (int i = offset; i < charLength; ++i) {\r\n        char charValue = stringValue.charAt(i);\r\n        if (charValue >= 0x0001 && charValue <= 0x007F) {\r\n            byteLength++;\r\n        } else if (charValue <= 0x07FF) {\r\n            byteLength += 2;\r\n        } else {\r\n            byteLength += 3;\r\n        }\r\n    }\r\n    if (byteLength > maxByteLength) {\r\n        throw new IllegalArgumentException(\"UTF8 string too large\");\r\n    }\r\n    // Compute where 'byteLength' must be stored in 'data', and store it at this location.\r\n    int byteLengthOffset = length - offset - 2;\r\n    if (byteLengthOffset >= 0) {\r\n        data[byteLengthOffset] = (byte) (byteLength >>> 8);\r\n        data[byteLengthOffset + 1] = (byte) byteLength;\r\n    }\r\n    if (length + byteLength - offset > data.length) {\r\n        enlarge(byteLength - offset);\r\n    }\r\n    int currentLength = length;\r\n    for (int i = offset; i < charLength; ++i) {\r\n        char charValue = stringValue.charAt(i);\r\n        if (charValue >= 0x0001 && charValue <= 0x007F) {\r\n            data[currentLength++] = (byte) charValue;\r\n        } else if (charValue <= 0x07FF) {\r\n            data[currentLength++] = (byte) (0xC0 | charValue >> 6 & 0x1F);\r\n            data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\r\n        } else {\r\n            data[currentLength++] = (byte) (0xE0 | charValue >> 12 & 0xF);\r\n            data[currentLength++] = (byte) (0x80 | charValue >> 6 & 0x3F);\r\n            data[currentLength++] = (byte) (0x80 | charValue & 0x3F);\r\n        }\r\n    }\r\n    length = currentLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts an UTF8 string into this byte vector. The byte vector is automatically enlarged if\n   * necessary. The string length is encoded in two bytes before the encoded characters, if there is\n   * space for that (i.e. if this.length - offset - 2 &gt;= 0).\n   *\n   * @param stringValue the String to encode.\n   * @param offset the index of the first character to encode. The previous characters are supposed\n   *     to have already been encoded, using only one byte per character.\n   * @param maxByteLength the maximum byte length of the encoded string, including the already\n   *     encoded characters.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#putByteArray(byte[],int,int)",
    "entityType": "method",
    "code": "/**\r\n * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\r\n * necessary.\r\n *\r\n * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\r\n *     bytes into this byte vector.\r\n * @param byteOffset index of the first byte of byteArrayValue that must be copied.\r\n * @param byteLength number of bytes of byteArrayValue that must be copied.\r\n * @return this byte vector.\r\n */\r\npublic ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\r\n    if (length + byteLength > data.length) {\r\n        enlarge(byteLength);\r\n    }\r\n    if (byteArrayValue != null) {\r\n        System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\r\n    }\r\n    length += byteLength;\r\n    return this;\r\n}",
    "comment": "\n   * Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\n   * necessary.\n   *\n   * @param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\n   *     bytes into this byte vector.\n   * @param byteOffset index of the first byte of byteArrayValue that must be copied.\n   * @param byteLength number of bytes of byteArrayValue that must be copied.\n   * @return this byte vector.\n   "
  },
  {
    "entityId": "org.springframework.asm.ByteVector#enlarge(int)",
    "entityType": "method",
    "code": "/**\r\n * Enlarges this byte vector so that it can receive 'size' more bytes.\r\n *\r\n * @param size number of additional bytes that this byte vector should be able to receive.\r\n */\r\nprivate void enlarge(final int size) {\r\n    if (length > data.length) {\r\n        throw new AssertionError(\"Internal error\");\r\n    }\r\n    int doubleCapacity = 2 * data.length;\r\n    int minimalCapacity = length + size;\r\n    byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\r\n    System.arraycopy(data, 0, newData, 0, length);\r\n    data = newData;\r\n}",
    "comment": "\n   * Enlarges this byte vector so that it can receive 'size' more bytes.\n   *\n   * @param size number of additional bytes that this byte vector should be able to receive.\n   "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests",
    "entityType": "class",
    "code": "@Test\r\nvoid propertiesPersister() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, null, false);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithWhitespace() throws IOException {\r\n    String propString = \" code1\\t= \\tmessage1\\n  code2 \\t  :\\t mess\\\\\\n \\t  age2\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, null, false);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithHeader() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, \"myHeader\", false);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithEmptyValue() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\\ncode3=\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, null, false);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithReader() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, null, true);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithReaderAndWhitespace() throws IOException {\r\n    String propString = \" code1\\t= \\tmessage1\\n  code2 \\t  :\\t mess\\\\\\n \\t  age2\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, null, true);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithReaderAndHeader() throws IOException {\r\n    String propString = \"code1\\t=\\tmessage1\\n  code2 \\t  : \\t message2\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, \"myHeader\", true);\r\n    loadProperties(propCopy, false);\r\n}\n@Test\r\nvoid propertiesPersisterWithReaderAndEmptyValue() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\\ncode3=\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, null, true);\r\n    loadProperties(propCopy, false);\r\n}\nprivate Properties loadProperties(String propString, boolean useReader) throws IOException {\r\n    DefaultPropertiesPersister persister = new DefaultPropertiesPersister();\r\n    Properties props = new Properties();\r\n    if (useReader) {\r\n        persister.load(props, new StringReader(propString));\r\n    } else {\r\n        persister.load(props, new ByteArrayInputStream(propString.getBytes()));\r\n    }\r\n    assertThat(props.getProperty(\"code1\")).isEqualTo(\"message1\");\r\n    assertThat(props.getProperty(\"code2\")).isEqualTo(\"message2\");\r\n    return props;\r\n}\nprivate String storeProperties(Properties props, String header, boolean useWriter) throws IOException {\r\n    DefaultPropertiesPersister persister = new DefaultPropertiesPersister();\r\n    String propCopy;\r\n    if (useWriter) {\r\n        StringWriter propWriter = new StringWriter();\r\n        persister.store(props, propWriter, header);\r\n        propCopy = propWriter.toString();\r\n    } else {\r\n        ByteArrayOutputStream propOut = new ByteArrayOutputStream();\r\n        persister.store(props, propOut, header);\r\n        propCopy = new String(propOut.toByteArray());\r\n    }\r\n    if (header != null) {\r\n        assertThat(propCopy).contains(header);\r\n    }\r\n    assertThat(propCopy).contains(\"\\ncode1=message1\");\r\n    assertThat(propCopy).contains(\"\\ncode2=message2\");\r\n    return propCopy;\r\n}",
    "comment": "\n * @author Juergen Hoeller\n * @since 11.01.2005\n "
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersister()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersister() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, null, false);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithWhitespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithWhitespace() throws IOException {\r\n    String propString = \" code1\\t= \\tmessage1\\n  code2 \\t  :\\t mess\\\\\\n \\t  age2\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, null, false);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithHeader()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithHeader() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, \"myHeader\", false);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithEmptyValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithEmptyValue() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\\ncode3=\";\r\n    Properties props = loadProperties(propString, false);\r\n    String propCopy = storeProperties(props, null, false);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithReader()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithReader() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, null, true);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithReaderAndWhitespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithReaderAndWhitespace() throws IOException {\r\n    String propString = \" code1\\t= \\tmessage1\\n  code2 \\t  :\\t mess\\\\\\n \\t  age2\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, null, true);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithReaderAndHeader()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithReaderAndHeader() throws IOException {\r\n    String propString = \"code1\\t=\\tmessage1\\n  code2 \\t  : \\t message2\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, \"myHeader\", true);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#propertiesPersisterWithReaderAndEmptyValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertiesPersisterWithReaderAndEmptyValue() throws IOException {\r\n    String propString = \"code1=message1\\ncode2:message2\\ncode3=\";\r\n    Properties props = loadProperties(propString, true);\r\n    String propCopy = storeProperties(props, null, true);\r\n    loadProperties(propCopy, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#loadProperties(String,boolean)",
    "entityType": "method",
    "code": "private Properties loadProperties(String propString, boolean useReader) throws IOException {\r\n    DefaultPropertiesPersister persister = new DefaultPropertiesPersister();\r\n    Properties props = new Properties();\r\n    if (useReader) {\r\n        persister.load(props, new StringReader(propString));\r\n    } else {\r\n        persister.load(props, new ByteArrayInputStream(propString.getBytes()));\r\n    }\r\n    assertThat(props.getProperty(\"code1\")).isEqualTo(\"message1\");\r\n    assertThat(props.getProperty(\"code2\")).isEqualTo(\"message2\");\r\n    return props;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertiesPersisterTests#storeProperties(Properties,String,boolean)",
    "entityType": "method",
    "code": "private String storeProperties(Properties props, String header, boolean useWriter) throws IOException {\r\n    DefaultPropertiesPersister persister = new DefaultPropertiesPersister();\r\n    String propCopy;\r\n    if (useWriter) {\r\n        StringWriter propWriter = new StringWriter();\r\n        persister.store(props, propWriter, header);\r\n        propCopy = propWriter.toString();\r\n    } else {\r\n        ByteArrayOutputStream propOut = new ByteArrayOutputStream();\r\n        persister.store(props, propOut, header);\r\n        propCopy = new String(propOut.toByteArray());\r\n    }\r\n    if (header != null) {\r\n        assertThat(propCopy).contains(header);\r\n    }\r\n    assertThat(propCopy).contains(\"\\ncode1=message1\");\r\n    assertThat(propCopy).contains(\"\\ncode2=message2\");\r\n    return propCopy;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.PropertyPlaceholderHelperTests",
    "entityType": "class",
    "code": "private final PropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(\"${\", \"}\");\n@Test\r\nvoid withProperties() {\r\n    String text = \"foo=${foo}\";\r\n    Properties props = new Properties();\r\n    props.setProperty(\"foo\", \"bar\");\r\n    assertThat(this.helper.replacePlaceholders(text, props)).isEqualTo(\"foo=bar\");\r\n}\n@Test\r\nvoid withMultipleProperties() {\r\n    String text = \"foo=${foo},bar=${bar}\";\r\n    Properties props = new Properties();\r\n    props.setProperty(\"foo\", \"bar\");\r\n    props.setProperty(\"bar\", \"baz\");\r\n    assertThat(this.helper.replacePlaceholders(text, props)).isEqualTo(\"foo=bar,bar=baz\");\r\n}\n@Test\r\nvoid recurseInProperty() {\r\n    String text = \"foo=${bar}\";\r\n    Properties props = new Properties();\r\n    props.setProperty(\"bar\", \"${baz}\");\r\n    props.setProperty(\"baz\", \"bar\");\r\n    assertThat(this.helper.replacePlaceholders(text, props)).isEqualTo(\"foo=bar\");\r\n}\n@Test\r\nvoid recurseInPlaceholder() {\r\n    String text = \"foo=${b${inner}}\";\r\n    Properties props = new Properties();\r\n    props.setProperty(\"bar\", \"bar\");\r\n    props.setProperty(\"inner\", \"ar\");\r\n    assertThat(this.helper.replacePlaceholders(text, props)).isEqualTo(\"foo=bar\");\r\n    text = \"${top}\";\r\n    props = new Properties();\r\n    props.setProperty(\"top\", \"${child}+${child}\");\r\n    props.setProperty(\"child\", \"${${differentiator}.grandchild}\");\r\n    props.setProperty(\"differentiator\", \"first\");\r\n    props.setProperty(\"first.grandchild\", \"actualValue\");\r\n    assertThat(this.helper.replacePlaceholders(text, props)).isEqualTo(\"actualValue+actualValue\");\r\n}\n@Test\r\nvoid withResolver() {\r\n    String text = \"foo=${foo}\";\r\n    PlaceholderResolver resolver = placeholderName -> \"foo\".equals(placeholderName) ? \"bar\" : null;\r\n    assertThat(this.helper.replacePlaceholders(text, resolver)).isEqualTo(\"foo=bar\");\r\n}\n@Test\r\nvoid unresolvedPlaceholderIsIgnored() {\r\n    String text = \"foo=${foo},bar=${bar}\";\r\n    Properties props = new Properties();\r\n    props.setProperty(\"foo\", \"bar\");\r\n    assertThat(this.helper.replacePlaceholders(text, props)).isEqualTo(\"foo=bar,bar=${bar}\");\r\n}\n@Test\r\nvoid unresolvedPlaceholderAsError() {\r\n    String text = \"foo=${foo},bar=${bar}\";\r\n    Properties props = new Properties();\r\n    props.setProperty(\"foo\", \"bar\");\r\n    PropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(\"${\", \"}\", null, null, false);\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> helper.replacePlaceholders(text, props));\r\n}\n@Nested\r\nclass DefaultValueTests {\r\n\r\n    private final PropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(\"${\", \"}\", \":\", null, true);\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"defaultValues\")\r\n    void defaultValueIsApplied(String text, String value) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"one\", \"1\");\r\n        properties.setProperty(\"two\", \"2\");\r\n        assertThat(this.helper.replacePlaceholders(text, properties)).isEqualTo(value);\r\n    }\r\n\r\n    @Test\r\n    void defaultValueIsNotEvaluatedEarly() {\r\n        PlaceholderResolver resolver = mockPlaceholderResolver(\"one\", \"1\");\r\n        assertThat(this.helper.replacePlaceholders(\"This is ${one:or${two}}\", resolver)).isEqualTo(\"This is 1\");\r\n        verify(resolver).resolvePlaceholder(\"one\");\r\n        verify(resolver, never()).resolvePlaceholder(\"two\");\r\n    }\r\n\r\n    static Stream<Arguments> defaultValues() {\r\n        return Stream.of(Arguments.of(\"${invalid:test}\", \"test\"), Arguments.of(\"${invalid:${one}}\", \"1\"), Arguments.of(\"${invalid:${one}${two}}\", \"12\"), Arguments.of(\"${invalid:${one}:${two}}\", \"1:2\"), Arguments.of(\"${invalid:${also_invalid:test}}\", \"test\"), Arguments.of(\"${invalid:${also_invalid:${one}}}\", \"1\"));\r\n    }\r\n\r\n    @ParameterizedTest(name = \"{0} -> {1}\")\r\n    @MethodSource(\"exactMatchPlaceholders\")\r\n    void placeholdersWithExactMatchAreConsidered(String text, String expected) {\r\n        Properties properties = new Properties();\r\n        properties.setProperty(\"prefix://my-service\", \"example-service\");\r\n        properties.setProperty(\"px\", \"prefix\");\r\n        properties.setProperty(\"p1\", \"${prefix://my-service}\");\r\n        assertThat(this.helper.replacePlaceholders(text, properties)).isEqualTo(expected);\r\n    }\r\n\r\n    static Stream<Arguments> exactMatchPlaceholders() {\r\n        return Stream.of(Arguments.of(\"${prefix://my-service}\", \"example-service\"), Arguments.of(\"${p1}\", \"example-service\"));\r\n    }\r\n}\nprivate static PlaceholderResolver mockPlaceholderResolver(String... pairs) {\r\n    if (pairs.length % 2 == 1) {\r\n        throw new IllegalArgumentException(\"size must be even, it is a set of key=value pairs\");\r\n    }\r\n    PlaceholderResolver resolver = mock();\r\n    for (int i = 0; i < pairs.length; i += 2) {\r\n        String key = pairs[i];\r\n        String value = pairs[i + 1];\r\n        given(resolver.resolvePlaceholder(key)).willReturn(value);\r\n    }\r\n    return resolver;\r\n}",
    "comment": "\n * Tests for {@link PropertyPlaceholderHelper}.\n *\n * @author Rob Harrop\n * @author Stephane Nicoll\n "
  }
]