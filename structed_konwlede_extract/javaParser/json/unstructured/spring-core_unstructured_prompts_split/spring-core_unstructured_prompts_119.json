[
  {
    "entityId": "org.springframework.core.convert.support.GenericConversionServiceTests#rawCollectionAsSource()",
    "entityType": "method",
    "code": "@Test\r\nvoid rawCollectionAsSource() throws Exception {\r\n    conversionService.addConverter(new MyStringToRawCollectionConverter());\r\n    assertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"stringCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\r\n    assertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"genericCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\r\n    assertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"rawCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\r\n    // The following is unpleasant but a consequence of the raw collection converter above...\r\n    assertThat(conversionService.convert(\"test\", TypeDescriptor.valueOf(String.class), new TypeDescriptor(getClass().getField(\"integerCollection\")))).isEqualTo(Collections.singleton(\"testX\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.GenericConversionServiceTests#stringListToListOfSubclassOfUnboundGenericClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid stringListToListOfSubclassOfUnboundGenericClass() {\r\n    conversionService.addConverter(new StringListToAListConverter());\r\n    conversionService.addConverter(new StringListToBListConverter());\r\n    List<?> aList = (List<?>) conversionService.convert(List.of(\"foo\"), TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)), TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(ARaw.class)));\r\n    assertThat(aList).allMatch(e -> e instanceof ARaw);\r\n    List<?> bList = (List<?>) conversionService.convert(List.of(\"foo\"), TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)), TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(BRaw.class)));\r\n    assertThat(bList).allMatch(e -> e instanceof BRaw);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyBaseInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyInterfaceImplementer",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyBaseInterfaceToStringConverter",
    "entityType": "class",
    "code": "@Override\r\npublic String convert(MyBaseInterface source) {\r\n    return \"RESULT\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyBaseInterfaceToStringConverter#convert(MyBaseInterface)",
    "entityType": "method",
    "code": "@Override\r\npublic String convert(MyBaseInterface source) {\r\n    return \"RESULT\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringArrayToResourceArrayConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Resource[] convert(String[] source) {\r\n    return Arrays.stream(source).map(s -> s.substring(1)).map(DescriptiveResource::new).toArray(Resource[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringArrayToResourceArrayConverter#convert(String[])",
    "entityType": "method",
    "code": "@Override\r\npublic Resource[] convert(String[] source) {\r\n    return Arrays.stream(source).map(s -> s.substring(1)).map(DescriptiveResource::new).toArray(Resource[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringArrayToIntegerArrayConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Integer[] convert(String[] source) {\r\n    return Arrays.stream(source).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringArrayToIntegerArrayConverter#convert(String[])",
    "entityType": "method",
    "code": "@Override\r\npublic Integer[] convert(String[] source) {\r\n    return Arrays.stream(source).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToIntegerArrayConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Integer[] convert(String source) {\r\n    String[] srcArray = StringUtils.commaDelimitedListToStringArray(source);\r\n    return Arrays.stream(srcArray).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToIntegerArrayConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Integer[] convert(String source) {\r\n    String[] srcArray = StringUtils.commaDelimitedListToStringArray(source);\r\n    return Arrays.stream(srcArray).map(s -> s.substring(1)).map(Integer::valueOf).toArray(Integer[]::new);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.WithCopyConstructor",
    "entityType": "class",
    "code": "WithCopyConstructor() {\r\n}\n@SuppressWarnings(\"unused\")\r\nWithCopyConstructor(WithCopyConstructor value) {\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverter",
    "entityType": "class",
    "code": "private int matchAttempts = 0;\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    matchAttempts++;\r\n    return false;\r\n}\n@Override\r\npublic Color convert(String source) {\r\n    throw new IllegalStateException();\r\n}\npublic int getMatchAttempts() {\r\n    return matchAttempts;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    matchAttempts++;\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Color convert(String source) {\r\n    throw new IllegalStateException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverter#getMatchAttempts()",
    "entityType": "method",
    "code": "public int getMatchAttempts() {\r\n    return matchAttempts;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.NonConditionalGenericConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return null;\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.NonConditionalGenericConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.NonConditionalGenericConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalGenericConverter",
    "entityType": "class",
    "code": "private final List<TypeDescriptor> sourceTypes = new ArrayList<>();\n@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return null;\r\n}\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    sourceTypes.add(sourceType);\r\n    return false;\r\n}\n@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return null;\r\n}\npublic List<TypeDescriptor> getSourceTypes() {\r\n    return sourceTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalGenericConverter#getConvertibleTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<ConvertiblePair> getConvertibleTypes() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalGenericConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    sourceTypes.add(sourceType);\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalGenericConverter#convert(Object,TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalGenericConverter#getSourceTypes()",
    "entityType": "method",
    "code": "public List<TypeDescriptor> getSourceTypes() {\r\n    return sourceTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverterFactory",
    "entityType": "class",
    "code": "private MyConditionalConverter converter = new MyConditionalConverter();\nprivate int matchAttempts = 0;\n@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    matchAttempts++;\r\n    return true;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T extends Color> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return (Converter<String, T>) converter;\r\n}\npublic int getMatchAttempts() {\r\n    return matchAttempts;\r\n}\npublic int getNestedMatchAttempts() {\r\n    return converter.getMatchAttempts();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverterFactory#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    matchAttempts++;\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverterFactory#getConverter(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T extends Color> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return (Converter<String, T>) converter;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverterFactory#getMatchAttempts()",
    "entityType": "method",
    "code": "public int getMatchAttempts() {\r\n    return matchAttempts;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalConverterFactory#getNestedMatchAttempts()",
    "entityType": "method",
    "code": "public int getNestedMatchAttempts() {\r\n    return converter.getMatchAttempts();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyEnumBaseInterface",
    "entityType": "class",
    "code": "String getBaseCode();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyEnumBaseInterface#getBaseCode()",
    "entityType": "method",
    "code": "String getBaseCode();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyEnumInterface",
    "entityType": "class",
    "code": "String getCode();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyEnumInterface#getCode()",
    "entityType": "method",
    "code": "String getCode();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToRawCollectionConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Collection convert(String source) {\r\n    return Collections.singleton(source + \"X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToRawCollectionConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Collection convert(String source) {\r\n    return Collections.singleton(source + \"X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToGenericCollectionConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Collection<?> convert(String source) {\r\n    return Collections.singleton(source + \"X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToGenericCollectionConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<?> convert(String source) {\r\n    return Collections.singleton(source + \"X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter",
    "entityType": "class",
    "code": "@Override\r\npublic String convert(T source) {\r\n    return source.getCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyEnumInterfaceToStringConverter#convert(T)",
    "entityType": "method",
    "code": "@Override\r\npublic String convert(T source) {\r\n    return source.getCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory",
    "entityType": "class",
    "code": "@Override\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic <T extends MyEnumInterface> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return new StringToMyEnumInterfaceConverter(targetType);\r\n}\nprivate static class StringToMyEnumInterfaceConverter<T extends Enum<?> & MyEnumInterface> implements Converter<String, T> {\r\n\r\n    private final Class<T> enumType;\r\n\r\n    public StringToMyEnumInterfaceConverter(Class<T> enumType) {\r\n        this.enumType = enumType;\r\n    }\r\n\r\n    @Override\r\n    public T convert(String source) {\r\n        for (T value : enumType.getEnumConstants()) {\r\n            if (value.getCode().equals(source)) {\r\n                return value;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverterFactory#getConverter(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic <T extends MyEnumInterface> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return new StringToMyEnumInterfaceConverter(targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter",
    "entityType": "class",
    "code": "private final Class<T> enumType;\npublic StringToMyEnumInterfaceConverter(Class<T> enumType) {\r\n    this.enumType = enumType;\r\n}\n@Override\r\npublic T convert(String source) {\r\n    for (T value : enumType.getEnumConstants()) {\r\n        if (value.getCode().equals(source)) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumInterfaceConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic T convert(String source) {\r\n    for (T value : enumType.getEnumConstants()) {\r\n        if (value.getCode().equals(source)) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumBaseInterfaceConverterFactory",
    "entityType": "class",
    "code": "@Override\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic <T extends MyEnumBaseInterface> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return new StringToMyEnumBaseInterfaceConverter(targetType);\r\n}\nprivate static class StringToMyEnumBaseInterfaceConverter<T extends Enum<?> & MyEnumBaseInterface> implements Converter<String, T> {\r\n\r\n    private final Class<T> enumType;\r\n\r\n    public StringToMyEnumBaseInterfaceConverter(Class<T> enumType) {\r\n        this.enumType = enumType;\r\n    }\r\n\r\n    @Override\r\n    public T convert(String source) {\r\n        for (T value : enumType.getEnumConstants()) {\r\n            if (value.getBaseCode().equals(source)) {\r\n                return value;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumBaseInterfaceConverterFactory#getConverter(Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic <T extends MyEnumBaseInterface> Converter<String, T> getConverter(Class<T> targetType) {\r\n    return new StringToMyEnumBaseInterfaceConverter(targetType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumBaseInterfaceConverter",
    "entityType": "class",
    "code": "private final Class<T> enumType;\npublic StringToMyEnumBaseInterfaceConverter(Class<T> enumType) {\r\n    this.enumType = enumType;\r\n}\n@Override\r\npublic T convert(String source) {\r\n    for (T value : enumType.getEnumConstants()) {\r\n        if (value.getBaseCode().equals(source)) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringToMyEnumBaseInterfaceConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic T convert(String source) {\r\n    for (T value : enumType.getEnumConstants()) {\r\n        if (value.getBaseCode().equals(source)) {\r\n            return value;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToStringCollectionConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Collection<String> convert(String source) {\r\n    return Collections.singleton(source + \"X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToStringCollectionConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<String> convert(String source) {\r\n    return Collections.singleton(source + \"X\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToIntegerCollectionConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Collection<Integer> convert(String source) {\r\n    return Collections.singleton(source.length());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyStringToIntegerCollectionConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<Integer> convert(String source) {\r\n    return Collections.singleton(source.length());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.UntypedConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Object convert(Object source) {\r\n    return source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.UntypedConverter#convert(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic Object convert(Object source) {\r\n    return source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ColorConverter",
    "entityType": "class",
    "code": "@Override\r\npublic Color convert(String source) {\r\n    return Color.decode(source.trim());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ColorConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Color convert(String source) {\r\n    return Color.decode(source.trim());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalColorConverter",
    "entityType": "class",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    ExampleAnnotation ann = targetType.getAnnotation(ExampleAnnotation.class);\r\n    return (ann != null && ann.active());\r\n}\n@Override\r\npublic Color convert(String source) {\r\n    return Color.decode(source.substring(0, 6));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalColorConverter#matches(TypeDescriptor,TypeDescriptor)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n    ExampleAnnotation ann = targetType.getAnnotation(ExampleAnnotation.class);\r\n    return (ann != null && ann.active());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MyConditionalColorConverter#convert(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Color convert(String source) {\r\n    return Color.decode(source.substring(0, 6));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.GenericBaseClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ARaw",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.BRaw",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringListToAListConverter",
    "entityType": "class",
    "code": "@Override\r\npublic List<ARaw> convert(List<String> source) {\r\n    return List.of(new ARaw());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringListToAListConverter#convert(List<String>)",
    "entityType": "method",
    "code": "@Override\r\npublic List<ARaw> convert(List<String> source) {\r\n    return List.of(new ARaw());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringListToBListConverter",
    "entityType": "class",
    "code": "@Override\r\npublic List<BRaw> convert(List<String> source) {\r\n    return List.of(new BRaw());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StringListToBListConverter#convert(List<String>)",
    "entityType": "method",
    "code": "@Override\r\npublic List<BRaw> convert(List<String> source) {\r\n    return List.of(new BRaw());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests",
    "entityType": "class",
    "code": "private final GenericConversionService conversionService = new GenericConversionService();\n@BeforeEach\r\nvoid setup() {\r\n    conversionService.addConverter(new MapToMapConverter(conversionService));\r\n}\n@Test\r\nvoid scalarMap() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    map.put(\"1\", \"9\");\r\n    map.put(\"2\", \"37\");\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"scalarMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    try {\r\n        conversionService.convert(map, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        assertThat(ex.getCause()).isInstanceOf(ConverterNotFoundException.class);\r\n    }\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, Integer> result = (Map<Integer, Integer>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat((int) result.get(1)).isEqualTo(9);\r\n    assertThat((int) result.get(2)).isEqualTo(37);\r\n}\n@Test\r\nvoid scalarMapNotGenericTarget() {\r\n    Map<String, String> map = new HashMap<>();\r\n    map.put(\"1\", \"9\");\r\n    map.put(\"2\", \"37\");\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}\n@Test\r\nvoid scalarMapNotGenericSourceField() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    map.put(\"1\", \"9\");\r\n    map.put(\"2\", \"37\");\r\n    TypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"notGenericMapSource\"));\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"scalarMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    try {\r\n        conversionService.convert(map, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        assertThat(ex.getCause()).isInstanceOf(ConverterNotFoundException.class);\r\n    }\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, Integer> result = (Map<Integer, Integer>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat((int) result.get(1)).isEqualTo(9);\r\n    assertThat((int) result.get(2)).isEqualTo(37);\r\n}\n@Test\r\nvoid collectionMap() throws Exception {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"collectionMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    try {\r\n        conversionService.convert(map, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        assertThat(ex.getCause()).isInstanceOf(ConverterNotFoundException.class);\r\n    }\r\n    conversionService.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, List<Integer>> result = (Map<Integer, List<Integer>>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat(result.get(1)).isEqualTo(Arrays.asList(9, 12));\r\n    assertThat(result.get(2)).isEqualTo(Arrays.asList(37, 23));\r\n}\n@Test\r\nvoid collectionMapSourceTarget() throws Exception {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    TypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"sourceCollectionMapTarget\"));\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"collectionMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isFalse();\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() -> conversionService.convert(map, sourceType, targetType));\r\n    conversionService.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, List<Integer>> result = (Map<Integer, List<Integer>>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat(result.get(1)).isEqualTo(Arrays.asList(9, 12));\r\n    assertThat(result.get(2)).isEqualTo(Arrays.asList(37, 23));\r\n}\n@Test\r\nvoid collectionMapNotGenericTarget() {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}\n@Test\r\nvoid collectionMapNotGenericTargetCollectionToObjectInteraction() {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    conversionService.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    conversionService.addConverter(new CollectionToObjectConverter(conversionService));\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}\n@Test\r\nvoid emptyMap() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"emptyMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    assertThat(conversionService.convert(map, sourceType, targetType)).isSameAs(map);\r\n}\n@Test\r\nvoid emptyMapNoTargetGenericInfo() {\r\n    Map<String, String> map = new HashMap<>();\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}\n@Test\r\nvoid emptyMapDifferentTargetImplType() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"emptyMapDifferentTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    LinkedHashMap<String, String> result = (LinkedHashMap<String, String>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(result).isEqualTo(map);\r\n    assertThat(result.getClass()).isEqualTo(LinkedHashMap.class);\r\n}\n@Test\r\nvoid noDefaultConstructorCopyNotRequired() {\r\n    // SPR-9284\r\n    NoDefaultConstructorMap<String, Integer> map = new NoDefaultConstructorMap<>(Collections.<String, Integer>singletonMap(\"1\", 1));\r\n    TypeDescriptor sourceType = TypeDescriptor.map(NoDefaultConstructorMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\r\n    TypeDescriptor targetType = TypeDescriptor.map(NoDefaultConstructorMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, Integer> result = (Map<String, Integer>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(result).isEqualTo(map);\r\n    assertThat(result.getClass()).isEqualTo(NoDefaultConstructorMap.class);\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid multiValueMapToMultiValueMap() throws Exception {\r\n    DefaultConversionService.addDefaultConverters(conversionService);\r\n    MultiValueMap<String, Integer> source = new LinkedMultiValueMap<>();\r\n    source.put(\"a\", Arrays.asList(1, 2, 3));\r\n    source.put(\"b\", Arrays.asList(4, 5, 6));\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"multiValueMapTarget\"));\r\n    MultiValueMap<String, String> converted = (MultiValueMap<String, String>) conversionService.convert(source, targetType);\r\n    assertThat(converted).hasSize(2);\r\n    assertThat(converted.get(\"a\")).isEqualTo(Arrays.asList(\"1\", \"2\", \"3\"));\r\n    assertThat(converted.get(\"b\")).isEqualTo(Arrays.asList(\"4\", \"5\", \"6\"));\r\n}\n@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid mapToMultiValueMap() throws Exception {\r\n    DefaultConversionService.addDefaultConverters(conversionService);\r\n    Map<String, Integer> source = new HashMap<>();\r\n    source.put(\"a\", 1);\r\n    source.put(\"b\", 2);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"multiValueMapTarget\"));\r\n    MultiValueMap<String, String> converted = (MultiValueMap<String, String>) conversionService.convert(source, targetType);\r\n    assertThat(converted).hasSize(2);\r\n    assertThat(converted.get(\"a\")).isEqualTo(List.of(\"1\"));\r\n    assertThat(converted.get(\"b\")).isEqualTo(List.of(\"2\"));\r\n}\n@Test\r\nvoid stringToEnumMap() throws Exception {\r\n    conversionService.addConverterFactory(new StringToEnumConverterFactory());\r\n    Map<String, Integer> source = new HashMap<>();\r\n    source.put(\"A\", 1);\r\n    source.put(\"C\", 2);\r\n    EnumMap<MyEnum, Integer> result = new EnumMap<>(MyEnum.class);\r\n    result.put(MyEnum.A, 1);\r\n    result.put(MyEnum.C, 2);\r\n    assertThat(conversionService.convert(source, TypeDescriptor.forObject(source), new TypeDescriptor(getClass().getField(\"enumMap\")))).isEqualTo(result);\r\n}\npublic Map<Integer, Integer> scalarMapTarget;\npublic Map<Integer, List<Integer>> collectionMapTarget;\npublic Map<String, List<String>> sourceCollectionMapTarget;\npublic Map<String, String> emptyMapTarget;\npublic LinkedHashMap<String, String> emptyMapDifferentTarget;\npublic MultiValueMap<String, String> multiValueMapTarget;\n@SuppressWarnings(\"rawtypes\")\r\npublic Map notGenericMapSource;\npublic EnumMap<MyEnum, Integer> enumMap;\n@SuppressWarnings(\"serial\")\r\npublic static class NoDefaultConstructorMap<K, V> extends HashMap<K, V> {\r\n\r\n    public NoDefaultConstructorMap(Map<? extends K, ? extends V> map) {\r\n        super(map);\r\n    }\r\n}\npublic enum MyEnum {\r\n\r\n    A, B, C\r\n}",
    "comment": "\n * @author Keith Donald\n * @author Phillip Webb\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    conversionService.addConverter(new MapToMapConverter(conversionService));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#scalarMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid scalarMap() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    map.put(\"1\", \"9\");\r\n    map.put(\"2\", \"37\");\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"scalarMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    try {\r\n        conversionService.convert(map, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        assertThat(ex.getCause()).isInstanceOf(ConverterNotFoundException.class);\r\n    }\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, Integer> result = (Map<Integer, Integer>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat((int) result.get(1)).isEqualTo(9);\r\n    assertThat((int) result.get(2)).isEqualTo(37);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#scalarMapNotGenericTarget()",
    "entityType": "method",
    "code": "@Test\r\nvoid scalarMapNotGenericTarget() {\r\n    Map<String, String> map = new HashMap<>();\r\n    map.put(\"1\", \"9\");\r\n    map.put(\"2\", \"37\");\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#scalarMapNotGenericSourceField()",
    "entityType": "method",
    "code": "@Test\r\nvoid scalarMapNotGenericSourceField() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    map.put(\"1\", \"9\");\r\n    map.put(\"2\", \"37\");\r\n    TypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"notGenericMapSource\"));\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"scalarMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    try {\r\n        conversionService.convert(map, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        assertThat(ex.getCause()).isInstanceOf(ConverterNotFoundException.class);\r\n    }\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, Integer> result = (Map<Integer, Integer>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat((int) result.get(1)).isEqualTo(9);\r\n    assertThat((int) result.get(2)).isEqualTo(37);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#collectionMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectionMap() throws Exception {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"collectionMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    try {\r\n        conversionService.convert(map, sourceType, targetType);\r\n    } catch (ConversionFailedException ex) {\r\n        assertThat(ex.getCause()).isInstanceOf(ConverterNotFoundException.class);\r\n    }\r\n    conversionService.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, List<Integer>> result = (Map<Integer, List<Integer>>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat(result.get(1)).isEqualTo(Arrays.asList(9, 12));\r\n    assertThat(result.get(2)).isEqualTo(Arrays.asList(37, 23));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#collectionMapSourceTarget()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectionMapSourceTarget() throws Exception {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    TypeDescriptor sourceType = new TypeDescriptor(getClass().getField(\"sourceCollectionMapTarget\"));\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"collectionMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isFalse();\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() -> conversionService.convert(map, sourceType, targetType));\r\n    conversionService.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<Integer, List<Integer>> result = (Map<Integer, List<Integer>>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(map).isNotEqualTo(result);\r\n    assertThat(result.get(1)).isEqualTo(Arrays.asList(9, 12));\r\n    assertThat(result.get(2)).isEqualTo(Arrays.asList(37, 23));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#collectionMapNotGenericTarget()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectionMapNotGenericTarget() {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#collectionMapNotGenericTargetCollectionToObjectInteraction()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectionMapNotGenericTargetCollectionToObjectInteraction() {\r\n    Map<String, List<String>> map = new HashMap<>();\r\n    map.put(\"1\", Arrays.asList(\"9\", \"12\"));\r\n    map.put(\"2\", Arrays.asList(\"37\", \"23\"));\r\n    conversionService.addConverter(new CollectionToCollectionConverter(conversionService));\r\n    conversionService.addConverter(new CollectionToObjectConverter(conversionService));\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#emptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid emptyMap() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"emptyMapTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    assertThat(conversionService.convert(map, sourceType, targetType)).isSameAs(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#emptyMapNoTargetGenericInfo()",
    "entityType": "method",
    "code": "@Test\r\nvoid emptyMapNoTargetGenericInfo() {\r\n    Map<String, String> map = new HashMap<>();\r\n    assertThat(conversionService.canConvert(Map.class, Map.class)).isTrue();\r\n    assertThat((Map<?, ?>) conversionService.convert(map, Map.class)).isSameAs(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#emptyMapDifferentTargetImplType()",
    "entityType": "method",
    "code": "@Test\r\nvoid emptyMapDifferentTargetImplType() throws Exception {\r\n    Map<String, String> map = new HashMap<>();\r\n    TypeDescriptor sourceType = TypeDescriptor.forObject(map);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"emptyMapDifferentTarget\"));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    LinkedHashMap<String, String> result = (LinkedHashMap<String, String>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(result).isEqualTo(map);\r\n    assertThat(result.getClass()).isEqualTo(LinkedHashMap.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#noDefaultConstructorCopyNotRequired()",
    "entityType": "method",
    "code": "@Test\r\nvoid noDefaultConstructorCopyNotRequired() {\r\n    // SPR-9284\r\n    NoDefaultConstructorMap<String, Integer> map = new NoDefaultConstructorMap<>(Collections.<String, Integer>singletonMap(\"1\", 1));\r\n    TypeDescriptor sourceType = TypeDescriptor.map(NoDefaultConstructorMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\r\n    TypeDescriptor targetType = TypeDescriptor.map(NoDefaultConstructorMap.class, TypeDescriptor.valueOf(String.class), TypeDescriptor.valueOf(Integer.class));\r\n    assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, Integer> result = (Map<String, Integer>) conversionService.convert(map, sourceType, targetType);\r\n    assertThat(result).isEqualTo(map);\r\n    assertThat(result.getClass()).isEqualTo(NoDefaultConstructorMap.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#multiValueMapToMultiValueMap()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid multiValueMapToMultiValueMap() throws Exception {\r\n    DefaultConversionService.addDefaultConverters(conversionService);\r\n    MultiValueMap<String, Integer> source = new LinkedMultiValueMap<>();\r\n    source.put(\"a\", Arrays.asList(1, 2, 3));\r\n    source.put(\"b\", Arrays.asList(4, 5, 6));\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"multiValueMapTarget\"));\r\n    MultiValueMap<String, String> converted = (MultiValueMap<String, String>) conversionService.convert(source, targetType);\r\n    assertThat(converted).hasSize(2);\r\n    assertThat(converted.get(\"a\")).isEqualTo(Arrays.asList(\"1\", \"2\", \"3\"));\r\n    assertThat(converted.get(\"b\")).isEqualTo(Arrays.asList(\"4\", \"5\", \"6\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#mapToMultiValueMap()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"unchecked\")\r\nvoid mapToMultiValueMap() throws Exception {\r\n    DefaultConversionService.addDefaultConverters(conversionService);\r\n    Map<String, Integer> source = new HashMap<>();\r\n    source.put(\"a\", 1);\r\n    source.put(\"b\", 2);\r\n    TypeDescriptor targetType = new TypeDescriptor(getClass().getField(\"multiValueMapTarget\"));\r\n    MultiValueMap<String, String> converted = (MultiValueMap<String, String>) conversionService.convert(source, targetType);\r\n    assertThat(converted).hasSize(2);\r\n    assertThat(converted.get(\"a\")).isEqualTo(List.of(\"1\"));\r\n    assertThat(converted.get(\"b\")).isEqualTo(List.of(\"2\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.MapToMapConverterTests#stringToEnumMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid stringToEnumMap() throws Exception {\r\n    conversionService.addConverterFactory(new StringToEnumConverterFactory());\r\n    Map<String, Integer> source = new HashMap<>();\r\n    source.put(\"A\", 1);\r\n    source.put(\"C\", 2);\r\n    EnumMap<MyEnum, Integer> result = new EnumMap<>(MyEnum.class);\r\n    result.put(MyEnum.A, 1);\r\n    result.put(MyEnum.C, 2);\r\n    assertThat(conversionService.convert(source, TypeDescriptor.forObject(source), new TypeDescriptor(getClass().getField(\"enumMap\")))).isEqualTo(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.NoDefaultConstructorMap",
    "entityType": "class",
    "code": "public NoDefaultConstructorMap(Map<? extends K, ? extends V> map) {\r\n    super(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ObjectToObjectConverterTests",
    "entityType": "class",
    "code": "private final GenericConversionService conversionService = new GenericConversionService();\n@BeforeEach\r\nvoid setup() {\r\n    conversionService.addConverter(new ObjectToObjectConverter());\r\n}\n/**\r\n * This test effectively verifies that the {@link ObjectToObjectConverter}\r\n * was properly registered with the {@link GenericConversionService}.\r\n */\r\n@Test\r\nvoid nonStaticToTargetTypeSimpleNameMethodWithMatchingReturnType() {\r\n    assertThat(conversionService.canConvert(Source.class, Data.class)).as(\"can convert Source to Data\").isTrue();\r\n    Data data = conversionService.convert(new Source(\"test\"), Data.class);\r\n    assertThat(data).asString().isEqualTo(\"test\");\r\n}\n@Test\r\nvoid nonStaticToTargetTypeSimpleNameMethodWithDifferentReturnType() {\r\n    assertThat(conversionService.canConvert(Text.class, Data.class)).as(\"can convert Text to Data\").isFalse();\r\n    assertThat(conversionService.canConvert(Text.class, Optional.class)).as(\"can convert Text to Optional\").isFalse();\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).as(\"convert Text to Data\").isThrownBy(() -> conversionService.convert(new Text(\"test\"), Data.class));\r\n}\n@Test\r\nvoid staticValueOfFactoryMethodWithDifferentReturnType() {\r\n    assertThat(conversionService.canConvert(String.class, Data.class)).as(\"can convert String to Data\").isFalse();\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).as(\"convert String to Data\").isThrownBy(() -> conversionService.convert(\"test\", Data.class));\r\n}\nstatic class Source {\r\n\r\n    private final String value;\r\n\r\n    private Source(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    public Data toData() {\r\n        return new Data(this.value);\r\n    }\r\n}\nstatic class Text {\r\n\r\n    private final String value;\r\n\r\n    private Text(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    public Optional<Data> toData() {\r\n        return Optional.of(new Data(this.value));\r\n    }\r\n}\nstatic class Data {\r\n\r\n    private final String value;\r\n\r\n    private Data(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return this.value;\r\n    }\r\n\r\n    public static Optional<Data> valueOf(String string) {\r\n        return (string != null ? Optional.of(new Data(string)) : Optional.empty());\r\n    }\r\n}",
    "comment": "\n * Tests for {@link ObjectToObjectConverter}.\n *\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 5.3.21\n * @see org.springframework.core.convert.converter.DefaultConversionServiceTests#convertObjectToObjectUsingValueOfMethod()\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.ObjectToObjectConverterTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    conversionService.addConverter(new ObjectToObjectConverter());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ObjectToObjectConverterTests#nonStaticToTargetTypeSimpleNameMethodWithMatchingReturnType()",
    "entityType": "method",
    "code": "/**\r\n * This test effectively verifies that the {@link ObjectToObjectConverter}\r\n * was properly registered with the {@link GenericConversionService}.\r\n */\r\n@Test\r\nvoid nonStaticToTargetTypeSimpleNameMethodWithMatchingReturnType() {\r\n    assertThat(conversionService.canConvert(Source.class, Data.class)).as(\"can convert Source to Data\").isTrue();\r\n    Data data = conversionService.convert(new Source(\"test\"), Data.class);\r\n    assertThat(data).asString().isEqualTo(\"test\");\r\n}",
    "comment": "\n\t * This test effectively verifies that the {@link ObjectToObjectConverter}\n\t * was properly registered with the {@link GenericConversionService}.\n\t "
  },
  {
    "entityId": "org.springframework.core.convert.support.ObjectToObjectConverterTests#nonStaticToTargetTypeSimpleNameMethodWithDifferentReturnType()",
    "entityType": "method",
    "code": "@Test\r\nvoid nonStaticToTargetTypeSimpleNameMethodWithDifferentReturnType() {\r\n    assertThat(conversionService.canConvert(Text.class, Data.class)).as(\"can convert Text to Data\").isFalse();\r\n    assertThat(conversionService.canConvert(Text.class, Optional.class)).as(\"can convert Text to Optional\").isFalse();\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).as(\"convert Text to Data\").isThrownBy(() -> conversionService.convert(new Text(\"test\"), Data.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.ObjectToObjectConverterTests#staticValueOfFactoryMethodWithDifferentReturnType()",
    "entityType": "method",
    "code": "@Test\r\nvoid staticValueOfFactoryMethodWithDifferentReturnType() {\r\n    assertThat(conversionService.canConvert(String.class, Data.class)).as(\"can convert String to Data\").isFalse();\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).as(\"convert String to Data\").isThrownBy(() -> conversionService.convert(\"test\", Data.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Source",
    "entityType": "class",
    "code": "private final String value;\nprivate Source(String value) {\r\n    this.value = value;\r\n}\npublic Data toData() {\r\n    return new Data(this.value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Source#toData()",
    "entityType": "method",
    "code": "public Data toData() {\r\n    return new Data(this.value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Text",
    "entityType": "class",
    "code": "private final String value;\nprivate Text(String value) {\r\n    this.value = value;\r\n}\npublic Optional<Data> toData() {\r\n    return Optional.of(new Data(this.value));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Text#toData()",
    "entityType": "method",
    "code": "public Optional<Data> toData() {\r\n    return Optional.of(new Data(this.value));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Data",
    "entityType": "class",
    "code": "private final String value;\nprivate Data(String value) {\r\n    this.value = value;\r\n}\n@Override\r\npublic String toString() {\r\n    return this.value;\r\n}\npublic static Optional<Data> valueOf(String string) {\r\n    return (string != null ? Optional.of(new Data(string)) : Optional.empty());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Data#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.Data#valueOf(String)",
    "entityType": "method",
    "code": "public static Optional<Data> valueOf(String string) {\r\n    return (string != null ? Optional.of(new Data(string)) : Optional.empty());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StreamConverterTests",
    "entityType": "class",
    "code": "private final GenericConversionService conversionService = new GenericConversionService();\nprivate final StreamConverter streamConverter = new StreamConverter(this.conversionService);\n@BeforeEach\r\nvoid setup() {\r\n    this.conversionService.addConverter(new CollectionToCollectionConverter(this.conversionService));\r\n    this.conversionService.addConverter(new ArrayToCollectionConverter(this.conversionService));\r\n    this.conversionService.addConverter(new CollectionToArrayConverter(this.conversionService));\r\n    this.conversionService.addConverter(this.streamConverter);\r\n}\n@Test\r\nvoid convertFromStreamToList() throws NoSuchFieldException {\r\n    this.conversionService.addConverter(Number.class, String.class, new ObjectToStringConverter());\r\n    Stream<Integer> stream = Stream.of(1, 2, 3);\r\n    TypeDescriptor listOfStrings = new TypeDescriptor(Types.class.getField(\"listOfStrings\"));\r\n    Object result = this.conversionService.convert(stream, listOfStrings);\r\n    assertThat(result).asInstanceOf(list(String.class)).containsExactly(\"1\", \"2\", \"3\");\r\n}\n@Test\r\nvoid convertFromStreamToArray() throws NoSuchFieldException {\r\n    this.conversionService.addConverterFactory(new NumberToNumberConverterFactory());\r\n    Stream<Integer> stream = Stream.of(1, 2, 3);\r\n    TypeDescriptor arrayOfLongs = new TypeDescriptor(Types.class.getField(\"arrayOfLongs\"));\r\n    Object result = this.conversionService.convert(stream, arrayOfLongs);\r\n    assertThat(result).as(\"Converted object must not be null\").isNotNull();\r\n    assertThat(result.getClass().isArray()).as(\"Converted object must be an array\").isTrue();\r\n    Long[] content = (Long[]) result;\r\n    assertThat(content).containsExactly(1L, 2L, 3L);\r\n}\n@Test\r\nvoid convertFromStreamToRawList() throws NoSuchFieldException {\r\n    Stream<Integer> stream = Stream.of(1, 2, 3);\r\n    TypeDescriptor listOfStrings = new TypeDescriptor(Types.class.getField(\"rawList\"));\r\n    Object result = this.conversionService.convert(stream, listOfStrings);\r\n    assertThat(result).asInstanceOf(list(Object.class)).containsExactly(1, 2, 3);\r\n}\n@Test\r\nvoid convertFromStreamToArrayNoConverter() throws NoSuchFieldException {\r\n    Stream<Integer> stream = Stream.of(1, 2, 3);\r\n    TypeDescriptor arrayOfLongs = new TypeDescriptor(Types.class.getField(\"arrayOfLongs\"));\r\n    assertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() -> this.conversionService.convert(stream, arrayOfLongs)).withCauseInstanceOf(ConverterNotFoundException.class);\r\n}\n@Test\r\nvoid convertFromListToStream() throws NoSuchFieldException {\r\n    this.conversionService.addConverterFactory(new StringToNumberConverterFactory());\r\n    List<String> list = Arrays.asList(\"1\", \"2\", \"3\");\r\n    TypeDescriptor streamOfInteger = new TypeDescriptor(Types.class.getField(\"streamOfIntegers\"));\r\n    Object result = this.conversionService.convert(list, streamOfInteger);\r\n    assertThat(result).as(\"Converted object must be a stream\").isInstanceOf(Stream.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Stream<Integer> content = (Stream<Integer>) result;\r\n    assertThat(content.mapToInt(x -> x).sum()).isEqualTo(6);\r\n}\n@Test\r\nvoid convertFromArrayToStream() throws NoSuchFieldException {\r\n    Integer[] array = new Integer[] { 1, 0, 1 };\r\n    this.conversionService.addConverter(Integer.class, Boolean.class, source -> source == 1);\r\n    TypeDescriptor streamOfBoolean = new TypeDescriptor(Types.class.getField(\"streamOfBooleans\"));\r\n    Object result = this.conversionService.convert(array, streamOfBoolean);\r\n    assertThat(result).asInstanceOf(stream(Boolean.class)).filteredOn(x -> x).hasSize(2);\r\n}\n@Test\r\nvoid convertFromListToRawStream() throws NoSuchFieldException {\r\n    List<String> list = Arrays.asList(\"1\", \"2\", \"3\");\r\n    TypeDescriptor streamOfInteger = new TypeDescriptor(Types.class.getField(\"rawStream\"));\r\n    Object result = this.conversionService.convert(list, streamOfInteger);\r\n    assertThat(result).as(\"Converted object must be a stream\").isInstanceOf(Stream.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Stream<Object> content = (Stream<Object>) result;\r\n    assertThat(content).containsExactly(\"1\", \"2\", \"3\");\r\n}\n@Test\r\nvoid doesNotMatchIfNoStream() throws NoSuchFieldException {\r\n    assertThat(this.streamConverter.matches(new TypeDescriptor(Types.class.getField(\"listOfStrings\")), new TypeDescriptor(Types.class.getField(\"arrayOfLongs\")))).as(\"Should not match non stream type\").isFalse();\r\n}\n@Test\r\nvoid shouldFailToConvertIfNoStream() throws NoSuchFieldException {\r\n    TypeDescriptor sourceType = new TypeDescriptor(Types.class.getField(\"listOfStrings\"));\r\n    TypeDescriptor targetType = new TypeDescriptor(Types.class.getField(\"arrayOfLongs\"));\r\n    assertThatIllegalStateException().isThrownBy(() -> this.streamConverter.convert(new Object(), sourceType, targetType));\r\n}\n@SuppressWarnings({ \"rawtypes\" })\r\nstatic class Types {\r\n\r\n    public List<String> listOfStrings;\r\n\r\n    public Long[] arrayOfLongs;\r\n\r\n    public Stream<Integer> streamOfIntegers;\r\n\r\n    public Stream<Boolean> streamOfBooleans;\r\n\r\n    public Stream rawStream;\r\n\r\n    public List rawList;\r\n}",
    "comment": "\n * Tests for {@link StreamConverter}.\n *\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 4.2\n "
  },
  {
    "entityId": "org.springframework.core.convert.support.StreamConverterTests#setup()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setup() {\r\n    this.conversionService.addConverter(new CollectionToCollectionConverter(this.conversionService));\r\n    this.conversionService.addConverter(new ArrayToCollectionConverter(this.conversionService));\r\n    this.conversionService.addConverter(new CollectionToArrayConverter(this.conversionService));\r\n    this.conversionService.addConverter(this.streamConverter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StreamConverterTests#convertFromStreamToList()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertFromStreamToList() throws NoSuchFieldException {\r\n    this.conversionService.addConverter(Number.class, String.class, new ObjectToStringConverter());\r\n    Stream<Integer> stream = Stream.of(1, 2, 3);\r\n    TypeDescriptor listOfStrings = new TypeDescriptor(Types.class.getField(\"listOfStrings\"));\r\n    Object result = this.conversionService.convert(stream, listOfStrings);\r\n    assertThat(result).asInstanceOf(list(String.class)).containsExactly(\"1\", \"2\", \"3\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.convert.support.StreamConverterTests#convertFromStreamToArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid convertFromStreamToArray() throws NoSuchFieldException {\r\n    this.conversionService.addConverterFactory(new NumberToNumberConverterFactory());\r\n    Stream<Integer> stream = Stream.of(1, 2, 3);\r\n    TypeDescriptor arrayOfLongs = new TypeDescriptor(Types.class.getField(\"arrayOfLongs\"));\r\n    Object result = this.conversionService.convert(stream, arrayOfLongs);\r\n    assertThat(result).as(\"Converted object must not be null\").isNotNull();\r\n    assertThat(result.getClass().isArray()).as(\"Converted object must be an array\").isTrue();\r\n    Long[] content = (Long[]) result;\r\n    assertThat(content).containsExactly(1L, 2L, 3L);\r\n}",
    "comment": ""
  }
]