[
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() throws Exception {\r\n    inputFactory = XMLInputFactory.newInstance();\r\n    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n    saxParserFactory.setNamespaceAware(true);\r\n    SAXParser saxParser = saxParserFactory.newSAXParser();\r\n    standardReader = saxParser.getXMLReader();\r\n    standardContentHandler = mockContentHandler();\r\n    standardReader.setContentHandler(standardContentHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#contentHandlerNamespacesNoPrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid contentHandlerNamespacesNoPrefixes() throws Exception {\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    standardReader.parse(new InputSource(createTestInputStream()));\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\r\n    ContentHandler contentHandler = mockContentHandler();\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    staxXmlReader.setContentHandler(contentHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    verifyIdenticalInvocations(standardContentHandler, contentHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#contentHandlerNamespacesPrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid contentHandlerNamespacesPrefixes() throws Exception {\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    standardReader.parse(new InputSource(createTestInputStream()));\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\r\n    ContentHandler contentHandler = mockContentHandler();\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    staxXmlReader.setContentHandler(contentHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    verifyIdenticalInvocations(standardContentHandler, contentHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#contentHandlerNoNamespacesPrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid contentHandlerNoNamespacesPrefixes() throws Exception {\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\r\n    standardReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    standardReader.parse(new InputSource(createTestInputStream()));\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(createTestInputStream());\r\n    ContentHandler contentHandler = mockContentHandler();\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespaces\", false);\r\n    staxXmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    staxXmlReader.setContentHandler(contentHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    verifyIdenticalInvocations(standardContentHandler, contentHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#whitespace()",
    "entityType": "method",
    "code": "@Test\r\nvoid whitespace() throws Exception {\r\n    String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><test><node1> </node1><node2> Some text </node2></test>\";\r\n    Transformer transformer = TransformerFactory.newInstance().newTransformer();\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));\r\n    SAXSource source = new SAXSource(staxXmlReader, new InputSource());\r\n    DOMResult result = new DOMResult();\r\n    transformer.transform(source, result);\r\n    Node node1 = result.getNode().getFirstChild().getFirstChild();\r\n    assertThat(node1.getTextContent()).isEqualTo(\" \");\r\n    assertThat(node1.getNextSibling().getTextContent()).isEqualTo(\" Some text \");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#lexicalHandler()",
    "entityType": "method",
    "code": "@Test\r\nvoid lexicalHandler() throws Exception {\r\n    Resource testLexicalHandlerXml = new ClassPathResource(\"testLexicalHandler.xml\", getClass());\r\n    LexicalHandler expectedLexicalHandler = mockLexicalHandler();\r\n    standardReader.setContentHandler(null);\r\n    standardReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", expectedLexicalHandler);\r\n    standardReader.parse(new InputSource(testLexicalHandlerXml.getInputStream()));\r\n    inputFactory.setProperty(\"javax.xml.stream.isCoalescing\", Boolean.FALSE);\r\n    inputFactory.setProperty(\"http://java.sun.com/xml/stream/properties/report-cdata-event\", Boolean.TRUE);\r\n    inputFactory.setProperty(\"javax.xml.stream.isReplacingEntityReferences\", Boolean.FALSE);\r\n    inputFactory.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.FALSE);\r\n    LexicalHandler actualLexicalHandler = mockLexicalHandler();\r\n    willAnswer(invocation -> invocation.getArguments()[0] = \"element\").given(actualLexicalHandler).startDTD(anyString(), anyString(), anyString());\r\n    AbstractStaxXMLReader staxXmlReader = createStaxXmlReader(testLexicalHandlerXml.getInputStream());\r\n    staxXmlReader.setProperty(\"http://xml.org/sax/properties/lexical-handler\", actualLexicalHandler);\r\n    staxXmlReader.parse(new InputSource());\r\n    // TODO: broken comparison since Mockito 2.2 upgrade\r\n    // verifyIdenticalInvocations(expectedLexicalHandler, actualLexicalHandler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#mockLexicalHandler()",
    "entityType": "method",
    "code": "private LexicalHandler mockLexicalHandler() throws Exception {\r\n    LexicalHandler lexicalHandler = mock();\r\n    willAnswer(new CopyCharsAnswer()).given(lexicalHandler).comment(any(char[].class), anyInt(), anyInt());\r\n    return lexicalHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#createTestInputStream()",
    "entityType": "method",
    "code": "private InputStream createTestInputStream() {\r\n    return getClass().getResourceAsStream(\"testContentHandler.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#mockContentHandler()",
    "entityType": "method",
    "code": "protected final ContentHandler mockContentHandler() throws Exception {\r\n    ContentHandler contentHandler = mock();\r\n    willAnswer(new CopyCharsAnswer()).given(contentHandler).characters(any(char[].class), anyInt(), anyInt());\r\n    willAnswer(new CopyCharsAnswer()).given(contentHandler).ignorableWhitespace(any(char[].class), anyInt(), anyInt());\r\n    willAnswer(invocation -> {\r\n        invocation.getArguments()[3] = new AttributesImpl((Attributes) invocation.getArguments()[3]);\r\n        return null;\r\n    }).given(contentHandler).startElement(anyString(), anyString(), anyString(), any(Attributes.class));\r\n    return contentHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#verifyIdenticalInvocations(T,T)",
    "entityType": "method",
    "code": "protected <T> void verifyIdenticalInvocations(T expected, T actual) {\r\n    MockitoUtils.verifySameInvocations(expected, actual, new SkipLocatorArgumentsAdapter(), new CharArrayToStringAdapter(), new PartialAttributesAdapter());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReaderTests#createStaxXmlReader(InputStream)",
    "entityType": "method",
    "code": "protected abstract AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SkipLocatorArgumentsAdapter",
    "entityType": "class",
    "code": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        if (arguments[i] instanceof Locator) {\r\n            arguments[i] = null;\r\n        }\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SkipLocatorArgumentsAdapter#adaptArguments(Object[])",
    "entityType": "method",
    "code": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        if (arguments[i] instanceof Locator) {\r\n            arguments[i] = null;\r\n        }\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.CharArrayToStringAdapter",
    "entityType": "class",
    "code": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    if (arguments.length == 3 && arguments[0] instanceof char[] && arguments[1] instanceof Integer && arguments[2] instanceof Integer) {\r\n        return new Object[] { new String((char[]) arguments[0], (Integer) arguments[1], (Integer) arguments[2]) };\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.CharArrayToStringAdapter#adaptArguments(Object[])",
    "entityType": "method",
    "code": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    if (arguments.length == 3 && arguments[0] instanceof char[] && arguments[1] instanceof Integer && arguments[2] instanceof Integer) {\r\n        return new Object[] { new String((char[]) arguments[0], (Integer) arguments[1], (Integer) arguments[2]) };\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.PartialAttributesAdapter",
    "entityType": "class",
    "code": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        if (arguments[i] instanceof Attributes) {\r\n            arguments[i] = new PartialAttributes((Attributes) arguments[i]);\r\n        }\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.PartialAttributesAdapter#adaptArguments(Object[])",
    "entityType": "method",
    "code": "@Override\r\npublic Object[] adaptArguments(Object[] arguments) {\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        if (arguments[i] instanceof Attributes) {\r\n            arguments[i] = new PartialAttributes((Attributes) arguments[i]);\r\n        }\r\n    }\r\n    return arguments;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.CopyCharsAnswer",
    "entityType": "class",
    "code": "@Override\r\npublic Object answer(InvocationOnMock invocation) {\r\n    char[] chars = (char[]) invocation.getArguments()[0];\r\n    char[] copy = new char[chars.length];\r\n    System.arraycopy(chars, 0, copy, 0, chars.length);\r\n    invocation.getArguments()[0] = copy;\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.CopyCharsAnswer#answer(InvocationOnMock)",
    "entityType": "method",
    "code": "@Override\r\npublic Object answer(InvocationOnMock invocation) {\r\n    char[] chars = (char[]) invocation.getArguments()[0];\r\n    char[] copy = new char[chars.length];\r\n    System.arraycopy(chars, 0, copy, 0, chars.length);\r\n    invocation.getArguments()[0] = copy;\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.PartialAttributes",
    "entityType": "class",
    "code": "private final Attributes attributes;\npublic PartialAttributes(Attributes attributes) {\r\n    this.attributes = attributes;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    Attributes other = ((PartialAttributes) obj).attributes;\r\n    if (this.attributes.getLength() != other.getLength()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < other.getLength(); i++) {\r\n        boolean found = false;\r\n        for (int j = 0; j < attributes.getLength(); j++) {\r\n            if (other.getURI(i).equals(attributes.getURI(j)) && other.getQName(i).equals(attributes.getQName(j)) && other.getType(i).equals(attributes.getType(j)) && other.getValue(i).equals(attributes.getValue(j))) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Override\r\npublic int hashCode() {\r\n    return 1;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.PartialAttributes#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object obj) {\r\n    Attributes other = ((PartialAttributes) obj).attributes;\r\n    if (this.attributes.getLength() != other.getLength()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < other.getLength(); i++) {\r\n        boolean found = false;\r\n        for (int j = 0; j < attributes.getLength(); j++) {\r\n            if (other.getURI(i).equals(attributes.getURI(j)) && other.getQName(i).equals(attributes.getQName(j)) && other.getType(i).equals(attributes.getType(j)) && other.getValue(i).equals(attributes.getValue(j))) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.PartialAttributes#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return 1;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Constants",
    "entityType": "class",
    "code": "// The ClassFile attribute names, in the order they are defined in\r\n// https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7-300.\r\nstatic final String CONSTANT_VALUE = \"ConstantValue\";\nstatic final String CODE = \"Code\";\nstatic final String STACK_MAP_TABLE = \"StackMapTable\";\nstatic final String EXCEPTIONS = \"Exceptions\";\nstatic final String INNER_CLASSES = \"InnerClasses\";\nstatic final String ENCLOSING_METHOD = \"EnclosingMethod\";\nstatic final String SYNTHETIC = \"Synthetic\";\nstatic final String SIGNATURE = \"Signature\";\nstatic final String SOURCE_FILE = \"SourceFile\";\nstatic final String SOURCE_DEBUG_EXTENSION = \"SourceDebugExtension\";\nstatic final String LINE_NUMBER_TABLE = \"LineNumberTable\";\nstatic final String LOCAL_VARIABLE_TABLE = \"LocalVariableTable\";\nstatic final String LOCAL_VARIABLE_TYPE_TABLE = \"LocalVariableTypeTable\";\nstatic final String DEPRECATED = \"Deprecated\";\nstatic final String RUNTIME_VISIBLE_ANNOTATIONS = \"RuntimeVisibleAnnotations\";\nstatic final String RUNTIME_INVISIBLE_ANNOTATIONS = \"RuntimeInvisibleAnnotations\";\nstatic final String RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = \"RuntimeVisibleParameterAnnotations\";\nstatic final String RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = \"RuntimeInvisibleParameterAnnotations\";\nstatic final String RUNTIME_VISIBLE_TYPE_ANNOTATIONS = \"RuntimeVisibleTypeAnnotations\";\nstatic final String RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = \"RuntimeInvisibleTypeAnnotations\";\nstatic final String ANNOTATION_DEFAULT = \"AnnotationDefault\";\nstatic final String BOOTSTRAP_METHODS = \"BootstrapMethods\";\nstatic final String METHOD_PARAMETERS = \"MethodParameters\";\nstatic final String MODULE = \"Module\";\nstatic final String MODULE_PACKAGES = \"ModulePackages\";\nstatic final String MODULE_MAIN_CLASS = \"ModuleMainClass\";\nstatic final String NEST_HOST = \"NestHost\";\nstatic final String NEST_MEMBERS = \"NestMembers\";\nstatic final String PERMITTED_SUBCLASSES = \"PermittedSubclasses\";\nstatic final String RECORD = \"Record\";\n// ASM specific access flags.\r\n// WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard\r\n// access flags, and also to make sure that these flags are automatically filtered out when\r\n// written in class files (because access flags are stored using 16 bits only).\r\n// method access flag.\r\nstatic final int ACC_CONSTRUCTOR = 0x40000;\n// ASM specific stack map frame types, used in {@link ClassVisitor#visitFrame}.\r\n/**\r\n * A frame inserted between already existing frames. This internal stack map frame type (in\r\n * addition to the ones declared in {@link Opcodes}) can only be used if the frame content can be\r\n * computed from the previous existing frame and from the instructions between this existing frame\r\n * and the inserted one, without any knowledge of the type hierarchy. This kind of frame is only\r\n * used when an unconditional jump is inserted in a method while expanding an ASM specific\r\n * instruction. Keep in sync with Opcodes.java.\r\n */\r\nstatic final int F_INSERT = 256;\n// The JVM opcode values which are not part of the ASM public API.\r\n// See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html.\r\nstatic final int LDC_W = 19;\nstatic final int LDC2_W = 20;\nstatic final int ILOAD_0 = 26;\nstatic final int ILOAD_1 = 27;\nstatic final int ILOAD_2 = 28;\nstatic final int ILOAD_3 = 29;\nstatic final int LLOAD_0 = 30;\nstatic final int LLOAD_1 = 31;\nstatic final int LLOAD_2 = 32;\nstatic final int LLOAD_3 = 33;\nstatic final int FLOAD_0 = 34;\nstatic final int FLOAD_1 = 35;\nstatic final int FLOAD_2 = 36;\nstatic final int FLOAD_3 = 37;\nstatic final int DLOAD_0 = 38;\nstatic final int DLOAD_1 = 39;\nstatic final int DLOAD_2 = 40;\nstatic final int DLOAD_3 = 41;\nstatic final int ALOAD_0 = 42;\nstatic final int ALOAD_1 = 43;\nstatic final int ALOAD_2 = 44;\nstatic final int ALOAD_3 = 45;\nstatic final int ISTORE_0 = 59;\nstatic final int ISTORE_1 = 60;\nstatic final int ISTORE_2 = 61;\nstatic final int ISTORE_3 = 62;\nstatic final int LSTORE_0 = 63;\nstatic final int LSTORE_1 = 64;\nstatic final int LSTORE_2 = 65;\nstatic final int LSTORE_3 = 66;\nstatic final int FSTORE_0 = 67;\nstatic final int FSTORE_1 = 68;\nstatic final int FSTORE_2 = 69;\nstatic final int FSTORE_3 = 70;\nstatic final int DSTORE_0 = 71;\nstatic final int DSTORE_1 = 72;\nstatic final int DSTORE_2 = 73;\nstatic final int DSTORE_3 = 74;\nstatic final int ASTORE_0 = 75;\nstatic final int ASTORE_1 = 76;\nstatic final int ASTORE_2 = 77;\nstatic final int ASTORE_3 = 78;\nstatic final int WIDE = 196;\nstatic final int GOTO_W = 200;\nstatic final int JSR_W = 201;\n// Constants to convert between normal and wide jump instructions.\r\n// The delta between the GOTO_W and JSR_W opcodes and GOTO and JUMP.\r\nstatic final int WIDE_JUMP_OPCODE_DELTA = GOTO_W - Opcodes.GOTO;\n// Constants to convert JVM opcodes to the equivalent ASM specific opcodes, and vice versa.\r\n// The delta between the ASM_IFEQ, ..., ASM_IF_ACMPNE, ASM_GOTO and ASM_JSR opcodes\r\n// and IFEQ, ..., IF_ACMPNE, GOTO and JSR.\r\nstatic final int ASM_OPCODE_DELTA = 49;\n// The delta between the ASM_IFNULL and ASM_IFNONNULL opcodes and IFNULL and IFNONNULL.\r\nstatic final int ASM_IFNULL_OPCODE_DELTA = 20;\n// ASM specific opcodes, used for long forward jump instructions.\r\nstatic final int ASM_IFEQ = Opcodes.IFEQ + ASM_OPCODE_DELTA;\nstatic final int ASM_IFNE = Opcodes.IFNE + ASM_OPCODE_DELTA;\nstatic final int ASM_IFLT = Opcodes.IFLT + ASM_OPCODE_DELTA;\nstatic final int ASM_IFGE = Opcodes.IFGE + ASM_OPCODE_DELTA;\nstatic final int ASM_IFGT = Opcodes.IFGT + ASM_OPCODE_DELTA;\nstatic final int ASM_IFLE = Opcodes.IFLE + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ICMPEQ = Opcodes.IF_ICMPEQ + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ICMPNE = Opcodes.IF_ICMPNE + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ICMPLT = Opcodes.IF_ICMPLT + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ICMPGE = Opcodes.IF_ICMPGE + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ICMPGT = Opcodes.IF_ICMPGT + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ICMPLE = Opcodes.IF_ICMPLE + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ACMPEQ = Opcodes.IF_ACMPEQ + ASM_OPCODE_DELTA;\nstatic final int ASM_IF_ACMPNE = Opcodes.IF_ACMPNE + ASM_OPCODE_DELTA;\nstatic final int ASM_GOTO = Opcodes.GOTO + ASM_OPCODE_DELTA;\nstatic final int ASM_JSR = Opcodes.JSR + ASM_OPCODE_DELTA;\nstatic final int ASM_IFNULL = Opcodes.IFNULL + ASM_IFNULL_OPCODE_DELTA;\nstatic final int ASM_IFNONNULL = Opcodes.IFNONNULL + ASM_IFNULL_OPCODE_DELTA;\nstatic final int ASM_GOTO_W = 220;\nprivate Constants() {\r\n}",
    "comment": "\n * Defines additional JVM opcodes, access flags and constants which are not part of the ASM public\n * API.\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html\">JVMS 6</a>\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.Context",
    "entityType": "class",
    "code": "/**\r\n * The prototypes of the attributes that must be parsed in this class.\r\n */\r\nAttribute[] attributePrototypes;\n/**\r\n * The options used to parse this class. One or more of {@link ClassReader#SKIP_CODE}, {@link\r\n * ClassReader#SKIP_DEBUG}, {@link ClassReader#SKIP_FRAMES}, {@link ClassReader#EXPAND_FRAMES} or\r\n * {@link ClassReader#EXPAND_ASM_INSNS}.\r\n */\r\nint parsingOptions;\n/**\r\n * The buffer used to read strings in the constant pool.\r\n */\r\nchar[] charBuffer;\n// Information about the current method, i.e. the one read in the current (or latest) call\r\n// to {@link ClassReader#readMethod()}.\r\n/**\r\n * The access flags of the current method.\r\n */\r\nint currentMethodAccessFlags;\n/**\r\n * The name of the current method.\r\n */\r\nString currentMethodName;\n/**\r\n * The descriptor of the current method.\r\n */\r\nString currentMethodDescriptor;\n/**\r\n * The labels of the current method, indexed by bytecode offset (only bytecode offsets for which a\r\n * label is needed have a non null associated Label).\r\n */\r\nLabel[] currentMethodLabels;\n// Information about the current type annotation target, i.e. the one read in the current\r\n// (or latest) call to {@link ClassReader#readAnnotationTarget()}.\r\n/**\r\n * The target_type and target_info of the current type annotation target, encoded as described in\r\n * {@link TypeReference}.\r\n */\r\nint currentTypeAnnotationTarget;\n/**\r\n * The target_path of the current type annotation target.\r\n */\r\nTypePath currentTypeAnnotationTargetPath;\n/**\r\n * The start of each local variable range in the current local variable annotation.\r\n */\r\nLabel[] currentLocalVariableAnnotationRangeStarts;\n/**\r\n * The end of each local variable range in the current local variable annotation.\r\n */\r\nLabel[] currentLocalVariableAnnotationRangeEnds;\n/**\r\n * The local variable index of each local variable range in the current local variable annotation.\r\n */\r\nint[] currentLocalVariableAnnotationRangeIndices;\n// Information about the current stack map frame, i.e. the one read in the current (or latest)\r\n// call to {@link ClassReader#readFrame()}.\r\n/**\r\n * The bytecode offset of the current stack map frame.\r\n */\r\nint currentFrameOffset;\n/**\r\n * The type of the current stack map frame. One of {@link Opcodes#F_FULL}, {@link\r\n * Opcodes#F_APPEND}, {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or {@link Opcodes#F_SAME1}.\r\n */\r\nint currentFrameType;\n/**\r\n * The number of local variable types in the current stack map frame. Each type is represented\r\n * with a single array element (even long and double).\r\n */\r\nint currentFrameLocalCount;\n/**\r\n * The delta number of local variable types in the current stack map frame (each type is\r\n * represented with a single array element - even long and double). This is the number of local\r\n * variable types in this frame, minus the number of local variable types in the previous frame.\r\n */\r\nint currentFrameLocalCountDelta;\n/**\r\n * The types of the local variables in the current stack map frame. Each type is represented with\r\n * a single array element (even long and double), using the format described in {@link\r\n * MethodVisitor#visitFrame}. Depending on {@link #currentFrameType}, this contains the types of\r\n * all the local variables, or only those of the additional ones (compared to the previous frame).\r\n */\r\nObject[] currentFrameLocalTypes;\n/**\r\n * The number stack element types in the current stack map frame. Each type is represented with a\r\n * single array element (even long and double).\r\n */\r\nint currentFrameStackCount;\n/**\r\n * The types of the stack elements in the current stack map frame. Each type is represented with a\r\n * single array element (even long and double), using the format described in {@link\r\n * MethodVisitor#visitFrame}.\r\n */\r\nObject[] currentFrameStackTypes;",
    "comment": "\n * Information about a class being parsed in a {@link ClassReader}.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.util.xml.DomContentHandlerTests",
    "entityType": "class",
    "code": "private static final String XML_1 = \"<?xml version='1.0' encoding='UTF-8'?>\" + \"<?pi content?>\" + \"<root xmlns='namespace'>\" + \"<prefix:child xmlns:prefix='namespace2' xmlns:prefix2='namespace3' prefix2:attr='value'>content</prefix:child>\" + \"</root>\";\nprivate static final String XML_2_EXPECTED = \"<?xml version='1.0' encoding='UTF-8'?>\" + \"<root xmlns='namespace'>\" + \"<child xmlns='namespace2' />\" + \"</root>\";\nprivate static final String XML_2_SNIPPET = \"<?xml version='1.0' encoding='UTF-8'?>\" + \"<child xmlns='namespace2' />\";\nprivate Document expected;\nprivate DomContentHandler handler;\nprivate Document result;\nprivate XMLReader xmlReader;\nprivate DocumentBuilder documentBuilder;\n@BeforeEach\r\nvoid setUp() throws Exception {\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n    result = documentBuilder.newDocument();\r\n    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n    saxParserFactory.setNamespaceAware(true);\r\n    SAXParser saxParser = saxParserFactory.newSAXParser();\r\n    xmlReader = saxParser.getXMLReader();\r\n}\n@Test\r\nvoid contentHandlerDocumentNamespacePrefixes() throws Exception {\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    handler = new DomContentHandler(result);\r\n    expected = documentBuilder.parse(new InputSource(new StringReader(XML_1)));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.parse(new InputSource(new StringReader(XML_1)));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}\n@Test\r\nvoid contentHandlerDocumentNoNamespacePrefixes() throws Exception {\r\n    handler = new DomContentHandler(result);\r\n    expected = documentBuilder.parse(new InputSource(new StringReader(XML_1)));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.parse(new InputSource(new StringReader(XML_1)));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}\n@Test\r\nvoid contentHandlerElement() throws Exception {\r\n    Element rootElement = result.createElementNS(\"namespace\", \"root\");\r\n    result.appendChild(rootElement);\r\n    handler = new DomContentHandler(rootElement);\r\n    expected = documentBuilder.parse(new InputSource(new StringReader(XML_2_EXPECTED)));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.parse(new InputSource(new StringReader(XML_2_SNIPPET)));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": "\n * Tests for {@link DomContentHandler}.\n "
  },
  {
    "entityId": "org.springframework.util.xml.DomContentHandlerTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() throws Exception {\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n    result = documentBuilder.newDocument();\r\n    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\r\n    saxParserFactory.setNamespaceAware(true);\r\n    SAXParser saxParser = saxParserFactory.newSAXParser();\r\n    xmlReader = saxParser.getXMLReader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomContentHandlerTests#contentHandlerDocumentNamespacePrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid contentHandlerDocumentNamespacePrefixes() throws Exception {\r\n    xmlReader.setFeature(\"http://xml.org/sax/features/namespace-prefixes\", true);\r\n    handler = new DomContentHandler(result);\r\n    expected = documentBuilder.parse(new InputSource(new StringReader(XML_1)));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.parse(new InputSource(new StringReader(XML_1)));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomContentHandlerTests#contentHandlerDocumentNoNamespacePrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid contentHandlerDocumentNoNamespacePrefixes() throws Exception {\r\n    handler = new DomContentHandler(result);\r\n    expected = documentBuilder.parse(new InputSource(new StringReader(XML_1)));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.parse(new InputSource(new StringReader(XML_1)));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomContentHandlerTests#contentHandlerElement()",
    "entityType": "method",
    "code": "@Test\r\nvoid contentHandlerElement() throws Exception {\r\n    Element rootElement = result.createElementNS(\"namespace\", \"root\");\r\n    result.appendChild(rootElement);\r\n    handler = new DomContentHandler(rootElement);\r\n    expected = documentBuilder.parse(new InputSource(new StringReader(XML_2_EXPECTED)));\r\n    xmlReader.setContentHandler(handler);\r\n    xmlReader.parse(new InputSource(new StringReader(XML_2_SNIPPET)));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.CurrentFrame",
    "entityType": "class",
    "code": "CurrentFrame(final Label owner) {\r\n    super(owner);\r\n}\n/**\r\n * Sets this CurrentFrame to the input stack map frame of the next \"current\" instruction, i.e. the\r\n * instruction just after the given one. It is assumed that the value of this object when this\r\n * method is called is the stack map frame status just before the given instruction is executed.\r\n */\r\n@Override\r\nvoid execute(final int opcode, final int arg, final Symbol symbolArg, final SymbolTable symbolTable) {\r\n    super.execute(opcode, arg, symbolArg, symbolTable);\r\n    Frame successor = new Frame(null);\r\n    merge(symbolTable, successor, 0);\r\n    copyFrom(successor);\r\n}",
    "comment": "\n * Information about the input stack map frame at the \"current\" instruction of a method. This is\n * implemented as a Frame subclass for a \"basic block\" containing only one instruction.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.CurrentFrame#execute(int,int,Symbol,SymbolTable)",
    "entityType": "method",
    "code": "/**\r\n * Sets this CurrentFrame to the input stack map frame of the next \"current\" instruction, i.e. the\r\n * instruction just after the given one. It is assumed that the value of this object when this\r\n * method is called is the stack map frame status just before the given instruction is executed.\r\n */\r\n@Override\r\nvoid execute(final int opcode, final int arg, final Symbol symbolArg, final SymbolTable symbolTable) {\r\n    super.execute(opcode, arg, symbolArg, symbolTable);\r\n    Frame successor = new Frame(null);\r\n    merge(symbolTable, successor, 0);\r\n    copyFrom(successor);\r\n}",
    "comment": "\n   * Sets this CurrentFrame to the input stack map frame of the next \"current\" instruction, i.e. the\n   * instruction just after the given one. It is assumed that the value of this object when this\n   * method is called is the stack map frame status just before the given instruction is executed.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests",
    "entityType": "class",
    "code": "private static final Element SCHOOL_ELEMENT = getDocumentElement(\"\"\"\r\n    <?xml version=\"1.0\"?>\r\n    <school>TestSchool\r\n    \t<class teacher=\"Happy Teacher\">Test Teacher One</class>\r\n    \t<class teacher=\"Sad Teacher\">Test Teacher Two</class>\r\n    \t<principal>Test Principal</principal>\r\n    \t<guard>Fox Test</guard>\r\n    </school>\"\"\");\n@Test\r\nvoid getChildElementsByTagNameWithSeveralMatchingTags() {\r\n    List<Element> childElements = DomUtils.getChildElementsByTagName(SCHOOL_ELEMENT, \"class\", \"principal\");\r\n    assertThat(childElements).map(Element::getNodeName).containsExactly(\"class\", \"class\", \"principal\");\r\n}\n@Test\r\nvoid getChildElementsByTagNameWhenTagDoesNotExist() {\r\n    assertThat(DomUtils.getChildElementsByTagName(SCHOOL_ELEMENT, \"teacher\")).isEmpty();\r\n}\n@Test\r\nvoid getChildElementByTagNameWithMatchingTag() {\r\n    Element principalElement = DomUtils.getChildElementByTagName(SCHOOL_ELEMENT, \"principal\");\r\n    assertThat(principalElement).isNotNull();\r\n    assertThat(principalElement.getTextContent()).isEqualTo(\"Test Principal\");\r\n}\n@Test\r\nvoid getChildElementByTagNameWithNonMatchingTag() {\r\n    assertThat(DomUtils.getChildElementByTagName(SCHOOL_ELEMENT, \"teacher\")).isNull();\r\n}\n@Test\r\nvoid getChildElementValueByTagName() {\r\n    assertThat(DomUtils.getChildElementValueByTagName(SCHOOL_ELEMENT, \"guard\")).isEqualTo(\"Fox Test\");\r\n}\n@Test\r\nvoid getChildElementValueByTagNameWithNonMatchingTag() {\r\n    assertThat(DomUtils.getChildElementValueByTagName(SCHOOL_ELEMENT, \"math tutor\")).isNull();\r\n}\n@Test\r\nvoid getChildElements() {\r\n    List<Element> childElements = DomUtils.getChildElements(SCHOOL_ELEMENT);\r\n    assertThat(childElements).map(Element::getNodeName).containsExactly(\"class\", \"class\", \"principal\", \"guard\");\r\n}\n@Test\r\nvoid getTextValueWithCharacterDataNode() {\r\n    assertThat(DomUtils.getTextValue(SCHOOL_ELEMENT)).isEqualToIgnoringWhitespace(\"TestSchool\");\r\n}\n@Test\r\nvoid getTextValueWithCommentInXml() {\r\n    Element elementWithComment = getDocumentElement(\"\"\"\r\n        <?xml version=\"1.0\"?>\r\n        <state>\r\n        \t<!-- This is a comment -->\r\n        \t<person>Alice</person>\r\n        </state>\"\"\");\r\n    assertThat(DomUtils.getTextValue(elementWithComment)).isBlank();\r\n}\n@Test\r\nvoid getTextValueWithEntityReference() {\r\n    Element elementWithEntityReference = getDocumentElement(\"\"\"\r\n        <?xml version=\"1.0\"?>\r\n        <state>\r\n        \t&amp;\r\n        \t<person>Alice</person>\r\n        </state>\"\"\");\r\n    assertThat(DomUtils.getTextValue(elementWithEntityReference)).contains(\"&\");\r\n}\n@Test\r\nvoid getTextValueWithEmptyElement() {\r\n    Element emptyElement = getDocumentElement(\"\"\"\r\n        <?xml version=\"1.0\"?>\r\n        <person></person>\"\"\");\r\n    assertThat(DomUtils.getTextValue(emptyElement)).isBlank();\r\n}\n@Test\r\nvoid nodeNameEqualsWhenTrue() {\r\n    assertThat(DomUtils.nodeNameEquals(SCHOOL_ELEMENT, \"school\")).isTrue();\r\n}\n@Test\r\nvoid nodeNameEqualsWhenFalse() {\r\n    assertThat(DomUtils.nodeNameEquals(SCHOOL_ELEMENT, \"college\")).isFalse();\r\n}\nprivate static Element getDocumentElement(String xmlContent) {\r\n    try {\r\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n        Document document = documentBuilder.parse(new ByteArrayInputStream(xmlContent.getBytes()));\r\n        return document.getDocumentElement();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Failed to parse xml content:%n%s\".formatted(xmlContent), ex);\r\n    }\r\n}",
    "comment": "\n * Tests for {@link DomUtils}.\n *\n * @author Stephane Nicoll\n * @author Kunal Jani\n "
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElementsByTagNameWithSeveralMatchingTags()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElementsByTagNameWithSeveralMatchingTags() {\r\n    List<Element> childElements = DomUtils.getChildElementsByTagName(SCHOOL_ELEMENT, \"class\", \"principal\");\r\n    assertThat(childElements).map(Element::getNodeName).containsExactly(\"class\", \"class\", \"principal\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElementsByTagNameWhenTagDoesNotExist()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElementsByTagNameWhenTagDoesNotExist() {\r\n    assertThat(DomUtils.getChildElementsByTagName(SCHOOL_ELEMENT, \"teacher\")).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElementByTagNameWithMatchingTag()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElementByTagNameWithMatchingTag() {\r\n    Element principalElement = DomUtils.getChildElementByTagName(SCHOOL_ELEMENT, \"principal\");\r\n    assertThat(principalElement).isNotNull();\r\n    assertThat(principalElement.getTextContent()).isEqualTo(\"Test Principal\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElementByTagNameWithNonMatchingTag()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElementByTagNameWithNonMatchingTag() {\r\n    assertThat(DomUtils.getChildElementByTagName(SCHOOL_ELEMENT, \"teacher\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElementValueByTagName()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElementValueByTagName() {\r\n    assertThat(DomUtils.getChildElementValueByTagName(SCHOOL_ELEMENT, \"guard\")).isEqualTo(\"Fox Test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElementValueByTagNameWithNonMatchingTag()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElementValueByTagNameWithNonMatchingTag() {\r\n    assertThat(DomUtils.getChildElementValueByTagName(SCHOOL_ELEMENT, \"math tutor\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getChildElements()",
    "entityType": "method",
    "code": "@Test\r\nvoid getChildElements() {\r\n    List<Element> childElements = DomUtils.getChildElements(SCHOOL_ELEMENT);\r\n    assertThat(childElements).map(Element::getNodeName).containsExactly(\"class\", \"class\", \"principal\", \"guard\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getTextValueWithCharacterDataNode()",
    "entityType": "method",
    "code": "@Test\r\nvoid getTextValueWithCharacterDataNode() {\r\n    assertThat(DomUtils.getTextValue(SCHOOL_ELEMENT)).isEqualToIgnoringWhitespace(\"TestSchool\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getTextValueWithCommentInXml()",
    "entityType": "method",
    "code": "@Test\r\nvoid getTextValueWithCommentInXml() {\r\n    Element elementWithComment = getDocumentElement(\"\"\"\r\n        <?xml version=\"1.0\"?>\r\n        <state>\r\n        \t<!-- This is a comment -->\r\n        \t<person>Alice</person>\r\n        </state>\"\"\");\r\n    assertThat(DomUtils.getTextValue(elementWithComment)).isBlank();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getTextValueWithEntityReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid getTextValueWithEntityReference() {\r\n    Element elementWithEntityReference = getDocumentElement(\"\"\"\r\n        <?xml version=\"1.0\"?>\r\n        <state>\r\n        \t&amp;\r\n        \t<person>Alice</person>\r\n        </state>\"\"\");\r\n    assertThat(DomUtils.getTextValue(elementWithEntityReference)).contains(\"&\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getTextValueWithEmptyElement()",
    "entityType": "method",
    "code": "@Test\r\nvoid getTextValueWithEmptyElement() {\r\n    Element emptyElement = getDocumentElement(\"\"\"\r\n        <?xml version=\"1.0\"?>\r\n        <person></person>\"\"\");\r\n    assertThat(DomUtils.getTextValue(emptyElement)).isBlank();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#nodeNameEqualsWhenTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid nodeNameEqualsWhenTrue() {\r\n    assertThat(DomUtils.nodeNameEquals(SCHOOL_ELEMENT, \"school\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#nodeNameEqualsWhenFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid nodeNameEqualsWhenFalse() {\r\n    assertThat(DomUtils.nodeNameEquals(SCHOOL_ELEMENT, \"college\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.DomUtilsTests#getDocumentElement(String)",
    "entityType": "method",
    "code": "private static Element getDocumentElement(String xmlContent) {\r\n    try {\r\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n        Document document = documentBuilder.parse(new ByteArrayInputStream(xmlContent.getBytes()));\r\n        return document.getDocumentElement();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Failed to parse xml content:%n%s\".formatted(xmlContent), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Edge",
    "entityType": "class",
    "code": "/**\r\n * A control flow graph edge corresponding to a jump or ret instruction. Only used with {@link\r\n * ClassWriter#COMPUTE_FRAMES}.\r\n */\r\nstatic final int JUMP = 0;\n/**\r\n * A control flow graph edge corresponding to an exception handler. Only used with {@link\r\n * ClassWriter#COMPUTE_MAXS}.\r\n */\r\nstatic final int EXCEPTION = 0x7FFFFFFF;\n/**\r\n * Information about this control flow graph edge.\r\n *\r\n * <ul>\r\n *   <li>If {@link ClassWriter#COMPUTE_MAXS} is used, this field contains either a stack size\r\n *       delta (for an edge corresponding to a jump instruction), or the value EXCEPTION (for an\r\n *       edge corresponding to an exception handler). The stack size delta is the stack size just\r\n *       after the jump instruction, minus the stack size at the beginning of the predecessor\r\n *       basic block, i.e. the one containing the jump instruction.\r\n *   <li>If {@link ClassWriter#COMPUTE_FRAMES} is used, this field contains either the value JUMP\r\n *       (for an edge corresponding to a jump instruction), or the index, in the {@link\r\n *       ClassWriter} type table, of the exception type that is handled (for an edge corresponding\r\n *       to an exception handler).\r\n * </ul>\r\n */\r\nfinal int info;\n/**\r\n * The successor block of this control flow graph edge.\r\n */\r\nfinal Label successor;\n/**\r\n * The next edge in the list of outgoing edges of a basic block. See {@link Label#outgoingEdges}.\r\n */\r\nEdge nextEdge;\n/**\r\n * Constructs a new Edge.\r\n *\r\n * @param info see {@link #info}.\r\n * @param successor see {@link #successor}.\r\n * @param nextEdge see {@link #nextEdge}.\r\n */\r\nEdge(final int info, final Label successor, final Edge nextEdge) {\r\n    this.info = info;\r\n    this.successor = successor;\r\n    this.nextEdge = nextEdge;\r\n}",
    "comment": "\n * An edge in the control flow graph of a method. Each node of this graph is a basic block,\n * represented with the Label corresponding to its first instruction. Each edge goes from one node\n * to another, i.e. from one basic block to another (called the predecessor and successor blocks,\n * respectively). An edge corresponds either to a jump or ret instruction or to an exception\n * handler.\n *\n * @see Label\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.util.xml.ListBasedXMLEventReaderTests",
    "entityType": "class",
    "code": "private final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\nprivate final XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();\n@Test\r\nvoid standard() throws Exception {\r\n    String xml = \"<foo><bar>baz</bar></foo>\";\r\n    List<XMLEvent> events = readEvents(xml);\r\n    ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\r\n    StringWriter resultWriter = new StringWriter();\r\n    XMLEventWriter writer = this.outputFactory.createXMLEventWriter(resultWriter);\r\n    writer.add(reader);\r\n    assertThat(XmlContent.from(resultWriter)).isSimilarTo(xml);\r\n}\n@Test\r\nvoid getElementText() throws Exception {\r\n    String xml = \"<foo><bar>baz</bar></foo>\";\r\n    List<XMLEvent> events = readEvents(xml);\r\n    ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_DOCUMENT);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_ELEMENT);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_ELEMENT);\r\n    assertThat(reader.getElementText()).isEqualTo(\"baz\");\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(END_ELEMENT);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(END_DOCUMENT);\r\n}\n@Test\r\nvoid getElementTextThrowsExceptionAtWrongPosition() throws Exception {\r\n    String xml = \"<foo><bar>baz</bar></foo>\";\r\n    List<XMLEvent> events = readEvents(xml);\r\n    ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_DOCUMENT);\r\n    assertThatExceptionOfType(XMLStreamException.class).isThrownBy(reader::getElementText).withMessageStartingWith(\"Not at START_ELEMENT\");\r\n}\nprivate List<XMLEvent> readEvents(String xml) throws XMLStreamException {\r\n    XMLEventReader reader = this.inputFactory.createXMLEventReader(new StringReader(xml));\r\n    List<XMLEvent> events = new ArrayList<>();\r\n    while (reader.hasNext()) {\r\n        events.add(reader.nextEvent());\r\n    }\r\n    return events;\r\n}",
    "comment": "\n * @author Arjen Poutsma\n * @author Andrzej Hołowko\n "
  },
  {
    "entityId": "org.springframework.util.xml.ListBasedXMLEventReaderTests#standard()",
    "entityType": "method",
    "code": "@Test\r\nvoid standard() throws Exception {\r\n    String xml = \"<foo><bar>baz</bar></foo>\";\r\n    List<XMLEvent> events = readEvents(xml);\r\n    ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\r\n    StringWriter resultWriter = new StringWriter();\r\n    XMLEventWriter writer = this.outputFactory.createXMLEventWriter(resultWriter);\r\n    writer.add(reader);\r\n    assertThat(XmlContent.from(resultWriter)).isSimilarTo(xml);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.ListBasedXMLEventReaderTests#getElementText()",
    "entityType": "method",
    "code": "@Test\r\nvoid getElementText() throws Exception {\r\n    String xml = \"<foo><bar>baz</bar></foo>\";\r\n    List<XMLEvent> events = readEvents(xml);\r\n    ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_DOCUMENT);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_ELEMENT);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_ELEMENT);\r\n    assertThat(reader.getElementText()).isEqualTo(\"baz\");\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(END_ELEMENT);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(END_DOCUMENT);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.ListBasedXMLEventReaderTests#getElementTextThrowsExceptionAtWrongPosition()",
    "entityType": "method",
    "code": "@Test\r\nvoid getElementTextThrowsExceptionAtWrongPosition() throws Exception {\r\n    String xml = \"<foo><bar>baz</bar></foo>\";\r\n    List<XMLEvent> events = readEvents(xml);\r\n    ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\r\n    assertThat(reader.nextEvent().getEventType()).isEqualTo(START_DOCUMENT);\r\n    assertThatExceptionOfType(XMLStreamException.class).isThrownBy(reader::getElementText).withMessageStartingWith(\"Not at START_ELEMENT\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.ListBasedXMLEventReaderTests#readEvents(String)",
    "entityType": "method",
    "code": "private List<XMLEvent> readEvents(String xml) throws XMLStreamException {\r\n    XMLEventReader reader = this.inputFactory.createXMLEventReader(new StringReader(xml));\r\n    List<XMLEvent> events = new ArrayList<>();\r\n    while (reader.hasNext()) {\r\n        events.add(reader.nextEvent());\r\n    }\r\n    return events;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.FieldVisitor",
    "entityType": "class",
    "code": "/**\r\n * The ASM API version implemented by this visitor. The value of this field must be one of the\r\n * {@code ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected final int api;\n/**\r\n * The field visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n */\r\nprotected FieldVisitor fv;\n/**\r\n * Constructs a new {@link FieldVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n */\r\nprotected FieldVisitor(final int api) {\r\n    this(api, null);\r\n}\n/**\r\n * Constructs a new {@link FieldVisitor}.\r\n *\r\n * @param api the ASM API version implemented by this visitor. Must be one of the {@code\r\n *     ASM}<i>x</i> values in {@link Opcodes}.\r\n * @param fieldVisitor the field visitor to which this visitor must delegate method calls. May be\r\n *     null.\r\n */\r\nprotected FieldVisitor(final int api, final FieldVisitor fieldVisitor) {\r\n    if (api != Opcodes.ASM9 && api != Opcodes.ASM8 && api != Opcodes.ASM7 && api != Opcodes.ASM6 && api != Opcodes.ASM5 && api != Opcodes.ASM4 && api != Opcodes.ASM10_EXPERIMENTAL) {\r\n        throw new IllegalArgumentException(\"Unsupported api \" + api);\r\n    }\r\n    // SPRING PATCH: no preview mode check for ASM experimental\r\n    this.api = api;\r\n    this.fv = fieldVisitor;\r\n}\n/**\r\n * The field visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the field visitor to which this visitor must delegate method calls, or {@literal null}.\r\n */\r\npublic FieldVisitor getDelegate() {\r\n    return fv;\r\n}\n/**\r\n * Visits an annotation of the field.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (fv != null) {\r\n        return fv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits an annotation on the type of the field.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#FIELD}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(\"This feature requires ASM5\");\r\n    }\r\n    if (fv != null) {\r\n        return fv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Visits a non standard attribute of the field.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (fv != null) {\r\n        fv.visitAttribute(attribute);\r\n    }\r\n}\n/**\r\n * Visits the end of the field. This method, which is the last one to be called, is used to inform\r\n * the visitor that all the annotations and attributes of the field have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (fv != null) {\r\n        fv.visitEnd();\r\n    }\r\n}",
    "comment": "\n * A visitor to visit a Java field. The methods of this class must be called in the following order:\n * ( {@code visitAnnotation} | {@code visitTypeAnnotation} | {@code visitAttribute} )* {@code\n * visitEnd}.\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.FieldVisitor#getDelegate()",
    "entityType": "method",
    "code": "/**\r\n * The field visitor to which this visitor must delegate method calls. May be {@literal null}.\r\n *\r\n * @return the field visitor to which this visitor must delegate method calls, or {@literal null}.\r\n */\r\npublic FieldVisitor getDelegate() {\r\n    return fv;\r\n}",
    "comment": "\n   * The field visitor to which this visitor must delegate method calls. May be {@literal null}.\n   *\n   * @return the field visitor to which this visitor must delegate method calls, or {@literal null}.\n   "
  },
  {
    "entityId": "org.springframework.asm.FieldVisitor#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation of the field.\r\n *\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (fv != null) {\r\n        return fv.visitAnnotation(descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation of the field.\n   *\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.FieldVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Visits an annotation on the type of the field.\r\n *\r\n * @param typeRef a reference to the annotated type. The sort of this type reference must be\r\n *     {@link TypeReference#FIELD}. See {@link TypeReference}.\r\n * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\r\n *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\r\n *     'typeRef' as a whole.\r\n * @param descriptor the class descriptor of the annotation class.\r\n * @param visible {@literal true} if the annotation is visible at runtime.\r\n * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\r\n *     interested in visiting this annotation.\r\n */\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (api < Opcodes.ASM5) {\r\n        throw new UnsupportedOperationException(\"This feature requires ASM5\");\r\n    }\r\n    if (fv != null) {\r\n        return fv.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\r\n    }\r\n    return null;\r\n}",
    "comment": "\n   * Visits an annotation on the type of the field.\n   *\n   * @param typeRef a reference to the annotated type. The sort of this type reference must be\n   *     {@link TypeReference#FIELD}. See {@link TypeReference}.\n   * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n   *     static inner type within 'typeRef'. May be {@literal null} if the annotation targets\n   *     'typeRef' as a whole.\n   * @param descriptor the class descriptor of the annotation class.\n   * @param visible {@literal true} if the annotation is visible at runtime.\n   * @return a visitor to visit the annotation values, or {@literal null} if this visitor is not\n   *     interested in visiting this annotation.\n   "
  },
  {
    "entityId": "org.springframework.asm.FieldVisitor#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "/**\r\n * Visits a non standard attribute of the field.\r\n *\r\n * @param attribute an attribute.\r\n */\r\npublic void visitAttribute(final Attribute attribute) {\r\n    if (fv != null) {\r\n        fv.visitAttribute(attribute);\r\n    }\r\n}",
    "comment": "\n   * Visits a non standard attribute of the field.\n   *\n   * @param attribute an attribute.\n   "
  },
  {
    "entityId": "org.springframework.asm.FieldVisitor#visitEnd()",
    "entityType": "method",
    "code": "/**\r\n * Visits the end of the field. This method, which is the last one to be called, is used to inform\r\n * the visitor that all the annotations and attributes of the field have been visited.\r\n */\r\npublic void visitEnd() {\r\n    if (fv != null) {\r\n        fv.visitEnd();\r\n    }\r\n}",
    "comment": "\n   * Visits the end of the field. This method, which is the last one to be called, is used to inform\n   * the visitor that all the annotations and attributes of the field have been visited.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests",
    "entityType": "class",
    "code": "private final String unboundPrefix = \"unbound\";\nprivate final String prefix = \"prefix\";\nprivate final String namespaceUri = \"https://Namespace-name-URI\";\nprivate final String additionalNamespaceUri = \"https://Additional-namespace-name-URI\";\nprivate final String unboundNamespaceUri = \"https://Unbound-namespace-name-URI\";\nprivate final String defaultNamespaceUri = \"https://Default-namespace-name-URI\";\nprivate final SimpleNamespaceContext context = new SimpleNamespaceContext();\n@Test\r\nvoid getNamespaceURI_withNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.getNamespaceURI(null));\r\n}\n@Test\r\nvoid getNamespaceURI() {\r\n    context.bindNamespaceUri(XMLConstants.XMLNS_ATTRIBUTE, additionalNamespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.XMLNS_ATTRIBUTE)).as(\"Always returns \\\"http://www.w3.org/2000/xmlns/\\\" for \\\"xmlns\\\"\").isEqualTo(XMLConstants.XMLNS_ATTRIBUTE_NS_URI);\r\n    context.bindNamespaceUri(XMLConstants.XML_NS_PREFIX, additionalNamespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.XML_NS_PREFIX)).as(\"Always returns \\\"http://www.w3.org/XML/1998/namespace\\\" for \\\"xml\\\"\").isEqualTo(XMLConstants.XML_NS_URI);\r\n    assertThat(context.getNamespaceURI(unboundPrefix)).as(\"Returns \\\"\\\" for an unbound prefix\").isEmpty();\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    assertThat(context.getNamespaceURI(prefix)).as(\"Returns the bound namespace URI for a bound prefix\").isEqualTo(namespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.DEFAULT_NS_PREFIX)).as(\"By default returns URI \\\"\\\" for the default namespace prefix\").isEmpty();\r\n    context.bindDefaultNamespaceUri(defaultNamespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.DEFAULT_NS_PREFIX)).as(\"Returns the set URI for the default namespace prefix\").isEqualTo(defaultNamespaceUri);\r\n}\n@Test\r\nvoid getPrefix_withNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.getPrefix(null));\r\n}\n@Test\r\nvoid getPrefix() {\r\n    assertThat(context.getPrefix(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)).as(\"Always returns \\\"xmlns\\\" for \\\"http://www.w3.org/2000/xmlns/\\\"\").isEqualTo(XMLConstants.XMLNS_ATTRIBUTE);\r\n    assertThat(context.getPrefix(XMLConstants.XML_NS_URI)).as(\"Always returns \\\"xml\\\" for \\\"http://www.w3.org/XML/1998/namespace\\\"\").isEqualTo(XMLConstants.XML_NS_PREFIX);\r\n    assertThat(context.getPrefix(unboundNamespaceUri)).as(\"Returns null for an unbound namespace URI\").isNull();\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    assertThat(context.getPrefix(namespaceUri)).as(\"Returns a prefix for a bound namespace URI\").matches(prefix -> \"prefix1\".equals(prefix) || \"prefix2\".equals(prefix));\r\n}\n@Test\r\nvoid getPrefixes_withNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.getPrefixes(null));\r\n}\n@Test\r\nvoid getPrefixes_IteratorIsNotModifiable() {\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    Iterator<String> iterator = context.getPrefixes(namespaceUri);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(iterator::remove);\r\n}\n@Test\r\nvoid getPrefixes() {\r\n    assertThat(getItemSet(context.getPrefixes(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))).as(\"Returns only \\\"xmlns\\\" for \\\"http://www.w3.org/2000/xmlns/\\\"\").containsExactly(XMLConstants.XMLNS_ATTRIBUTE);\r\n    assertThat(getItemSet(context.getPrefixes(XMLConstants.XML_NS_URI))).as(\"Returns only \\\"xml\\\" for \\\"http://www.w3.org/XML/1998/namespace\\\"\").containsExactly(XMLConstants.XML_NS_PREFIX);\r\n    assertThat(context.getPrefixes(\"unbound Namespace URI\").hasNext()).as(\"Returns empty iterator for unbound prefix\").isFalse();\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    assertThat(getItemSet(context.getPrefixes(namespaceUri))).as(\"Returns all prefixes (and only those) bound to the namespace URI\").containsExactlyInAnyOrder(\"prefix1\", \"prefix2\");\r\n}\n@Test\r\nvoid bindNamespaceUri_withNullNamespaceUri() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.bindNamespaceUri(\"prefix\", null));\r\n}\n@Test\r\nvoid bindNamespaceUri_withNullPrefix() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.bindNamespaceUri(null, namespaceUri));\r\n}\n@Test\r\nvoid bindNamespaceUri() {\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    assertThat(context.getNamespaceURI(prefix)).as(\"The Namespace URI was bound to the prefix\").isEqualTo(namespaceUri);\r\n    assertThat(getItemSet(context.getPrefixes(namespaceUri))).as(\"The prefix was bound to the namespace URI\").contains(prefix);\r\n}\n@Test\r\nvoid getBoundPrefixes() {\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix3\", additionalNamespaceUri);\r\n    assertThat(getItemSet(context.getBoundPrefixes())).as(\"Returns all bound prefixes\").containsExactlyInAnyOrder(\"prefix1\", \"prefix2\", \"prefix3\");\r\n}\n@Test\r\nvoid clear() {\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix3\", additionalNamespaceUri);\r\n    context.clear();\r\n    assertThat(context.getBoundPrefixes().hasNext()).as(\"All bound prefixes were removed\").isFalse();\r\n    assertThat(context.getPrefixes(namespaceUri).hasNext()).as(\"All bound namespace URIs were removed\").isFalse();\r\n}\n@Test\r\nvoid removeBinding() {\r\n    context.removeBinding(unboundPrefix);\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    context.removeBinding(prefix);\r\n    assertThat(context.getNamespaceURI(prefix)).as(\"Returns default namespace URI for removed prefix\").isEmpty();\r\n    assertThat(context.getPrefix(namespaceUri)).as(\"#getPrefix returns null when all prefixes for a namespace URI were removed\").isNull();\r\n    assertThat(context.getPrefixes(namespaceUri).hasNext()).as(\"#getPrefixes returns an empty iterator when all prefixes for a namespace URI were removed\").isFalse();\r\n    context.bindNamespaceUri(\"prefix1\", additionalNamespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", additionalNamespaceUri);\r\n    context.removeBinding(\"prefix1\");\r\n    assertThat(context.getNamespaceURI(\"prefix1\")).as(\"Prefix was unbound\").isEmpty();\r\n    assertThat(context.getPrefix(additionalNamespaceUri)).as(\"#getPrefix returns a bound prefix after removal of another prefix for the same namespace URI\").isEqualTo(\"prefix2\");\r\n    assertThat(getItemSet(context.getPrefixes(additionalNamespaceUri))).as(\"Prefix was removed from namespace URI\").containsExactly(\"prefix2\");\r\n}\nprivate Set<String> getItemSet(Iterator<String> iterator) {\r\n    Set<String> itemSet = new LinkedHashSet<>();\r\n    iterator.forEachRemaining(itemSet::add);\r\n    return itemSet;\r\n}",
    "comment": "\n * @author Arjen Poutsma\n * @author Leo Arnold\n "
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getNamespaceURI_withNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid getNamespaceURI_withNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.getNamespaceURI(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getNamespaceURI()",
    "entityType": "method",
    "code": "@Test\r\nvoid getNamespaceURI() {\r\n    context.bindNamespaceUri(XMLConstants.XMLNS_ATTRIBUTE, additionalNamespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.XMLNS_ATTRIBUTE)).as(\"Always returns \\\"http://www.w3.org/2000/xmlns/\\\" for \\\"xmlns\\\"\").isEqualTo(XMLConstants.XMLNS_ATTRIBUTE_NS_URI);\r\n    context.bindNamespaceUri(XMLConstants.XML_NS_PREFIX, additionalNamespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.XML_NS_PREFIX)).as(\"Always returns \\\"http://www.w3.org/XML/1998/namespace\\\" for \\\"xml\\\"\").isEqualTo(XMLConstants.XML_NS_URI);\r\n    assertThat(context.getNamespaceURI(unboundPrefix)).as(\"Returns \\\"\\\" for an unbound prefix\").isEmpty();\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    assertThat(context.getNamespaceURI(prefix)).as(\"Returns the bound namespace URI for a bound prefix\").isEqualTo(namespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.DEFAULT_NS_PREFIX)).as(\"By default returns URI \\\"\\\" for the default namespace prefix\").isEmpty();\r\n    context.bindDefaultNamespaceUri(defaultNamespaceUri);\r\n    assertThat(context.getNamespaceURI(XMLConstants.DEFAULT_NS_PREFIX)).as(\"Returns the set URI for the default namespace prefix\").isEqualTo(defaultNamespaceUri);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getPrefix_withNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPrefix_withNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.getPrefix(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getPrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPrefix() {\r\n    assertThat(context.getPrefix(XMLConstants.XMLNS_ATTRIBUTE_NS_URI)).as(\"Always returns \\\"xmlns\\\" for \\\"http://www.w3.org/2000/xmlns/\\\"\").isEqualTo(XMLConstants.XMLNS_ATTRIBUTE);\r\n    assertThat(context.getPrefix(XMLConstants.XML_NS_URI)).as(\"Always returns \\\"xml\\\" for \\\"http://www.w3.org/XML/1998/namespace\\\"\").isEqualTo(XMLConstants.XML_NS_PREFIX);\r\n    assertThat(context.getPrefix(unboundNamespaceUri)).as(\"Returns null for an unbound namespace URI\").isNull();\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    assertThat(context.getPrefix(namespaceUri)).as(\"Returns a prefix for a bound namespace URI\").matches(prefix -> \"prefix1\".equals(prefix) || \"prefix2\".equals(prefix));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getPrefixes_withNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPrefixes_withNull() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.getPrefixes(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getPrefixes_IteratorIsNotModifiable()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPrefixes_IteratorIsNotModifiable() {\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    Iterator<String> iterator = context.getPrefixes(namespaceUri);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(iterator::remove);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getPrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPrefixes() {\r\n    assertThat(getItemSet(context.getPrefixes(XMLConstants.XMLNS_ATTRIBUTE_NS_URI))).as(\"Returns only \\\"xmlns\\\" for \\\"http://www.w3.org/2000/xmlns/\\\"\").containsExactly(XMLConstants.XMLNS_ATTRIBUTE);\r\n    assertThat(getItemSet(context.getPrefixes(XMLConstants.XML_NS_URI))).as(\"Returns only \\\"xml\\\" for \\\"http://www.w3.org/XML/1998/namespace\\\"\").containsExactly(XMLConstants.XML_NS_PREFIX);\r\n    assertThat(context.getPrefixes(\"unbound Namespace URI\").hasNext()).as(\"Returns empty iterator for unbound prefix\").isFalse();\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    assertThat(getItemSet(context.getPrefixes(namespaceUri))).as(\"Returns all prefixes (and only those) bound to the namespace URI\").containsExactlyInAnyOrder(\"prefix1\", \"prefix2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#bindNamespaceUri_withNullNamespaceUri()",
    "entityType": "method",
    "code": "@Test\r\nvoid bindNamespaceUri_withNullNamespaceUri() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.bindNamespaceUri(\"prefix\", null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#bindNamespaceUri_withNullPrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid bindNamespaceUri_withNullPrefix() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> context.bindNamespaceUri(null, namespaceUri));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#bindNamespaceUri()",
    "entityType": "method",
    "code": "@Test\r\nvoid bindNamespaceUri() {\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    assertThat(context.getNamespaceURI(prefix)).as(\"The Namespace URI was bound to the prefix\").isEqualTo(namespaceUri);\r\n    assertThat(getItemSet(context.getPrefixes(namespaceUri))).as(\"The prefix was bound to the namespace URI\").contains(prefix);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getBoundPrefixes()",
    "entityType": "method",
    "code": "@Test\r\nvoid getBoundPrefixes() {\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix3\", additionalNamespaceUri);\r\n    assertThat(getItemSet(context.getBoundPrefixes())).as(\"Returns all bound prefixes\").containsExactlyInAnyOrder(\"prefix1\", \"prefix2\", \"prefix3\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#clear()",
    "entityType": "method",
    "code": "@Test\r\nvoid clear() {\r\n    context.bindNamespaceUri(\"prefix1\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", namespaceUri);\r\n    context.bindNamespaceUri(\"prefix3\", additionalNamespaceUri);\r\n    context.clear();\r\n    assertThat(context.getBoundPrefixes().hasNext()).as(\"All bound prefixes were removed\").isFalse();\r\n    assertThat(context.getPrefixes(namespaceUri).hasNext()).as(\"All bound namespace URIs were removed\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#removeBinding()",
    "entityType": "method",
    "code": "@Test\r\nvoid removeBinding() {\r\n    context.removeBinding(unboundPrefix);\r\n    context.bindNamespaceUri(prefix, namespaceUri);\r\n    context.removeBinding(prefix);\r\n    assertThat(context.getNamespaceURI(prefix)).as(\"Returns default namespace URI for removed prefix\").isEmpty();\r\n    assertThat(context.getPrefix(namespaceUri)).as(\"#getPrefix returns null when all prefixes for a namespace URI were removed\").isNull();\r\n    assertThat(context.getPrefixes(namespaceUri).hasNext()).as(\"#getPrefixes returns an empty iterator when all prefixes for a namespace URI were removed\").isFalse();\r\n    context.bindNamespaceUri(\"prefix1\", additionalNamespaceUri);\r\n    context.bindNamespaceUri(\"prefix2\", additionalNamespaceUri);\r\n    context.removeBinding(\"prefix1\");\r\n    assertThat(context.getNamespaceURI(\"prefix1\")).as(\"Prefix was unbound\").isEmpty();\r\n    assertThat(context.getPrefix(additionalNamespaceUri)).as(\"#getPrefix returns a bound prefix after removal of another prefix for the same namespace URI\").isEqualTo(\"prefix2\");\r\n    assertThat(getItemSet(context.getPrefixes(additionalNamespaceUri))).as(\"Prefix was removed from namespace URI\").containsExactly(\"prefix2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.SimpleNamespaceContextTests#getItemSet(Iterator<String>)",
    "entityType": "method",
    "code": "private Set<String> getItemSet(Iterator<String> iterator) {\r\n    Set<String> itemSet = new LinkedHashSet<>();\r\n    iterator.forEachRemaining(itemSet::add);\r\n    return itemSet;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventHandlerTests",
    "entityType": "class",
    "code": "@Override\r\nprotected AbstractStaxHandler createStaxHandler(Result result) throws XMLStreamException {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();\r\n    XMLEventWriter eventWriter = outputFactory.createXMLEventWriter(result);\r\n    return new StaxEventHandler(eventWriter);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventHandlerTests#createStaxHandler(Result)",
    "entityType": "method",
    "code": "@Override\r\nprotected AbstractStaxHandler createStaxHandler(Result result) throws XMLStreamException {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();\r\n    XMLEventWriter eventWriter = outputFactory.createXMLEventWriter(result);\r\n    return new StaxEventHandler(eventWriter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.FieldWriter",
    "entityType": "class",
    "code": "/**\r\n * Where the constants used in this FieldWriter must be stored.\r\n */\r\nprivate final SymbolTable symbolTable;\n// Note: fields are ordered as in the field_info structure, and those related to attributes are\r\n// ordered as in Section 4.7 of the JVMS.\r\n/**\r\n * The access_flags field of the field_info JVMS structure. This field can contain ASM specific\r\n * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the\r\n * ClassFile structure.\r\n */\r\nprivate final int accessFlags;\n/**\r\n * The name_index field of the field_info JVMS structure.\r\n */\r\nprivate final int nameIndex;\n/**\r\n * The descriptor_index field of the field_info JVMS structure.\r\n */\r\nprivate final int descriptorIndex;\n/**\r\n * The signature_index field of the Signature attribute of this field_info, or 0 if there is no\r\n * Signature attribute.\r\n */\r\nprivate int signatureIndex;\n/**\r\n * The constantvalue_index field of the ConstantValue attribute of this field_info, or 0 if there\r\n * is no ConstantValue attribute.\r\n */\r\nprivate int constantValueIndex;\n/**\r\n * The last runtime visible annotation of this field. The previous ones can be accessed with the\r\n * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleAnnotation;\n/**\r\n * The last runtime invisible annotation of this field. The previous ones can be accessed with the\r\n * {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleAnnotation;\n/**\r\n * The last runtime visible type annotation of this field. The previous ones can be accessed with\r\n * the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeVisibleTypeAnnotation;\n/**\r\n * The last runtime invisible type annotation of this field. The previous ones can be accessed\r\n * with the {@link AnnotationWriter#previousAnnotation} field. May be {@literal null}.\r\n */\r\nprivate AnnotationWriter lastRuntimeInvisibleTypeAnnotation;\n/**\r\n * The first non standard attribute of this field. The next ones can be accessed with the {@link\r\n * Attribute#nextAttribute} field. May be {@literal null}.\r\n *\r\n * <p><b>WARNING</b>: this list stores the attributes in the <i>reverse</i> order of their visit.\r\n * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link\r\n * #putFieldInfo} method writes the attributes in the order defined by this list, i.e. in the\r\n * reverse order specified by the user.\r\n */\r\nprivate Attribute firstAttribute;\n// -----------------------------------------------------------------------------------------------\r\n// Constructor\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new {@link FieldWriter}.\r\n *\r\n * @param symbolTable where the constants used in this FieldWriter must be stored.\r\n * @param access the field's access flags (see {@link Opcodes}).\r\n * @param name the field's name.\r\n * @param descriptor the field's descriptor (see {@link Type}).\r\n * @param signature the field's signature. May be {@literal null}.\r\n * @param constantValue the field's constant value. May be {@literal null}.\r\n */\r\nFieldWriter(final SymbolTable symbolTable, final int access, final String name, final String descriptor, final String signature, final Object constantValue) {\r\n    super(/* latest api = */\r\n    Opcodes.ASM9);\r\n    this.symbolTable = symbolTable;\r\n    this.accessFlags = access;\r\n    this.nameIndex = symbolTable.addConstantUtf8(name);\r\n    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);\r\n    if (signature != null) {\r\n        this.signatureIndex = symbolTable.addConstantUtf8(signature);\r\n    }\r\n    if (constantValue != null) {\r\n        this.constantValueIndex = symbolTable.addConstant(constantValue).index;\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Implementation of the FieldVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}\n@Override\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}\n@Override\r\npublic void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    attribute.nextAttribute = firstAttribute;\r\n    firstAttribute = attribute;\r\n}\n@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\r\n * names of the attributes of this field in the constant pool.\r\n *\r\n * @return the size in bytes of the field_info JVMS structure.\r\n */\r\nint computeFieldInfoSize() {\r\n    // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.\r\n    int size = 8;\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (constantValueIndex != 0) {\r\n        // ConstantValue attributes always use 8 bytes.\r\n        symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);\r\n        size += 8;\r\n    }\r\n    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}\n/**\r\n * Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\r\n * ByteVector.\r\n *\r\n * @param output where the field_info structure must be put.\r\n */\r\nvoid putFieldInfo(final ByteVector output) {\r\n    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\r\n    // Put the access_flags, name_index and descriptor_index fields.\r\n    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\r\n    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\r\n    // Compute and put the attributes_count field.\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributesCount = 0;\r\n    if (constantValueIndex != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\r\n        ++attributesCount;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n    }\r\n    output.putShort(attributesCount);\r\n    // Put the field_info attributes.\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (constantValueIndex != 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)).putInt(2).putShort(constantValueIndex);\r\n    }\r\n    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}\n/**\r\n * Collects the attributes of this field into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n}",
    "comment": "\n * A {@link FieldVisitor} that generates a corresponding 'field_info' structure, as defined in the\n * Java Virtual Machine Specification (JVMS).\n *\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.5\">JVMS\n *     4.5</a>\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Implementation of the FieldVisitor abstract class\r\n// -----------------------------------------------------------------------------------------------\r\n@Override\r\npublic AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeVisibleAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleAnnotation = AnnotationWriter.create(symbolTable, descriptor, lastRuntimeInvisibleAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\r\n    if (visible) {\r\n        return lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeVisibleTypeAnnotation);\r\n    } else {\r\n        return lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(symbolTable, typeRef, typePath, descriptor, lastRuntimeInvisibleTypeAnnotation);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#visitAttribute(Attribute)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitAttribute(final Attribute attribute) {\r\n    // Store the attributes in the <i>reverse</i> order of their visit by this method.\r\n    attribute.nextAttribute = firstAttribute;\r\n    firstAttribute = attribute;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    // Nothing to do.\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#computeFieldInfoSize()",
    "entityType": "method",
    "code": "// -----------------------------------------------------------------------------------------------\r\n// Utility methods\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\r\n * names of the attributes of this field in the constant pool.\r\n *\r\n * @return the size in bytes of the field_info JVMS structure.\r\n */\r\nint computeFieldInfoSize() {\r\n    // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.\r\n    int size = 8;\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (constantValueIndex != 0) {\r\n        // ConstantValue attributes always use 8 bytes.\r\n        symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);\r\n        size += 8;\r\n    }\r\n    size += Attribute.computeAttributesSize(symbolTable, accessFlags, signatureIndex);\r\n    size += AnnotationWriter.computeAnnotationsSize(lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation);\r\n    if (firstAttribute != null) {\r\n        size += firstAttribute.computeAttributesSize(symbolTable);\r\n    }\r\n    return size;\r\n}",
    "comment": "\n   * Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\n   * names of the attributes of this field in the constant pool.\n   *\n   * @return the size in bytes of the field_info JVMS structure.\n   "
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#putFieldInfo(ByteVector)",
    "entityType": "method",
    "code": "/**\r\n * Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\r\n * ByteVector.\r\n *\r\n * @param output where the field_info structure must be put.\r\n */\r\nvoid putFieldInfo(final ByteVector output) {\r\n    boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5;\r\n    // Put the access_flags, name_index and descriptor_index fields.\r\n    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;\r\n    output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\r\n    // Compute and put the attributes_count field.\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    int attributesCount = 0;\r\n    if (constantValueIndex != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) {\r\n        ++attributesCount;\r\n    }\r\n    if (signatureIndex != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeVisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (lastRuntimeInvisibleTypeAnnotation != null) {\r\n        ++attributesCount;\r\n    }\r\n    if (firstAttribute != null) {\r\n        attributesCount += firstAttribute.getAttributeCount();\r\n    }\r\n    output.putShort(attributesCount);\r\n    // Put the field_info attributes.\r\n    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\r\n    if (constantValueIndex != 0) {\r\n        output.putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)).putInt(2).putShort(constantValueIndex);\r\n    }\r\n    Attribute.putAttributes(symbolTable, accessFlags, signatureIndex, output);\r\n    AnnotationWriter.putAnnotations(symbolTable, lastRuntimeVisibleAnnotation, lastRuntimeInvisibleAnnotation, lastRuntimeVisibleTypeAnnotation, lastRuntimeInvisibleTypeAnnotation, output);\r\n    if (firstAttribute != null) {\r\n        firstAttribute.putAttributes(symbolTable, output);\r\n    }\r\n}",
    "comment": "\n   * Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\n   * ByteVector.\n   *\n   * @param output where the field_info structure must be put.\n   "
  },
  {
    "entityId": "org.springframework.asm.FieldWriter#collectAttributePrototypes(Attribute.Set)",
    "entityType": "method",
    "code": "/**\r\n * Collects the attributes of this field into the given set of attribute prototypes.\r\n *\r\n * @param attributePrototypes a set of attribute prototypes.\r\n */\r\nfinal void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n    attributePrototypes.addAttributes(firstAttribute);\r\n}",
    "comment": "\n   * Collects the attributes of this field into the given set of attribute prototypes.\n   *\n   * @param attributePrototypes a set of attribute prototypes.\n   "
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReaderTests",
    "entityType": "class",
    "code": "public static final String CONTENT = \"<root xmlns='http://springframework.org/spring-ws'><child/></root>\";\n@Override\r\nprotected AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException {\r\n    return new StaxEventXMLReader(inputFactory.createXMLEventReader(inputStream));\r\n}\n@Test\r\nvoid partial() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(CONTENT));\r\n    // skip to root\r\n    eventReader.nextTag();\r\n    StaxEventXMLReader xmlReader = new StaxEventXMLReader(eventReader);\r\n    ContentHandler contentHandler = mock();\r\n    xmlReader.setContentHandler(contentHandler);\r\n    xmlReader.parse(new InputSource());\r\n    verify(contentHandler).startDocument();\r\n    verify(contentHandler).startElement(eq(\"http://springframework.org/spring-ws\"), eq(\"child\"), eq(\"child\"), any(Attributes.class));\r\n    verify(contentHandler).endElement(\"http://springframework.org/spring-ws\", \"child\", \"child\");\r\n    verify(contentHandler).endDocument();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReaderTests#createStaxXmlReader(InputStream)",
    "entityType": "method",
    "code": "@Override\r\nprotected AbstractStaxXMLReader createStaxXmlReader(InputStream inputStream) throws XMLStreamException {\r\n    return new StaxEventXMLReader(inputFactory.createXMLEventReader(inputStream));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxEventXMLReaderTests#partial()",
    "entityType": "method",
    "code": "@Test\r\nvoid partial() throws Exception {\r\n    XMLInputFactory inputFactory = XMLInputFactory.newInstance();\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(CONTENT));\r\n    // skip to root\r\n    eventReader.nextTag();\r\n    StaxEventXMLReader xmlReader = new StaxEventXMLReader(eventReader);\r\n    ContentHandler contentHandler = mock();\r\n    xmlReader.setContentHandler(contentHandler);\r\n    xmlReader.parse(new InputSource());\r\n    verify(contentHandler).startDocument();\r\n    verify(contentHandler).startElement(eq(\"http://springframework.org/spring-ws\"), eq(\"child\"), eq(\"child\"), any(Attributes.class));\r\n    verify(contentHandler).endElement(\"http://springframework.org/spring-ws\", \"child\", \"child\");\r\n    verify(contentHandler).endDocument();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxResultTests",
    "entityType": "class",
    "code": "private static final String XML = \"<root xmlns='namespace'><child/></root>\";\nprivate Transformer transformer;\nprivate XMLOutputFactory inputFactory;\n@BeforeEach\r\nvoid setUp() throws Exception {\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    transformer = transformerFactory.newTransformer();\r\n    inputFactory = XMLOutputFactory.newInstance();\r\n}\n@Test\r\nvoid streamWriterSource() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    XMLStreamWriter streamWriter = inputFactory.createXMLStreamWriter(stringWriter);\r\n    Reader reader = new StringReader(XML);\r\n    Source source = new StreamSource(reader);\r\n    StaxResult result = new StaxResult(streamWriter);\r\n    assertThat(result.getXMLStreamWriter()).as(\"Invalid streamWriter returned\").isEqualTo(streamWriter);\r\n    assertThat(result.getXMLEventWriter()).as(\"EventWriter returned\").isNull();\r\n    transformer.transform(source, result);\r\n    assertThat(XmlContent.from(stringWriter)).as(\"Invalid result\").isSimilarTo(XML);\r\n}\n@Test\r\nvoid eventWriterSource() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    XMLEventWriter eventWriter = inputFactory.createXMLEventWriter(stringWriter);\r\n    Reader reader = new StringReader(XML);\r\n    Source source = new StreamSource(reader);\r\n    StaxResult result = new StaxResult(eventWriter);\r\n    assertThat(result.getXMLEventWriter()).as(\"Invalid eventWriter returned\").isEqualTo(eventWriter);\r\n    assertThat(result.getXMLStreamWriter()).as(\"StreamWriter returned\").isNull();\r\n    transformer.transform(source, result);\r\n    assertThat(XmlContent.from(stringWriter)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxResultTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() throws Exception {\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    transformer = transformerFactory.newTransformer();\r\n    inputFactory = XMLOutputFactory.newInstance();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxResultTests#streamWriterSource()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamWriterSource() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    XMLStreamWriter streamWriter = inputFactory.createXMLStreamWriter(stringWriter);\r\n    Reader reader = new StringReader(XML);\r\n    Source source = new StreamSource(reader);\r\n    StaxResult result = new StaxResult(streamWriter);\r\n    assertThat(result.getXMLStreamWriter()).as(\"Invalid streamWriter returned\").isEqualTo(streamWriter);\r\n    assertThat(result.getXMLEventWriter()).as(\"EventWriter returned\").isNull();\r\n    transformer.transform(source, result);\r\n    assertThat(XmlContent.from(stringWriter)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxResultTests#eventWriterSource()",
    "entityType": "method",
    "code": "@Test\r\nvoid eventWriterSource() throws Exception {\r\n    StringWriter stringWriter = new StringWriter();\r\n    XMLEventWriter eventWriter = inputFactory.createXMLEventWriter(stringWriter);\r\n    Reader reader = new StringReader(XML);\r\n    Source source = new StreamSource(reader);\r\n    StaxResult result = new StaxResult(eventWriter);\r\n    assertThat(result.getXMLEventWriter()).as(\"Invalid eventWriter returned\").isEqualTo(eventWriter);\r\n    assertThat(result.getXMLStreamWriter()).as(\"StreamWriter returned\").isNull();\r\n    transformer.transform(source, result);\r\n    assertThat(XmlContent.from(stringWriter)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxSourceTests",
    "entityType": "class",
    "code": "private static final String XML = \"<root xmlns='namespace'><child/></root>\";\nprivate Transformer transformer;\nprivate XMLInputFactory inputFactory;\nprivate DocumentBuilder documentBuilder;\n@BeforeEach\r\nvoid setUp() throws Exception {\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    transformer = transformerFactory.newTransformer();\r\n    inputFactory = XMLInputFactory.newInstance();\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n}\n@Test\r\nvoid streamReaderSourceToStreamResult() throws Exception {\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(streamReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"Invalid streamReader returned\").isEqualTo(streamReader);\r\n    assertThat(source.getXMLEventReader()).as(\"EventReader returned\").isNull();\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    assertThat(XmlContent.from(writer)).as(\"Invalid result\").isSimilarTo(XML);\r\n}\n@Test\r\nvoid streamReaderSourceToDOMResult() throws Exception {\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(streamReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"Invalid streamReader returned\").isEqualTo(streamReader);\r\n    assertThat(source.getXMLEventReader()).as(\"EventReader returned\").isNull();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    transformer.transform(source, new DOMResult(result));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}\n@Test\r\nvoid eventReaderSourceToStreamResult() throws Exception {\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(eventReader);\r\n    assertThat(source.getXMLEventReader()).as(\"Invalid eventReader returned\").isEqualTo(eventReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"StreamReader returned\").isNull();\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    assertThat(XmlContent.from(writer)).as(\"Invalid result\").isSimilarTo(XML);\r\n}\n@Test\r\nvoid eventReaderSourceToDOMResult() throws Exception {\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(eventReader);\r\n    assertThat(source.getXMLEventReader()).as(\"Invalid eventReader returned\").isEqualTo(eventReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"StreamReader returned\").isNull();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    transformer.transform(source, new DOMResult(result));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxSourceTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() throws Exception {\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    transformer = transformerFactory.newTransformer();\r\n    inputFactory = XMLInputFactory.newInstance();\r\n    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\r\n    documentBuilderFactory.setNamespaceAware(true);\r\n    documentBuilder = documentBuilderFactory.newDocumentBuilder();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToStreamResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamReaderSourceToStreamResult() throws Exception {\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(streamReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"Invalid streamReader returned\").isEqualTo(streamReader);\r\n    assertThat(source.getXMLEventReader()).as(\"EventReader returned\").isNull();\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    assertThat(XmlContent.from(writer)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxSourceTests#streamReaderSourceToDOMResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamReaderSourceToDOMResult() throws Exception {\r\n    XMLStreamReader streamReader = inputFactory.createXMLStreamReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(streamReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"Invalid streamReader returned\").isEqualTo(streamReader);\r\n    assertThat(source.getXMLEventReader()).as(\"EventReader returned\").isNull();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    transformer.transform(source, new DOMResult(result));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToStreamResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid eventReaderSourceToStreamResult() throws Exception {\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(eventReader);\r\n    assertThat(source.getXMLEventReader()).as(\"Invalid eventReader returned\").isEqualTo(eventReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"StreamReader returned\").isNull();\r\n    StringWriter writer = new StringWriter();\r\n    transformer.transform(source, new StreamResult(writer));\r\n    assertThat(XmlContent.from(writer)).as(\"Invalid result\").isSimilarTo(XML);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxSourceTests#eventReaderSourceToDOMResult()",
    "entityType": "method",
    "code": "@Test\r\nvoid eventReaderSourceToDOMResult() throws Exception {\r\n    XMLEventReader eventReader = inputFactory.createXMLEventReader(new StringReader(XML));\r\n    StaxSource source = new StaxSource(eventReader);\r\n    assertThat(source.getXMLEventReader()).as(\"Invalid eventReader returned\").isEqualTo(eventReader);\r\n    assertThat(source.getXMLStreamReader()).as(\"StreamReader returned\").isNull();\r\n    Document expected = documentBuilder.parse(new InputSource(new StringReader(XML)));\r\n    Document result = documentBuilder.newDocument();\r\n    transformer.transform(source, new DOMResult(result));\r\n    assertThat(XmlContent.of(result)).as(\"Invalid result\").isSimilarTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandlerTests",
    "entityType": "class",
    "code": "@Override\r\nprotected AbstractStaxHandler createStaxHandler(Result result) throws XMLStreamException {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();\r\n    XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(result);\r\n    return new StaxStreamHandler(streamWriter);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.xml.StaxStreamHandlerTests#createStaxHandler(Result)",
    "entityType": "method",
    "code": "@Override\r\nprotected AbstractStaxHandler createStaxHandler(Result result) throws XMLStreamException {\r\n    XMLOutputFactory outputFactory = XMLOutputFactory.newFactory();\r\n    XMLStreamWriter streamWriter = outputFactory.createXMLStreamWriter(result);\r\n    return new StaxStreamHandler(streamWriter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.asm.Frame",
    "entityType": "class",
    "code": "// Constants used in the StackMapTable attribute.\r\n// See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.\r\nstatic final int SAME_FRAME = 0;\nstatic final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\nstatic final int RESERVED = 128;\nstatic final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\nstatic final int CHOP_FRAME = 248;\nstatic final int SAME_FRAME_EXTENDED = 251;\nstatic final int APPEND_FRAME = 252;\nstatic final int FULL_FRAME = 255;\nstatic final int ITEM_TOP = 0;\nstatic final int ITEM_INTEGER = 1;\nstatic final int ITEM_FLOAT = 2;\nstatic final int ITEM_DOUBLE = 3;\nstatic final int ITEM_LONG = 4;\nstatic final int ITEM_NULL = 5;\nstatic final int ITEM_UNINITIALIZED_THIS = 6;\nstatic final int ITEM_OBJECT = 7;\nstatic final int ITEM_UNINITIALIZED = 8;\n// Additional, ASM specific constants used in abstract types below.\r\nprivate static final int ITEM_ASM_BOOLEAN = 9;\nprivate static final int ITEM_ASM_BYTE = 10;\nprivate static final int ITEM_ASM_CHAR = 11;\nprivate static final int ITEM_ASM_SHORT = 12;\n// The size and offset in bits of each field of an abstract type.\r\nprivate static final int DIM_SIZE = 6;\nprivate static final int KIND_SIZE = 4;\nprivate static final int FLAGS_SIZE = 2;\nprivate static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;\nprivate static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;\nprivate static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;\nprivate static final int FLAGS_SHIFT = VALUE_SIZE;\n// Bitmasks to get each field of an abstract type.\r\nprivate static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;\nprivate static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;\nprivate static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;\n// Constants to manipulate the DIM field of an abstract type.\r\n/**\r\n * The constant to be added to an abstract type to get one with one more array dimension.\r\n */\r\nprivate static final int ARRAY_OF = +1 << DIM_SHIFT;\n/**\r\n * The constant to be added to an abstract type to get one with one less array dimension.\r\n */\r\nprivate static final int ELEMENT_OF = -1 << DIM_SHIFT;\n// Possible values for the KIND field of an abstract type.\r\nprivate static final int CONSTANT_KIND = 1 << KIND_SHIFT;\nprivate static final int REFERENCE_KIND = 2 << KIND_SHIFT;\nprivate static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;\nprivate static final int FORWARD_UNINITIALIZED_KIND = 4 << KIND_SHIFT;\nprivate static final int LOCAL_KIND = 5 << KIND_SHIFT;\nprivate static final int STACK_KIND = 6 << KIND_SHIFT;\n// Possible flags for the FLAGS field of an abstract type.\r\n/**\r\n * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,\r\n * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been\r\n * partially overridden with an xSTORE instruction).\r\n */\r\nprivate static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;\n// Useful predefined abstract types (all the possible CONSTANT_KIND types).\r\nprivate static final int TOP = CONSTANT_KIND | ITEM_TOP;\nprivate static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;\nprivate static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;\nprivate static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;\nprivate static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;\nprivate static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;\nprivate static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;\nprivate static final int LONG = CONSTANT_KIND | ITEM_LONG;\nprivate static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;\nprivate static final int NULL = CONSTANT_KIND | ITEM_NULL;\nprivate static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;\n// -----------------------------------------------------------------------------------------------\r\n// Instance fields\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * The basic block to which these input and output stack map frames correspond.\r\n */\r\nLabel owner;\n/**\r\n * The input stack map frame locals. This is an array of abstract types.\r\n */\r\nprivate int[] inputLocals;\n/**\r\n * The input stack map frame stack. This is an array of abstract types.\r\n */\r\nprivate int[] inputStack;\n/**\r\n * The output stack map frame locals. This is an array of abstract types.\r\n */\r\nprivate int[] outputLocals;\n/**\r\n * The output stack map frame stack. This is an array of abstract types.\r\n */\r\nprivate int[] outputStack;\n/**\r\n * The start of the output stack, relatively to the input stack. This offset is always negative or\r\n * null. A null offset means that the output stack must be appended to the input stack. A -n\r\n * offset means that the first n output stack elements must replace the top n input stack\r\n * elements, and that the other elements must be appended to the input stack.\r\n */\r\nprivate short outputStackStart;\n/**\r\n * The index of the top stack element in {@link #outputStack}.\r\n */\r\nprivate short outputStackTop;\n/**\r\n * The number of types that are initialized in the basic block. See {@link #initializations}.\r\n */\r\nprivate int initializationCount;\n/**\r\n * The abstract types that are initialized in the basic block. A constructor invocation on an\r\n * UNINITIALIZED, FORWARD_UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every\r\n * occurrence</i> of this type in the local variables and in the operand stack. This cannot be\r\n * done during the first step of the algorithm since, during this step, the local variables and\r\n * the operand stack types are still abstract. It is therefore necessary to store the abstract\r\n * types of the constructors which are invoked in the basic block, in order to do this replacement\r\n * during the second step of the algorithm, where the frames are fully computed. Note that this\r\n * array can contain abstract types that are relative to the input locals or to the input stack.\r\n */\r\nprivate int[] initializations;\n// -----------------------------------------------------------------------------------------------\r\n// Constructor\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Constructs a new Frame.\r\n *\r\n * @param owner the basic block to which these input and output stack map frames correspond.\r\n */\r\nFrame(final Label owner) {\r\n    this.owner = owner;\r\n}\n/**\r\n * Sets this frame to the value of the given frame.\r\n *\r\n * <p>WARNING: after this method is called the two frames share the same data structures. It is\r\n * recommended to discard the given frame to avoid unexpected side effects.\r\n *\r\n * @param frame The new frame value.\r\n */\r\nfinal void copyFrom(final Frame frame) {\r\n    inputLocals = frame.inputLocals;\r\n    inputStack = frame.inputStack;\r\n    outputStackStart = 0;\r\n    outputLocals = frame.outputLocals;\r\n    outputStack = frame.outputStack;\r\n    outputStackTop = frame.outputStackTop;\r\n    initializationCount = frame.initializationCount;\r\n    initializations = frame.initializations;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Static methods to get abstract types from other type formats\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the abstract type corresponding to the given public API frame element type.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param type a frame element type described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\r\n *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\r\n *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\r\n *     a NEW instruction (for uninitialized types).\r\n * @return the abstract type corresponding to the given frame element type.\r\n */\r\nstatic int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {\r\n    if (type instanceof Integer) {\r\n        return CONSTANT_KIND | ((Integer) type).intValue();\r\n    } else if (type instanceof String) {\r\n        String descriptor = Type.getObjectType((String) type).getDescriptor();\r\n        return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\r\n    } else {\r\n        Label label = (Label) type;\r\n        if ((label.flags & Label.FLAG_RESOLVED) != 0) {\r\n            return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", label.bytecodeOffset);\r\n        } else {\r\n            return FORWARD_UNINITIALIZED_KIND | symbolTable.addForwardUninitializedType(\"\", label);\r\n        }\r\n    }\r\n}\n/**\r\n * Returns the abstract type corresponding to the internal name of a class.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param internalName the internal name of a class. This must <i>not</i> be an array type\r\n *     descriptor.\r\n * @return the abstract type value corresponding to the given internal name.\r\n */\r\nstatic int getAbstractTypeFromInternalName(final SymbolTable symbolTable, final String internalName) {\r\n    return REFERENCE_KIND | symbolTable.addType(internalName);\r\n}\n/**\r\n * Returns the abstract type corresponding to the given type descriptor.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param buffer a string ending with a type descriptor.\r\n * @param offset the start offset of the type descriptor in buffer.\r\n * @return the abstract type corresponding to the given type descriptor.\r\n */\r\nprivate static int getAbstractTypeFromDescriptor(final SymbolTable symbolTable, final String buffer, final int offset) {\r\n    String internalName;\r\n    switch(buffer.charAt(offset)) {\r\n        case 'V':\r\n            return 0;\r\n        case 'Z':\r\n        case 'C':\r\n        case 'B':\r\n        case 'S':\r\n        case 'I':\r\n            return INTEGER;\r\n        case 'F':\r\n            return FLOAT;\r\n        case 'J':\r\n            return LONG;\r\n        case 'D':\r\n            return DOUBLE;\r\n        case 'L':\r\n            internalName = buffer.substring(offset + 1, buffer.length() - 1);\r\n            return REFERENCE_KIND | symbolTable.addType(internalName);\r\n        case '[':\r\n            int elementDescriptorOffset = offset + 1;\r\n            while (buffer.charAt(elementDescriptorOffset) == '[') {\r\n                ++elementDescriptorOffset;\r\n            }\r\n            int typeValue;\r\n            switch(buffer.charAt(elementDescriptorOffset)) {\r\n                case 'Z':\r\n                    typeValue = BOOLEAN;\r\n                    break;\r\n                case 'C':\r\n                    typeValue = CHAR;\r\n                    break;\r\n                case 'B':\r\n                    typeValue = BYTE;\r\n                    break;\r\n                case 'S':\r\n                    typeValue = SHORT;\r\n                    break;\r\n                case 'I':\r\n                    typeValue = INTEGER;\r\n                    break;\r\n                case 'F':\r\n                    typeValue = FLOAT;\r\n                    break;\r\n                case 'J':\r\n                    typeValue = LONG;\r\n                    break;\r\n                case 'D':\r\n                    typeValue = DOUBLE;\r\n                    break;\r\n                case 'L':\r\n                    internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);\r\n                    typeValue = REFERENCE_KIND | symbolTable.addType(internalName);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Invalid descriptor fragment: \" + buffer.substring(elementDescriptorOffset));\r\n            }\r\n            return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + buffer.substring(offset));\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods related to the input frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Sets the input frame from the given method description. This method is used to initialize the\r\n * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable\r\n * attribute).\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param access the method's access flags.\r\n * @param descriptor the method descriptor.\r\n * @param maxLocals the maximum number of local variables of the method.\r\n */\r\nfinal void setInputFrameFromDescriptor(final SymbolTable symbolTable, final int access, final String descriptor, final int maxLocals) {\r\n    inputLocals = new int[maxLocals];\r\n    inputStack = new int[0];\r\n    int inputLocalIndex = 0;\r\n    if ((access & Opcodes.ACC_STATIC) == 0) {\r\n        if ((access & Constants.ACC_CONSTRUCTOR) == 0) {\r\n            inputLocals[inputLocalIndex++] = REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\r\n        } else {\r\n            inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;\r\n        }\r\n    }\r\n    for (Type argumentType : Type.getArgumentTypes(descriptor)) {\r\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);\r\n        inputLocals[inputLocalIndex++] = abstractType;\r\n        if (abstractType == LONG || abstractType == DOUBLE) {\r\n            inputLocals[inputLocalIndex++] = TOP;\r\n        }\r\n    }\r\n    while (inputLocalIndex < maxLocals) {\r\n        inputLocals[inputLocalIndex++] = TOP;\r\n    }\r\n}\n/**\r\n * Sets the input frame from the given public API frame description.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param numLocal the number of local variables.\r\n * @param local the local variable types, described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}.\r\n * @param numStack the number of operand stack elements.\r\n * @param stack the operand stack types, described using the same format as in {@link\r\n *     MethodVisitor#visitFrame}.\r\n */\r\nfinal void setInputFrameFromApiFormat(final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n    int inputLocalIndex = 0;\r\n    for (int i = 0; i < numLocal; ++i) {\r\n        inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);\r\n        if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {\r\n            inputLocals[inputLocalIndex++] = TOP;\r\n        }\r\n    }\r\n    while (inputLocalIndex < inputLocals.length) {\r\n        inputLocals[inputLocalIndex++] = TOP;\r\n    }\r\n    int numStackTop = 0;\r\n    for (int i = 0; i < numStack; ++i) {\r\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n            ++numStackTop;\r\n        }\r\n    }\r\n    inputStack = new int[numStack + numStackTop];\r\n    int inputStackIndex = 0;\r\n    for (int i = 0; i < numStack; ++i) {\r\n        inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);\r\n        if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {\r\n            inputStack[inputStackIndex++] = TOP;\r\n        }\r\n    }\r\n    outputStackTop = 0;\r\n    initializationCount = 0;\r\n}\nfinal int getInputStackSize() {\r\n    return inputStack.length;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods related to the output frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Returns the abstract type stored at the given local variable index in the output frame.\r\n *\r\n * @param localIndex the index of the local variable whose value must be returned.\r\n * @return the abstract type stored at the given local variable index in the output frame.\r\n */\r\nprivate int getLocal(final int localIndex) {\r\n    if (outputLocals == null || localIndex >= outputLocals.length) {\r\n        // If this local has never been assigned in this basic block, it is still equal to its value\r\n        // in the input frame.\r\n        return LOCAL_KIND | localIndex;\r\n    } else {\r\n        int abstractType = outputLocals[localIndex];\r\n        if (abstractType == 0) {\r\n            // If this local has never been assigned in this basic block, so it is still equal to its\r\n            // value in the input frame.\r\n            abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\r\n        }\r\n        return abstractType;\r\n    }\r\n}\n/**\r\n * Replaces the abstract type stored at the given local variable index in the output frame.\r\n *\r\n * @param localIndex the index of the output frame local variable that must be set.\r\n * @param abstractType the value that must be set.\r\n */\r\nprivate void setLocal(final int localIndex, final int abstractType) {\r\n    // Create and/or resize the output local variables array if necessary.\r\n    if (outputLocals == null) {\r\n        outputLocals = new int[10];\r\n    }\r\n    int outputLocalsLength = outputLocals.length;\r\n    if (localIndex >= outputLocalsLength) {\r\n        int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\r\n        System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\r\n        outputLocals = newOutputLocals;\r\n    }\r\n    // Set the local variable.\r\n    outputLocals[localIndex] = abstractType;\r\n}\n/**\r\n * Pushes the given abstract type on the output frame stack.\r\n *\r\n * @param abstractType an abstract type.\r\n */\r\nprivate void push(final int abstractType) {\r\n    // Create and/or resize the output stack array if necessary.\r\n    if (outputStack == null) {\r\n        outputStack = new int[10];\r\n    }\r\n    int outputStackLength = outputStack.length;\r\n    if (outputStackTop >= outputStackLength) {\r\n        int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\r\n        System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\r\n        outputStack = newOutputStack;\r\n    }\r\n    // Pushes the abstract type on the output stack.\r\n    outputStack[outputStackTop++] = abstractType;\r\n    // Updates the maximum size reached by the output stack, if needed (note that this size is\r\n    // relative to the input stack size, which is not known yet).\r\n    short outputStackSize = (short) (outputStackStart + outputStackTop);\r\n    if (outputStackSize > owner.outputStackMax) {\r\n        owner.outputStackMax = outputStackSize;\r\n    }\r\n}\n/**\r\n * Pushes the abstract type corresponding to the given descriptor on the output frame stack.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param descriptor a type or method descriptor (in which case its return type is pushed).\r\n */\r\nprivate void push(final SymbolTable symbolTable, final String descriptor) {\r\n    int typeDescriptorOffset = descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;\r\n    int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\r\n    if (abstractType != 0) {\r\n        push(abstractType);\r\n        if (abstractType == LONG || abstractType == DOUBLE) {\r\n            push(TOP);\r\n        }\r\n    }\r\n}\n/**\r\n * Pops an abstract type from the output frame stack and returns its value.\r\n *\r\n * @return the abstract type that has been popped from the output frame stack.\r\n */\r\nprivate int pop() {\r\n    if (outputStackTop > 0) {\r\n        return outputStack[--outputStackTop];\r\n    } else {\r\n        // If the output frame stack is empty, pop from the input stack.\r\n        return STACK_KIND | -(--outputStackStart);\r\n    }\r\n}\n/**\r\n * Pops the given number of abstract types from the output frame stack.\r\n *\r\n * @param elements the number of abstract types that must be popped.\r\n */\r\nprivate void pop(final int elements) {\r\n    if (outputStackTop >= elements) {\r\n        outputStackTop -= elements;\r\n    } else {\r\n        // If the number of elements to be popped is greater than the number of elements in the output\r\n        // stack, clear it, and pop the remaining elements from the input stack.\r\n        outputStackStart -= elements - outputStackTop;\r\n        outputStackTop = 0;\r\n    }\r\n}\n/**\r\n * Pops as many abstract types from the output frame stack as described by the given descriptor.\r\n *\r\n * @param descriptor a type or method descriptor (in which case its argument types are popped).\r\n */\r\nprivate void pop(final String descriptor) {\r\n    char firstDescriptorChar = descriptor.charAt(0);\r\n    if (firstDescriptorChar == '(') {\r\n        pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\r\n    } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\r\n        pop(2);\r\n    } else {\r\n        pop(1);\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Methods to handle uninitialized types\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Adds an abstract type to the list of types on which a constructor is invoked in the basic\r\n * block.\r\n *\r\n * @param abstractType an abstract type on a which a constructor is invoked.\r\n */\r\nprivate void addInitializedType(final int abstractType) {\r\n    // Create and/or resize the initializations array if necessary.\r\n    if (initializations == null) {\r\n        initializations = new int[2];\r\n    }\r\n    int initializationsLength = initializations.length;\r\n    if (initializationCount >= initializationsLength) {\r\n        int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\r\n        System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\r\n        initializations = newInitializations;\r\n    }\r\n    // Store the abstract type.\r\n    initializations[initializationCount++] = abstractType;\r\n}\n/**\r\n * Returns the \"initialized\" abstract type corresponding to the given abstract type.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param abstractType an abstract type.\r\n * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is\r\n *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\r\n *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\r\n *     abstractType.\r\n */\r\nprivate int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\r\n    if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {\r\n        for (int i = 0; i < initializationCount; ++i) {\r\n            int initializedType = initializations[i];\r\n            int dim = initializedType & DIM_MASK;\r\n            int kind = initializedType & KIND_MASK;\r\n            int value = initializedType & VALUE_MASK;\r\n            if (kind == LOCAL_KIND) {\r\n                initializedType = dim + inputLocals[value];\r\n            } else if (kind == STACK_KIND) {\r\n                initializedType = dim + inputStack[inputStack.length - value];\r\n            }\r\n            if (abstractType == initializedType) {\r\n                if (abstractType == UNINITIALIZED_THIS) {\r\n                    return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());\r\n                } else {\r\n                    return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return abstractType;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Main method, to simulate the execution of each instruction on the output frame\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Simulates the action of the given instruction on the output stack frame.\r\n *\r\n * @param opcode the opcode of the instruction.\r\n * @param arg the numeric operand of the instruction, if any.\r\n * @param argSymbol the Symbol operand of the instruction, if any.\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n */\r\nvoid execute(final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {\r\n    // Abstract types popped from the stack or read from local variables.\r\n    int abstractType1;\r\n    int abstractType2;\r\n    int abstractType3;\r\n    int abstractType4;\r\n    switch(opcode) {\r\n        case Opcodes.NOP:\r\n        case Opcodes.INEG:\r\n        case Opcodes.LNEG:\r\n        case Opcodes.FNEG:\r\n        case Opcodes.DNEG:\r\n        case Opcodes.I2B:\r\n        case Opcodes.I2C:\r\n        case Opcodes.I2S:\r\n        case Opcodes.GOTO:\r\n        case Opcodes.RETURN:\r\n            break;\r\n        case Opcodes.ACONST_NULL:\r\n            push(NULL);\r\n            break;\r\n        case Opcodes.ICONST_M1:\r\n        case Opcodes.ICONST_0:\r\n        case Opcodes.ICONST_1:\r\n        case Opcodes.ICONST_2:\r\n        case Opcodes.ICONST_3:\r\n        case Opcodes.ICONST_4:\r\n        case Opcodes.ICONST_5:\r\n        case Opcodes.BIPUSH:\r\n        case Opcodes.SIPUSH:\r\n        case Opcodes.ILOAD:\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCONST_0:\r\n        case Opcodes.LCONST_1:\r\n        case Opcodes.LLOAD:\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FCONST_0:\r\n        case Opcodes.FCONST_1:\r\n        case Opcodes.FCONST_2:\r\n        case Opcodes.FLOAD:\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DCONST_0:\r\n        case Opcodes.DCONST_1:\r\n        case Opcodes.DLOAD:\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LDC:\r\n            switch(argSymbol.tag) {\r\n                case Symbol.CONSTANT_INTEGER_TAG:\r\n                    push(INTEGER);\r\n                    break;\r\n                case Symbol.CONSTANT_LONG_TAG:\r\n                    push(LONG);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_FLOAT_TAG:\r\n                    push(FLOAT);\r\n                    break;\r\n                case Symbol.CONSTANT_DOUBLE_TAG:\r\n                    push(DOUBLE);\r\n                    push(TOP);\r\n                    break;\r\n                case Symbol.CONSTANT_CLASS_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/Class\"));\r\n                    break;\r\n                case Symbol.CONSTANT_STRING_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/String\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_TYPE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodType\"));\r\n                    break;\r\n                case Symbol.CONSTANT_METHOD_HANDLE_TAG:\r\n                    push(REFERENCE_KIND | symbolTable.addType(\"java/lang/invoke/MethodHandle\"));\r\n                    break;\r\n                case Symbol.CONSTANT_DYNAMIC_TAG:\r\n                    push(symbolTable, argSymbol.value);\r\n                    break;\r\n                default:\r\n                    throw new AssertionError();\r\n            }\r\n            break;\r\n        case Opcodes.ALOAD:\r\n            push(getLocal(arg));\r\n            break;\r\n        case Opcodes.LALOAD:\r\n        case Opcodes.D2L:\r\n            pop(2);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.DALOAD:\r\n        case Opcodes.L2D:\r\n            pop(2);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.AALOAD:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);\r\n            break;\r\n        case Opcodes.ISTORE:\r\n        case Opcodes.FSTORE:\r\n        case Opcodes.ASTORE:\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    // The type of the previous local variable is not known yet, but if it later appears\r\n                    // to be LONG or DOUBLE, we should then use TOP instead.\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.LSTORE:\r\n        case Opcodes.DSTORE:\r\n            pop(1);\r\n            abstractType1 = pop();\r\n            setLocal(arg, abstractType1);\r\n            setLocal(arg + 1, TOP);\r\n            if (arg > 0) {\r\n                int previousLocalType = getLocal(arg - 1);\r\n                if (previousLocalType == LONG || previousLocalType == DOUBLE) {\r\n                    setLocal(arg - 1, TOP);\r\n                } else if ((previousLocalType & KIND_MASK) == LOCAL_KIND || (previousLocalType & KIND_MASK) == STACK_KIND) {\r\n                    // The type of the previous local variable is not known yet, but if it later appears\r\n                    // to be LONG or DOUBLE, we should then use TOP instead.\r\n                    setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.IASTORE:\r\n        case Opcodes.BASTORE:\r\n        case Opcodes.CASTORE:\r\n        case Opcodes.SASTORE:\r\n        case Opcodes.FASTORE:\r\n        case Opcodes.AASTORE:\r\n            pop(3);\r\n            break;\r\n        case Opcodes.LASTORE:\r\n        case Opcodes.DASTORE:\r\n            pop(4);\r\n            break;\r\n        case Opcodes.POP:\r\n        case Opcodes.IFEQ:\r\n        case Opcodes.IFNE:\r\n        case Opcodes.IFLT:\r\n        case Opcodes.IFGE:\r\n        case Opcodes.IFGT:\r\n        case Opcodes.IFLE:\r\n        case Opcodes.IRETURN:\r\n        case Opcodes.FRETURN:\r\n        case Opcodes.ARETURN:\r\n        case Opcodes.TABLESWITCH:\r\n        case Opcodes.LOOKUPSWITCH:\r\n        case Opcodes.ATHROW:\r\n        case Opcodes.MONITORENTER:\r\n        case Opcodes.MONITOREXIT:\r\n        case Opcodes.IFNULL:\r\n        case Opcodes.IFNONNULL:\r\n            pop(1);\r\n            break;\r\n        case Opcodes.POP2:\r\n        case Opcodes.IF_ICMPEQ:\r\n        case Opcodes.IF_ICMPNE:\r\n        case Opcodes.IF_ICMPLT:\r\n        case Opcodes.IF_ICMPGE:\r\n        case Opcodes.IF_ICMPGT:\r\n        case Opcodes.IF_ICMPLE:\r\n        case Opcodes.IF_ACMPEQ:\r\n        case Opcodes.IF_ACMPNE:\r\n        case Opcodes.LRETURN:\r\n        case Opcodes.DRETURN:\r\n            pop(2);\r\n            break;\r\n        case Opcodes.DUP:\r\n            abstractType1 = pop();\r\n            push(abstractType1);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X1:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.DUP2_X2:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            abstractType3 = pop();\r\n            abstractType4 = pop();\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            push(abstractType4);\r\n            push(abstractType3);\r\n            push(abstractType2);\r\n            push(abstractType1);\r\n            break;\r\n        case Opcodes.SWAP:\r\n            abstractType1 = pop();\r\n            abstractType2 = pop();\r\n            push(abstractType1);\r\n            push(abstractType2);\r\n            break;\r\n        case Opcodes.IALOAD:\r\n        case Opcodes.BALOAD:\r\n        case Opcodes.CALOAD:\r\n        case Opcodes.SALOAD:\r\n        case Opcodes.IADD:\r\n        case Opcodes.ISUB:\r\n        case Opcodes.IMUL:\r\n        case Opcodes.IDIV:\r\n        case Opcodes.IREM:\r\n        case Opcodes.IAND:\r\n        case Opcodes.IOR:\r\n        case Opcodes.IXOR:\r\n        case Opcodes.ISHL:\r\n        case Opcodes.ISHR:\r\n        case Opcodes.IUSHR:\r\n        case Opcodes.L2I:\r\n        case Opcodes.D2I:\r\n        case Opcodes.FCMPL:\r\n        case Opcodes.FCMPG:\r\n            pop(2);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LADD:\r\n        case Opcodes.LSUB:\r\n        case Opcodes.LMUL:\r\n        case Opcodes.LDIV:\r\n        case Opcodes.LREM:\r\n        case Opcodes.LAND:\r\n        case Opcodes.LOR:\r\n        case Opcodes.LXOR:\r\n            pop(4);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FALOAD:\r\n        case Opcodes.FADD:\r\n        case Opcodes.FSUB:\r\n        case Opcodes.FMUL:\r\n        case Opcodes.FDIV:\r\n        case Opcodes.FREM:\r\n        case Opcodes.L2F:\r\n        case Opcodes.D2F:\r\n            pop(2);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DADD:\r\n        case Opcodes.DSUB:\r\n        case Opcodes.DMUL:\r\n        case Opcodes.DDIV:\r\n        case Opcodes.DREM:\r\n            pop(4);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LSHL:\r\n        case Opcodes.LSHR:\r\n        case Opcodes.LUSHR:\r\n            pop(3);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.IINC:\r\n            setLocal(arg, INTEGER);\r\n            break;\r\n        case Opcodes.I2L:\r\n        case Opcodes.F2L:\r\n            pop(1);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.I2F:\r\n            pop(1);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.I2D:\r\n        case Opcodes.F2D:\r\n            pop(1);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.F2I:\r\n        case Opcodes.ARRAYLENGTH:\r\n        case Opcodes.INSTANCEOF:\r\n            pop(1);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCMP:\r\n        case Opcodes.DCMPL:\r\n        case Opcodes.DCMPG:\r\n            pop(4);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.JSR:\r\n        case Opcodes.RET:\r\n            throw new IllegalArgumentException(\"JSR/RET are not supported with computeFrames option\");\r\n        case Opcodes.GETSTATIC:\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTSTATIC:\r\n            pop(argSymbol.value);\r\n            break;\r\n        case Opcodes.GETFIELD:\r\n            pop(1);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.PUTFIELD:\r\n            pop(argSymbol.value);\r\n            pop();\r\n            break;\r\n        case Opcodes.INVOKEVIRTUAL:\r\n        case Opcodes.INVOKESPECIAL:\r\n        case Opcodes.INVOKESTATIC:\r\n        case Opcodes.INVOKEINTERFACE:\r\n            pop(argSymbol.value);\r\n            if (opcode != Opcodes.INVOKESTATIC) {\r\n                abstractType1 = pop();\r\n                if (opcode == Opcodes.INVOKESPECIAL && argSymbol.name.charAt(0) == '<') {\r\n                    addInitializedType(abstractType1);\r\n                }\r\n            }\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.INVOKEDYNAMIC:\r\n            pop(argSymbol.value);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        case Opcodes.NEW:\r\n            push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));\r\n            break;\r\n        case Opcodes.NEWARRAY:\r\n            pop();\r\n            switch(arg) {\r\n                case Opcodes.T_BOOLEAN:\r\n                    push(ARRAY_OF | BOOLEAN);\r\n                    break;\r\n                case Opcodes.T_CHAR:\r\n                    push(ARRAY_OF | CHAR);\r\n                    break;\r\n                case Opcodes.T_BYTE:\r\n                    push(ARRAY_OF | BYTE);\r\n                    break;\r\n                case Opcodes.T_SHORT:\r\n                    push(ARRAY_OF | SHORT);\r\n                    break;\r\n                case Opcodes.T_INT:\r\n                    push(ARRAY_OF | INTEGER);\r\n                    break;\r\n                case Opcodes.T_FLOAT:\r\n                    push(ARRAY_OF | FLOAT);\r\n                    break;\r\n                case Opcodes.T_DOUBLE:\r\n                    push(ARRAY_OF | DOUBLE);\r\n                    break;\r\n                case Opcodes.T_LONG:\r\n                    push(ARRAY_OF | LONG);\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException();\r\n            }\r\n            break;\r\n        case Opcodes.ANEWARRAY:\r\n            String arrayElementType = argSymbol.value;\r\n            pop();\r\n            if (arrayElementType.charAt(0) == '[') {\r\n                push(symbolTable, '[' + arrayElementType);\r\n            } else {\r\n                push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));\r\n            }\r\n            break;\r\n        case Opcodes.CHECKCAST:\r\n            String castType = argSymbol.value;\r\n            pop();\r\n            if (castType.charAt(0) == '[') {\r\n                push(symbolTable, castType);\r\n            } else {\r\n                push(REFERENCE_KIND | symbolTable.addType(castType));\r\n            }\r\n            break;\r\n        case Opcodes.MULTIANEWARRAY:\r\n            pop(arg);\r\n            push(symbolTable, argSymbol.value);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException();\r\n    }\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Frame merging methods, used in the second step of the stack map frame computation algorithm\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Computes the concrete output type corresponding to a given abstract output type.\r\n *\r\n * @param abstractOutputType an abstract output type.\r\n * @param numStack the size of the input stack, used to resolve abstract output types of\r\n *     STACK_KIND kind.\r\n * @return the concrete output type corresponding to 'abstractOutputType'.\r\n */\r\nprivate int getConcreteOutputType(final int abstractOutputType, final int numStack) {\r\n    int dim = abstractOutputType & DIM_MASK;\r\n    int kind = abstractOutputType & KIND_MASK;\r\n    if (kind == LOCAL_KIND) {\r\n        // By definition, a LOCAL_KIND type designates the concrete type of a local variable at\r\n        // the beginning of the basic block corresponding to this frame (which is known when\r\n        // this method is called, but was not when the abstract type was computed).\r\n        int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];\r\n        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0 && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\r\n            concreteOutputType = TOP;\r\n        }\r\n        return concreteOutputType;\r\n    } else if (kind == STACK_KIND) {\r\n        // By definition, a STACK_KIND type designates the concrete type of a local variable at\r\n        // the beginning of the basic block corresponding to this frame (which is known when\r\n        // this method is called, but was not when the abstract type was computed).\r\n        int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];\r\n        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0 && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {\r\n            concreteOutputType = TOP;\r\n        }\r\n        return concreteOutputType;\r\n    } else {\r\n        return abstractOutputType;\r\n    }\r\n}\n/**\r\n * Merges the input frame of the given {@link Frame} with the input and output frames of this\r\n * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation\r\n * (the input and output frames of this {@link Frame} are never changed).\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame\r\n *     of a successor, in the control flow graph, of the basic block corresponding to this frame.\r\n * @param catchTypeIndex if 'frame' corresponds to an exception handler basic block, the type\r\n *     table index of the caught exception type, otherwise 0.\r\n * @return {@literal true} if the input frame of 'frame' has been changed by this operation.\r\n */\r\nfinal boolean merge(final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {\r\n    boolean frameChanged = false;\r\n    // Compute the concrete types of the local variables at the end of the basic block corresponding\r\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\r\n    // those of the local variables in the input frame of dstFrame.\r\n    int numLocal = inputLocals.length;\r\n    int numStack = inputStack.length;\r\n    if (dstFrame.inputLocals == null) {\r\n        dstFrame.inputLocals = new int[numLocal];\r\n        frameChanged = true;\r\n    }\r\n    for (int i = 0; i < numLocal; ++i) {\r\n        int concreteOutputType;\r\n        if (outputLocals != null && i < outputLocals.length) {\r\n            int abstractOutputType = outputLocals[i];\r\n            if (abstractOutputType == 0) {\r\n                // If the local variable has never been assigned in this basic block, it is equal to its\r\n                // value at the beginning of the block.\r\n                concreteOutputType = inputLocals[i];\r\n            } else {\r\n                concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\r\n            }\r\n        } else {\r\n            // If the local variable has never been assigned in this basic block, it is equal to its\r\n            // value at the beginning of the block.\r\n            concreteOutputType = inputLocals[i];\r\n        }\r\n        // concreteOutputType might be an uninitialized type from the input locals or from the input\r\n        // stack. However, if a constructor has been called for this class type in the basic block,\r\n        // then this type is no longer uninitialized at the end of basic block.\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);\r\n    }\r\n    // If dstFrame is an exception handler block, it can be reached from any instruction of the\r\n    // basic block corresponding to this frame, in particular from the first one. Therefore, the\r\n    // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this\r\n    // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one\r\n    // element stack containing the caught exception type).\r\n    if (catchTypeIndex > 0) {\r\n        for (int i = 0; i < numLocal; ++i) {\r\n            frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);\r\n        }\r\n        if (dstFrame.inputStack == null) {\r\n            dstFrame.inputStack = new int[1];\r\n            frameChanged = true;\r\n        }\r\n        frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);\r\n        return frameChanged;\r\n    }\r\n    // Compute the concrete types of the stack operands at the end of the basic block corresponding\r\n    // to this frame, by resolving its abstract output types, and merge these concrete types with\r\n    // those of the stack operands in the input frame of dstFrame.\r\n    int numInputStack = inputStack.length + outputStackStart;\r\n    if (dstFrame.inputStack == null) {\r\n        dstFrame.inputStack = new int[numInputStack + outputStackTop];\r\n        frameChanged = true;\r\n    }\r\n    // First, do this for the stack operands that have not been popped in the basic block\r\n    // corresponding to this frame, and which are therefore equal to their value in the input\r\n    // frame (except for uninitialized types, which may have been initialized).\r\n    for (int i = 0; i < numInputStack; ++i) {\r\n        int concreteOutputType = inputStack[i];\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);\r\n    }\r\n    // Then, do this for the stack operands that have pushed in the basic block (this code is the\r\n    // same as the one above for local variables).\r\n    for (int i = 0; i < outputStackTop; ++i) {\r\n        int abstractOutputType = outputStack[i];\r\n        int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);\r\n        if (initializations != null) {\r\n            concreteOutputType = getInitializedType(symbolTable, concreteOutputType);\r\n        }\r\n        frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);\r\n    }\r\n    return frameChanged;\r\n}\n/**\r\n * Merges the type at the given index in the given abstract type array with the given type.\r\n * Returns {@literal true} if the type array has been modified by this operation.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param sourceType the abstract type with which the abstract type array element must be merged.\r\n *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\r\n *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\r\n *     {@literal null} array dimensions.\r\n * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},\r\n *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\r\n *     kind, with positive or {@literal null} array dimensions.\r\n * @param dstIndex the index of the type that must be merged in dstTypes.\r\n * @return {@literal true} if the type array has been modified by this operation.\r\n */\r\nprivate static boolean merge(final SymbolTable symbolTable, final int sourceType, final int[] dstTypes, final int dstIndex) {\r\n    int dstType = dstTypes[dstIndex];\r\n    if (dstType == sourceType) {\r\n        // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.\r\n        return false;\r\n    }\r\n    int srcType = sourceType;\r\n    if ((sourceType & ~DIM_MASK) == NULL) {\r\n        if (dstType == NULL) {\r\n            return false;\r\n        }\r\n        srcType = NULL;\r\n    }\r\n    if (dstType == 0) {\r\n        // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.\r\n        dstTypes[dstIndex] = srcType;\r\n        return true;\r\n    }\r\n    int mergedType;\r\n    if ((dstType & DIM_MASK) != 0 || (dstType & KIND_MASK) == REFERENCE_KIND) {\r\n        // If dstType is a reference type of any array dimension.\r\n        if (srcType == NULL) {\r\n            // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.\r\n            return false;\r\n        } else if ((srcType & (DIM_MASK | KIND_MASK)) == (dstType & (DIM_MASK | KIND_MASK))) {\r\n            // If srcType has the same array dimension and the same kind as dstType.\r\n            if ((dstType & KIND_MASK) == REFERENCE_KIND) {\r\n                // If srcType and dstType are reference types with the same array dimension,\r\n                // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.\r\n                mergedType = (srcType & DIM_MASK) | REFERENCE_KIND | symbolTable.addMergedType(srcType & VALUE_MASK, dstType & VALUE_MASK);\r\n            } else {\r\n                // If srcType and dstType are array types of equal dimension but different element types,\r\n                // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.\r\n                int mergedDim = ELEMENT_OF + (srcType & DIM_MASK);\r\n                mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\r\n            }\r\n        } else if ((srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND) {\r\n            // If srcType is any other reference or array type,\r\n            // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object\r\n            // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type\r\n            // with a non reference element type (and similarly for dstDim).\r\n            int srcDim = srcType & DIM_MASK;\r\n            if (srcDim != 0 && (srcType & KIND_MASK) != REFERENCE_KIND) {\r\n                srcDim = ELEMENT_OF + srcDim;\r\n            }\r\n            int dstDim = dstType & DIM_MASK;\r\n            if (dstDim != 0 && (dstType & KIND_MASK) != REFERENCE_KIND) {\r\n                dstDim = ELEMENT_OF + dstDim;\r\n            }\r\n            mergedType = Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(\"java/lang/Object\");\r\n        } else {\r\n            // If srcType is any other type, merge(srcType, dstType) = TOP.\r\n            mergedType = TOP;\r\n        }\r\n    } else if (dstType == NULL) {\r\n        // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a\r\n        // an array type or a reference type.\r\n        mergedType = (srcType & DIM_MASK) != 0 || (srcType & KIND_MASK) == REFERENCE_KIND ? srcType : TOP;\r\n    } else {\r\n        // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.\r\n        mergedType = TOP;\r\n    }\r\n    if (mergedType != dstType) {\r\n        dstTypes[dstIndex] = mergedType;\r\n        return true;\r\n    }\r\n    return false;\r\n}\n// -----------------------------------------------------------------------------------------------\r\n// Frame output methods, to generate StackMapFrame attributes\r\n// -----------------------------------------------------------------------------------------------\r\n/**\r\n * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is\r\n * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and\r\n * {@link MethodWriter#visitFrameEnd} methods.\r\n *\r\n * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link\r\n *     Frame}.\r\n */\r\nfinal void accept(final MethodWriter methodWriter) {\r\n    // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and\r\n    // all trailing TOP types.\r\n    int[] localTypes = inputLocals;\r\n    int numLocal = 0;\r\n    int numTrailingTop = 0;\r\n    int i = 0;\r\n    while (i < localTypes.length) {\r\n        int localType = localTypes[i];\r\n        i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\r\n        if (localType == TOP) {\r\n            numTrailingTop++;\r\n        } else {\r\n            numLocal += numTrailingTop + 1;\r\n            numTrailingTop = 0;\r\n        }\r\n    }\r\n    // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.\r\n    int[] stackTypes = inputStack;\r\n    int numStack = 0;\r\n    i = 0;\r\n    while (i < stackTypes.length) {\r\n        int stackType = stackTypes[i];\r\n        i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\r\n        numStack++;\r\n    }\r\n    // Visit the frame and its content.\r\n    int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);\r\n    i = 0;\r\n    while (numLocal-- > 0) {\r\n        int localType = localTypes[i];\r\n        i += (localType == LONG || localType == DOUBLE) ? 2 : 1;\r\n        methodWriter.visitAbstractType(frameIndex++, localType);\r\n    }\r\n    i = 0;\r\n    while (numStack-- > 0) {\r\n        int stackType = stackTypes[i];\r\n        i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;\r\n        methodWriter.visitAbstractType(frameIndex++, stackType);\r\n    }\r\n    methodWriter.visitFrameEnd();\r\n}\n/**\r\n * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\r\n * format used in StackMapTable attributes.\r\n *\r\n * @param symbolTable the type table to use to lookup and store type {@link Symbol}.\r\n * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\r\n *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link\r\n *     Frame#FORWARD_UNINITIALIZED_KIND} types.\r\n * @param output where the abstract type must be put.\r\n * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\r\n *     4.7.4</a>\r\n */\r\nstatic void putAbstractType(final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\r\n    int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT;\r\n    if (arrayDimensions == 0) {\r\n        int typeValue = abstractType & VALUE_MASK;\r\n        switch(abstractType & KIND_MASK) {\r\n            case CONSTANT_KIND:\r\n                output.putByte(typeValue);\r\n                break;\r\n            case REFERENCE_KIND:\r\n                output.putByte(ITEM_OBJECT).putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);\r\n                break;\r\n            case UNINITIALIZED_KIND:\r\n                output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data);\r\n                break;\r\n            case FORWARD_UNINITIALIZED_KIND:\r\n                output.putByte(ITEM_UNINITIALIZED);\r\n                symbolTable.getForwardUninitializedLabel(typeValue).put(output);\r\n                break;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    } else {\r\n        // Case of an array type, we need to build its descriptor first.\r\n        // SPRING PATCH: larger initial size\r\n        StringBuilder typeDescriptor = new StringBuilder(32);\r\n        while (arrayDimensions-- > 0) {\r\n            typeDescriptor.append('[');\r\n        }\r\n        if ((abstractType & KIND_MASK) == REFERENCE_KIND) {\r\n            typeDescriptor.append('L').append(symbolTable.getType(abstractType & VALUE_MASK).value).append(';');\r\n        } else {\r\n            switch(abstractType & VALUE_MASK) {\r\n                case Frame.ITEM_ASM_BOOLEAN:\r\n                    typeDescriptor.append('Z');\r\n                    break;\r\n                case Frame.ITEM_ASM_BYTE:\r\n                    typeDescriptor.append('B');\r\n                    break;\r\n                case Frame.ITEM_ASM_CHAR:\r\n                    typeDescriptor.append('C');\r\n                    break;\r\n                case Frame.ITEM_ASM_SHORT:\r\n                    typeDescriptor.append('S');\r\n                    break;\r\n                case Frame.ITEM_INTEGER:\r\n                    typeDescriptor.append('I');\r\n                    break;\r\n                case Frame.ITEM_FLOAT:\r\n                    typeDescriptor.append('F');\r\n                    break;\r\n                case Frame.ITEM_LONG:\r\n                    typeDescriptor.append('J');\r\n                    break;\r\n                case Frame.ITEM_DOUBLE:\r\n                    typeDescriptor.append('D');\r\n                    break;\r\n                default:\r\n                    throw new AssertionError();\r\n            }\r\n        }\r\n        output.putByte(ITEM_OBJECT).putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index);\r\n    }\r\n}",
    "comment": "\n * The input and output stack map frames of a basic block.\n *\n * <p>Stack map frames are computed in two steps:\n *\n * <ul>\n *   <li>During the visit of each instruction in MethodWriter, the state of the frame at the end of\n *       the current basic block is updated by simulating the action of the instruction on the\n *       previous state of this so called \"output frame\".\n *   <li>After all instructions have been visited, a fix point algorithm is used in MethodWriter to\n *       compute the \"input frame\" of each basic block (i.e. the stack map frame at the beginning of\n *       the basic block). See {@link MethodWriter#computeAllFrames}.\n * </ul>\n *\n * <p>Output stack map frames are computed relatively to the input frame of the basic block, which\n * is not yet known when output frames are computed. It is therefore necessary to be able to\n * represent abstract types such as \"the type at position x in the input frame locals\" or \"the type\n * at position x from the top of the input frame stack\" or even \"the type at position x in the input\n * frame, with y more (or less) array dimensions\". This explains the rather complicated type format\n * used in this class, explained below.\n *\n * <p>The local variables and the operand stack of input and output frames contain values called\n * \"abstract types\" hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS\n * and VALUE, packed in a single int value for better performance and memory efficiency:\n *\n * <pre>\n *   =====================================\n *   |...DIM|KIND|.F|...............VALUE|\n *   =====================================\n * </pre>\n *\n * <ul>\n *   <li>the DIM field, stored in the 6 most significant bits, is a signed number of array\n *       dimensions (from -32 to 31, included). It can be retrieved with {@link #DIM_MASK} and a\n *       right shift of {@link #DIM_SHIFT}.\n *   <li>the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be\n *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link\n *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link\n *       #FORWARD_UNINITIALIZED_KIND},{@link #LOCAL_KIND} or {@link #STACK_KIND}.\n *   <li>the FLAGS field, stored in 2 bits, contains up to 2 boolean flags. Currently only one flag\n *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.\n *   <li>the VALUE field, stored in the remaining 20 bits, contains either\n *       <ul>\n *         <li>one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link\n *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link\n *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link\n *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link\n *             #CONSTANT_KIND}.\n *         <li>the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link\n *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.\n *         <li>the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type\n *             table of a {@link SymbolTable}, if KIND is equal to {@link #UNINITIALIZED_KIND}.\n *         <li>the index of a {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} {@link Symbol} in the\n *             type table of a {@link SymbolTable}, if KIND is equal to {@link\n *             #FORWARD_UNINITIALIZED_KIND}.\n *         <li>the index of a local variable in the input stack frame, if KIND is equal to {@link\n *             #LOCAL_KIND}.\n *         <li>a position relatively to the top of the stack of the input stack frame, if KIND is\n *             equal to {@link #STACK_KIND},\n *       </ul>\n * </ul>\n *\n * <p>Output frames can contain abstract types of any kind and with a positive or negative array\n * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid\n * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND,\n * UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract types of positive or {@literal null}\n * array dimension. In all cases the type table contains only internal type names (array type\n * descriptors are forbidden - array dimensions must be represented through the DIM field).\n *\n * <p>The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +\n * TOP), for local variables as well as in the operand stack. This is necessary to be able to\n * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented\n * by the abstract types in the stack (which are not always known).\n *\n * @author Eric Bruneton\n "
  },
  {
    "entityId": "org.springframework.asm.Frame#copyFrom(Frame)",
    "entityType": "method",
    "code": "/**\r\n * Sets this frame to the value of the given frame.\r\n *\r\n * <p>WARNING: after this method is called the two frames share the same data structures. It is\r\n * recommended to discard the given frame to avoid unexpected side effects.\r\n *\r\n * @param frame The new frame value.\r\n */\r\nfinal void copyFrom(final Frame frame) {\r\n    inputLocals = frame.inputLocals;\r\n    inputStack = frame.inputStack;\r\n    outputStackStart = 0;\r\n    outputLocals = frame.outputLocals;\r\n    outputStack = frame.outputStack;\r\n    outputStackTop = frame.outputStackTop;\r\n    initializationCount = frame.initializationCount;\r\n    initializations = frame.initializations;\r\n}",
    "comment": "\n   * Sets this frame to the value of the given frame.\n   *\n   * <p>WARNING: after this method is called the two frames share the same data structures. It is\n   * recommended to discard the given frame to avoid unexpected side effects.\n   *\n   * @param frame The new frame value.\n   "
  }
]