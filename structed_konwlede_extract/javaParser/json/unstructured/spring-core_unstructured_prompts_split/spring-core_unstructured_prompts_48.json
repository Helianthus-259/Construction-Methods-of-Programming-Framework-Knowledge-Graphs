[
  {
    "entityId": "org.springframework.core.annotation.Nearest#select(MergedAnnotation<Annotation>,MergedAnnotation<Annotation>)",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<Annotation> select(MergedAnnotation<Annotation> existing, MergedAnnotation<Annotation> candidate) {\r\n    if (candidate.getDistance() < existing.getDistance()) {\r\n        return candidate;\r\n    }\r\n    return existing;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FirstDirectlyDeclared",
    "entityType": "class",
    "code": "@Override\r\npublic boolean isBestCandidate(MergedAnnotation<Annotation> annotation) {\r\n    return annotation.getDistance() == 0;\r\n}\n@Override\r\npublic MergedAnnotation<Annotation> select(MergedAnnotation<Annotation> existing, MergedAnnotation<Annotation> candidate) {\r\n    if (existing.getDistance() > 0 && candidate.getDistance() == 0) {\r\n        return candidate;\r\n    }\r\n    return existing;\r\n}",
    "comment": "\n\t * {@link MergedAnnotationSelector} to select the first directly declared\n\t * annotation.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.FirstDirectlyDeclared#isBestCandidate(MergedAnnotation<Annotation>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isBestCandidate(MergedAnnotation<Annotation> annotation) {\r\n    return annotation.getDistance() == 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.FirstDirectlyDeclared#select(MergedAnnotation<Annotation>,MergedAnnotation<Annotation>)",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<Annotation> select(MergedAnnotation<Annotation> existing, MergedAnnotation<Annotation> candidate) {\r\n    if (existing.getDistance() > 0 && candidate.getDistance() == 0) {\r\n        return candidate;\r\n    }\r\n    return existing;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation",
    "entityType": "class",
    "code": "private static final MissingMergedAnnotation<?> INSTANCE = new MissingMergedAnnotation<>();\nprivate MissingMergedAnnotation() {\r\n}\n@Override\r\npublic Class<A> getType() {\r\n    throw new NoSuchElementException(\"Unable to get type for missing annotation\");\r\n}\n@Override\r\npublic boolean isPresent() {\r\n    return false;\r\n}\n@Override\r\n@Nullable\r\npublic Object getSource() {\r\n    return null;\r\n}\n@Override\r\n@Nullable\r\npublic MergedAnnotation<?> getMetaSource() {\r\n    return null;\r\n}\n@Override\r\npublic MergedAnnotation<?> getRoot() {\r\n    return this;\r\n}\n@Override\r\npublic List<Class<? extends Annotation>> getMetaTypes() {\r\n    return Collections.emptyList();\r\n}\n@Override\r\npublic int getDistance() {\r\n    return -1;\r\n}\n@Override\r\npublic int getAggregateIndex() {\r\n    return -1;\r\n}\n@Override\r\npublic boolean hasNonDefaultValue(String attributeName) {\r\n    throw new NoSuchElementException(\"Unable to check non-default value for missing annotation\");\r\n}\n@Override\r\npublic boolean hasDefaultValue(String attributeName) {\r\n    throw new NoSuchElementException(\"Unable to check default value for missing annotation\");\r\n}\n@Override\r\npublic <T> Optional<T> getValue(String attributeName, Class<T> type) {\r\n    return Optional.empty();\r\n}\n@Override\r\npublic <T> Optional<T> getDefaultValue(@Nullable String attributeName, Class<T> type) {\r\n    return Optional.empty();\r\n}\n@Override\r\npublic MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {\r\n    return this;\r\n}\n@Override\r\npublic MergedAnnotation<A> withNonMergedAttributes() {\r\n    return this;\r\n}\n@Override\r\npublic AnnotationAttributes asAnnotationAttributes(Adapt... adaptations) {\r\n    return new AnnotationAttributes();\r\n}\n@Override\r\npublic Map<String, Object> asMap(Adapt... adaptations) {\r\n    return Collections.emptyMap();\r\n}\n@Override\r\npublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\r\n    return factory.apply(this);\r\n}\n@Override\r\npublic String toString() {\r\n    return \"(missing)\";\r\n}\n@Override\r\npublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    throw new NoSuchElementException(\"Unable to get attribute value for missing annotation\");\r\n}\n@Override\r\npublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    throw new NoSuchElementException(\"Unable to get attribute value for missing annotation\");\r\n}\n@Override\r\nprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\r\n    throw new NoSuchElementException(\"Unable to get attribute value for missing annotation\");\r\n}\n@Override\r\nprotected A createSynthesizedAnnotation() {\r\n    throw new NoSuchElementException(\"Unable to synthesize missing annotation\");\r\n}\n@SuppressWarnings(\"unchecked\")\r\nstatic <A extends Annotation> MergedAnnotation<A> getInstance() {\r\n    return (MergedAnnotation<A>) INSTANCE;\r\n}",
    "comment": "\n * An {@link AbstractMergedAnnotation} used as the implementation of\n * {@link MergedAnnotation#missing()}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @since 5.2\n * @param <A> the annotation type\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getType()",
    "entityType": "method",
    "code": "@Override\r\npublic Class<A> getType() {\r\n    throw new NoSuchElementException(\"Unable to get type for missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#isPresent()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isPresent() {\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getSource()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object getSource() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getMetaSource()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic MergedAnnotation<?> getMetaSource() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getRoot()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<?> getRoot() {\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getMetaTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic List<Class<? extends Annotation>> getMetaTypes() {\r\n    return Collections.emptyList();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getDistance()",
    "entityType": "method",
    "code": "@Override\r\npublic int getDistance() {\r\n    return -1;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getAggregateIndex()",
    "entityType": "method",
    "code": "@Override\r\npublic int getAggregateIndex() {\r\n    return -1;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#hasNonDefaultValue(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNonDefaultValue(String attributeName) {\r\n    throw new NoSuchElementException(\"Unable to check non-default value for missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#hasDefaultValue(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasDefaultValue(String attributeName) {\r\n    throw new NoSuchElementException(\"Unable to check default value for missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getValue(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> Optional<T> getValue(String attributeName, Class<T> type) {\r\n    return Optional.empty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getDefaultValue(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> Optional<T> getDefaultValue(@Nullable String attributeName, Class<T> type) {\r\n    return Optional.empty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#filterAttributes(Predicate<String>)",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#withNonMergedAttributes()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<A> withNonMergedAttributes() {\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#asAnnotationAttributes(Adapt)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationAttributes asAnnotationAttributes(Adapt... adaptations) {\r\n    return new AnnotationAttributes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#asMap(Adapt)",
    "entityType": "method",
    "code": "@Override\r\npublic Map<String, Object> asMap(Adapt... adaptations) {\r\n    return Collections.emptyMap();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#asMap(Function<MergedAnnotation<?>,T>,Adapt)",
    "entityType": "method",
    "code": "@Override\r\npublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\r\n    return factory.apply(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"(missing)\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getAnnotation(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    throw new NoSuchElementException(\"Unable to get attribute value for missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getAnnotationArray(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    throw new NoSuchElementException(\"Unable to get attribute value for missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getAttributeValue(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\nprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\r\n    throw new NoSuchElementException(\"Unable to get attribute value for missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#createSynthesizedAnnotation()",
    "entityType": "method",
    "code": "@Override\r\nprotected A createSynthesizedAnnotation() {\r\n    throw new NoSuchElementException(\"Unable to synthesize missing annotation\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotation#getInstance()",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nstatic <A extends Annotation> MergedAnnotation<A> getInstance() {\r\n    return (MergedAnnotation<A>) INSTANCE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils",
    "entityType": "class",
    "code": "/**\r\n * Cache marker for a non-annotated Class.\r\n */\r\nprivate static final Object NOT_ANNOTATED = new Object();\nprivate static final String JAKARTA_PRIORITY_ANNOTATION = \"jakarta.annotation.Priority\";\n/**\r\n * Cache for @Order value (or NOT_ANNOTATED marker) per Class.\r\n */\r\nstatic final Map<AnnotatedElement, Object> orderCache = new ConcurrentReferenceHashMap<>(64);\n/**\r\n * Return the order on the specified {@code type}, or the specified\r\n * default value if none can be found.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param type the type to handle\r\n * @return the priority value, or the specified default order if none can be found\r\n * @since 5.0\r\n * @see #getPriority(Class)\r\n */\r\npublic static int getOrder(Class<?> type, int defaultOrder) {\r\n    Integer order = getOrder(type);\r\n    return (order != null ? order : defaultOrder);\r\n}\n/**\r\n * Return the order on the specified {@code type}, or the specified\r\n * default value if none can be found.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param type the type to handle\r\n * @return the priority value, or the specified default order if none can be found\r\n * @see #getPriority(Class)\r\n */\r\n@Nullable\r\npublic static Integer getOrder(Class<?> type, @Nullable Integer defaultOrder) {\r\n    Integer order = getOrder(type);\r\n    return (order != null ? order : defaultOrder);\r\n}\n/**\r\n * Return the order on the specified {@code type}.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param type the type to handle\r\n * @return the order value, or {@code null} if none can be found\r\n * @see #getPriority(Class)\r\n */\r\n@Nullable\r\npublic static Integer getOrder(Class<?> type) {\r\n    return getOrder((AnnotatedElement) type);\r\n}\n/**\r\n * Return the order declared on the specified {@code element}.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param element the annotated element (for example, type or method)\r\n * @return the order value, or {@code null} if none can be found\r\n * @since 5.3\r\n */\r\n@Nullable\r\npublic static Integer getOrder(AnnotatedElement element) {\r\n    return getOrderFromAnnotations(element, MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY));\r\n}\n/**\r\n * Return the order from the specified annotations collection.\r\n * <p>Takes care of {@link Order @Order} and\r\n * {@code @jakarta.annotation.Priority}.\r\n * @param element the source element\r\n * @param annotations the annotation to consider\r\n * @return the order value, or {@code null} if none can be found\r\n */\r\n@Nullable\r\nstatic Integer getOrderFromAnnotations(AnnotatedElement element, MergedAnnotations annotations) {\r\n    if (!(element instanceof Class)) {\r\n        return findOrder(annotations);\r\n    }\r\n    Object cached = orderCache.get(element);\r\n    if (cached != null) {\r\n        return (cached instanceof Integer integer ? integer : null);\r\n    }\r\n    Integer result = findOrder(annotations);\r\n    orderCache.put(element, result != null ? result : NOT_ANNOTATED);\r\n    return result;\r\n}\n@Nullable\r\nprivate static Integer findOrder(MergedAnnotations annotations) {\r\n    MergedAnnotation<Order> orderAnnotation = annotations.get(Order.class);\r\n    if (orderAnnotation.isPresent()) {\r\n        return orderAnnotation.getInt(MergedAnnotation.VALUE);\r\n    }\r\n    MergedAnnotation<?> priorityAnnotation = annotations.get(JAKARTA_PRIORITY_ANNOTATION);\r\n    if (priorityAnnotation.isPresent()) {\r\n        return priorityAnnotation.getInt(MergedAnnotation.VALUE);\r\n    }\r\n    return null;\r\n}\n/**\r\n * Return the value of the {@code jakarta.annotation.Priority} annotation\r\n * declared on the specified type, or {@code null} if none.\r\n * @param type the type to handle\r\n * @return the priority value if the annotation is declared, or {@code null} if none\r\n */\r\n@Nullable\r\npublic static Integer getPriority(Class<?> type) {\r\n    return MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).get(JAKARTA_PRIORITY_ANNOTATION).getValue(MergedAnnotation.VALUE, Integer.class).orElse(null);\r\n}",
    "comment": "\n * General utility for determining the order of an object based on its type declaration.\n * Handles Spring's {@link Order} annotation as well as {@link jakarta.annotation.Priority}.\n *\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n * @since 4.1\n * @see Order\n * @see jakarta.annotation.Priority\n "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#getOrder(Class<?>,int)",
    "entityType": "method",
    "code": "/**\r\n * Return the order on the specified {@code type}, or the specified\r\n * default value if none can be found.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param type the type to handle\r\n * @return the priority value, or the specified default order if none can be found\r\n * @since 5.0\r\n * @see #getPriority(Class)\r\n */\r\npublic static int getOrder(Class<?> type, int defaultOrder) {\r\n    Integer order = getOrder(type);\r\n    return (order != null ? order : defaultOrder);\r\n}",
    "comment": "\n\t * Return the order on the specified {@code type}, or the specified\n\t * default value if none can be found.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param type the type to handle\n\t * @return the priority value, or the specified default order if none can be found\n\t * @since 5.0\n\t * @see #getPriority(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#getOrder(Class<?>,Integer)",
    "entityType": "method",
    "code": "/**\r\n * Return the order on the specified {@code type}, or the specified\r\n * default value if none can be found.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param type the type to handle\r\n * @return the priority value, or the specified default order if none can be found\r\n * @see #getPriority(Class)\r\n */\r\n@Nullable\r\npublic static Integer getOrder(Class<?> type, @Nullable Integer defaultOrder) {\r\n    Integer order = getOrder(type);\r\n    return (order != null ? order : defaultOrder);\r\n}",
    "comment": "\n\t * Return the order on the specified {@code type}, or the specified\n\t * default value if none can be found.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param type the type to handle\n\t * @return the priority value, or the specified default order if none can be found\n\t * @see #getPriority(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#getOrder(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the order on the specified {@code type}.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param type the type to handle\r\n * @return the order value, or {@code null} if none can be found\r\n * @see #getPriority(Class)\r\n */\r\n@Nullable\r\npublic static Integer getOrder(Class<?> type) {\r\n    return getOrder((AnnotatedElement) type);\r\n}",
    "comment": "\n\t * Return the order on the specified {@code type}.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param type the type to handle\n\t * @return the order value, or {@code null} if none can be found\n\t * @see #getPriority(Class)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#getOrder(AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * Return the order declared on the specified {@code element}.\r\n * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\r\n * @param element the annotated element (for example, type or method)\r\n * @return the order value, or {@code null} if none can be found\r\n * @since 5.3\r\n */\r\n@Nullable\r\npublic static Integer getOrder(AnnotatedElement element) {\r\n    return getOrderFromAnnotations(element, MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY));\r\n}",
    "comment": "\n\t * Return the order declared on the specified {@code element}.\n\t * <p>Takes care of {@link Order @Order} and {@code @jakarta.annotation.Priority}.\n\t * @param element the annotated element (for example, type or method)\n\t * @return the order value, or {@code null} if none can be found\n\t * @since 5.3\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#getOrderFromAnnotations(AnnotatedElement,MergedAnnotations)",
    "entityType": "method",
    "code": "/**\r\n * Return the order from the specified annotations collection.\r\n * <p>Takes care of {@link Order @Order} and\r\n * {@code @jakarta.annotation.Priority}.\r\n * @param element the source element\r\n * @param annotations the annotation to consider\r\n * @return the order value, or {@code null} if none can be found\r\n */\r\n@Nullable\r\nstatic Integer getOrderFromAnnotations(AnnotatedElement element, MergedAnnotations annotations) {\r\n    if (!(element instanceof Class)) {\r\n        return findOrder(annotations);\r\n    }\r\n    Object cached = orderCache.get(element);\r\n    if (cached != null) {\r\n        return (cached instanceof Integer integer ? integer : null);\r\n    }\r\n    Integer result = findOrder(annotations);\r\n    orderCache.put(element, result != null ? result : NOT_ANNOTATED);\r\n    return result;\r\n}",
    "comment": "\n\t * Return the order from the specified annotations collection.\n\t * <p>Takes care of {@link Order @Order} and\n\t * {@code @jakarta.annotation.Priority}.\n\t * @param element the source element\n\t * @param annotations the annotation to consider\n\t * @return the order value, or {@code null} if none can be found\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#findOrder(MergedAnnotations)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Integer findOrder(MergedAnnotations annotations) {\r\n    MergedAnnotation<Order> orderAnnotation = annotations.get(Order.class);\r\n    if (orderAnnotation.isPresent()) {\r\n        return orderAnnotation.getInt(MergedAnnotation.VALUE);\r\n    }\r\n    MergedAnnotation<?> priorityAnnotation = annotations.get(JAKARTA_PRIORITY_ANNOTATION);\r\n    if (priorityAnnotation.isPresent()) {\r\n        return priorityAnnotation.getInt(MergedAnnotation.VALUE);\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtils#getPriority(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the value of the {@code jakarta.annotation.Priority} annotation\r\n * declared on the specified type, or {@code null} if none.\r\n * @param type the type to handle\r\n * @return the priority value if the annotation is declared, or {@code null} if none\r\n */\r\n@Nullable\r\npublic static Integer getPriority(Class<?> type) {\r\n    return MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).get(JAKARTA_PRIORITY_ANNOTATION).getValue(MergedAnnotation.VALUE, Integer.class).orElse(null);\r\n}",
    "comment": "\n\t * Return the value of the {@code jakarta.annotation.Priority} annotation\n\t * declared on the specified type, or {@code null} if none.\n\t * @param type the type to handle\n\t * @return the priority value if the annotation is declared, or {@code null} if none\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilter",
    "entityType": "class",
    "code": "private final String[] prefixes;\nprivate final int hashCode;\nPackagesAnnotationFilter(String... packages) {\r\n    Assert.notNull(packages, \"Packages array must not be null\");\r\n    this.prefixes = new String[packages.length];\r\n    for (int i = 0; i < packages.length; i++) {\r\n        String pkg = packages[i];\r\n        Assert.hasText(pkg, \"Packages array must not have empty elements\");\r\n        this.prefixes[i] = pkg + \".\";\r\n    }\r\n    Arrays.sort(this.prefixes);\r\n    this.hashCode = Arrays.hashCode(this.prefixes);\r\n}\n@Override\r\npublic boolean matches(String annotationType) {\r\n    for (String prefix : this.prefixes) {\r\n        if (annotationType.startsWith(prefix)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    return Arrays.equals(this.prefixes, ((PackagesAnnotationFilter) other).prefixes);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.hashCode;\r\n}\n@Override\r\npublic String toString() {\r\n    return \"Packages annotation filter: \" + StringUtils.arrayToCommaDelimitedString(this.prefixes);\r\n}",
    "comment": "\n * {@link AnnotationFilter} implementation used for\n * {@link AnnotationFilter#packages(String...)}.\n *\n * @author Phillip Webb\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilter#matches(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean matches(String annotationType) {\r\n    for (String prefix : this.prefixes) {\r\n        if (annotationType.startsWith(prefix)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilter#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    return Arrays.equals(this.prefixes, ((PackagesAnnotationFilter) other).prefixes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilter#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.hashCode;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.PackagesAnnotationFilter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return \"Packages annotation filter: \" + StringUtils.arrayToCommaDelimitedString(this.prefixes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers",
    "entityType": "class",
    "code": "static final Map<Class<? extends Annotation>, Object> cache = new ConcurrentReferenceHashMap<>();\n@Nullable\r\nprivate final RepeatableContainers parent;\nprivate RepeatableContainers(@Nullable RepeatableContainers parent) {\r\n    this.parent = parent;\r\n}\n/**\r\n * Add an additional explicit relationship between a container and\r\n * repeatable annotation.\r\n * <p>WARNING: the arguments supplied to this method are in the reverse order\r\n * of those supplied to {@link #of(Class, Class)}.\r\n * @param container the container annotation type\r\n * @param repeatable the repeatable annotation type\r\n * @return a new {@link RepeatableContainers} instance\r\n */\r\npublic RepeatableContainers and(Class<? extends Annotation> container, Class<? extends Annotation> repeatable) {\r\n    return new ExplicitRepeatableContainer(this, repeatable, container);\r\n}\nAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n    if (this.parent == null) {\r\n        return null;\r\n    }\r\n    return this.parent.findRepeatedAnnotations(annotation);\r\n}\n@Override\r\n@Contract(\"null -> false\")\r\npublic boolean equals(@Nullable Object other) {\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    return ObjectUtils.nullSafeEquals(this.parent, ((RepeatableContainers) other).parent);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hashCode(this.parent);\r\n}\n/**\r\n * Create a {@link RepeatableContainers} instance that searches using Java's\r\n * {@link Repeatable @Repeatable} annotation.\r\n * @return a {@link RepeatableContainers} instance\r\n */\r\npublic static RepeatableContainers standardRepeatables() {\r\n    return StandardRepeatableContainers.INSTANCE;\r\n}\n/**\r\n * Create a {@link RepeatableContainers} instance that uses predefined\r\n * repeatable and container types.\r\n * <p>WARNING: the arguments supplied to this method are in the reverse order\r\n * of those supplied to {@link #and(Class, Class)}.\r\n * @param repeatable the repeatable annotation type\r\n * @param container the container annotation type or {@code null}. If specified,\r\n * this annotation must declare a {@code value} attribute returning an array\r\n * of repeatable annotations. If not specified, the container will be\r\n * deduced by inspecting the {@code @Repeatable} annotation on\r\n * {@code repeatable}.\r\n * @return a {@link RepeatableContainers} instance\r\n * @throws IllegalArgumentException if the supplied container type is\r\n * {@code null} and the annotation type is not a repeatable annotation\r\n * @throws AnnotationConfigurationException if the supplied container type\r\n * is not a properly configured container for a repeatable annotation\r\n */\r\npublic static RepeatableContainers of(Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\r\n    return new ExplicitRepeatableContainer(null, repeatable, container);\r\n}\n/**\r\n * Create a {@link RepeatableContainers} instance that does not support any\r\n * repeatable annotations.\r\n * @return a {@link RepeatableContainers} instance\r\n */\r\npublic static RepeatableContainers none() {\r\n    return NoRepeatableContainers.INSTANCE;\r\n}\n/**\r\n * Standard {@link RepeatableContainers} implementation that searches using\r\n * Java's {@link Repeatable @Repeatable} annotation.\r\n */\r\nprivate static class StandardRepeatableContainers extends RepeatableContainers {\r\n\r\n    private static final Object NONE = new Object();\r\n\r\n    private static final StandardRepeatableContainers INSTANCE = new StandardRepeatableContainers();\r\n\r\n    StandardRepeatableContainers() {\r\n        super(null);\r\n    }\r\n\r\n    @Override\r\n    Annotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n        Method method = getRepeatedAnnotationsMethod(annotation.annotationType());\r\n        if (method != null) {\r\n            return (Annotation[]) AnnotationUtils.invokeAnnotationMethod(method, annotation);\r\n        }\r\n        return super.findRepeatedAnnotations(annotation);\r\n    }\r\n\r\n    @Nullable\r\n    private static Method getRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\r\n        Object result = cache.computeIfAbsent(annotationType, StandardRepeatableContainers::computeRepeatedAnnotationsMethod);\r\n        return (result != NONE ? (Method) result : null);\r\n    }\r\n\r\n    private static Object computeRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\r\n        AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\r\n        Method method = methods.get(MergedAnnotation.VALUE);\r\n        if (method != null) {\r\n            Class<?> returnType = method.getReturnType();\r\n            if (returnType.isArray()) {\r\n                Class<?> componentType = returnType.componentType();\r\n                if (Annotation.class.isAssignableFrom(componentType) && componentType.isAnnotationPresent(Repeatable.class)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        return NONE;\r\n    }\r\n}\n/**\r\n * A single explicit mapping.\r\n */\r\nprivate static class ExplicitRepeatableContainer extends RepeatableContainers {\r\n\r\n    private final Class<? extends Annotation> repeatable;\r\n\r\n    private final Class<? extends Annotation> container;\r\n\r\n    private final Method valueMethod;\r\n\r\n    ExplicitRepeatableContainer(@Nullable RepeatableContainers parent, Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\r\n        super(parent);\r\n        Assert.notNull(repeatable, \"Repeatable must not be null\");\r\n        if (container == null) {\r\n            container = deduceContainer(repeatable);\r\n        }\r\n        Method valueMethod = AttributeMethods.forAnnotationType(container).get(MergedAnnotation.VALUE);\r\n        try {\r\n            if (valueMethod == null) {\r\n                throw new NoSuchMethodException(\"No value method found\");\r\n            }\r\n            Class<?> returnType = valueMethod.getReturnType();\r\n            if (!returnType.isArray() || returnType.componentType() != repeatable) {\r\n                throw new AnnotationConfigurationException(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\".formatted(container.getName(), repeatable.getName()));\r\n            }\r\n        } catch (AnnotationConfigurationException ex) {\r\n            throw ex;\r\n        } catch (Throwable ex) {\r\n            throw new AnnotationConfigurationException(\"Invalid declaration of container type [%s] for repeatable annotation [%s]\".formatted(container.getName(), repeatable.getName()), ex);\r\n        }\r\n        this.repeatable = repeatable;\r\n        this.container = container;\r\n        this.valueMethod = valueMethod;\r\n    }\r\n\r\n    private Class<? extends Annotation> deduceContainer(Class<? extends Annotation> repeatable) {\r\n        Repeatable annotation = repeatable.getAnnotation(Repeatable.class);\r\n        Assert.notNull(annotation, () -> \"Annotation type must be a repeatable annotation: \" + \"failed to resolve container type for \" + repeatable.getName());\r\n        return annotation.value();\r\n    }\r\n\r\n    @Override\r\n    Annotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n        if (this.container.isAssignableFrom(annotation.annotationType())) {\r\n            return (Annotation[]) AnnotationUtils.invokeAnnotationMethod(this.valueMethod, annotation);\r\n        }\r\n        return super.findRepeatedAnnotations(annotation);\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        if (!super.equals(other)) {\r\n            return false;\r\n        }\r\n        ExplicitRepeatableContainer otherErc = (ExplicitRepeatableContainer) other;\r\n        return (this.container.equals(otherErc.container) && this.repeatable.equals(otherErc.repeatable));\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int hashCode = super.hashCode();\r\n        hashCode = 31 * hashCode + this.container.hashCode();\r\n        hashCode = 31 * hashCode + this.repeatable.hashCode();\r\n        return hashCode;\r\n    }\r\n}\n/**\r\n * No repeatable containers.\r\n */\r\nprivate static class NoRepeatableContainers extends RepeatableContainers {\r\n\r\n    private static final NoRepeatableContainers INSTANCE = new NoRepeatableContainers();\r\n\r\n    NoRepeatableContainers() {\r\n        super(null);\r\n    }\r\n}",
    "comment": "\n * Strategy used to determine annotations that act as containers for other\n * annotations. The {@link #standardRepeatables()} method provides a default\n * strategy that respects Java's {@link Repeatable @Repeatable} support and\n * should be suitable for most situations.\n *\n * <p>The {@link #of} method can be used to register relationships for\n * annotations that do not wish to use {@link Repeatable @Repeatable}.\n *\n * <p>To completely disable repeatable support use {@link #none()}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#and(Class<? extends Annotation>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Add an additional explicit relationship between a container and\r\n * repeatable annotation.\r\n * <p>WARNING: the arguments supplied to this method are in the reverse order\r\n * of those supplied to {@link #of(Class, Class)}.\r\n * @param container the container annotation type\r\n * @param repeatable the repeatable annotation type\r\n * @return a new {@link RepeatableContainers} instance\r\n */\r\npublic RepeatableContainers and(Class<? extends Annotation> container, Class<? extends Annotation> repeatable) {\r\n    return new ExplicitRepeatableContainer(this, repeatable, container);\r\n}",
    "comment": "\n\t * Add an additional explicit relationship between a container and\n\t * repeatable annotation.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #of(Class, Class)}.\n\t * @param container the container annotation type\n\t * @param repeatable the repeatable annotation type\n\t * @return a new {@link RepeatableContainers} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#findRepeatedAnnotations(Annotation)",
    "entityType": "method",
    "code": "Annotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n    if (this.parent == null) {\r\n        return null;\r\n    }\r\n    return this.parent.findRepeatedAnnotations(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Contract(\"null -> false\")\r\npublic boolean equals(@Nullable Object other) {\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    return ObjectUtils.nullSafeEquals(this.parent, ((RepeatableContainers) other).parent);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hashCode(this.parent);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#standardRepeatables()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link RepeatableContainers} instance that searches using Java's\r\n * {@link Repeatable @Repeatable} annotation.\r\n * @return a {@link RepeatableContainers} instance\r\n */\r\npublic static RepeatableContainers standardRepeatables() {\r\n    return StandardRepeatableContainers.INSTANCE;\r\n}",
    "comment": "\n\t * Create a {@link RepeatableContainers} instance that searches using Java's\n\t * {@link Repeatable @Repeatable} annotation.\n\t * @return a {@link RepeatableContainers} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#of(Class<? extends Annotation>,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link RepeatableContainers} instance that uses predefined\r\n * repeatable and container types.\r\n * <p>WARNING: the arguments supplied to this method are in the reverse order\r\n * of those supplied to {@link #and(Class, Class)}.\r\n * @param repeatable the repeatable annotation type\r\n * @param container the container annotation type or {@code null}. If specified,\r\n * this annotation must declare a {@code value} attribute returning an array\r\n * of repeatable annotations. If not specified, the container will be\r\n * deduced by inspecting the {@code @Repeatable} annotation on\r\n * {@code repeatable}.\r\n * @return a {@link RepeatableContainers} instance\r\n * @throws IllegalArgumentException if the supplied container type is\r\n * {@code null} and the annotation type is not a repeatable annotation\r\n * @throws AnnotationConfigurationException if the supplied container type\r\n * is not a properly configured container for a repeatable annotation\r\n */\r\npublic static RepeatableContainers of(Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\r\n    return new ExplicitRepeatableContainer(null, repeatable, container);\r\n}",
    "comment": "\n\t * Create a {@link RepeatableContainers} instance that uses predefined\n\t * repeatable and container types.\n\t * <p>WARNING: the arguments supplied to this method are in the reverse order\n\t * of those supplied to {@link #and(Class, Class)}.\n\t * @param repeatable the repeatable annotation type\n\t * @param container the container annotation type or {@code null}. If specified,\n\t * this annotation must declare a {@code value} attribute returning an array\n\t * of repeatable annotations. If not specified, the container will be\n\t * deduced by inspecting the {@code @Repeatable} annotation on\n\t * {@code repeatable}.\n\t * @return a {@link RepeatableContainers} instance\n\t * @throws IllegalArgumentException if the supplied container type is\n\t * {@code null} and the annotation type is not a repeatable annotation\n\t * @throws AnnotationConfigurationException if the supplied container type\n\t * is not a properly configured container for a repeatable annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableContainers#none()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link RepeatableContainers} instance that does not support any\r\n * repeatable annotations.\r\n * @return a {@link RepeatableContainers} instance\r\n */\r\npublic static RepeatableContainers none() {\r\n    return NoRepeatableContainers.INSTANCE;\r\n}",
    "comment": "\n\t * Create a {@link RepeatableContainers} instance that does not support any\n\t * repeatable annotations.\n\t * @return a {@link RepeatableContainers} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainers",
    "entityType": "class",
    "code": "private static final Object NONE = new Object();\nprivate static final StandardRepeatableContainers INSTANCE = new StandardRepeatableContainers();\nStandardRepeatableContainers() {\r\n    super(null);\r\n}\n@Override\r\nAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n    Method method = getRepeatedAnnotationsMethod(annotation.annotationType());\r\n    if (method != null) {\r\n        return (Annotation[]) AnnotationUtils.invokeAnnotationMethod(method, annotation);\r\n    }\r\n    return super.findRepeatedAnnotations(annotation);\r\n}\n@Nullable\r\nprivate static Method getRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\r\n    Object result = cache.computeIfAbsent(annotationType, StandardRepeatableContainers::computeRepeatedAnnotationsMethod);\r\n    return (result != NONE ? (Method) result : null);\r\n}\nprivate static Object computeRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\r\n    Method method = methods.get(MergedAnnotation.VALUE);\r\n    if (method != null) {\r\n        Class<?> returnType = method.getReturnType();\r\n        if (returnType.isArray()) {\r\n            Class<?> componentType = returnType.componentType();\r\n            if (Annotation.class.isAssignableFrom(componentType) && componentType.isAnnotationPresent(Repeatable.class)) {\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n    return NONE;\r\n}",
    "comment": "\n\t * Standard {@link RepeatableContainers} implementation that searches using\n\t * Java's {@link Repeatable @Repeatable} annotation.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainers#findRepeatedAnnotations(Annotation)",
    "entityType": "method",
    "code": "@Override\r\nAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n    Method method = getRepeatedAnnotationsMethod(annotation.annotationType());\r\n    if (method != null) {\r\n        return (Annotation[]) AnnotationUtils.invokeAnnotationMethod(method, annotation);\r\n    }\r\n    return super.findRepeatedAnnotations(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainers#getRepeatedAnnotationsMethod(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Method getRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\r\n    Object result = cache.computeIfAbsent(annotationType, StandardRepeatableContainers::computeRepeatedAnnotationsMethod);\r\n    return (result != NONE ? (Method) result : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StandardRepeatableContainers#computeRepeatedAnnotationsMethod(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private static Object computeRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);\r\n    Method method = methods.get(MergedAnnotation.VALUE);\r\n    if (method != null) {\r\n        Class<?> returnType = method.getReturnType();\r\n        if (returnType.isArray()) {\r\n            Class<?> componentType = returnType.componentType();\r\n            if (Annotation.class.isAssignableFrom(componentType) && componentType.isAnnotationPresent(Repeatable.class)) {\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n    return NONE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainer",
    "entityType": "class",
    "code": "private final Class<? extends Annotation> repeatable;\nprivate final Class<? extends Annotation> container;\nprivate final Method valueMethod;\nExplicitRepeatableContainer(@Nullable RepeatableContainers parent, Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {\r\n    super(parent);\r\n    Assert.notNull(repeatable, \"Repeatable must not be null\");\r\n    if (container == null) {\r\n        container = deduceContainer(repeatable);\r\n    }\r\n    Method valueMethod = AttributeMethods.forAnnotationType(container).get(MergedAnnotation.VALUE);\r\n    try {\r\n        if (valueMethod == null) {\r\n            throw new NoSuchMethodException(\"No value method found\");\r\n        }\r\n        Class<?> returnType = valueMethod.getReturnType();\r\n        if (!returnType.isArray() || returnType.componentType() != repeatable) {\r\n            throw new AnnotationConfigurationException(\"Container type [%s] must declare a 'value' attribute for an array of type [%s]\".formatted(container.getName(), repeatable.getName()));\r\n        }\r\n    } catch (AnnotationConfigurationException ex) {\r\n        throw ex;\r\n    } catch (Throwable ex) {\r\n        throw new AnnotationConfigurationException(\"Invalid declaration of container type [%s] for repeatable annotation [%s]\".formatted(container.getName(), repeatable.getName()), ex);\r\n    }\r\n    this.repeatable = repeatable;\r\n    this.container = container;\r\n    this.valueMethod = valueMethod;\r\n}\nprivate Class<? extends Annotation> deduceContainer(Class<? extends Annotation> repeatable) {\r\n    Repeatable annotation = repeatable.getAnnotation(Repeatable.class);\r\n    Assert.notNull(annotation, () -> \"Annotation type must be a repeatable annotation: \" + \"failed to resolve container type for \" + repeatable.getName());\r\n    return annotation.value();\r\n}\n@Override\r\nAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n    if (this.container.isAssignableFrom(annotation.annotationType())) {\r\n        return (Annotation[]) AnnotationUtils.invokeAnnotationMethod(this.valueMethod, annotation);\r\n    }\r\n    return super.findRepeatedAnnotations(annotation);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (!super.equals(other)) {\r\n        return false;\r\n    }\r\n    ExplicitRepeatableContainer otherErc = (ExplicitRepeatableContainer) other;\r\n    return (this.container.equals(otherErc.container) && this.repeatable.equals(otherErc.repeatable));\r\n}\n@Override\r\npublic int hashCode() {\r\n    int hashCode = super.hashCode();\r\n    hashCode = 31 * hashCode + this.container.hashCode();\r\n    hashCode = 31 * hashCode + this.repeatable.hashCode();\r\n    return hashCode;\r\n}",
    "comment": "\n\t * A single explicit mapping.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainer#deduceContainer(Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private Class<? extends Annotation> deduceContainer(Class<? extends Annotation> repeatable) {\r\n    Repeatable annotation = repeatable.getAnnotation(Repeatable.class);\r\n    Assert.notNull(annotation, () -> \"Annotation type must be a repeatable annotation: \" + \"failed to resolve container type for \" + repeatable.getName());\r\n    return annotation.value();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainer#findRepeatedAnnotations(Annotation)",
    "entityType": "method",
    "code": "@Override\r\nAnnotation @Nullable [] findRepeatedAnnotations(Annotation annotation) {\r\n    if (this.container.isAssignableFrom(annotation.annotationType())) {\r\n        return (Annotation[]) AnnotationUtils.invokeAnnotationMethod(this.valueMethod, annotation);\r\n    }\r\n    return super.findRepeatedAnnotations(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainer#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (!super.equals(other)) {\r\n        return false;\r\n    }\r\n    ExplicitRepeatableContainer otherErc = (ExplicitRepeatableContainer) other;\r\n    return (this.container.equals(otherErc.container) && this.repeatable.equals(otherErc.repeatable));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ExplicitRepeatableContainer#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    int hashCode = super.hashCode();\r\n    hashCode = 31 * hashCode + this.container.hashCode();\r\n    hashCode = 31 * hashCode + this.repeatable.hashCode();\r\n    return hashCode;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.NoRepeatableContainers",
    "entityType": "class",
    "code": "private static final NoRepeatableContainers INSTANCE = new NoRepeatableContainers();\nNoRepeatableContainers() {\r\n    super(null);\r\n}",
    "comment": "\n\t * No repeatable containers.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler",
    "entityType": "class",
    "code": "private final MergedAnnotation<?> annotation;\nprivate final Class<A> type;\nprivate final AttributeMethods attributes;\nprivate final Map<String, Object> valueCache = new ConcurrentHashMap<>(8);\n@Nullable\r\nprivate volatile Integer hashCode;\n@Nullable\r\nprivate volatile String string;\nprivate SynthesizedMergedAnnotationInvocationHandler(MergedAnnotation<A> annotation, Class<A> type) {\r\n    Assert.notNull(annotation, \"MergedAnnotation must not be null\");\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    Assert.isTrue(type.isAnnotation(), \"Type must be an annotation\");\r\n    this.annotation = annotation;\r\n    this.type = type;\r\n    this.attributes = AttributeMethods.forAnnotationType(type);\r\n}\n@Override\r\npublic Object invoke(Object proxy, Method method, Object[] args) {\r\n    if (this.attributes.indexOf(method.getName()) != -1) {\r\n        return getAttributeValue(method);\r\n    }\r\n    if (method.getParameterCount() == 0) {\r\n        switch(method.getName()) {\r\n            case \"annotationType\":\r\n                return this.type;\r\n            case \"hashCode\":\r\n                return annotationHashCode();\r\n            case \"toString\":\r\n                return annotationToString();\r\n        }\r\n    }\r\n    if (ReflectionUtils.isEqualsMethod(method)) {\r\n        return annotationEquals(args[0]);\r\n    }\r\n    throw new AnnotationConfigurationException(String.format(\"Method [%s] is unsupported for synthesized annotation type [%s]\", method, this.type));\r\n}\n/**\r\n * See {@link Annotation#equals(Object)} for a definition of the required algorithm.\r\n * @param other the other object to compare against\r\n */\r\nprivate boolean annotationEquals(Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (!this.type.isInstance(other)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        Object thisValue = getAttributeValue(attribute);\r\n        Object otherValue = AnnotationUtils.invokeAnnotationMethod(attribute, other);\r\n        if (!ObjectUtils.nullSafeEquals(thisValue, otherValue)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n/**\r\n * See {@link Annotation#hashCode()} for a definition of the required algorithm.\r\n */\r\nprivate int annotationHashCode() {\r\n    Integer hashCode = this.hashCode;\r\n    if (hashCode == null) {\r\n        hashCode = computeHashCode();\r\n        this.hashCode = hashCode;\r\n    }\r\n    return hashCode;\r\n}\nprivate Integer computeHashCode() {\r\n    int hashCode = 0;\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        Object value = getAttributeValue(attribute);\r\n        hashCode += (127 * attribute.getName().hashCode()) ^ ObjectUtils.nullSafeHashCode(value);\r\n    }\r\n    return hashCode;\r\n}\nprivate String annotationToString() {\r\n    String string = this.string;\r\n    if (string == null) {\r\n        StringBuilder builder = new StringBuilder(\"@\").append(getName(this.type)).append('(');\r\n        for (int i = 0; i < this.attributes.size(); i++) {\r\n            Method attribute = this.attributes.get(i);\r\n            if (i > 0) {\r\n                builder.append(\", \");\r\n            }\r\n            builder.append(attribute.getName());\r\n            builder.append('=');\r\n            builder.append(toString(getAttributeValue(attribute)));\r\n        }\r\n        builder.append(')');\r\n        string = builder.toString();\r\n        this.string = string;\r\n    }\r\n    return string;\r\n}\n/**\r\n * This method currently does not address the following issues which we may\r\n * choose to address at a later point in time.\r\n *\r\n * <ul>\r\n * <li>non-ASCII, non-visible, and non-printable characters within a character\r\n * or String literal are not escaped.</li>\r\n * <li>formatting for float and double values does not take into account whether\r\n * a value is not a number (NaN) or infinite.</li>\r\n * </ul>\r\n * @param value the attribute value to format\r\n * @return the formatted string representation\r\n */\r\nprivate String toString(Object value) {\r\n    if (value instanceof String str) {\r\n        return '\"' + str + '\"';\r\n    }\r\n    if (value instanceof Character) {\r\n        return '\\'' + value.toString() + '\\'';\r\n    }\r\n    if (value instanceof Byte) {\r\n        return String.format(\"(byte) 0x%02X\", value);\r\n    }\r\n    if (value instanceof Long longValue) {\r\n        return Long.toString(longValue) + 'L';\r\n    }\r\n    if (value instanceof Float floatValue) {\r\n        return Float.toString(floatValue) + 'f';\r\n    }\r\n    if (value instanceof Double doubleValue) {\r\n        return Double.toString(doubleValue) + 'd';\r\n    }\r\n    if (value instanceof Enum<?> e) {\r\n        return e.name();\r\n    }\r\n    if (value instanceof Class<?> clazz) {\r\n        return getName(clazz) + \".class\";\r\n    }\r\n    if (value.getClass().isArray()) {\r\n        StringBuilder builder = new StringBuilder(\"{\");\r\n        for (int i = 0; i < Array.getLength(value); i++) {\r\n            if (i > 0) {\r\n                builder.append(\", \");\r\n            }\r\n            builder.append(toString(Array.get(value, i)));\r\n        }\r\n        builder.append('}');\r\n        return builder.toString();\r\n    }\r\n    return String.valueOf(value);\r\n}\nprivate Object getAttributeValue(Method method) {\r\n    Object value = this.valueCache.computeIfAbsent(method.getName(), attributeName -> {\r\n        Class<?> type = ClassUtils.resolvePrimitiveIfNecessary(method.getReturnType());\r\n        return this.annotation.getValue(attributeName, type).orElseThrow(() -> new NoSuchElementException(\"No value found for attribute named '\" + attributeName + \"' in merged annotation \" + getName(this.annotation.getType())));\r\n    });\r\n    // Clone non-empty arrays so that users cannot alter the contents of values in our cache.\r\n    if (value.getClass().isArray() && Array.getLength(value) > 0) {\r\n        value = cloneArray(value);\r\n    }\r\n    return value;\r\n}\n/**\r\n * Clone the provided array, ensuring that the original component type is retained.\r\n * @param array the array to clone\r\n */\r\nprivate Object cloneArray(Object array) {\r\n    if (array instanceof boolean[] booleans) {\r\n        return booleans.clone();\r\n    }\r\n    if (array instanceof byte[] bytes) {\r\n        return bytes.clone();\r\n    }\r\n    if (array instanceof char[] chars) {\r\n        return chars.clone();\r\n    }\r\n    if (array instanceof double[] doubles) {\r\n        return doubles.clone();\r\n    }\r\n    if (array instanceof float[] floats) {\r\n        return floats.clone();\r\n    }\r\n    if (array instanceof int[] ints) {\r\n        return ints.clone();\r\n    }\r\n    if (array instanceof long[] longs) {\r\n        return longs.clone();\r\n    }\r\n    if (array instanceof short[] shorts) {\r\n        return shorts.clone();\r\n    }\r\n    // else\r\n    return ((Object[]) array).clone();\r\n}\n@SuppressWarnings(\"unchecked\")\r\nstatic <A extends Annotation> A createProxy(MergedAnnotation<A> annotation, Class<A> type) {\r\n    ClassLoader classLoader = type.getClassLoader();\r\n    Class<?>[] interfaces = new Class<?>[] { type };\r\n    InvocationHandler handler = new SynthesizedMergedAnnotationInvocationHandler<>(annotation, type);\r\n    return (A) Proxy.newProxyInstance(classLoader, interfaces, handler);\r\n}\nprivate static String getName(Class<?> clazz) {\r\n    String canonicalName = clazz.getCanonicalName();\r\n    return (canonicalName != null ? canonicalName : clazz.getName());\r\n}",
    "comment": "\n * {@link InvocationHandler} for an {@link Annotation} that Spring has\n * <em>synthesized</em> (i.e. wrapped in a dynamic proxy) with additional\n * functionality such as attribute alias handling.\n *\n * @author Sam Brannen\n * @author Phillip Webb\n * @since 5.2\n * @param <A> the annotation type\n * @see Annotation\n * @see AnnotationUtils#synthesizeAnnotation(Annotation, AnnotatedElement)\n "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#invoke(Object,Method,Object[])",
    "entityType": "method",
    "code": "@Override\r\npublic Object invoke(Object proxy, Method method, Object[] args) {\r\n    if (this.attributes.indexOf(method.getName()) != -1) {\r\n        return getAttributeValue(method);\r\n    }\r\n    if (method.getParameterCount() == 0) {\r\n        switch(method.getName()) {\r\n            case \"annotationType\":\r\n                return this.type;\r\n            case \"hashCode\":\r\n                return annotationHashCode();\r\n            case \"toString\":\r\n                return annotationToString();\r\n        }\r\n    }\r\n    if (ReflectionUtils.isEqualsMethod(method)) {\r\n        return annotationEquals(args[0]);\r\n    }\r\n    throw new AnnotationConfigurationException(String.format(\"Method [%s] is unsupported for synthesized annotation type [%s]\", method, this.type));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#annotationEquals(Object)",
    "entityType": "method",
    "code": "/**\r\n * See {@link Annotation#equals(Object)} for a definition of the required algorithm.\r\n * @param other the other object to compare against\r\n */\r\nprivate boolean annotationEquals(Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (!this.type.isInstance(other)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        Object thisValue = getAttributeValue(attribute);\r\n        Object otherValue = AnnotationUtils.invokeAnnotationMethod(attribute, other);\r\n        if (!ObjectUtils.nullSafeEquals(thisValue, otherValue)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": "\n\t * See {@link Annotation#equals(Object)} for a definition of the required algorithm.\n\t * @param other the other object to compare against\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#annotationHashCode()",
    "entityType": "method",
    "code": "/**\r\n * See {@link Annotation#hashCode()} for a definition of the required algorithm.\r\n */\r\nprivate int annotationHashCode() {\r\n    Integer hashCode = this.hashCode;\r\n    if (hashCode == null) {\r\n        hashCode = computeHashCode();\r\n        this.hashCode = hashCode;\r\n    }\r\n    return hashCode;\r\n}",
    "comment": "\n\t * See {@link Annotation#hashCode()} for a definition of the required algorithm.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#computeHashCode()",
    "entityType": "method",
    "code": "private Integer computeHashCode() {\r\n    int hashCode = 0;\r\n    for (int i = 0; i < this.attributes.size(); i++) {\r\n        Method attribute = this.attributes.get(i);\r\n        Object value = getAttributeValue(attribute);\r\n        hashCode += (127 * attribute.getName().hashCode()) ^ ObjectUtils.nullSafeHashCode(value);\r\n    }\r\n    return hashCode;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#annotationToString()",
    "entityType": "method",
    "code": "private String annotationToString() {\r\n    String string = this.string;\r\n    if (string == null) {\r\n        StringBuilder builder = new StringBuilder(\"@\").append(getName(this.type)).append('(');\r\n        for (int i = 0; i < this.attributes.size(); i++) {\r\n            Method attribute = this.attributes.get(i);\r\n            if (i > 0) {\r\n                builder.append(\", \");\r\n            }\r\n            builder.append(attribute.getName());\r\n            builder.append('=');\r\n            builder.append(toString(getAttributeValue(attribute)));\r\n        }\r\n        builder.append(')');\r\n        string = builder.toString();\r\n        this.string = string;\r\n    }\r\n    return string;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#toString(Object)",
    "entityType": "method",
    "code": "/**\r\n * This method currently does not address the following issues which we may\r\n * choose to address at a later point in time.\r\n *\r\n * <ul>\r\n * <li>non-ASCII, non-visible, and non-printable characters within a character\r\n * or String literal are not escaped.</li>\r\n * <li>formatting for float and double values does not take into account whether\r\n * a value is not a number (NaN) or infinite.</li>\r\n * </ul>\r\n * @param value the attribute value to format\r\n * @return the formatted string representation\r\n */\r\nprivate String toString(Object value) {\r\n    if (value instanceof String str) {\r\n        return '\"' + str + '\"';\r\n    }\r\n    if (value instanceof Character) {\r\n        return '\\'' + value.toString() + '\\'';\r\n    }\r\n    if (value instanceof Byte) {\r\n        return String.format(\"(byte) 0x%02X\", value);\r\n    }\r\n    if (value instanceof Long longValue) {\r\n        return Long.toString(longValue) + 'L';\r\n    }\r\n    if (value instanceof Float floatValue) {\r\n        return Float.toString(floatValue) + 'f';\r\n    }\r\n    if (value instanceof Double doubleValue) {\r\n        return Double.toString(doubleValue) + 'd';\r\n    }\r\n    if (value instanceof Enum<?> e) {\r\n        return e.name();\r\n    }\r\n    if (value instanceof Class<?> clazz) {\r\n        return getName(clazz) + \".class\";\r\n    }\r\n    if (value.getClass().isArray()) {\r\n        StringBuilder builder = new StringBuilder(\"{\");\r\n        for (int i = 0; i < Array.getLength(value); i++) {\r\n            if (i > 0) {\r\n                builder.append(\", \");\r\n            }\r\n            builder.append(toString(Array.get(value, i)));\r\n        }\r\n        builder.append('}');\r\n        return builder.toString();\r\n    }\r\n    return String.valueOf(value);\r\n}",
    "comment": "\n\t * This method currently does not address the following issues which we may\n\t * choose to address at a later point in time.\n\t *\n\t * <ul>\n\t * <li>non-ASCII, non-visible, and non-printable characters within a character\n\t * or String literal are not escaped.</li>\n\t * <li>formatting for float and double values does not take into account whether\n\t * a value is not a number (NaN) or infinite.</li>\n\t * </ul>\n\t * @param value the attribute value to format\n\t * @return the formatted string representation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#getAttributeValue(Method)",
    "entityType": "method",
    "code": "private Object getAttributeValue(Method method) {\r\n    Object value = this.valueCache.computeIfAbsent(method.getName(), attributeName -> {\r\n        Class<?> type = ClassUtils.resolvePrimitiveIfNecessary(method.getReturnType());\r\n        return this.annotation.getValue(attributeName, type).orElseThrow(() -> new NoSuchElementException(\"No value found for attribute named '\" + attributeName + \"' in merged annotation \" + getName(this.annotation.getType())));\r\n    });\r\n    // Clone non-empty arrays so that users cannot alter the contents of values in our cache.\r\n    if (value.getClass().isArray() && Array.getLength(value) > 0) {\r\n        value = cloneArray(value);\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#cloneArray(Object)",
    "entityType": "method",
    "code": "/**\r\n * Clone the provided array, ensuring that the original component type is retained.\r\n * @param array the array to clone\r\n */\r\nprivate Object cloneArray(Object array) {\r\n    if (array instanceof boolean[] booleans) {\r\n        return booleans.clone();\r\n    }\r\n    if (array instanceof byte[] bytes) {\r\n        return bytes.clone();\r\n    }\r\n    if (array instanceof char[] chars) {\r\n        return chars.clone();\r\n    }\r\n    if (array instanceof double[] doubles) {\r\n        return doubles.clone();\r\n    }\r\n    if (array instanceof float[] floats) {\r\n        return floats.clone();\r\n    }\r\n    if (array instanceof int[] ints) {\r\n        return ints.clone();\r\n    }\r\n    if (array instanceof long[] longs) {\r\n        return longs.clone();\r\n    }\r\n    if (array instanceof short[] shorts) {\r\n        return shorts.clone();\r\n    }\r\n    // else\r\n    return ((Object[]) array).clone();\r\n}",
    "comment": "\n\t * Clone the provided array, ensuring that the original component type is retained.\n\t * @param array the array to clone\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#createProxy(MergedAnnotation<A>,Class<A>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nstatic <A extends Annotation> A createProxy(MergedAnnotation<A> annotation, Class<A> type) {\r\n    ClassLoader classLoader = type.getClassLoader();\r\n    Class<?>[] interfaces = new Class<?>[] { type };\r\n    InvocationHandler handler = new SynthesizedMergedAnnotationInvocationHandler<>(annotation, type);\r\n    return (A) Proxy.newProxyInstance(classLoader, interfaces, handler);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler#getName(Class<?>)",
    "entityType": "method",
    "code": "private static String getName(Class<?> clazz) {\r\n    String canonicalName = clazz.getCanonicalName();\r\n    return (canonicalName != null ? canonicalName : clazz.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameter",
    "entityType": "class",
    "code": "/**\r\n * Create a new {@code SynthesizingMethodParameter} for the given method,\r\n * with nesting level 1.\r\n * @param method the Method to specify a parameter for\r\n * @param parameterIndex the index of the parameter: -1 for the method\r\n * return type; 0 for the first method parameter; 1 for the second method\r\n * parameter, etc.\r\n */\r\npublic SynthesizingMethodParameter(Method method, int parameterIndex) {\r\n    super(method, parameterIndex);\r\n}\n/**\r\n * Create a new {@code SynthesizingMethodParameter} for the given method.\r\n * @param method the Method to specify a parameter for\r\n * @param parameterIndex the index of the parameter: -1 for the method\r\n * return type; 0 for the first method parameter; 1 for the second method\r\n * parameter, etc.\r\n * @param nestingLevel the nesting level of the target type\r\n * (typically 1; for example, in case of a List of Lists, 1 would indicate the\r\n * nested List, whereas 2 would indicate the element of the nested List)\r\n */\r\npublic SynthesizingMethodParameter(Method method, int parameterIndex, int nestingLevel) {\r\n    super(method, parameterIndex, nestingLevel);\r\n}\n/**\r\n * Create a new {@code SynthesizingMethodParameter} for the given constructor,\r\n * with nesting level 1.\r\n * @param constructor the Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n */\r\npublic SynthesizingMethodParameter(Constructor<?> constructor, int parameterIndex) {\r\n    super(constructor, parameterIndex);\r\n}\n/**\r\n * Create a new {@code SynthesizingMethodParameter} for the given constructor.\r\n * @param constructor the Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @param nestingLevel the nesting level of the target type\r\n * (typically 1; for example, in case of a List of Lists, 1 would indicate the\r\n * nested List, whereas 2 would indicate the element of the nested List)\r\n */\r\npublic SynthesizingMethodParameter(Constructor<?> constructor, int parameterIndex, int nestingLevel) {\r\n    super(constructor, parameterIndex, nestingLevel);\r\n}\n/**\r\n * Copy constructor, resulting in an independent {@code SynthesizingMethodParameter}\r\n * based on the same metadata and cache state that the original object was in.\r\n * @param original the original SynthesizingMethodParameter object to copy from\r\n */\r\nprotected SynthesizingMethodParameter(SynthesizingMethodParameter original) {\r\n    super(original);\r\n}\n@Override\r\nprotected <A extends Annotation> A adaptAnnotation(A annotation) {\r\n    return AnnotationUtils.synthesizeAnnotation(annotation, getAnnotatedElement());\r\n}\n@Override\r\nprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\r\n    return AnnotationUtils.synthesizeAnnotationArray(annotations, getAnnotatedElement());\r\n}\n@Override\r\npublic SynthesizingMethodParameter clone() {\r\n    return new SynthesizingMethodParameter(this);\r\n}\n/**\r\n * Create a new SynthesizingMethodParameter for the given method or constructor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Method or Constructor reference is treated in a generic fashion.\r\n * @param executable the Method or Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @return the corresponding SynthesizingMethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex) {\r\n    if (executable instanceof Method method) {\r\n        return new SynthesizingMethodParameter(method, parameterIndex);\r\n    } else if (executable instanceof Constructor<?> constructor) {\r\n        return new SynthesizingMethodParameter(constructor, parameterIndex);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\r\n    }\r\n}\n/**\r\n * Create a new SynthesizingMethodParameter for the given parameter descriptor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Java 8 {@link Parameter} descriptor is already available.\r\n * @param parameter the parameter descriptor\r\n * @return the corresponding SynthesizingMethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static SynthesizingMethodParameter forParameter(Parameter parameter) {\r\n    return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));\r\n}",
    "comment": "\n * A {@link MethodParameter} variant which synthesizes annotations that\n * declare attribute aliases via {@link AliasFor @AliasFor}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 4.2\n * @see AnnotationUtils#synthesizeAnnotation\n * @see AnnotationUtils#synthesizeAnnotationArray\n "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameter#adaptAnnotation(A)",
    "entityType": "method",
    "code": "@Override\r\nprotected <A extends Annotation> A adaptAnnotation(A annotation) {\r\n    return AnnotationUtils.synthesizeAnnotation(annotation, getAnnotatedElement());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameter#adaptAnnotationArray(Annotation[])",
    "entityType": "method",
    "code": "@Override\r\nprotected Annotation[] adaptAnnotationArray(Annotation[] annotations) {\r\n    return AnnotationUtils.synthesizeAnnotationArray(annotations, getAnnotatedElement());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameter#clone()",
    "entityType": "method",
    "code": "@Override\r\npublic SynthesizingMethodParameter clone() {\r\n    return new SynthesizingMethodParameter(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameter#forExecutable(Executable,int)",
    "entityType": "method",
    "code": "/**\r\n * Create a new SynthesizingMethodParameter for the given method or constructor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Method or Constructor reference is treated in a generic fashion.\r\n * @param executable the Method or Constructor to specify a parameter for\r\n * @param parameterIndex the index of the parameter\r\n * @return the corresponding SynthesizingMethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex) {\r\n    if (executable instanceof Method method) {\r\n        return new SynthesizingMethodParameter(method, parameterIndex);\r\n    } else if (executable instanceof Constructor<?> constructor) {\r\n        return new SynthesizingMethodParameter(constructor, parameterIndex);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Not a Method/Constructor: \" + executable);\r\n    }\r\n}",
    "comment": "\n\t * Create a new SynthesizingMethodParameter for the given method or constructor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Method or Constructor reference is treated in a generic fashion.\n\t * @param executable the Method or Constructor to specify a parameter for\n\t * @param parameterIndex the index of the parameter\n\t * @return the corresponding SynthesizingMethodParameter instance\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.SynthesizingMethodParameter#forParameter(Parameter)",
    "entityType": "method",
    "code": "/**\r\n * Create a new SynthesizingMethodParameter for the given parameter descriptor.\r\n * <p>This is a convenience factory method for scenarios where a\r\n * Java 8 {@link Parameter} descriptor is already available.\r\n * @param parameter the parameter descriptor\r\n * @return the corresponding SynthesizingMethodParameter instance\r\n * @since 5.0\r\n */\r\npublic static SynthesizingMethodParameter forParameter(Parameter parameter) {\r\n    return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));\r\n}",
    "comment": "\n\t * Create a new SynthesizingMethodParameter for the given parameter descriptor.\n\t * <p>This is a convenience factory method for scenarios where a\n\t * Java 8 {@link Parameter} descriptor is already available.\n\t * @param parameter the parameter descriptor\n\t * @return the corresponding SynthesizingMethodParameter instance\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation",
    "entityType": "class",
    "code": "private static final Map<Class<?>, Object> EMPTY_ARRAYS = Map.of(boolean.class, new boolean[0], byte.class, new byte[0], char.class, new char[0], double.class, new double[0], float.class, new float[0], int.class, new int[0], long.class, new long[0], short.class, new short[0], String.class, new String[0]);\nprivate final AnnotationTypeMapping mapping;\n@Nullable\r\nprivate final ClassLoader classLoader;\n@Nullable\r\nprivate final Object source;\n@Nullable\r\nprivate final Object rootAttributes;\nprivate final ValueExtractor valueExtractor;\nprivate final int aggregateIndex;\nprivate final boolean useMergedValues;\n@Nullable\r\nprivate final Predicate<String> attributeFilter;\nprivate final int[] resolvedRootMirrors;\nprivate final int[] resolvedMirrors;\nprivate TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader, @Nullable Object source, @Nullable Object rootAttributes, ValueExtractor valueExtractor, int aggregateIndex) {\r\n    this(mapping, classLoader, source, rootAttributes, valueExtractor, aggregateIndex, null);\r\n}\nprivate TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader, @Nullable Object source, @Nullable Object rootAttributes, ValueExtractor valueExtractor, int aggregateIndex, int @Nullable [] resolvedRootMirrors) {\r\n    this.mapping = mapping;\r\n    this.classLoader = classLoader;\r\n    this.source = source;\r\n    this.rootAttributes = rootAttributes;\r\n    this.valueExtractor = valueExtractor;\r\n    this.aggregateIndex = aggregateIndex;\r\n    this.useMergedValues = true;\r\n    this.attributeFilter = null;\r\n    this.resolvedRootMirrors = (resolvedRootMirrors != null ? resolvedRootMirrors : mapping.getRoot().getMirrorSets().resolve(source, rootAttributes, this.valueExtractor));\r\n    this.resolvedMirrors = (getDistance() == 0 ? this.resolvedRootMirrors : mapping.getMirrorSets().resolve(source, this, this::getValueForMirrorResolution));\r\n}\nprivate TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader, @Nullable Object source, @Nullable Object rootAnnotation, ValueExtractor valueExtractor, int aggregateIndex, boolean useMergedValues, @Nullable Predicate<String> attributeFilter, int[] resolvedRootMirrors, int[] resolvedMirrors) {\r\n    this.classLoader = classLoader;\r\n    this.source = source;\r\n    this.rootAttributes = rootAnnotation;\r\n    this.valueExtractor = valueExtractor;\r\n    this.mapping = mapping;\r\n    this.aggregateIndex = aggregateIndex;\r\n    this.useMergedValues = useMergedValues;\r\n    this.attributeFilter = attributeFilter;\r\n    this.resolvedRootMirrors = resolvedRootMirrors;\r\n    this.resolvedMirrors = resolvedMirrors;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Class<A> getType() {\r\n    return (Class<A>) this.mapping.getAnnotationType();\r\n}\n@Override\r\npublic List<Class<? extends Annotation>> getMetaTypes() {\r\n    return this.mapping.getMetaTypes();\r\n}\n@Override\r\npublic boolean isPresent() {\r\n    return true;\r\n}\n@Override\r\npublic int getDistance() {\r\n    return this.mapping.getDistance();\r\n}\n@Override\r\npublic int getAggregateIndex() {\r\n    return this.aggregateIndex;\r\n}\n@Override\r\n@Nullable\r\npublic Object getSource() {\r\n    return this.source;\r\n}\n@Override\r\n@Nullable\r\npublic MergedAnnotation<?> getMetaSource() {\r\n    AnnotationTypeMapping metaSourceMapping = this.mapping.getSource();\r\n    if (metaSourceMapping == null) {\r\n        return null;\r\n    }\r\n    return new TypeMappedAnnotation<>(metaSourceMapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);\r\n}\n@Override\r\npublic MergedAnnotation<?> getRoot() {\r\n    if (getDistance() == 0) {\r\n        return this;\r\n    }\r\n    AnnotationTypeMapping rootMapping = this.mapping.getRoot();\r\n    return new TypeMappedAnnotation<>(rootMapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);\r\n}\n@Override\r\npublic boolean hasDefaultValue(String attributeName) {\r\n    int attributeIndex = getAttributeIndex(attributeName, true);\r\n    Object value = getValue(attributeIndex, true, false);\r\n    return (value == null || this.mapping.isEquivalentToDefaultValue(attributeIndex, value, this.valueExtractor));\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    int attributeIndex = getAttributeIndex(attributeName, true);\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    Assert.isAssignable(type, attribute.getReturnType(), () -> \"Attribute \" + attributeName + \" type mismatch:\");\r\n    return (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    int attributeIndex = getAttributeIndex(attributeName, true);\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    Class<?> componentType = attribute.getReturnType().componentType();\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    Assert.notNull(componentType, () -> \"Attribute \" + attributeName + \" is not an array\");\r\n    Assert.isAssignable(type, componentType, () -> \"Attribute \" + attributeName + \" component type mismatch:\");\r\n    return (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);\r\n}\n@Override\r\npublic <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {\r\n    int attributeIndex = getAttributeIndex(attributeName, false);\r\n    if (attributeIndex == -1) {\r\n        return Optional.empty();\r\n    }\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    return Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));\r\n}\n@Override\r\npublic MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {\r\n    if (this.attributeFilter != null) {\r\n        predicate = this.attributeFilter.and(predicate);\r\n    }\r\n    return new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.useMergedValues, predicate, this.resolvedRootMirrors, this.resolvedMirrors);\r\n}\n@Override\r\npublic MergedAnnotation<A> withNonMergedAttributes() {\r\n    return new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, false, this.attributeFilter, this.resolvedRootMirrors, this.resolvedMirrors);\r\n}\n@Override\r\npublic Map<String, Object> asMap(Adapt... adaptations) {\r\n    return Collections.unmodifiableMap(asMap(mergedAnnotation -> new LinkedHashMap<>(), adaptations));\r\n}\n@Override\r\npublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\r\n    T map = factory.apply(this);\r\n    Assert.state(map != null, \"Factory used to create MergedAnnotation Map must not return null\");\r\n    AttributeMethods attributes = this.mapping.getAttributes();\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        Method attribute = attributes.get(i);\r\n        Object value = (isFiltered(attribute.getName()) ? null : getValue(i, getTypeForMapOptions(attribute, adaptations)));\r\n        if (value != null) {\r\n            map.put(attribute.getName(), adaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));\r\n        }\r\n    }\r\n    return map;\r\n}\nprivate Class<?> getTypeForMapOptions(Method attribute, Adapt[] adaptations) {\r\n    Class<?> attributeType = attribute.getReturnType();\r\n    Class<?> componentType = (attributeType.isArray() ? attributeType.componentType() : attributeType);\r\n    if (Adapt.CLASS_TO_STRING.isIn(adaptations) && componentType == Class.class) {\r\n        return (attributeType.isArray() ? String[].class : String.class);\r\n    }\r\n    return Object.class;\r\n}\nprivate <T extends Map<String, Object>> Object adaptValueForMapOptions(Method attribute, Object value, Class<?> mapType, Function<MergedAnnotation<?>, T> factory, Adapt[] adaptations) {\r\n    if (value instanceof MergedAnnotation<?> annotation) {\r\n        return (Adapt.ANNOTATION_TO_MAP.isIn(adaptations) ? annotation.asMap(factory, adaptations) : annotation.synthesize());\r\n    }\r\n    if (value instanceof MergedAnnotation<?>[] annotations) {\r\n        if (Adapt.ANNOTATION_TO_MAP.isIn(adaptations)) {\r\n            Object result = Array.newInstance(mapType, annotations.length);\r\n            for (int i = 0; i < annotations.length; i++) {\r\n                Array.set(result, i, annotations[i].asMap(factory, adaptations));\r\n            }\r\n            return result;\r\n        }\r\n        Object result = Array.newInstance(attribute.getReturnType().componentType(), annotations.length);\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            Array.set(result, i, annotations[i].synthesize());\r\n        }\r\n        return result;\r\n    }\r\n    return value;\r\n}\n@Override\r\n@SuppressWarnings(\"unchecked\")\r\nprotected A createSynthesizedAnnotation() {\r\n    // Check root annotation\r\n    if (this.rootAttributes instanceof Annotation ann && isTargetAnnotation(ann) && !isSynthesizable(ann)) {\r\n        return (A) ann;\r\n    }\r\n    // Check meta-annotation\r\n    Annotation meta = this.mapping.getAnnotation();\r\n    if (meta != null && isTargetAnnotation(meta) && !isSynthesizable(meta)) {\r\n        return (A) meta;\r\n    }\r\n    return SynthesizedMergedAnnotationInvocationHandler.createProxy(this, getType());\r\n}\n/**\r\n * Determine if the supplied object is an annotation of the required\r\n * {@linkplain #getType() type}.\r\n * @param obj the object to check\r\n * @since 5.3.22\r\n */\r\nprivate boolean isTargetAnnotation(Object obj) {\r\n    return getType().isInstance(obj);\r\n}\n/**\r\n * Determine if the supplied annotation has not already been synthesized\r\n * <strong>and</strong> whether the mapped annotation is a composed annotation\r\n * that needs to have its attributes merged or the mapped annotation is\r\n * {@linkplain AnnotationTypeMapping#isSynthesizable() synthesizable} in general.\r\n * @param annotation the annotation to check\r\n * @since 5.3.22\r\n */\r\nprivate boolean isSynthesizable(Annotation annotation) {\r\n    // Already synthesized?\r\n    if (AnnotationUtils.isSynthesizedAnnotation(annotation)) {\r\n        return false;\r\n    }\r\n    // Is this a mapped annotation for a composed annotation, and are there\r\n    // annotation attributes (mirrors) that need to be merged?\r\n    if (getDistance() > 0 && this.resolvedMirrors.length > 0) {\r\n        return true;\r\n    }\r\n    // Is the mapped annotation itself synthesizable?\r\n    return this.mapping.isSynthesizable();\r\n}\n@Override\r\n@Nullable\r\nprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\r\n    int attributeIndex = getAttributeIndex(attributeName, false);\r\n    return (attributeIndex != -1 ? getValue(attributeIndex, type) : null);\r\n}\nprivate Object getRequiredValue(int attributeIndex, String attributeName) {\r\n    Object value = getValue(attributeIndex, Object.class);\r\n    if (value == null) {\r\n        throw new NoSuchElementException(\"No element at attribute index \" + attributeIndex + \" for name \" + attributeName);\r\n    }\r\n    return value;\r\n}\n@Nullable\r\nprivate <T> T getValue(int attributeIndex, Class<T> type) {\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    Object value = getValue(attributeIndex, true, false);\r\n    if (value == null) {\r\n        value = attribute.getDefaultValue();\r\n    }\r\n    return adapt(attribute, value, type);\r\n}\n@Nullable\r\nprivate Object getValue(int attributeIndex, boolean useConventionMapping, boolean forMirrorResolution) {\r\n    AnnotationTypeMapping mapping = this.mapping;\r\n    if (this.useMergedValues) {\r\n        int mappedIndex = this.mapping.getAliasMapping(attributeIndex);\r\n        if (mappedIndex == -1 && useConventionMapping) {\r\n            mappedIndex = this.mapping.getConventionMapping(attributeIndex);\r\n        }\r\n        if (mappedIndex != -1) {\r\n            mapping = mapping.getRoot();\r\n            attributeIndex = mappedIndex;\r\n        }\r\n    }\r\n    if (!forMirrorResolution) {\r\n        attributeIndex = (mapping.getDistance() != 0 ? this.resolvedMirrors : this.resolvedRootMirrors)[attributeIndex];\r\n    }\r\n    if (attributeIndex == -1) {\r\n        return null;\r\n    }\r\n    if (mapping.getDistance() == 0) {\r\n        Method attribute = mapping.getAttributes().get(attributeIndex);\r\n        Object result = this.valueExtractor.extract(attribute, this.rootAttributes);\r\n        return (result != null ? result : attribute.getDefaultValue());\r\n    }\r\n    return getValueFromMetaAnnotation(attributeIndex, forMirrorResolution);\r\n}\n@Nullable\r\nprivate Object getValueFromMetaAnnotation(int attributeIndex, boolean forMirrorResolution) {\r\n    Object value = null;\r\n    if (this.useMergedValues || forMirrorResolution) {\r\n        value = this.mapping.getMappedAnnotationValue(attributeIndex, forMirrorResolution);\r\n    }\r\n    if (value == null) {\r\n        Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n        value = AnnotationUtils.invokeAnnotationMethod(attribute, this.mapping.getAnnotation());\r\n    }\r\n    return value;\r\n}\n@Nullable\r\nprivate Object getValueForMirrorResolution(Method attribute, @Nullable Object annotation) {\r\n    int attributeIndex = this.mapping.getAttributes().indexOf(attribute);\r\n    boolean valueAttribute = VALUE.equals(attribute.getName());\r\n    return getValue(attributeIndex, !valueAttribute, true);\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate <T> T adapt(Method attribute, @Nullable Object value, Class<T> type) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    value = adaptForAttribute(attribute, value);\r\n    type = getAdaptType(attribute, type);\r\n    if (value instanceof Class<?> clazz && type == String.class) {\r\n        value = clazz.getName();\r\n    } else if (value instanceof String str && type == Class.class) {\r\n        value = ClassUtils.resolveClassName(str, getClassLoader());\r\n    } else if (value instanceof Class<?>[] classes && type == String[].class) {\r\n        String[] names = new String[classes.length];\r\n        for (int i = 0; i < classes.length; i++) {\r\n            names[i] = classes[i].getName();\r\n        }\r\n        value = names;\r\n    } else if (value instanceof String[] names && type == Class[].class) {\r\n        Class<?>[] classes = new Class<?>[names.length];\r\n        for (int i = 0; i < names.length; i++) {\r\n            classes[i] = ClassUtils.resolveClassName(names[i], getClassLoader());\r\n        }\r\n        value = classes;\r\n    } else if (value instanceof MergedAnnotation<?> annotation && type.isAnnotation()) {\r\n        value = annotation.synthesize();\r\n    } else if (value instanceof MergedAnnotation<?>[] annotations && type.isArray() && type.componentType().isAnnotation()) {\r\n        Object array = Array.newInstance(type.componentType(), annotations.length);\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            Array.set(array, i, annotations[i].synthesize());\r\n        }\r\n        value = array;\r\n    }\r\n    if (!type.isInstance(value)) {\r\n        throw new IllegalArgumentException(\"Unable to adapt value of type \" + value.getClass().getName() + \" to \" + type.getName());\r\n    }\r\n    return (T) value;\r\n}\n@SuppressWarnings(\"unchecked\")\r\nprivate Object adaptForAttribute(Method attribute, Object value) {\r\n    Class<?> attributeType = ClassUtils.resolvePrimitiveIfNecessary(attribute.getReturnType());\r\n    if (attributeType.isArray() && !value.getClass().isArray()) {\r\n        Object array = Array.newInstance(value.getClass(), 1);\r\n        Array.set(array, 0, value);\r\n        return adaptForAttribute(attribute, array);\r\n    }\r\n    if (attributeType.isAnnotation()) {\r\n        return adaptToMergedAnnotation(value, (Class<? extends Annotation>) attributeType);\r\n    }\r\n    if (attributeType.isArray() && attributeType.componentType().isAnnotation()) {\r\n        MergedAnnotation<?>[] result = new MergedAnnotation<?>[Array.getLength(value)];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = adaptToMergedAnnotation(Array.get(value, i), (Class<? extends Annotation>) attributeType.componentType());\r\n        }\r\n        return result;\r\n    }\r\n    if ((attributeType == Class.class && value instanceof String) || (attributeType == Class[].class && value instanceof String[]) || (attributeType == String.class && value instanceof Class) || (attributeType == String[].class && value instanceof Class[])) {\r\n        return value;\r\n    }\r\n    if (attributeType.isArray() && isEmptyObjectArray(value)) {\r\n        return emptyArray(attributeType.componentType());\r\n    }\r\n    if (!attributeType.isInstance(value)) {\r\n        throw new IllegalStateException(\"Attribute '\" + attribute.getName() + \"' in annotation \" + getType().getName() + \" should be compatible with \" + attributeType.getName() + \" but a \" + value.getClass().getName() + \" value was returned\");\r\n    }\r\n    return value;\r\n}\nprivate boolean isEmptyObjectArray(Object value) {\r\n    return (value instanceof Object[] objects && objects.length == 0);\r\n}\nprivate Object emptyArray(Class<?> componentType) {\r\n    Object result = EMPTY_ARRAYS.get(componentType);\r\n    if (result == null) {\r\n        result = Array.newInstance(componentType, 0);\r\n    }\r\n    return result;\r\n}\nprivate MergedAnnotation<?> adaptToMergedAnnotation(Object value, Class<? extends Annotation> annotationType) {\r\n    if (value instanceof MergedAnnotation<?> mergedAnnotation) {\r\n        return mergedAnnotation;\r\n    }\r\n    AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\r\n    return new TypeMappedAnnotation<>(mapping, null, this.source, value, getValueExtractor(value), this.aggregateIndex);\r\n}\nprivate ValueExtractor getValueExtractor(Object value) {\r\n    if (value instanceof Annotation) {\r\n        return AnnotationUtils::invokeAnnotationMethod;\r\n    }\r\n    if (value instanceof Map) {\r\n        return TypeMappedAnnotation::extractFromMap;\r\n    }\r\n    return this.valueExtractor;\r\n}\n@SuppressWarnings(\"unchecked\")\r\nprivate <T> Class<T> getAdaptType(Method attribute, Class<T> type) {\r\n    if (type != Object.class) {\r\n        return type;\r\n    }\r\n    Class<?> attributeType = attribute.getReturnType();\r\n    if (attributeType.isAnnotation()) {\r\n        return (Class<T>) MergedAnnotation.class;\r\n    }\r\n    if (attributeType.isArray() && attributeType.componentType().isAnnotation()) {\r\n        return (Class<T>) MergedAnnotation[].class;\r\n    }\r\n    return (Class<T>) ClassUtils.resolvePrimitiveIfNecessary(attributeType);\r\n}\nprivate int getAttributeIndex(String attributeName, boolean required) {\r\n    Assert.hasText(attributeName, \"Attribute name must not be null\");\r\n    int attributeIndex = (isFiltered(attributeName) ? -1 : this.mapping.getAttributes().indexOf(attributeName));\r\n    if (attributeIndex == -1 && required) {\r\n        throw new NoSuchElementException(\"No attribute named '\" + attributeName + \"' present in merged annotation \" + getType().getName());\r\n    }\r\n    return attributeIndex;\r\n}\nprivate boolean isFiltered(String attributeName) {\r\n    if (this.attributeFilter != null) {\r\n        return !this.attributeFilter.test(attributeName);\r\n    }\r\n    return false;\r\n}\n@Nullable\r\nprivate ClassLoader getClassLoader() {\r\n    if (this.classLoader != null) {\r\n        return this.classLoader;\r\n    }\r\n    if (this.source != null) {\r\n        if (this.source instanceof Class<?> clazz) {\r\n            return clazz.getClassLoader();\r\n        }\r\n        if (this.source instanceof Member member) {\r\n            member.getDeclaringClass().getClassLoader();\r\n        }\r\n    }\r\n    return null;\r\n}\nstatic <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\r\n    Assert.notNull(annotation, \"Annotation must not be null\");\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType());\r\n    return new TypeMappedAnnotation<>(mappings.get(0), null, source, annotation, AnnotationUtils::invokeAnnotationMethod, 0);\r\n}\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable ClassLoader classLoader, @Nullable Object source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    Assert.notNull(annotationType, \"Annotation type must not be null\");\r\n    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotationType);\r\n    return new TypeMappedAnnotation<>(mappings.get(0), classLoader, source, attributes, TypeMappedAnnotation::extractFromMap, 0);\r\n}\n@Nullable\r\nstatic <A extends Annotation> TypeMappedAnnotation<A> createIfPossible(AnnotationTypeMapping mapping, MergedAnnotation<?> annotation, IntrospectionFailureLogger logger) {\r\n    if (annotation instanceof TypeMappedAnnotation<?> typeMappedAnnotation) {\r\n        return createIfPossible(mapping, typeMappedAnnotation.source, typeMappedAnnotation.rootAttributes, typeMappedAnnotation.valueExtractor, typeMappedAnnotation.aggregateIndex, logger);\r\n    }\r\n    return createIfPossible(mapping, annotation.getSource(), annotation.synthesize(), annotation.getAggregateIndex(), logger);\r\n}\n@Nullable\r\nstatic <A extends Annotation> TypeMappedAnnotation<A> createIfPossible(AnnotationTypeMapping mapping, @Nullable Object source, Annotation annotation, int aggregateIndex, IntrospectionFailureLogger logger) {\r\n    return createIfPossible(mapping, source, annotation, AnnotationUtils::invokeAnnotationMethod, aggregateIndex, logger);\r\n}\n@Nullable\r\nprivate static <A extends Annotation> TypeMappedAnnotation<A> createIfPossible(AnnotationTypeMapping mapping, @Nullable Object source, @Nullable Object rootAttribute, ValueExtractor valueExtractor, int aggregateIndex, IntrospectionFailureLogger logger) {\r\n    try {\r\n        return new TypeMappedAnnotation<>(mapping, null, source, rootAttribute, valueExtractor, aggregateIndex);\r\n    } catch (Exception ex) {\r\n        AnnotationUtils.rethrowAnnotationConfigurationException(ex);\r\n        if (logger.isEnabled()) {\r\n            String type = mapping.getAnnotationType().getName();\r\n            String item = (mapping.getDistance() == 0 ? \"annotation \" + type : \"meta-annotation \" + type + \" from \" + mapping.getRoot().getAnnotationType().getName());\r\n            logger.log(\"Failed to introspect \" + item, source, ex);\r\n        }\r\n        return null;\r\n    }\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nstatic Object extractFromMap(Method attribute, @Nullable Object map) {\r\n    return (map != null ? ((Map<String, ?>) map).get(attribute.getName()) : null);\r\n}",
    "comment": "\n * {@link MergedAnnotation} that adapts attributes from a root annotation by\n * applying the mapping and mirroring rules of an {@link AnnotationTypeMapping}.\n *\n * <p>Root attribute values are extracted from a source object using a supplied\n * {@code BiFunction}. This allows various different annotation models to be\n * supported by the same class. For example, the attributes source might be an\n * actual {@link Annotation} instance where methods on the annotation instance\n * are {@linkplain AnnotationUtils#invokeAnnotationMethod(Method, Object) invoked}\n * to extract values. Similarly, the source could be a simple {@link Map} with\n * values extracted using {@link Map#get(Object)}.\n *\n * <p>Extracted root attribute values must be compatible with the attribute\n * return type, namely:\n *\n * <p><table border=\"1\">\n * <tr><th>Return Type</th><th>Extracted Type</th></tr>\n * <tr><td>Class</td><td>Class or String</td></tr>\n * <tr><td>Class[]</td><td>Class[] or String[]</td></tr>\n * <tr><td>Annotation</td><td>Annotation, Map, or Object compatible with the value\n * extractor</td></tr>\n * <tr><td>Annotation[]</td><td>Annotation[], Map[], or Object[] where elements are\n * compatible with the value extractor</td></tr>\n * <tr><td>Other types</td><td>An exact match or the appropriate primitive wrapper</td></tr>\n * </table>\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 5.2\n * @param <A> the annotation type\n * @see TypeMappedAnnotations\n "
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getType()",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic Class<A> getType() {\r\n    return (Class<A>) this.mapping.getAnnotationType();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getMetaTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic List<Class<? extends Annotation>> getMetaTypes() {\r\n    return this.mapping.getMetaTypes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#isPresent()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isPresent() {\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getDistance()",
    "entityType": "method",
    "code": "@Override\r\npublic int getDistance() {\r\n    return this.mapping.getDistance();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getAggregateIndex()",
    "entityType": "method",
    "code": "@Override\r\npublic int getAggregateIndex() {\r\n    return this.aggregateIndex;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getSource()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Object getSource() {\r\n    return this.source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getMetaSource()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic MergedAnnotation<?> getMetaSource() {\r\n    AnnotationTypeMapping metaSourceMapping = this.mapping.getSource();\r\n    if (metaSourceMapping == null) {\r\n        return null;\r\n    }\r\n    return new TypeMappedAnnotation<>(metaSourceMapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getRoot()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<?> getRoot() {\r\n    if (getDistance() == 0) {\r\n        return this;\r\n    }\r\n    AnnotationTypeMapping rootMapping = this.mapping.getRoot();\r\n    return new TypeMappedAnnotation<>(rootMapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#hasDefaultValue(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasDefaultValue(String attributeName) {\r\n    int attributeIndex = getAttributeIndex(attributeName, true);\r\n    Object value = getValue(attributeIndex, true, false);\r\n    return (value == null || this.mapping.isEquivalentToDefaultValue(attributeIndex, value, this.valueExtractor));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getAnnotation(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    int attributeIndex = getAttributeIndex(attributeName, true);\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    Assert.isAssignable(type, attribute.getReturnType(), () -> \"Attribute \" + attributeName + \" type mismatch:\");\r\n    return (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getAnnotationArray(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray(String attributeName, Class<T> type) throws NoSuchElementException {\r\n    int attributeIndex = getAttributeIndex(attributeName, true);\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    Class<?> componentType = attribute.getReturnType().componentType();\r\n    Assert.notNull(type, \"Type must not be null\");\r\n    Assert.notNull(componentType, () -> \"Attribute \" + attributeName + \" is not an array\");\r\n    Assert.isAssignable(type, componentType, () -> \"Attribute \" + attributeName + \" component type mismatch:\");\r\n    return (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getDefaultValue(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\npublic <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {\r\n    int attributeIndex = getAttributeIndex(attributeName, false);\r\n    if (attributeIndex == -1) {\r\n        return Optional.empty();\r\n    }\r\n    Method attribute = this.mapping.getAttributes().get(attributeIndex);\r\n    return Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#filterAttributes(Predicate<String>)",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {\r\n    if (this.attributeFilter != null) {\r\n        predicate = this.attributeFilter.and(predicate);\r\n    }\r\n    return new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.useMergedValues, predicate, this.resolvedRootMirrors, this.resolvedMirrors);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#withNonMergedAttributes()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotation<A> withNonMergedAttributes() {\r\n    return new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes, this.valueExtractor, this.aggregateIndex, false, this.attributeFilter, this.resolvedRootMirrors, this.resolvedMirrors);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#asMap(Adapt)",
    "entityType": "method",
    "code": "@Override\r\npublic Map<String, Object> asMap(Adapt... adaptations) {\r\n    return Collections.unmodifiableMap(asMap(mergedAnnotation -> new LinkedHashMap<>(), adaptations));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#asMap(Function<MergedAnnotation<?>,T>,Adapt)",
    "entityType": "method",
    "code": "@Override\r\npublic <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {\r\n    T map = factory.apply(this);\r\n    Assert.state(map != null, \"Factory used to create MergedAnnotation Map must not return null\");\r\n    AttributeMethods attributes = this.mapping.getAttributes();\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        Method attribute = attributes.get(i);\r\n        Object value = (isFiltered(attribute.getName()) ? null : getValue(i, getTypeForMapOptions(attribute, adaptations)));\r\n        if (value != null) {\r\n            map.put(attribute.getName(), adaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));\r\n        }\r\n    }\r\n    return map;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getTypeForMapOptions(Method,Adapt[])",
    "entityType": "method",
    "code": "private Class<?> getTypeForMapOptions(Method attribute, Adapt[] adaptations) {\r\n    Class<?> attributeType = attribute.getReturnType();\r\n    Class<?> componentType = (attributeType.isArray() ? attributeType.componentType() : attributeType);\r\n    if (Adapt.CLASS_TO_STRING.isIn(adaptations) && componentType == Class.class) {\r\n        return (attributeType.isArray() ? String[].class : String.class);\r\n    }\r\n    return Object.class;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#adaptValueForMapOptions(Method,Object,Class<?>,Function<MergedAnnotation<?>,T>,Adapt[])",
    "entityType": "method",
    "code": "private <T extends Map<String, Object>> Object adaptValueForMapOptions(Method attribute, Object value, Class<?> mapType, Function<MergedAnnotation<?>, T> factory, Adapt[] adaptations) {\r\n    if (value instanceof MergedAnnotation<?> annotation) {\r\n        return (Adapt.ANNOTATION_TO_MAP.isIn(adaptations) ? annotation.asMap(factory, adaptations) : annotation.synthesize());\r\n    }\r\n    if (value instanceof MergedAnnotation<?>[] annotations) {\r\n        if (Adapt.ANNOTATION_TO_MAP.isIn(adaptations)) {\r\n            Object result = Array.newInstance(mapType, annotations.length);\r\n            for (int i = 0; i < annotations.length; i++) {\r\n                Array.set(result, i, annotations[i].asMap(factory, adaptations));\r\n            }\r\n            return result;\r\n        }\r\n        Object result = Array.newInstance(attribute.getReturnType().componentType(), annotations.length);\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            Array.set(result, i, annotations[i].synthesize());\r\n        }\r\n        return result;\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#createSynthesizedAnnotation()",
    "entityType": "method",
    "code": "@Override\r\n@SuppressWarnings(\"unchecked\")\r\nprotected A createSynthesizedAnnotation() {\r\n    // Check root annotation\r\n    if (this.rootAttributes instanceof Annotation ann && isTargetAnnotation(ann) && !isSynthesizable(ann)) {\r\n        return (A) ann;\r\n    }\r\n    // Check meta-annotation\r\n    Annotation meta = this.mapping.getAnnotation();\r\n    if (meta != null && isTargetAnnotation(meta) && !isSynthesizable(meta)) {\r\n        return (A) meta;\r\n    }\r\n    return SynthesizedMergedAnnotationInvocationHandler.createProxy(this, getType());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#isTargetAnnotation(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied object is an annotation of the required\r\n * {@linkplain #getType() type}.\r\n * @param obj the object to check\r\n * @since 5.3.22\r\n */\r\nprivate boolean isTargetAnnotation(Object obj) {\r\n    return getType().isInstance(obj);\r\n}",
    "comment": "\n\t * Determine if the supplied object is an annotation of the required\n\t * {@linkplain #getType() type}.\n\t * @param obj the object to check\n\t * @since 5.3.22\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#isSynthesizable(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied annotation has not already been synthesized\r\n * <strong>and</strong> whether the mapped annotation is a composed annotation\r\n * that needs to have its attributes merged or the mapped annotation is\r\n * {@linkplain AnnotationTypeMapping#isSynthesizable() synthesizable} in general.\r\n * @param annotation the annotation to check\r\n * @since 5.3.22\r\n */\r\nprivate boolean isSynthesizable(Annotation annotation) {\r\n    // Already synthesized?\r\n    if (AnnotationUtils.isSynthesizedAnnotation(annotation)) {\r\n        return false;\r\n    }\r\n    // Is this a mapped annotation for a composed annotation, and are there\r\n    // annotation attributes (mirrors) that need to be merged?\r\n    if (getDistance() > 0 && this.resolvedMirrors.length > 0) {\r\n        return true;\r\n    }\r\n    // Is the mapped annotation itself synthesizable?\r\n    return this.mapping.isSynthesizable();\r\n}",
    "comment": "\n\t * Determine if the supplied annotation has not already been synthesized\n\t * <strong>and</strong> whether the mapped annotation is a composed annotation\n\t * that needs to have its attributes merged or the mapped annotation is\n\t * {@linkplain AnnotationTypeMapping#isSynthesizable() synthesizable} in general.\n\t * @param annotation the annotation to check\n\t * @since 5.3.22\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getAttributeValue(String,Class<T>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected <T> T getAttributeValue(String attributeName, Class<T> type) {\r\n    int attributeIndex = getAttributeIndex(attributeName, false);\r\n    return (attributeIndex != -1 ? getValue(attributeIndex, type) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TypeMappedAnnotation#getRequiredValue(int,String)",
    "entityType": "method",
    "code": "private Object getRequiredValue(int attributeIndex, String attributeName) {\r\n    Object value = getValue(attributeIndex, Object.class);\r\n    if (value == null) {\r\n        throw new NoSuchElementException(\"No element at attribute index \" + attributeIndex + \" for name \" + attributeName);\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  }
]