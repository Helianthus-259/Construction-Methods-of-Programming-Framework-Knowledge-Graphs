[
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getIntArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getIntArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getIntArray(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getLongThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getLongThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getLong(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getLongArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getLongArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getLongArray(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getDoubleThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDoubleThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getDouble(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getDoubleArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDoubleArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getDoubleArray(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getFloatThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFloatThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getFloat(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getFloatArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getFloatArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getFloatArray(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getStringThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getStringThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getString(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getStringArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getStringArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getStringArray(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getClassThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getClassThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getClass(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getClassArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getClassArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getClassArray(\"value\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getEnumThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getEnumThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getEnum(\"value\", TestEnum.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getEnumArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getEnumArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getEnumArray(\"value\", TestEnum.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getAnnotationThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getAnnotation(\"value\", TestAnnotation.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getAnnotationArrayThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAnnotationArrayThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.getAnnotationArray(\"value\", TestAnnotation.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getValueReturnsEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid getValueReturnsEmpty() {\r\n    assertThat(this.missing.getValue(\"value\", Integer.class)).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#getDefaultValueReturnsEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultValueReturnsEmpty() {\r\n    assertThat(this.missing.getDefaultValue(\"value\", Integer.class)).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#synthesizeThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(this.missing::synthesize);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#synthesizeWithPredicateWhenPredicateMatchesThrowsNoSuchElementException()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithPredicateWhenPredicateMatchesThrowsNoSuchElementException() {\r\n    assertThatNoSuchElementException().isThrownBy(() -> this.missing.synthesize(annotation -> true));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#synthesizeWithPredicateWhenPredicateDoesNotMatchReturnsEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizeWithPredicateWhenPredicateDoesNotMatchReturnsEmpty() {\r\n    assertThat(this.missing.synthesize(annotation -> false)).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#toStringReturnsString()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStringReturnsString() {\r\n    assertThat(this.missing.toString()).isEqualTo(\"(missing)\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#asAnnotationAttributesReturnsNewAnnotationAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid asAnnotationAttributesReturnsNewAnnotationAttributes() {\r\n    AnnotationAttributes attributes = this.missing.asAnnotationAttributes();\r\n    assertThat(attributes).isEmpty();\r\n    assertThat(this.missing.asAnnotationAttributes()).isNotSameAs(attributes);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#asMapReturnsEmptyMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid asMapReturnsEmptyMap() {\r\n    Map<String, Object> map = this.missing.asMap();\r\n    assertThat(map).isSameAs(Collections.EMPTY_MAP);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#asMapWithFactoryReturnsNewMapFromFactory()",
    "entityType": "method",
    "code": "@Test\r\nvoid asMapWithFactoryReturnsNewMapFromFactory() {\r\n    Map<String, Object> map = this.missing.asMap(annotation -> new ConcurrentReferenceHashMap<>());\r\n    assertThat(map).isInstanceOf(ConcurrentReferenceHashMap.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MissingMergedAnnotationTests#assertThatNoSuchElementException()",
    "entityType": "method",
    "code": "private static ThrowableTypeAssert<NoSuchElementException> assertThatNoSuchElementException() {\r\n    return assertThatExceptionOfType(NoSuchElementException.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests",
    "entityType": "class",
    "code": "@Test\r\nvoid getMultipleComposedAnnotationsOnClass() {\r\n    assertGetAllMergedAnnotationsBehavior(MultipleComposedCachesClass.class);\r\n}\n@Test\r\nvoid getMultipleInheritedComposedAnnotationsOnSuperclass() {\r\n    assertGetAllMergedAnnotationsBehavior(SubMultipleComposedCachesClass.class);\r\n}\n@Test\r\nvoid getMultipleNoninheritedComposedAnnotationsOnClass() {\r\n    Class<?> element = MultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable cacheable1 = iterator.next();\r\n    Cacheable cacheable2 = iterator.next();\r\n    assertThat(cacheable1.value()).isEqualTo(\"noninheritedCache1\");\r\n    assertThat(cacheable2.value()).isEqualTo(\"noninheritedCache2\");\r\n}\n@Test\r\nvoid getMultipleNoninheritedComposedAnnotationsOnSuperclass() {\r\n    Class<?> element = SubMultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).isEmpty();\r\n}\n@Test\r\nvoid getComposedPlusLocalAnnotationsOnClass() {\r\n    assertGetAllMergedAnnotationsBehavior(ComposedPlusLocalCachesClass.class);\r\n}\n@Test\r\nvoid getMultipleComposedAnnotationsOnInterface() {\r\n    Class<MultipleComposedCachesOnInterfaceClass> element = MultipleComposedCachesOnInterfaceClass.class;\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).isEmpty();\r\n}\n@Test\r\nvoid getMultipleComposedAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"multipleComposedCachesMethod\");\r\n    assertGetAllMergedAnnotationsBehavior(element);\r\n}\n@Test\r\nvoid getComposedPlusLocalAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\");\r\n    assertGetAllMergedAnnotationsBehavior(element);\r\n}\n@Test\r\n@Disabled(\"Disabled since some Java 8 updates handle the bridge method differently\")\r\nvoid getMultipleComposedAnnotationsOnBridgeMethod() {\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(getBridgeMethod(), Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).isEmpty();\r\n}\n@Test\r\nvoid findMultipleComposedAnnotationsOnClass() {\r\n    assertFindAllMergedAnnotationsBehavior(MultipleComposedCachesClass.class);\r\n}\n@Test\r\nvoid findMultipleInheritedComposedAnnotationsOnSuperclass() {\r\n    assertFindAllMergedAnnotationsBehavior(SubMultipleComposedCachesClass.class);\r\n}\n@Test\r\nvoid findMultipleNoninheritedComposedAnnotationsOnClass() {\r\n    Class<?> element = MultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = findAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable cacheable1 = iterator.next();\r\n    Cacheable cacheable2 = iterator.next();\r\n    assertThat(cacheable1.value()).isEqualTo(\"noninheritedCache1\");\r\n    assertThat(cacheable2.value()).isEqualTo(\"noninheritedCache2\");\r\n}\n@Test\r\nvoid findMultipleNoninheritedComposedAnnotationsOnSuperclass() {\r\n    Class<?> element = SubMultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = findAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable cacheable1 = iterator.next();\r\n    Cacheable cacheable2 = iterator.next();\r\n    assertThat(cacheable1.value()).isEqualTo(\"noninheritedCache1\");\r\n    assertThat(cacheable2.value()).isEqualTo(\"noninheritedCache2\");\r\n}\n@Test\r\nvoid findComposedPlusLocalAnnotationsOnClass() {\r\n    assertFindAllMergedAnnotationsBehavior(ComposedPlusLocalCachesClass.class);\r\n}\n@Test\r\nvoid findMultipleComposedAnnotationsOnInterface() {\r\n    assertFindAllMergedAnnotationsBehavior(MultipleComposedCachesOnInterfaceClass.class);\r\n}\n@Test\r\nvoid findComposedCacheOnInterfaceAndLocalCacheOnClass() {\r\n    assertFindAllMergedAnnotationsBehavior(ComposedCacheOnInterfaceAndLocalCacheClass.class);\r\n}\n@Test\r\nvoid findMultipleComposedAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"multipleComposedCachesMethod\");\r\n    assertFindAllMergedAnnotationsBehavior(element);\r\n}\n@Test\r\nvoid findComposedPlusLocalAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\");\r\n    assertFindAllMergedAnnotationsBehavior(element);\r\n}\n@Test\r\nvoid findMultipleComposedAnnotationsOnBridgeMethod() {\r\n    assertFindAllMergedAnnotationsBehavior(getBridgeMethod());\r\n}\n/**\r\n * Bridge/bridged method setup code copied from\r\n * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\r\n */\r\nMethod getBridgeMethod() {\r\n    Method[] methods = StringGenericParameter.class.getMethods();\r\n    Method bridgeMethod = null;\r\n    Method bridgedMethod = null;\r\n    for (Method method : methods) {\r\n        if (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\r\n            if (method.getReturnType().equals(Object.class)) {\r\n                bridgeMethod = method;\r\n            } else {\r\n                bridgedMethod = method;\r\n            }\r\n        }\r\n    }\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    boolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\r\n    assertThat(condition).isTrue();\r\n    return bridgeMethod;\r\n}\nprivate void assertGetAllMergedAnnotationsBehavior(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable fooCacheable = iterator.next();\r\n    Cacheable barCacheable = iterator.next();\r\n    assertThat(fooCacheable.key()).isEqualTo(\"fooKey\");\r\n    assertThat(fooCacheable.value()).isEqualTo(\"fooCache\");\r\n    assertThat(barCacheable.key()).isEqualTo(\"barKey\");\r\n    assertThat(barCacheable.value()).isEqualTo(\"barCache\");\r\n}\nprivate void assertFindAllMergedAnnotationsBehavior(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<Cacheable> cacheables = findAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable fooCacheable = iterator.next();\r\n    Cacheable barCacheable = iterator.next();\r\n    assertThat(fooCacheable.key()).isEqualTo(\"fooKey\");\r\n    assertThat(fooCacheable.value()).isEqualTo(\"fooCache\");\r\n    assertThat(barCacheable.key()).isEqualTo(\"barKey\");\r\n    assertThat(barCacheable.value()).isEqualTo(\"barCache\");\r\n}\n// -------------------------------------------------------------------------\r\n/**\r\n * Mock of {@code org.springframework.cache.annotation.Cacheable}.\r\n */\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface Cacheable {\r\n\r\n    @AliasFor(\"cacheName\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(\"value\")\r\n    String cacheName() default \"\";\r\n\r\n    String key() default \"\";\r\n}\n@Cacheable(\"fooCache\")\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface FooCache {\r\n\r\n    @AliasFor(annotation = Cacheable.class)\r\n    String key() default \"\";\r\n}\n@Cacheable(\"barCache\")\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface BarCache {\r\n\r\n    @AliasFor(annotation = Cacheable.class)\r\n    String key();\r\n}\n@Cacheable(\"noninheritedCache1\")\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NoninheritedCache1 {\r\n\r\n    @AliasFor(annotation = Cacheable.class)\r\n    String key() default \"\";\r\n}\n@Cacheable(\"noninheritedCache2\")\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NoninheritedCache2 {\r\n\r\n    @AliasFor(annotation = Cacheable.class)\r\n    String key() default \"\";\r\n}\n@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate static class MultipleComposedCachesClass {\r\n}\nprivate static class SubMultipleComposedCachesClass extends MultipleComposedCachesClass {\r\n}\n@NoninheritedCache1\r\n@NoninheritedCache2\r\nprivate static class MultipleNoninheritedComposedCachesClass {\r\n}\nprivate static class SubMultipleNoninheritedComposedCachesClass extends MultipleNoninheritedComposedCachesClass {\r\n}\n@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate static class ComposedPlusLocalCachesClass {\r\n}\n@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate interface MultipleComposedCachesInterface {\r\n}\nprivate static class MultipleComposedCachesOnInterfaceClass implements MultipleComposedCachesInterface {\r\n}\n@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\r\nprivate interface ComposedCacheInterface {\r\n}\n@BarCache(key = \"barKey\")\r\nprivate static class ComposedCacheOnInterfaceAndLocalCacheClass implements ComposedCacheInterface {\r\n}\n@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate void multipleComposedCachesMethod() ;\n@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate void composedPlusLocalCachesMethod() ;\npublic interface GenericParameter<T> {\r\n\r\n    T getFor(Class<T> cls);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class StringGenericParameter implements GenericParameter<String> {\r\n\r\n    @FooCache(key = \"fooKey\")\r\n    @BarCache(key = \"barKey\")\r\n    @Override\r\n    public String getFor(Class<String> cls) {\r\n        return \"foo\";\r\n    }\r\n\r\n    public String getFor(Integer integer) {\r\n        return \"foo\";\r\n    }\r\n}",
    "comment": "\n * Unit tests that verify support for finding multiple composed annotations on\n * a single annotated element.\n *\n * <p>See <a href=\"https://jira.spring.io/browse/SPR-13486\">SPR-13486</a>.\n *\n * @author Sam Brannen\n * @since 4.3\n * @see AnnotatedElementUtils\n * @see AnnotatedElementUtilsTests\n * @see ComposedRepeatableAnnotationsTests\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleComposedAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMultipleComposedAnnotationsOnClass() {\r\n    assertGetAllMergedAnnotationsBehavior(MultipleComposedCachesClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleInheritedComposedAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMultipleInheritedComposedAnnotationsOnSuperclass() {\r\n    assertGetAllMergedAnnotationsBehavior(SubMultipleComposedCachesClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleNoninheritedComposedAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMultipleNoninheritedComposedAnnotationsOnClass() {\r\n    Class<?> element = MultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable cacheable1 = iterator.next();\r\n    Cacheable cacheable2 = iterator.next();\r\n    assertThat(cacheable1.value()).isEqualTo(\"noninheritedCache1\");\r\n    assertThat(cacheable2.value()).isEqualTo(\"noninheritedCache2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleNoninheritedComposedAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMultipleNoninheritedComposedAnnotationsOnSuperclass() {\r\n    Class<?> element = SubMultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getComposedPlusLocalAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComposedPlusLocalAnnotationsOnClass() {\r\n    assertGetAllMergedAnnotationsBehavior(ComposedPlusLocalCachesClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleComposedAnnotationsOnInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMultipleComposedAnnotationsOnInterface() {\r\n    Class<MultipleComposedCachesOnInterfaceClass> element = MultipleComposedCachesOnInterfaceClass.class;\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleComposedAnnotationsOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMultipleComposedAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"multipleComposedCachesMethod\");\r\n    assertGetAllMergedAnnotationsBehavior(element);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getComposedPlusLocalAnnotationsOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComposedPlusLocalAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\");\r\n    assertGetAllMergedAnnotationsBehavior(element);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getMultipleComposedAnnotationsOnBridgeMethod()",
    "entityType": "method",
    "code": "@Test\r\n@Disabled(\"Disabled since some Java 8 updates handle the bridge method differently\")\r\nvoid getMultipleComposedAnnotationsOnBridgeMethod() {\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(getBridgeMethod(), Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleComposedAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleComposedAnnotationsOnClass() {\r\n    assertFindAllMergedAnnotationsBehavior(MultipleComposedCachesClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleInheritedComposedAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleInheritedComposedAnnotationsOnSuperclass() {\r\n    assertFindAllMergedAnnotationsBehavior(SubMultipleComposedCachesClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleNoninheritedComposedAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleNoninheritedComposedAnnotationsOnClass() {\r\n    Class<?> element = MultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = findAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable cacheable1 = iterator.next();\r\n    Cacheable cacheable2 = iterator.next();\r\n    assertThat(cacheable1.value()).isEqualTo(\"noninheritedCache1\");\r\n    assertThat(cacheable2.value()).isEqualTo(\"noninheritedCache2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleNoninheritedComposedAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleNoninheritedComposedAnnotationsOnSuperclass() {\r\n    Class<?> element = SubMultipleNoninheritedComposedCachesClass.class;\r\n    Set<Cacheable> cacheables = findAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable cacheable1 = iterator.next();\r\n    Cacheable cacheable2 = iterator.next();\r\n    assertThat(cacheable1.value()).isEqualTo(\"noninheritedCache1\");\r\n    assertThat(cacheable2.value()).isEqualTo(\"noninheritedCache2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findComposedPlusLocalAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findComposedPlusLocalAnnotationsOnClass() {\r\n    assertFindAllMergedAnnotationsBehavior(ComposedPlusLocalCachesClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleComposedAnnotationsOnInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleComposedAnnotationsOnInterface() {\r\n    assertFindAllMergedAnnotationsBehavior(MultipleComposedCachesOnInterfaceClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findComposedCacheOnInterfaceAndLocalCacheOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findComposedCacheOnInterfaceAndLocalCacheOnClass() {\r\n    assertFindAllMergedAnnotationsBehavior(ComposedCacheOnInterfaceAndLocalCacheClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleComposedAnnotationsOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleComposedAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"multipleComposedCachesMethod\");\r\n    assertFindAllMergedAnnotationsBehavior(element);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findComposedPlusLocalAnnotationsOnMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findComposedPlusLocalAnnotationsOnMethod() throws Exception {\r\n    AnnotatedElement element = getClass().getDeclaredMethod(\"composedPlusLocalCachesMethod\");\r\n    assertFindAllMergedAnnotationsBehavior(element);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#findMultipleComposedAnnotationsOnBridgeMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMultipleComposedAnnotationsOnBridgeMethod() {\r\n    assertFindAllMergedAnnotationsBehavior(getBridgeMethod());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#getBridgeMethod()",
    "entityType": "method",
    "code": "/**\r\n * Bridge/bridged method setup code copied from\r\n * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\r\n */\r\nMethod getBridgeMethod() {\r\n    Method[] methods = StringGenericParameter.class.getMethods();\r\n    Method bridgeMethod = null;\r\n    Method bridgedMethod = null;\r\n    for (Method method : methods) {\r\n        if (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\r\n            if (method.getReturnType().equals(Object.class)) {\r\n                bridgeMethod = method;\r\n            } else {\r\n                bridgedMethod = method;\r\n            }\r\n        }\r\n    }\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    boolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\r\n    assertThat(condition).isTrue();\r\n    return bridgeMethod;\r\n}",
    "comment": "\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#assertGetAllMergedAnnotationsBehavior(AnnotatedElement)",
    "entityType": "method",
    "code": "private void assertGetAllMergedAnnotationsBehavior(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<Cacheable> cacheables = getAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable fooCacheable = iterator.next();\r\n    Cacheable barCacheable = iterator.next();\r\n    assertThat(fooCacheable.key()).isEqualTo(\"fooKey\");\r\n    assertThat(fooCacheable.value()).isEqualTo(\"fooCache\");\r\n    assertThat(barCacheable.key()).isEqualTo(\"barKey\");\r\n    assertThat(barCacheable.value()).isEqualTo(\"barCache\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#assertFindAllMergedAnnotationsBehavior(AnnotatedElement)",
    "entityType": "method",
    "code": "private void assertFindAllMergedAnnotationsBehavior(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<Cacheable> cacheables = findAllMergedAnnotations(element, Cacheable.class);\r\n    assertThat(cacheables).isNotNull();\r\n    assertThat(cacheables).hasSize(2);\r\n    Iterator<Cacheable> iterator = cacheables.iterator();\r\n    Cacheable fooCacheable = iterator.next();\r\n    Cacheable barCacheable = iterator.next();\r\n    assertThat(fooCacheable.key()).isEqualTo(\"fooKey\");\r\n    assertThat(fooCacheable.value()).isEqualTo(\"fooCache\");\r\n    assertThat(barCacheable.key()).isEqualTo(\"barKey\");\r\n    assertThat(barCacheable.value()).isEqualTo(\"barCache\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#multipleComposedCachesMethod()",
    "entityType": "method",
    "code": "@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate void multipleComposedCachesMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedAnnotationsOnSingleAnnotatedElementTests#composedPlusLocalCachesMethod()",
    "entityType": "method",
    "code": "@Cacheable(cacheName = \"fooCache\", key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\nprivate void composedPlusLocalCachesMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedCachesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubMultipleComposedCachesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleNoninheritedComposedCachesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubMultipleNoninheritedComposedCachesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedPlusLocalCachesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedCachesInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleComposedCachesOnInterfaceClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedCacheInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedCacheOnInterfaceAndLocalCacheClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.GenericParameter",
    "entityType": "class",
    "code": "T getFor(Class<T> cls);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.GenericParameter#getFor(Class<T>)",
    "entityType": "method",
    "code": "T getFor(Class<T> cls);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StringGenericParameter",
    "entityType": "class",
    "code": "@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\n@Override\r\npublic String getFor(Class<String> cls) {\r\n    return \"foo\";\r\n}\npublic String getFor(Integer integer) {\r\n    return \"foo\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StringGenericParameter#getFor(Class<String>)",
    "entityType": "method",
    "code": "@FooCache(key = \"fooKey\")\r\n@BarCache(key = \"barKey\")\r\n@Override\r\npublic String getFor(Class<String> cls) {\r\n    return \"foo\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.StringGenericParameter#getFor(Integer)",
    "entityType": "method",
    "code": "public String getFor(Integer integer) {\r\n    return \"foo\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.NestedRepeatableAnnotationsTests",
    "entityType": "class",
    "code": "@Nested\r\nclass SingleRepeatableAnnotationTests {\r\n\r\n    private final Method method = ReflectionUtils.findMethod(getClass(), \"annotatedMethod\");\r\n\r\n    @Test\r\n    void streamRepeatableAnnotations_MergedAnnotationsApi() {\r\n        Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n        // Merged, so we expect to find @A once with its value coming from @B(5).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5);\r\n    }\r\n\r\n    @Test\r\n    void findMergedRepeatableAnnotations_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class);\r\n        // Merged, so we expect to find @A once with its value coming from @B(5).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5);\r\n    }\r\n\r\n    @Test\r\n    void getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class);\r\n        // Merged, so we expect to find @A once with its value coming from @B(5).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5);\r\n    }\r\n\r\n    @Test\r\n    void getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n        // Merged, so we expect to find @A once with its value coming from @B(5).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5);\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void getRepeatableAnnotations_AnnotationUtils() {\r\n        Set<A> annotations = AnnotationUtils.getRepeatableAnnotations(method, A.class);\r\n        // Not merged, so we expect to find @A once with the default value of 0.\r\n        // @A will actually be found twice, but we have Set semantics here.\r\n        assertThat(annotations).extracting(A::value).containsExactly(0);\r\n    }\r\n\r\n    @B(5)\r\n    void annotatedMethod() {\r\n    }\r\n}\n@Nested\r\nclass MultipleRepeatableAnnotationsTests {\r\n\r\n    private final Method method = ReflectionUtils.findMethod(getClass(), \"annotatedMethod\");\r\n\r\n    @Test\r\n    void streamRepeatableAnnotationsWithStandardRepeatables_MergedAnnotationsApi() {\r\n        RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables();\r\n        Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, repeatableContainers).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n        // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n    }\r\n\r\n    @Test\r\n    void streamRepeatableAnnotationsWithExplicitRepeatables_MergedAnnotationsApi() {\r\n        RepeatableContainers repeatableContainers = RepeatableContainers.of(A.class, A.Container.class).and(B.Container.class, B.class);\r\n        Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, repeatableContainers).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n        // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n    }\r\n\r\n    @Test\r\n    void findMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class);\r\n        // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n    }\r\n\r\n    @Test\r\n    void findMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n        // When findMergedRepeatableAnnotations(...) is invoked with an explicit container\r\n        // type, it uses RepeatableContainers.of(...) which limits the repeatable annotation\r\n        // support to a single container type.\r\n        //\r\n        // In this test case, we are therefore limiting the support to @A.Container, which\r\n        // means that @B.Container is unsupported and effectively ignored as a repeatable\r\n        // container type.\r\n        //\r\n        // Long story, short: the search doesn't find anything.\r\n        assertThat(annotations).isEmpty();\r\n    }\r\n\r\n    @Test\r\n    void getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class);\r\n        // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n        assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n    }\r\n\r\n    @Test\r\n    void getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n        Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n        // When getMergedRepeatableAnnotations(...) is invoked with an explicit container\r\n        // type, it uses RepeatableContainers.of(...) which limits the repeatable annotation\r\n        // support to a single container type.\r\n        //\r\n        // In this test case, we are therefore limiting the support to @A.Container, which\r\n        // means that @B.Container is unsupported and effectively ignored as a repeatable\r\n        // container type.\r\n        //\r\n        // Long story, short: the search doesn't find anything.\r\n        assertThat(annotations).isEmpty();\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void getRepeatableAnnotations_AnnotationUtils() {\r\n        Set<A> annotations = AnnotationUtils.getRepeatableAnnotations(method, A.class);\r\n        // Not merged, so we expect to find a single @A with default value of 0.\r\n        // @A will actually be found twice, but we have Set semantics here.\r\n        assertThat(annotations).extracting(A::value).containsExactly(0);\r\n    }\r\n\r\n    @B(5)\r\n    @B(10)\r\n    void annotatedMethod() {\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })\r\n@Repeatable(A.Container.class)\r\n@interface A {\r\n\r\n    int value() default 0;\r\n\r\n    @Retention(RetentionPolicy.RUNTIME)\r\n    @Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })\r\n    @interface Container {\r\n\r\n        A[] value();\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })\r\n@Repeatable(B.Container.class)\r\n@A\r\n@A\r\n@interface B {\r\n\r\n    @AliasFor(annotation = A.class)\r\n    int value();\r\n\r\n    @Retention(RetentionPolicy.RUNTIME)\r\n    @Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })\r\n    @interface Container {\r\n\r\n        B[] value();\r\n    }\r\n}",
    "comment": "\n * Tests for various ways to search for repeatable annotations that are\n * nested (i.e., repeatable annotations used as meta-annotations on other\n * repeatable annotations).\n *\n * @author Sam Brannen\n * @since 5.3.24\n "
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests",
    "entityType": "class",
    "code": "private final Method method = ReflectionUtils.findMethod(getClass(), \"annotatedMethod\");\n@Test\r\nvoid streamRepeatableAnnotations_MergedAnnotationsApi() {\r\n    Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}\n@Test\r\nvoid findMergedRepeatableAnnotations_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}\n@Test\r\nvoid getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}\n@Test\r\nvoid getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid getRepeatableAnnotations_AnnotationUtils() {\r\n    Set<A> annotations = AnnotationUtils.getRepeatableAnnotations(method, A.class);\r\n    // Not merged, so we expect to find @A once with the default value of 0.\r\n    // @A will actually be found twice, but we have Set semantics here.\r\n    assertThat(annotations).extracting(A::value).containsExactly(0);\r\n}\n@B(5)\r\nvoid annotatedMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests#streamRepeatableAnnotations_MergedAnnotationsApi()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableAnnotations_MergedAnnotationsApi() {\r\n    Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests#findMergedRepeatableAnnotations_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedRepeatableAnnotations_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests#getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests#getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n    // Merged, so we expect to find @A once with its value coming from @B(5).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests#getRepeatableAnnotations_AnnotationUtils()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid getRepeatableAnnotations_AnnotationUtils() {\r\n    Set<A> annotations = AnnotationUtils.getRepeatableAnnotations(method, A.class);\r\n    // Not merged, so we expect to find @A once with the default value of 0.\r\n    // @A will actually be found twice, but we have Set semantics here.\r\n    assertThat(annotations).extracting(A::value).containsExactly(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SingleRepeatableAnnotationTests#annotatedMethod()",
    "entityType": "method",
    "code": "@B(5)\r\nvoid annotatedMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests",
    "entityType": "class",
    "code": "private final Method method = ReflectionUtils.findMethod(getClass(), \"annotatedMethod\");\n@Test\r\nvoid streamRepeatableAnnotationsWithStandardRepeatables_MergedAnnotationsApi() {\r\n    RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, repeatableContainers).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}\n@Test\r\nvoid streamRepeatableAnnotationsWithExplicitRepeatables_MergedAnnotationsApi() {\r\n    RepeatableContainers repeatableContainers = RepeatableContainers.of(A.class, A.Container.class).and(B.Container.class, B.class);\r\n    Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, repeatableContainers).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}\n@Test\r\nvoid findMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}\n@Test\r\nvoid findMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n    // When findMergedRepeatableAnnotations(...) is invoked with an explicit container\r\n    // type, it uses RepeatableContainers.of(...) which limits the repeatable annotation\r\n    // support to a single container type.\r\n    //\r\n    // In this test case, we are therefore limiting the support to @A.Container, which\r\n    // means that @B.Container is unsupported and effectively ignored as a repeatable\r\n    // container type.\r\n    //\r\n    // Long story, short: the search doesn't find anything.\r\n    assertThat(annotations).isEmpty();\r\n}\n@Test\r\nvoid getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}\n@Test\r\nvoid getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n    // When getMergedRepeatableAnnotations(...) is invoked with an explicit container\r\n    // type, it uses RepeatableContainers.of(...) which limits the repeatable annotation\r\n    // support to a single container type.\r\n    //\r\n    // In this test case, we are therefore limiting the support to @A.Container, which\r\n    // means that @B.Container is unsupported and effectively ignored as a repeatable\r\n    // container type.\r\n    //\r\n    // Long story, short: the search doesn't find anything.\r\n    assertThat(annotations).isEmpty();\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid getRepeatableAnnotations_AnnotationUtils() {\r\n    Set<A> annotations = AnnotationUtils.getRepeatableAnnotations(method, A.class);\r\n    // Not merged, so we expect to find a single @A with default value of 0.\r\n    // @A will actually be found twice, but we have Set semantics here.\r\n    assertThat(annotations).extracting(A::value).containsExactly(0);\r\n}\n@B(5)\r\n@B(10)\r\nvoid annotatedMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#streamRepeatableAnnotationsWithStandardRepeatables_MergedAnnotationsApi()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableAnnotationsWithStandardRepeatables_MergedAnnotationsApi() {\r\n    RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables();\r\n    Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, repeatableContainers).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#streamRepeatableAnnotationsWithExplicitRepeatables_MergedAnnotationsApi()",
    "entityType": "method",
    "code": "@Test\r\nvoid streamRepeatableAnnotationsWithExplicitRepeatables_MergedAnnotationsApi() {\r\n    RepeatableContainers repeatableContainers = RepeatableContainers.of(A.class, A.Container.class).and(B.Container.class, B.class);\r\n    Set<A> annotations = MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, repeatableContainers).stream(A.class).collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#findMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#findMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n    // When findMergedRepeatableAnnotations(...) is invoked with an explicit container\r\n    // type, it uses RepeatableContainers.of(...) which limits the repeatable annotation\r\n    // support to a single container type.\r\n    //\r\n    // In this test case, we are therefore limiting the support to @A.Container, which\r\n    // means that @B.Container is unsupported and effectively ignored as a repeatable\r\n    // container type.\r\n    //\r\n    // Long story, short: the search doesn't find anything.\r\n    assertThat(annotations).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedRepeatableAnnotationsWithStandardRepeatables_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class);\r\n    // Merged, so we expect to find @A twice with values coming from @B(5) and @B(10).\r\n    assertThat(annotations).extracting(A::value).containsExactly(5, 10);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedRepeatableAnnotationsWithExplicitContainer_AnnotatedElementUtils() {\r\n    Set<A> annotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, A.class, A.Container.class);\r\n    // When getMergedRepeatableAnnotations(...) is invoked with an explicit container\r\n    // type, it uses RepeatableContainers.of(...) which limits the repeatable annotation\r\n    // support to a single container type.\r\n    //\r\n    // In this test case, we are therefore limiting the support to @A.Container, which\r\n    // means that @B.Container is unsupported and effectively ignored as a repeatable\r\n    // container type.\r\n    //\r\n    // Long story, short: the search doesn't find anything.\r\n    assertThat(annotations).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#getRepeatableAnnotations_AnnotationUtils()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid getRepeatableAnnotations_AnnotationUtils() {\r\n    Set<A> annotations = AnnotationUtils.getRepeatableAnnotations(method, A.class);\r\n    // Not merged, so we expect to find a single @A with default value of 0.\r\n    // @A will actually be found twice, but we have Set semantics here.\r\n    assertThat(annotations).extracting(A::value).containsExactly(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MultipleRepeatableAnnotationsTests#annotatedMethod()",
    "entityType": "method",
    "code": "@B(5)\r\n@B(10)\r\nvoid annotatedMethod() ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests",
    "entityType": "class",
    "code": "private final AnnotationAwareOrderComparator comparator = AnnotationAwareOrderComparator.INSTANCE;\n@Test\r\nvoid plainComparator() {\r\n    List<Object> items = new ArrayList<>();\r\n    C c = new C(5);\r\n    C c2 = new C(-5);\r\n    items.add(c);\r\n    items.add(c2);\r\n    items.sort(comparator);\r\n    assertOrder(items, c2, c);\r\n}\n@Test\r\nvoid listNoFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(-50);\r\n    B b = new B();\r\n    List<?> items = Arrays.asList(a, c, b);\r\n    items.sort(comparator.withSourceProvider(obj -> null));\r\n    assertOrder(items, c, a, b);\r\n}\n@Test\r\nvoid listFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(3);\r\n    B b = new B();\r\n    List<?> items = Arrays.asList(a, c, b);\r\n    items.sort(comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return new C(4);\r\n        }\r\n        if (obj == b) {\r\n            return new C(2);\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, b, c, a);\r\n}\n@Test\r\nvoid listFactoryMethodOverridesStaticOrder() {\r\n    A a = new A();\r\n    C c = new C(5);\r\n    C c2 = new C(-5);\r\n    List<?> items = Arrays.asList(a, c, c2);\r\n    items.sort(comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return 4;\r\n        }\r\n        if (obj == c2) {\r\n            return 2;\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, c2, a, c);\r\n}\n@Test\r\nvoid arrayNoFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(-50);\r\n    B b = new B();\r\n    Object[] items = new Object[] { a, c, b };\r\n    Arrays.sort(items, comparator.withSourceProvider(obj -> null));\r\n    assertOrder(items, c, a, b);\r\n}\n@Test\r\nvoid arrayFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(3);\r\n    B b = new B();\r\n    Object[] items = new Object[] { a, c, b };\r\n    Arrays.sort(items, comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return new C(4);\r\n        }\r\n        if (obj == b) {\r\n            return new C(2);\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, b, c, a);\r\n}\n@Test\r\nvoid arrayFactoryMethodOverridesStaticOrder() {\r\n    A a = new A();\r\n    C c = new C(5);\r\n    C c2 = new C(-5);\r\n    Object[] items = new Object[] { a, c, c2 };\r\n    Arrays.sort(items, comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return 4;\r\n        }\r\n        if (obj == c2) {\r\n            return 2;\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, c2, a, c);\r\n}\nprivate void assertOrder(List<?> actual, Object... expected) {\r\n    for (int i = 0; i < actual.size(); i++) {\r\n        assertThat(actual.get(i)).as(\"Wrong instance at index '\" + i + \"'\").isSameAs(expected[i]);\r\n    }\r\n    assertThat(actual.size()).as(\"Wrong number of items\").isEqualTo(expected.length);\r\n}\nprivate void assertOrder(Object[] actual, Object... expected) {\r\n    for (int i = 0; i < actual.length; i++) {\r\n        assertThat(actual[i]).as(\"Wrong instance at index '\" + i + \"'\").isSameAs(expected[i]);\r\n    }\r\n    assertThat(expected.length).as(\"Wrong number of items\").isEqualTo(expected.length);\r\n}\n@Order(1)\r\nprivate static class A {\r\n}\n@Order(2)\r\nprivate static class B {\r\n}\nprivate static class C implements Ordered {\r\n\r\n    private final int order;\r\n\r\n    private C(int order) {\r\n        this.order = order;\r\n    }\r\n\r\n    @Override\r\n    public int getOrder() {\r\n        return order;\r\n    }\r\n}",
    "comment": "\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#plainComparator()",
    "entityType": "method",
    "code": "@Test\r\nvoid plainComparator() {\r\n    List<Object> items = new ArrayList<>();\r\n    C c = new C(5);\r\n    C c2 = new C(-5);\r\n    items.add(c);\r\n    items.add(c2);\r\n    items.sort(comparator);\r\n    assertOrder(items, c2, c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#listNoFactoryMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid listNoFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(-50);\r\n    B b = new B();\r\n    List<?> items = Arrays.asList(a, c, b);\r\n    items.sort(comparator.withSourceProvider(obj -> null));\r\n    assertOrder(items, c, a, b);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#listFactoryMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid listFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(3);\r\n    B b = new B();\r\n    List<?> items = Arrays.asList(a, c, b);\r\n    items.sort(comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return new C(4);\r\n        }\r\n        if (obj == b) {\r\n            return new C(2);\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, b, c, a);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#listFactoryMethodOverridesStaticOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid listFactoryMethodOverridesStaticOrder() {\r\n    A a = new A();\r\n    C c = new C(5);\r\n    C c2 = new C(-5);\r\n    List<?> items = Arrays.asList(a, c, c2);\r\n    items.sort(comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return 4;\r\n        }\r\n        if (obj == c2) {\r\n            return 2;\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, c2, a, c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#arrayNoFactoryMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid arrayNoFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(-50);\r\n    B b = new B();\r\n    Object[] items = new Object[] { a, c, b };\r\n    Arrays.sort(items, comparator.withSourceProvider(obj -> null));\r\n    assertOrder(items, c, a, b);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#arrayFactoryMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid arrayFactoryMethod() {\r\n    A a = new A();\r\n    C c = new C(3);\r\n    B b = new B();\r\n    Object[] items = new Object[] { a, c, b };\r\n    Arrays.sort(items, comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return new C(4);\r\n        }\r\n        if (obj == b) {\r\n            return new C(2);\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, b, c, a);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#arrayFactoryMethodOverridesStaticOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid arrayFactoryMethodOverridesStaticOrder() {\r\n    A a = new A();\r\n    C c = new C(5);\r\n    C c2 = new C(-5);\r\n    Object[] items = new Object[] { a, c, c2 };\r\n    Arrays.sort(items, comparator.withSourceProvider(obj -> {\r\n        if (obj == a) {\r\n            return 4;\r\n        }\r\n        if (obj == c2) {\r\n            return 2;\r\n        }\r\n        return null;\r\n    }));\r\n    assertOrder(items, c2, a, c);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#assertOrder(List<?>,Object)",
    "entityType": "method",
    "code": "private void assertOrder(List<?> actual, Object... expected) {\r\n    for (int i = 0; i < actual.size(); i++) {\r\n        assertThat(actual.get(i)).as(\"Wrong instance at index '\" + i + \"'\").isSameAs(expected[i]);\r\n    }\r\n    assertThat(actual.size()).as(\"Wrong number of items\").isEqualTo(expected.length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderSourceProviderTests#assertOrder(Object[],Object)",
    "entityType": "method",
    "code": "private void assertOrder(Object[] actual, Object... expected) {\r\n    for (int i = 0; i < actual.length; i++) {\r\n        assertThat(actual[i]).as(\"Wrong instance at index '\" + i + \"'\").isSameAs(expected[i]);\r\n    }\r\n    assertThat(expected.length).as(\"Wrong number of items\").isEqualTo(expected.length);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.A",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.B",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.C",
    "entityType": "class",
    "code": "private final int order;\nprivate C(int order) {\r\n    this.order = order;\r\n}\n@Override\r\npublic int getOrder() {\r\n    return order;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.C#getOrder()",
    "entityType": "method",
    "code": "@Override\r\npublic int getOrder() {\r\n    return order;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid getSimpleOrder() {\r\n    assertThat(OrderUtils.getOrder(SimpleOrder.class, null)).isEqualTo(Integer.valueOf(50));\r\n    assertThat(OrderUtils.getOrder(SimpleOrder.class, null)).isEqualTo(Integer.valueOf(50));\r\n}\n@Test\r\nvoid getPriorityOrder() {\r\n    assertThat(OrderUtils.getOrder(SimplePriority.class, null)).isEqualTo(Integer.valueOf(55));\r\n    assertThat(OrderUtils.getOrder(SimplePriority.class, null)).isEqualTo(Integer.valueOf(55));\r\n}\n@Test\r\nvoid getOrderWithBoth() {\r\n    assertThat(OrderUtils.getOrder(OrderAndPriority.class, null)).isEqualTo(Integer.valueOf(50));\r\n    assertThat(OrderUtils.getOrder(OrderAndPriority.class, null)).isEqualTo(Integer.valueOf(50));\r\n}\n@Test\r\nvoid getDefaultOrder() {\r\n    assertThat(OrderUtils.getOrder(NoOrder.class, 33)).isEqualTo(33);\r\n    assertThat(OrderUtils.getOrder(NoOrder.class, 33)).isEqualTo(33);\r\n}\n@Test\r\nvoid getPriorityValueNoAnnotation() {\r\n    assertThat(OrderUtils.getPriority(SimpleOrder.class)).isNull();\r\n    assertThat(OrderUtils.getPriority(SimpleOrder.class)).isNull();\r\n}\n@Test\r\nvoid getPriorityValue() {\r\n    assertThat(OrderUtils.getPriority(OrderAndPriority.class)).isEqualTo(Integer.valueOf(55));\r\n    assertThat(OrderUtils.getPriority(OrderAndPriority.class)).isEqualTo(Integer.valueOf(55));\r\n}\n@Order(50)\r\nprivate static class SimpleOrder {\r\n}\n@Priority(55)\r\nprivate static class SimplePriority {\r\n}\n@Order(50)\r\n@Priority(55)\r\nprivate static class OrderAndPriority {\r\n}\nprivate static class NoOrder {\r\n}",
    "comment": "\n * @author Stephane Nicoll\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests#getSimpleOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid getSimpleOrder() {\r\n    assertThat(OrderUtils.getOrder(SimpleOrder.class, null)).isEqualTo(Integer.valueOf(50));\r\n    assertThat(OrderUtils.getOrder(SimpleOrder.class, null)).isEqualTo(Integer.valueOf(50));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests#getPriorityOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPriorityOrder() {\r\n    assertThat(OrderUtils.getOrder(SimplePriority.class, null)).isEqualTo(Integer.valueOf(55));\r\n    assertThat(OrderUtils.getOrder(SimplePriority.class, null)).isEqualTo(Integer.valueOf(55));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests#getOrderWithBoth()",
    "entityType": "method",
    "code": "@Test\r\nvoid getOrderWithBoth() {\r\n    assertThat(OrderUtils.getOrder(OrderAndPriority.class, null)).isEqualTo(Integer.valueOf(50));\r\n    assertThat(OrderUtils.getOrder(OrderAndPriority.class, null)).isEqualTo(Integer.valueOf(50));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.OrderUtilsTests#getDefaultOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid getDefaultOrder() {\r\n    assertThat(OrderUtils.getOrder(NoOrder.class, 33)).isEqualTo(33);\r\n    assertThat(OrderUtils.getOrder(NoOrder.class, 33)).isEqualTo(33);\r\n}",
    "comment": ""
  }
]