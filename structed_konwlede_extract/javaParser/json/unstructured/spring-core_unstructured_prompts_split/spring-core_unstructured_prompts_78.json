[
  {
    "entityId": "org.springframework.util.AddTask#evictEntries()",
    "entityType": "method",
    "code": "private void evictEntries() {\r\n    while (currentSize.get() > capacity) {\r\n        final Node<K, V> node = evictionQueue.poll();\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        cache.remove(node.key, node);\r\n        markAsRemoved(node);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.RemovalTask",
    "entityType": "class",
    "code": "final Node<K, V> node;\nRemovalTask(Node<K, V> node) {\r\n    this.node = node;\r\n}\n@Override\r\npublic void run() {\r\n    evictionQueue.remove(this.node);\r\n    markAsRemoved(this.node);\r\n}",
    "comment": "\n\t * Write operation recorded when an entry is removed to the cache.\n\t "
  },
  {
    "entityId": "org.springframework.util.RemovalTask#run()",
    "entityType": "method",
    "code": "@Override\r\npublic void run() {\r\n    evictionQueue.remove(this.node);\r\n    markAsRemoved(this.node);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations",
    "entityType": "class",
    "code": "private static final int BUFFER_COUNT = detectNumberOfBuffers();\nprivate static int detectNumberOfBuffers() {\r\n    int availableProcessors = Runtime.getRuntime().availableProcessors();\r\n    int nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1));\r\n    return Math.min(4, nextPowerOfTwo);\r\n}\nprivate static final int BUFFERS_MASK = BUFFER_COUNT - 1;\nprivate static final int MAX_PENDING_OPERATIONS = 32;\nprivate static final int MAX_DRAIN_COUNT = 2 * MAX_PENDING_OPERATIONS;\nprivate static final int BUFFER_SIZE = 2 * MAX_DRAIN_COUNT;\nprivate static final int BUFFER_INDEX_MASK = BUFFER_SIZE - 1;\n/*\r\n\t\t * Number of operations recorded, for each buffer\r\n\t\t */\r\nprivate final AtomicLongArray recordedCount = new AtomicLongArray(BUFFER_COUNT);\n/*\r\n\t\t * Number of operations read, for each buffer\r\n\t\t */\r\nprivate final long[] readCount = new long[BUFFER_COUNT];\n/*\r\n\t\t * Number of operations processed, for each buffer\r\n\t\t */\r\nprivate final AtomicLongArray processedCount = new AtomicLongArray(BUFFER_COUNT);\n@SuppressWarnings(\"rawtypes\")\r\nprivate final AtomicReferenceArray<Node<K, V>>[] buffers = new AtomicReferenceArray[BUFFER_COUNT];\nprivate final EvictionQueue<K, V> evictionQueue;\nReadOperations(EvictionQueue<K, V> evictionQueue) {\r\n    this.evictionQueue = evictionQueue;\r\n    for (int i = 0; i < BUFFER_COUNT; i++) {\r\n        this.buffers[i] = new AtomicReferenceArray<>(BUFFER_SIZE);\r\n    }\r\n}\n// for Thread.getId() on JDK 19\r\n@SuppressWarnings(\"deprecation\")\r\nprivate static int getBufferIndex() {\r\n    return ((int) Thread.currentThread().getId()) & BUFFERS_MASK;\r\n}\nboolean recordRead(Node<K, V> node) {\r\n    int bufferIndex = getBufferIndex();\r\n    final long writeCount = this.recordedCount.get(bufferIndex);\r\n    this.recordedCount.lazySet(bufferIndex, writeCount + 1);\r\n    final int index = (int) (writeCount & BUFFER_INDEX_MASK);\r\n    this.buffers[bufferIndex].lazySet(index, node);\r\n    final long pending = (writeCount - this.processedCount.get(bufferIndex));\r\n    return (pending < MAX_PENDING_OPERATIONS);\r\n}\n// for Thread.getId() on JDK 19\r\n@SuppressWarnings(\"deprecation\")\r\nvoid drain() {\r\n    final int start = (int) Thread.currentThread().getId();\r\n    final int end = start + BUFFER_COUNT;\r\n    for (int i = start; i < end; i++) {\r\n        drainReadBuffer(i & BUFFERS_MASK);\r\n    }\r\n}\nvoid clear() {\r\n    for (int i = 0; i < BUFFER_COUNT; i++) {\r\n        AtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\r\n        for (int j = 0; j < BUFFER_SIZE; j++) {\r\n            buffer.lazySet(j, null);\r\n        }\r\n    }\r\n}\nprivate void drainReadBuffer(int bufferIndex) {\r\n    final long writeCount = this.recordedCount.get(bufferIndex);\r\n    for (int i = 0; i < MAX_DRAIN_COUNT; i++) {\r\n        final int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK);\r\n        final AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex];\r\n        final Node<K, V> node = buffer.get(index);\r\n        if (node == null) {\r\n            break;\r\n        }\r\n        buffer.lazySet(index, null);\r\n        this.evictionQueue.moveToBack(node);\r\n        this.readCount[bufferIndex]++;\r\n    }\r\n    this.processedCount.lazySet(bufferIndex, writeCount);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations#detectNumberOfBuffers()",
    "entityType": "method",
    "code": "private static int detectNumberOfBuffers() {\r\n    int availableProcessors = Runtime.getRuntime().availableProcessors();\r\n    int nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1));\r\n    return Math.min(4, nextPowerOfTwo);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations#getBufferIndex()",
    "entityType": "method",
    "code": "// for Thread.getId() on JDK 19\r\n@SuppressWarnings(\"deprecation\")\r\nprivate static int getBufferIndex() {\r\n    return ((int) Thread.currentThread().getId()) & BUFFERS_MASK;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations#recordRead(Node<K,V>)",
    "entityType": "method",
    "code": "boolean recordRead(Node<K, V> node) {\r\n    int bufferIndex = getBufferIndex();\r\n    final long writeCount = this.recordedCount.get(bufferIndex);\r\n    this.recordedCount.lazySet(bufferIndex, writeCount + 1);\r\n    final int index = (int) (writeCount & BUFFER_INDEX_MASK);\r\n    this.buffers[bufferIndex].lazySet(index, node);\r\n    final long pending = (writeCount - this.processedCount.get(bufferIndex));\r\n    return (pending < MAX_PENDING_OPERATIONS);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations#drain()",
    "entityType": "method",
    "code": "// for Thread.getId() on JDK 19\r\n@SuppressWarnings(\"deprecation\")\r\nvoid drain() {\r\n    final int start = (int) Thread.currentThread().getId();\r\n    final int end = start + BUFFER_COUNT;\r\n    for (int i = start; i < end; i++) {\r\n        drainReadBuffer(i & BUFFERS_MASK);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations#clear()",
    "entityType": "method",
    "code": "void clear() {\r\n    for (int i = 0; i < BUFFER_COUNT; i++) {\r\n        AtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\r\n        for (int j = 0; j < BUFFER_SIZE; j++) {\r\n            buffer.lazySet(j, null);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
    "entityType": "method",
    "code": "private void drainReadBuffer(int bufferIndex) {\r\n    final long writeCount = this.recordedCount.get(bufferIndex);\r\n    for (int i = 0; i < MAX_DRAIN_COUNT; i++) {\r\n        final int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK);\r\n        final AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex];\r\n        final Node<K, V> node = buffer.get(index);\r\n        if (node == null) {\r\n            break;\r\n        }\r\n        buffer.lazySet(index, null);\r\n        this.evictionQueue.moveToBack(node);\r\n        this.readCount[bufferIndex]++;\r\n    }\r\n    this.processedCount.lazySet(bufferIndex, writeCount);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WriteOperations",
    "entityType": "class",
    "code": "private static final int DRAIN_THRESHOLD = 16;\nprivate final Queue<Runnable> operations = new ConcurrentLinkedQueue<>();\npublic void add(Runnable task) {\r\n    this.operations.add(task);\r\n}\npublic void drain() {\r\n    for (int i = 0; i < DRAIN_THRESHOLD; i++) {\r\n        final Runnable task = this.operations.poll();\r\n        if (task == null) {\r\n            break;\r\n        }\r\n        task.run();\r\n    }\r\n}\npublic void drainAll() {\r\n    Runnable task;\r\n    while ((task = this.operations.poll()) != null) {\r\n        task.run();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WriteOperations#add(Runnable)",
    "entityType": "method",
    "code": "public void add(Runnable task) {\r\n    this.operations.add(task);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WriteOperations#drain()",
    "entityType": "method",
    "code": "public void drain() {\r\n    for (int i = 0; i < DRAIN_THRESHOLD; i++) {\r\n        final Runnable task = this.operations.poll();\r\n        if (task == null) {\r\n            break;\r\n        }\r\n        task.run();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.WriteOperations#drainAll()",
    "entityType": "method",
    "code": "public void drainAll() {\r\n    Runnable task;\r\n    while ((task = this.operations.poll()) != null) {\r\n        task.run();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Node",
    "entityType": "class",
    "code": "final K key;\n@Nullable\r\nNode<K, V> prev;\n@Nullable\r\nNode<K, V> next;\nNode(K key, CacheEntry<V> cacheEntry) {\r\n    super(cacheEntry);\r\n    this.key = key;\r\n}\n@Nullable\r\npublic Node<K, V> getPrevious() {\r\n    return this.prev;\r\n}\npublic void setPrevious(@Nullable Node<K, V> prev) {\r\n    this.prev = prev;\r\n}\n@Nullable\r\npublic Node<K, V> getNext() {\r\n    return this.next;\r\n}\npublic void setNext(@Nullable Node<K, V> next) {\r\n    this.next = next;\r\n}\nV getValue() {\r\n    return get().value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Node#getPrevious()",
    "entityType": "method",
    "code": "@Nullable\r\npublic Node<K, V> getPrevious() {\r\n    return this.prev;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Node#setPrevious(Node<K,V>)",
    "entityType": "method",
    "code": "public void setPrevious(@Nullable Node<K, V> prev) {\r\n    this.prev = prev;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Node#getNext()",
    "entityType": "method",
    "code": "@Nullable\r\npublic Node<K, V> getNext() {\r\n    return this.next;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Node#setNext(Node<K,V>)",
    "entityType": "method",
    "code": "public void setNext(@Nullable Node<K, V> next) {\r\n    this.next = next;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Node#getValue()",
    "entityType": "method",
    "code": "V getValue() {\r\n    return get().value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue",
    "entityType": "class",
    "code": "@Nullable\r\nNode<K, V> first;\n@Nullable\r\nNode<K, V> last;\n@Nullable\r\nNode<K, V> poll() {\r\n    if (this.first == null) {\r\n        return null;\r\n    }\r\n    final Node<K, V> f = this.first;\r\n    final Node<K, V> next = f.getNext();\r\n    f.setNext(null);\r\n    this.first = next;\r\n    if (next == null) {\r\n        this.last = null;\r\n    } else {\r\n        next.setPrevious(null);\r\n    }\r\n    return f;\r\n}\nvoid add(Node<K, V> e) {\r\n    if (contains(e)) {\r\n        return;\r\n    }\r\n    linkLast(e);\r\n}\nprivate boolean contains(Node<K, V> e) {\r\n    return (e.getPrevious() != null) || (e.getNext() != null) || (e == this.first);\r\n}\nprivate void linkLast(final Node<K, V> e) {\r\n    final Node<K, V> l = this.last;\r\n    this.last = e;\r\n    if (l == null) {\r\n        this.first = e;\r\n    } else {\r\n        l.setNext(e);\r\n        e.setPrevious(l);\r\n    }\r\n}\nprivate void unlink(Node<K, V> e) {\r\n    final Node<K, V> prev = e.getPrevious();\r\n    final Node<K, V> next = e.getNext();\r\n    if (prev == null) {\r\n        this.first = next;\r\n    } else {\r\n        prev.setNext(next);\r\n        e.setPrevious(null);\r\n    }\r\n    if (next == null) {\r\n        this.last = prev;\r\n    } else {\r\n        next.setPrevious(prev);\r\n        e.setNext(null);\r\n    }\r\n}\nvoid moveToBack(Node<K, V> e) {\r\n    if (contains(e) && e != this.last) {\r\n        unlink(e);\r\n        linkLast(e);\r\n    }\r\n}\nvoid remove(Node<K, V> e) {\r\n    if (contains(e)) {\r\n        unlink(e);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#poll()",
    "entityType": "method",
    "code": "@Nullable\r\nNode<K, V> poll() {\r\n    if (this.first == null) {\r\n        return null;\r\n    }\r\n    final Node<K, V> f = this.first;\r\n    final Node<K, V> next = f.getNext();\r\n    f.setNext(null);\r\n    this.first = next;\r\n    if (next == null) {\r\n        this.last = null;\r\n    } else {\r\n        next.setPrevious(null);\r\n    }\r\n    return f;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#add(Node<K,V>)",
    "entityType": "method",
    "code": "void add(Node<K, V> e) {\r\n    if (contains(e)) {\r\n        return;\r\n    }\r\n    linkLast(e);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#contains(Node<K,V>)",
    "entityType": "method",
    "code": "private boolean contains(Node<K, V> e) {\r\n    return (e.getPrevious() != null) || (e.getNext() != null) || (e == this.first);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
    "entityType": "method",
    "code": "private void linkLast(final Node<K, V> e) {\r\n    final Node<K, V> l = this.last;\r\n    this.last = e;\r\n    if (l == null) {\r\n        this.first = e;\r\n    } else {\r\n        l.setNext(e);\r\n        e.setPrevious(l);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#unlink(Node<K,V>)",
    "entityType": "method",
    "code": "private void unlink(Node<K, V> e) {\r\n    final Node<K, V> prev = e.getPrevious();\r\n    final Node<K, V> next = e.getNext();\r\n    if (prev == null) {\r\n        this.first = next;\r\n    } else {\r\n        prev.setNext(next);\r\n        e.setPrevious(null);\r\n    }\r\n    if (next == null) {\r\n        this.last = prev;\r\n    } else {\r\n        next.setPrevious(prev);\r\n        e.setNext(null);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#moveToBack(Node<K,V>)",
    "entityType": "method",
    "code": "void moveToBack(Node<K, V> e) {\r\n    if (contains(e) && e != this.last) {\r\n        unlink(e);\r\n        linkLast(e);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
    "entityType": "method",
    "code": "void remove(Node<K, V> e) {\r\n    if (contains(e)) {\r\n        unlink(e);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap",
    "entityType": "class",
    "code": "private static final int DEFAULT_INITIAL_CAPACITY = 16;\nprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\nprivate static final int DEFAULT_CONCURRENCY_LEVEL = 16;\nprivate static final ReferenceType DEFAULT_REFERENCE_TYPE = ReferenceType.SOFT;\nprivate static final int MAXIMUM_CONCURRENCY_LEVEL = 1 << 16;\nprivate static final int MAXIMUM_SEGMENT_SIZE = 1 << 30;\n/**\r\n * Array of segments indexed using the high order bits from the hash.\r\n */\r\nprivate final Segment[] segments;\n/**\r\n * When the average number of references per table exceeds this value resize will be attempted.\r\n */\r\nprivate final float loadFactor;\n/**\r\n * The reference type: SOFT or WEAK.\r\n */\r\nprivate final ReferenceType referenceType;\n/**\r\n * The shift value used to calculate the size of the segments array and an index from the hash.\r\n */\r\nprivate final int shift;\n/**\r\n * Late binding entry set.\r\n */\r\n@Nullable\r\nprivate volatile Set<Map.Entry<K, V>> entrySet;\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n */\r\npublic ConcurrentReferenceHashMap() {\r\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\r\n}\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n * @param initialCapacity the initial capacity of the map\r\n */\r\npublic ConcurrentReferenceHashMap(int initialCapacity) {\r\n    this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\r\n}\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n * @param initialCapacity the initial capacity of the map\r\n * @param loadFactor the load factor. When the average number of references per table\r\n * exceeds this value resize will be attempted\r\n */\r\npublic ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {\r\n    this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\r\n}\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n * @param initialCapacity the initial capacity of the map\r\n * @param concurrencyLevel the expected number of threads that will concurrently\r\n * write to the map\r\n */\r\npublic ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {\r\n    this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE);\r\n}\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n * @param initialCapacity the initial capacity of the map\r\n * @param referenceType the reference type used for entries (soft or weak)\r\n */\r\npublic ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {\r\n    this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType);\r\n}\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n * @param initialCapacity the initial capacity of the map\r\n * @param loadFactor the load factor. When the average number of references per\r\n * table exceeds this value, resize will be attempted.\r\n * @param concurrencyLevel the expected number of threads that will concurrently\r\n * write to the map\r\n */\r\npublic ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {\r\n    this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE);\r\n}\n/**\r\n * Create a new {@code ConcurrentReferenceHashMap} instance.\r\n * @param initialCapacity the initial capacity of the map\r\n * @param loadFactor the load factor. When the average number of references per\r\n * table exceeds this value, resize will be attempted.\r\n * @param concurrencyLevel the expected number of threads that will concurrently\r\n * write to the map\r\n * @param referenceType the reference type used for entries (soft or weak)\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {\r\n    Assert.isTrue(initialCapacity >= 0, \"Initial capacity must not be negative\");\r\n    Assert.isTrue(loadFactor > 0f, \"Load factor must be positive\");\r\n    Assert.isTrue(concurrencyLevel > 0, \"Concurrency level must be positive\");\r\n    Assert.notNull(referenceType, \"Reference type must not be null\");\r\n    this.loadFactor = loadFactor;\r\n    this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL);\r\n    int size = 1 << this.shift;\r\n    this.referenceType = referenceType;\r\n    int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size);\r\n    int initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE);\r\n    Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size);\r\n    int resizeThreshold = (int) (initialSize * getLoadFactor());\r\n    for (int i = 0; i < segments.length; i++) {\r\n        segments[i] = new Segment(initialSize, resizeThreshold);\r\n    }\r\n    this.segments = segments;\r\n}\nprotected final float getLoadFactor() {\r\n    return this.loadFactor;\r\n}\nprotected final int getSegmentsSize() {\r\n    return this.segments.length;\r\n}\nprotected final Segment getSegment(int index) {\r\n    return this.segments[index];\r\n}\n/**\r\n * Factory method that returns the {@link ReferenceManager}.\r\n * This method will be called once for each {@link Segment}.\r\n * @return a new reference manager\r\n */\r\nprotected ReferenceManager createReferenceManager() {\r\n    return new ReferenceManager();\r\n}\n/**\r\n * Get the hash for a given object, apply an additional hash function to reduce\r\n * collisions. This implementation uses the same Wang/Jenkins algorithm as\r\n * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing.\r\n * @param o the object to hash (may be null)\r\n * @return the resulting hash code\r\n */\r\nprotected int getHash(@Nullable Object o) {\r\n    int hash = (o != null ? o.hashCode() : 0);\r\n    hash += (hash << 15) ^ 0xffffcd7d;\r\n    hash ^= (hash >>> 10);\r\n    hash += (hash << 3);\r\n    hash ^= (hash >>> 6);\r\n    hash += (hash << 2) + (hash << 14);\r\n    hash ^= (hash >>> 16);\r\n    return hash;\r\n}\n@Override\r\n@Nullable\r\npublic V get(@Nullable Object key) {\r\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\r\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n    return (entry != null ? entry.getValue() : null);\r\n}\n@Override\r\n@Nullable\r\npublic V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\r\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\r\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n    return (entry != null ? entry.getValue() : defaultValue);\r\n}\n@Override\r\npublic boolean containsKey(@Nullable Object key) {\r\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\r\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n    return (entry != null && ObjectUtils.nullSafeEquals(entry.getKey(), key));\r\n}\n/**\r\n * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\r\n * or {@code null} if not found.\r\n * @param key the key (can be {@code null})\r\n * @param restructure types of restructure allowed during this call\r\n * @return the reference, or {@code null} if not found\r\n */\r\n@Nullable\r\nprotected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {\r\n    int hash = getHash(key);\r\n    return getSegmentForHash(hash).getReference(key, hash, restructure);\r\n}\n@Override\r\n@Nullable\r\npublic V put(@Nullable K key, @Nullable V value) {\r\n    return put(key, value, true);\r\n}\n@Override\r\n@Nullable\r\npublic V putIfAbsent(@Nullable K key, @Nullable V value) {\r\n    return put(key, value, false);\r\n}\n@Nullable\r\nprivate V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {\r\n    return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.RESIZE) {\r\n\r\n        @Override\r\n        @Nullable\r\n        protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\r\n            if (entry != null) {\r\n                V oldValue = entry.getValue();\r\n                if (overwriteExisting) {\r\n                    entry.setValue(value);\r\n                }\r\n                return oldValue;\r\n            }\r\n            Assert.state(entries != null, \"No entries segment\");\r\n            entries.add(value);\r\n            return null;\r\n        }\r\n    });\r\n}\n@Override\r\n@Nullable\r\npublic V remove(@Nullable Object key) {\r\n    return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        @Nullable\r\n        protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null) {\r\n                if (ref != null) {\r\n                    ref.release();\r\n                }\r\n                return entry.value;\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}\n@Override\r\npublic boolean remove(@Nullable Object key, @Nullable final Object value) {\r\n    Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {\r\n                if (ref != null) {\r\n                    ref.release();\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n    return (Boolean.TRUE.equals(result));\r\n}\n@Override\r\npublic boolean replace(@Nullable K key, @Nullable final V oldValue, @Nullable final V newValue) {\r\n    Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {\r\n                entry.setValue(newValue);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n    return (Boolean.TRUE.equals(result));\r\n}\n@Override\r\n@Nullable\r\npublic V replace(@Nullable K key, @Nullable final V value) {\r\n    return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        @Nullable\r\n        protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null) {\r\n                V oldValue = entry.getValue();\r\n                entry.setValue(value);\r\n                return oldValue;\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}\n@Override\r\npublic void clear() {\r\n    for (Segment segment : this.segments) {\r\n        segment.clear();\r\n    }\r\n}\n/**\r\n * Remove any entries that have been garbage collected and are no longer referenced.\r\n * Under normal circumstances garbage collected entries are automatically purged as\r\n * items are added or removed from the Map. This method can be used to force a purge,\r\n * and is useful when the Map is read frequently but updated less often.\r\n */\r\npublic void purgeUnreferencedEntries() {\r\n    for (Segment segment : this.segments) {\r\n        segment.restructureIfNecessary(false);\r\n    }\r\n}\n@Override\r\npublic int size() {\r\n    int size = 0;\r\n    for (Segment segment : this.segments) {\r\n        size += segment.getCount();\r\n    }\r\n    return size;\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    for (Segment segment : this.segments) {\r\n        if (segment.getCount() > 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n@Override\r\npublic Set<Map.Entry<K, V>> entrySet() {\r\n    Set<Map.Entry<K, V>> entrySet = this.entrySet;\r\n    if (entrySet == null) {\r\n        entrySet = new EntrySet();\r\n        this.entrySet = entrySet;\r\n    }\r\n    return entrySet;\r\n}\n@Nullable\r\nprivate <T> T doTask(@Nullable Object key, Task<T> task) {\r\n    int hash = getHash(key);\r\n    return getSegmentForHash(hash).doTask(hash, key, task);\r\n}\nprivate Segment getSegmentForHash(int hash) {\r\n    return this.segments[(hash >>> (32 - this.shift)) & (this.segments.length - 1)];\r\n}\n/**\r\n * Calculate a shift value that can be used to create a power-of-two value between\r\n * the specified maximum and minimum values.\r\n * @param minimumValue the minimum value\r\n * @param maximumValue the maximum value\r\n * @return the calculated shift (use {@code 1 << shift} to obtain a value)\r\n */\r\nprotected static int calculateShift(int minimumValue, int maximumValue) {\r\n    int shift = 0;\r\n    int value = 1;\r\n    while (value < minimumValue && value < maximumValue) {\r\n        value <<= 1;\r\n        shift++;\r\n    }\r\n    return shift;\r\n}\n/**\r\n * Various reference types supported by this map.\r\n */\r\npublic enum ReferenceType {\r\n\r\n    /**\r\n     * Use {@link SoftReference SoftReferences}.\r\n     */\r\n    SOFT,\r\n    /**\r\n     * Use {@link WeakReference WeakReferences}.\r\n     */\r\n    WEAK\r\n}\n/**\r\n * A single segment used to divide the map to allow better concurrent performance.\r\n */\r\n@SuppressWarnings(\"serial\")\r\nprotected final class Segment extends ReentrantLock {\r\n\r\n    private final ReferenceManager referenceManager;\r\n\r\n    private final int initialSize;\r\n\r\n    /**\r\n     * Array of references indexed using the low order bits from the hash.\r\n     * This property should only be set along with {@code resizeThreshold}.\r\n     */\r\n    @Nullable\r\n    private volatile Reference<K, V>[] references;\r\n\r\n    /**\r\n     * The total number of references contained in this segment. This includes chained\r\n     * references and references that have been garbage collected but not purged.\r\n     */\r\n    private final AtomicInteger count = new AtomicInteger();\r\n\r\n    /**\r\n     * The threshold when resizing of the references should occur. When {@code count}\r\n     * exceeds this value references will be resized.\r\n     */\r\n    private int resizeThreshold;\r\n\r\n    public Segment(int initialSize, int resizeThreshold) {\r\n        this.referenceManager = createReferenceManager();\r\n        this.initialSize = initialSize;\r\n        this.references = createReferenceArray(initialSize);\r\n        this.resizeThreshold = resizeThreshold;\r\n    }\r\n\r\n    @Nullable\r\n    public Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\r\n        if (restructure == Restructure.WHEN_NECESSARY) {\r\n            restructureIfNecessary(false);\r\n        }\r\n        if (this.count.get() == 0) {\r\n            return null;\r\n        }\r\n        // Use a local copy to protect against other threads writing\r\n        @Nullable\r\n        Reference<K, V>[] references = this.references;\r\n        int index = getIndex(hash, references);\r\n        Reference<K, V> head = references[index];\r\n        return findInChain(head, key, hash);\r\n    }\r\n\r\n    /**\r\n     * Apply an update operation to this segment.\r\n     * The segment will be locked during the update.\r\n     * @param hash the hash of the key\r\n     * @param key the key\r\n     * @param task the update operation\r\n     * @return the result of the operation\r\n     */\r\n    @Nullable\r\n    public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {\r\n        boolean resize = task.hasOption(TaskOption.RESIZE);\r\n        if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\r\n            restructureIfNecessary(resize);\r\n        }\r\n        if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\r\n            return task.execute(null, null, null);\r\n        }\r\n        lock();\r\n        try {\r\n            final int index = getIndex(hash, this.references);\r\n            final Reference<K, V> head = this.references[index];\r\n            Reference<K, V> ref = findInChain(head, key, hash);\r\n            Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n            Entries<V> entries = value -> {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Entry<K, V> newEntry = new Entry<>((K) key, value);\r\n                Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\r\n                Segment.this.references[index] = newReference;\r\n                Segment.this.count.incrementAndGet();\r\n            };\r\n            return task.execute(ref, entry, entries);\r\n        } finally {\r\n            unlock();\r\n            if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\r\n                restructureIfNecessary(resize);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all items from this segment.\r\n     */\r\n    public void clear() {\r\n        if (this.count.get() == 0) {\r\n            return;\r\n        }\r\n        lock();\r\n        try {\r\n            this.references = createReferenceArray(this.initialSize);\r\n            this.resizeThreshold = (int) (this.references.length * getLoadFactor());\r\n            this.count.set(0);\r\n        } finally {\r\n            unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restructure the underlying data structure when it becomes necessary. This\r\n     * method can increase the size of the references table as well as purge any\r\n     * references that have been garbage collected.\r\n     * @param allowResize if resizing is permitted\r\n     */\r\n    void restructureIfNecessary(boolean allowResize) {\r\n        int currCount = this.count.get();\r\n        boolean needsResize = allowResize && (currCount > 0 && currCount >= this.resizeThreshold);\r\n        Reference<K, V> ref = this.referenceManager.pollForPurge();\r\n        if (ref != null || (needsResize)) {\r\n            restructure(allowResize, ref);\r\n        }\r\n    }\r\n\r\n    private void restructure(boolean allowResize, @Nullable Reference<K, V> ref) {\r\n        boolean needsResize;\r\n        lock();\r\n        try {\r\n            int expectedCount = this.count.get();\r\n            Set<Reference<K, V>> toPurge = Collections.emptySet();\r\n            if (ref != null) {\r\n                toPurge = new HashSet<>();\r\n                while (ref != null) {\r\n                    toPurge.add(ref);\r\n                    ref = this.referenceManager.pollForPurge();\r\n                }\r\n            }\r\n            expectedCount -= toPurge.size();\r\n            // Estimate new count, taking into account count inside lock and items that\r\n            // will be purged.\r\n            needsResize = (expectedCount > 0 && expectedCount >= this.resizeThreshold);\r\n            boolean resizing = false;\r\n            int restructureSize = this.references.length;\r\n            if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {\r\n                restructureSize <<= 1;\r\n                resizing = true;\r\n            }\r\n            int newCount = 0;\r\n            // Restructure the resized reference array\r\n            if (resizing) {\r\n                Reference<K, V>[] restructured = createReferenceArray(restructureSize);\r\n                for (Reference<K, V> reference : this.references) {\r\n                    ref = reference;\r\n                    while (ref != null) {\r\n                        if (!toPurge.contains(ref)) {\r\n                            Entry<K, V> entry = ref.get();\r\n                            // Also filter out null references that are now null\r\n                            // they should be polled from the queue in a later restructure call.\r\n                            if (entry != null) {\r\n                                int index = getIndex(ref.getHash(), restructured);\r\n                                restructured[index] = this.referenceManager.createReference(entry, ref.getHash(), restructured[index]);\r\n                                newCount++;\r\n                            }\r\n                        }\r\n                        ref = ref.getNext();\r\n                    }\r\n                }\r\n                // Replace volatile members\r\n                this.references = restructured;\r\n                this.resizeThreshold = (int) (this.references.length * getLoadFactor());\r\n            } else // Restructure the existing reference array \"in place\"\r\n            {\r\n                for (int i = 0; i < this.references.length; i++) {\r\n                    Reference<K, V> purgedRef = null;\r\n                    ref = this.references[i];\r\n                    while (ref != null) {\r\n                        if (!toPurge.contains(ref)) {\r\n                            Entry<K, V> entry = ref.get();\r\n                            // Also filter out null references that are now null\r\n                            // they should be polled from the queue in a later restructure call.\r\n                            if (entry != null) {\r\n                                purgedRef = this.referenceManager.createReference(entry, ref.getHash(), purgedRef);\r\n                            }\r\n                            newCount++;\r\n                        }\r\n                        ref = ref.getNext();\r\n                    }\r\n                    this.references[i] = purgedRef;\r\n                }\r\n            }\r\n            this.count.set(Math.max(newCount, 0));\r\n        } finally {\r\n            unlock();\r\n        }\r\n    }\r\n\r\n    @Nullable\r\n    private Reference<K, V> findInChain(@Nullable Reference<K, V> ref, @Nullable Object key, int hash) {\r\n        Reference<K, V> currRef = ref;\r\n        while (currRef != null) {\r\n            if (currRef.getHash() == hash) {\r\n                Entry<K, V> entry = currRef.get();\r\n                if (entry != null) {\r\n                    K entryKey = entry.getKey();\r\n                    if (ObjectUtils.nullSafeEquals(entryKey, key)) {\r\n                        return currRef;\r\n                    }\r\n                }\r\n            }\r\n            currRef = currRef.getNext();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\n    private Reference<K, V>[] createReferenceArray(int size) {\r\n        return new Reference[size];\r\n    }\r\n\r\n    private int getIndex(int hash, @Nullable Reference<K, V>[] references) {\r\n        return (hash & (references.length - 1));\r\n    }\r\n\r\n    /**\r\n     * Return the size of the current references array.\r\n     */\r\n    public int getSize() {\r\n        return this.references.length;\r\n    }\r\n\r\n    /**\r\n     * Return the total number of references in this segment.\r\n     */\r\n    public int getCount() {\r\n        return this.count.get();\r\n    }\r\n}\n/**\r\n * A reference to an {@link Entry} contained in the map. Implementations are usually\r\n * wrappers around specific Java reference implementations (for example, {@link SoftReference}).\r\n * @param <K> the key type\r\n * @param <V> the value type\r\n */\r\nprotected interface Reference<K, V> {\r\n\r\n    /**\r\n     * Return the referenced entry, or {@code null} if the entry is no longer available.\r\n     */\r\n    @Nullable\r\n    Entry<K, V> get();\r\n\r\n    /**\r\n     * Return the hash for the reference.\r\n     */\r\n    int getHash();\r\n\r\n    /**\r\n     * Return the next reference in the chain, or {@code null} if none.\r\n     */\r\n    @Nullable\r\n    Reference<K, V> getNext();\r\n\r\n    /**\r\n     * Release this entry and ensure that it will be returned from\r\n     * {@code ReferenceManager#pollForPurge()}.\r\n     */\r\n    void release();\r\n}\n/**\r\n * A single map entry.\r\n * @param <K> the key type\r\n * @param <V> the value type\r\n */\r\nprotected static final class Entry<K, V> implements Map.Entry<K, V> {\r\n\r\n    @Nullable\r\n    private final K key;\r\n\r\n    @Nullable\r\n    private volatile V value;\r\n\r\n    public Entry(@Nullable K key, @Nullable V value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public K getKey() {\r\n        return this.key;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public V getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public V setValue(@Nullable V value) {\r\n        V previous = this.value;\r\n        this.value = value;\r\n        return previous;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        return (this == other || (other instanceof Map.Entry<?, ?> that && ObjectUtils.nullSafeEquals(getKey(), that.getKey()) && ObjectUtils.nullSafeEquals(getValue(), that.getValue())));\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value));\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return (this.key + \"=\" + this.value);\r\n    }\r\n}\n/**\r\n * A task that can be {@link Segment#doTask run} against a {@link Segment}.\r\n */\r\nprivate abstract class Task<T> {\r\n\r\n    private final EnumSet<TaskOption> options;\r\n\r\n    public Task(TaskOption... options) {\r\n        this.options = (options.length == 0 ? EnumSet.noneOf(TaskOption.class) : EnumSet.of(options[0], options));\r\n    }\r\n\r\n    public boolean hasOption(TaskOption option) {\r\n        return this.options.contains(option);\r\n    }\r\n\r\n    /**\r\n     * Execute the task.\r\n     * @param ref the found reference (or {@code null})\r\n     * @param entry the found entry (or {@code null})\r\n     * @param entries access to the underlying entries\r\n     * @return the result of the task\r\n     * @see #execute(Reference, Entry)\r\n     */\r\n    @Nullable\r\n    protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\r\n        return execute(ref, entry);\r\n    }\r\n\r\n    /**\r\n     * Convenience method that can be used for tasks that do not need access to {@link Entries}.\r\n     * @param ref the found reference (or {@code null})\r\n     * @param entry the found entry (or {@code null})\r\n     * @return the result of the task\r\n     * @see #execute(Reference, Entry, Entries)\r\n     */\r\n    @Nullable\r\n    protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n        return null;\r\n    }\r\n}\n/**\r\n * Various options supported by a {@code Task}.\r\n */\r\nprivate enum TaskOption {\r\n\r\n    RESTRUCTURE_BEFORE, RESTRUCTURE_AFTER, SKIP_IF_EMPTY, RESIZE\r\n}\n/**\r\n * Allows a task access to {@link ConcurrentReferenceHashMap.Segment} entries.\r\n */\r\nprivate interface Entries<V> {\r\n\r\n    /**\r\n     * Add a new entry with the specified value.\r\n     * @param value the value to add\r\n     */\r\n    void add(@Nullable V value);\r\n}\n/**\r\n * Internal entry-set implementation.\r\n */\r\nprivate class EntrySet extends AbstractSet<Map.Entry<K, V>> {\r\n\r\n    @Override\r\n    public Iterator<Map.Entry<K, V>> iterator() {\r\n        return new EntryIterator();\r\n    }\r\n\r\n    @Override\r\n    public boolean contains(@Nullable Object o) {\r\n        if (o instanceof Map.Entry<?, ?> entry) {\r\n            Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);\r\n            Entry<K, V> otherEntry = (ref != null ? ref.get() : null);\r\n            if (otherEntry != null) {\r\n                return ObjectUtils.nullSafeEquals(entry.getValue(), otherEntry.getValue());\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean remove(Object o) {\r\n        if (o instanceof Map.Entry<?, ?> entry) {\r\n            return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return ConcurrentReferenceHashMap.this.size();\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        ConcurrentReferenceHashMap.this.clear();\r\n    }\r\n}\n/**\r\n * Internal entry iterator implementation.\r\n */\r\nprivate class EntryIterator implements Iterator<Map.Entry<K, V>> {\r\n\r\n    private int segmentIndex;\r\n\r\n    private int referenceIndex;\r\n\r\n    @Nullable\r\n    private Reference<K, V> @Nullable [] references;\r\n\r\n    @Nullable\r\n    private Reference<K, V> reference;\r\n\r\n    @Nullable\r\n    private Entry<K, V> next;\r\n\r\n    @Nullable\r\n    private Entry<K, V> last;\r\n\r\n    public EntryIterator() {\r\n        moveToNextSegment();\r\n    }\r\n\r\n    @Override\r\n    public boolean hasNext() {\r\n        getNextIfNecessary();\r\n        return (this.next != null);\r\n    }\r\n\r\n    @Override\r\n    public Entry<K, V> next() {\r\n        getNextIfNecessary();\r\n        if (this.next == null) {\r\n            throw new NoSuchElementException();\r\n        }\r\n        this.last = this.next;\r\n        this.next = null;\r\n        return this.last;\r\n    }\r\n\r\n    private void getNextIfNecessary() {\r\n        while (this.next == null) {\r\n            moveToNextReference();\r\n            if (this.reference == null) {\r\n                return;\r\n            }\r\n            this.next = this.reference.get();\r\n        }\r\n    }\r\n\r\n    private void moveToNextReference() {\r\n        if (this.reference != null) {\r\n            this.reference = this.reference.getNext();\r\n        }\r\n        while (this.reference == null && this.references != null) {\r\n            if (this.referenceIndex >= this.references.length) {\r\n                moveToNextSegment();\r\n                this.referenceIndex = 0;\r\n            } else {\r\n                this.reference = this.references[this.referenceIndex];\r\n                this.referenceIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void moveToNextSegment() {\r\n        this.reference = null;\r\n        this.references = null;\r\n        if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {\r\n            this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;\r\n            this.segmentIndex++;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void remove() {\r\n        Assert.state(this.last != null, \"No element to remove\");\r\n        ConcurrentReferenceHashMap.this.remove(this.last.getKey());\r\n        this.last = null;\r\n    }\r\n}\n/**\r\n * The types of restructuring that can be performed.\r\n */\r\nprotected enum Restructure {\r\n\r\n    WHEN_NECESSARY, NEVER\r\n}\n/**\r\n * Strategy class used to manage {@link Reference References}.\r\n * This class can be overridden if alternative reference types need to be supported.\r\n */\r\nprotected class ReferenceManager {\r\n\r\n    private final ReferenceQueue<Entry<K, V>> queue = new ReferenceQueue<>();\r\n\r\n    /**\r\n     * Factory method used to create a new {@link Reference}.\r\n     * @param entry the entry contained in the reference\r\n     * @param hash the hash\r\n     * @param next the next reference in the chain, or {@code null} if none\r\n     * @return a new {@link Reference}\r\n     */\r\n    public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\r\n        if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\r\n            return new WeakEntryReference<>(entry, hash, next, this.queue);\r\n        }\r\n        return new SoftEntryReference<>(entry, hash, next, this.queue);\r\n    }\r\n\r\n    /**\r\n     * Return any reference that has been garbage collected and can be purged from the\r\n     * underlying structure or {@code null} if no references need purging. This\r\n     * method must be thread safe and ideally should not block when returning\r\n     * {@code null}. References should be returned once and only once.\r\n     * @return a reference to purge or {@code null}\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    public Reference<K, V> pollForPurge() {\r\n        return (Reference<K, V>) this.queue.poll();\r\n    }\r\n}\n/**\r\n * Internal {@link Reference} implementation for {@link SoftReference SoftReferences}.\r\n */\r\nprivate static final class SoftEntryReference<K, V> extends SoftReference<Entry<K, V>> implements Reference<K, V> {\r\n\r\n    private final int hash;\r\n\r\n    @Nullable\r\n    private final Reference<K, V> nextReference;\r\n\r\n    public SoftEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next, ReferenceQueue<Entry<K, V>> queue) {\r\n        super(entry, queue);\r\n        this.hash = hash;\r\n        this.nextReference = next;\r\n    }\r\n\r\n    @Override\r\n    public int getHash() {\r\n        return this.hash;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Reference<K, V> getNext() {\r\n        return this.nextReference;\r\n    }\r\n\r\n    @Override\r\n    public void release() {\r\n        enqueue();\r\n    }\r\n}\n/**\r\n * Internal {@link Reference} implementation for {@link WeakReference WeakReferences}.\r\n */\r\nprivate static final class WeakEntryReference<K, V> extends WeakReference<Entry<K, V>> implements Reference<K, V> {\r\n\r\n    private final int hash;\r\n\r\n    @Nullable\r\n    private final Reference<K, V> nextReference;\r\n\r\n    public WeakEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next, ReferenceQueue<Entry<K, V>> queue) {\r\n        super(entry, queue);\r\n        this.hash = hash;\r\n        this.nextReference = next;\r\n    }\r\n\r\n    @Override\r\n    public int getHash() {\r\n        return this.hash;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Reference<K, V> getNext() {\r\n        return this.nextReference;\r\n    }\r\n\r\n    @Override\r\n    public void release() {\r\n        enqueue();\r\n    }\r\n}",
    "comment": "\n * A {@link ConcurrentHashMap} that uses {@link ReferenceType#SOFT soft} or\n * {@linkplain ReferenceType#WEAK weak} references for both {@code keys} and {@code values}.\n *\n * <p>This class can be used as an alternative to\n * {@code Collections.synchronizedMap(new WeakHashMap<K, Reference<V>>())} in order to\n * support better performance when accessed concurrently. This implementation follows the\n * same design constraints as {@link ConcurrentHashMap} with the exception that\n * {@code null} values and {@code null} keys are supported.\n *\n * <p><b>NOTE:</b> The use of references means that there is no guarantee that items\n * placed into the map will be subsequently available. The garbage collector may discard\n * references at any time, so it may appear that an unknown thread is silently removing\n * entries.\n *\n * <p>If not explicitly specified, this implementation will use\n * {@linkplain SoftReference soft entry references}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @author Brian Clozel\n * @since 3.2\n * @param <K> the key type\n * @param <V> the value type\n "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getLoadFactor()",
    "entityType": "method",
    "code": "protected final float getLoadFactor() {\r\n    return this.loadFactor;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getSegmentsSize()",
    "entityType": "method",
    "code": "protected final int getSegmentsSize() {\r\n    return this.segments.length;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getSegment(int)",
    "entityType": "method",
    "code": "protected final Segment getSegment(int index) {\r\n    return this.segments[index];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
    "entityType": "method",
    "code": "/**\r\n * Factory method that returns the {@link ReferenceManager}.\r\n * This method will be called once for each {@link Segment}.\r\n * @return a new reference manager\r\n */\r\nprotected ReferenceManager createReferenceManager() {\r\n    return new ReferenceManager();\r\n}",
    "comment": "\n\t * Factory method that returns the {@link ReferenceManager}.\n\t * This method will be called once for each {@link Segment}.\n\t * @return a new reference manager\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
    "entityType": "method",
    "code": "/**\r\n * Get the hash for a given object, apply an additional hash function to reduce\r\n * collisions. This implementation uses the same Wang/Jenkins algorithm as\r\n * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing.\r\n * @param o the object to hash (may be null)\r\n * @return the resulting hash code\r\n */\r\nprotected int getHash(@Nullable Object o) {\r\n    int hash = (o != null ? o.hashCode() : 0);\r\n    hash += (hash << 15) ^ 0xffffcd7d;\r\n    hash ^= (hash >>> 10);\r\n    hash += (hash << 3);\r\n    hash ^= (hash >>> 6);\r\n    hash += (hash << 2) + (hash << 14);\r\n    hash ^= (hash >>> 16);\r\n    return hash;\r\n}",
    "comment": "\n\t * Get the hash for a given object, apply an additional hash function to reduce\n\t * collisions. This implementation uses the same Wang/Jenkins algorithm as\n\t * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing.\n\t * @param o the object to hash (may be null)\n\t * @return the resulting hash code\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V get(@Nullable Object key) {\r\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\r\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n    return (entry != null ? entry.getValue() : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getOrDefault(Object,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\r\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\r\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n    return (entry != null ? entry.getValue() : defaultValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(@Nullable Object key) {\r\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\r\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n    return (entry != null && ObjectUtils.nullSafeEquals(entry.getKey(), key));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getReference(Object,Restructure)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\r\n * or {@code null} if not found.\r\n * @param key the key (can be {@code null})\r\n * @param restructure types of restructure allowed during this call\r\n * @return the reference, or {@code null} if not found\r\n */\r\n@Nullable\r\nprotected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {\r\n    int hash = getHash(key);\r\n    return getSegmentForHash(hash).getReference(key, hash, restructure);\r\n}",
    "comment": "\n\t * Return a {@link Reference} to the {@link Entry} for the specified {@code key},\n\t * or {@code null} if not found.\n\t * @param key the key (can be {@code null})\n\t * @param restructure types of restructure allowed during this call\n\t * @return the reference, or {@code null} if not found\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V put(@Nullable K key, @Nullable V value) {\r\n    return put(key, value, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#putIfAbsent(K,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V putIfAbsent(@Nullable K key, @Nullable V value) {\r\n    return put(key, value, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {\r\n    return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.RESIZE) {\r\n\r\n        @Override\r\n        @Nullable\r\n        protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\r\n            if (entry != null) {\r\n                V oldValue = entry.getValue();\r\n                if (overwriteExisting) {\r\n                    entry.setValue(value);\r\n                }\r\n                return oldValue;\r\n            }\r\n            Assert.state(entries != null, \"No entries segment\");\r\n            entries.add(value);\r\n            return null;\r\n        }\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V remove(@Nullable Object key) {\r\n    return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        @Nullable\r\n        protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null) {\r\n                if (ref != null) {\r\n                    ref.release();\r\n                }\r\n                return entry.value;\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean remove(@Nullable Object key, @Nullable final Object value) {\r\n    Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {\r\n                if (ref != null) {\r\n                    ref.release();\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n    return (Boolean.TRUE.equals(result));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V,V)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean replace(@Nullable K key, @Nullable final V oldValue, @Nullable final V newValue) {\r\n    Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {\r\n                entry.setValue(newValue);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n    return (Boolean.TRUE.equals(result));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V replace(@Nullable K key, @Nullable final V value) {\r\n    return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {\r\n\r\n        @Override\r\n        @Nullable\r\n        protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n            if (entry != null) {\r\n                V oldValue = entry.getValue();\r\n                entry.setValue(value);\r\n                return oldValue;\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    for (Segment segment : this.segments) {\r\n        segment.clear();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#purgeUnreferencedEntries()",
    "entityType": "method",
    "code": "/**\r\n * Remove any entries that have been garbage collected and are no longer referenced.\r\n * Under normal circumstances garbage collected entries are automatically purged as\r\n * items are added or removed from the Map. This method can be used to force a purge,\r\n * and is useful when the Map is read frequently but updated less often.\r\n */\r\npublic void purgeUnreferencedEntries() {\r\n    for (Segment segment : this.segments) {\r\n        segment.restructureIfNecessary(false);\r\n    }\r\n}",
    "comment": "\n\t * Remove any entries that have been garbage collected and are no longer referenced.\n\t * Under normal circumstances garbage collected entries are automatically purged as\n\t * items are added or removed from the Map. This method can be used to force a purge,\n\t * and is useful when the Map is read frequently but updated less often.\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    int size = 0;\r\n    for (Segment segment : this.segments) {\r\n        size += segment.getCount();\r\n    }\r\n    return size;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    for (Segment segment : this.segments) {\r\n        if (segment.getCount() > 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Map.Entry<K, V>> entrySet() {\r\n    Set<Map.Entry<K, V>> entrySet = this.entrySet;\r\n    if (entrySet == null) {\r\n        entrySet = new EntrySet();\r\n        this.entrySet = entrySet;\r\n    }\r\n    return entrySet;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate <T> T doTask(@Nullable Object key, Task<T> task) {\r\n    int hash = getHash(key);\r\n    return getSegmentForHash(hash).doTask(hash, key, task);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#getSegmentForHash(int)",
    "entityType": "method",
    "code": "private Segment getSegmentForHash(int hash) {\r\n    return this.segments[(hash >>> (32 - this.shift)) & (this.segments.length - 1)];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMap#calculateShift(int,int)",
    "entityType": "method",
    "code": "/**\r\n * Calculate a shift value that can be used to create a power-of-two value between\r\n * the specified maximum and minimum values.\r\n * @param minimumValue the minimum value\r\n * @param maximumValue the maximum value\r\n * @return the calculated shift (use {@code 1 << shift} to obtain a value)\r\n */\r\nprotected static int calculateShift(int minimumValue, int maximumValue) {\r\n    int shift = 0;\r\n    int value = 1;\r\n    while (value < minimumValue && value < maximumValue) {\r\n        value <<= 1;\r\n        shift++;\r\n    }\r\n    return shift;\r\n}",
    "comment": "\n\t * Calculate a shift value that can be used to create a power-of-two value between\n\t * the specified maximum and minimum values.\n\t * @param minimumValue the minimum value\n\t * @param maximumValue the maximum value\n\t * @return the calculated shift (use {@code 1 << shift} to obtain a value)\n\t "
  },
  {
    "entityId": "org.springframework.util.Segment",
    "entityType": "class",
    "code": "private final ReferenceManager referenceManager;\nprivate final int initialSize;\n/**\r\n * Array of references indexed using the low order bits from the hash.\r\n * This property should only be set along with {@code resizeThreshold}.\r\n */\r\n@Nullable\r\nprivate volatile Reference<K, V>[] references;\n/**\r\n * The total number of references contained in this segment. This includes chained\r\n * references and references that have been garbage collected but not purged.\r\n */\r\nprivate final AtomicInteger count = new AtomicInteger();\n/**\r\n * The threshold when resizing of the references should occur. When {@code count}\r\n * exceeds this value references will be resized.\r\n */\r\nprivate int resizeThreshold;\npublic Segment(int initialSize, int resizeThreshold) {\r\n    this.referenceManager = createReferenceManager();\r\n    this.initialSize = initialSize;\r\n    this.references = createReferenceArray(initialSize);\r\n    this.resizeThreshold = resizeThreshold;\r\n}\n@Nullable\r\npublic Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\r\n    if (restructure == Restructure.WHEN_NECESSARY) {\r\n        restructureIfNecessary(false);\r\n    }\r\n    if (this.count.get() == 0) {\r\n        return null;\r\n    }\r\n    // Use a local copy to protect against other threads writing\r\n    @Nullable\r\n    Reference<K, V>[] references = this.references;\r\n    int index = getIndex(hash, references);\r\n    Reference<K, V> head = references[index];\r\n    return findInChain(head, key, hash);\r\n}\n/**\r\n * Apply an update operation to this segment.\r\n * The segment will be locked during the update.\r\n * @param hash the hash of the key\r\n * @param key the key\r\n * @param task the update operation\r\n * @return the result of the operation\r\n */\r\n@Nullable\r\npublic <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {\r\n    boolean resize = task.hasOption(TaskOption.RESIZE);\r\n    if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\r\n        restructureIfNecessary(resize);\r\n    }\r\n    if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\r\n        return task.execute(null, null, null);\r\n    }\r\n    lock();\r\n    try {\r\n        final int index = getIndex(hash, this.references);\r\n        final Reference<K, V> head = this.references[index];\r\n        Reference<K, V> ref = findInChain(head, key, hash);\r\n        Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n        Entries<V> entries = value -> {\r\n            @SuppressWarnings(\"unchecked\")\r\n            Entry<K, V> newEntry = new Entry<>((K) key, value);\r\n            Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\r\n            Segment.this.references[index] = newReference;\r\n            Segment.this.count.incrementAndGet();\r\n        };\r\n        return task.execute(ref, entry, entries);\r\n    } finally {\r\n        unlock();\r\n        if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\r\n            restructureIfNecessary(resize);\r\n        }\r\n    }\r\n}\n/**\r\n * Clear all items from this segment.\r\n */\r\npublic void clear() {\r\n    if (this.count.get() == 0) {\r\n        return;\r\n    }\r\n    lock();\r\n    try {\r\n        this.references = createReferenceArray(this.initialSize);\r\n        this.resizeThreshold = (int) (this.references.length * getLoadFactor());\r\n        this.count.set(0);\r\n    } finally {\r\n        unlock();\r\n    }\r\n}\n/**\r\n * Restructure the underlying data structure when it becomes necessary. This\r\n * method can increase the size of the references table as well as purge any\r\n * references that have been garbage collected.\r\n * @param allowResize if resizing is permitted\r\n */\r\nvoid restructureIfNecessary(boolean allowResize) {\r\n    int currCount = this.count.get();\r\n    boolean needsResize = allowResize && (currCount > 0 && currCount >= this.resizeThreshold);\r\n    Reference<K, V> ref = this.referenceManager.pollForPurge();\r\n    if (ref != null || (needsResize)) {\r\n        restructure(allowResize, ref);\r\n    }\r\n}\nprivate void restructure(boolean allowResize, @Nullable Reference<K, V> ref) {\r\n    boolean needsResize;\r\n    lock();\r\n    try {\r\n        int expectedCount = this.count.get();\r\n        Set<Reference<K, V>> toPurge = Collections.emptySet();\r\n        if (ref != null) {\r\n            toPurge = new HashSet<>();\r\n            while (ref != null) {\r\n                toPurge.add(ref);\r\n                ref = this.referenceManager.pollForPurge();\r\n            }\r\n        }\r\n        expectedCount -= toPurge.size();\r\n        // Estimate new count, taking into account count inside lock and items that\r\n        // will be purged.\r\n        needsResize = (expectedCount > 0 && expectedCount >= this.resizeThreshold);\r\n        boolean resizing = false;\r\n        int restructureSize = this.references.length;\r\n        if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {\r\n            restructureSize <<= 1;\r\n            resizing = true;\r\n        }\r\n        int newCount = 0;\r\n        // Restructure the resized reference array\r\n        if (resizing) {\r\n            Reference<K, V>[] restructured = createReferenceArray(restructureSize);\r\n            for (Reference<K, V> reference : this.references) {\r\n                ref = reference;\r\n                while (ref != null) {\r\n                    if (!toPurge.contains(ref)) {\r\n                        Entry<K, V> entry = ref.get();\r\n                        // Also filter out null references that are now null\r\n                        // they should be polled from the queue in a later restructure call.\r\n                        if (entry != null) {\r\n                            int index = getIndex(ref.getHash(), restructured);\r\n                            restructured[index] = this.referenceManager.createReference(entry, ref.getHash(), restructured[index]);\r\n                            newCount++;\r\n                        }\r\n                    }\r\n                    ref = ref.getNext();\r\n                }\r\n            }\r\n            // Replace volatile members\r\n            this.references = restructured;\r\n            this.resizeThreshold = (int) (this.references.length * getLoadFactor());\r\n        } else // Restructure the existing reference array \"in place\"\r\n        {\r\n            for (int i = 0; i < this.references.length; i++) {\r\n                Reference<K, V> purgedRef = null;\r\n                ref = this.references[i];\r\n                while (ref != null) {\r\n                    if (!toPurge.contains(ref)) {\r\n                        Entry<K, V> entry = ref.get();\r\n                        // Also filter out null references that are now null\r\n                        // they should be polled from the queue in a later restructure call.\r\n                        if (entry != null) {\r\n                            purgedRef = this.referenceManager.createReference(entry, ref.getHash(), purgedRef);\r\n                        }\r\n                        newCount++;\r\n                    }\r\n                    ref = ref.getNext();\r\n                }\r\n                this.references[i] = purgedRef;\r\n            }\r\n        }\r\n        this.count.set(Math.max(newCount, 0));\r\n    } finally {\r\n        unlock();\r\n    }\r\n}\n@Nullable\r\nprivate Reference<K, V> findInChain(@Nullable Reference<K, V> ref, @Nullable Object key, int hash) {\r\n    Reference<K, V> currRef = ref;\r\n    while (currRef != null) {\r\n        if (currRef.getHash() == hash) {\r\n            Entry<K, V> entry = currRef.get();\r\n            if (entry != null) {\r\n                K entryKey = entry.getKey();\r\n                if (ObjectUtils.nullSafeEquals(entryKey, key)) {\r\n                    return currRef;\r\n                }\r\n            }\r\n        }\r\n        currRef = currRef.getNext();\r\n    }\r\n    return null;\r\n}\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\nprivate Reference<K, V>[] createReferenceArray(int size) {\r\n    return new Reference[size];\r\n}\nprivate int getIndex(int hash, @Nullable Reference<K, V>[] references) {\r\n    return (hash & (references.length - 1));\r\n}\n/**\r\n * Return the size of the current references array.\r\n */\r\npublic int getSize() {\r\n    return this.references.length;\r\n}\n/**\r\n * Return the total number of references in this segment.\r\n */\r\npublic int getCount() {\r\n    return this.count.get();\r\n}",
    "comment": "\n\t * A single segment used to divide the map to allow better concurrent performance.\n\t "
  },
  {
    "entityId": "org.springframework.util.Segment#getReference(Object,int,Restructure)",
    "entityType": "method",
    "code": "@Nullable\r\npublic Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {\r\n    if (restructure == Restructure.WHEN_NECESSARY) {\r\n        restructureIfNecessary(false);\r\n    }\r\n    if (this.count.get() == 0) {\r\n        return null;\r\n    }\r\n    // Use a local copy to protect against other threads writing\r\n    @Nullable\r\n    Reference<K, V>[] references = this.references;\r\n    int index = getIndex(hash, references);\r\n    Reference<K, V> head = references[index];\r\n    return findInChain(head, key, hash);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Segment#doTask(int,Object,Task<T>)",
    "entityType": "method",
    "code": "/**\r\n * Apply an update operation to this segment.\r\n * The segment will be locked during the update.\r\n * @param hash the hash of the key\r\n * @param key the key\r\n * @param task the update operation\r\n * @return the result of the operation\r\n */\r\n@Nullable\r\npublic <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {\r\n    boolean resize = task.hasOption(TaskOption.RESIZE);\r\n    if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {\r\n        restructureIfNecessary(resize);\r\n    }\r\n    if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {\r\n        return task.execute(null, null, null);\r\n    }\r\n    lock();\r\n    try {\r\n        final int index = getIndex(hash, this.references);\r\n        final Reference<K, V> head = this.references[index];\r\n        Reference<K, V> ref = findInChain(head, key, hash);\r\n        Entry<K, V> entry = (ref != null ? ref.get() : null);\r\n        Entries<V> entries = value -> {\r\n            @SuppressWarnings(\"unchecked\")\r\n            Entry<K, V> newEntry = new Entry<>((K) key, value);\r\n            Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);\r\n            Segment.this.references[index] = newReference;\r\n            Segment.this.count.incrementAndGet();\r\n        };\r\n        return task.execute(ref, entry, entries);\r\n    } finally {\r\n        unlock();\r\n        if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {\r\n            restructureIfNecessary(resize);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t\t * Apply an update operation to this segment.\n\t\t * The segment will be locked during the update.\n\t\t * @param hash the hash of the key\n\t\t * @param key the key\n\t\t * @param task the update operation\n\t\t * @return the result of the operation\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Segment#clear()",
    "entityType": "method",
    "code": "/**\r\n * Clear all items from this segment.\r\n */\r\npublic void clear() {\r\n    if (this.count.get() == 0) {\r\n        return;\r\n    }\r\n    lock();\r\n    try {\r\n        this.references = createReferenceArray(this.initialSize);\r\n        this.resizeThreshold = (int) (this.references.length * getLoadFactor());\r\n        this.count.set(0);\r\n    } finally {\r\n        unlock();\r\n    }\r\n}",
    "comment": "\n\t\t * Clear all items from this segment.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Restructure the underlying data structure when it becomes necessary. This\r\n * method can increase the size of the references table as well as purge any\r\n * references that have been garbage collected.\r\n * @param allowResize if resizing is permitted\r\n */\r\nvoid restructureIfNecessary(boolean allowResize) {\r\n    int currCount = this.count.get();\r\n    boolean needsResize = allowResize && (currCount > 0 && currCount >= this.resizeThreshold);\r\n    Reference<K, V> ref = this.referenceManager.pollForPurge();\r\n    if (ref != null || (needsResize)) {\r\n        restructure(allowResize, ref);\r\n    }\r\n}",
    "comment": "\n\t\t * Restructure the underlying data structure when it becomes necessary. This\n\t\t * method can increase the size of the references table as well as purge any\n\t\t * references that have been garbage collected.\n\t\t * @param allowResize if resizing is permitted\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Segment#restructure(boolean,Reference<K,V>)",
    "entityType": "method",
    "code": "private void restructure(boolean allowResize, @Nullable Reference<K, V> ref) {\r\n    boolean needsResize;\r\n    lock();\r\n    try {\r\n        int expectedCount = this.count.get();\r\n        Set<Reference<K, V>> toPurge = Collections.emptySet();\r\n        if (ref != null) {\r\n            toPurge = new HashSet<>();\r\n            while (ref != null) {\r\n                toPurge.add(ref);\r\n                ref = this.referenceManager.pollForPurge();\r\n            }\r\n        }\r\n        expectedCount -= toPurge.size();\r\n        // Estimate new count, taking into account count inside lock and items that\r\n        // will be purged.\r\n        needsResize = (expectedCount > 0 && expectedCount >= this.resizeThreshold);\r\n        boolean resizing = false;\r\n        int restructureSize = this.references.length;\r\n        if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {\r\n            restructureSize <<= 1;\r\n            resizing = true;\r\n        }\r\n        int newCount = 0;\r\n        // Restructure the resized reference array\r\n        if (resizing) {\r\n            Reference<K, V>[] restructured = createReferenceArray(restructureSize);\r\n            for (Reference<K, V> reference : this.references) {\r\n                ref = reference;\r\n                while (ref != null) {\r\n                    if (!toPurge.contains(ref)) {\r\n                        Entry<K, V> entry = ref.get();\r\n                        // Also filter out null references that are now null\r\n                        // they should be polled from the queue in a later restructure call.\r\n                        if (entry != null) {\r\n                            int index = getIndex(ref.getHash(), restructured);\r\n                            restructured[index] = this.referenceManager.createReference(entry, ref.getHash(), restructured[index]);\r\n                            newCount++;\r\n                        }\r\n                    }\r\n                    ref = ref.getNext();\r\n                }\r\n            }\r\n            // Replace volatile members\r\n            this.references = restructured;\r\n            this.resizeThreshold = (int) (this.references.length * getLoadFactor());\r\n        } else // Restructure the existing reference array \"in place\"\r\n        {\r\n            for (int i = 0; i < this.references.length; i++) {\r\n                Reference<K, V> purgedRef = null;\r\n                ref = this.references[i];\r\n                while (ref != null) {\r\n                    if (!toPurge.contains(ref)) {\r\n                        Entry<K, V> entry = ref.get();\r\n                        // Also filter out null references that are now null\r\n                        // they should be polled from the queue in a later restructure call.\r\n                        if (entry != null) {\r\n                            purgedRef = this.referenceManager.createReference(entry, ref.getHash(), purgedRef);\r\n                        }\r\n                        newCount++;\r\n                    }\r\n                    ref = ref.getNext();\r\n                }\r\n                this.references[i] = purgedRef;\r\n            }\r\n        }\r\n        this.count.set(Math.max(newCount, 0));\r\n    } finally {\r\n        unlock();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate Reference<K, V> findInChain(@Nullable Reference<K, V> ref, @Nullable Object key, int hash) {\r\n    Reference<K, V> currRef = ref;\r\n    while (currRef != null) {\r\n        if (currRef.getHash() == hash) {\r\n            Entry<K, V> entry = currRef.get();\r\n            if (entry != null) {\r\n                K entryKey = entry.getKey();\r\n                if (ObjectUtils.nullSafeEquals(entryKey, key)) {\r\n                    return currRef;\r\n                }\r\n            }\r\n        }\r\n        currRef = currRef.getNext();\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Segment#createReferenceArray(int)",
    "entityType": "method",
    "code": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\nprivate Reference<K, V>[] createReferenceArray(int size) {\r\n    return new Reference[size];\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
    "entityType": "method",
    "code": "private int getIndex(int hash, @Nullable Reference<K, V>[] references) {\r\n    return (hash & (references.length - 1));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Segment#getSize()",
    "entityType": "method",
    "code": "/**\r\n * Return the size of the current references array.\r\n */\r\npublic int getSize() {\r\n    return this.references.length;\r\n}",
    "comment": "\n\t\t * Return the size of the current references array.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Segment#getCount()",
    "entityType": "method",
    "code": "/**\r\n * Return the total number of references in this segment.\r\n */\r\npublic int getCount() {\r\n    return this.count.get();\r\n}",
    "comment": "\n\t\t * Return the total number of references in this segment.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Reference",
    "entityType": "class",
    "code": "/**\r\n * Return the referenced entry, or {@code null} if the entry is no longer available.\r\n */\r\n@Nullable\r\nEntry<K, V> get();\n/**\r\n * Return the hash for the reference.\r\n */\r\nint getHash();\n/**\r\n * Return the next reference in the chain, or {@code null} if none.\r\n */\r\n@Nullable\r\nReference<K, V> getNext();\n/**\r\n * Release this entry and ensure that it will be returned from\r\n * {@code ReferenceManager#pollForPurge()}.\r\n */\r\nvoid release();",
    "comment": "\n\t * A reference to an {@link Entry} contained in the map. Implementations are usually\n\t * wrappers around specific Java reference implementations (for example, {@link SoftReference}).\n\t * @param <K> the key type\n\t * @param <V> the value type\n\t "
  },
  {
    "entityId": "org.springframework.util.Reference#get()",
    "entityType": "method",
    "code": "/**\r\n * Return the referenced entry, or {@code null} if the entry is no longer available.\r\n */\r\n@Nullable\r\nEntry<K, V> get();",
    "comment": "\n\t\t * Return the referenced entry, or {@code null} if the entry is no longer available.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Reference#getHash()",
    "entityType": "method",
    "code": "/**\r\n * Return the hash for the reference.\r\n */\r\nint getHash();",
    "comment": "\n\t\t * Return the hash for the reference.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Reference#getNext()",
    "entityType": "method",
    "code": "/**\r\n * Return the next reference in the chain, or {@code null} if none.\r\n */\r\n@Nullable\r\nReference<K, V> getNext();",
    "comment": "\n\t\t * Return the next reference in the chain, or {@code null} if none.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Reference#release()",
    "entityType": "method",
    "code": "/**\r\n * Release this entry and ensure that it will be returned from\r\n * {@code ReferenceManager#pollForPurge()}.\r\n */\r\nvoid release();",
    "comment": "\n\t\t * Release this entry and ensure that it will be returned from\n\t\t * {@code ReferenceManager#pollForPurge()}.\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Entry",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final K key;\n@Nullable\r\nprivate volatile V value;\npublic Entry(@Nullable K key, @Nullable V value) {\r\n    this.key = key;\r\n    this.value = value;\r\n}\n@Override\r\n@Nullable\r\npublic K getKey() {\r\n    return this.key;\r\n}\n@Override\r\n@Nullable\r\npublic V getValue() {\r\n    return this.value;\r\n}\n@Override\r\n@Nullable\r\npublic V setValue(@Nullable V value) {\r\n    V previous = this.value;\r\n    this.value = value;\r\n    return previous;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Map.Entry<?, ?> that && ObjectUtils.nullSafeEquals(getKey(), that.getKey()) && ObjectUtils.nullSafeEquals(getValue(), that.getValue())));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value));\r\n}\n@Override\r\npublic String toString() {\r\n    return (this.key + \"=\" + this.value);\r\n}",
    "comment": "\n\t * A single map entry.\n\t * @param <K> the key type\n\t * @param <V> the value type\n\t "
  },
  {
    "entityId": "org.springframework.util.Entry#getKey()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic K getKey() {\r\n    return this.key;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Entry#getValue()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V getValue() {\r\n    return this.value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Entry#setValue(V)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic V setValue(@Nullable V value) {\r\n    V previous = this.value;\r\n    this.value = value;\r\n    return previous;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Entry#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Map.Entry<?, ?> that && ObjectUtils.nullSafeEquals(getKey(), that.getKey()) && ObjectUtils.nullSafeEquals(getValue(), that.getValue())));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Entry#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Entry#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return (this.key + \"=\" + this.value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Task",
    "entityType": "class",
    "code": "private final EnumSet<TaskOption> options;\npublic Task(TaskOption... options) {\r\n    this.options = (options.length == 0 ? EnumSet.noneOf(TaskOption.class) : EnumSet.of(options[0], options));\r\n}\npublic boolean hasOption(TaskOption option) {\r\n    return this.options.contains(option);\r\n}\n/**\r\n * Execute the task.\r\n * @param ref the found reference (or {@code null})\r\n * @param entry the found entry (or {@code null})\r\n * @param entries access to the underlying entries\r\n * @return the result of the task\r\n * @see #execute(Reference, Entry)\r\n */\r\n@Nullable\r\nprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\r\n    return execute(ref, entry);\r\n}\n/**\r\n * Convenience method that can be used for tasks that do not need access to {@link Entries}.\r\n * @param ref the found reference (or {@code null})\r\n * @param entry the found entry (or {@code null})\r\n * @return the result of the task\r\n * @see #execute(Reference, Entry, Entries)\r\n */\r\n@Nullable\r\nprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n    return null;\r\n}",
    "comment": "\n\t * A task that can be {@link Segment#doTask run} against a {@link Segment}.\n\t "
  },
  {
    "entityId": "org.springframework.util.Task#hasOption(TaskOption)",
    "entityType": "method",
    "code": "public boolean hasOption(TaskOption option) {\r\n    return this.options.contains(option);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
    "entityType": "method",
    "code": "/**\r\n * Execute the task.\r\n * @param ref the found reference (or {@code null})\r\n * @param entry the found entry (or {@code null})\r\n * @param entries access to the underlying entries\r\n * @return the result of the task\r\n * @see #execute(Reference, Entry)\r\n */\r\n@Nullable\r\nprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {\r\n    return execute(ref, entry);\r\n}",
    "comment": "\n\t\t * Execute the task.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @param entries access to the underlying entries\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry)\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Convenience method that can be used for tasks that do not need access to {@link Entries}.\r\n * @param ref the found reference (or {@code null})\r\n * @param entry the found entry (or {@code null})\r\n * @return the result of the task\r\n * @see #execute(Reference, Entry, Entries)\r\n */\r\n@Nullable\r\nprotected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {\r\n    return null;\r\n}",
    "comment": "\n\t\t * Convenience method that can be used for tasks that do not need access to {@link Entries}.\n\t\t * @param ref the found reference (or {@code null})\n\t\t * @param entry the found entry (or {@code null})\n\t\t * @return the result of the task\n\t\t * @see #execute(Reference, Entry, Entries)\n\t\t "
  },
  {
    "entityId": "org.springframework.util.Entries",
    "entityType": "class",
    "code": "/**\r\n * Add a new entry with the specified value.\r\n * @param value the value to add\r\n */\r\nvoid add(@Nullable V value);",
    "comment": "\n\t * Allows a task access to {@link ConcurrentReferenceHashMap.Segment} entries.\n\t "
  },
  {
    "entityId": "org.springframework.util.Entries#add(V)",
    "entityType": "method",
    "code": "/**\r\n * Add a new entry with the specified value.\r\n * @param value the value to add\r\n */\r\nvoid add(@Nullable V value);",
    "comment": "\n\t\t * Add a new entry with the specified value.\n\t\t * @param value the value to add\n\t\t "
  },
  {
    "entityId": "org.springframework.util.EntrySet",
    "entityType": "class",
    "code": "@Override\r\npublic Iterator<Map.Entry<K, V>> iterator() {\r\n    return new EntryIterator();\r\n}\n@Override\r\npublic boolean contains(@Nullable Object o) {\r\n    if (o instanceof Map.Entry<?, ?> entry) {\r\n        Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);\r\n        Entry<K, V> otherEntry = (ref != null ? ref.get() : null);\r\n        if (otherEntry != null) {\r\n            return ObjectUtils.nullSafeEquals(entry.getValue(), otherEntry.getValue());\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic boolean remove(Object o) {\r\n    if (o instanceof Map.Entry<?, ?> entry) {\r\n        return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic int size() {\r\n    return ConcurrentReferenceHashMap.this.size();\r\n}\n@Override\r\npublic void clear() {\r\n    ConcurrentReferenceHashMap.this.clear();\r\n}",
    "comment": "\n\t * Internal entry-set implementation.\n\t "
  },
  {
    "entityId": "org.springframework.util.EntrySet#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<Map.Entry<K, V>> iterator() {\r\n    return new EntryIterator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#contains(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean contains(@Nullable Object o) {\r\n    if (o instanceof Map.Entry<?, ?> entry) {\r\n        Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);\r\n        Entry<K, V> otherEntry = (ref != null ? ref.get() : null);\r\n        if (otherEntry != null) {\r\n            return ObjectUtils.nullSafeEquals(entry.getValue(), otherEntry.getValue());\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean remove(Object o) {\r\n    if (o instanceof Map.Entry<?, ?> entry) {\r\n        return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#size()",
    "entityType": "method",
    "code": "@Override\r\npublic int size() {\r\n    return ConcurrentReferenceHashMap.this.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntrySet#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    ConcurrentReferenceHashMap.this.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator",
    "entityType": "class",
    "code": "private int segmentIndex;\nprivate int referenceIndex;\n@Nullable\r\nprivate Reference<K, V> @Nullable [] references;\n@Nullable\r\nprivate Reference<K, V> reference;\n@Nullable\r\nprivate Entry<K, V> next;\n@Nullable\r\nprivate Entry<K, V> last;\npublic EntryIterator() {\r\n    moveToNextSegment();\r\n}\n@Override\r\npublic boolean hasNext() {\r\n    getNextIfNecessary();\r\n    return (this.next != null);\r\n}\n@Override\r\npublic Entry<K, V> next() {\r\n    getNextIfNecessary();\r\n    if (this.next == null) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    this.last = this.next;\r\n    this.next = null;\r\n    return this.last;\r\n}\nprivate void getNextIfNecessary() {\r\n    while (this.next == null) {\r\n        moveToNextReference();\r\n        if (this.reference == null) {\r\n            return;\r\n        }\r\n        this.next = this.reference.get();\r\n    }\r\n}\nprivate void moveToNextReference() {\r\n    if (this.reference != null) {\r\n        this.reference = this.reference.getNext();\r\n    }\r\n    while (this.reference == null && this.references != null) {\r\n        if (this.referenceIndex >= this.references.length) {\r\n            moveToNextSegment();\r\n            this.referenceIndex = 0;\r\n        } else {\r\n            this.reference = this.references[this.referenceIndex];\r\n            this.referenceIndex++;\r\n        }\r\n    }\r\n}\nprivate void moveToNextSegment() {\r\n    this.reference = null;\r\n    this.references = null;\r\n    if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {\r\n        this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;\r\n        this.segmentIndex++;\r\n    }\r\n}\n@Override\r\npublic void remove() {\r\n    Assert.state(this.last != null, \"No element to remove\");\r\n    ConcurrentReferenceHashMap.this.remove(this.last.getKey());\r\n    this.last = null;\r\n}",
    "comment": "\n\t * Internal entry iterator implementation.\n\t "
  },
  {
    "entityId": "org.springframework.util.EntryIterator#hasNext()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasNext() {\r\n    getNextIfNecessary();\r\n    return (this.next != null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#next()",
    "entityType": "method",
    "code": "@Override\r\npublic Entry<K, V> next() {\r\n    getNextIfNecessary();\r\n    if (this.next == null) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    this.last = this.next;\r\n    this.next = null;\r\n    return this.last;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#getNextIfNecessary()",
    "entityType": "method",
    "code": "private void getNextIfNecessary() {\r\n    while (this.next == null) {\r\n        moveToNextReference();\r\n        if (this.reference == null) {\r\n            return;\r\n        }\r\n        this.next = this.reference.get();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#moveToNextReference()",
    "entityType": "method",
    "code": "private void moveToNextReference() {\r\n    if (this.reference != null) {\r\n        this.reference = this.reference.getNext();\r\n    }\r\n    while (this.reference == null && this.references != null) {\r\n        if (this.referenceIndex >= this.references.length) {\r\n            moveToNextSegment();\r\n            this.referenceIndex = 0;\r\n        } else {\r\n            this.reference = this.references[this.referenceIndex];\r\n            this.referenceIndex++;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#moveToNextSegment()",
    "entityType": "method",
    "code": "private void moveToNextSegment() {\r\n    this.reference = null;\r\n    this.references = null;\r\n    if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {\r\n        this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;\r\n        this.segmentIndex++;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.EntryIterator#remove()",
    "entityType": "method",
    "code": "@Override\r\npublic void remove() {\r\n    Assert.state(this.last != null, \"No element to remove\");\r\n    ConcurrentReferenceHashMap.this.remove(this.last.getKey());\r\n    this.last = null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ReferenceManager",
    "entityType": "class",
    "code": "private final ReferenceQueue<Entry<K, V>> queue = new ReferenceQueue<>();\n/**\r\n * Factory method used to create a new {@link Reference}.\r\n * @param entry the entry contained in the reference\r\n * @param hash the hash\r\n * @param next the next reference in the chain, or {@code null} if none\r\n * @return a new {@link Reference}\r\n */\r\npublic Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\r\n    if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\r\n        return new WeakEntryReference<>(entry, hash, next, this.queue);\r\n    }\r\n    return new SoftEntryReference<>(entry, hash, next, this.queue);\r\n}\n/**\r\n * Return any reference that has been garbage collected and can be purged from the\r\n * underlying structure or {@code null} if no references need purging. This\r\n * method must be thread safe and ideally should not block when returning\r\n * {@code null}. References should be returned once and only once.\r\n * @return a reference to purge or {@code null}\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic Reference<K, V> pollForPurge() {\r\n    return (Reference<K, V>) this.queue.poll();\r\n}",
    "comment": "\n\t * Strategy class used to manage {@link Reference References}.\n\t * This class can be overridden if alternative reference types need to be supported.\n\t "
  },
  {
    "entityId": "org.springframework.util.ReferenceManager#createReference(Entry<K,V>,int,Reference<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Factory method used to create a new {@link Reference}.\r\n * @param entry the entry contained in the reference\r\n * @param hash the hash\r\n * @param next the next reference in the chain, or {@code null} if none\r\n * @return a new {@link Reference}\r\n */\r\npublic Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\r\n    if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\r\n        return new WeakEntryReference<>(entry, hash, next, this.queue);\r\n    }\r\n    return new SoftEntryReference<>(entry, hash, next, this.queue);\r\n}",
    "comment": "\n\t\t * Factory method used to create a new {@link Reference}.\n\t\t * @param entry the entry contained in the reference\n\t\t * @param hash the hash\n\t\t * @param next the next reference in the chain, or {@code null} if none\n\t\t * @return a new {@link Reference}\n\t\t "
  },
  {
    "entityId": "org.springframework.util.ReferenceManager#pollForPurge()",
    "entityType": "method",
    "code": "/**\r\n * Return any reference that has been garbage collected and can be purged from the\r\n * underlying structure or {@code null} if no references need purging. This\r\n * method must be thread safe and ideally should not block when returning\r\n * {@code null}. References should be returned once and only once.\r\n * @return a reference to purge or {@code null}\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\npublic Reference<K, V> pollForPurge() {\r\n    return (Reference<K, V>) this.queue.poll();\r\n}",
    "comment": "\n\t\t * Return any reference that has been garbage collected and can be purged from the\n\t\t * underlying structure or {@code null} if no references need purging. This\n\t\t * method must be thread safe and ideally should not block when returning\n\t\t * {@code null}. References should be returned once and only once.\n\t\t * @return a reference to purge or {@code null}\n\t\t "
  },
  {
    "entityId": "org.springframework.util.SoftEntryReference",
    "entityType": "class",
    "code": "private final int hash;\n@Nullable\r\nprivate final Reference<K, V> nextReference;\npublic SoftEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next, ReferenceQueue<Entry<K, V>> queue) {\r\n    super(entry, queue);\r\n    this.hash = hash;\r\n    this.nextReference = next;\r\n}\n@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}\n@Override\r\n@Nullable\r\npublic Reference<K, V> getNext() {\r\n    return this.nextReference;\r\n}\n@Override\r\npublic void release() {\r\n    enqueue();\r\n}",
    "comment": "\n\t * Internal {@link Reference} implementation for {@link SoftReference SoftReferences}.\n\t "
  },
  {
    "entityId": "org.springframework.util.SoftEntryReference#getHash()",
    "entityType": "method",
    "code": "@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}",
    "comment": ""
  }
]