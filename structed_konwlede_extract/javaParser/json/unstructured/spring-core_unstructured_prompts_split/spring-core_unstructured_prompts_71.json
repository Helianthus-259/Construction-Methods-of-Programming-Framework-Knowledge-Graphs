[
  {
    "entityId": "org.springframework.core.SimpleAliasRegistry#canonicalName(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine the raw name, resolving aliases to canonical names.\r\n * @param name the user-specified name\r\n * @return the transformed name\r\n */\r\npublic String canonicalName(String name) {\r\n    String canonicalName = name;\r\n    // Handle aliasing...\r\n    String resolvedName;\r\n    do {\r\n        resolvedName = this.aliasMap.get(canonicalName);\r\n        if (resolvedName != null) {\r\n            canonicalName = resolvedName;\r\n        }\r\n    } while (resolvedName != null);\r\n    return canonicalName;\r\n}",
    "comment": "\n\t * Determine the raw name, resolving aliases to canonical names.\n\t * @param name the user-specified name\n\t * @return the transformed name\n\t "
  },
  {
    "entityId": "org.springframework.core.SmartClassLoader",
    "entityType": "class",
    "code": "/**\r\n * Determine whether the given class is reloadable (in this ClassLoader).\r\n * <p>Typically used to check whether the result may be cached (for this\r\n * ClassLoader) or whether it should be reobtained every time.\r\n * The default implementation always returns {@code false}.\r\n * @param clazz the class to check (usually loaded from this ClassLoader)\r\n * @return whether the class should be expected to appear in a reloaded\r\n * version (with a different {@code Class} object) later on\r\n */\r\ndefault boolean isClassReloadable(Class<?> clazz) {\r\n    return false;\r\n}\n/**\r\n * Return the original ClassLoader for this SmartClassLoader, or potentially\r\n * the present loader itself if it is self-sufficient.\r\n * <p>The default implementation returns the local ClassLoader reference as-is.\r\n * In case of a reloadable or other selectively overriding ClassLoader which\r\n * commonly deals with unaffected classes from a base application class loader,\r\n * this should get implemented to return the original ClassLoader that the\r\n * present loader got derived from (for example, through {@code return getParent();}).\r\n * <p>This gets specifically used in Spring's AOP framework to determine the\r\n * class loader for a specific proxy in case the target class has not been\r\n * defined in the present class loader. In case of a reloadable class loader,\r\n * we prefer the base application class loader for proxying general classes\r\n * not defined in the reloadable class loader itself.\r\n * @return the original ClassLoader (the same reference by default)\r\n * @since 5.3.5\r\n * @see ClassLoader#getParent()\r\n * @see org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator\r\n */\r\ndefault ClassLoader getOriginalClassLoader() {\r\n    return (ClassLoader) this;\r\n}\n/**\r\n * Define a custom class (typically a CGLIB proxy class) in this class loader.\r\n * <p>This is a public equivalent of the protected\r\n * {@code defineClass(String, byte[], int, int, ProtectionDomain)} method\r\n * in {@link ClassLoader} which is traditionally invoked via reflection.\r\n * A concrete implementation in a custom class loader should simply delegate\r\n * to that protected method in order to make classloader-specific definitions\r\n * publicly available without \"illegal access\" warnings on JDK 9+:\r\n * {@code return defineClass(name, b, 0, b.length, protectionDomain)}.\r\n * Note that the JDK 9+ {@code Lookup#defineClass} method does not support\r\n * a custom target class loader for the new definition; it rather always\r\n * defines the class in the same class loader as the lookup's context class.\r\n * @param name the name of the class\r\n * @param b the bytes defining the class\r\n * @param protectionDomain the protection domain for the class, if any\r\n * @return the newly created class\r\n * @throws LinkageError in case of a bad class definition\r\n * @throws SecurityException in case of an invalid definition attempt\r\n * @throws UnsupportedOperationException in case of a custom definition attempt\r\n * not being possible (thrown by the default implementation in this interface)\r\n * @since 5.3.4\r\n * @see ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)\r\n */\r\ndefault Class<?> publicDefineClass(String name, byte[] b, @Nullable ProtectionDomain protectionDomain) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": "\n * Interface to be implemented by a reloading-aware ClassLoader\n * (for example, a Groovy-based ClassLoader). Detected for example by\n * Spring's CGLIB proxy factory for making a caching decision.\n *\n * <p>If a ClassLoader does <i>not</i> implement this interface,\n * then all the classes obtained from it should be considered\n * as not reloadable (i.e. cacheable).\n *\n * @author Juergen Hoeller\n * @since 2.5.1\n "
  },
  {
    "entityId": "org.springframework.core.SmartClassLoader#isClassReloadable(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given class is reloadable (in this ClassLoader).\r\n * <p>Typically used to check whether the result may be cached (for this\r\n * ClassLoader) or whether it should be reobtained every time.\r\n * The default implementation always returns {@code false}.\r\n * @param clazz the class to check (usually loaded from this ClassLoader)\r\n * @return whether the class should be expected to appear in a reloaded\r\n * version (with a different {@code Class} object) later on\r\n */\r\ndefault boolean isClassReloadable(Class<?> clazz) {\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the given class is reloadable (in this ClassLoader).\n\t * <p>Typically used to check whether the result may be cached (for this\n\t * ClassLoader) or whether it should be reobtained every time.\n\t * The default implementation always returns {@code false}.\n\t * @param clazz the class to check (usually loaded from this ClassLoader)\n\t * @return whether the class should be expected to appear in a reloaded\n\t * version (with a different {@code Class} object) later on\n\t "
  },
  {
    "entityId": "org.springframework.core.SmartClassLoader#getOriginalClassLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the original ClassLoader for this SmartClassLoader, or potentially\r\n * the present loader itself if it is self-sufficient.\r\n * <p>The default implementation returns the local ClassLoader reference as-is.\r\n * In case of a reloadable or other selectively overriding ClassLoader which\r\n * commonly deals with unaffected classes from a base application class loader,\r\n * this should get implemented to return the original ClassLoader that the\r\n * present loader got derived from (for example, through {@code return getParent();}).\r\n * <p>This gets specifically used in Spring's AOP framework to determine the\r\n * class loader for a specific proxy in case the target class has not been\r\n * defined in the present class loader. In case of a reloadable class loader,\r\n * we prefer the base application class loader for proxying general classes\r\n * not defined in the reloadable class loader itself.\r\n * @return the original ClassLoader (the same reference by default)\r\n * @since 5.3.5\r\n * @see ClassLoader#getParent()\r\n * @see org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator\r\n */\r\ndefault ClassLoader getOriginalClassLoader() {\r\n    return (ClassLoader) this;\r\n}",
    "comment": "\n\t * Return the original ClassLoader for this SmartClassLoader, or potentially\n\t * the present loader itself if it is self-sufficient.\n\t * <p>The default implementation returns the local ClassLoader reference as-is.\n\t * In case of a reloadable or other selectively overriding ClassLoader which\n\t * commonly deals with unaffected classes from a base application class loader,\n\t * this should get implemented to return the original ClassLoader that the\n\t * present loader got derived from (for example, through {@code return getParent();}).\n\t * <p>This gets specifically used in Spring's AOP framework to determine the\n\t * class loader for a specific proxy in case the target class has not been\n\t * defined in the present class loader. In case of a reloadable class loader,\n\t * we prefer the base application class loader for proxying general classes\n\t * not defined in the reloadable class loader itself.\n\t * @return the original ClassLoader (the same reference by default)\n\t * @since 5.3.5\n\t * @see ClassLoader#getParent()\n\t * @see org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator\n\t "
  },
  {
    "entityId": "org.springframework.core.SmartClassLoader#publicDefineClass(String,byte[],ProtectionDomain)",
    "entityType": "method",
    "code": "/**\r\n * Define a custom class (typically a CGLIB proxy class) in this class loader.\r\n * <p>This is a public equivalent of the protected\r\n * {@code defineClass(String, byte[], int, int, ProtectionDomain)} method\r\n * in {@link ClassLoader} which is traditionally invoked via reflection.\r\n * A concrete implementation in a custom class loader should simply delegate\r\n * to that protected method in order to make classloader-specific definitions\r\n * publicly available without \"illegal access\" warnings on JDK 9+:\r\n * {@code return defineClass(name, b, 0, b.length, protectionDomain)}.\r\n * Note that the JDK 9+ {@code Lookup#defineClass} method does not support\r\n * a custom target class loader for the new definition; it rather always\r\n * defines the class in the same class loader as the lookup's context class.\r\n * @param name the name of the class\r\n * @param b the bytes defining the class\r\n * @param protectionDomain the protection domain for the class, if any\r\n * @return the newly created class\r\n * @throws LinkageError in case of a bad class definition\r\n * @throws SecurityException in case of an invalid definition attempt\r\n * @throws UnsupportedOperationException in case of a custom definition attempt\r\n * not being possible (thrown by the default implementation in this interface)\r\n * @since 5.3.4\r\n * @see ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)\r\n */\r\ndefault Class<?> publicDefineClass(String name, byte[] b, @Nullable ProtectionDomain protectionDomain) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": "\n\t * Define a custom class (typically a CGLIB proxy class) in this class loader.\n\t * <p>This is a public equivalent of the protected\n\t * {@code defineClass(String, byte[], int, int, ProtectionDomain)} method\n\t * in {@link ClassLoader} which is traditionally invoked via reflection.\n\t * A concrete implementation in a custom class loader should simply delegate\n\t * to that protected method in order to make classloader-specific definitions\n\t * publicly available without \"illegal access\" warnings on JDK 9+:\n\t * {@code return defineClass(name, b, 0, b.length, protectionDomain)}.\n\t * Note that the JDK 9+ {@code Lookup#defineClass} method does not support\n\t * a custom target class loader for the new definition; it rather always\n\t * defines the class in the same class loader as the lookup's context class.\n\t * @param name the name of the class\n\t * @param b the bytes defining the class\n\t * @param protectionDomain the protection domain for the class, if any\n\t * @return the newly created class\n\t * @throws LinkageError in case of a bad class definition\n\t * @throws SecurityException in case of an invalid definition attempt\n\t * @throws UnsupportedOperationException in case of a custom definition attempt\n\t * not being possible (thrown by the default implementation in this interface)\n\t * @since 5.3.4\n\t * @see ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)\n\t "
  },
  {
    "entityId": "org.springframework.core.SortedProperties",
    "entityType": "class",
    "code": "static final String EOL = System.lineSeparator();\nprivate static final Comparator<Object> keyComparator = Comparator.comparing(String::valueOf);\nprivate static final Comparator<Entry<Object, Object>> entryComparator = Entry.comparingByKey(keyComparator);\nprivate final boolean omitComments;\n/**\r\n * Construct a new {@code SortedProperties} instance that honors the supplied\r\n * {@code omitComments} flag.\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n */\r\nSortedProperties(boolean omitComments) {\r\n    this.omitComments = omitComments;\r\n}\n/**\r\n * Construct a new {@code SortedProperties} instance with properties populated\r\n * from the supplied {@link Properties} object and honoring the supplied\r\n * {@code omitComments} flag.\r\n * <p>Default properties from the supplied {@code Properties} object will\r\n * not be copied.\r\n * @param properties the {@code Properties} object from which to copy the\r\n * initial properties\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n */\r\nSortedProperties(Properties properties, boolean omitComments) {\r\n    this(omitComments);\r\n    putAll(properties);\r\n}\n@Override\r\npublic void store(OutputStream out, @Nullable String comments) throws IOException {\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    super.store(baos, (this.omitComments ? null : comments));\r\n    String contents = baos.toString(StandardCharsets.ISO_8859_1);\r\n    for (String line : contents.split(EOL)) {\r\n        if (!(this.omitComments && line.startsWith(\"#\"))) {\r\n            out.write((line + EOL).getBytes(StandardCharsets.ISO_8859_1));\r\n        }\r\n    }\r\n}\n@Override\r\npublic void store(Writer writer, @Nullable String comments) throws IOException {\r\n    StringWriter stringWriter = new StringWriter();\r\n    super.store(stringWriter, (this.omitComments ? null : comments));\r\n    String contents = stringWriter.toString();\r\n    for (String line : contents.split(EOL)) {\r\n        if (!(this.omitComments && line.startsWith(\"#\"))) {\r\n            writer.write(line + EOL);\r\n        }\r\n    }\r\n}\n@Override\r\npublic void storeToXML(OutputStream out, @Nullable String comments) throws IOException {\r\n    super.storeToXML(out, (this.omitComments ? null : comments));\r\n}\n@Override\r\npublic void storeToXML(OutputStream out, @Nullable String comments, String encoding) throws IOException {\r\n    super.storeToXML(out, (this.omitComments ? null : comments), encoding);\r\n}\n/**\r\n * Return a sorted enumeration of the keys in this {@link Properties} object.\r\n * @see #keySet()\r\n */\r\n@Override\r\npublic synchronized Enumeration<Object> keys() {\r\n    return Collections.enumeration(keySet());\r\n}\n/**\r\n * Return a sorted set of the keys in this {@link Properties} object.\r\n * <p>The keys will be converted to strings if necessary using\r\n * {@link String#valueOf(Object)} and sorted alphanumerically according to\r\n * the natural order of strings.\r\n */\r\n@Override\r\npublic Set<Object> keySet() {\r\n    Set<Object> sortedKeys = new TreeSet<>(keyComparator);\r\n    sortedKeys.addAll(super.keySet());\r\n    return Collections.synchronizedSet(sortedKeys);\r\n}\n/**\r\n * Return a sorted set of the entries in this {@link Properties} object.\r\n * <p>The entries will be sorted based on their keys, and the keys will be\r\n * converted to strings if necessary using {@link String#valueOf(Object)}\r\n * and compared alphanumerically according to the natural order of strings.\r\n */\r\n@Override\r\npublic Set<Entry<Object, Object>> entrySet() {\r\n    Set<Entry<Object, Object>> sortedEntries = new TreeSet<>(entryComparator);\r\n    sortedEntries.addAll(super.entrySet());\r\n    return Collections.synchronizedSet(sortedEntries);\r\n}",
    "comment": "\n * Specialization of {@link Properties} that sorts properties alphanumerically\n * based on their keys.\n *\n * <p>This can be useful when storing the {@link Properties} instance in a\n * properties file, since it allows such files to be generated in a repeatable\n * manner with consistent ordering of properties.\n *\n * <p>Comments in generated properties files can also be optionally omitted.\n *\n * @author Sam Brannen\n * @since 5.2\n * @see java.util.Properties\n "
  },
  {
    "entityId": "org.springframework.core.SortedProperties#store(OutputStream,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void store(OutputStream out, @Nullable String comments) throws IOException {\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    super.store(baos, (this.omitComments ? null : comments));\r\n    String contents = baos.toString(StandardCharsets.ISO_8859_1);\r\n    for (String line : contents.split(EOL)) {\r\n        if (!(this.omitComments && line.startsWith(\"#\"))) {\r\n            out.write((line + EOL).getBytes(StandardCharsets.ISO_8859_1));\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SortedProperties#store(Writer,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void store(Writer writer, @Nullable String comments) throws IOException {\r\n    StringWriter stringWriter = new StringWriter();\r\n    super.store(stringWriter, (this.omitComments ? null : comments));\r\n    String contents = stringWriter.toString();\r\n    for (String line : contents.split(EOL)) {\r\n        if (!(this.omitComments && line.startsWith(\"#\"))) {\r\n            writer.write(line + EOL);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SortedProperties#storeToXML(OutputStream,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void storeToXML(OutputStream out, @Nullable String comments) throws IOException {\r\n    super.storeToXML(out, (this.omitComments ? null : comments));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SortedProperties#storeToXML(OutputStream,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void storeToXML(OutputStream out, @Nullable String comments, String encoding) throws IOException {\r\n    super.storeToXML(out, (this.omitComments ? null : comments), encoding);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.SortedProperties#keys()",
    "entityType": "method",
    "code": "/**\r\n * Return a sorted enumeration of the keys in this {@link Properties} object.\r\n * @see #keySet()\r\n */\r\n@Override\r\npublic synchronized Enumeration<Object> keys() {\r\n    return Collections.enumeration(keySet());\r\n}",
    "comment": "\n\t * Return a sorted enumeration of the keys in this {@link Properties} object.\n\t * @see #keySet()\n\t "
  },
  {
    "entityId": "org.springframework.core.SortedProperties#keySet()",
    "entityType": "method",
    "code": "/**\r\n * Return a sorted set of the keys in this {@link Properties} object.\r\n * <p>The keys will be converted to strings if necessary using\r\n * {@link String#valueOf(Object)} and sorted alphanumerically according to\r\n * the natural order of strings.\r\n */\r\n@Override\r\npublic Set<Object> keySet() {\r\n    Set<Object> sortedKeys = new TreeSet<>(keyComparator);\r\n    sortedKeys.addAll(super.keySet());\r\n    return Collections.synchronizedSet(sortedKeys);\r\n}",
    "comment": "\n\t * Return a sorted set of the keys in this {@link Properties} object.\n\t * <p>The keys will be converted to strings if necessary using\n\t * {@link String#valueOf(Object)} and sorted alphanumerically according to\n\t * the natural order of strings.\n\t "
  },
  {
    "entityId": "org.springframework.core.SortedProperties#entrySet()",
    "entityType": "method",
    "code": "/**\r\n * Return a sorted set of the entries in this {@link Properties} object.\r\n * <p>The entries will be sorted based on their keys, and the keys will be\r\n * converted to strings if necessary using {@link String#valueOf(Object)}\r\n * and compared alphanumerically according to the natural order of strings.\r\n */\r\n@Override\r\npublic Set<Entry<Object, Object>> entrySet() {\r\n    Set<Entry<Object, Object>> sortedEntries = new TreeSet<>(entryComparator);\r\n    sortedEntries.addAll(super.entrySet());\r\n    return Collections.synchronizedSet(sortedEntries);\r\n}",
    "comment": "\n\t * Return a sorted set of the entries in this {@link Properties} object.\n\t * <p>The entries will be sorted based on their keys, and the keys will be\n\t * converted to strings if necessary using {@link String#valueOf(Object)}\n\t * and compared alphanumerically according to the natural order of strings.\n\t "
  },
  {
    "entityId": "org.springframework.core.SpringProperties",
    "entityType": "class",
    "code": "private static final String PROPERTIES_RESOURCE_LOCATION = \"spring.properties\";\nprivate static final Properties localProperties = new Properties();\nstatic {\r\n    try {\r\n        ClassLoader cl = SpringProperties.class.getClassLoader();\r\n        URL url = (cl != null ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) : ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION));\r\n        if (url != null) {\r\n            try (InputStream is = url.openStream()) {\r\n                localProperties.load(is);\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        System.err.println(\"Could not load 'spring.properties' file from local classpath: \" + ex);\r\n    }\r\n}\nprivate SpringProperties() {\r\n}\n/**\r\n * Programmatically set a local property, overriding an entry in the\r\n * {@code spring.properties} file (if any).\r\n * @param key the property key\r\n * @param value the associated property value, or {@code null} to reset it\r\n */\r\npublic static void setProperty(String key, @Nullable String value) {\r\n    if (value != null) {\r\n        localProperties.setProperty(key, value);\r\n    } else {\r\n        localProperties.remove(key);\r\n    }\r\n}\n/**\r\n * Retrieve the property value for the given key, checking local Spring\r\n * properties first and falling back to JVM-level system properties.\r\n * @param key the property key\r\n * @return the associated property value, or {@code null} if none found\r\n */\r\n@Nullable\r\npublic static String getProperty(String key) {\r\n    String value = localProperties.getProperty(key);\r\n    if (value == null) {\r\n        try {\r\n            value = System.getProperty(key);\r\n        } catch (Throwable ex) {\r\n            System.err.println(\"Could not retrieve system property '\" + key + \"': \" + ex);\r\n        }\r\n    }\r\n    return value;\r\n}\n/**\r\n * Programmatically set a local flag to \"true\", overriding an\r\n * entry in the {@code spring.properties} file (if any).\r\n * @param key the property key\r\n */\r\npublic static void setFlag(String key) {\r\n    localProperties.put(key, Boolean.TRUE.toString());\r\n}\n/**\r\n * Retrieve the flag for the given property key.\r\n * @param key the property key\r\n * @return {@code true} if the property is set to the string \"true\"\r\n * (ignoring case), {@code false} otherwise\r\n */\r\npublic static boolean getFlag(String key) {\r\n    return Boolean.parseBoolean(getProperty(key));\r\n}",
    "comment": "\n * Static holder for local Spring properties, i.e. defined at the Spring library level.\n *\n * <p>Reads a {@code spring.properties} file from the root of the Spring library classpath,\n * and also allows for programmatically setting properties through {@link #setProperty}.\n * When checking a property, local entries are being checked first, then falling back\n * to JVM-level system properties through a {@link System#getProperty} check.\n *\n * <p>This is an alternative way to set Spring-related system properties such as\n * \"spring.getenv.ignore\" and \"spring.beaninfo.ignore\", in particular for scenarios\n * where JVM system properties are locked on the target platform (for example, WebSphere).\n * See {@link #setFlag} for a convenient way to locally set such flags to \"true\".\n *\n * @author Juergen Hoeller\n * @since 3.2.7\n * @see org.springframework.beans.StandardBeanInfoFactory#IGNORE_BEANINFO_PROPERTY_NAME\n * @see org.springframework.core.env.AbstractEnvironment#IGNORE_GETENV_PROPERTY_NAME\n * @see org.springframework.expression.spel.SpelParserConfiguration#SPRING_EXPRESSION_COMPILER_MODE_PROPERTY_NAME\n * @see org.springframework.jdbc.core.StatementCreatorUtils#IGNORE_GETPARAMETERTYPE_PROPERTY_NAME\n * @see org.springframework.jndi.JndiLocatorDelegate#IGNORE_JNDI_PROPERTY_NAME\n * @see org.springframework.objenesis.SpringObjenesis#IGNORE_OBJENESIS_PROPERTY_NAME\n * @see org.springframework.test.context.NestedTestConfiguration#ENCLOSING_CONFIGURATION_PROPERTY_NAME\n * @see org.springframework.test.context.TestConstructor#TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME\n * @see org.springframework.test.context.cache.ContextCache#MAX_CONTEXT_CACHE_SIZE_PROPERTY_NAME\n "
  },
  {
    "entityId": "org.springframework.core.SpringProperties#setProperty(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Programmatically set a local property, overriding an entry in the\r\n * {@code spring.properties} file (if any).\r\n * @param key the property key\r\n * @param value the associated property value, or {@code null} to reset it\r\n */\r\npublic static void setProperty(String key, @Nullable String value) {\r\n    if (value != null) {\r\n        localProperties.setProperty(key, value);\r\n    } else {\r\n        localProperties.remove(key);\r\n    }\r\n}",
    "comment": "\n\t * Programmatically set a local property, overriding an entry in the\n\t * {@code spring.properties} file (if any).\n\t * @param key the property key\n\t * @param value the associated property value, or {@code null} to reset it\n\t "
  },
  {
    "entityId": "org.springframework.core.SpringProperties#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the property value for the given key, checking local Spring\r\n * properties first and falling back to JVM-level system properties.\r\n * @param key the property key\r\n * @return the associated property value, or {@code null} if none found\r\n */\r\n@Nullable\r\npublic static String getProperty(String key) {\r\n    String value = localProperties.getProperty(key);\r\n    if (value == null) {\r\n        try {\r\n            value = System.getProperty(key);\r\n        } catch (Throwable ex) {\r\n            System.err.println(\"Could not retrieve system property '\" + key + \"': \" + ex);\r\n        }\r\n    }\r\n    return value;\r\n}",
    "comment": "\n\t * Retrieve the property value for the given key, checking local Spring\n\t * properties first and falling back to JVM-level system properties.\n\t * @param key the property key\n\t * @return the associated property value, or {@code null} if none found\n\t "
  },
  {
    "entityId": "org.springframework.core.SpringProperties#setFlag(String)",
    "entityType": "method",
    "code": "/**\r\n * Programmatically set a local flag to \"true\", overriding an\r\n * entry in the {@code spring.properties} file (if any).\r\n * @param key the property key\r\n */\r\npublic static void setFlag(String key) {\r\n    localProperties.put(key, Boolean.TRUE.toString());\r\n}",
    "comment": "\n\t * Programmatically set a local flag to \"true\", overriding an\n\t * entry in the {@code spring.properties} file (if any).\n\t * @param key the property key\n\t "
  },
  {
    "entityId": "org.springframework.core.SpringProperties#getFlag(String)",
    "entityType": "method",
    "code": "/**\r\n * Retrieve the flag for the given property key.\r\n * @param key the property key\r\n * @return {@code true} if the property is set to the string \"true\"\r\n * (ignoring case), {@code false} otherwise\r\n */\r\npublic static boolean getFlag(String key) {\r\n    return Boolean.parseBoolean(getProperty(key));\r\n}",
    "comment": "\n\t * Retrieve the flag for the given property key.\n\t * @param key the property key\n\t * @return {@code true} if the property is set to the string \"true\"\n\t * (ignoring case), {@code false} otherwise\n\t "
  },
  {
    "entityId": "org.springframework.core.SpringVersion",
    "entityType": "class",
    "code": "private SpringVersion() {\r\n}\n/**\r\n * Return the full version string of the present Spring codebase,\r\n * or {@code null} if it cannot be determined.\r\n * @see Package#getImplementationVersion()\r\n */\r\n@Nullable\r\npublic static String getVersion() {\r\n    Package pkg = SpringVersion.class.getPackage();\r\n    return (pkg != null ? pkg.getImplementationVersion() : null);\r\n}",
    "comment": "\n * Class that exposes the Spring version. Fetches the\n * \"Implementation-Version\" manifest attribute from the jar file.\n *\n * <p>Note that some ClassLoaders do not expose the package metadata,\n * hence this class might not be able to determine the Spring version\n * in all environments. Consider using a reflection-based check instead &mdash;\n * for example, checking for the presence of a specific Spring method that you\n * intend to call.\n *\n * @author Juergen Hoeller\n * @since 1.1\n "
  },
  {
    "entityId": "org.springframework.core.SpringVersion#getVersion()",
    "entityType": "method",
    "code": "/**\r\n * Return the full version string of the present Spring codebase,\r\n * or {@code null} if it cannot be determined.\r\n * @see Package#getImplementationVersion()\r\n */\r\n@Nullable\r\npublic static String getVersion() {\r\n    Package pkg = SpringVersion.class.getPackage();\r\n    return (pkg != null ? pkg.getImplementationVersion() : null);\r\n}",
    "comment": "\n\t * Return the full version string of the present Spring codebase,\n\t * or {@code null} if it cannot be determined.\n\t * @see Package#getImplementationVersion()\n\t "
  },
  {
    "entityId": "org.springframework.core.StandardReflectionParameterNameDiscoverer",
    "entityType": "class",
    "code": "@Override\r\n@Nullable\r\npublic String @Nullable [] getParameterNames(Method method) {\r\n    return getParameterNames(method.getParameters());\r\n}\n@Override\r\n@Nullable\r\npublic String @Nullable [] getParameterNames(Constructor<?> ctor) {\r\n    return getParameterNames(ctor.getParameters());\r\n}\nprivate String @Nullable [] getParameterNames(Parameter[] parameters) {\r\n    String[] parameterNames = new String[parameters.length];\r\n    for (int i = 0; i < parameters.length; i++) {\r\n        Parameter param = parameters[i];\r\n        if (!param.isNamePresent()) {\r\n            return null;\r\n        }\r\n        parameterNames[i] = param.getName();\r\n    }\r\n    return parameterNames;\r\n}",
    "comment": "\n * {@link ParameterNameDiscoverer} implementation which uses JDK 8's reflection facilities\n * for introspecting parameter names (based on the \"-parameters\" compiler flag).\n *\n * <p>This is a key element of {@link DefaultParameterNameDiscoverer} where it is being\n * combined with {@link KotlinReflectionParameterNameDiscoverer} if Kotlin is present.\n *\n * @author Juergen Hoeller\n * @since 4.0\n * @see java.lang.reflect.Method#getParameters()\n * @see java.lang.reflect.Parameter#getName()\n * @see KotlinReflectionParameterNameDiscoverer\n * @see DefaultParameterNameDiscoverer\n "
  },
  {
    "entityId": "org.springframework.core.StandardReflectionParameterNameDiscoverer#getParameterNames(Method)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String @Nullable [] getParameterNames(Method method) {\r\n    return getParameterNames(method.getParameters());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.StandardReflectionParameterNameDiscoverer#getParameterNames(Constructor<?>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String @Nullable [] getParameterNames(Constructor<?> ctor) {\r\n    return getParameterNames(ctor.getParameters());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.StandardReflectionParameterNameDiscoverer#getParameterNames(Parameter[])",
    "entityType": "method",
    "code": "private String @Nullable [] getParameterNames(Parameter[] parameters) {\r\n    String[] parameterNames = new String[parameters.length];\r\n    for (int i = 0; i < parameters.length; i++) {\r\n        Parameter param = parameters[i];\r\n        if (!param.isNamePresent()) {\r\n            return null;\r\n        }\r\n        parameterNames[i] = param.getName();\r\n    }\r\n    return parameterNames;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler",
    "entityType": "class",
    "code": "private final ValueStyler valueStyler;\n/**\r\n * Create a new DefaultToStringStyler.\r\n * @param valueStyler the ValueStyler to use\r\n */\r\npublic DefaultToStringStyler(ValueStyler valueStyler) {\r\n    Assert.notNull(valueStyler, \"ValueStyler must not be null\");\r\n    this.valueStyler = valueStyler;\r\n}\n/**\r\n * Return the ValueStyler used by this ToStringStyler.\r\n */\r\nprotected final ValueStyler getValueStyler() {\r\n    return this.valueStyler;\r\n}\n@Override\r\npublic void styleStart(StringBuilder buffer, Object obj) {\r\n    if (!obj.getClass().isArray()) {\r\n        buffer.append('[').append(ClassUtils.getShortName(obj.getClass()));\r\n        styleIdentityHashCode(buffer, obj);\r\n    } else {\r\n        buffer.append('[');\r\n        styleIdentityHashCode(buffer, obj);\r\n        buffer.append(' ');\r\n        styleValue(buffer, obj);\r\n    }\r\n}\nprivate void styleIdentityHashCode(StringBuilder buffer, Object obj) {\r\n    buffer.append('@');\r\n    buffer.append(ObjectUtils.getIdentityHexString(obj));\r\n}\n@Override\r\npublic void styleEnd(StringBuilder buffer, Object o) {\r\n    buffer.append(']');\r\n}\n@Override\r\npublic void styleField(StringBuilder buffer, String fieldName, @Nullable Object value) {\r\n    styleFieldStart(buffer, fieldName);\r\n    styleValue(buffer, value);\r\n    styleFieldEnd(buffer, fieldName);\r\n}\nprotected void styleFieldStart(StringBuilder buffer, String fieldName) {\r\n    buffer.append(' ').append(fieldName).append(\" = \");\r\n}\nprotected void styleFieldEnd(StringBuilder buffer, String fieldName) ;\n@Override\r\npublic void styleValue(StringBuilder buffer, @Nullable Object value) {\r\n    buffer.append(this.valueStyler.style(value));\r\n}\n@Override\r\npublic void styleFieldSeparator(StringBuilder buffer) {\r\n    buffer.append(',');\r\n}",
    "comment": "\n * Spring's default {@code toString()} styler.\n *\n * <p>This class is used by {@link ToStringCreator} to style {@code toString()}\n * output in a consistent manner according to Spring conventions.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#getValueStyler()",
    "entityType": "method",
    "code": "/**\r\n * Return the ValueStyler used by this ToStringStyler.\r\n */\r\nprotected final ValueStyler getValueStyler() {\r\n    return this.valueStyler;\r\n}",
    "comment": "\n\t * Return the ValueStyler used by this ToStringStyler.\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleStart(StringBuilder,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void styleStart(StringBuilder buffer, Object obj) {\r\n    if (!obj.getClass().isArray()) {\r\n        buffer.append('[').append(ClassUtils.getShortName(obj.getClass()));\r\n        styleIdentityHashCode(buffer, obj);\r\n    } else {\r\n        buffer.append('[');\r\n        styleIdentityHashCode(buffer, obj);\r\n        buffer.append(' ');\r\n        styleValue(buffer, obj);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleIdentityHashCode(StringBuilder,Object)",
    "entityType": "method",
    "code": "private void styleIdentityHashCode(StringBuilder buffer, Object obj) {\r\n    buffer.append('@');\r\n    buffer.append(ObjectUtils.getIdentityHexString(obj));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleEnd(StringBuilder,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void styleEnd(StringBuilder buffer, Object o) {\r\n    buffer.append(']');\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleField(StringBuilder,String,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void styleField(StringBuilder buffer, String fieldName, @Nullable Object value) {\r\n    styleFieldStart(buffer, fieldName);\r\n    styleValue(buffer, value);\r\n    styleFieldEnd(buffer, fieldName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleFieldStart(StringBuilder,String)",
    "entityType": "method",
    "code": "protected void styleFieldStart(StringBuilder buffer, String fieldName) {\r\n    buffer.append(' ').append(fieldName).append(\" = \");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleFieldEnd(StringBuilder,String)",
    "entityType": "method",
    "code": "protected void styleFieldEnd(StringBuilder buffer, String fieldName) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleValue(StringBuilder,Object)",
    "entityType": "method",
    "code": "@Override\r\npublic void styleValue(StringBuilder buffer, @Nullable Object value) {\r\n    buffer.append(this.valueStyler.style(value));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultToStringStyler#styleFieldSeparator(StringBuilder)",
    "entityType": "method",
    "code": "@Override\r\npublic void styleFieldSeparator(StringBuilder buffer) {\r\n    buffer.append(',');\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler",
    "entityType": "class",
    "code": "private static final String EMPTY = \"[[empty]]\";\nprivate static final String NULL = \"[null]\";\nprivate static final String COLLECTION = \"collection\";\nprivate static final String SET = \"set\";\nprivate static final String LIST = \"list\";\nprivate static final String MAP = \"map\";\nprivate static final String EMPTY_MAP = MAP + EMPTY;\nprivate static final String ARRAY = \"array\";\n@Override\r\npublic String style(@Nullable Object value) {\r\n    if (value == null) {\r\n        return styleNull();\r\n    } else if (value instanceof String str) {\r\n        return styleString(str);\r\n    } else if (value instanceof Class<?> clazz) {\r\n        return styleClass(clazz);\r\n    } else if (value instanceof Method method) {\r\n        return styleMethod(method);\r\n    } else if (value instanceof Map<?, ?> map) {\r\n        return styleMap(map);\r\n    } else if (value instanceof Map.Entry<?, ?> entry) {\r\n        return styleMapEntry(entry);\r\n    } else if (value instanceof Collection<?> collection) {\r\n        return styleCollection(collection);\r\n    } else if (value.getClass().isArray()) {\r\n        return styleArray(ObjectUtils.toObjectArray(value));\r\n    } else {\r\n        return styleObject(value);\r\n    }\r\n}\n/**\r\n * Generate a styled version of {@code null}.\r\n * <p>The default implementation returns {@code \"[null]\"}.\r\n * @return a styled version of {@code null}\r\n * @since 6.0\r\n */\r\nprotected String styleNull() {\r\n    return NULL;\r\n}\n/**\r\n * Generate a styled version of the supplied {@link String}.\r\n * <p>The default implementation returns the supplied string wrapped in\r\n * single quotes.\r\n * @return a styled version of the supplied string\r\n * @since 6.0\r\n */\r\nprotected String styleString(String str) {\r\n    return \"\\'\" + str + \"\\'\";\r\n}\n/**\r\n * Generate a styled version of the supplied {@link Class}.\r\n * <p>The default implementation delegates to {@link ClassUtils#getShortName(Class)}.\r\n * @return a styled version of the supplied class\r\n * @since 6.0\r\n */\r\nprotected String styleClass(Class<?> clazz) {\r\n    return ClassUtils.getShortName(clazz);\r\n}\n/**\r\n * Generate a styled version of the supplied {@link Method}.\r\n * <p>The default implementation returns the method's {@linkplain Method#getName()\r\n * name} and the {@linkplain ClassUtils#getShortName(Class) short name} of the\r\n * method's {@linkplain Method#getDeclaringClass() declaring class}, separated by\r\n * the {@code \"@\"} symbol.\r\n * @return a styled version of the supplied method\r\n * @since 6.0\r\n */\r\nprotected String styleMethod(Method method) {\r\n    return method.getName() + \"@\" + ClassUtils.getShortName(method.getDeclaringClass());\r\n}\n/**\r\n * Generate a styled version of the supplied {@link Map}.\r\n * @return a styled version of the supplied map\r\n * @since 6.0\r\n */\r\nprotected <K, V> String styleMap(Map<K, V> map) {\r\n    if (map.isEmpty()) {\r\n        return EMPTY_MAP;\r\n    }\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Map.Entry<K, V> entry : map.entrySet()) {\r\n        result.add(styleMapEntry(entry));\r\n    }\r\n    return MAP + result;\r\n}\n/**\r\n * Generate a styled version of the supplied {@link Map.Entry}.\r\n * @return a styled version of the supplied map entry\r\n * @since 6.0\r\n */\r\nprotected String styleMapEntry(Map.Entry<?, ?> entry) {\r\n    return style(entry.getKey()) + \" -> \" + style(entry.getValue());\r\n}\n/**\r\n * Generate a styled version of the supplied {@link Collection}.\r\n * @return a styled version of the supplied collection\r\n * @since 6.0\r\n */\r\nprotected String styleCollection(Collection<?> collection) {\r\n    String collectionType = getCollectionTypeString(collection);\r\n    if (collection.isEmpty()) {\r\n        return collectionType + EMPTY;\r\n    }\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : collection) {\r\n        result.add(style(element));\r\n    }\r\n    return collectionType + result;\r\n}\n/**\r\n * Generate a styled version of the supplied array.\r\n * @return a styled version of the supplied array\r\n * @since 6.0\r\n */\r\nprotected String styleArray(Object[] array) {\r\n    if (array.length == 0) {\r\n        return ARRAY + '<' + ClassUtils.getShortName(array.getClass().componentType()) + '>' + EMPTY;\r\n    }\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : array) {\r\n        result.add(style(element));\r\n    }\r\n    return ARRAY + '<' + ClassUtils.getShortName(array.getClass().componentType()) + '>' + result;\r\n}\n/**\r\n * Generate a styled version of the supplied {@link Object}.\r\n * <p>This method is only invoked by {@link #style(Object)} as a fallback,\r\n * if none of the other {@code style*()} methods is suitable for the object's\r\n * type.\r\n * <p>The default implementation delegates to {@link String#valueOf(Object)}.\r\n * @return a styled version of the supplied object\r\n * @since 6.0\r\n */\r\nprotected String styleObject(Object obj) {\r\n    return String.valueOf(obj);\r\n}\nprivate static String getCollectionTypeString(Collection<?> collection) {\r\n    if (collection instanceof List) {\r\n        return LIST;\r\n    } else if (collection instanceof Set) {\r\n        return SET;\r\n    } else {\r\n        return COLLECTION;\r\n    }\r\n}",
    "comment": "\n * Converts objects to String form, generally for debugging purposes,\n * using Spring's {@code toString} styling conventions.\n *\n * <p>Uses the reflective visitor pattern underneath the hood to nicely\n * encapsulate styling algorithms for each type of styled object.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#style(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic String style(@Nullable Object value) {\r\n    if (value == null) {\r\n        return styleNull();\r\n    } else if (value instanceof String str) {\r\n        return styleString(str);\r\n    } else if (value instanceof Class<?> clazz) {\r\n        return styleClass(clazz);\r\n    } else if (value instanceof Method method) {\r\n        return styleMethod(method);\r\n    } else if (value instanceof Map<?, ?> map) {\r\n        return styleMap(map);\r\n    } else if (value instanceof Map.Entry<?, ?> entry) {\r\n        return styleMapEntry(entry);\r\n    } else if (value instanceof Collection<?> collection) {\r\n        return styleCollection(collection);\r\n    } else if (value.getClass().isArray()) {\r\n        return styleArray(ObjectUtils.toObjectArray(value));\r\n    } else {\r\n        return styleObject(value);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleNull()",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of {@code null}.\r\n * <p>The default implementation returns {@code \"[null]\"}.\r\n * @return a styled version of {@code null}\r\n * @since 6.0\r\n */\r\nprotected String styleNull() {\r\n    return NULL;\r\n}",
    "comment": "\n\t * Generate a styled version of {@code null}.\n\t * <p>The default implementation returns {@code \"[null]\"}.\n\t * @return a styled version of {@code null}\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleString(String)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link String}.\r\n * <p>The default implementation returns the supplied string wrapped in\r\n * single quotes.\r\n * @return a styled version of the supplied string\r\n * @since 6.0\r\n */\r\nprotected String styleString(String str) {\r\n    return \"\\'\" + str + \"\\'\";\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link String}.\n\t * <p>The default implementation returns the supplied string wrapped in\n\t * single quotes.\n\t * @return a styled version of the supplied string\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleClass(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link Class}.\r\n * <p>The default implementation delegates to {@link ClassUtils#getShortName(Class)}.\r\n * @return a styled version of the supplied class\r\n * @since 6.0\r\n */\r\nprotected String styleClass(Class<?> clazz) {\r\n    return ClassUtils.getShortName(clazz);\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link Class}.\n\t * <p>The default implementation delegates to {@link ClassUtils#getShortName(Class)}.\n\t * @return a styled version of the supplied class\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleMethod(Method)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link Method}.\r\n * <p>The default implementation returns the method's {@linkplain Method#getName()\r\n * name} and the {@linkplain ClassUtils#getShortName(Class) short name} of the\r\n * method's {@linkplain Method#getDeclaringClass() declaring class}, separated by\r\n * the {@code \"@\"} symbol.\r\n * @return a styled version of the supplied method\r\n * @since 6.0\r\n */\r\nprotected String styleMethod(Method method) {\r\n    return method.getName() + \"@\" + ClassUtils.getShortName(method.getDeclaringClass());\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link Method}.\n\t * <p>The default implementation returns the method's {@linkplain Method#getName()\n\t * name} and the {@linkplain ClassUtils#getShortName(Class) short name} of the\n\t * method's {@linkplain Method#getDeclaringClass() declaring class}, separated by\n\t * the {@code \"@\"} symbol.\n\t * @return a styled version of the supplied method\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleMap(Map<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link Map}.\r\n * @return a styled version of the supplied map\r\n * @since 6.0\r\n */\r\nprotected <K, V> String styleMap(Map<K, V> map) {\r\n    if (map.isEmpty()) {\r\n        return EMPTY_MAP;\r\n    }\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Map.Entry<K, V> entry : map.entrySet()) {\r\n        result.add(styleMapEntry(entry));\r\n    }\r\n    return MAP + result;\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link Map}.\n\t * @return a styled version of the supplied map\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleMapEntry(Map.Entry<?,?>)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link Map.Entry}.\r\n * @return a styled version of the supplied map entry\r\n * @since 6.0\r\n */\r\nprotected String styleMapEntry(Map.Entry<?, ?> entry) {\r\n    return style(entry.getKey()) + \" -> \" + style(entry.getValue());\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link Map.Entry}.\n\t * @return a styled version of the supplied map entry\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleCollection(Collection<?>)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link Collection}.\r\n * @return a styled version of the supplied collection\r\n * @since 6.0\r\n */\r\nprotected String styleCollection(Collection<?> collection) {\r\n    String collectionType = getCollectionTypeString(collection);\r\n    if (collection.isEmpty()) {\r\n        return collectionType + EMPTY;\r\n    }\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : collection) {\r\n        result.add(style(element));\r\n    }\r\n    return collectionType + result;\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link Collection}.\n\t * @return a styled version of the supplied collection\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleArray(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied array.\r\n * @return a styled version of the supplied array\r\n * @since 6.0\r\n */\r\nprotected String styleArray(Object[] array) {\r\n    if (array.length == 0) {\r\n        return ARRAY + '<' + ClassUtils.getShortName(array.getClass().componentType()) + '>' + EMPTY;\r\n    }\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : array) {\r\n        result.add(style(element));\r\n    }\r\n    return ARRAY + '<' + ClassUtils.getShortName(array.getClass().componentType()) + '>' + result;\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied array.\n\t * @return a styled version of the supplied array\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#styleObject(Object)",
    "entityType": "method",
    "code": "/**\r\n * Generate a styled version of the supplied {@link Object}.\r\n * <p>This method is only invoked by {@link #style(Object)} as a fallback,\r\n * if none of the other {@code style*()} methods is suitable for the object's\r\n * type.\r\n * <p>The default implementation delegates to {@link String#valueOf(Object)}.\r\n * @return a styled version of the supplied object\r\n * @since 6.0\r\n */\r\nprotected String styleObject(Object obj) {\r\n    return String.valueOf(obj);\r\n}",
    "comment": "\n\t * Generate a styled version of the supplied {@link Object}.\n\t * <p>This method is only invoked by {@link #style(Object)} as a fallback,\n\t * if none of the other {@code style*()} methods is suitable for the object's\n\t * type.\n\t * <p>The default implementation delegates to {@link String#valueOf(Object)}.\n\t * @return a styled version of the supplied object\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.style.DefaultValueStyler#getCollectionTypeString(Collection<?>)",
    "entityType": "method",
    "code": "private static String getCollectionTypeString(Collection<?> collection) {\r\n    if (collection instanceof List) {\r\n        return LIST;\r\n    } else if (collection instanceof Set) {\r\n        return SET;\r\n    } else {\r\n        return COLLECTION;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler",
    "entityType": "class",
    "code": "/**\r\n * Default {@link Class} styling function: {@link Class#getCanonicalName()}.\r\n */\r\npublic static final Function<Class<?>, String> DEFAULT_CLASS_STYLER = Class::getCanonicalName;\n/**\r\n * Default {@link Method} styling function: converts the supplied {@link Method}\r\n * to a simple string representation of the method's signature in the form of\r\n * {@code <method name>(<parameter types>)}, where {@code <parameter types>}\r\n * is a comma-separated list of the {@linkplain Class#getSimpleName() simple names}\r\n * of the parameter types.\r\n * <p>For example, if the supplied method is a reference to\r\n * {@link String#getBytes(java.nio.charset.Charset)}, this function will\r\n * return {@code \"getBytes(Charset)\"}.\r\n */\r\npublic static final Function<Method, String> DEFAULT_METHOD_STYLER = SimpleValueStyler::toSimpleMethodSignature;\nprivate final Function<Class<?>, String> classStyler;\nprivate final Function<Method, String> methodStyler;\n/**\r\n * Create a {@code SimpleValueStyler} using the {@link #DEFAULT_CLASS_STYLER}\r\n * and {@link #DEFAULT_METHOD_STYLER}.\r\n */\r\npublic SimpleValueStyler() {\r\n    this(DEFAULT_CLASS_STYLER, DEFAULT_METHOD_STYLER);\r\n}\n/**\r\n * Create a {@code SimpleValueStyler} using the supplied class and method stylers.\r\n * @param classStyler a function that applies styling to a {@link Class}\r\n * @param methodStyler a function that applies styling to a {@link Method}\r\n */\r\npublic SimpleValueStyler(Function<Class<?>, String> classStyler, Function<Method, String> methodStyler) {\r\n    this.classStyler = classStyler;\r\n    this.methodStyler = methodStyler;\r\n}\n@Override\r\nprotected String styleNull() {\r\n    return \"null\";\r\n}\n@Override\r\nprotected String styleString(String str) {\r\n    return \"\\\"\" + str + \"\\\"\";\r\n}\n@Override\r\nprotected String styleClass(Class<?> clazz) {\r\n    return this.classStyler.apply(clazz);\r\n}\n@Override\r\nprotected String styleMethod(Method method) {\r\n    return this.methodStyler.apply(method);\r\n}\n@Override\r\nprotected <K, V> String styleMap(Map<K, V> map) {\r\n    StringJoiner result = new StringJoiner(\", \", \"{\", \"}\");\r\n    for (Map.Entry<K, V> entry : map.entrySet()) {\r\n        result.add(style(entry));\r\n    }\r\n    return result.toString();\r\n}\n@Override\r\nprotected String styleCollection(Collection<?> collection) {\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : collection) {\r\n        result.add(style(element));\r\n    }\r\n    return result.toString();\r\n}\n@Override\r\nprotected String styleArray(Object[] array) {\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : array) {\r\n        result.add(style(element));\r\n    }\r\n    return result.toString();\r\n}\nprivate static String toSimpleMethodSignature(Method method) {\r\n    String parameterList = Arrays.stream(method.getParameterTypes()).map(Class::getSimpleName).collect(Collectors.joining(\", \"));\r\n    return String.format(\"%s(%s)\", method.getName(), parameterList);\r\n}",
    "comment": "\n * {@link ValueStyler} that converts objects to String form &mdash; generally for\n * debugging purposes &mdash; using simple styling conventions that mimic the\n * {@code toString()} styling conventions for standard JDK implementations of\n * collections, maps, and arrays.\n *\n * <p>Uses the reflective visitor pattern underneath the hood to nicely\n * encapsulate styling algorithms for each type of styled object.\n *\n * <p>Favor {@link SimpleValueStyler} over {@link DefaultValueStyler} when you\n * wish to use styling similar to the JDK or when you need configurable control\n * over the styling of classes and methods.\n *\n * @author Sam Brannen\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleNull()",
    "entityType": "method",
    "code": "@Override\r\nprotected String styleNull() {\r\n    return \"null\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleString(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected String styleString(String str) {\r\n    return \"\\\"\" + str + \"\\\"\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleClass(Class<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected String styleClass(Class<?> clazz) {\r\n    return this.classStyler.apply(clazz);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleMethod(Method)",
    "entityType": "method",
    "code": "@Override\r\nprotected String styleMethod(Method method) {\r\n    return this.methodStyler.apply(method);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleMap(Map<K,V>)",
    "entityType": "method",
    "code": "@Override\r\nprotected <K, V> String styleMap(Map<K, V> map) {\r\n    StringJoiner result = new StringJoiner(\", \", \"{\", \"}\");\r\n    for (Map.Entry<K, V> entry : map.entrySet()) {\r\n        result.add(style(entry));\r\n    }\r\n    return result.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleCollection(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\nprotected String styleCollection(Collection<?> collection) {\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : collection) {\r\n        result.add(style(element));\r\n    }\r\n    return result.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#styleArray(Object[])",
    "entityType": "method",
    "code": "@Override\r\nprotected String styleArray(Object[] array) {\r\n    StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\r\n    for (Object element : array) {\r\n        result.add(style(element));\r\n    }\r\n    return result.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.SimpleValueStyler#toSimpleMethodSignature(Method)",
    "entityType": "method",
    "code": "private static String toSimpleMethodSignature(Method method) {\r\n    String parameterList = Arrays.stream(method.getParameterTypes()).map(Class::getSimpleName).collect(Collectors.joining(\", \"));\r\n    return String.format(\"%s(%s)\", method.getName(), parameterList);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.StylerUtils",
    "entityType": "class",
    "code": "/**\r\n * Default ValueStyler instance used by the {@code style} method.\r\n * Also available for the {@link ToStringCreator} class in this package.\r\n */\r\nstatic final ValueStyler DEFAULT_VALUE_STYLER = new DefaultValueStyler();\n/**\r\n * Style the specified value according to default conventions.\r\n * @param value the Object value to style\r\n * @return the styled String\r\n * @see DefaultValueStyler\r\n */\r\npublic static String style(Object value) {\r\n    return DEFAULT_VALUE_STYLER.style(value);\r\n}",
    "comment": "\n * Simple utility class to allow for convenient access to value\n * styling logic, mainly to support descriptive logging messages.\n *\n * <p>For more sophisticated needs, use the {@link ValueStyler} abstraction\n * directly. This class simply uses a shared {@link DefaultValueStyler}\n * instance underneath.\n *\n * @author Keith Donald\n * @since 1.2.2\n * @see ValueStyler\n * @see DefaultValueStyler\n "
  },
  {
    "entityId": "org.springframework.core.style.StylerUtils#style(Object)",
    "entityType": "method",
    "code": "/**\r\n * Style the specified value according to default conventions.\r\n * @param value the Object value to style\r\n * @return the styled String\r\n * @see DefaultValueStyler\r\n */\r\npublic static String style(Object value) {\r\n    return DEFAULT_VALUE_STYLER.style(value);\r\n}",
    "comment": "\n\t * Style the specified value according to default conventions.\n\t * @param value the Object value to style\n\t * @return the styled String\n\t * @see DefaultValueStyler\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator",
    "entityType": "class",
    "code": "/**\r\n * Default ToStringStyler instance used by this ToStringCreator.\r\n */\r\nprivate static final ToStringStyler DEFAULT_TO_STRING_STYLER = new DefaultToStringStyler(StylerUtils.DEFAULT_VALUE_STYLER);\nprivate final StringBuilder buffer = new StringBuilder(256);\nprivate final ToStringStyler styler;\nprivate final Object object;\nprivate boolean styledFirstField;\n/**\r\n * Create a ToStringCreator for the given object.\r\n * @param obj the object to be stringified\r\n */\r\npublic ToStringCreator(Object obj) {\r\n    this(obj, (ToStringStyler) null);\r\n}\n/**\r\n * Create a ToStringCreator for the given object, using the provided style.\r\n * @param obj the object to be stringified\r\n * @param styler the ValueStyler encapsulating pretty-print instructions\r\n */\r\npublic ToStringCreator(Object obj, @Nullable ValueStyler styler) {\r\n    this(obj, new DefaultToStringStyler(styler != null ? styler : StylerUtils.DEFAULT_VALUE_STYLER));\r\n}\n/**\r\n * Create a ToStringCreator for the given object, using the provided style.\r\n * @param obj the object to be stringified\r\n * @param styler the ToStringStyler encapsulating pretty-print instructions\r\n */\r\npublic ToStringCreator(Object obj, @Nullable ToStringStyler styler) {\r\n    Assert.notNull(obj, \"The object to be styled must not be null\");\r\n    this.object = obj;\r\n    this.styler = (styler != null ? styler : DEFAULT_TO_STRING_STYLER);\r\n    this.styler.styleStart(this.buffer, this.object);\r\n}\n/**\r\n * Append a byte field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, byte value) {\r\n    return append(fieldName, Byte.valueOf(value));\r\n}\n/**\r\n * Append a short field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, short value) {\r\n    return append(fieldName, Short.valueOf(value));\r\n}\n/**\r\n * Append a integer field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, int value) {\r\n    return append(fieldName, Integer.valueOf(value));\r\n}\n/**\r\n * Append a long field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, long value) {\r\n    return append(fieldName, Long.valueOf(value));\r\n}\n/**\r\n * Append a float field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, float value) {\r\n    return append(fieldName, Float.valueOf(value));\r\n}\n/**\r\n * Append a double field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, double value) {\r\n    return append(fieldName, Double.valueOf(value));\r\n}\n/**\r\n * Append a boolean field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, boolean value) {\r\n    return append(fieldName, Boolean.valueOf(value));\r\n}\n/**\r\n * Append a field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, @Nullable Object value) {\r\n    printFieldSeparatorIfNecessary();\r\n    this.styler.styleField(this.buffer, fieldName, value);\r\n    return this;\r\n}\nprivate void printFieldSeparatorIfNecessary() {\r\n    if (this.styledFirstField) {\r\n        this.styler.styleFieldSeparator(this.buffer);\r\n    } else {\r\n        this.styledFirstField = true;\r\n    }\r\n}\n/**\r\n * Append the provided value.\r\n * @param value the value to append\r\n * @return this, to support call-chaining.\r\n */\r\npublic ToStringCreator append(Object value) {\r\n    this.styler.styleValue(this.buffer, value);\r\n    return this;\r\n}\n/**\r\n * Return the String representation that this ToStringCreator built.\r\n */\r\n@Override\r\npublic String toString() {\r\n    this.styler.styleEnd(this.buffer, this.object);\r\n    return this.buffer.toString();\r\n}",
    "comment": "\n * Utility class that builds pretty-printing {@code toString()} methods\n * with pluggable styling conventions. By default, ToStringCreator adheres\n * to Spring's {@code toString()} styling conventions.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,byte)",
    "entityType": "method",
    "code": "/**\r\n * Append a byte field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, byte value) {\r\n    return append(fieldName, Byte.valueOf(value));\r\n}",
    "comment": "\n\t * Append a byte field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,short)",
    "entityType": "method",
    "code": "/**\r\n * Append a short field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, short value) {\r\n    return append(fieldName, Short.valueOf(value));\r\n}",
    "comment": "\n\t * Append a short field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,int)",
    "entityType": "method",
    "code": "/**\r\n * Append a integer field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, int value) {\r\n    return append(fieldName, Integer.valueOf(value));\r\n}",
    "comment": "\n\t * Append a integer field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,long)",
    "entityType": "method",
    "code": "/**\r\n * Append a long field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, long value) {\r\n    return append(fieldName, Long.valueOf(value));\r\n}",
    "comment": "\n\t * Append a long field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,float)",
    "entityType": "method",
    "code": "/**\r\n * Append a float field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, float value) {\r\n    return append(fieldName, Float.valueOf(value));\r\n}",
    "comment": "\n\t * Append a float field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,double)",
    "entityType": "method",
    "code": "/**\r\n * Append a double field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, double value) {\r\n    return append(fieldName, Double.valueOf(value));\r\n}",
    "comment": "\n\t * Append a double field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Append a boolean field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, boolean value) {\r\n    return append(fieldName, Boolean.valueOf(value));\r\n}",
    "comment": "\n\t * Append a boolean field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Append a field value.\r\n * @param fieldName the name of the field, usually the member variable name\r\n * @param value the field value\r\n * @return this, to support call-chaining\r\n */\r\npublic ToStringCreator append(String fieldName, @Nullable Object value) {\r\n    printFieldSeparatorIfNecessary();\r\n    this.styler.styleField(this.buffer, fieldName, value);\r\n    return this;\r\n}",
    "comment": "\n\t * Append a field value.\n\t * @param fieldName the name of the field, usually the member variable name\n\t * @param value the field value\n\t * @return this, to support call-chaining\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#printFieldSeparatorIfNecessary()",
    "entityType": "method",
    "code": "private void printFieldSeparatorIfNecessary() {\r\n    if (this.styledFirstField) {\r\n        this.styler.styleFieldSeparator(this.buffer);\r\n    } else {\r\n        this.styledFirstField = true;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#append(Object)",
    "entityType": "method",
    "code": "/**\r\n * Append the provided value.\r\n * @param value the value to append\r\n * @return this, to support call-chaining.\r\n */\r\npublic ToStringCreator append(Object value) {\r\n    this.styler.styleValue(this.buffer, value);\r\n    return this;\r\n}",
    "comment": "\n\t * Append the provided value.\n\t * @param value the value to append\n\t * @return this, to support call-chaining.\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringCreator#toString()",
    "entityType": "method",
    "code": "/**\r\n * Return the String representation that this ToStringCreator built.\r\n */\r\n@Override\r\npublic String toString() {\r\n    this.styler.styleEnd(this.buffer, this.object);\r\n    return this.buffer.toString();\r\n}",
    "comment": "\n\t * Return the String representation that this ToStringCreator built.\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringStyler",
    "entityType": "class",
    "code": "/**\r\n * Style a {@code toString()}'ed object before its fields are styled.\r\n * @param buffer the buffer to print to\r\n * @param obj the object to style\r\n */\r\nvoid styleStart(StringBuilder buffer, Object obj);\n/**\r\n * Style a {@code toString()}'ed object after it's fields are styled.\r\n * @param buffer the buffer to print to\r\n * @param obj the object to style\r\n */\r\nvoid styleEnd(StringBuilder buffer, Object obj);\n/**\r\n * Style a field value as a string.\r\n * @param buffer the buffer to print to\r\n * @param fieldName the name of the field\r\n * @param value the field value\r\n */\r\nvoid styleField(StringBuilder buffer, String fieldName, @Nullable Object value);\n/**\r\n * Style the given value.\r\n * @param buffer the buffer to print to\r\n * @param value the field value\r\n */\r\nvoid styleValue(StringBuilder buffer, Object value);\n/**\r\n * Style the field separator.\r\n * @param buffer the buffer to print to\r\n */\r\nvoid styleFieldSeparator(StringBuilder buffer);",
    "comment": "\n * A strategy interface for pretty-printing {@code toString()} methods.\n * Encapsulates the print algorithms; some other object such as a builder\n * should provide the workflow.\n *\n * @author Keith Donald\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.core.style.ToStringStyler#styleStart(StringBuilder,Object)",
    "entityType": "method",
    "code": "/**\r\n * Style a {@code toString()}'ed object before its fields are styled.\r\n * @param buffer the buffer to print to\r\n * @param obj the object to style\r\n */\r\nvoid styleStart(StringBuilder buffer, Object obj);",
    "comment": "\n\t * Style a {@code toString()}'ed object before its fields are styled.\n\t * @param buffer the buffer to print to\n\t * @param obj the object to style\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringStyler#styleEnd(StringBuilder,Object)",
    "entityType": "method",
    "code": "/**\r\n * Style a {@code toString()}'ed object after it's fields are styled.\r\n * @param buffer the buffer to print to\r\n * @param obj the object to style\r\n */\r\nvoid styleEnd(StringBuilder buffer, Object obj);",
    "comment": "\n\t * Style a {@code toString()}'ed object after it's fields are styled.\n\t * @param buffer the buffer to print to\n\t * @param obj the object to style\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringStyler#styleField(StringBuilder,String,Object)",
    "entityType": "method",
    "code": "/**\r\n * Style a field value as a string.\r\n * @param buffer the buffer to print to\r\n * @param fieldName the name of the field\r\n * @param value the field value\r\n */\r\nvoid styleField(StringBuilder buffer, String fieldName, @Nullable Object value);",
    "comment": "\n\t * Style a field value as a string.\n\t * @param buffer the buffer to print to\n\t * @param fieldName the name of the field\n\t * @param value the field value\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringStyler#styleValue(StringBuilder,Object)",
    "entityType": "method",
    "code": "/**\r\n * Style the given value.\r\n * @param buffer the buffer to print to\r\n * @param value the field value\r\n */\r\nvoid styleValue(StringBuilder buffer, Object value);",
    "comment": "\n\t * Style the given value.\n\t * @param buffer the buffer to print to\n\t * @param value the field value\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ToStringStyler#styleFieldSeparator(StringBuilder)",
    "entityType": "method",
    "code": "/**\r\n * Style the field separator.\r\n * @param buffer the buffer to print to\r\n */\r\nvoid styleFieldSeparator(StringBuilder buffer);",
    "comment": "\n\t * Style the field separator.\n\t * @param buffer the buffer to print to\n\t "
  },
  {
    "entityId": "org.springframework.core.style.ValueStyler",
    "entityType": "class",
    "code": "/**\r\n * Style the given value, returning a String representation.\r\n * @param value the Object value to style\r\n * @return the styled String\r\n */\r\nString style(@Nullable Object value);",
    "comment": "\n * Strategy that encapsulates value String styling algorithms\n * according to Spring conventions.\n *\n * @author Keith Donald\n * @since 1.2.2\n "
  },
  {
    "entityId": "org.springframework.core.style.ValueStyler#style(Object)",
    "entityType": "method",
    "code": "/**\r\n * Style the given value, returning a String representation.\r\n * @param value the Object value to style\r\n * @return the styled String\r\n */\r\nString style(@Nullable Object value);",
    "comment": "\n\t * Style the given value, returning a String representation.\n\t * @param value the Object value to style\n\t * @return the styled String\n\t "
  },
  {
    "entityId": "org.springframework.core.task.AsyncTaskExecutor",
    "entityType": "class",
    "code": "/**\r\n * Constant that indicates immediate execution.\r\n * @deprecated as of 5.3.16 along with {@link #execute(Runnable, long)}\r\n */\r\n@Deprecated\r\nlong TIMEOUT_IMMEDIATE = 0;\n/**\r\n * Constant that indicates no time limit.\r\n * @deprecated as of 5.3.16 along with {@link #execute(Runnable, long)}\r\n */\r\n@Deprecated\r\nlong TIMEOUT_INDEFINITE = Long.MAX_VALUE;\n/**\r\n * Execute the given {@code task}.\r\n * <p>As of 6.1, this method comes with a default implementation that simply\r\n * delegates to {@link #execute(Runnable)}, ignoring the timeout completely.\r\n * @param task the {@code Runnable} to execute (never {@code null})\r\n * @param startTimeout the time duration (milliseconds) within which the task is\r\n * supposed to start. This is intended as a hint to the executor, allowing for\r\n * preferred handling of immediate tasks. Typical values are {@link #TIMEOUT_IMMEDIATE}\r\n * or {@link #TIMEOUT_INDEFINITE} (the default as used by {@link #execute(Runnable)}).\r\n * @throws TaskTimeoutException in case of the task being rejected because\r\n * of the timeout (i.e. it cannot be started in time)\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @see #execute(Runnable)\r\n * @deprecated as of 5.3.16 since the common executors do not support start timeouts\r\n */\r\n@Deprecated\r\ndefault void execute(Runnable task, long startTimeout) {\r\n    execute(task);\r\n}\n/**\r\n * Submit a Runnable task for execution, receiving a Future representing that task.\r\n * The Future will return a {@code null} result upon completion.\r\n * <p>As of 6.1, this method comes with a default implementation that delegates\r\n * to {@link #execute(Runnable)}.\r\n * @param task the {@code Runnable} to execute (never {@code null})\r\n * @return a Future representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 3.0\r\n */\r\ndefault Future<?> submit(Runnable task) {\r\n    FutureTask<Object> future = new FutureTask<>(task, null);\r\n    execute(future);\r\n    return future;\r\n}\n/**\r\n * Submit a Callable task for execution, receiving a Future representing that task.\r\n * The Future will return the Callable's result upon completion.\r\n * <p>As of 6.1, this method comes with a default implementation that delegates\r\n * to {@link #execute(Runnable)}.\r\n * @param task the {@code Callable} to execute (never {@code null})\r\n * @return a Future representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 3.0\r\n */\r\ndefault <T> Future<T> submit(Callable<T> task) {\r\n    FutureTask<T> future = new FutureTask<>(task);\r\n    execute(future, TIMEOUT_INDEFINITE);\r\n    return future;\r\n}\n/**\r\n * Submit a {@code Runnable} task for execution, receiving a {@code CompletableFuture}\r\n * representing that task. The Future will return a {@code null} result upon completion.\r\n * @param task the {@code Runnable} to execute (never {@code null})\r\n * @return a {@code CompletableFuture} representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 6.0\r\n */\r\ndefault CompletableFuture<Void> submitCompletable(Runnable task) {\r\n    return CompletableFuture.runAsync(task, this);\r\n}\n/**\r\n * Submit a {@code Callable} task for execution, receiving a {@code CompletableFuture}\r\n * representing that task. The Future will return the Callable's result upon\r\n * completion.\r\n * @param task the {@code Callable} to execute (never {@code null})\r\n * @return a {@code CompletableFuture} representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 6.0\r\n */\r\ndefault <T> CompletableFuture<T> submitCompletable(Callable<T> task) {\r\n    return FutureUtils.callAsync(task, this);\r\n}",
    "comment": "\n * Extended interface for asynchronous {@link TaskExecutor} implementations,\n * offering support for {@link java.util.concurrent.Callable}.\n *\n * <p>Note: The {@link java.util.concurrent.Executors} class includes a set of\n * methods that can convert some other common closure-like objects, for example,\n * {@link java.security.PrivilegedAction} to {@link Callable} before executing them.\n *\n * <p>Implementing this interface also indicates that the {@link #execute(Runnable)}\n * method will not execute its Runnable in the caller's thread but rather\n * asynchronously in some other thread.\n *\n * @author Juergen Hoeller\n * @since 2.0.3\n * @see SimpleAsyncTaskExecutor\n * @see org.springframework.scheduling.SchedulingTaskExecutor\n * @see java.util.concurrent.Callable\n * @see java.util.concurrent.Executors\n "
  },
  {
    "entityId": "org.springframework.core.task.AsyncTaskExecutor#execute(Runnable,long)",
    "entityType": "method",
    "code": "/**\r\n * Execute the given {@code task}.\r\n * <p>As of 6.1, this method comes with a default implementation that simply\r\n * delegates to {@link #execute(Runnable)}, ignoring the timeout completely.\r\n * @param task the {@code Runnable} to execute (never {@code null})\r\n * @param startTimeout the time duration (milliseconds) within which the task is\r\n * supposed to start. This is intended as a hint to the executor, allowing for\r\n * preferred handling of immediate tasks. Typical values are {@link #TIMEOUT_IMMEDIATE}\r\n * or {@link #TIMEOUT_INDEFINITE} (the default as used by {@link #execute(Runnable)}).\r\n * @throws TaskTimeoutException in case of the task being rejected because\r\n * of the timeout (i.e. it cannot be started in time)\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @see #execute(Runnable)\r\n * @deprecated as of 5.3.16 since the common executors do not support start timeouts\r\n */\r\n@Deprecated\r\ndefault void execute(Runnable task, long startTimeout) {\r\n    execute(task);\r\n}",
    "comment": "\n\t * Execute the given {@code task}.\n\t * <p>As of 6.1, this method comes with a default implementation that simply\n\t * delegates to {@link #execute(Runnable)}, ignoring the timeout completely.\n\t * @param task the {@code Runnable} to execute (never {@code null})\n\t * @param startTimeout the time duration (milliseconds) within which the task is\n\t * supposed to start. This is intended as a hint to the executor, allowing for\n\t * preferred handling of immediate tasks. Typical values are {@link #TIMEOUT_IMMEDIATE}\n\t * or {@link #TIMEOUT_INDEFINITE} (the default as used by {@link #execute(Runnable)}).\n\t * @throws TaskTimeoutException in case of the task being rejected because\n\t * of the timeout (i.e. it cannot be started in time)\n\t * @throws TaskRejectedException if the given task was not accepted\n\t * @see #execute(Runnable)\n\t * @deprecated as of 5.3.16 since the common executors do not support start timeouts\n\t "
  },
  {
    "entityId": "org.springframework.core.task.AsyncTaskExecutor#submit(Runnable)",
    "entityType": "method",
    "code": "/**\r\n * Submit a Runnable task for execution, receiving a Future representing that task.\r\n * The Future will return a {@code null} result upon completion.\r\n * <p>As of 6.1, this method comes with a default implementation that delegates\r\n * to {@link #execute(Runnable)}.\r\n * @param task the {@code Runnable} to execute (never {@code null})\r\n * @return a Future representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 3.0\r\n */\r\ndefault Future<?> submit(Runnable task) {\r\n    FutureTask<Object> future = new FutureTask<>(task, null);\r\n    execute(future);\r\n    return future;\r\n}",
    "comment": "\n\t * Submit a Runnable task for execution, receiving a Future representing that task.\n\t * The Future will return a {@code null} result upon completion.\n\t * <p>As of 6.1, this method comes with a default implementation that delegates\n\t * to {@link #execute(Runnable)}.\n\t * @param task the {@code Runnable} to execute (never {@code null})\n\t * @return a Future representing pending completion of the task\n\t * @throws TaskRejectedException if the given task was not accepted\n\t * @since 3.0\n\t "
  },
  {
    "entityId": "org.springframework.core.task.AsyncTaskExecutor#submit(Callable<T>)",
    "entityType": "method",
    "code": "/**\r\n * Submit a Callable task for execution, receiving a Future representing that task.\r\n * The Future will return the Callable's result upon completion.\r\n * <p>As of 6.1, this method comes with a default implementation that delegates\r\n * to {@link #execute(Runnable)}.\r\n * @param task the {@code Callable} to execute (never {@code null})\r\n * @return a Future representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 3.0\r\n */\r\ndefault <T> Future<T> submit(Callable<T> task) {\r\n    FutureTask<T> future = new FutureTask<>(task);\r\n    execute(future, TIMEOUT_INDEFINITE);\r\n    return future;\r\n}",
    "comment": "\n\t * Submit a Callable task for execution, receiving a Future representing that task.\n\t * The Future will return the Callable's result upon completion.\n\t * <p>As of 6.1, this method comes with a default implementation that delegates\n\t * to {@link #execute(Runnable)}.\n\t * @param task the {@code Callable} to execute (never {@code null})\n\t * @return a Future representing pending completion of the task\n\t * @throws TaskRejectedException if the given task was not accepted\n\t * @since 3.0\n\t "
  },
  {
    "entityId": "org.springframework.core.task.AsyncTaskExecutor#submitCompletable(Runnable)",
    "entityType": "method",
    "code": "/**\r\n * Submit a {@code Runnable} task for execution, receiving a {@code CompletableFuture}\r\n * representing that task. The Future will return a {@code null} result upon completion.\r\n * @param task the {@code Runnable} to execute (never {@code null})\r\n * @return a {@code CompletableFuture} representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 6.0\r\n */\r\ndefault CompletableFuture<Void> submitCompletable(Runnable task) {\r\n    return CompletableFuture.runAsync(task, this);\r\n}",
    "comment": "\n\t * Submit a {@code Runnable} task for execution, receiving a {@code CompletableFuture}\n\t * representing that task. The Future will return a {@code null} result upon completion.\n\t * @param task the {@code Runnable} to execute (never {@code null})\n\t * @return a {@code CompletableFuture} representing pending completion of the task\n\t * @throws TaskRejectedException if the given task was not accepted\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.task.AsyncTaskExecutor#submitCompletable(Callable<T>)",
    "entityType": "method",
    "code": "/**\r\n * Submit a {@code Callable} task for execution, receiving a {@code CompletableFuture}\r\n * representing that task. The Future will return the Callable's result upon\r\n * completion.\r\n * @param task the {@code Callable} to execute (never {@code null})\r\n * @return a {@code CompletableFuture} representing pending completion of the task\r\n * @throws TaskRejectedException if the given task was not accepted\r\n * @since 6.0\r\n */\r\ndefault <T> CompletableFuture<T> submitCompletable(Callable<T> task) {\r\n    return FutureUtils.callAsync(task, this);\r\n}",
    "comment": "\n\t * Submit a {@code Callable} task for execution, receiving a {@code CompletableFuture}\n\t * representing that task. The Future will return the Callable's result upon\n\t * completion.\n\t * @param task the {@code Callable} to execute (never {@code null})\n\t * @return a {@code CompletableFuture} representing pending completion of the task\n\t * @throws TaskRejectedException if the given task was not accepted\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor",
    "entityType": "class",
    "code": "/**\r\n * Permit any number of concurrent invocations: that is, don't throttle concurrency.\r\n * @see ConcurrencyThrottleSupport#UNBOUNDED_CONCURRENCY\r\n */\r\npublic static final int UNBOUNDED_CONCURRENCY = ConcurrencyThrottleSupport.UNBOUNDED_CONCURRENCY;\n/**\r\n * Switch concurrency 'off': that is, don't allow any concurrent invocations.\r\n * @see ConcurrencyThrottleSupport#NO_CONCURRENCY\r\n */\r\npublic static final int NO_CONCURRENCY = ConcurrencyThrottleSupport.NO_CONCURRENCY;\n/**\r\n * Internal concurrency throttle used by this executor.\r\n */\r\nprivate final ConcurrencyThrottleAdapter concurrencyThrottle = new ConcurrencyThrottleAdapter();\n@Nullable\r\nprivate VirtualThreadDelegate virtualThreadDelegate;\n@Nullable\r\nprivate ThreadFactory threadFactory;\n@Nullable\r\nprivate TaskDecorator taskDecorator;\nprivate long taskTerminationTimeout;\n@Nullable\r\nprivate Set<Thread> activeThreads;\nprivate volatile boolean active = true;\n/**\r\n * Create a new SimpleAsyncTaskExecutor with default thread name prefix.\r\n */\r\npublic SimpleAsyncTaskExecutor() {\r\n    super();\r\n}\n/**\r\n * Create a new SimpleAsyncTaskExecutor with the given thread name prefix.\r\n * @param threadNamePrefix the prefix to use for the names of newly created threads\r\n */\r\npublic SimpleAsyncTaskExecutor(String threadNamePrefix) {\r\n    super(threadNamePrefix);\r\n}\n/**\r\n * Create a new SimpleAsyncTaskExecutor with the given external thread factory.\r\n * @param threadFactory the factory to use for creating new Threads\r\n */\r\npublic SimpleAsyncTaskExecutor(ThreadFactory threadFactory) {\r\n    this.threadFactory = threadFactory;\r\n}\n/**\r\n * Switch this executor to virtual threads. Requires Java 21 or higher.\r\n * <p>The default is {@code false}, indicating platform threads.\r\n * Set this flag to {@code true} in order to create virtual threads instead.\r\n * @since 6.1\r\n */\r\npublic void setVirtualThreads(boolean virtual) {\r\n    this.virtualThreadDelegate = (virtual ? new VirtualThreadDelegate() : null);\r\n}\n/**\r\n * Specify an external factory to use for creating new Threads,\r\n * instead of relying on the local properties of this executor.\r\n * <p>You may specify an inner ThreadFactory bean or also a ThreadFactory reference\r\n * obtained from JNDI (on a Jakarta EE server) or some other lookup mechanism.\r\n * @see #setThreadNamePrefix\r\n * @see #setThreadPriority\r\n */\r\npublic void setThreadFactory(@Nullable ThreadFactory threadFactory) {\r\n    this.threadFactory = threadFactory;\r\n}\n/**\r\n * Return the external factory to use for creating new Threads, if any.\r\n */\r\n@Nullable\r\npublic final ThreadFactory getThreadFactory() {\r\n    return this.threadFactory;\r\n}\n/**\r\n * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\r\n * about to be executed.\r\n * <p>Note that such a decorator is not necessarily being applied to the\r\n * user-supplied {@code Runnable}/{@code Callable} but rather to the actual\r\n * execution callback (which may be a wrapper around the user-supplied task).\r\n * <p>The primary use case is to set some execution context around the task's\r\n * invocation, or to provide some monitoring/statistics for task execution.\r\n * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\r\n * is limited to plain {@code Runnable} execution via {@code execute} calls.\r\n * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\r\n * {@code FutureTask} which does not propagate any exceptions; you might\r\n * have to cast it and call {@code Future#get} to evaluate exceptions.\r\n * @since 4.3\r\n */\r\npublic void setTaskDecorator(TaskDecorator taskDecorator) {\r\n    this.taskDecorator = taskDecorator;\r\n}\n/**\r\n * Specify a timeout (in milliseconds) for task termination when closing\r\n * this executor. The default is 0, not waiting for task termination at all.\r\n * <p>Note that a concrete >0 timeout specified here will lead to the\r\n * wrapping of every submitted task into a task-tracking runnable which\r\n * involves considerable overhead in case of a high number of tasks.\r\n * However, for a modest level of submissions with longer-running\r\n * tasks, this is feasible in order to arrive at a graceful shutdown.\r\n * <p>Note that {@code SimpleAsyncTaskExecutor} does not participate in\r\n * a coordinated lifecycle stop but rather just awaits task termination\r\n * on {@link #close()}.\r\n * @param timeout the timeout in milliseconds\r\n * @since 6.1\r\n * @see #close()\r\n * @see org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAwaitTerminationMillis\r\n */\r\npublic void setTaskTerminationTimeout(long timeout) {\r\n    Assert.isTrue(timeout >= 0, \"Timeout value must be >=0\");\r\n    this.taskTerminationTimeout = timeout;\r\n    this.activeThreads = (timeout > 0 ? ConcurrentHashMap.newKeySet() : null);\r\n}\n/**\r\n * Set the maximum number of parallel task executions allowed.\r\n * The default of -1 indicates no concurrency limit at all.\r\n * <p>This is the equivalent of a maximum pool size in a thread pool,\r\n * preventing temporary overload of the thread management system.\r\n * However, in contrast to a thread pool with a managed task queue,\r\n * this executor will block the submitter until the task can be\r\n * accepted when the configured concurrency limit has been reached.\r\n * If you prefer queue-based task hand-offs without such blocking,\r\n * consider using a {@code ThreadPoolTaskExecutor} instead.\r\n * @see #UNBOUNDED_CONCURRENCY\r\n * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setMaxPoolSize\r\n */\r\npublic void setConcurrencyLimit(int concurrencyLimit) {\r\n    this.concurrencyThrottle.setConcurrencyLimit(concurrencyLimit);\r\n}\n/**\r\n * Return the maximum number of parallel task executions allowed.\r\n */\r\npublic final int getConcurrencyLimit() {\r\n    return this.concurrencyThrottle.getConcurrencyLimit();\r\n}\n/**\r\n * Return whether the concurrency throttle is currently active.\r\n * @return {@code true} if the concurrency limit for this instance is active\r\n * @see #getConcurrencyLimit()\r\n * @see #setConcurrencyLimit\r\n */\r\npublic final boolean isThrottleActive() {\r\n    return this.concurrencyThrottle.isThrottleActive();\r\n}\n/**\r\n * Return whether this executor is still active, i.e. not closed yet,\r\n * and therefore accepts further task submissions. Otherwise, it is\r\n * either in the task termination phase or entirely shut down already.\r\n * @since 6.1\r\n * @see #setTaskTerminationTimeout\r\n * @see #close()\r\n */\r\npublic boolean isActive() {\r\n    return this.active;\r\n}\n/**\r\n * Executes the given task, within a concurrency throttle\r\n * if configured (through the superclass's settings).\r\n * @see #doExecute(Runnable)\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\n@Override\r\npublic void execute(Runnable task) {\r\n    execute(task, TIMEOUT_INDEFINITE);\r\n}\n/**\r\n * Executes the given task, within a concurrency throttle\r\n * if configured (through the superclass's settings).\r\n * <p>Executes urgent tasks (with 'immediate' timeout) directly,\r\n * bypassing the concurrency throttle (if active). All other\r\n * tasks are subject to throttling.\r\n * @see #TIMEOUT_IMMEDIATE\r\n * @see #doExecute(Runnable)\r\n */\r\n@Deprecated\r\n@Override\r\npublic void execute(Runnable task, long startTimeout) {\r\n    Assert.notNull(task, \"Runnable must not be null\");\r\n    if (!isActive()) {\r\n        throw new TaskRejectedException(getClass().getSimpleName() + \" has been closed already\");\r\n    }\r\n    Runnable taskToUse = (this.taskDecorator != null ? this.taskDecorator.decorate(task) : task);\r\n    if (isThrottleActive() && startTimeout > TIMEOUT_IMMEDIATE) {\r\n        this.concurrencyThrottle.beforeAccess();\r\n        doExecute(new TaskTrackingRunnable(taskToUse));\r\n    } else if (this.activeThreads != null) {\r\n        doExecute(new TaskTrackingRunnable(taskToUse));\r\n    } else {\r\n        doExecute(taskToUse);\r\n    }\r\n}\n@SuppressWarnings(\"deprecation\")\r\n@Override\r\npublic Future<?> submit(Runnable task) {\r\n    FutureTask<Object> future = new FutureTask<>(task, null);\r\n    execute(future, TIMEOUT_INDEFINITE);\r\n    return future;\r\n}\n@SuppressWarnings(\"deprecation\")\r\n@Override\r\npublic <T> Future<T> submit(Callable<T> task) {\r\n    FutureTask<T> future = new FutureTask<>(task);\r\n    execute(future, TIMEOUT_INDEFINITE);\r\n    return future;\r\n}\n/**\r\n * Template method for the actual execution of a task.\r\n * <p>The default implementation creates a new Thread and starts it.\r\n * @param task the Runnable to execute\r\n * @see #newThread\r\n * @see Thread#start()\r\n */\r\nprotected void doExecute(Runnable task) {\r\n    newThread(task).start();\r\n}\n/**\r\n * Create a new Thread for the given task.\r\n * @param task the Runnable to create a Thread for\r\n * @return the new Thread instance\r\n * @since 6.1\r\n * @see #setVirtualThreads\r\n * @see #setThreadFactory\r\n * @see #createThread\r\n */\r\nprotected Thread newThread(Runnable task) {\r\n    if (this.virtualThreadDelegate != null) {\r\n        return this.virtualThreadDelegate.newVirtualThread(nextThreadName(), task);\r\n    } else {\r\n        return (this.threadFactory != null ? this.threadFactory.newThread(task) : createThread(task));\r\n    }\r\n}\n/**\r\n * This close methods tracks the termination of active threads if a concrete\r\n * {@link #setTaskTerminationTimeout task termination timeout} has been set.\r\n * Otherwise, it is not necessary to close this executor.\r\n * @since 6.1\r\n */\r\n@Override\r\npublic void close() {\r\n    if (this.active) {\r\n        this.active = false;\r\n        Set<Thread> threads = this.activeThreads;\r\n        if (threads != null) {\r\n            threads.forEach(Thread::interrupt);\r\n            synchronized (threads) {\r\n                try {\r\n                    if (!threads.isEmpty()) {\r\n                        threads.wait(this.taskTerminationTimeout);\r\n                    }\r\n                } catch (InterruptedException ex) {\r\n                    Thread.currentThread().interrupt();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n/**\r\n * Subclass of the general ConcurrencyThrottleSupport class,\r\n * making {@code beforeAccess()} and {@code afterAccess()}\r\n * visible to the surrounding class.\r\n */\r\nprivate static class ConcurrencyThrottleAdapter extends ConcurrencyThrottleSupport {\r\n\r\n    @Override\r\n    protected void beforeAccess() {\r\n        super.beforeAccess();\r\n    }\r\n\r\n    @Override\r\n    protected void afterAccess() {\r\n        super.afterAccess();\r\n    }\r\n}\n/**\r\n * Decorates a target task with active thread tracking\r\n * and concurrency throttle management, if necessary.\r\n */\r\nprivate class TaskTrackingRunnable implements Runnable {\r\n\r\n    private final Runnable task;\r\n\r\n    public TaskTrackingRunnable(Runnable task) {\r\n        Assert.notNull(task, \"Task must not be null\");\r\n        this.task = task;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        Set<Thread> threads = activeThreads;\r\n        Thread thread = null;\r\n        if (threads != null) {\r\n            thread = Thread.currentThread();\r\n            threads.add(thread);\r\n        }\r\n        try {\r\n            this.task.run();\r\n        } finally {\r\n            if (threads != null) {\r\n                threads.remove(thread);\r\n                if (!isActive()) {\r\n                    synchronized (threads) {\r\n                        if (threads.isEmpty()) {\r\n                            threads.notify();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            concurrencyThrottle.afterAccess();\r\n        }\r\n    }\r\n}",
    "comment": "\n * {@link TaskExecutor} implementation that fires up a new Thread for each task,\n * executing it asynchronously. Provides a virtual thread option on JDK 21.\n *\n * <p>Supports a graceful shutdown through {@link #setTaskTerminationTimeout},\n * at the expense of task tracking overhead per execution thread at runtime.\n * Supports limiting concurrent threads through {@link #setConcurrencyLimit}.\n * By default, the number of concurrent task executions is unlimited.\n *\n * <p><b>NOTE: This implementation does not reuse threads!</b> Consider a\n * thread-pooling TaskExecutor implementation instead, in particular for\n * executing a large number of short-lived tasks. Alternatively, on JDK 21,\n * consider setting {@link #setVirtualThreads} to {@code true}.\n *\n * <p><b>NOTE: This executor does not participate in context-level lifecycle\n * management.</b> Tasks on handed-off execution threads cannot be centrally\n * stopped and restarted; if such tight lifecycle management is necessary,\n * consider a common {@code ThreadPoolTaskExecutor} setup instead.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see #setVirtualThreads\n * @see #setTaskTerminationTimeout\n * @see #setConcurrencyLimit\n * @see org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler\n * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\n "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#setVirtualThreads(boolean)",
    "entityType": "method",
    "code": "/**\r\n * Switch this executor to virtual threads. Requires Java 21 or higher.\r\n * <p>The default is {@code false}, indicating platform threads.\r\n * Set this flag to {@code true} in order to create virtual threads instead.\r\n * @since 6.1\r\n */\r\npublic void setVirtualThreads(boolean virtual) {\r\n    this.virtualThreadDelegate = (virtual ? new VirtualThreadDelegate() : null);\r\n}",
    "comment": "\n\t * Switch this executor to virtual threads. Requires Java 21 or higher.\n\t * <p>The default is {@code false}, indicating platform threads.\n\t * Set this flag to {@code true} in order to create virtual threads instead.\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#setThreadFactory(ThreadFactory)",
    "entityType": "method",
    "code": "/**\r\n * Specify an external factory to use for creating new Threads,\r\n * instead of relying on the local properties of this executor.\r\n * <p>You may specify an inner ThreadFactory bean or also a ThreadFactory reference\r\n * obtained from JNDI (on a Jakarta EE server) or some other lookup mechanism.\r\n * @see #setThreadNamePrefix\r\n * @see #setThreadPriority\r\n */\r\npublic void setThreadFactory(@Nullable ThreadFactory threadFactory) {\r\n    this.threadFactory = threadFactory;\r\n}",
    "comment": "\n\t * Specify an external factory to use for creating new Threads,\n\t * instead of relying on the local properties of this executor.\n\t * <p>You may specify an inner ThreadFactory bean or also a ThreadFactory reference\n\t * obtained from JNDI (on a Jakarta EE server) or some other lookup mechanism.\n\t * @see #setThreadNamePrefix\n\t * @see #setThreadPriority\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#getThreadFactory()",
    "entityType": "method",
    "code": "/**\r\n * Return the external factory to use for creating new Threads, if any.\r\n */\r\n@Nullable\r\npublic final ThreadFactory getThreadFactory() {\r\n    return this.threadFactory;\r\n}",
    "comment": "\n\t * Return the external factory to use for creating new Threads, if any.\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#setTaskDecorator(TaskDecorator)",
    "entityType": "method",
    "code": "/**\r\n * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\r\n * about to be executed.\r\n * <p>Note that such a decorator is not necessarily being applied to the\r\n * user-supplied {@code Runnable}/{@code Callable} but rather to the actual\r\n * execution callback (which may be a wrapper around the user-supplied task).\r\n * <p>The primary use case is to set some execution context around the task's\r\n * invocation, or to provide some monitoring/statistics for task execution.\r\n * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\r\n * is limited to plain {@code Runnable} execution via {@code execute} calls.\r\n * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\r\n * {@code FutureTask} which does not propagate any exceptions; you might\r\n * have to cast it and call {@code Future#get} to evaluate exceptions.\r\n * @since 4.3\r\n */\r\npublic void setTaskDecorator(TaskDecorator taskDecorator) {\r\n    this.taskDecorator = taskDecorator;\r\n}",
    "comment": "\n\t * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}\n\t * about to be executed.\n\t * <p>Note that such a decorator is not necessarily being applied to the\n\t * user-supplied {@code Runnable}/{@code Callable} but rather to the actual\n\t * execution callback (which may be a wrapper around the user-supplied task).\n\t * <p>The primary use case is to set some execution context around the task's\n\t * invocation, or to provide some monitoring/statistics for task execution.\n\t * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\n\t * is limited to plain {@code Runnable} execution via {@code execute} calls.\n\t * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\n\t * {@code FutureTask} which does not propagate any exceptions; you might\n\t * have to cast it and call {@code Future#get} to evaluate exceptions.\n\t * @since 4.3\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#setTaskTerminationTimeout(long)",
    "entityType": "method",
    "code": "/**\r\n * Specify a timeout (in milliseconds) for task termination when closing\r\n * this executor. The default is 0, not waiting for task termination at all.\r\n * <p>Note that a concrete >0 timeout specified here will lead to the\r\n * wrapping of every submitted task into a task-tracking runnable which\r\n * involves considerable overhead in case of a high number of tasks.\r\n * However, for a modest level of submissions with longer-running\r\n * tasks, this is feasible in order to arrive at a graceful shutdown.\r\n * <p>Note that {@code SimpleAsyncTaskExecutor} does not participate in\r\n * a coordinated lifecycle stop but rather just awaits task termination\r\n * on {@link #close()}.\r\n * @param timeout the timeout in milliseconds\r\n * @since 6.1\r\n * @see #close()\r\n * @see org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAwaitTerminationMillis\r\n */\r\npublic void setTaskTerminationTimeout(long timeout) {\r\n    Assert.isTrue(timeout >= 0, \"Timeout value must be >=0\");\r\n    this.taskTerminationTimeout = timeout;\r\n    this.activeThreads = (timeout > 0 ? ConcurrentHashMap.newKeySet() : null);\r\n}",
    "comment": "\n\t * Specify a timeout (in milliseconds) for task termination when closing\n\t * this executor. The default is 0, not waiting for task termination at all.\n\t * <p>Note that a concrete >0 timeout specified here will lead to the\n\t * wrapping of every submitted task into a task-tracking runnable which\n\t * involves considerable overhead in case of a high number of tasks.\n\t * However, for a modest level of submissions with longer-running\n\t * tasks, this is feasible in order to arrive at a graceful shutdown.\n\t * <p>Note that {@code SimpleAsyncTaskExecutor} does not participate in\n\t * a coordinated lifecycle stop but rather just awaits task termination\n\t * on {@link #close()}.\n\t * @param timeout the timeout in milliseconds\n\t * @since 6.1\n\t * @see #close()\n\t * @see org.springframework.scheduling.concurrent.ExecutorConfigurationSupport#setAwaitTerminationMillis\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#setConcurrencyLimit(int)",
    "entityType": "method",
    "code": "/**\r\n * Set the maximum number of parallel task executions allowed.\r\n * The default of -1 indicates no concurrency limit at all.\r\n * <p>This is the equivalent of a maximum pool size in a thread pool,\r\n * preventing temporary overload of the thread management system.\r\n * However, in contrast to a thread pool with a managed task queue,\r\n * this executor will block the submitter until the task can be\r\n * accepted when the configured concurrency limit has been reached.\r\n * If you prefer queue-based task hand-offs without such blocking,\r\n * consider using a {@code ThreadPoolTaskExecutor} instead.\r\n * @see #UNBOUNDED_CONCURRENCY\r\n * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setMaxPoolSize\r\n */\r\npublic void setConcurrencyLimit(int concurrencyLimit) {\r\n    this.concurrencyThrottle.setConcurrencyLimit(concurrencyLimit);\r\n}",
    "comment": "\n\t * Set the maximum number of parallel task executions allowed.\n\t * The default of -1 indicates no concurrency limit at all.\n\t * <p>This is the equivalent of a maximum pool size in a thread pool,\n\t * preventing temporary overload of the thread management system.\n\t * However, in contrast to a thread pool with a managed task queue,\n\t * this executor will block the submitter until the task can be\n\t * accepted when the configured concurrency limit has been reached.\n\t * If you prefer queue-based task hand-offs without such blocking,\n\t * consider using a {@code ThreadPoolTaskExecutor} instead.\n\t * @see #UNBOUNDED_CONCURRENCY\n\t * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor#setMaxPoolSize\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#getConcurrencyLimit()",
    "entityType": "method",
    "code": "/**\r\n * Return the maximum number of parallel task executions allowed.\r\n */\r\npublic final int getConcurrencyLimit() {\r\n    return this.concurrencyThrottle.getConcurrencyLimit();\r\n}",
    "comment": "\n\t * Return the maximum number of parallel task executions allowed.\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#isThrottleActive()",
    "entityType": "method",
    "code": "/**\r\n * Return whether the concurrency throttle is currently active.\r\n * @return {@code true} if the concurrency limit for this instance is active\r\n * @see #getConcurrencyLimit()\r\n * @see #setConcurrencyLimit\r\n */\r\npublic final boolean isThrottleActive() {\r\n    return this.concurrencyThrottle.isThrottleActive();\r\n}",
    "comment": "\n\t * Return whether the concurrency throttle is currently active.\n\t * @return {@code true} if the concurrency limit for this instance is active\n\t * @see #getConcurrencyLimit()\n\t * @see #setConcurrencyLimit\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#isActive()",
    "entityType": "method",
    "code": "/**\r\n * Return whether this executor is still active, i.e. not closed yet,\r\n * and therefore accepts further task submissions. Otherwise, it is\r\n * either in the task termination phase or entirely shut down already.\r\n * @since 6.1\r\n * @see #setTaskTerminationTimeout\r\n * @see #close()\r\n */\r\npublic boolean isActive() {\r\n    return this.active;\r\n}",
    "comment": "\n\t * Return whether this executor is still active, i.e. not closed yet,\n\t * and therefore accepts further task submissions. Otherwise, it is\n\t * either in the task termination phase or entirely shut down already.\n\t * @since 6.1\n\t * @see #setTaskTerminationTimeout\n\t * @see #close()\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#execute(Runnable)",
    "entityType": "method",
    "code": "/**\r\n * Executes the given task, within a concurrency throttle\r\n * if configured (through the superclass's settings).\r\n * @see #doExecute(Runnable)\r\n */\r\n@SuppressWarnings(\"deprecation\")\r\n@Override\r\npublic void execute(Runnable task) {\r\n    execute(task, TIMEOUT_INDEFINITE);\r\n}",
    "comment": "\n\t * Executes the given task, within a concurrency throttle\n\t * if configured (through the superclass's settings).\n\t * @see #doExecute(Runnable)\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#execute(Runnable,long)",
    "entityType": "method",
    "code": "/**\r\n * Executes the given task, within a concurrency throttle\r\n * if configured (through the superclass's settings).\r\n * <p>Executes urgent tasks (with 'immediate' timeout) directly,\r\n * bypassing the concurrency throttle (if active). All other\r\n * tasks are subject to throttling.\r\n * @see #TIMEOUT_IMMEDIATE\r\n * @see #doExecute(Runnable)\r\n */\r\n@Deprecated\r\n@Override\r\npublic void execute(Runnable task, long startTimeout) {\r\n    Assert.notNull(task, \"Runnable must not be null\");\r\n    if (!isActive()) {\r\n        throw new TaskRejectedException(getClass().getSimpleName() + \" has been closed already\");\r\n    }\r\n    Runnable taskToUse = (this.taskDecorator != null ? this.taskDecorator.decorate(task) : task);\r\n    if (isThrottleActive() && startTimeout > TIMEOUT_IMMEDIATE) {\r\n        this.concurrencyThrottle.beforeAccess();\r\n        doExecute(new TaskTrackingRunnable(taskToUse));\r\n    } else if (this.activeThreads != null) {\r\n        doExecute(new TaskTrackingRunnable(taskToUse));\r\n    } else {\r\n        doExecute(taskToUse);\r\n    }\r\n}",
    "comment": "\n\t * Executes the given task, within a concurrency throttle\n\t * if configured (through the superclass's settings).\n\t * <p>Executes urgent tasks (with 'immediate' timeout) directly,\n\t * bypassing the concurrency throttle (if active). All other\n\t * tasks are subject to throttling.\n\t * @see #TIMEOUT_IMMEDIATE\n\t * @see #doExecute(Runnable)\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#submit(Runnable)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"deprecation\")\r\n@Override\r\npublic Future<?> submit(Runnable task) {\r\n    FutureTask<Object> future = new FutureTask<>(task, null);\r\n    execute(future, TIMEOUT_INDEFINITE);\r\n    return future;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#submit(Callable<T>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"deprecation\")\r\n@Override\r\npublic <T> Future<T> submit(Callable<T> task) {\r\n    FutureTask<T> future = new FutureTask<>(task);\r\n    execute(future, TIMEOUT_INDEFINITE);\r\n    return future;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#doExecute(Runnable)",
    "entityType": "method",
    "code": "/**\r\n * Template method for the actual execution of a task.\r\n * <p>The default implementation creates a new Thread and starts it.\r\n * @param task the Runnable to execute\r\n * @see #newThread\r\n * @see Thread#start()\r\n */\r\nprotected void doExecute(Runnable task) {\r\n    newThread(task).start();\r\n}",
    "comment": "\n\t * Template method for the actual execution of a task.\n\t * <p>The default implementation creates a new Thread and starts it.\n\t * @param task the Runnable to execute\n\t * @see #newThread\n\t * @see Thread#start()\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#newThread(Runnable)",
    "entityType": "method",
    "code": "/**\r\n * Create a new Thread for the given task.\r\n * @param task the Runnable to create a Thread for\r\n * @return the new Thread instance\r\n * @since 6.1\r\n * @see #setVirtualThreads\r\n * @see #setThreadFactory\r\n * @see #createThread\r\n */\r\nprotected Thread newThread(Runnable task) {\r\n    if (this.virtualThreadDelegate != null) {\r\n        return this.virtualThreadDelegate.newVirtualThread(nextThreadName(), task);\r\n    } else {\r\n        return (this.threadFactory != null ? this.threadFactory.newThread(task) : createThread(task));\r\n    }\r\n}",
    "comment": "\n\t * Create a new Thread for the given task.\n\t * @param task the Runnable to create a Thread for\n\t * @return the new Thread instance\n\t * @since 6.1\n\t * @see #setVirtualThreads\n\t * @see #setThreadFactory\n\t * @see #createThread\n\t "
  },
  {
    "entityId": "org.springframework.core.task.SimpleAsyncTaskExecutor#close()",
    "entityType": "method",
    "code": "/**\r\n * This close methods tracks the termination of active threads if a concrete\r\n * {@link #setTaskTerminationTimeout task termination timeout} has been set.\r\n * Otherwise, it is not necessary to close this executor.\r\n * @since 6.1\r\n */\r\n@Override\r\npublic void close() {\r\n    if (this.active) {\r\n        this.active = false;\r\n        Set<Thread> threads = this.activeThreads;\r\n        if (threads != null) {\r\n            threads.forEach(Thread::interrupt);\r\n            synchronized (threads) {\r\n                try {\r\n                    if (!threads.isEmpty()) {\r\n                        threads.wait(this.taskTerminationTimeout);\r\n                    }\r\n                } catch (InterruptedException ex) {\r\n                    Thread.currentThread().interrupt();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * This close methods tracks the termination of active threads if a concrete\n\t * {@link #setTaskTerminationTimeout task termination timeout} has been set.\n\t * Otherwise, it is not necessary to close this executor.\n\t * @since 6.1\n\t "
  }
]