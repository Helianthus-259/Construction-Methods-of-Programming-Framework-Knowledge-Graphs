[
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertOfAndExpressionWithInvertedSingleElement(Profiles)",
    "entityType": "method",
    "code": "private void assertOfAndExpressionWithInvertedSingleElement(Profiles profiles) {\r\n    assertThat(profiles.matches(activeProfiles(\"framework\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"java\"))).isFalse();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\", \"framework\"))).isFalse();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#ofOrExpressionWithInvertedSingleElementWithoutSpaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofOrExpressionWithInvertedSingleElementWithoutSpaces() {\r\n    Profiles profiles = Profiles.of(\"!spring|framework\");\r\n    assertOfOrExpressionWithInvertedSingleElement(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertOfOrExpressionWithInvertedSingleElement(Profiles)",
    "entityType": "method",
    "code": "private void assertOfOrExpressionWithInvertedSingleElement(Profiles profiles) {\r\n    assertThat(profiles.matches(activeProfiles(\"framework\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"java\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\", \"framework\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#ofNotOrExpression()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofNotOrExpression() {\r\n    Profiles profiles = Profiles.of(\"!(spring | framework)\");\r\n    assertOfNotOrExpression(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#ofNotOrExpressionWithoutSpaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofNotOrExpressionWithoutSpaces() {\r\n    Profiles profiles = Profiles.of(\"!(spring|framework)\");\r\n    assertOfNotOrExpression(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertOfNotOrExpression(Profiles)",
    "entityType": "method",
    "code": "private void assertOfNotOrExpression(Profiles profiles) {\r\n    assertThat(profiles.matches(activeProfiles(\"spring\"))).isFalse();\r\n    assertThat(profiles.matches(activeProfiles(\"framework\"))).isFalse();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\", \"framework\"))).isFalse();\r\n    assertThat(profiles.matches(activeProfiles(\"java\"))).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#ofComplexExpression()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofComplexExpression() {\r\n    Profiles profiles = Profiles.of(\"(spring & framework) | (spring & java)\");\r\n    assertComplexExpression(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#ofComplexExpressionWithoutSpaces()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofComplexExpressionWithoutSpaces() {\r\n    Profiles profiles = Profiles.of(\"(spring&framework)|(spring&java)\");\r\n    assertComplexExpression(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#ofComplexExpressionEnclosedInParentheses()",
    "entityType": "method",
    "code": "@Test\r\nvoid ofComplexExpressionEnclosedInParentheses() {\r\n    Profiles profiles = Profiles.of(\"((spring & framework) | (spring & java))\");\r\n    assertComplexExpression(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertComplexExpression(Profiles)",
    "entityType": "method",
    "code": "private void assertComplexExpression(Profiles profiles) {\r\n    assertThat(profiles.matches(activeProfiles(\"spring\"))).isFalse();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\", \"framework\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"spring\", \"java\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"java\", \"framework\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#malformedExpressions()",
    "entityType": "method",
    "code": "@Test\r\nvoid malformedExpressions() {\r\n    assertMalformed(() -> Profiles.of(\"(\"));\r\n    assertMalformed(() -> Profiles.of(\")\"));\r\n    assertMalformed(() -> Profiles.of(\"a & b | c\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#sensibleToString()",
    "entityType": "method",
    "code": "@Test\r\nvoid sensibleToString() {\r\n    assertThat(Profiles.of(\"spring\")).hasToString(\"spring\");\r\n    assertThat(Profiles.of(\"(spring & framework) | (spring & java)\")).hasToString(\"(spring & framework) | (spring & java)\");\r\n    assertThat(Profiles.of(\"(spring&framework)|(spring&java)\")).hasToString(\"(spring&framework)|(spring&java)\");\r\n    assertThat(Profiles.of(\"spring & framework\", \"java | kotlin\")).hasToString(\"(spring & framework) | (java | kotlin)\");\r\n    assertThat(Profiles.of(\"java | kotlin\", \"spring & framework\")).hasToString(\"(java | kotlin) | (spring & framework)\");\r\n    assertThat(Profiles.of(\"java | kotlin\", \"spring & framework\", \"cat | dog\")).hasToString(\"(java | kotlin) | (spring & framework) | (cat | dog)\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#toStringGeneratesValidCompositeProfileExpression()",
    "entityType": "method",
    "code": "@Test\r\nvoid toStringGeneratesValidCompositeProfileExpression() {\r\n    assertThatToStringGeneratesValidCompositeProfileExpression(\"spring\");\r\n    assertThatToStringGeneratesValidCompositeProfileExpression(\"(spring & kotlin) | (spring & java)\");\r\n    assertThatToStringGeneratesValidCompositeProfileExpression(\"spring & kotlin\", \"spring & java\");\r\n    assertThatToStringGeneratesValidCompositeProfileExpression(\"spring & kotlin\", \"spring & java\", \"cat | dog\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertThatToStringGeneratesValidCompositeProfileExpression(String)",
    "entityType": "method",
    "code": "private static void assertThatToStringGeneratesValidCompositeProfileExpression(String... profileExpressions) {\r\n    Profiles profiles = Profiles.of(profileExpressions);\r\n    assertThat(profiles.matches(activeProfiles(\"spring\", \"java\"))).isTrue();\r\n    assertThat(profiles.matches(activeProfiles(\"kotlin\"))).isFalse();\r\n    Profiles compositeProfiles = Profiles.of(profiles.toString());\r\n    assertThat(compositeProfiles.matches(activeProfiles(\"spring\", \"java\"))).isTrue();\r\n    assertThat(compositeProfiles.matches(activeProfiles(\"kotlin\"))).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#sensibleEquals()",
    "entityType": "method",
    "code": "@Test\r\nvoid sensibleEquals() {\r\n    assertEqual(\"(spring & framework) | (spring & java)\");\r\n    assertEqual(\"(spring&framework)|(spring&java)\");\r\n    assertEqual(\"spring & framework\", \"java | kotlin\");\r\n    // Ensure order of individual expressions does not affect equals().\r\n    String expression1 = \"A | B\";\r\n    String expression2 = \"C & (D | E)\";\r\n    Profiles profiles1 = Profiles.of(expression1, expression2);\r\n    Profiles profiles2 = Profiles.of(expression2, expression1);\r\n    assertThat(profiles1).isEqualTo(profiles2);\r\n    assertThat(profiles2).isEqualTo(profiles1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertEqual(String)",
    "entityType": "method",
    "code": "private void assertEqual(String... expressions) {\r\n    Profiles profiles1 = Profiles.of(expressions);\r\n    Profiles profiles2 = Profiles.of(expressions);\r\n    assertThat(profiles1).isEqualTo(profiles2);\r\n    assertThat(profiles2).isEqualTo(profiles1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#sensibleHashCode()",
    "entityType": "method",
    "code": "@Test\r\nvoid sensibleHashCode() {\r\n    assertHashCode(\"(spring & framework) | (spring & java)\");\r\n    assertHashCode(\"(spring&framework)|(spring&java)\");\r\n    assertHashCode(\"spring & framework\", \"java | kotlin\");\r\n    // Ensure order of individual expressions does not affect hashCode().\r\n    String expression1 = \"A | B\";\r\n    String expression2 = \"C & (D | E)\";\r\n    Profiles profiles1 = Profiles.of(expression1, expression2);\r\n    Profiles profiles2 = Profiles.of(expression2, expression1);\r\n    assertThat(profiles1).hasSameHashCodeAs(profiles2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertHashCode(String)",
    "entityType": "method",
    "code": "private void assertHashCode(String... expressions) {\r\n    Profiles profiles1 = Profiles.of(expressions);\r\n    Profiles profiles2 = Profiles.of(expressions);\r\n    assertThat(profiles1).hasSameHashCodeAs(profiles2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#equalsAndHashCodeAreNotBasedOnLogicalStructureOfNodesWithinExpressionTree()",
    "entityType": "method",
    "code": "@Test\r\nvoid equalsAndHashCodeAreNotBasedOnLogicalStructureOfNodesWithinExpressionTree() {\r\n    Profiles profiles1 = Profiles.of(\"A | B\");\r\n    Profiles profiles2 = Profiles.of(\"B | A\");\r\n    assertThat(profiles1.matches(activeProfiles(\"A\"))).isTrue();\r\n    assertThat(profiles1.matches(activeProfiles(\"B\"))).isTrue();\r\n    assertThat(profiles2.matches(activeProfiles(\"A\"))).isTrue();\r\n    assertThat(profiles2.matches(activeProfiles(\"B\"))).isTrue();\r\n    assertThat(profiles1).isNotEqualTo(profiles2);\r\n    assertThat(profiles2).isNotEqualTo(profiles1);\r\n    assertThat(profiles1.hashCode()).isNotEqualTo(profiles2.hashCode());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#assertMalformed(Supplier<Profiles>)",
    "entityType": "method",
    "code": "private static void assertMalformed(Supplier<Profiles> supplier) {\r\n    assertThatIllegalArgumentException().isThrownBy(supplier::get).withMessageStartingWith(\"Malformed profile expression\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.ProfilesTests#activeProfiles(String)",
    "entityType": "method",
    "code": "private static Predicate<String> activeProfiles(String... profiles) {\r\n    return new MockActiveProfiles(profiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MockActiveProfiles",
    "entityType": "class",
    "code": "private final List<String> activeProfiles;\nMockActiveProfiles(String[] activeProfiles) {\r\n    this.activeProfiles = Arrays.asList(activeProfiles);\r\n}\n@Override\r\npublic boolean test(String profile) {\r\n    // The following if-condition (which basically mimics\r\n    // AbstractEnvironment#validateProfile(String)) is necessary in order\r\n    // to ensure that the Profiles implementation returned by Profiles.of()\r\n    // never passes an invalid (parsed) profile name to the active profiles\r\n    // predicate supplied to Profiles#matches(Predicate<String>).\r\n    if (!StringUtils.hasText(profile) || profile.charAt(0) == '!') {\r\n        throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]\");\r\n    }\r\n    return this.activeProfiles.contains(profile);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.MockActiveProfiles#test(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(String profile) {\r\n    // The following if-condition (which basically mimics\r\n    // AbstractEnvironment#validateProfile(String)) is necessary in order\r\n    // to ensure that the Profiles implementation returned by Profiles.of()\r\n    // never passes an invalid (parsed) profile name to the active profiles\r\n    // predicate supplied to Profiles#matches(Predicate<String>).\r\n    if (!StringUtils.hasText(profile) || profile.charAt(0) == '!') {\r\n        throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]\");\r\n    }\r\n    return this.activeProfiles.contains(profile);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests",
    "entityType": "class",
    "code": "private Properties testProperties;\nprivate MutablePropertySources propertySources;\nprivate ConfigurablePropertyResolver propertyResolver;\n@BeforeEach\r\nvoid setUp() {\r\n    propertySources = new MutablePropertySources();\r\n    propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    testProperties = new Properties();\r\n    propertySources.addFirst(new PropertiesPropertySource(\"testProperties\", testProperties));\r\n}\n@Test\r\nvoid containsProperty() {\r\n    assertThat(propertyResolver.containsProperty(\"foo\")).isFalse();\r\n    testProperties.put(\"foo\", \"bar\");\r\n    assertThat(propertyResolver.containsProperty(\"foo\")).isTrue();\r\n}\n@Test\r\nvoid getProperty() {\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isNull();\r\n    testProperties.put(\"foo\", \"bar\");\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"bar\");\r\n}\n@Test\r\nvoid getProperty_withDefaultValue() {\r\n    assertThat(propertyResolver.getProperty(\"foo\", \"myDefault\")).isEqualTo(\"myDefault\");\r\n    testProperties.put(\"foo\", \"bar\");\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"bar\");\r\n}\n@Test\r\nvoid getProperty_propertySourceSearchOrderIsFIFO() {\r\n    MutablePropertySources sources = new MutablePropertySources();\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(sources);\r\n    sources.addFirst(new MockPropertySource(\"ps1\").withProperty(\"pName\", \"ps1Value\"));\r\n    assertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps1Value\");\r\n    sources.addFirst(new MockPropertySource(\"ps2\").withProperty(\"pName\", \"ps2Value\"));\r\n    assertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps2Value\");\r\n    sources.addFirst(new MockPropertySource(\"ps3\").withProperty(\"pName\", \"ps3Value\"));\r\n    assertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps3Value\");\r\n}\n@Test\r\nvoid getProperty_withExplicitNullValue() {\r\n    // java.util.Properties does not allow null values (because Hashtable does not)\r\n    Map<String, Object> nullableProperties = new HashMap<>();\r\n    propertySources.addLast(new MapPropertySource(\"nullableProperties\", nullableProperties));\r\n    nullableProperties.put(\"foo\", null);\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isNull();\r\n}\n@Test\r\nvoid getProperty_withTargetType_andDefaultValue() {\r\n    assertThat(propertyResolver.getProperty(\"foo\", Integer.class, 42)).isEqualTo(42);\r\n    testProperties.put(\"foo\", 13);\r\n    assertThat(propertyResolver.getProperty(\"foo\", Integer.class, 42)).isEqualTo(13);\r\n}\n@Test\r\nvoid getProperty_withStringArrayConversion() {\r\n    testProperties.put(\"foo\", \"bar,baz\");\r\n    assertThat(propertyResolver.getProperty(\"foo\", String[].class)).isEqualTo(new String[] { \"bar\", \"baz\" });\r\n}\n@Test\r\nvoid getProperty_withNonConvertibleTargetType() {\r\n    testProperties.put(\"foo\", \"bar\");\r\n    class TestType ;\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() -> propertyResolver.getProperty(\"foo\", TestType.class));\r\n}\n@Test\r\nvoid getProperty_doesNotCache_replaceExistingKeyPostConstruction() {\r\n    String key = \"foo\";\r\n    String value1 = \"bar\";\r\n    String value2 = \"biz\";\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    // before construction\r\n    map.put(key, value1);\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MapPropertySource(\"testProperties\", map));\r\n    PropertyResolver propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(propertyResolver.getProperty(key)).isEqualTo(value1);\r\n    // after construction and first resolution\r\n    map.put(key, value2);\r\n    assertThat(propertyResolver.getProperty(key)).isEqualTo(value2);\r\n}\n@Test\r\nvoid getProperty_doesNotCache_addNewKeyPostConstruction() {\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MapPropertySource(\"testProperties\", map));\r\n    PropertyResolver propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isNull();\r\n    map.put(\"foo\", \"42\");\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"42\");\r\n}\n@Test\r\nvoid getPropertySources_replacePropertySource() {\r\n    propertySources = new MutablePropertySources();\r\n    propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    propertySources.addLast(new MockPropertySource(\"local\").withProperty(\"foo\", \"localValue\"));\r\n    propertySources.addLast(new MockPropertySource(\"system\").withProperty(\"foo\", \"systemValue\"));\r\n    // 'local' was added first so has precedence\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"localValue\");\r\n    // replace 'local' with new property source\r\n    propertySources.replace(\"local\", new MockPropertySource(\"new\").withProperty(\"foo\", \"newValue\"));\r\n    // 'system' now has precedence\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"newValue\");\r\n    assertThat(propertySources).hasSize(2);\r\n}\n@Test\r\nvoid getRequiredProperty() {\r\n    testProperties.put(\"exists\", \"xyz\");\r\n    assertThat(propertyResolver.getRequiredProperty(\"exists\")).isEqualTo(\"xyz\");\r\n    assertThatIllegalStateException().isThrownBy(() -> propertyResolver.getRequiredProperty(\"bogus\"));\r\n}\n@Test\r\nvoid getRequiredProperty_withStringArrayConversion() {\r\n    testProperties.put(\"exists\", \"abc,123\");\r\n    assertThat(propertyResolver.getRequiredProperty(\"exists\", String[].class)).isEqualTo(new String[] { \"abc\", \"123\" });\r\n    assertThatIllegalStateException().isThrownBy(() -> propertyResolver.getRequiredProperty(\"bogus\", String[].class));\r\n}\n@Test\r\nvoid resolvePlaceholders() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolvePlaceholders(\"Replace this ${key}\")).isEqualTo(\"Replace this value\");\r\n}\n@Test\r\nvoid resolvePlaceholders_withUnresolvable() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolvePlaceholders(\"Replace this ${key} plus ${unknown}\")).isEqualTo(\"Replace this value plus ${unknown}\");\r\n}\n@Test\r\nvoid resolvePlaceholders_withDefaultValue() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolvePlaceholders(\"Replace this ${key} plus ${unknown:defaultValue}\")).isEqualTo(\"Replace this value plus defaultValue\");\r\n}\n@Test\r\nvoid resolvePlaceholders_withNullInput() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PropertySourcesPropertyResolver(new MutablePropertySources()).resolvePlaceholders(null));\r\n}\n@Test\r\nvoid resolveRequiredPlaceholders() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolveRequiredPlaceholders(\"Replace this ${key}\")).isEqualTo(\"Replace this value\");\r\n}\n@Test\r\nvoid resolveRequiredPlaceholders_withUnresolvable() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> resolver.resolveRequiredPlaceholders(\"Replace this ${key} plus ${unknown}\"));\r\n}\n@Test\r\nvoid resolveRequiredPlaceholders_withDefaultValue() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolveRequiredPlaceholders(\"Replace this ${key} plus ${unknown:defaultValue}\")).isEqualTo(\"Replace this value plus defaultValue\");\r\n}\n@Test\r\nvoid resolveRequiredPlaceholders_withNullInput() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PropertySourcesPropertyResolver(new MutablePropertySources()).resolveRequiredPlaceholders(null));\r\n}\n@Test\r\nvoid setRequiredProperties_andValidateRequiredProperties() {\r\n    // no properties have been marked as required -> validation should pass\r\n    propertyResolver.validateRequiredProperties();\r\n    // mark which properties are required\r\n    propertyResolver.setRequiredProperties(\"foo\", \"bar\");\r\n    // neither foo nor bar properties are present -> validating should throw\r\n    assertThatExceptionOfType(MissingRequiredPropertiesException.class).isThrownBy(propertyResolver::validateRequiredProperties).withMessage(\"The following properties were declared as required \" + \"but could not be resolved: [foo, bar]\");\r\n    // add foo property -> validation should fail only on missing 'bar' property\r\n    testProperties.put(\"foo\", \"fooValue\");\r\n    assertThatExceptionOfType(MissingRequiredPropertiesException.class).isThrownBy(propertyResolver::validateRequiredProperties).withMessage(\"The following properties were declared as required \" + \"but could not be resolved: [bar]\");\r\n    // add bar property -> validation should pass, even with an empty string value\r\n    testProperties.put(\"bar\", \"\");\r\n    propertyResolver.validateRequiredProperties();\r\n}\n@Test\r\nvoid resolveNestedPropertyPlaceholders() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", // nested placeholders\r\n    \"${p1}:${p2}\").withProperty(\"p4\", // deeply nested placeholders\r\n    \"${p3}\").withProperty(\"p5\", // unresolvable placeholder\r\n    \"${p1}:${p2}:${bogus}\").withProperty(\"p6\", // unresolvable w/ default\r\n    \"${p1}:${p2}:${bogus:def}\").withProperty(\"pL\", // cyclic reference left\r\n    \"${pR}\").withProperty(\"pR\", // cyclic reference right\r\n    \"${pL}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\r\n    assertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"p5\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n    assertThat(pr.getProperty(\"p6\")).isEqualTo(\"v1:v2:def\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"pL\")).withMessageContaining(\"Circular\");\r\n}\n@Test\r\nvoid resolveNestedPlaceholdersIfValueIsCharSequence() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\r\n}\n@Test\r\nvoid resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p3\", StringBuilder.class)).isInstanceOf(StringBuilder.class).hasToString(\"${p1}:${p2}\");\r\n}\n// gh-33727\r\n@Test\r\nvoid resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"new.enabled\", \"${old.enabled:true}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"new.enabled\", Boolean.class, false)).isTrue();\r\n}\n@Test\r\nvoid ignoreUnresolvableNestedPlaceholdersIsConfigurable() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", // unresolvable w/ default\r\n    \"${p1}:${p2}:${bogus:def}\").withProperty(\"p4\", // unresolvable placeholder\r\n    \"${p1}:${p2}:${bogus}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2:def\");\r\n    // placeholders nested within the value of \"p4\" are unresolvable and cause an\r\n    // exception by default\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"p4\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n    // relax the treatment of unresolvable nested placeholders\r\n    pr.setIgnoreUnresolvableNestedPlaceholders(true);\r\n    // and observe they now pass through unresolved\r\n    assertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2:${bogus}\");\r\n    // resolve[Nested]Placeholders methods behave as usual regardless the value of\r\n    // ignoreUnresolvableNestedPlaceholders\r\n    assertThat(pr.resolvePlaceholders(\"${p1}:${p2}:${bogus}\")).isEqualTo(\"v1:v2:${bogus}\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.resolveRequiredPlaceholders(\"${p1}:${p2}:${bogus}\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n}",
    "comment": "\n * @author Chris Beams\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#setUp()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid setUp() {\r\n    propertySources = new MutablePropertySources();\r\n    propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    testProperties = new Properties();\r\n    propertySources.addFirst(new PropertiesPropertySource(\"testProperties\", testProperties));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#containsProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsProperty() {\r\n    assertThat(propertyResolver.containsProperty(\"foo\")).isFalse();\r\n    testProperties.put(\"foo\", \"bar\");\r\n    assertThat(propertyResolver.containsProperty(\"foo\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty() {\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isNull();\r\n    testProperties.put(\"foo\", \"bar\");\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_withDefaultValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_withDefaultValue() {\r\n    assertThat(propertyResolver.getProperty(\"foo\", \"myDefault\")).isEqualTo(\"myDefault\");\r\n    testProperties.put(\"foo\", \"bar\");\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"bar\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_propertySourceSearchOrderIsFIFO()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_propertySourceSearchOrderIsFIFO() {\r\n    MutablePropertySources sources = new MutablePropertySources();\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(sources);\r\n    sources.addFirst(new MockPropertySource(\"ps1\").withProperty(\"pName\", \"ps1Value\"));\r\n    assertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps1Value\");\r\n    sources.addFirst(new MockPropertySource(\"ps2\").withProperty(\"pName\", \"ps2Value\"));\r\n    assertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps2Value\");\r\n    sources.addFirst(new MockPropertySource(\"ps3\").withProperty(\"pName\", \"ps3Value\"));\r\n    assertThat(resolver.getProperty(\"pName\")).isEqualTo(\"ps3Value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_withExplicitNullValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_withExplicitNullValue() {\r\n    // java.util.Properties does not allow null values (because Hashtable does not)\r\n    Map<String, Object> nullableProperties = new HashMap<>();\r\n    propertySources.addLast(new MapPropertySource(\"nullableProperties\", nullableProperties));\r\n    nullableProperties.put(\"foo\", null);\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_withTargetType_andDefaultValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_withTargetType_andDefaultValue() {\r\n    assertThat(propertyResolver.getProperty(\"foo\", Integer.class, 42)).isEqualTo(42);\r\n    testProperties.put(\"foo\", 13);\r\n    assertThat(propertyResolver.getProperty(\"foo\", Integer.class, 42)).isEqualTo(13);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_withStringArrayConversion()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_withStringArrayConversion() {\r\n    testProperties.put(\"foo\", \"bar,baz\");\r\n    assertThat(propertyResolver.getProperty(\"foo\", String[].class)).isEqualTo(new String[] { \"bar\", \"baz\" });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_withNonConvertibleTargetType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_withNonConvertibleTargetType() {\r\n    testProperties.put(\"foo\", \"bar\");\r\n    class TestType ;\r\n    assertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() -> propertyResolver.getProperty(\"foo\", TestType.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_doesNotCache_replaceExistingKeyPostConstruction()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_doesNotCache_replaceExistingKeyPostConstruction() {\r\n    String key = \"foo\";\r\n    String value1 = \"bar\";\r\n    String value2 = \"biz\";\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    // before construction\r\n    map.put(key, value1);\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MapPropertySource(\"testProperties\", map));\r\n    PropertyResolver propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(propertyResolver.getProperty(key)).isEqualTo(value1);\r\n    // after construction and first resolution\r\n    map.put(key, value2);\r\n    assertThat(propertyResolver.getProperty(key)).isEqualTo(value2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getProperty_doesNotCache_addNewKeyPostConstruction()",
    "entityType": "method",
    "code": "@Test\r\nvoid getProperty_doesNotCache_addNewKeyPostConstruction() {\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MapPropertySource(\"testProperties\", map));\r\n    PropertyResolver propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isNull();\r\n    map.put(\"foo\", \"42\");\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"42\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getPropertySources_replacePropertySource()",
    "entityType": "method",
    "code": "@Test\r\nvoid getPropertySources_replacePropertySource() {\r\n    propertySources = new MutablePropertySources();\r\n    propertyResolver = new PropertySourcesPropertyResolver(propertySources);\r\n    propertySources.addLast(new MockPropertySource(\"local\").withProperty(\"foo\", \"localValue\"));\r\n    propertySources.addLast(new MockPropertySource(\"system\").withProperty(\"foo\", \"systemValue\"));\r\n    // 'local' was added first so has precedence\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"localValue\");\r\n    // replace 'local' with new property source\r\n    propertySources.replace(\"local\", new MockPropertySource(\"new\").withProperty(\"foo\", \"newValue\"));\r\n    // 'system' now has precedence\r\n    assertThat(propertyResolver.getProperty(\"foo\")).isEqualTo(\"newValue\");\r\n    assertThat(propertySources).hasSize(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getRequiredProperty()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRequiredProperty() {\r\n    testProperties.put(\"exists\", \"xyz\");\r\n    assertThat(propertyResolver.getRequiredProperty(\"exists\")).isEqualTo(\"xyz\");\r\n    assertThatIllegalStateException().isThrownBy(() -> propertyResolver.getRequiredProperty(\"bogus\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#getRequiredProperty_withStringArrayConversion()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRequiredProperty_withStringArrayConversion() {\r\n    testProperties.put(\"exists\", \"abc,123\");\r\n    assertThat(propertyResolver.getRequiredProperty(\"exists\", String[].class)).isEqualTo(new String[] { \"abc\", \"123\" });\r\n    assertThatIllegalStateException().isThrownBy(() -> propertyResolver.getRequiredProperty(\"bogus\", String[].class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolvePlaceholders()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolvePlaceholders() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolvePlaceholders(\"Replace this ${key}\")).isEqualTo(\"Replace this value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolvePlaceholders_withUnresolvable()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolvePlaceholders_withUnresolvable() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolvePlaceholders(\"Replace this ${key} plus ${unknown}\")).isEqualTo(\"Replace this value plus ${unknown}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolvePlaceholders_withDefaultValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolvePlaceholders_withDefaultValue() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolvePlaceholders(\"Replace this ${key} plus ${unknown:defaultValue}\")).isEqualTo(\"Replace this value plus defaultValue\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolvePlaceholders_withNullInput()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolvePlaceholders_withNullInput() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PropertySourcesPropertyResolver(new MutablePropertySources()).resolvePlaceholders(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveRequiredPlaceholders()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveRequiredPlaceholders() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolveRequiredPlaceholders(\"Replace this ${key}\")).isEqualTo(\"Replace this value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveRequiredPlaceholders_withUnresolvable()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveRequiredPlaceholders_withUnresolvable() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> resolver.resolveRequiredPlaceholders(\"Replace this ${key} plus ${unknown}\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveRequiredPlaceholders_withDefaultValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveRequiredPlaceholders_withDefaultValue() {\r\n    MutablePropertySources propertySources = new MutablePropertySources();\r\n    propertySources.addFirst(new MockPropertySource().withProperty(\"key\", \"value\"));\r\n    PropertyResolver resolver = new PropertySourcesPropertyResolver(propertySources);\r\n    assertThat(resolver.resolveRequiredPlaceholders(\"Replace this ${key} plus ${unknown:defaultValue}\")).isEqualTo(\"Replace this value plus defaultValue\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveRequiredPlaceholders_withNullInput()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveRequiredPlaceholders_withNullInput() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new PropertySourcesPropertyResolver(new MutablePropertySources()).resolveRequiredPlaceholders(null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#setRequiredProperties_andValidateRequiredProperties()",
    "entityType": "method",
    "code": "@Test\r\nvoid setRequiredProperties_andValidateRequiredProperties() {\r\n    // no properties have been marked as required -> validation should pass\r\n    propertyResolver.validateRequiredProperties();\r\n    // mark which properties are required\r\n    propertyResolver.setRequiredProperties(\"foo\", \"bar\");\r\n    // neither foo nor bar properties are present -> validating should throw\r\n    assertThatExceptionOfType(MissingRequiredPropertiesException.class).isThrownBy(propertyResolver::validateRequiredProperties).withMessage(\"The following properties were declared as required \" + \"but could not be resolved: [foo, bar]\");\r\n    // add foo property -> validation should fail only on missing 'bar' property\r\n    testProperties.put(\"foo\", \"fooValue\");\r\n    assertThatExceptionOfType(MissingRequiredPropertiesException.class).isThrownBy(propertyResolver::validateRequiredProperties).withMessage(\"The following properties were declared as required \" + \"but could not be resolved: [bar]\");\r\n    // add bar property -> validation should pass, even with an empty string value\r\n    testProperties.put(\"bar\", \"\");\r\n    propertyResolver.validateRequiredProperties();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPropertyPlaceholders()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveNestedPropertyPlaceholders() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", // nested placeholders\r\n    \"${p1}:${p2}\").withProperty(\"p4\", // deeply nested placeholders\r\n    \"${p3}\").withProperty(\"p5\", // unresolvable placeholder\r\n    \"${p1}:${p2}:${bogus}\").withProperty(\"p6\", // unresolvable w/ default\r\n    \"${p1}:${p2}:${bogus:def}\").withProperty(\"pL\", // cyclic reference left\r\n    \"${pR}\").withProperty(\"pR\", // cyclic reference right\r\n    \"${pL}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\r\n    assertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"p5\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n    assertThat(pr.getProperty(\"p6\")).isEqualTo(\"v1:v2:def\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"pL\")).withMessageContaining(\"Circular\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequence()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveNestedPlaceholdersIfValueIsCharSequence() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested()",
    "entityType": "method",
    "code": "@Test\r\nvoid resolveNestedPlaceholdersIfValueIsCharSequenceAndStringBuilderIsRequested() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", new StringBuilder(\"${p1}:${p2}\")));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p3\", StringBuilder.class)).isInstanceOf(StringBuilder.class).hasToString(\"${p1}:${p2}\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes()",
    "entityType": "method",
    "code": "// gh-33727\r\n@Test\r\nvoid resolveNestedPlaceHolderIfValueShouldConvertToOtherTypes() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"new.enabled\", \"${old.enabled:true}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"new.enabled\", Boolean.class, false)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourcesPropertyResolverTests#ignoreUnresolvableNestedPlaceholdersIsConfigurable()",
    "entityType": "method",
    "code": "@Test\r\nvoid ignoreUnresolvableNestedPlaceholdersIsConfigurable() {\r\n    MutablePropertySources ps = new MutablePropertySources();\r\n    ps.addFirst(new MockPropertySource().withProperty(\"p1\", \"v1\").withProperty(\"p2\", \"v2\").withProperty(\"p3\", // unresolvable w/ default\r\n    \"${p1}:${p2}:${bogus:def}\").withProperty(\"p4\", // unresolvable placeholder\r\n    \"${p1}:${p2}:${bogus}\"));\r\n    ConfigurablePropertyResolver pr = new PropertySourcesPropertyResolver(ps);\r\n    assertThat(pr.getProperty(\"p1\")).isEqualTo(\"v1\");\r\n    assertThat(pr.getProperty(\"p2\")).isEqualTo(\"v2\");\r\n    assertThat(pr.getProperty(\"p3\")).isEqualTo(\"v1:v2:def\");\r\n    // placeholders nested within the value of \"p4\" are unresolvable and cause an\r\n    // exception by default\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.getProperty(\"p4\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n    // relax the treatment of unresolvable nested placeholders\r\n    pr.setIgnoreUnresolvableNestedPlaceholders(true);\r\n    // and observe they now pass through unresolved\r\n    assertThat(pr.getProperty(\"p4\")).isEqualTo(\"v1:v2:${bogus}\");\r\n    // resolve[Nested]Placeholders methods behave as usual regardless the value of\r\n    // ignoreUnresolvableNestedPlaceholders\r\n    assertThat(pr.resolvePlaceholders(\"${p1}:${p2}:${bogus}\")).isEqualTo(\"v1:v2:${bogus}\");\r\n    assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(() -> pr.resolveRequiredPlaceholders(\"${p1}:${p2}:${bogus}\")).withMessageContaining(\"Could not resolve placeholder 'bogus' in value \\\"${p1}:${p2}:${bogus}\\\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.TestType",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourceTests",
    "entityType": "class",
    "code": "@Test\r\n@SuppressWarnings(\"serial\")\r\nvoid equals() {\r\n    Map<String, Object> map1 = Map.of(\"a\", \"b\");\r\n    Map<String, Object> map2 = Map.of(\"c\", \"d\");\r\n    Properties props1 = new Properties() {\r\n\r\n        {\r\n            setProperty(\"a\", \"b\");\r\n        }\r\n    };\r\n    Properties props2 = new Properties() {\r\n\r\n        {\r\n            setProperty(\"c\", \"d\");\r\n        }\r\n    };\r\n    MapPropertySource mps = new MapPropertySource(\"mps\", map1);\r\n    assertThat(mps).isEqualTo(mps);\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new Object());\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(\"x\");\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props2));\r\n}\n@Test\r\nvoid collectionsOperations() {\r\n    Map<String, Object> map1 = Map.of(\"a\", \"b\");\r\n    Map<String, Object> map2 = Map.of(\"c\", \"d\");\r\n    PropertySource<?> ps1 = new MapPropertySource(\"ps1\", map1);\r\n    ps1.getSource();\r\n    List<PropertySource<?>> propertySources = new ArrayList<>();\r\n    assertThat(propertySources.add(ps1)).isTrue();\r\n    assertThat(propertySources).contains(ps1);\r\n    assertThat(propertySources).contains(PropertySource.named(\"ps1\"));\r\n    // notice - different map\r\n    PropertySource<?> ps1replacement = new MapPropertySource(\"ps1\", map2);\r\n    // true because linkedlist allows duplicates\r\n    assertThat(propertySources.add(ps1replacement)).isTrue();\r\n    assertThat(propertySources).hasSize(2);\r\n    assertThat(propertySources.remove(PropertySource.named(\"ps1\"))).isTrue();\r\n    assertThat(propertySources).hasSize(1);\r\n    assertThat(propertySources.remove(PropertySource.named(\"ps1\"))).isTrue();\r\n    assertThat(propertySources).isEmpty();\r\n    PropertySource<?> ps2 = new MapPropertySource(\"ps2\", map2);\r\n    propertySources.add(ps1);\r\n    propertySources.add(ps2);\r\n    assertThat(propertySources.indexOf(PropertySource.named(\"ps1\"))).isEqualTo(0);\r\n    assertThat(propertySources.indexOf(PropertySource.named(\"ps2\"))).isEqualTo(1);\r\n    propertySources.clear();\r\n}",
    "comment": "\n * Tests for {@link PropertySource} implementations.\n *\n * @author Chris Beams\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.env.PropertySourceTests#equals()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"serial\")\r\nvoid equals() {\r\n    Map<String, Object> map1 = Map.of(\"a\", \"b\");\r\n    Map<String, Object> map2 = Map.of(\"c\", \"d\");\r\n    Properties props1 = new Properties() {\r\n\r\n        {\r\n            setProperty(\"a\", \"b\");\r\n        }\r\n    };\r\n    Properties props2 = new Properties() {\r\n\r\n        {\r\n            setProperty(\"c\", \"d\");\r\n        }\r\n    };\r\n    MapPropertySource mps = new MapPropertySource(\"mps\", map1);\r\n    assertThat(mps).isEqualTo(mps);\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new MapPropertySource(\"x\", map2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isEqualTo(new PropertiesPropertySource(\"x\", props2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new Object());\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(\"x\");\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new MapPropertySource(\"y\", map2));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props1));\r\n    assertThat(new MapPropertySource(\"x\", map1)).isNotEqualTo(new PropertiesPropertySource(\"y\", props2));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.PropertySourceTests#collectionsOperations()",
    "entityType": "method",
    "code": "@Test\r\nvoid collectionsOperations() {\r\n    Map<String, Object> map1 = Map.of(\"a\", \"b\");\r\n    Map<String, Object> map2 = Map.of(\"c\", \"d\");\r\n    PropertySource<?> ps1 = new MapPropertySource(\"ps1\", map1);\r\n    ps1.getSource();\r\n    List<PropertySource<?>> propertySources = new ArrayList<>();\r\n    assertThat(propertySources.add(ps1)).isTrue();\r\n    assertThat(propertySources).contains(ps1);\r\n    assertThat(propertySources).contains(PropertySource.named(\"ps1\"));\r\n    // notice - different map\r\n    PropertySource<?> ps1replacement = new MapPropertySource(\"ps1\", map2);\r\n    // true because linkedlist allows duplicates\r\n    assertThat(propertySources.add(ps1replacement)).isTrue();\r\n    assertThat(propertySources).hasSize(2);\r\n    assertThat(propertySources.remove(PropertySource.named(\"ps1\"))).isTrue();\r\n    assertThat(propertySources).hasSize(1);\r\n    assertThat(propertySources.remove(PropertySource.named(\"ps1\"))).isTrue();\r\n    assertThat(propertySources).isEmpty();\r\n    PropertySource<?> ps2 = new MapPropertySource(\"ps2\", map2);\r\n    propertySources.add(ps1);\r\n    propertySources.add(ps2);\r\n    assertThat(propertySources.indexOf(PropertySource.named(\"ps1\"))).isEqualTo(0);\r\n    assertThat(propertySources.indexOf(PropertySource.named(\"ps2\"))).isEqualTo(1);\r\n    propertySources.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests",
    "entityType": "class",
    "code": "private final SimpleCommandLineArgsParser parser = new SimpleCommandLineArgsParser();\n@Test\r\nvoid withNoOptions() {\r\n    assertThat(parser.parse().getOptionValues(\"foo\")).isNull();\r\n}\n@Test\r\nvoid withSingleOptionAndNoValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).isEmpty();\r\n}\n@Test\r\nvoid withSingleOptionAndValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n}\n@Test\r\nvoid withRepeatedOptionAndSameValues() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--o1=v1\", \"--o1=v1\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\", \"v1\", \"v1\");\r\n}\n@Test\r\nvoid withRepeatedOptionAndDifferentValues() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--o1=v2\", \"--o1=v3\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\", \"v2\", \"v3\");\r\n}\n@Test\r\nvoid withMixOfOptionsHavingValueAndOptionsHavingNoValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--o2\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.containsOption(\"o2\")).isTrue();\r\n    assertThat(args.containsOption(\"o3\")).isFalse();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n    assertThat(args.getOptionValues(\"o2\")).isEqualTo(Collections.EMPTY_LIST);\r\n    assertThat(args.getOptionValues(\"o3\")).isNull();\r\n}\n@Test\r\nvoid withEmptyOptionName() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> parser.parse(\"--=v1\"));\r\n}\n@Test\r\nvoid withEmptyOptionValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1=\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"\");\r\n}\n@Test\r\nvoid withEmptyOptionNameAndEmptyOptionValue() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> parser.parse(\"--=\"));\r\n}\n@Test\r\nvoid withNonOptionArguments() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"noa1\", \"--o2=v2\", \"noa2\");\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n    assertThat(args.getOptionValues(\"o2\")).containsExactly(\"v2\");\r\n    List<String> nonOptions = args.getNonOptionArgs();\r\n    assertThat(nonOptions).containsExactly(\"noa1\", \"noa2\");\r\n}\n@Test\r\nvoid optionNamesSetIsUnmodifiable() {\r\n    CommandLineArgs args = new SimpleCommandLineArgsParser().parse();\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> args.getOptionNames().add(\"bogus\"));\r\n}\n@Test\r\nvoid nonOptionArgsListIsUnmodifiable() {\r\n    CommandLineArgs args = new SimpleCommandLineArgsParser().parse();\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> args.getNonOptionArgs().add(\"foo\"));\r\n}\n@Test\r\nvoid supportsEndOfOptionsDelimiter() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--\", \"--o2=v2\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.containsOption(\"o2\")).isFalse();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n    assertThat(args.getNonOptionArgs()).contains(\"--o2=v2\");\r\n}",
    "comment": "\n * Tests for {@link SimpleCommandLineArgsParser}.\n *\n * @author Chris Beams\n * @author Sam Brannen\n * @author Brian Clozel\n "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withNoOptions()",
    "entityType": "method",
    "code": "@Test\r\nvoid withNoOptions() {\r\n    assertThat(parser.parse().getOptionValues(\"foo\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withSingleOptionAndNoValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid withSingleOptionAndNoValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withSingleOptionAndValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid withSingleOptionAndValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withRepeatedOptionAndSameValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid withRepeatedOptionAndSameValues() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--o1=v1\", \"--o1=v1\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\", \"v1\", \"v1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withRepeatedOptionAndDifferentValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid withRepeatedOptionAndDifferentValues() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--o1=v2\", \"--o1=v3\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\", \"v2\", \"v3\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withMixOfOptionsHavingValueAndOptionsHavingNoValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid withMixOfOptionsHavingValueAndOptionsHavingNoValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--o2\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.containsOption(\"o2\")).isTrue();\r\n    assertThat(args.containsOption(\"o3\")).isFalse();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n    assertThat(args.getOptionValues(\"o2\")).isEqualTo(Collections.EMPTY_LIST);\r\n    assertThat(args.getOptionValues(\"o3\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withEmptyOptionName()",
    "entityType": "method",
    "code": "@Test\r\nvoid withEmptyOptionName() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> parser.parse(\"--=v1\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withEmptyOptionValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid withEmptyOptionValue() {\r\n    CommandLineArgs args = parser.parse(\"--o1=\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withEmptyOptionNameAndEmptyOptionValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid withEmptyOptionNameAndEmptyOptionValue() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> parser.parse(\"--=\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#withNonOptionArguments()",
    "entityType": "method",
    "code": "@Test\r\nvoid withNonOptionArguments() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"noa1\", \"--o2=v2\", \"noa2\");\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n    assertThat(args.getOptionValues(\"o2\")).containsExactly(\"v2\");\r\n    List<String> nonOptions = args.getNonOptionArgs();\r\n    assertThat(nonOptions).containsExactly(\"noa1\", \"noa2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#optionNamesSetIsUnmodifiable()",
    "entityType": "method",
    "code": "@Test\r\nvoid optionNamesSetIsUnmodifiable() {\r\n    CommandLineArgs args = new SimpleCommandLineArgsParser().parse();\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> args.getOptionNames().add(\"bogus\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#nonOptionArgsListIsUnmodifiable()",
    "entityType": "method",
    "code": "@Test\r\nvoid nonOptionArgsListIsUnmodifiable() {\r\n    CommandLineArgs args = new SimpleCommandLineArgsParser().parse();\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> args.getNonOptionArgs().add(\"foo\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLineArgsParserTests#supportsEndOfOptionsDelimiter()",
    "entityType": "method",
    "code": "@Test\r\nvoid supportsEndOfOptionsDelimiter() {\r\n    CommandLineArgs args = parser.parse(\"--o1=v1\", \"--\", \"--o2=v2\");\r\n    assertThat(args.containsOption(\"o1\")).isTrue();\r\n    assertThat(args.containsOption(\"o2\")).isFalse();\r\n    assertThat(args.getOptionValues(\"o1\")).containsExactly(\"v1\");\r\n    assertThat(args.getNonOptionArgs()).contains(\"--o2=v2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests",
    "entityType": "class",
    "code": "@Test\r\nvoid withDefaultName() {\r\n    PropertySource<?> ps = new SimpleCommandLinePropertySource();\r\n    assertThat(ps.getName()).isEqualTo(CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME);\r\n}\n@Test\r\nvoid withCustomName() {\r\n    PropertySource<?> ps = new SimpleCommandLinePropertySource(\"ps1\", new String[0]);\r\n    assertThat(ps.getName()).isEqualTo(\"ps1\");\r\n}\n@Test\r\nvoid withNoArgs() {\r\n    PropertySource<?> ps = new SimpleCommandLinePropertySource();\r\n    assertThat(ps.containsProperty(\"foo\")).isFalse();\r\n    assertThat(ps.getProperty(\"foo\")).isNull();\r\n}\n@Test\r\nvoid withOptionArgsOnly() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"--o2\");\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o3\")).isFalse();\r\n    assertThat(ps.getProperty(\"o1\")).isEqualTo(\"v1\");\r\n    assertThat(ps.getProperty(\"o2\")).isEmpty();\r\n    assertThat(ps.getProperty(\"o3\")).isNull();\r\n}\n// gh-34282\r\n@Test\r\nvoid withRepeatedOptionArgs() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"--o1=v2\", \"--o1=v3\");\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isFalse();\r\n    assertThat(ps.getProperty(\"o1\")).isEqualTo(\"v1,v2,v3\");\r\n    assertThat(ps.getProperty(\"o2\")).isNull();\r\n}\n// gh-24464\r\n@Test\r\nvoid withOptionalArg_andArgIsEmpty() {\r\n    EnumerablePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--foo=\");\r\n    assertThat(ps.containsProperty(\"foo\")).isTrue();\r\n    assertThat(ps.getProperty(\"foo\")).isEqualTo(\"\");\r\n}\n@Test\r\nvoid withDefaultNonOptionArgsNameAndNoNonOptionArgsPresent() {\r\n    EnumerablePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"--o2\");\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isFalse();\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isFalse();\r\n    assertThat(ps.getProperty(\"nonOptionArgs\")).isNull();\r\n    assertThat(ps.getPropertyNames()).hasSize(2);\r\n}\n@Test\r\nvoid withDefaultNonOptionArgsNameAndNonOptionArgsPresent() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"noa1\", \"--o2\", \"noa2\");\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    String nonOptionArgs = ps.getProperty(\"nonOptionArgs\");\r\n    assertThat(nonOptionArgs).isEqualTo(\"noa1,noa2\");\r\n}\n@Test\r\nvoid withCustomNonOptionArgsNameAndNoNonOptionArgsPresent() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"noa1\", \"--o2\", \"noa2\");\r\n    ps.setNonOptionArgsPropertyName(\"NOA\");\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isFalse();\r\n    assertThat(ps.containsProperty(\"NOA\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    String nonOptionArgs = ps.getProperty(\"NOA\");\r\n    assertThat(nonOptionArgs).isEqualTo(\"noa1,noa2\");\r\n}\n@Test\r\nvoid covertNonOptionArgsToStringArrayAndList() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"noa1\", \"--o2\", \"noa2\");\r\n    StandardEnvironment env = new StandardEnvironment();\r\n    env.getPropertySources().addFirst(ps);\r\n    String nonOptionArgs = env.getProperty(\"nonOptionArgs\");\r\n    assertThat(nonOptionArgs).isEqualTo(\"noa1,noa2\");\r\n    String[] nonOptionArgsArray = env.getProperty(\"nonOptionArgs\", String[].class);\r\n    assertThat(nonOptionArgsArray[0]).isEqualTo(\"noa1\");\r\n    assertThat(nonOptionArgsArray[1]).isEqualTo(\"noa2\");\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<String> nonOptionArgsList = env.getProperty(\"nonOptionArgs\", List.class);\r\n    assertThat(nonOptionArgsList).containsExactly(\"noa1\", \"noa2\");\r\n}",
    "comment": "\n * Tests for {@link SimpleCommandLinePropertySource}.\n *\n * @author Chris Beams\n * @author Sam Brannen\n * @since 3.1\n "
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withDefaultName()",
    "entityType": "method",
    "code": "@Test\r\nvoid withDefaultName() {\r\n    PropertySource<?> ps = new SimpleCommandLinePropertySource();\r\n    assertThat(ps.getName()).isEqualTo(CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withCustomName()",
    "entityType": "method",
    "code": "@Test\r\nvoid withCustomName() {\r\n    PropertySource<?> ps = new SimpleCommandLinePropertySource(\"ps1\", new String[0]);\r\n    assertThat(ps.getName()).isEqualTo(\"ps1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withNoArgs()",
    "entityType": "method",
    "code": "@Test\r\nvoid withNoArgs() {\r\n    PropertySource<?> ps = new SimpleCommandLinePropertySource();\r\n    assertThat(ps.containsProperty(\"foo\")).isFalse();\r\n    assertThat(ps.getProperty(\"foo\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withOptionArgsOnly()",
    "entityType": "method",
    "code": "@Test\r\nvoid withOptionArgsOnly() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"--o2\");\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o3\")).isFalse();\r\n    assertThat(ps.getProperty(\"o1\")).isEqualTo(\"v1\");\r\n    assertThat(ps.getProperty(\"o2\")).isEmpty();\r\n    assertThat(ps.getProperty(\"o3\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withRepeatedOptionArgs()",
    "entityType": "method",
    "code": "// gh-34282\r\n@Test\r\nvoid withRepeatedOptionArgs() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"--o1=v2\", \"--o1=v3\");\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isFalse();\r\n    assertThat(ps.getProperty(\"o1\")).isEqualTo(\"v1,v2,v3\");\r\n    assertThat(ps.getProperty(\"o2\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withOptionalArg_andArgIsEmpty()",
    "entityType": "method",
    "code": "// gh-24464\r\n@Test\r\nvoid withOptionalArg_andArgIsEmpty() {\r\n    EnumerablePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--foo=\");\r\n    assertThat(ps.containsProperty(\"foo\")).isTrue();\r\n    assertThat(ps.getProperty(\"foo\")).isEqualTo(\"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withDefaultNonOptionArgsNameAndNoNonOptionArgsPresent()",
    "entityType": "method",
    "code": "@Test\r\nvoid withDefaultNonOptionArgsNameAndNoNonOptionArgsPresent() {\r\n    EnumerablePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"--o2\");\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isFalse();\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isFalse();\r\n    assertThat(ps.getProperty(\"nonOptionArgs\")).isNull();\r\n    assertThat(ps.getPropertyNames()).hasSize(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withDefaultNonOptionArgsNameAndNonOptionArgsPresent()",
    "entityType": "method",
    "code": "@Test\r\nvoid withDefaultNonOptionArgsNameAndNonOptionArgsPresent() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"noa1\", \"--o2\", \"noa2\");\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    String nonOptionArgs = ps.getProperty(\"nonOptionArgs\");\r\n    assertThat(nonOptionArgs).isEqualTo(\"noa1,noa2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#withCustomNonOptionArgsNameAndNoNonOptionArgsPresent()",
    "entityType": "method",
    "code": "@Test\r\nvoid withCustomNonOptionArgsNameAndNoNonOptionArgsPresent() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"noa1\", \"--o2\", \"noa2\");\r\n    ps.setNonOptionArgsPropertyName(\"NOA\");\r\n    assertThat(ps.containsProperty(\"nonOptionArgs\")).isFalse();\r\n    assertThat(ps.containsProperty(\"NOA\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o1\")).isTrue();\r\n    assertThat(ps.containsProperty(\"o2\")).isTrue();\r\n    String nonOptionArgs = ps.getProperty(\"NOA\");\r\n    assertThat(nonOptionArgs).isEqualTo(\"noa1,noa2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.SimpleCommandLinePropertySourceTests#covertNonOptionArgsToStringArrayAndList()",
    "entityType": "method",
    "code": "@Test\r\nvoid covertNonOptionArgsToStringArrayAndList() {\r\n    CommandLinePropertySource<?> ps = new SimpleCommandLinePropertySource(\"--o1=v1\", \"noa1\", \"--o2\", \"noa2\");\r\n    StandardEnvironment env = new StandardEnvironment();\r\n    env.getPropertySources().addFirst(ps);\r\n    String nonOptionArgs = env.getProperty(\"nonOptionArgs\");\r\n    assertThat(nonOptionArgs).isEqualTo(\"noa1,noa2\");\r\n    String[] nonOptionArgsArray = env.getProperty(\"nonOptionArgs\", String[].class);\r\n    assertThat(nonOptionArgsArray[0]).isEqualTo(\"noa1\");\r\n    assertThat(nonOptionArgsArray[1]).isEqualTo(\"noa2\");\r\n    @SuppressWarnings(\"unchecked\")\r\n    List<String> nonOptionArgsList = env.getProperty(\"nonOptionArgs\", List.class);\r\n    assertThat(nonOptionArgsList).containsExactly(\"noa1\", \"noa2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests",
    "entityType": "class",
    "code": "private static final String ALLOWED_PROPERTY_NAME = \"theanswer\";\nprivate static final String ALLOWED_PROPERTY_VALUE = \"42\";\nprivate static final String DISALLOWED_PROPERTY_NAME = \"verboten\";\nprivate static final String DISALLOWED_PROPERTY_VALUE = \"secret\";\nprivate static final String STRING_PROPERTY_NAME = \"stringPropName\";\nprivate static final String STRING_PROPERTY_VALUE = \"stringPropValue\";\nprivate static final Object NON_STRING_PROPERTY_NAME = new Object();\nprivate static final Object NON_STRING_PROPERTY_VALUE = new Object();\nprivate final ConfigurableEnvironment environment = new StandardEnvironment();\n@Test\r\nvoid merge() {\r\n    ConfigurableEnvironment child = new StandardEnvironment();\r\n    child.setActiveProfiles(\"c1\", \"c2\");\r\n    child.getPropertySources().addLast(new MockPropertySource(\"childMock\").withProperty(\"childKey\", \"childVal\").withProperty(\"bothKey\", \"childBothVal\"));\r\n    ConfigurableEnvironment parent = new StandardEnvironment();\r\n    parent.setActiveProfiles(\"p1\", \"p2\");\r\n    parent.getPropertySources().addLast(new MockPropertySource(\"parentMock\").withProperty(\"parentKey\", \"parentVal\").withProperty(\"bothKey\", \"parentBothVal\"));\r\n    assertThat(child.getProperty(\"childKey\")).isEqualTo(\"childVal\");\r\n    assertThat(child.getProperty(\"parentKey\")).isNull();\r\n    assertThat(child.getProperty(\"bothKey\")).isEqualTo(\"childBothVal\");\r\n    assertThat(parent.getProperty(\"childKey\")).isNull();\r\n    assertThat(parent.getProperty(\"parentKey\")).isEqualTo(\"parentVal\");\r\n    assertThat(parent.getProperty(\"bothKey\")).isEqualTo(\"parentBothVal\");\r\n    assertThat(child.getActiveProfiles()).containsExactly(\"c1\", \"c2\");\r\n    assertThat(parent.getActiveProfiles()).containsExactly(\"p1\", \"p2\");\r\n    child.merge(parent);\r\n    assertThat(child.getProperty(\"childKey\")).isEqualTo(\"childVal\");\r\n    assertThat(child.getProperty(\"parentKey\")).isEqualTo(\"parentVal\");\r\n    assertThat(child.getProperty(\"bothKey\")).isEqualTo(\"childBothVal\");\r\n    assertThat(parent.getProperty(\"childKey\")).isNull();\r\n    assertThat(parent.getProperty(\"parentKey\")).isEqualTo(\"parentVal\");\r\n    assertThat(parent.getProperty(\"bothKey\")).isEqualTo(\"parentBothVal\");\r\n    assertThat(child.getActiveProfiles()).containsExactly(\"c1\", \"c2\", \"p1\", \"p2\");\r\n    assertThat(parent.getActiveProfiles()).containsExactly(\"p1\", \"p2\");\r\n}\n@Test\r\nvoid propertySourceOrder() {\r\n    ConfigurableEnvironment env = new StandardEnvironment();\r\n    MutablePropertySources sources = env.getPropertySources();\r\n    assertThat(sources.precedenceOf(PropertySource.named(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME))).isEqualTo(0);\r\n    assertThat(sources.precedenceOf(PropertySource.named(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME))).isEqualTo(1);\r\n    assertThat(sources).hasSize(2);\r\n}\n@Test\r\nvoid propertySourceTypes() {\r\n    ConfigurableEnvironment env = new StandardEnvironment();\r\n    MutablePropertySources sources = env.getPropertySources();\r\n    assertThat(sources.get(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME)).isInstanceOf(SystemEnvironmentPropertySource.class);\r\n}\n@Test\r\nvoid activeProfilesIsEmptyByDefault() {\r\n    assertThat(environment.getActiveProfiles()).isEmpty();\r\n}\n@Test\r\nvoid defaultProfilesContainsDefaultProfileByDefault() {\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(\"default\");\r\n}\n@Test\r\nvoid setActiveProfiles() {\r\n    environment.setActiveProfiles(\"local\", \"embedded\");\r\n    String[] activeProfiles = environment.getActiveProfiles();\r\n    assertThat(activeProfiles).containsExactly(\"local\", \"embedded\");\r\n}\n@Test\r\nvoid setActiveProfiles_withNullProfileArray() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles((String[]) null));\r\n}\n@Test\r\nvoid setActiveProfiles_withNullProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles((String) null));\r\n}\n@Test\r\nvoid setActiveProfiles_withEmptyProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles(\"\"));\r\n}\n@Test\r\nvoid setActiveProfiles_withNotOperator() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles(\"p1\", \"!p2\"));\r\n}\n@Test\r\nvoid setDefaultProfiles_withNullProfileArray() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles((String[]) null));\r\n}\n@Test\r\nvoid setDefaultProfiles_withNullProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles((String) null));\r\n}\n@Test\r\nvoid setDefaultProfiles_withEmptyProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles(\"\"));\r\n}\n@Test\r\nvoid setDefaultProfiles_withNotOperator() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles(\"d1\", \"!d2\"));\r\n}\n@Test\r\nvoid addActiveProfile() {\r\n    assertThat(environment.getActiveProfiles()).isEmpty();\r\n    environment.setActiveProfiles(\"local\", \"embedded\");\r\n    assertThat(environment.getActiveProfiles()).containsExactly(\"local\", \"embedded\");\r\n    environment.addActiveProfile(\"p1\");\r\n    assertThat(environment.getActiveProfiles()).containsExactly(\"local\", \"embedded\", \"p1\");\r\n    environment.addActiveProfile(\"p2\");\r\n    environment.addActiveProfile(\"p3\");\r\n    assertThat(environment.getActiveProfiles()).containsExactly(\"local\", \"embedded\", \"p1\", \"p2\", \"p3\");\r\n}\n@Test\r\nvoid addActiveProfile_whenActiveProfilesPropertyIsAlreadySet() {\r\n    ConfigurableEnvironment env = new StandardEnvironment();\r\n    assertThat(env.getProperty(ACTIVE_PROFILES_PROPERTY_NAME)).isNull();\r\n    env.getPropertySources().addFirst(new MockPropertySource().withProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"p1\"));\r\n    assertThat(env.getProperty(ACTIVE_PROFILES_PROPERTY_NAME)).isEqualTo(\"p1\");\r\n    env.addActiveProfile(\"p2\");\r\n    assertThat(env.getActiveProfiles()).containsExactly(\"p1\", \"p2\");\r\n}\n@Test\r\nvoid reservedDefaultProfile() {\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(RESERVED_DEFAULT_PROFILE_NAME);\r\n    try {\r\n        System.setProperty(DEFAULT_PROFILES_PROPERTY_NAME, \"d0\");\r\n        assertThat(environment.getDefaultProfiles()).containsExactly(\"d0\");\r\n        environment.setDefaultProfiles(\"d1\", \"d2\");\r\n        assertThat(environment.getDefaultProfiles()).containsExactly(\"d1\", \"d2\");\r\n    } finally {\r\n        System.clearProperty(DEFAULT_PROFILES_PROPERTY_NAME);\r\n    }\r\n}\n@Test\r\nvoid defaultProfileWithCircularPlaceholder() {\r\n    try {\r\n        System.setProperty(DEFAULT_PROFILES_PROPERTY_NAME, \"${spring.profiles.default}\");\r\n        assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(environment::getDefaultProfiles).withMessageContaining(\"Circular placeholder reference 'spring.profiles.default'\");\r\n    } finally {\r\n        System.clearProperty(DEFAULT_PROFILES_PROPERTY_NAME);\r\n    }\r\n}\n@Test\r\nvoid getDefaultProfiles() {\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(RESERVED_DEFAULT_PROFILE_NAME);\r\n    environment.getPropertySources().addFirst(new MockPropertySource().withProperty(DEFAULT_PROFILES_PROPERTY_NAME, \"pd1\"));\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(\"pd1\");\r\n}\n@Test\r\nvoid setDefaultProfiles() {\r\n    environment.setDefaultProfiles();\r\n    assertThat(environment.getDefaultProfiles()).isEmpty();\r\n    environment.setDefaultProfiles(\"pd1\");\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(\"pd1\");\r\n    environment.setDefaultProfiles(\"pd2\", \"pd3\");\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(\"pd2\", \"pd3\");\r\n}\n@Test\r\nvoid environmentSubclass_withCustomProfileValidation() {\r\n    ConfigurableEnvironment env = new AbstractEnvironment() {\r\n\r\n        @Override\r\n        protected void validateProfile(String profile) {\r\n            super.validateProfile(profile);\r\n            if (profile.contains(\"-\")) {\r\n                throw new IllegalArgumentException(\"Invalid profile [\" + profile + \"]: must not contain dash character\");\r\n            }\r\n        }\r\n    };\r\n    // succeeds\r\n    env.addActiveProfile(\"validProfile\");\r\n    assertThatIllegalArgumentException().isThrownBy(() -> env.addActiveProfile(\"invalid-profile\")).withMessage(\"Invalid profile [invalid-profile]: must not contain dash character\");\r\n}\n@Test\r\nvoid suppressGetenvAccessThroughSystemProperty() {\r\n    try {\r\n        System.setProperty(\"spring.getenv.ignore\", \"true\");\r\n        assertThat(environment.getSystemEnvironment()).isEmpty();\r\n    } finally {\r\n        System.clearProperty(\"spring.getenv.ignore\");\r\n    }\r\n}\n@Test\r\nvoid suppressGetenvAccessThroughSpringProperty() {\r\n    try {\r\n        SpringProperties.setProperty(\"spring.getenv.ignore\", \"true\");\r\n        assertThat(environment.getSystemEnvironment()).isEmpty();\r\n    } finally {\r\n        SpringProperties.setProperty(\"spring.getenv.ignore\", null);\r\n    }\r\n}\n@Test\r\nvoid suppressGetenvAccessThroughSpringFlag() {\r\n    try {\r\n        SpringProperties.setFlag(\"spring.getenv.ignore\");\r\n        assertThat(environment.getSystemEnvironment()).isEmpty();\r\n    } finally {\r\n        SpringProperties.setProperty(\"spring.getenv.ignore\", null);\r\n    }\r\n}\n@Test\r\nvoid getSystemProperties() {\r\n    try {\r\n        System.setProperty(ALLOWED_PROPERTY_NAME, ALLOWED_PROPERTY_VALUE);\r\n        System.setProperty(DISALLOWED_PROPERTY_NAME, DISALLOWED_PROPERTY_VALUE);\r\n        System.getProperties().put(STRING_PROPERTY_NAME, NON_STRING_PROPERTY_VALUE);\r\n        System.getProperties().put(NON_STRING_PROPERTY_NAME, STRING_PROPERTY_VALUE);\r\n        Map<?, ?> systemProperties = environment.getSystemProperties();\r\n        assertThat(systemProperties).isNotNull();\r\n        assertThat(System.getProperties()).isSameAs(systemProperties);\r\n        assertThat(systemProperties.get(ALLOWED_PROPERTY_NAME)).isEqualTo(ALLOWED_PROPERTY_VALUE);\r\n        assertThat(systemProperties.get(DISALLOWED_PROPERTY_NAME)).isEqualTo(DISALLOWED_PROPERTY_VALUE);\r\n        assertThat(systemProperties.get(STRING_PROPERTY_NAME)).isEqualTo(NON_STRING_PROPERTY_VALUE);\r\n        assertThat(systemProperties.get(NON_STRING_PROPERTY_NAME)).isEqualTo(STRING_PROPERTY_VALUE);\r\n        PropertiesPropertySource systemPropertySource = (PropertiesPropertySource) environment.getPropertySources().get(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME);\r\n        Set<String> expectedKeys = new HashSet<>(System.getProperties().stringPropertyNames());\r\n        // filtered out by stringPropertyNames due to non-String value\r\n        expectedKeys.add(STRING_PROPERTY_NAME);\r\n        assertThat(Set.of(systemPropertySource.getPropertyNames())).isEqualTo(expectedKeys);\r\n    } finally {\r\n        System.clearProperty(ALLOWED_PROPERTY_NAME);\r\n        System.clearProperty(DISALLOWED_PROPERTY_NAME);\r\n        System.getProperties().remove(STRING_PROPERTY_NAME);\r\n        System.getProperties().remove(NON_STRING_PROPERTY_NAME);\r\n    }\r\n}\n@Test\r\nvoid getSystemEnvironment() {\r\n    Map<String, Object> systemEnvironment = environment.getSystemEnvironment();\r\n    assertThat(systemEnvironment).isNotNull();\r\n    assertThat(System.getenv()).isSameAs(systemEnvironment);\r\n}\n@Nested\r\nclass GetActiveProfiles {\r\n\r\n    @Test\r\n    void systemPropertiesEmpty() {\r\n        assertThat(environment.getActiveProfiles()).isEmpty();\r\n        try {\r\n            System.setProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"\");\r\n            assertThat(environment.getActiveProfiles()).isEmpty();\r\n        } finally {\r\n            System.clearProperty(ACTIVE_PROFILES_PROPERTY_NAME);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void fromSystemProperties() {\r\n        try {\r\n            System.setProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"foo\");\r\n            assertThat(environment.getActiveProfiles()).containsExactly(\"foo\");\r\n        } finally {\r\n            System.clearProperty(ACTIVE_PROFILES_PROPERTY_NAME);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void fromSystemProperties_withMultipleProfiles() {\r\n        try {\r\n            System.setProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"foo,bar\");\r\n            assertThat(environment.getActiveProfiles()).containsExactly(\"foo\", \"bar\");\r\n        } finally {\r\n            System.clearProperty(ACTIVE_PROFILES_PROPERTY_NAME);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void fromSystemProperties_withMultipleProfiles_withWhitespace() {\r\n        try {\r\n            // notice whitespace\r\n            System.setProperty(ACTIVE_PROFILES_PROPERTY_NAME, \" bar , baz \");\r\n            assertThat(environment.getActiveProfiles()).containsExactly(\"bar\", \"baz\");\r\n        } finally {\r\n            System.clearProperty(ACTIVE_PROFILES_PROPERTY_NAME);\r\n        }\r\n    }\r\n}\n@Nested\r\nclass AcceptsProfilesTests {\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void withEmptyArgumentList() {\r\n        assertThatIllegalArgumentException().isThrownBy(environment::acceptsProfiles);\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void withNullArgumentList() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.acceptsProfiles((String[]) null));\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void withNullArgument() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.acceptsProfiles((String) null));\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void withEmptyArgument() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.acceptsProfiles(\"\"));\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void activeProfileSetProgrammatically() {\r\n        assertThat(environment.acceptsProfiles(\"p1\", \"p2\")).isFalse();\r\n        environment.setActiveProfiles(\"p1\");\r\n        assertThat(environment.acceptsProfiles(\"p1\", \"p2\")).isTrue();\r\n        environment.setActiveProfiles(\"p2\");\r\n        assertThat(environment.acceptsProfiles(\"p1\", \"p2\")).isTrue();\r\n        environment.setActiveProfiles(\"p1\", \"p2\");\r\n        assertThat(environment.acceptsProfiles(\"p1\", \"p2\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void activeProfileSetViaProperty() {\r\n        assertThat(environment.acceptsProfiles(\"p1\")).isFalse();\r\n        environment.getPropertySources().addFirst(new MockPropertySource().withProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"p1\"));\r\n        assertThat(environment.acceptsProfiles(\"p1\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void defaultProfile() {\r\n        assertThat(environment.acceptsProfiles(\"pd\")).isFalse();\r\n        environment.setDefaultProfiles(\"pd\");\r\n        assertThat(environment.acceptsProfiles(\"pd\")).isTrue();\r\n        environment.setActiveProfiles(\"p1\");\r\n        assertThat(environment.acceptsProfiles(\"pd\")).isFalse();\r\n        assertThat(environment.acceptsProfiles(\"p1\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void withNotOperator() {\r\n        assertThat(environment.acceptsProfiles(\"p1\")).isFalse();\r\n        assertThat(environment.acceptsProfiles(\"!p1\")).isTrue();\r\n        environment.addActiveProfile(\"p1\");\r\n        assertThat(environment.acceptsProfiles(\"p1\")).isTrue();\r\n        assertThat(environment.acceptsProfiles(\"!p1\")).isFalse();\r\n    }\r\n\r\n    @Test\r\n    @SuppressWarnings(\"deprecation\")\r\n    void withInvalidNotOperator() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.acceptsProfiles(\"p1\", \"!\"));\r\n    }\r\n\r\n    @Test\r\n    void withProfileExpression() {\r\n        assertThat(environment.acceptsProfiles(Profiles.of(\"p1 & p2\"))).isFalse();\r\n        environment.addActiveProfile(\"p1\");\r\n        assertThat(environment.acceptsProfiles(Profiles.of(\"p1 & p2\"))).isFalse();\r\n        environment.addActiveProfile(\"p2\");\r\n        assertThat(environment.acceptsProfiles(Profiles.of(\"p1 & p2\"))).isTrue();\r\n    }\r\n}\n@Nested\r\nclass MatchesProfilesTests {\r\n\r\n    @Test\r\n    void withEmptyArgumentList() {\r\n        assertThatIllegalArgumentException().isThrownBy(environment::matchesProfiles);\r\n    }\r\n\r\n    @Test\r\n    void withNullArgumentList() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles((String[]) null));\r\n    }\r\n\r\n    @Test\r\n    void withNullArgument() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles((String) null));\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1\", null));\r\n    }\r\n\r\n    @Test\r\n    void withEmptyArgument() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"\"));\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1\", \"\"));\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1\", \"      \"));\r\n    }\r\n\r\n    @Test\r\n    void withInvalidNotOperator() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1\", \"!\"));\r\n    }\r\n\r\n    @Test\r\n    void withInvalidCompoundExpressionGrouping() {\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1 | p2 & p3\"));\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1 & p2 | p3\"));\r\n        assertThatIllegalArgumentException().isThrownBy(() -> environment.matchesProfiles(\"p1 & (p2 | p3) | p4\"));\r\n    }\r\n\r\n    @Test\r\n    void activeProfileSetProgrammatically() {\r\n        assertThat(environment.matchesProfiles(\"p1\", \"p2\")).isFalse();\r\n        environment.setActiveProfiles(\"p1\");\r\n        assertThat(environment.matchesProfiles(\"p1\", \"p2\")).isTrue();\r\n        environment.setActiveProfiles(\"p2\");\r\n        assertThat(environment.matchesProfiles(\"p1\", \"p2\")).isTrue();\r\n        environment.setActiveProfiles(\"p1\", \"p2\");\r\n        assertThat(environment.matchesProfiles(\"p1\", \"p2\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    void activeProfileSetViaProperty() {\r\n        assertThat(environment.matchesProfiles(\"p1\")).isFalse();\r\n        environment.getPropertySources().addFirst(new MockPropertySource().withProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"p1\"));\r\n        assertThat(environment.matchesProfiles(\"p1\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    void defaultProfile() {\r\n        assertThat(environment.matchesProfiles(\"pd\")).isFalse();\r\n        environment.setDefaultProfiles(\"pd\");\r\n        assertThat(environment.matchesProfiles(\"pd\")).isTrue();\r\n        environment.setActiveProfiles(\"p1\");\r\n        assertThat(environment.matchesProfiles(\"pd\")).isFalse();\r\n        assertThat(environment.matchesProfiles(\"p1\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    void withNotOperator() {\r\n        assertThat(environment.matchesProfiles(\"p1\")).isFalse();\r\n        assertThat(environment.matchesProfiles(\"!p1\")).isTrue();\r\n        environment.addActiveProfile(\"p1\");\r\n        assertThat(environment.matchesProfiles(\"p1\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"!p1\")).isFalse();\r\n    }\r\n\r\n    @Test\r\n    void withProfileExpressions() {\r\n        assertThat(environment.matchesProfiles(\"p1 & p2\")).isFalse();\r\n        environment.addActiveProfile(\"p1\");\r\n        assertThat(environment.matchesProfiles(\"p1 | p2\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"p1 & p2\")).isFalse();\r\n        environment.addActiveProfile(\"p2\");\r\n        assertThat(environment.matchesProfiles(\"p1 & p2\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"p1 | p2\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"foo | p1\", \"p2\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"foo | p2\", \"p1\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"foo | (p2 & p1)\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"p2 & (foo | p1)\")).isTrue();\r\n        assertThat(environment.matchesProfiles(\"foo\", \"(p2 & p1)\")).isTrue();\r\n    }\r\n}",
    "comment": "\n * Tests for {@link StandardEnvironment}.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#merge()",
    "entityType": "method",
    "code": "@Test\r\nvoid merge() {\r\n    ConfigurableEnvironment child = new StandardEnvironment();\r\n    child.setActiveProfiles(\"c1\", \"c2\");\r\n    child.getPropertySources().addLast(new MockPropertySource(\"childMock\").withProperty(\"childKey\", \"childVal\").withProperty(\"bothKey\", \"childBothVal\"));\r\n    ConfigurableEnvironment parent = new StandardEnvironment();\r\n    parent.setActiveProfiles(\"p1\", \"p2\");\r\n    parent.getPropertySources().addLast(new MockPropertySource(\"parentMock\").withProperty(\"parentKey\", \"parentVal\").withProperty(\"bothKey\", \"parentBothVal\"));\r\n    assertThat(child.getProperty(\"childKey\")).isEqualTo(\"childVal\");\r\n    assertThat(child.getProperty(\"parentKey\")).isNull();\r\n    assertThat(child.getProperty(\"bothKey\")).isEqualTo(\"childBothVal\");\r\n    assertThat(parent.getProperty(\"childKey\")).isNull();\r\n    assertThat(parent.getProperty(\"parentKey\")).isEqualTo(\"parentVal\");\r\n    assertThat(parent.getProperty(\"bothKey\")).isEqualTo(\"parentBothVal\");\r\n    assertThat(child.getActiveProfiles()).containsExactly(\"c1\", \"c2\");\r\n    assertThat(parent.getActiveProfiles()).containsExactly(\"p1\", \"p2\");\r\n    child.merge(parent);\r\n    assertThat(child.getProperty(\"childKey\")).isEqualTo(\"childVal\");\r\n    assertThat(child.getProperty(\"parentKey\")).isEqualTo(\"parentVal\");\r\n    assertThat(child.getProperty(\"bothKey\")).isEqualTo(\"childBothVal\");\r\n    assertThat(parent.getProperty(\"childKey\")).isNull();\r\n    assertThat(parent.getProperty(\"parentKey\")).isEqualTo(\"parentVal\");\r\n    assertThat(parent.getProperty(\"bothKey\")).isEqualTo(\"parentBothVal\");\r\n    assertThat(child.getActiveProfiles()).containsExactly(\"c1\", \"c2\", \"p1\", \"p2\");\r\n    assertThat(parent.getActiveProfiles()).containsExactly(\"p1\", \"p2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#propertySourceOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertySourceOrder() {\r\n    ConfigurableEnvironment env = new StandardEnvironment();\r\n    MutablePropertySources sources = env.getPropertySources();\r\n    assertThat(sources.precedenceOf(PropertySource.named(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME))).isEqualTo(0);\r\n    assertThat(sources.precedenceOf(PropertySource.named(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME))).isEqualTo(1);\r\n    assertThat(sources).hasSize(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#propertySourceTypes()",
    "entityType": "method",
    "code": "@Test\r\nvoid propertySourceTypes() {\r\n    ConfigurableEnvironment env = new StandardEnvironment();\r\n    MutablePropertySources sources = env.getPropertySources();\r\n    assertThat(sources.get(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME)).isInstanceOf(SystemEnvironmentPropertySource.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#activeProfilesIsEmptyByDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid activeProfilesIsEmptyByDefault() {\r\n    assertThat(environment.getActiveProfiles()).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#defaultProfilesContainsDefaultProfileByDefault()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultProfilesContainsDefaultProfileByDefault() {\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(\"default\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setActiveProfiles()",
    "entityType": "method",
    "code": "@Test\r\nvoid setActiveProfiles() {\r\n    environment.setActiveProfiles(\"local\", \"embedded\");\r\n    String[] activeProfiles = environment.getActiveProfiles();\r\n    assertThat(activeProfiles).containsExactly(\"local\", \"embedded\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setActiveProfiles_withNullProfileArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid setActiveProfiles_withNullProfileArray() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles((String[]) null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setActiveProfiles_withNullProfile()",
    "entityType": "method",
    "code": "@Test\r\nvoid setActiveProfiles_withNullProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles((String) null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setActiveProfiles_withEmptyProfile()",
    "entityType": "method",
    "code": "@Test\r\nvoid setActiveProfiles_withEmptyProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles(\"\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setActiveProfiles_withNotOperator()",
    "entityType": "method",
    "code": "@Test\r\nvoid setActiveProfiles_withNotOperator() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setActiveProfiles(\"p1\", \"!p2\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setDefaultProfiles_withNullProfileArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid setDefaultProfiles_withNullProfileArray() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles((String[]) null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setDefaultProfiles_withNullProfile()",
    "entityType": "method",
    "code": "@Test\r\nvoid setDefaultProfiles_withNullProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles((String) null));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setDefaultProfiles_withEmptyProfile()",
    "entityType": "method",
    "code": "@Test\r\nvoid setDefaultProfiles_withEmptyProfile() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles(\"\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#setDefaultProfiles_withNotOperator()",
    "entityType": "method",
    "code": "@Test\r\nvoid setDefaultProfiles_withNotOperator() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> environment.setDefaultProfiles(\"d1\", \"!d2\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#addActiveProfile()",
    "entityType": "method",
    "code": "@Test\r\nvoid addActiveProfile() {\r\n    assertThat(environment.getActiveProfiles()).isEmpty();\r\n    environment.setActiveProfiles(\"local\", \"embedded\");\r\n    assertThat(environment.getActiveProfiles()).containsExactly(\"local\", \"embedded\");\r\n    environment.addActiveProfile(\"p1\");\r\n    assertThat(environment.getActiveProfiles()).containsExactly(\"local\", \"embedded\", \"p1\");\r\n    environment.addActiveProfile(\"p2\");\r\n    environment.addActiveProfile(\"p3\");\r\n    assertThat(environment.getActiveProfiles()).containsExactly(\"local\", \"embedded\", \"p1\", \"p2\", \"p3\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#addActiveProfile_whenActiveProfilesPropertyIsAlreadySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid addActiveProfile_whenActiveProfilesPropertyIsAlreadySet() {\r\n    ConfigurableEnvironment env = new StandardEnvironment();\r\n    assertThat(env.getProperty(ACTIVE_PROFILES_PROPERTY_NAME)).isNull();\r\n    env.getPropertySources().addFirst(new MockPropertySource().withProperty(ACTIVE_PROFILES_PROPERTY_NAME, \"p1\"));\r\n    assertThat(env.getProperty(ACTIVE_PROFILES_PROPERTY_NAME)).isEqualTo(\"p1\");\r\n    env.addActiveProfile(\"p2\");\r\n    assertThat(env.getActiveProfiles()).containsExactly(\"p1\", \"p2\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#reservedDefaultProfile()",
    "entityType": "method",
    "code": "@Test\r\nvoid reservedDefaultProfile() {\r\n    assertThat(environment.getDefaultProfiles()).containsExactly(RESERVED_DEFAULT_PROFILE_NAME);\r\n    try {\r\n        System.setProperty(DEFAULT_PROFILES_PROPERTY_NAME, \"d0\");\r\n        assertThat(environment.getDefaultProfiles()).containsExactly(\"d0\");\r\n        environment.setDefaultProfiles(\"d1\", \"d2\");\r\n        assertThat(environment.getDefaultProfiles()).containsExactly(\"d1\", \"d2\");\r\n    } finally {\r\n        System.clearProperty(DEFAULT_PROFILES_PROPERTY_NAME);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.env.StandardEnvironmentTests#defaultProfileWithCircularPlaceholder()",
    "entityType": "method",
    "code": "@Test\r\nvoid defaultProfileWithCircularPlaceholder() {\r\n    try {\r\n        System.setProperty(DEFAULT_PROFILES_PROPERTY_NAME, \"${spring.profiles.default}\");\r\n        assertThatExceptionOfType(PlaceholderResolutionException.class).isThrownBy(environment::getDefaultProfiles).withMessageContaining(\"Circular placeholder reference 'spring.profiles.default'\");\r\n    } finally {\r\n        System.clearProperty(DEFAULT_PROFILES_PROPERTY_NAME);\r\n    }\r\n}",
    "comment": ""
  }
]