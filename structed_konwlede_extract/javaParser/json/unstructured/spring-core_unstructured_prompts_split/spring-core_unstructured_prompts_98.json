[
  {
    "entityId": "org.springframework.aot.nativex.SerializationHintsTests#shouldWriteEmptyHint()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteEmptyHint() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.SerializationHintsTests#shouldWriteSingleHint()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteSingleHint() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.serialization().registerType(TypeReference.of(String.class));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"type\": \"java.lang.String\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.SerializationHintsTests#shouldWriteMultipleHints()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteMultipleHints() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.serialization().registerType(TypeReference.of(Environment.class)).registerType(TypeReference.of(String.class));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"type\": \"java.lang.String\" },\r\n        \t\t{ \"type\": \"org.springframework.core.env.Environment\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.SerializationHintsTests#shouldWriteSingleHintWithCondition()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteSingleHintWithCondition() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.serialization().registerType(TypeReference.of(String.class), builder -> builder.onReachableType(TypeReference.of(\"org.example.Test\")));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"serialization\": [\r\n        \t\t{ \"condition\": { \"typeReached\": \"org.example.Test\" }, \"type\": \"java.lang.String\" }\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}\n@Test\r\nvoid shouldWriteOneEntry() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(Function.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": {\r\n        \t\t\t\t\"proxy\": [\"java.util.function.Function\"]\r\n        \t\t\t}\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid shouldWriteMultipleEntries() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(Function.class).registerJdkProxy(Function.class, Consumer.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\", \"java.util.function.Consumer\"] }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid shouldWriteEntriesInNaturalOrder() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(Supplier.class).registerJdkProxy(Function.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Supplier\"] }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid shouldWriteInnerClass() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(InnerInterface.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerInterface\"] }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}\n@Test\r\nvoid shouldWriteCondition() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(builder -> builder.proxiedInterfaces(Function.class).onReachableType(TypeReference.of(\"org.example.Test\")));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] },\r\n        \t\t\t\"condition\": { \"typeReached\": \"org.example.Test\" }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests#empty()",
    "entityType": "method",
    "code": "@Test\r\nvoid empty() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    assertEquals(\";\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests#shouldWriteOneEntry()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteOneEntry() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(Function.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": {\r\n        \t\t\t\t\"proxy\": [\"java.util.function.Function\"]\r\n        \t\t\t}\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests#shouldWriteMultipleEntries()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteMultipleEntries() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(Function.class).registerJdkProxy(Function.class, Consumer.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\", \"java.util.function.Consumer\"] }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests#shouldWriteEntriesInNaturalOrder()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteEntriesInNaturalOrder() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(Supplier.class).registerJdkProxy(Function.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] }\r\n        \t\t},\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Supplier\"] }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests#shouldWriteInnerClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteInnerClass() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(InnerInterface.class);\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"org.springframework.aot.nativex.RuntimeHintsWriterTests$InnerInterface\"] }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.ProxyHintsTests#shouldWriteCondition()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldWriteCondition() throws JSONException {\r\n    RuntimeHints hints = new RuntimeHints();\r\n    hints.proxies().registerJdkProxy(builder -> builder.proxiedInterfaces(Function.class).onReachableType(TypeReference.of(\"org.example.Test\")));\r\n    assertEquals(\"\"\"\r\n        {\r\n        \t\"reflection\": [\r\n        \t\t{\r\n        \t\t\t\"type\": { \"proxy\": [\"java.util.function.Function\"] },\r\n        \t\t\t\"condition\": { \"typeReached\": \"org.example.Test\" }\r\n        \t\t}\r\n        \t]\r\n        }\r\n        \"\"\", hints);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.InnerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.nativex.InnerInterface",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests",
    "entityType": "class",
    "code": "private final Set<String> reservedClassNames = new HashSet<>();\n@Test\r\nvoid nullPrefix() {\r\n    assertThat(getClassName(null)).isEqualTo(\"org.springframework.cglib.empty.Object$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(null)).isEqualTo(\"org.springframework.cglib.empty.Object$$SpringCGLIB$$1\");\r\n}\n@Test\r\nvoid javaPrefix() {\r\n    assertThat(getClassName(\"java.util.ArrayList\")).isEqualTo(\"_java.util.ArrayList$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(\"java.util.ArrayList\")).isEqualTo(\"_java.util.ArrayList$$SpringCGLIB$$1\");\r\n}\n@Test\r\nvoid javaxPrefix() {\r\n    assertThat(getClassName(\"javax.sql.RowSet\")).isEqualTo(\"_javax.sql.RowSet$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(\"javax.sql.RowSet\")).isEqualTo(\"_javax.sql.RowSet$$SpringCGLIB$$1\");\r\n}\n@Test\r\nvoid examplePrefix() {\r\n    assertThat(getClassName(\"example.MyComponent\")).isEqualTo(\"example.MyComponent$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(\"example.MyComponent\")).isEqualTo(\"example.MyComponent$$SpringCGLIB$$1\");\r\n}\n@Test\r\nvoid prefixContainingSpringLabel() {\r\n    String generated1 = \"example.MyComponent$$SpringCGLIB$$0\";\r\n    String generated2 = \"example.MyComponent$$SpringCGLIB$$1\";\r\n    assertThat(getClassName(generated1)).isEqualTo(generated1);\r\n    assertThat(getClassName(generated1)).isEqualTo(generated2);\r\n}\n@Test\r\nvoid fastClass() {\r\n    String prefix = \"example.MyComponent\";\r\n    String source = FastClass.class.getName();\r\n    assertThat(getClassName(prefix, \"a.b.c\", null)).isEqualTo(\"example.MyComponent$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(prefix, source, null)).isEqualTo(\"example.MyComponent$$SpringCGLIB$$FastClass$$0\");\r\n    assertThat(getClassName(prefix, source, null)).isEqualTo(\"example.MyComponent$$SpringCGLIB$$FastClass$$1\");\r\n}\nprivate String getClassName(String prefix) {\r\n    return getClassName(prefix, null, null);\r\n}\nprivate String getClassName(String prefix, String source, Object key) {\r\n    String className = SpringNamingPolicy.INSTANCE.getClassName(prefix, source, key, reservedClassNames::contains);\r\n    reservedClassNames.add(className);\r\n    return className;\r\n}",
    "comment": "\n * Tests for {@link SpringNamingPolicy}.\n *\n * @author Sam Brannen\n * @since 6.0.13\n "
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#nullPrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullPrefix() {\r\n    assertThat(getClassName(null)).isEqualTo(\"org.springframework.cglib.empty.Object$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(null)).isEqualTo(\"org.springframework.cglib.empty.Object$$SpringCGLIB$$1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#javaPrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaPrefix() {\r\n    assertThat(getClassName(\"java.util.ArrayList\")).isEqualTo(\"_java.util.ArrayList$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(\"java.util.ArrayList\")).isEqualTo(\"_java.util.ArrayList$$SpringCGLIB$$1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#javaxPrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaxPrefix() {\r\n    assertThat(getClassName(\"javax.sql.RowSet\")).isEqualTo(\"_javax.sql.RowSet$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(\"javax.sql.RowSet\")).isEqualTo(\"_javax.sql.RowSet$$SpringCGLIB$$1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#examplePrefix()",
    "entityType": "method",
    "code": "@Test\r\nvoid examplePrefix() {\r\n    assertThat(getClassName(\"example.MyComponent\")).isEqualTo(\"example.MyComponent$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(\"example.MyComponent\")).isEqualTo(\"example.MyComponent$$SpringCGLIB$$1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#prefixContainingSpringLabel()",
    "entityType": "method",
    "code": "@Test\r\nvoid prefixContainingSpringLabel() {\r\n    String generated1 = \"example.MyComponent$$SpringCGLIB$$0\";\r\n    String generated2 = \"example.MyComponent$$SpringCGLIB$$1\";\r\n    assertThat(getClassName(generated1)).isEqualTo(generated1);\r\n    assertThat(getClassName(generated1)).isEqualTo(generated2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#fastClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid fastClass() {\r\n    String prefix = \"example.MyComponent\";\r\n    String source = FastClass.class.getName();\r\n    assertThat(getClassName(prefix, \"a.b.c\", null)).isEqualTo(\"example.MyComponent$$SpringCGLIB$$0\");\r\n    assertThat(getClassName(prefix, source, null)).isEqualTo(\"example.MyComponent$$SpringCGLIB$$FastClass$$0\");\r\n    assertThat(getClassName(prefix, source, null)).isEqualTo(\"example.MyComponent$$SpringCGLIB$$FastClass$$1\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#getClassName(String)",
    "entityType": "method",
    "code": "private String getClassName(String prefix) {\r\n    return getClassName(prefix, null, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.core.SpringNamingPolicyTests#getClassName(String,String,Object)",
    "entityType": "method",
    "code": "private String getClassName(String prefix, String source, Object key) {\r\n    String className = SpringNamingPolicy.INSTANCE.getClassName(prefix, source, key, reservedClassNames::contains);\r\n    reservedClassNames.add(className);\r\n    return className;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests",
    "entityType": "class",
    "code": "private static final String TX_NAME = Transactional.class.getName();\n@Nested\r\nclass ConventionBasedAnnotationAttributeOverrideTests {\r\n\r\n    @Test\r\n    void getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {\r\n        Class<?> element = ConventionBasedComposedContextConfigClass.class;\r\n        String name = ContextConfig.class.getName();\r\n        AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n        assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n        assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").containsExactly(\"explicitDeclaration\");\r\n        assertThat(attributes.getStringArray(\"value\")).as(\"value\").containsExactly(\"explicitDeclaration\");\r\n        // Verify contracts between utility methods:\r\n        assertThat(isAnnotated(element, name)).isTrue();\r\n    }\r\n\r\n    /**\r\n     * This test should never pass, simply because Spring does not support a hybrid\r\n     * approach for annotation attribute overrides with transitive implicit aliases.\r\n     * See SPR-13554 for details.\r\n     * <p>Furthermore, if you choose to execute this test, it can fail for either\r\n     * the first test class or the second one (with different exceptions), depending\r\n     * on the order in which the JVM returns the attribute methods via reflection.\r\n     */\r\n    @Disabled(\"Permanently disabled but left in place for illustrative purposes\")\r\n    @Test\r\n    void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {\r\n        for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class, HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {\r\n            getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz);\r\n        }\r\n    }\r\n\r\n    private void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {\r\n        String name = ContextConfig.class.getName();\r\n        String simpleName = clazz.getSimpleName();\r\n        AnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name);\r\n        assertThat(attributes).as(\"Should find @ContextConfig on \" + simpleName).isNotNull();\r\n        assertThat(attributes.getStringArray(\"locations\")).as(\"locations for class [\" + simpleName + \"]\").containsExactly(\"explicitDeclaration\");\r\n        assertThat(attributes.getStringArray(\"value\")).as(\"value for class [\" + simpleName + \"]\").containsExactly(\"explicitDeclaration\");\r\n        // Verify contracts between utility methods:\r\n        assertThat(isAnnotated(clazz, name)).isTrue();\r\n    }\r\n\r\n    @Test\r\n    void getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {\r\n        Class<?> element = InvalidConventionBasedComposedContextConfigClass.class;\r\n        assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(() -> getMergedAnnotationAttributes(element, ContextConfig.class)).withMessageContaining(\"Different @AliasFor mirror values for annotation\").withMessageContaining(\"attribute 'locations' and its alias 'value'\").withMessageContaining(\"values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]\");\r\n    }\r\n\r\n    @Test\r\n    void findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {\r\n        assertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n    }\r\n\r\n    @Test\r\n    void findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {\r\n        Class<?> element = SpringAppConfigClass.class;\r\n        ContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\r\n        assertThat(contextConfig).as(\"Should find @ContextConfig on \" + element).isNotNull();\r\n        assertThat(contextConfig.locations()).as(\"locations for \" + element).isEmpty();\r\n        // 'value' in @SpringAppConfig should not override 'value' in @ContextConfig\r\n        assertThat(contextConfig.value()).as(\"value for \" + element).isEmpty();\r\n        assertThat(contextConfig.classes()).as(\"classes for \" + element).containsExactly(Number.class);\r\n    }\r\n\r\n    @Test\r\n    void findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {\r\n        assertWebMapping(WebController.class.getMethod(\"postMappedWithPathAttribute\"));\r\n    }\r\n}\n@Test\r\nvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\r\n    assertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\r\n    assertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\r\n}\n@Test\r\nvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\r\n    Set<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\r\n    assertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\r\n    names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\r\n    assertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\r\n}\n@Test\r\nvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\r\n    Set<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\r\n    assertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\r\n    names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\r\n    assertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\r\n}\nprivate Set<String> names(Class<?>... classes) {\r\n    return stream(classes).map(Class::getName).collect(toSet());\r\n}\n@Test\r\nvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\r\n    assertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\r\n}\n@Test\r\nvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\r\n    assertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\r\n}\n@Test\r\nvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\r\n    assertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n}\n@Test\r\nvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\r\n    assertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n    assertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\r\n}\n@Test\r\nvoid isAnnotatedOnNonAnnotatedClass() {\r\n    assertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\r\n}\n@Test\r\nvoid isAnnotatedOnClassWithMetaDepth() {\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\r\n    assertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid isAnnotatedForPlainTypes() {\r\n    assertThat(isAnnotated(Order.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\r\n    assertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\r\n}\n@Test\r\nvoid isAnnotatedWithNameOnNonAnnotatedClass() {\r\n    assertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\r\n}\n@Test\r\nvoid isAnnotatedWithNameOnClassWithMetaDepth() {\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\r\n    assertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\r\n}\n@Test\r\nvoid hasAnnotationOnNonAnnotatedClass() {\r\n    assertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\r\n}\n@Test\r\nvoid hasAnnotationOnClassWithMetaDepth() {\r\n    assertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\r\n    assertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\r\n    assertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid hasAnnotationForPlainTypes() {\r\n    assertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\r\n    assertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\r\n    assertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\r\n    assertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\r\n}\n@Test\r\nvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\r\n    assertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\r\n}\n@Test\r\nvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\r\n    assertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\r\n}\n@Test\r\nvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\r\n    assertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\r\n}\n@Test\r\nvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\r\n    assertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\r\n}\n@Test\r\nvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\r\n    assertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\r\n}\n/**\r\n * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\r\n * the algorithm is accidentally picking up shadowed annotations of the same\r\n * type within the class hierarchy. Such undesirable behavior would cause the\r\n * logic in {@code org.springframework.context.annotation.ProfileCondition}\r\n * to fail.\r\n */\r\n@Test\r\nvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    // See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\r\n    assertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\r\n}\n/**\r\n * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\r\n */\r\n@Test\r\nvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\r\n    // See org.springframework.core.env.EnvironmentSystemIntegrationTests\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\r\n    assertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\r\n}\n@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid getAllAnnotationAttributesOnLangType() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(org.springframework.lang.NonNullApi.class, Nonnull.class.getName());\r\n    assertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\r\n    assertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\r\n}\n@Test\r\nvoid getAllAnnotationAttributesOnJavaxType() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(ParametersAreNonnullByDefault.class, Nonnull.class.getName());\r\n    assertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\r\n    assertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\r\n    Class<?> element = TxConfig.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    Class<?> element = DerivedTxConfig.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\r\n    assertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\r\n    Class<?> element = SubClassWithInheritedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n    assertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    Class<?> element = SubSubClassWithInheritedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n    assertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    Class<?> element = SubSubClassWithInheritedComposedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n    assertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\r\n    Class<?> element = ConcreteClassWithInheritedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isFalse();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\r\n    Class<?> element = InheritedAnnotationInterface.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\r\n    Class<?> element = NonInheritedAnnotationInterface.class;\r\n    String name = Order.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\r\n    Class<?> element = AliasedComposedContextConfigClass.class;\r\n    String name = ContextConfig.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\r\n    Class<?> element = AliasedValueComposedContextConfigClass.class;\r\n    String name = ContextConfig.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\r\n    Class<?> element = ComposedImplicitAliasesContextConfigClass.class;\r\n    String name = ImplicitAliasesContextConfig.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    String[] expected = asArray(\"A.xml\", \"B.xml\");\r\n    assertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\r\n    assertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\r\n}\n@Test\r\nvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\r\n    assertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\r\n    assertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\r\n    assertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\r\n}\n@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliases() {\r\n    assertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\r\n}\n@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    assertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\r\n}\n@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\r\n    assertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\r\n}\n@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    assertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\r\n}\nprivate void assertGetMergedAnnotation(Class<?> element, String... expected) {\r\n    String name = ContextConfig.class.getName();\r\n    ContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\r\n    assertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\r\n    assertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\r\n    Object[] expecteds = new Class<?>[0];\r\n    assertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\r\n    Class<?> element = ComposedImplicitAliasesContextConfigClass.class;\r\n    String name = ImplicitAliasesContextConfig.class.getName();\r\n    ImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\r\n    String[] expected = asArray(\"A.xml\", \"B.xml\");\r\n    assertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\r\n    assertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\r\n    assertThat(config.locations()).as(\"locations\").isEqualTo(expected);\r\n    assertThat(config.value()).as(\"value\").isEqualTo(expected);\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\r\n    Class<?> element = ImplicitAliasesWithDefaultsClass.class;\r\n    String name = AliasesWithDefaults.class.getName();\r\n    AliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\r\n    assertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\r\n    assertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}\n@Test\r\nvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\r\n    Class<?> element = ShadowedAliasComposedContextConfigClass.class;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\r\n    String[] expected = asArray(\"test.xml\");\r\n    assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\r\n}\n/**\r\n * Bridge/bridged method setup code copied from\r\n * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\r\n * @since 4.2\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesFromBridgeMethod() {\r\n    Method[] methods = StringGenericParameter.class.getMethods();\r\n    Method bridgeMethod = null;\r\n    Method bridgedMethod = null;\r\n    for (Method method : methods) {\r\n        if (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\r\n            if (method.getReturnType().equals(Object.class)) {\r\n                bridgeMethod = method;\r\n            } else {\r\n                bridgedMethod = method;\r\n            }\r\n        }\r\n    }\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    boolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\r\n    assertThat(condition).isTrue();\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\r\n}\n@Test\r\nvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\r\n    String qualifier = \"aliasForQualifier\";\r\n    // 1) Find and merge AnnotationAttributes from the annotation hierarchy\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(AliasedTransactionalComponentClass.class, AliasedTransactional.class);\r\n    assertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\r\n    // 2) Synthesize the AnnotationAttributes back into the target annotation\r\n    AliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes, AliasedTransactional.class, AliasedTransactionalComponentClass.class);\r\n    assertThat(annotation).isNotNull();\r\n    // 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\r\n    assertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\r\n    assertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\r\n    AnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\r\n    Filter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(excludeFilters).isNotNull();\r\n    List<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\r\n}\n/**\r\n * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\r\n * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\r\n * attributes since attributes may be arrays.\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\r\n    assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\r\n}\n/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\r\n    assertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n}\n/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\r\n    AliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\r\n    assertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\r\n    assertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n}\n/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\r\n    Class<?> clazz = ComposedTransactionalClass.class;\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\r\n    assertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n}\n/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\r\n    Class<?> clazz = ComposedTransactionalClass.class;\r\n    AliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\r\n    assertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\r\n    assertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n}\n@Test\r\nvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    assertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n}\nprivate AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\r\n    assertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\r\n    return attributes;\r\n}\nprivate AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    return AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\r\n}\n@Test\r\nvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\r\n    Class<?> element = AliasedTransactionalComponentClass.class;\r\n    AliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\r\n    assertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\r\n    assertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\r\n}\n@Test\r\nvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\r\n    String[] xmlLocations = asArray(\"test.xml\");\r\n    String[] propFiles = asArray(\"test.properties\");\r\n    Class<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\r\n    ContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\r\n    assertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\r\n    assertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\r\n    assertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\r\n    // Synthesized annotation\r\n    TestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\r\n    assertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\r\n    assertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\r\n    // Merged annotation\r\n    testPropSource = findMergedAnnotation(element, TestPropSource.class);\r\n    assertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\r\n    assertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\r\n    assertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\r\n}\n@Test\r\nvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\r\n    assertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\r\n    assertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\r\n}\nprivate void assertWebMapping(AnnotatedElement element) {\r\n    WebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\r\n    assertThat(webMapping).isNotNull();\r\n    assertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\r\n    assertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\r\n}\n@Test\r\nvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\r\n    Constructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\r\n    assertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\r\n    assertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\r\n}\n@Test\r\nvoid javaxAnnotationTypeViaFindMergedAnnotation() {\r\n    assertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\r\n    assertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\r\n}\n@Test\r\nvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\r\n    assertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\r\n    assertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\r\n}\n@Test\r\nvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    assertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\r\n}\n@Test\r\nvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    Set<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\r\n    assertThat(allMergedAnnotations).isEmpty();\r\n}\n@Test\r\nvoid findAllMergedAnnotationsOnClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    Set<Transactional> allMergedAnnotations = findAllMergedAnnotations(method, Transactional.class);\r\n    assertThat(allMergedAnnotations).hasSize(1);\r\n}\n// SPR-16060\r\n@Test\r\nvoid findMethodAnnotationFromGenericInterface() throws Exception {\r\n    Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    Order order = findMergedAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n// SPR-17146\r\n@Test\r\nvoid findMethodAnnotationFromGenericSuperclass() throws Exception {\r\n    Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod(\"foo\", String.class);\r\n    Order order = findMergedAnnotation(method, Order.class);\r\n    assertThat(order).isNotNull();\r\n}\n// gh-22655\r\n@Test\r\nvoid forAnnotationsCreatesCopyOfArrayOnEachCall() {\r\n    AnnotatedElement element = AnnotatedElementUtils.forAnnotations(ForAnnotationsClass.class.getDeclaredAnnotations());\r\n    // Trigger the NPE as originally reported in the bug\r\n    AnnotationsScanner.getDeclaredAnnotations(element, false);\r\n    AnnotationsScanner.getDeclaredAnnotations(element, false);\r\n    // Also specifically test we get different instances\r\n    assertThat(element.getDeclaredAnnotations()).isNotSameAs(element.getDeclaredAnnotations());\r\n}\n// gh-22703\r\n@Test\r\nvoid getMergedAnnotationOnThreeDeepMetaWithValue() {\r\n    ValueAttribute annotation = AnnotatedElementUtils.getMergedAnnotation(ValueAttributeMetaMetaClass.class, ValueAttribute.class);\r\n    assertThat(annotation.value()).containsExactly(\"FromValueAttributeMeta\");\r\n}\n/**\r\n * @since 5.3.25\r\n */\r\n// gh-29685\r\n@Test\r\nvoid getMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\r\n    Set<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations(StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class, StandardRepeatableWithContainerWithMultipleAttributes.class);\r\n    assertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value).containsExactly(\"a\", \"b\");\r\n}\n/**\r\n * @since 5.3.25\r\n */\r\n// gh-29685\r\n@Test\r\nvoid findMergedRepeatableAnnotationsWithContainerWithMultipleAttributes() {\r\n    Set<StandardRepeatableWithContainerWithMultipleAttributes> repeatableAnnotations = AnnotatedElementUtils.findMergedRepeatableAnnotations(StandardRepeatablesWithContainerWithMultipleAttributesTestCase.class, StandardRepeatableWithContainerWithMultipleAttributes.class);\r\n    assertThat(repeatableAnnotations).map(StandardRepeatableWithContainerWithMultipleAttributes::value).containsExactly(\"a\", \"b\");\r\n}\n// -------------------------------------------------------------------------\r\n@MetaCycle3\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.ANNOTATION_TYPE)\r\n@interface MetaCycle1 {\r\n}\n@MetaCycle1\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.ANNOTATION_TYPE)\r\n@interface MetaCycle2 {\r\n}\n@MetaCycle2\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@interface MetaCycle3 {\r\n}\n@MetaCycle3\r\nstatic class MetaCycleAnnotatedClass {\r\n}\n// -------------------------------------------------------------------------\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@Inherited\r\n@interface Transactional {\r\n\r\n    String value() default \"\";\r\n\r\n    String qualifier() default \"transactionManager\";\r\n\r\n    boolean readOnly() default false;\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@Inherited\r\n@interface AliasedTransactional {\r\n\r\n    @AliasFor(\"qualifier\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(\"value\")\r\n    String qualifier() default \"\";\r\n}\n@AliasedTransactional\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@interface MyAliasedTransactional {\r\n\r\n    @AliasFor(annotation = AliasedTransactional.class, attribute = \"value\")\r\n    String value() default \"defaultTransactionManager\";\r\n}\n@MyAliasedTransactional(\"anotherTransactionManager\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ ElementType.TYPE, ElementType.METHOD })\r\n@interface ComposedMyAliasedTransactional {\r\n}\n@Transactional(qualifier = \"composed1\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@Inherited\r\n@interface InheritedComposed {\r\n}\n@Transactional(qualifier = \"composed2\", readOnly = true)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@interface Composed {\r\n}\n@Transactional\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TxComposedWithOverride {\r\n\r\n    String qualifier() default \"txMgr\";\r\n}\n@Transactional(\"TxInheritedComposed\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TxInheritedComposed {\r\n}\n@Transactional(\"TxComposed\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TxComposed {\r\n}\n@Transactional\r\n@Component\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransactionalComponent {\r\n}\n@TransactionalComponent\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComposedTransactionalComponent {\r\n}\n@AliasedTransactional(value = \"aliasForQualifier\")\r\n@Component\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedTransactionalComponent {\r\n}\n@TxComposedWithOverride\r\n// Override default \"txMgr\" from @TxComposedWithOverride with \"localTxMgr\"\r\n@Transactional(qualifier = \"localTxMgr\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.TYPE)\r\n@interface MetaAndLocalTxConfig {\r\n}\n/**\r\n * Mock of {@code org.springframework.test.context.TestPropertySource}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestPropSource {\r\n\r\n    @AliasFor(\"locations\")\r\n    String[] value() default {};\r\n\r\n    @AliasFor(\"value\")\r\n    String[] locations() default {};\r\n}\n/**\r\n * Mock of {@code org.springframework.test.context.ContextConfiguration}.\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ContextConfig {\r\n\r\n    @AliasFor(\"locations\")\r\n    String[] value() default {};\r\n\r\n    @AliasFor(\"value\")\r\n    String[] locations() default {};\r\n\r\n    Class<?>[] classes() default {};\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ConventionBasedComposedContextConfig {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfig.class)\r\n    String[] locations() default {};\r\n}\n@ContextConfig(value = \"duplicateDeclaration\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface InvalidConventionBasedComposedContextConfig {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfig.class)\r\n    String[] locations();\r\n}\n/**\r\n * This hybrid approach for annotation attribute overrides with transitive implicit\r\n * aliases is unsupported. See SPR-13554 for details.\r\n */\r\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface HalfConventionBasedAndHalfAliasedComposedContextConfig {\r\n\r\n    String[] locations() default {};\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles() default {};\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles();\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedValueComposedContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"value\")\r\n    String[] locations();\r\n}\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ImplicitAliasesContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] groovyScripts() default {};\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] xmlFiles() default {};\r\n\r\n    // intentionally omitted: attribute = \"locations\"\r\n    @AliasFor(annotation = ContextConfig.class)\r\n    String[] locations() default {};\r\n\r\n    // intentionally omitted: attribute = \"locations\" (SPR-14069)\r\n    @AliasFor(annotation = ContextConfig.class)\r\n    String[] value() default {};\r\n}\n@ImplicitAliasesContextConfig(xmlFiles = { \"A.xml\", \"B.xml\" })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComposedImplicitAliasesContextConfig {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasesWithDefaults {\r\n\r\n    @AliasFor(\"a2\")\r\n    String a1() default \"AliasesWithDefaults\";\r\n\r\n    @AliasFor(\"a1\")\r\n    String a2() default \"AliasesWithDefaults\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@AliasesWithDefaults\r\n@interface ImplicitAliasesWithDefaults {\r\n\r\n    @AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a1\")\r\n    String b1() default \"ImplicitAliasesWithDefaults\";\r\n\r\n    @AliasFor(annotation = AliasesWithDefaults.class, attribute = \"a2\")\r\n    String b2() default \"ImplicitAliasesWithDefaults\";\r\n}\n@ImplicitAliasesContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesContextConfig {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\r\n    String[] xml() default {};\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\r\n    String[] groovy() default {};\r\n}\n@ImplicitAliasesContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SingleLocationTransitiveImplicitAliasesContextConfig {\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"xmlFiles\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\r\n    String groovy() default \"\";\r\n}\n@ImplicitAliasesContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TransitiveImplicitAliasesWithSkippedLevelContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] xml() default {};\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\r\n    String[] groovy() default {};\r\n}\n@ImplicitAliasesContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String xml() default \"\";\r\n\r\n    @AliasFor(annotation = ImplicitAliasesContextConfig.class, attribute = \"groovyScripts\")\r\n    String groovy() default \"\";\r\n}\n/**\r\n * Although the configuration declares an explicit value for 'value' and\r\n * requires a value for the aliased 'locations', this does not result in\r\n * an error since 'locations' effectively <em>shadows</em> the 'value'\r\n * attribute (which cannot be set via the composed annotation anyway).\r\n *\r\n * If 'value' were not shadowed, such a declaration would not make sense.\r\n */\r\n@ContextConfig(value = \"duplicateDeclaration\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ShadowedAliasComposedContextConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles();\r\n}\n@ContextConfig(locations = \"shadowed.xml\")\r\n@TestPropSource(locations = \"test.properties\")\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasedComposedContextConfigAndTestPropSource {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] xmlConfigFiles() default \"default.xml\";\r\n}\n/**\r\n * Mock of {@code org.springframework.boot.test.SpringApplicationConfiguration}.\r\n */\r\n@ContextConfig\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface SpringAppConfig {\r\n\r\n    @AliasFor(annotation = ContextConfig.class, attribute = \"locations\")\r\n    String[] locations() default {};\r\n\r\n    // Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\r\n    @AliasFor(\"value\")\r\n    Class<?>[] classes() default {};\r\n\r\n    // Do NOT use @AliasFor(annotation = ...) here until Spring 6.1\r\n    // @AliasFor(annotation = ContextConfig.class, attribute = \"classes\")\r\n    @AliasFor(\"classes\")\r\n    Class<?>[] value() default {};\r\n}\n/**\r\n * Mock of {@code org.springframework.context.annotation.ComponentScan}\r\n */\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComponentScan {\r\n\r\n    @AliasFor(\"basePackages\")\r\n    String[] value() default {};\r\n\r\n    // Intentionally no alias declaration for \"value\"\r\n    String[] basePackages() default {};\r\n\r\n    Filter[] excludeFilters() default {};\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({})\r\n@interface Filter {\r\n\r\n    String pattern();\r\n}\n@ComponentScan(excludeFilters = { @Filter(pattern = \"*Test\"), @Filter(pattern = \"*Tests\") })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestComponentScan {\r\n\r\n    @AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\r\n    String[] packages();\r\n}\n@ComponentScan\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ConventionBasedSinglePackageComponentScan {\r\n\r\n    // Do NOT use @AliasFor here until Spring 6.1\r\n    // @AliasFor(annotation = ComponentScan.class)\r\n    String basePackages();\r\n}\n@ComponentScan\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface AliasForBasedSinglePackageComponentScan {\r\n\r\n    @AliasFor(attribute = \"basePackages\", annotation = ComponentScan.class)\r\n    String pkg();\r\n}\n// -------------------------------------------------------------------------\r\nstatic class NonAnnotatedClass {\r\n}\n@TransactionalComponent\r\nstatic class TransactionalComponentClass {\r\n}\nstatic class SubTransactionalComponentClass extends TransactionalComponentClass {\r\n}\n@ComposedTransactionalComponent\r\nstatic class ComposedTransactionalComponentClass {\r\n}\n@AliasedTransactionalComponent\r\nstatic class AliasedTransactionalComponentClass {\r\n}\n@ComposedMyAliasedTransactional\r\nvoid composedTransactionalMethod() ;\n@ComposedMyAliasedTransactional\r\nstatic class ComposedTransactionalClass {\r\n}\n@Transactional\r\nstatic class ClassWithInheritedAnnotation {\r\n}\n@Composed\r\nstatic class SubClassWithInheritedAnnotation extends ClassWithInheritedAnnotation {\r\n}\nstatic class SubSubClassWithInheritedAnnotation extends SubClassWithInheritedAnnotation {\r\n}\n@InheritedComposed\r\nstatic class ClassWithInheritedComposedAnnotation {\r\n}\n@Composed\r\nstatic class SubClassWithInheritedComposedAnnotation extends ClassWithInheritedComposedAnnotation {\r\n}\nstatic class SubSubClassWithInheritedComposedAnnotation extends SubClassWithInheritedComposedAnnotation {\r\n}\n@MetaAndLocalTxConfig\r\nstatic class MetaAndLocalTxConfigClass {\r\n}\n@Transactional(\"TxConfig\")\r\nstatic class TxConfig {\r\n}\n@Transactional(\"DerivedTxConfig\")\r\nstatic class DerivedTxConfig extends TxConfig {\r\n}\n@TxInheritedComposed\r\n@TxComposed\r\nstatic class TxFromMultipleComposedAnnotations {\r\n}\n@Transactional\r\ninterface InterfaceWithInheritedAnnotation {\r\n\r\n    @Order\r\n    void handleFromInterface();\r\n}\nabstract static class AbstractClassWithInheritedAnnotation<T> implements InterfaceWithInheritedAnnotation {\r\n\r\n    @Transactional\r\n    public abstract void handle();\r\n\r\n    @Transactional\r\n    public void handleParameterized(T t) {\r\n    }\r\n}\nstatic class ConcreteClassWithInheritedAnnotation extends AbstractClassWithInheritedAnnotation<String> {\r\n\r\n    @Override\r\n    public void handle() {\r\n    }\r\n\r\n    @Override\r\n    public void handleParameterized(String s) {\r\n    }\r\n\r\n    @Override\r\n    public void handleFromInterface() {\r\n    }\r\n}\npublic interface GenericParameter<T> {\r\n\r\n    T getFor(Class<T> cls);\r\n}\n@SuppressWarnings(\"unused\")\r\nprivate static class StringGenericParameter implements GenericParameter<String> {\r\n\r\n    @Order\r\n    @Override\r\n    public String getFor(Class<String> cls) {\r\n        return \"foo\";\r\n    }\r\n\r\n    public String getFor(Integer integer) {\r\n        return \"foo\";\r\n    }\r\n}\n@Transactional\r\npublic interface InheritedAnnotationInterface {\r\n}\npublic interface SubInheritedAnnotationInterface extends InheritedAnnotationInterface {\r\n}\npublic interface SubSubInheritedAnnotationInterface extends SubInheritedAnnotationInterface {\r\n}\n@Order\r\npublic interface NonInheritedAnnotationInterface {\r\n}\npublic interface SubNonInheritedAnnotationInterface extends NonInheritedAnnotationInterface {\r\n}\npublic interface SubSubNonInheritedAnnotationInterface extends SubNonInheritedAnnotationInterface {\r\n}\n@ConventionBasedComposedContextConfig(locations = \"explicitDeclaration\")\r\nstatic class ConventionBasedComposedContextConfigClass {\r\n}\n@InvalidConventionBasedComposedContextConfig(locations = \"requiredLocationsDeclaration\")\r\nstatic class InvalidConventionBasedComposedContextConfigClass {\r\n}\n@HalfConventionBasedAndHalfAliasedComposedContextConfig(xmlConfigFiles = \"explicitDeclaration\")\r\nstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1 {\r\n}\n@HalfConventionBasedAndHalfAliasedComposedContextConfig(locations = \"explicitDeclaration\")\r\nstatic class HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2 {\r\n}\n@AliasedComposedContextConfig(xmlConfigFiles = \"test.xml\")\r\nstatic class AliasedComposedContextConfigClass {\r\n}\n@AliasedValueComposedContextConfig(locations = \"test.xml\")\r\nstatic class AliasedValueComposedContextConfigClass {\r\n}\n@ImplicitAliasesContextConfig(\"foo.xml\")\r\nstatic class ImplicitAliasesContextConfigClass1 {\r\n}\n@ImplicitAliasesContextConfig(locations = \"bar.xml\")\r\nstatic class ImplicitAliasesContextConfigClass2 {\r\n}\n@ImplicitAliasesContextConfig(xmlFiles = \"baz.xml\")\r\nstatic class ImplicitAliasesContextConfigClass3 {\r\n}\n@ImplicitAliasesWithDefaults\r\nstatic class ImplicitAliasesWithDefaultsClass {\r\n}\n@TransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\r\nstatic class TransitiveImplicitAliasesContextConfigClass {\r\n}\n@SingleLocationTransitiveImplicitAliasesContextConfig(groovy = \"test.groovy\")\r\nstatic class SingleLocationTransitiveImplicitAliasesContextConfigClass {\r\n}\n@TransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\r\nstatic class TransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\r\n}\n@SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfig(xml = \"test.xml\")\r\nstatic class SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass {\r\n}\n@ComposedImplicitAliasesContextConfig\r\nstatic class ComposedImplicitAliasesContextConfigClass {\r\n}\n@ShadowedAliasComposedContextConfig(xmlConfigFiles = \"test.xml\")\r\nstatic class ShadowedAliasComposedContextConfigClass {\r\n}\n@AliasedComposedContextConfigAndTestPropSource(xmlConfigFiles = \"test.xml\")\r\nstatic class AliasedComposedContextConfigAndTestPropSourceClass {\r\n}\n@ComponentScan(value = \"com.example.app.test\", basePackages = \"com.example.app.test\")\r\nstatic class ComponentScanWithBasePackagesAndValueAliasClass {\r\n}\n@TestComponentScan(packages = \"com.example.app.test\")\r\nstatic class TestComponentScanClass {\r\n}\n@ConventionBasedSinglePackageComponentScan(basePackages = \"com.example.app.test\")\r\nstatic class ConventionBasedSinglePackageComponentScanClass {\r\n}\n@AliasForBasedSinglePackageComponentScan(pkg = \"com.example.app.test\")\r\nstatic class AliasForBasedSinglePackageComponentScanClass {\r\n}\n@SpringAppConfig(Number.class)\r\nstatic class SpringAppConfigClass {\r\n}\n@Resource(name = \"x\")\r\n@ParametersAreNonnullByDefault\r\nstatic class ResourceHolder {\r\n}\ninterface TransactionalService {\r\n\r\n    @Transactional\r\n    @Nullable\r\n    Object doIt();\r\n}\nclass TransactionalServiceImpl implements TransactionalService {\r\n\r\n    @Override\r\n    @Nullable\r\n    public Object doIt() {\r\n        return null;\r\n    }\r\n}\n@Deprecated\r\n@ComponentScan\r\nclass ForAnnotationsClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ValueAttribute {\r\n\r\n    String[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@ValueAttribute(\"FromValueAttributeMeta\")\r\n@interface ValueAttributeMeta {\r\n\r\n    @AliasFor(\"alias\")\r\n    String[] value() default {};\r\n\r\n    @AliasFor(\"value\")\r\n    String[] alias() default {};\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@ValueAttributeMeta(\"FromValueAttributeMetaMeta\")\r\n@interface ValueAttributeMetaMeta {\r\n}\n@ValueAttributeMetaMeta\r\nstatic class ValueAttributeMetaMetaClass {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface StandardContainerWithMultipleAttributes {\r\n\r\n    StandardRepeatableWithContainerWithMultipleAttributes[] value();\r\n\r\n    String name() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(StandardContainerWithMultipleAttributes.class)\r\n@interface StandardRepeatableWithContainerWithMultipleAttributes {\r\n\r\n    String value() default \"\";\r\n}\n@StandardRepeatableWithContainerWithMultipleAttributes(\"a\")\r\n@StandardRepeatableWithContainerWithMultipleAttributes(\"b\")\r\nstatic class StandardRepeatablesWithContainerWithMultipleAttributesTestCase {\r\n}",
    "comment": "\n * Tests for {@link AnnotatedElementUtils}.\n *\n * @author Sam Brannen\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0.3\n * @see AnnotationUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n * @see ComposedRepeatableAnnotationsTests\n * @see NestedRepeatableAnnotationsTests\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMetaAnnotationTypesOnNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMetaAnnotationTypesOnNonAnnotatedClass() {\r\n    assertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class)).isEmpty();\r\n    assertThat(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName())).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMetaAnnotationTypesOnClassWithMetaDepth1()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMetaAnnotationTypesOnClassWithMetaDepth1() {\r\n    Set<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class);\r\n    assertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\r\n    names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName());\r\n    assertThat(names).isEqualTo(names(Transactional.class, Component.class, Indexed.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMetaAnnotationTypesOnClassWithMetaDepth2()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMetaAnnotationTypesOnClassWithMetaDepth2() {\r\n    Set<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class);\r\n    assertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\r\n    names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName());\r\n    assertThat(names).isEqualTo(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#names(Class<?>)",
    "entityType": "method",
    "code": "private Set<String> names(Class<?>... classes) {\r\n    return stream(classes).map(Class::getName).collect(toSet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasMetaAnnotationTypesOnNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationTypesOnNonAnnotatedClass() {\r\n    assertThat(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasMetaAnnotationTypesOnClassWithMetaDepth0()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationTypesOnClassWithMetaDepth0() {\r\n    assertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasMetaAnnotationTypesOnClassWithMetaDepth1()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationTypesOnClassWithMetaDepth1() {\r\n    assertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasMetaAnnotationTypesOnClassWithMetaDepth2()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasMetaAnnotationTypesOnClassWithMetaDepth2() {\r\n    assertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n    assertThat(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#isAnnotatedOnNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedOnNonAnnotatedClass() {\r\n    assertThat(isAnnotated(NonAnnotatedClass.class, Transactional.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#isAnnotatedOnClassWithMetaDepth()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedOnClassWithMetaDepth() {\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\r\n    assertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class)).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#isAnnotatedForPlainTypes()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid isAnnotatedForPlainTypes() {\r\n    assertThat(isAnnotated(Order.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\r\n    assertThat(isAnnotated(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\r\n    assertThat(isAnnotated(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#isAnnotatedWithNameOnNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedWithNameOnNonAnnotatedClass() {\r\n    assertThat(isAnnotated(NonAnnotatedClass.class, TX_NAME)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#isAnnotatedWithNameOnClassWithMetaDepth()",
    "entityType": "method",
    "code": "@Test\r\nvoid isAnnotatedWithNameOnClassWithMetaDepth() {\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())).isTrue();\r\n    assertThat(isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())).as(\"isAnnotated() does not search the class hierarchy.\").isFalse();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(isAnnotated(TransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).isTrue();\r\n    assertThat(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasAnnotationOnNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotationOnNonAnnotatedClass() {\r\n    assertThat(hasAnnotation(NonAnnotatedClass.class, Transactional.class)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasAnnotationOnClassWithMetaDepth()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasAnnotationOnClassWithMetaDepth() {\r\n    assertThat(hasAnnotation(TransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\r\n    assertThat(hasAnnotation(SubTransactionalComponentClass.class, TransactionalComponent.class)).isTrue();\r\n    assertThat(hasAnnotation(TransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(hasAnnotation(TransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Transactional.class)).isTrue();\r\n    assertThat(hasAnnotation(ComposedTransactionalComponentClass.class, Component.class)).isTrue();\r\n    assertThat(hasAnnotation(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#hasAnnotationForPlainTypes()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid hasAnnotationForPlainTypes() {\r\n    assertThat(hasAnnotation(Order.class, Documented.class)).isTrue();\r\n    assertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Documented.class)).isTrue();\r\n    assertThat(hasAnnotation(org.springframework.lang.NonNullApi.class, Nonnull.class)).isTrue();\r\n    assertThat(hasAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnNonAnnotatedClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesOnNonAnnotatedClass() {\r\n    assertThat(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnClassWithLocalAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesOnClassWithLocalAnnotation() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on TxConfig\").isNotNull();\r\n    assertThat(attributes.get(\"value\")).as(\"value for TxConfig\").isEqualTo(List.of(\"TxConfig\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\r\n    assertThat(attributes.get(\"qualifier\")).isEqualTo(asList(\"composed2\", \"transactionManager\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\r\n    assertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"transactionManager\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedComposedAnnotation.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation\").isNotNull();\r\n    assertThat(attributes.get(\"qualifier\")).isEqualTo(List.of(\"composed1\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass()",
    "entityType": "method",
    "code": "/**\r\n * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\r\n * the algorithm is accidentally picking up shadowed annotations of the same\r\n * type within the class hierarchy. Such undesirable behavior would cause the\r\n * logic in {@code org.springframework.context.annotation.ProfileCondition}\r\n * to fail.\r\n */\r\n@Test\r\nvoid getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    // See org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on DerivedTxConfig\").isNotNull();\r\n    assertThat(attributes.get(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(List.of(\"DerivedTxConfig\"));\r\n}",
    "comment": "\n\t * If the \"value\" entry contains both \"DerivedTxConfig\" AND \"TxConfig\", then\n\t * the algorithm is accidentally picking up shadowed annotations of the same\n\t * type within the class hierarchy. Such undesirable behavior would cause the\n\t * logic in {@code org.springframework.context.annotation.ProfileCondition}\n\t * to fail.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations()",
    "entityType": "method",
    "code": "/**\r\n * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\r\n */\r\n@Test\r\nvoid getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {\r\n    // See org.springframework.core.env.EnvironmentSystemIntegrationTests\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME);\r\n    assertThat(attributes).as(\"Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations\").isNotNull();\r\n    assertThat(attributes.get(\"value\")).as(\"value for TxFromMultipleComposedAnnotations.\").isEqualTo(asList(\"TxInheritedComposed\", \"TxComposed\"));\r\n}",
    "comment": "\n\t * Note: this functionality is required by {@code org.springframework.context.annotation.ProfileCondition}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnLangType()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings(\"deprecation\")\r\nvoid getAllAnnotationAttributesOnLangType() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(org.springframework.lang.NonNullApi.class, Nonnull.class.getName());\r\n    assertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\r\n    assertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllAnnotationAttributesOnJavaxType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllAnnotationAttributesOnJavaxType() {\r\n    MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(ParametersAreNonnullByDefault.class, Nonnull.class.getName());\r\n    assertThat(attributes).as(\"Annotation attributes map for @Nonnull on NonNullApi\").isNotNull();\r\n    assertThat(attributes.get(\"when\")).as(\"value for NonNullApi\").isEqualTo(List.of(When.ALWAYS));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesOnClassWithLocalAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesOnClassWithLocalAnnotation() {\r\n    Class<?> element = TxConfig.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Annotation attributes for @Transactional on TxConfig\").isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"value for TxConfig\").isEqualTo(\"TxConfig\");\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {\r\n    Class<?> element = DerivedTxConfig.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Annotation attributes for @Transactional on DerivedTxConfig\").isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"value for DerivedTxConfig\").isEqualTo(\"DerivedTxConfig\");\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME);\r\n    assertThat(attributes).as(\"Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass\").isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {\r\n    Class<?> element = SubClassWithInheritedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n    assertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubClassWithInheritedAnnotation.\").isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    Class<?> element = SubSubClassWithInheritedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n    assertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedAnnotation.\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\r\n    Class<?> element = SubSubClassWithInheritedComposedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n    assertThat(attributes.getBoolean(\"readOnly\")).as(\"readOnly flag for SubSubClassWithInheritedComposedAnnotation.\").isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {\r\n    Class<?> element = ConcreteClassWithInheritedAnnotation.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should not find @Transactional on ConcreteClassWithInheritedAnnotation\").isNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesOnInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesOnInheritedAnnotationInterface() {\r\n    Class<?> element = InheritedAnnotationInterface.class;\r\n    String name = TX_NAME;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesOnNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\r\n    Class<?> element = NonInheritedAnnotationInterface.class;\r\n    String name = Order.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesWithAliasedComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesWithAliasedComposedAnnotation() {\r\n    Class<?> element = AliasedComposedContextConfigClass.class;\r\n    String name = ContextConfig.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesWithAliasedValueComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {\r\n    Class<?> element = AliasedValueComposedContextConfigClass.class;\r\n    String name = ContextConfig.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(asArray(\"test.xml\"));\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(asArray(\"test.xml\"));\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\r\n    Class<?> element = ComposedImplicitAliasesContextConfigClass.class;\r\n    String name = ImplicitAliasesContextConfig.class.getName();\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name);\r\n    String[] expected = asArray(\"A.xml\", \"B.xml\");\r\n    assertThat(attributes).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"groovyScripts\")).as(\"groovyScripts\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"xmlFiles\")).as(\"xmlFiles\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithAliasedValueComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithAliasedValueComposedAnnotation() {\r\n    assertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, \"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {\r\n    assertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, \"foo.xml\");\r\n    assertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, \"bar.xml\");\r\n    assertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, \"baz.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithTransitiveImplicitAliases()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliases() {\r\n    assertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    assertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, \"test.groovy\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {\r\n    assertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    assertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, \"test.xml\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#assertGetMergedAnnotation(Class<?>,String)",
    "entityType": "method",
    "code": "private void assertGetMergedAnnotation(Class<?> element, String... expected) {\r\n    String name = ContextConfig.class.getName();\r\n    ContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class);\r\n    assertThat(contextConfig).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(contextConfig.locations()).as(\"locations\").isEqualTo(expected);\r\n    assertThat(contextConfig.value()).as(\"value\").isEqualTo(expected);\r\n    Object[] expecteds = new Class<?>[0];\r\n    assertThat(contextConfig.classes()).as(\"classes\").isEqualTo(expecteds);\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {\r\n    Class<?> element = ComposedImplicitAliasesContextConfigClass.class;\r\n    String name = ImplicitAliasesContextConfig.class.getName();\r\n    ImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class);\r\n    String[] expected = asArray(\"A.xml\", \"B.xml\");\r\n    assertThat(config).as(\"Should find @ImplicitAliasesContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(config.groovyScripts()).as(\"groovyScripts\").isEqualTo(expected);\r\n    assertThat(config.xmlFiles()).as(\"xmlFiles\").isEqualTo(expected);\r\n    assertThat(config.locations()).as(\"locations\").isEqualTo(expected);\r\n    assertThat(config.value()).as(\"value\").isEqualTo(expected);\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationWithImplicitAliasesWithDefaultsInMetaAnnotationOnComposedAnnotation() {\r\n    Class<?> element = ImplicitAliasesWithDefaultsClass.class;\r\n    String name = AliasesWithDefaults.class.getName();\r\n    AliasesWithDefaults annotation = getMergedAnnotation(element, AliasesWithDefaults.class);\r\n    assertThat(annotation).as(\"Should find @AliasesWithDefaults on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(annotation.a1()).as(\"a1\").isEqualTo(\"ImplicitAliasesWithDefaults\");\r\n    assertThat(annotation.a2()).as(\"a2\").isEqualTo(\"ImplicitAliasesWithDefaults\");\r\n    // Verify contracts between utility methods:\r\n    assertThat(isAnnotated(element, name)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {\r\n    Class<?> element = ShadowedAliasComposedContextConfigClass.class;\r\n    AnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class);\r\n    String[] expected = asArray(\"test.xml\");\r\n    assertThat(attributes).as(\"Should find @ContextConfig on \" + element.getSimpleName()).isNotNull();\r\n    assertThat(attributes.getStringArray(\"locations\")).as(\"locations\").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value\").isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on InheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on SubInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on SubSubInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on NonInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on SubNonInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on SubSubNonInheritedAnnotationInterface\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesInheritedFromInterfaceMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleFromInterface\");\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesInheritedFromAbstractMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handle\");\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesInheritedFromBridgedMethod()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {\r\n    Method method = ConcreteClassWithInheritedAnnotation.class.getMethod(\"handleParameterized\", String.class);\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()\").isNotNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesFromBridgeMethod()",
    "entityType": "method",
    "code": "/**\r\n * Bridge/bridged method setup code copied from\r\n * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\r\n * @since 4.2\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesFromBridgeMethod() {\r\n    Method[] methods = StringGenericParameter.class.getMethods();\r\n    Method bridgeMethod = null;\r\n    Method bridgedMethod = null;\r\n    for (Method method : methods) {\r\n        if (\"getFor\".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {\r\n            if (method.getReturnType().equals(Object.class)) {\r\n                bridgeMethod = method;\r\n            } else {\r\n                bridgedMethod = method;\r\n            }\r\n        }\r\n    }\r\n    assertThat(bridgeMethod != null && bridgeMethod.isBridge()).isTrue();\r\n    boolean condition = bridgedMethod != null && !bridgedMethod.isBridge();\r\n    assertThat(condition).isTrue();\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class);\r\n    assertThat(attributes).as(\"Should find @Order on StringGenericParameter.getFor() bridge method\").isNotNull();\r\n}",
    "comment": "\n\t * Bridge/bridged method setup code copied from\n\t * {@link org.springframework.core.BridgeMethodResolverTests#withGenericParameter()}.\n\t * @since 4.2\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class);\r\n    assertThat(attributes).as(\"Should find @Transactional on MetaAndLocalTxConfigClass\").isNotNull();\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for MetaAndLocalTxConfigClass.\").isEqualTo(\"localTxMgr\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {\r\n    String qualifier = \"aliasForQualifier\";\r\n    // 1) Find and merge AnnotationAttributes from the annotation hierarchy\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(AliasedTransactionalComponentClass.class, AliasedTransactional.class);\r\n    assertThat(attributes).as(\"@AliasedTransactional on AliasedTransactionalComponentClass.\").isNotNull();\r\n    // 2) Synthesize the AnnotationAttributes back into the target annotation\r\n    AliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes, AliasedTransactional.class, AliasedTransactionalComponentClass.class);\r\n    assertThat(annotation).isNotNull();\r\n    // 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent\r\n    assertThat(attributes.getString(\"value\")).as(\"TX value via attributes.\").isEqualTo(qualifier);\r\n    assertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(qualifier);\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier via attributes.\").isEqualTo(qualifier);\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(qualifier);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {\r\n    AnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, \"com.example.app.test\");\r\n    Filter[] excludeFilters = attributes.getAnnotationArray(\"excludeFilters\", Filter.class);\r\n    assertThat(excludeFilters).isNotNull();\r\n    List<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList());\r\n    assertThat(patterns).isEqualTo(asList(\"*Test\", \"*Tests\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared()",
    "entityType": "method",
    "code": "/**\r\n * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\r\n * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\r\n * attributes since attributes may be arrays.\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {\r\n    assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, \"com.example.app.test\");\r\n}",
    "comment": "\n\t * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}\n\t * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation\n\t * attributes since attributes may be arrays.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(method, AliasedTransactional.class);\r\n    assertThat(attributes).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n}",
    "comment": "\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationOnMethodWithComposedMetaTransactionalAnnotation() throws Exception {\r\n    Method method = getClass().getDeclaredMethod(\"composedTransactionalMethod\");\r\n    AliasedTransactional annotation = findMergedAnnotation(method, AliasedTransactional.class);\r\n    assertThat(annotation).as(\"Should find @AliasedTransactional on \" + method).isNotNull();\r\n    assertThat(annotation.value()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier for \" + method).isEqualTo(\"anotherTransactionManager\");\r\n}",
    "comment": "\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationAttributesOnClassWithComposedMetaTransactionalAnnotation() {\r\n    Class<?> clazz = ComposedTransactionalClass.class;\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(clazz, AliasedTransactional.class);\r\n    assertThat(attributes).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\r\n    assertThat(attributes.getString(\"value\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(attributes.getString(\"qualifier\")).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n}",
    "comment": "\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation()",
    "entityType": "method",
    "code": "/**\r\n * @since 5.2.1\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\r\n */\r\n@Test\r\nvoid findMergedAnnotationOnClassWithComposedMetaTransactionalAnnotation() {\r\n    Class<?> clazz = ComposedTransactionalClass.class;\r\n    AliasedTransactional annotation = findMergedAnnotation(clazz, AliasedTransactional.class);\r\n    assertThat(annotation).as(\"Should find @AliasedTransactional on \" + clazz).isNotNull();\r\n    assertThat(annotation.value()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier for \" + clazz).isEqualTo(\"anotherTransactionManager\");\r\n}",
    "comment": "\n\t * @since 5.2.1\n\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/23767\">#23767</a>\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {\r\n    assertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, \"com.example.app.test\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#assertComponentScanAttributes(Class<?>,String)",
    "entityType": "method",
    "code": "private AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {\r\n    AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class);\r\n    assertThat(attributes).as(\"Should find @ComponentScan on \" + element).isNotNull();\r\n    assertThat(attributes.getStringArray(\"value\")).as(\"value: \").isEqualTo(expected);\r\n    assertThat(attributes.getStringArray(\"basePackages\")).as(\"basePackages: \").isEqualTo(expected);\r\n    return attributes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationAttributes(AnnotatedElement,Class<? extends Annotation>)",
    "entityType": "method",
    "code": "private AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {\r\n    return AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationWithAttributeAliasesInTargetAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {\r\n    Class<?> element = AliasedTransactionalComponentClass.class;\r\n    AliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class);\r\n    assertThat(annotation).as(\"@AliasedTransactional on \" + element).isNotNull();\r\n    assertThat(annotation.value()).as(\"TX value via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\r\n    assertThat(annotation.qualifier()).as(\"TX qualifier via synthesized annotation.\").isEqualTo(\"aliasForQualifier\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {\r\n    String[] xmlLocations = asArray(\"test.xml\");\r\n    String[] propFiles = asArray(\"test.properties\");\r\n    Class<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class;\r\n    ContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class);\r\n    assertThat(contextConfig).as(\"@ContextConfig on \" + element).isNotNull();\r\n    assertThat(contextConfig.locations()).as(\"locations\").isEqualTo(xmlLocations);\r\n    assertThat(contextConfig.value()).as(\"value\").isEqualTo(xmlLocations);\r\n    // Synthesized annotation\r\n    TestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class);\r\n    assertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\r\n    assertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\r\n    // Merged annotation\r\n    testPropSource = findMergedAnnotation(element, TestPropSource.class);\r\n    assertThat(testPropSource).as(\"@TestPropSource on \" + element).isNotNull();\r\n    assertThat(testPropSource.locations()).as(\"locations\").isEqualTo(propFiles);\r\n    assertThat(testPropSource.value()).as(\"value\").isEqualTo(propFiles);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor()",
    "entityType": "method",
    "code": "@Test\r\nvoid findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {\r\n    assertWebMapping(WebController.class.getMethod(\"getMappedWithValueAttribute\"));\r\n    assertWebMapping(WebController.class.getMethod(\"getMappedWithPathAttribute\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#assertWebMapping(AnnotatedElement)",
    "entityType": "method",
    "code": "private void assertWebMapping(AnnotatedElement element) {\r\n    WebMapping webMapping = findMergedAnnotation(element, WebMapping.class);\r\n    assertThat(webMapping).isNotNull();\r\n    assertThat(webMapping.value()).as(\"value attribute: \").isEqualTo(asArray(\"/test\"));\r\n    assertThat(webMapping.path()).as(\"path attribute: \").isEqualTo(asArray(\"/test\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#javaLangAnnotationTypeViaFindMergedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {\r\n    Constructor<?> deprecatedCtor = Date.class.getConstructor(String.class);\r\n    assertThat(findMergedAnnotation(deprecatedCtor, Deprecated.class)).isEqualTo(deprecatedCtor.getAnnotation(Deprecated.class));\r\n    assertThat(findMergedAnnotation(Date.class, Deprecated.class)).isEqualTo(Date.class.getAnnotation(Deprecated.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#javaxAnnotationTypeViaFindMergedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaxAnnotationTypeViaFindMergedAnnotation() {\r\n    assertThat(findMergedAnnotation(ResourceHolder.class, Resource.class)).isEqualTo(ResourceHolder.class.getAnnotation(Resource.class));\r\n    assertThat(findMergedAnnotation(SpringAppConfigClass.class, Resource.class)).isEqualTo(SpringAppConfigClass.class.getAnnotation(Resource.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#javaxMetaAnnotationTypeViaFindMergedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid javaxMetaAnnotationTypeViaFindMergedAnnotation() {\r\n    assertThat(findMergedAnnotation(ParametersAreNonnullByDefault.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\r\n    assertThat(findMergedAnnotation(ResourceHolder.class, Nonnull.class)).isEqualTo(ParametersAreNonnullByDefault.class.getAnnotation(Nonnull.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#nullableAnnotationTypeViaFindMergedAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid nullableAnnotationTypeViaFindMergedAnnotation() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    assertThat(findMergedAnnotation(method, Resource.class)).isEqualTo(method.getAnnotation(Resource.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotatedElementUtilsTests#getAllMergedAnnotationsOnClassWithInterface()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAllMergedAnnotationsOnClassWithInterface() throws Exception {\r\n    Method method = TransactionalServiceImpl.class.getMethod(\"doIt\");\r\n    Set<Transactional> allMergedAnnotations = getAllMergedAnnotations(method, Transactional.class);\r\n    assertThat(allMergedAnnotations).isEmpty();\r\n}",
    "comment": ""
  }
]