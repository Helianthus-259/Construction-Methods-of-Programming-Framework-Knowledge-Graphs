[
  {
    "entityId": "org.springframework.core.annotation.ValueImplicitAliasesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.Location1ImplicitAliasesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.Location2ImplicitAliasesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.Location3ImplicitAliasesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.ValueImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.LocationsImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.XmlFilesImplicitAliasesWithImpliedAliasNamesOmittedContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": " Attribute value intentionally matches attribute name:"
  },
  {
    "entityId": "org.springframework.core.annotation.ImplicitAliasesWithMissingDefaultValuesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ImplicitAliasesWithDifferentDefaultValuesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ImplicitAliasesWithDuplicateValuesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ImplicitAliasesForAliasPairContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TransitiveImplicitAliasesContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TransitiveImplicitAliasesForAliasPairContextConfigClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComponentScanClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComponentScanSingleFilterClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ContextConfigMismatch",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TestRepeatablesClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.DeprecatedClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubclassOfDeprecatedClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid forAnnotationTypeWhenNullReturnsNone() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(null);\r\n    assertThat(methods).isSameAs(AttributeMethods.NONE);\r\n}\n@Test\r\nvoid forAnnotationTypeWhenHasNoAttributesReturnsNone() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(NoAttributes.class);\r\n    assertThat(methods).isSameAs(AttributeMethods.NONE);\r\n}\n@Test\r\nvoid forAnnotationTypeWhenHasMultipleAttributesReturnsAttributes() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.get(\"value\").getName()).isEqualTo(\"value\");\r\n    assertThat(methods.get(\"intValue\").getName()).isEqualTo(\"intValue\");\r\n    assertThat(getAll(methods)).flatExtracting(Method::getName).containsExactly(\"intValue\", \"value\");\r\n}\n@Test\r\nvoid indexOfNameReturnsIndex() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.indexOf(\"value\")).isEqualTo(1);\r\n}\n@Test\r\nvoid indexOfMethodReturnsIndex() throws Exception {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    Method method = MultipleAttributes.class.getDeclaredMethod(\"value\");\r\n    assertThat(methods.indexOf(method)).isEqualTo(1);\r\n}\n@Test\r\nvoid sizeReturnsSize() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.size()).isEqualTo(2);\r\n}\n@Test\r\nvoid canThrowTypeNotPresentExceptionWhenHasClassAttributeReturnsTrue() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ClassValue.class);\r\n    assertThat(methods.canThrowTypeNotPresentException(0)).isTrue();\r\n}\n@Test\r\nvoid canThrowTypeNotPresentExceptionWhenHasClassArrayAttributeReturnsTrue() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ClassArrayValue.class);\r\n    assertThat(methods.canThrowTypeNotPresentException(0)).isTrue();\r\n}\n@Test\r\nvoid canThrowTypeNotPresentExceptionWhenNotClassOrClassArrayAttributeReturnsFalse() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ValueOnly.class);\r\n    assertThat(methods.canThrowTypeNotPresentException(0)).isFalse();\r\n}\n@Test\r\nvoid hasDefaultValueMethodWhenHasDefaultValueMethodReturnsTrue() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(DefaultValueAttribute.class);\r\n    assertThat(methods.hasDefaultValueMethod()).isTrue();\r\n}\n@Test\r\nvoid hasDefaultValueMethodWhenHasNoDefaultValueMethodsReturnsFalse() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.hasDefaultValueMethod()).isFalse();\r\n}\n@Test\r\nvoid isValidWhenHasTypeNotPresentExceptionReturnsFalse() {\r\n    ClassValue annotation = mockAnnotation(ClassValue.class);\r\n    given(annotation.value()).willThrow(TypeNotPresentException.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    assertThat(attributes.canLoad(annotation)).isFalse();\r\n}\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid isValidWhenDoesNotHaveTypeNotPresentExceptionReturnsTrue() {\r\n    ClassValue annotation = mock();\r\n    given(annotation.value()).willReturn((Class) InputStream.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    assertThat(attributes.canLoad(annotation)).isTrue();\r\n}\n@Test\r\nvoid validateWhenHasTypeNotPresentExceptionThrowsException() {\r\n    ClassValue annotation = mockAnnotation(ClassValue.class);\r\n    given(annotation.value()).willThrow(TypeNotPresentException.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    assertThatIllegalStateException().isThrownBy(() -> attributes.validate(annotation));\r\n}\n@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid validateWhenDoesNotHaveTypeNotPresentExceptionThrowsNothing() {\r\n    ClassValue annotation = mockAnnotation(ClassValue.class);\r\n    given(annotation.value()).willReturn((Class) InputStream.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    attributes.validate(annotation);\r\n}\nprivate List<Method> getAll(AttributeMethods attributes) {\r\n    List<Method> result = new ArrayList<>(attributes.size());\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        result.add(attributes.get(i));\r\n    }\r\n    return result;\r\n}\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <A extends Annotation> A mockAnnotation(Class<A> annotationType) {\r\n    A annotation = mock(annotationType);\r\n    given(annotation.annotationType()).willReturn((Class) annotationType);\r\n    return annotation;\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NoAttributes {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MultipleAttributes {\r\n\r\n    int intValue();\r\n\r\n    String value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ValueOnly {\r\n\r\n    String value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NonValueOnly {\r\n\r\n    String test();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ClassValue {\r\n\r\n    Class<?> value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ClassArrayValue {\r\n\r\n    Class<?>[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface DefaultValueAttribute {\r\n\r\n    String one();\r\n\r\n    String two();\r\n\r\n    String three() default \"3\";\r\n}",
    "comment": "\n * Tests for {@link AttributeMethods}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#forAnnotationTypeWhenNullReturnsNone()",
    "entityType": "method",
    "code": "@Test\r\nvoid forAnnotationTypeWhenNullReturnsNone() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(null);\r\n    assertThat(methods).isSameAs(AttributeMethods.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#forAnnotationTypeWhenHasNoAttributesReturnsNone()",
    "entityType": "method",
    "code": "@Test\r\nvoid forAnnotationTypeWhenHasNoAttributesReturnsNone() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(NoAttributes.class);\r\n    assertThat(methods).isSameAs(AttributeMethods.NONE);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#forAnnotationTypeWhenHasMultipleAttributesReturnsAttributes()",
    "entityType": "method",
    "code": "@Test\r\nvoid forAnnotationTypeWhenHasMultipleAttributesReturnsAttributes() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.get(\"value\").getName()).isEqualTo(\"value\");\r\n    assertThat(methods.get(\"intValue\").getName()).isEqualTo(\"intValue\");\r\n    assertThat(getAll(methods)).flatExtracting(Method::getName).containsExactly(\"intValue\", \"value\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#indexOfNameReturnsIndex()",
    "entityType": "method",
    "code": "@Test\r\nvoid indexOfNameReturnsIndex() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.indexOf(\"value\")).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#indexOfMethodReturnsIndex()",
    "entityType": "method",
    "code": "@Test\r\nvoid indexOfMethodReturnsIndex() throws Exception {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    Method method = MultipleAttributes.class.getDeclaredMethod(\"value\");\r\n    assertThat(methods.indexOf(method)).isEqualTo(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#sizeReturnsSize()",
    "entityType": "method",
    "code": "@Test\r\nvoid sizeReturnsSize() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.size()).isEqualTo(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#canThrowTypeNotPresentExceptionWhenHasClassAttributeReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid canThrowTypeNotPresentExceptionWhenHasClassAttributeReturnsTrue() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ClassValue.class);\r\n    assertThat(methods.canThrowTypeNotPresentException(0)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#canThrowTypeNotPresentExceptionWhenHasClassArrayAttributeReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid canThrowTypeNotPresentExceptionWhenHasClassArrayAttributeReturnsTrue() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ClassArrayValue.class);\r\n    assertThat(methods.canThrowTypeNotPresentException(0)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#canThrowTypeNotPresentExceptionWhenNotClassOrClassArrayAttributeReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid canThrowTypeNotPresentExceptionWhenNotClassOrClassArrayAttributeReturnsFalse() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(ValueOnly.class);\r\n    assertThat(methods.canThrowTypeNotPresentException(0)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#hasDefaultValueMethodWhenHasDefaultValueMethodReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasDefaultValueMethodWhenHasDefaultValueMethodReturnsTrue() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(DefaultValueAttribute.class);\r\n    assertThat(methods.hasDefaultValueMethod()).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#hasDefaultValueMethodWhenHasNoDefaultValueMethodsReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid hasDefaultValueMethodWhenHasNoDefaultValueMethodsReturnsFalse() {\r\n    AttributeMethods methods = AttributeMethods.forAnnotationType(MultipleAttributes.class);\r\n    assertThat(methods.hasDefaultValueMethod()).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#isValidWhenHasTypeNotPresentExceptionReturnsFalse()",
    "entityType": "method",
    "code": "@Test\r\nvoid isValidWhenHasTypeNotPresentExceptionReturnsFalse() {\r\n    ClassValue annotation = mockAnnotation(ClassValue.class);\r\n    given(annotation.value()).willThrow(TypeNotPresentException.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    assertThat(attributes.canLoad(annotation)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#isValidWhenDoesNotHaveTypeNotPresentExceptionReturnsTrue()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid isValidWhenDoesNotHaveTypeNotPresentExceptionReturnsTrue() {\r\n    ClassValue annotation = mock();\r\n    given(annotation.value()).willReturn((Class) InputStream.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    assertThat(attributes.canLoad(annotation)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#validateWhenHasTypeNotPresentExceptionThrowsException()",
    "entityType": "method",
    "code": "@Test\r\nvoid validateWhenHasTypeNotPresentExceptionThrowsException() {\r\n    ClassValue annotation = mockAnnotation(ClassValue.class);\r\n    given(annotation.value()).willThrow(TypeNotPresentException.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    assertThatIllegalStateException().isThrownBy(() -> attributes.validate(annotation));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#validateWhenDoesNotHaveTypeNotPresentExceptionThrowsNothing()",
    "entityType": "method",
    "code": "@Test\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nvoid validateWhenDoesNotHaveTypeNotPresentExceptionThrowsNothing() {\r\n    ClassValue annotation = mockAnnotation(ClassValue.class);\r\n    given(annotation.value()).willReturn((Class) InputStream.class);\r\n    AttributeMethods attributes = AttributeMethods.forAnnotationType(annotation.annotationType());\r\n    attributes.validate(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#getAll(AttributeMethods)",
    "entityType": "method",
    "code": "private List<Method> getAll(AttributeMethods attributes) {\r\n    List<Method> result = new ArrayList<>(attributes.size());\r\n    for (int i = 0; i < attributes.size(); i++) {\r\n        result.add(attributes.get(i));\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AttributeMethodsTests#mockAnnotation(Class<A>)",
    "entityType": "method",
    "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <A extends Annotation> A mockAnnotation(Class<A> annotationType) {\r\n    A annotation = mock(annotationType);\r\n    given(annotation.annotationType()).willReturn((Class) annotationType);\r\n    return annotation;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid getNonRepeatableAnnotation() {\r\n    expectNonRepeatableAnnotation(() -> getMergedRepeatableAnnotations(getClass(), NonRepeatable.class));\r\n}\n@Test\r\nvoid getInvalidRepeatableAnnotationContainerMissingValueAttribute() {\r\n    expectContainerMissingValueAttribute(() -> getMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerMissingValueAttribute.class));\r\n}\n@Test\r\nvoid getInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute() {\r\n    expectContainerWithNonArrayValueAttribute(() -> getMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithNonArrayValueAttribute.class));\r\n}\n@Test\r\nvoid getInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType() {\r\n    expectContainerWithArrayValueAttributeButWrongComponentType(() -> getMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithArrayValueAttributeButWrongComponentType.class));\r\n}\n@Test\r\nvoid getRepeatableAnnotationsOnClass() {\r\n    assertGetRepeatableAnnotations(RepeatableClass.class);\r\n}\n@Test\r\nvoid getRepeatableAnnotationsOnSuperclass() {\r\n    assertGetRepeatableAnnotations(SubRepeatableClass.class);\r\n}\n@Test\r\nvoid getComposedRepeatableAnnotationsOnClass() {\r\n    assertGetRepeatableAnnotations(ComposedRepeatableClass.class);\r\n}\n@Test\r\nvoid getComposedRepeatableAnnotationsMixedWithContainerOnClass() {\r\n    assertGetRepeatableAnnotations(ComposedRepeatableMixedWithContainerClass.class);\r\n}\n@Test\r\nvoid getComposedContainerForRepeatableAnnotationsOnClass() {\r\n    assertGetRepeatableAnnotations(ComposedContainerClass.class);\r\n}\n@Test\r\nvoid getNoninheritedComposedRepeatableAnnotationsOnClass() {\r\n    Class<?> element = NoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = getMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertNoninheritedRepeatableAnnotations(annotations);\r\n}\n@Test\r\nvoid getNoninheritedComposedRepeatableAnnotationsOnSuperclass() {\r\n    Class<?> element = SubNoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = getMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertThat(annotations).isNotNull();\r\n    assertThat(annotations).isEmpty();\r\n}\n@Test\r\nvoid findNonRepeatableAnnotation() {\r\n    expectNonRepeatableAnnotation(() -> findMergedRepeatableAnnotations(getClass(), NonRepeatable.class));\r\n}\n@Test\r\nvoid findInvalidRepeatableAnnotationContainerMissingValueAttribute() {\r\n    expectContainerMissingValueAttribute(() -> findMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerMissingValueAttribute.class));\r\n}\n@Test\r\nvoid findInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute() {\r\n    expectContainerWithNonArrayValueAttribute(() -> findMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithNonArrayValueAttribute.class));\r\n}\n@Test\r\nvoid findInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType() {\r\n    expectContainerWithArrayValueAttributeButWrongComponentType(() -> findMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithArrayValueAttributeButWrongComponentType.class));\r\n}\n@Test\r\nvoid findRepeatableAnnotationsOnClass() {\r\n    assertFindRepeatableAnnotations(RepeatableClass.class);\r\n}\n@Test\r\nvoid findRepeatableAnnotationsOnSuperclass() {\r\n    assertFindRepeatableAnnotations(SubRepeatableClass.class);\r\n}\n@Test\r\nvoid findComposedRepeatableAnnotationsOnClass() {\r\n    assertFindRepeatableAnnotations(ComposedRepeatableClass.class);\r\n}\n@Test\r\nvoid findComposedRepeatableAnnotationsMixedWithContainerOnClass() {\r\n    assertFindRepeatableAnnotations(ComposedRepeatableMixedWithContainerClass.class);\r\n}\n@Test\r\nvoid findNoninheritedComposedRepeatableAnnotationsOnClass() {\r\n    Class<?> element = NoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = findMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertNoninheritedRepeatableAnnotations(annotations);\r\n}\n@Test\r\nvoid findNoninheritedComposedRepeatableAnnotationsOnSuperclass() {\r\n    Class<?> element = SubNoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = findMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertNoninheritedRepeatableAnnotations(annotations);\r\n}\n@Test\r\nvoid findComposedContainerForRepeatableAnnotationsOnClass() {\r\n    assertFindRepeatableAnnotations(ComposedContainerClass.class);\r\n}\nprivate void expectNonRepeatableAnnotation(ThrowingCallable throwingCallable) {\r\n    assertThatIllegalArgumentException().isThrownBy(throwingCallable).withMessageStartingWith(\"Annotation type must be a repeatable annotation\").withMessageContaining(\"failed to resolve container type for\").withMessageContaining(NonRepeatable.class.getName());\r\n}\nprivate void expectContainerMissingValueAttribute(ThrowingCallable throwingCallable) {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(throwingCallable).withMessageStartingWith(\"Invalid declaration of container type\").withMessageContaining(ContainerMissingValueAttribute.class.getName()).withMessageContaining(\"for repeatable annotation\").withMessageContaining(InvalidRepeatable.class.getName()).withCauseExactlyInstanceOf(NoSuchMethodException.class);\r\n}\nprivate void expectContainerWithNonArrayValueAttribute(ThrowingCallable throwingCallable) {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(throwingCallable).withMessageStartingWith(\"Container type\").withMessageContaining(ContainerWithNonArrayValueAttribute.class.getName()).withMessageContaining(\"must declare a 'value' attribute for an array of type\").withMessageContaining(InvalidRepeatable.class.getName());\r\n}\nprivate void expectContainerWithArrayValueAttributeButWrongComponentType(ThrowingCallable throwingCallable) {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(throwingCallable).withMessageStartingWith(\"Container type\").withMessageContaining(ContainerWithArrayValueAttributeButWrongComponentType.class.getName()).withMessageContaining(\"must declare a 'value' attribute for an array of type\").withMessageContaining(InvalidRepeatable.class.getName());\r\n}\nprivate void assertGetRepeatableAnnotations(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<PeteRepeat> peteRepeats = getMergedRepeatableAnnotations(element, PeteRepeat.class);\r\n    assertThat(peteRepeats).isNotNull();\r\n    assertThat(peteRepeats).hasSize(3);\r\n    Iterator<PeteRepeat> iterator = peteRepeats.iterator();\r\n    assertThat(iterator.next().value()).isEqualTo(\"A\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"B\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"C\");\r\n}\nprivate void assertFindRepeatableAnnotations(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<PeteRepeat> peteRepeats = findMergedRepeatableAnnotations(element, PeteRepeat.class);\r\n    assertThat(peteRepeats).isNotNull();\r\n    assertThat(peteRepeats).hasSize(3);\r\n    Iterator<PeteRepeat> iterator = peteRepeats.iterator();\r\n    assertThat(iterator.next().value()).isEqualTo(\"A\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"B\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"C\");\r\n}\nprivate void assertNoninheritedRepeatableAnnotations(Set<Noninherited> annotations) {\r\n    assertThat(annotations).isNotNull();\r\n    assertThat(annotations).hasSize(3);\r\n    Iterator<Noninherited> iterator = annotations.iterator();\r\n    assertThat(iterator.next().value()).isEqualTo(\"A\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"B\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"C\");\r\n}\n// -------------------------------------------------------------------------\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface NonRepeatable {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ContainerMissingValueAttribute {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ContainerWithNonArrayValueAttribute {\r\n\r\n    InvalidRepeatable value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ContainerWithArrayValueAttributeButWrongComponentType {\r\n\r\n    String[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface InvalidRepeatable {\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface PeteRepeats {\r\n\r\n    PeteRepeat[] value();\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@Repeatable(PeteRepeats.class)\r\n@interface PeteRepeat {\r\n\r\n    String value();\r\n}\n@PeteRepeat(\"shadowed\")\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface ForPetesSake {\r\n\r\n    @AliasFor(annotation = PeteRepeat.class)\r\n    String value();\r\n}\n@PeteRepeat(\"shadowed\")\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface ForTheLoveOfFoo {\r\n\r\n    @AliasFor(annotation = PeteRepeat.class)\r\n    String value();\r\n}\n@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\r\n@Target({ ElementType.METHOD, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Inherited\r\n@interface ComposedContainer {\r\n}\n@PeteRepeat(\"A\")\r\n@PeteRepeats({ @PeteRepeat(\"B\"), @PeteRepeat(\"C\") })\r\nstatic class RepeatableClass {\r\n}\nstatic class SubRepeatableClass extends RepeatableClass {\r\n}\n@ForPetesSake(\"B\")\r\n@ForTheLoveOfFoo(\"C\")\r\n@PeteRepeat(\"A\")\r\nstatic class ComposedRepeatableClass {\r\n}\n@ForPetesSake(\"C\")\r\n@PeteRepeats(@PeteRepeat(\"A\"))\r\n@PeteRepeat(\"B\")\r\nstatic class ComposedRepeatableMixedWithContainerClass {\r\n}\n@PeteRepeat(\"A\")\r\n@ComposedContainer\r\nstatic class ComposedContainerClass {\r\n}\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface Noninheriteds {\r\n\r\n    Noninherited[] value();\r\n}\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(Noninheriteds.class)\r\n@interface Noninherited {\r\n\r\n    @AliasFor(\"name\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(\"value\")\r\n    String name() default \"\";\r\n}\n@Noninherited(name = \"shadowed\")\r\n@Target(ElementType.TYPE)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface ComposedNoninherited {\r\n\r\n    @AliasFor(annotation = Noninherited.class)\r\n    String name() default \"\";\r\n}\n@ComposedNoninherited(name = \"C\")\r\n@Noninheriteds({ @Noninherited(value = \"A\"), @Noninherited(name = \"B\") })\r\nstatic class NoninheritedRepeatableClass {\r\n}\nstatic class SubNoninheritedRepeatableClass extends NoninheritedRepeatableClass {\r\n}",
    "comment": "\n * Unit tests that verify support for getting and finding all composed, repeatable\n * annotations on a single annotated element.\n *\n * <p>See <a href=\"https://jira.spring.io/browse/SPR-13973\">SPR-13973</a>.\n *\n * @author Sam Brannen\n * @since 4.3\n * @see AnnotatedElementUtils#getMergedRepeatableAnnotations\n * @see AnnotatedElementUtils#findMergedRepeatableAnnotations\n * @see AnnotatedElementUtilsTests\n * @see MultipleComposedAnnotationsOnSingleAnnotatedElementTests\n "
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getNonRepeatableAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid getNonRepeatableAnnotation() {\r\n    expectNonRepeatableAnnotation(() -> getMergedRepeatableAnnotations(getClass(), NonRepeatable.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getInvalidRepeatableAnnotationContainerMissingValueAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInvalidRepeatableAnnotationContainerMissingValueAttribute() {\r\n    expectContainerMissingValueAttribute(() -> getMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerMissingValueAttribute.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute() {\r\n    expectContainerWithNonArrayValueAttribute(() -> getMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithNonArrayValueAttribute.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType()",
    "entityType": "method",
    "code": "@Test\r\nvoid getInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType() {\r\n    expectContainerWithArrayValueAttributeButWrongComponentType(() -> getMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithArrayValueAttributeButWrongComponentType.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsOnClass() {\r\n    assertGetRepeatableAnnotations(RepeatableClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getRepeatableAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getRepeatableAnnotationsOnSuperclass() {\r\n    assertGetRepeatableAnnotations(SubRepeatableClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getComposedRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComposedRepeatableAnnotationsOnClass() {\r\n    assertGetRepeatableAnnotations(ComposedRepeatableClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getComposedRepeatableAnnotationsMixedWithContainerOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComposedRepeatableAnnotationsMixedWithContainerOnClass() {\r\n    assertGetRepeatableAnnotations(ComposedRepeatableMixedWithContainerClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getComposedContainerForRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getComposedContainerForRepeatableAnnotationsOnClass() {\r\n    assertGetRepeatableAnnotations(ComposedContainerClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getNoninheritedComposedRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getNoninheritedComposedRepeatableAnnotationsOnClass() {\r\n    Class<?> element = NoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = getMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertNoninheritedRepeatableAnnotations(annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#getNoninheritedComposedRepeatableAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid getNoninheritedComposedRepeatableAnnotationsOnSuperclass() {\r\n    Class<?> element = SubNoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = getMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertThat(annotations).isNotNull();\r\n    assertThat(annotations).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findNonRepeatableAnnotation()",
    "entityType": "method",
    "code": "@Test\r\nvoid findNonRepeatableAnnotation() {\r\n    expectNonRepeatableAnnotation(() -> findMergedRepeatableAnnotations(getClass(), NonRepeatable.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findInvalidRepeatableAnnotationContainerMissingValueAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid findInvalidRepeatableAnnotationContainerMissingValueAttribute() {\r\n    expectContainerMissingValueAttribute(() -> findMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerMissingValueAttribute.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute()",
    "entityType": "method",
    "code": "@Test\r\nvoid findInvalidRepeatableAnnotationContainerWithNonArrayValueAttribute() {\r\n    expectContainerWithNonArrayValueAttribute(() -> findMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithNonArrayValueAttribute.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType()",
    "entityType": "method",
    "code": "@Test\r\nvoid findInvalidRepeatableAnnotationContainerWithArrayValueAttributeButWrongComponentType() {\r\n    expectContainerWithArrayValueAttributeButWrongComponentType(() -> findMergedRepeatableAnnotations(getClass(), InvalidRepeatable.class, ContainerWithArrayValueAttributeButWrongComponentType.class));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findRepeatableAnnotationsOnClass() {\r\n    assertFindRepeatableAnnotations(RepeatableClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findRepeatableAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findRepeatableAnnotationsOnSuperclass() {\r\n    assertFindRepeatableAnnotations(SubRepeatableClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findComposedRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findComposedRepeatableAnnotationsOnClass() {\r\n    assertFindRepeatableAnnotations(ComposedRepeatableClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findComposedRepeatableAnnotationsMixedWithContainerOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findComposedRepeatableAnnotationsMixedWithContainerOnClass() {\r\n    assertFindRepeatableAnnotations(ComposedRepeatableMixedWithContainerClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findNoninheritedComposedRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findNoninheritedComposedRepeatableAnnotationsOnClass() {\r\n    Class<?> element = NoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = findMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertNoninheritedRepeatableAnnotations(annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findNoninheritedComposedRepeatableAnnotationsOnSuperclass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findNoninheritedComposedRepeatableAnnotationsOnSuperclass() {\r\n    Class<?> element = SubNoninheritedRepeatableClass.class;\r\n    Set<Noninherited> annotations = findMergedRepeatableAnnotations(element, Noninherited.class);\r\n    assertNoninheritedRepeatableAnnotations(annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#findComposedContainerForRepeatableAnnotationsOnClass()",
    "entityType": "method",
    "code": "@Test\r\nvoid findComposedContainerForRepeatableAnnotationsOnClass() {\r\n    assertFindRepeatableAnnotations(ComposedContainerClass.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#expectNonRepeatableAnnotation(ThrowingCallable)",
    "entityType": "method",
    "code": "private void expectNonRepeatableAnnotation(ThrowingCallable throwingCallable) {\r\n    assertThatIllegalArgumentException().isThrownBy(throwingCallable).withMessageStartingWith(\"Annotation type must be a repeatable annotation\").withMessageContaining(\"failed to resolve container type for\").withMessageContaining(NonRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#expectContainerMissingValueAttribute(ThrowingCallable)",
    "entityType": "method",
    "code": "private void expectContainerMissingValueAttribute(ThrowingCallable throwingCallable) {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(throwingCallable).withMessageStartingWith(\"Invalid declaration of container type\").withMessageContaining(ContainerMissingValueAttribute.class.getName()).withMessageContaining(\"for repeatable annotation\").withMessageContaining(InvalidRepeatable.class.getName()).withCauseExactlyInstanceOf(NoSuchMethodException.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#expectContainerWithNonArrayValueAttribute(ThrowingCallable)",
    "entityType": "method",
    "code": "private void expectContainerWithNonArrayValueAttribute(ThrowingCallable throwingCallable) {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(throwingCallable).withMessageStartingWith(\"Container type\").withMessageContaining(ContainerWithNonArrayValueAttribute.class.getName()).withMessageContaining(\"must declare a 'value' attribute for an array of type\").withMessageContaining(InvalidRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#expectContainerWithArrayValueAttributeButWrongComponentType(ThrowingCallable)",
    "entityType": "method",
    "code": "private void expectContainerWithArrayValueAttributeButWrongComponentType(ThrowingCallable throwingCallable) {\r\n    assertThatExceptionOfType(AnnotationConfigurationException.class).isThrownBy(throwingCallable).withMessageStartingWith(\"Container type\").withMessageContaining(ContainerWithArrayValueAttributeButWrongComponentType.class.getName()).withMessageContaining(\"must declare a 'value' attribute for an array of type\").withMessageContaining(InvalidRepeatable.class.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#assertGetRepeatableAnnotations(AnnotatedElement)",
    "entityType": "method",
    "code": "private void assertGetRepeatableAnnotations(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<PeteRepeat> peteRepeats = getMergedRepeatableAnnotations(element, PeteRepeat.class);\r\n    assertThat(peteRepeats).isNotNull();\r\n    assertThat(peteRepeats).hasSize(3);\r\n    Iterator<PeteRepeat> iterator = peteRepeats.iterator();\r\n    assertThat(iterator.next().value()).isEqualTo(\"A\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"B\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"C\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#assertFindRepeatableAnnotations(AnnotatedElement)",
    "entityType": "method",
    "code": "private void assertFindRepeatableAnnotations(AnnotatedElement element) {\r\n    assertThat(element).isNotNull();\r\n    Set<PeteRepeat> peteRepeats = findMergedRepeatableAnnotations(element, PeteRepeat.class);\r\n    assertThat(peteRepeats).isNotNull();\r\n    assertThat(peteRepeats).hasSize(3);\r\n    Iterator<PeteRepeat> iterator = peteRepeats.iterator();\r\n    assertThat(iterator.next().value()).isEqualTo(\"A\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"B\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"C\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableAnnotationsTests#assertNoninheritedRepeatableAnnotations(Set<Noninherited>)",
    "entityType": "method",
    "code": "private void assertNoninheritedRepeatableAnnotations(Set<Noninherited> annotations) {\r\n    assertThat(annotations).isNotNull();\r\n    assertThat(annotations).hasSize(3);\r\n    Iterator<Noninherited> iterator = annotations.iterator();\r\n    assertThat(iterator.next().value()).isEqualTo(\"A\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"B\");\r\n    assertThat(iterator.next().value()).isEqualTo(\"C\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.RepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedRepeatableMixedWithContainerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.ComposedContainerClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.NoninheritedRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.SubNoninheritedRepeatableClass",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationClassLoaderTests",
    "entityType": "class",
    "code": "private static final String TEST_ANNOTATION = TestAnnotation.class.getName();\nprivate static final String TEST_META_ANNOTATION = TestMetaAnnotation.class.getName();\nprivate static final String WITH_TEST_ANNOTATION = WithTestAnnotation.class.getName();\nprivate static final String TEST_REFERENCE = TestReference.class.getName();\n@Test\r\nvoid synthesizedUsesCorrectClassLoader() throws Exception {\r\n    ClassLoader parent = getClass().getClassLoader();\r\n    TestClassLoader child = new TestClassLoader(parent);\r\n    Class<?> source = child.loadClass(WITH_TEST_ANNOTATION);\r\n    Annotation annotation = getDeclaredAnnotation(source, TEST_ANNOTATION);\r\n    Annotation metaAnnotation = getDeclaredAnnotation(annotation.annotationType(), TEST_META_ANNOTATION);\r\n    // We should have loaded the source and initial annotation from child\r\n    assertThat(source.getClassLoader()).isEqualTo(child);\r\n    assertThat(annotation.getClass().getClassLoader()).isEqualTo(child);\r\n    assertThat(annotation.annotationType().getClassLoader()).isEqualTo(child);\r\n    // The meta-annotation should have been loaded by the parent\r\n    assertThat(metaAnnotation.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(metaAnnotation.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getEnumAttribute(metaAnnotation).getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getClassAttribute(metaAnnotation).getClassLoader()).isEqualTo(child);\r\n    // MergedAnnotation should follow the same class loader logic\r\n    MergedAnnotations mergedAnnotations = MergedAnnotations.from(source);\r\n    Annotation synthesized = mergedAnnotations.get(TEST_ANNOTATION).synthesize();\r\n    Annotation synthesizedMeta = mergedAnnotations.get(TEST_META_ANNOTATION).synthesize();\r\n    assertThat(synthesized.getClass().getClassLoader()).isEqualTo(child);\r\n    assertThat(synthesized.annotationType().getClassLoader()).isEqualTo(child);\r\n    assertThat(synthesizedMeta.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(synthesizedMeta.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getClassAttribute(synthesizedMeta).getClassLoader()).isEqualTo(child);\r\n    assertThat(getEnumAttribute(synthesizedMeta).getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(synthesized).isEqualTo(annotation);\r\n    assertThat(synthesizedMeta).isEqualTo(metaAnnotation);\r\n    // Also check utils version\r\n    Annotation utilsMeta = AnnotatedElementUtils.getMergedAnnotation(source, TestMetaAnnotation.class);\r\n    assertThat(utilsMeta.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getClassAttribute(utilsMeta).getClassLoader()).isEqualTo(child);\r\n    assertThat(getEnumAttribute(utilsMeta).getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(utilsMeta).isEqualTo(metaAnnotation);\r\n}\nprivate Class<?> getClassAttribute(Annotation annotation) throws Exception {\r\n    return (Class<?>) getAttributeValue(annotation, \"classValue\");\r\n}\nprivate Enum<?> getEnumAttribute(Annotation annotation) throws Exception {\r\n    return (Enum<?>) getAttributeValue(annotation, \"enumValue\");\r\n}\nprivate Object getAttributeValue(Annotation annotation, String name) throws Exception {\r\n    Method classValueMethod = annotation.annotationType().getDeclaredMethod(name);\r\n    classValueMethod.setAccessible(true);\r\n    return classValueMethod.invoke(annotation);\r\n}\nprivate Annotation getDeclaredAnnotation(Class<?> element, String annotationType) {\r\n    for (Annotation annotation : element.getDeclaredAnnotations()) {\r\n        if (annotation.annotationType().getName().equals(annotationType)) {\r\n            return annotation;\r\n        }\r\n    }\r\n    return null;\r\n}\nprivate static class TestClassLoader extends OverridingClassLoader {\r\n\r\n    public TestClassLoader(ClassLoader parent) {\r\n        super(parent);\r\n    }\r\n\r\n    @Override\r\n    protected boolean isEligibleForOverriding(String className) {\r\n        return WITH_TEST_ANNOTATION.equals(className) || TEST_ANNOTATION.equals(className) || TEST_REFERENCE.equals(className);\r\n    }\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestMetaAnnotation {\r\n\r\n    @AliasFor(\"d\")\r\n    String c() default \"\";\r\n\r\n    @AliasFor(\"c\")\r\n    String d() default \"\";\r\n\r\n    Class<?> classValue();\r\n\r\n    TestEnum enumValue();\r\n}\n@TestMetaAnnotation(classValue = TestReference.class, enumValue = TestEnum.TWO)\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestAnnotation {\r\n\r\n    @AliasFor(\"b\")\r\n    String a() default \"\";\r\n\r\n    @AliasFor(\"a\")\r\n    String b() default \"\";\r\n}\n@TestAnnotation\r\nstatic class WithTestAnnotation {\r\n}\nstatic class TestReference {\r\n}\nenum TestEnum {\r\n\r\n    ONE, TWO, THREE\r\n}",
    "comment": "\n * Tests for {@link MergedAnnotation} to ensure the correct class loader is\n * used.\n *\n * @author Phillip Webb\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationClassLoaderTests#synthesizedUsesCorrectClassLoader()",
    "entityType": "method",
    "code": "@Test\r\nvoid synthesizedUsesCorrectClassLoader() throws Exception {\r\n    ClassLoader parent = getClass().getClassLoader();\r\n    TestClassLoader child = new TestClassLoader(parent);\r\n    Class<?> source = child.loadClass(WITH_TEST_ANNOTATION);\r\n    Annotation annotation = getDeclaredAnnotation(source, TEST_ANNOTATION);\r\n    Annotation metaAnnotation = getDeclaredAnnotation(annotation.annotationType(), TEST_META_ANNOTATION);\r\n    // We should have loaded the source and initial annotation from child\r\n    assertThat(source.getClassLoader()).isEqualTo(child);\r\n    assertThat(annotation.getClass().getClassLoader()).isEqualTo(child);\r\n    assertThat(annotation.annotationType().getClassLoader()).isEqualTo(child);\r\n    // The meta-annotation should have been loaded by the parent\r\n    assertThat(metaAnnotation.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(metaAnnotation.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getEnumAttribute(metaAnnotation).getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getClassAttribute(metaAnnotation).getClassLoader()).isEqualTo(child);\r\n    // MergedAnnotation should follow the same class loader logic\r\n    MergedAnnotations mergedAnnotations = MergedAnnotations.from(source);\r\n    Annotation synthesized = mergedAnnotations.get(TEST_ANNOTATION).synthesize();\r\n    Annotation synthesizedMeta = mergedAnnotations.get(TEST_META_ANNOTATION).synthesize();\r\n    assertThat(synthesized.getClass().getClassLoader()).isEqualTo(child);\r\n    assertThat(synthesized.annotationType().getClassLoader()).isEqualTo(child);\r\n    assertThat(synthesizedMeta.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(synthesizedMeta.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getClassAttribute(synthesizedMeta).getClassLoader()).isEqualTo(child);\r\n    assertThat(getEnumAttribute(synthesizedMeta).getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(synthesized).isEqualTo(annotation);\r\n    assertThat(synthesizedMeta).isEqualTo(metaAnnotation);\r\n    // Also check utils version\r\n    Annotation utilsMeta = AnnotatedElementUtils.getMergedAnnotation(source, TestMetaAnnotation.class);\r\n    assertThat(utilsMeta.getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(getClassAttribute(utilsMeta).getClassLoader()).isEqualTo(child);\r\n    assertThat(getEnumAttribute(utilsMeta).getClass().getClassLoader()).isEqualTo(parent);\r\n    assertThat(utilsMeta).isEqualTo(metaAnnotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationClassLoaderTests#getClassAttribute(Annotation)",
    "entityType": "method",
    "code": "private Class<?> getClassAttribute(Annotation annotation) throws Exception {\r\n    return (Class<?>) getAttributeValue(annotation, \"classValue\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationClassLoaderTests#getEnumAttribute(Annotation)",
    "entityType": "method",
    "code": "private Enum<?> getEnumAttribute(Annotation annotation) throws Exception {\r\n    return (Enum<?>) getAttributeValue(annotation, \"enumValue\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationClassLoaderTests#getAttributeValue(Annotation,String)",
    "entityType": "method",
    "code": "private Object getAttributeValue(Annotation annotation, String name) throws Exception {\r\n    Method classValueMethod = annotation.annotationType().getDeclaredMethod(name);\r\n    classValueMethod.setAccessible(true);\r\n    return classValueMethod.invoke(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationClassLoaderTests#getDeclaredAnnotation(Class<?>,String)",
    "entityType": "method",
    "code": "private Annotation getDeclaredAnnotation(Class<?> element, String annotationType) {\r\n    for (Annotation annotation : element.getDeclaredAnnotations()) {\r\n        if (annotation.annotationType().getName().equals(annotationType)) {\r\n            return annotation;\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TestClassLoader",
    "entityType": "class",
    "code": "public TestClassLoader(ClassLoader parent) {\r\n    super(parent);\r\n}\n@Override\r\nprotected boolean isEligibleForOverriding(String className) {\r\n    return WITH_TEST_ANNOTATION.equals(className) || TEST_ANNOTATION.equals(className) || TEST_REFERENCE.equals(className);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TestClassLoader#isEligibleForOverriding(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean isEligibleForOverriding(String className) {\r\n    return WITH_TEST_ANNOTATION.equals(className) || TEST_ANNOTATION.equals(className) || TEST_REFERENCE.equals(className);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithTestAnnotation",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.TestReference",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid toAnnotationSetCollectsLinkedHashSetWithSynthesizedAnnotations() {\r\n    Set<TestAnnotation> set = stream().collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    assertThat(set).isInstanceOf(LinkedHashSet.class).flatExtracting(TestAnnotation::value).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(set).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n}\n@Test\r\nvoid toAnnotationArrayCollectsAnnotationArrayWithSynthesizedAnnotations() {\r\n    Annotation[] array = stream().collect(MergedAnnotationCollectors.toAnnotationArray());\r\n    assertThat(Arrays.stream(array).map(annotation -> ((TestAnnotation) annotation).value())).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(array).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n}\n@Test\r\nvoid toSuppliedAnnotationArrayCollectsAnnotationArrayWithSynthesizedAnnotations() {\r\n    TestAnnotation[] array = stream().collect(MergedAnnotationCollectors.toAnnotationArray(TestAnnotation[]::new));\r\n    assertThat(Arrays.stream(array).map(TestAnnotation::value)).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(array).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n}\n@Test\r\nvoid toMultiValueMapCollectsMultiValueMap() {\r\n    MultiValueMap<String, Object> map = stream().map(MergedAnnotation::filterDefaultValues).collect(MergedAnnotationCollectors.toMultiValueMap(Adapt.CLASS_TO_STRING));\r\n    assertThat(map.get(\"value\")).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(map.get(\"extra\")).containsExactly(\"java.lang.String\", \"java.lang.Integer\");\r\n}\n@Test\r\nvoid toFinishedMultiValueMapCollectsMultiValueMap() {\r\n    MultiValueMap<String, Object> map = stream().collect(MergedAnnotationCollectors.toMultiValueMap(result -> {\r\n        result.add(\"finished\", true);\r\n        return result;\r\n    }));\r\n    assertThat(map.get(\"value\")).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(map.get(\"extra\")).containsExactly(void.class, String.class, Integer.class);\r\n    assertThat(map.get(\"finished\")).containsExactly(true);\r\n}\nprivate Stream<MergedAnnotation<TestAnnotation>> stream() {\r\n    return MergedAnnotations.from(WithTestAnnotations.class).stream(TestAnnotation.class);\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(TestAnnotations.class)\r\n@interface TestAnnotation {\r\n\r\n    @AliasFor(\"name\")\r\n    String value() default \"\";\r\n\r\n    @AliasFor(\"value\")\r\n    String name() default \"\";\r\n\r\n    Class<?> extra() default void.class;\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestAnnotations {\r\n\r\n    TestAnnotation[] value();\r\n}\n@TestAnnotation(\"a\")\r\n@TestAnnotation(name = \"b\", extra = String.class)\r\n@TestAnnotation(name = \"c\", extra = Integer.class)\r\nstatic class WithTestAnnotations {\r\n}",
    "comment": "\n * Tests for {@link MergedAnnotationCollectors}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests#toAnnotationSetCollectsLinkedHashSetWithSynthesizedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid toAnnotationSetCollectsLinkedHashSetWithSynthesizedAnnotations() {\r\n    Set<TestAnnotation> set = stream().collect(MergedAnnotationCollectors.toAnnotationSet());\r\n    assertThat(set).isInstanceOf(LinkedHashSet.class).flatExtracting(TestAnnotation::value).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(set).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests#toAnnotationArrayCollectsAnnotationArrayWithSynthesizedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid toAnnotationArrayCollectsAnnotationArrayWithSynthesizedAnnotations() {\r\n    Annotation[] array = stream().collect(MergedAnnotationCollectors.toAnnotationArray());\r\n    assertThat(Arrays.stream(array).map(annotation -> ((TestAnnotation) annotation).value())).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(array).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests#toSuppliedAnnotationArrayCollectsAnnotationArrayWithSynthesizedAnnotations()",
    "entityType": "method",
    "code": "@Test\r\nvoid toSuppliedAnnotationArrayCollectsAnnotationArrayWithSynthesizedAnnotations() {\r\n    TestAnnotation[] array = stream().collect(MergedAnnotationCollectors.toAnnotationArray(TestAnnotation[]::new));\r\n    assertThat(Arrays.stream(array).map(TestAnnotation::value)).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(array).allMatch(AnnotationUtils::isSynthesizedAnnotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests#toMultiValueMapCollectsMultiValueMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid toMultiValueMapCollectsMultiValueMap() {\r\n    MultiValueMap<String, Object> map = stream().map(MergedAnnotation::filterDefaultValues).collect(MergedAnnotationCollectors.toMultiValueMap(Adapt.CLASS_TO_STRING));\r\n    assertThat(map.get(\"value\")).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(map.get(\"extra\")).containsExactly(\"java.lang.String\", \"java.lang.Integer\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests#toFinishedMultiValueMapCollectsMultiValueMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid toFinishedMultiValueMapCollectsMultiValueMap() {\r\n    MultiValueMap<String, Object> map = stream().collect(MergedAnnotationCollectors.toMultiValueMap(result -> {\r\n        result.add(\"finished\", true);\r\n        return result;\r\n    }));\r\n    assertThat(map.get(\"value\")).containsExactly(\"a\", \"b\", \"c\");\r\n    assertThat(map.get(\"extra\")).containsExactly(void.class, String.class, Integer.class);\r\n    assertThat(map.get(\"finished\")).containsExactly(true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectorsTests#stream()",
    "entityType": "method",
    "code": "private Stream<MergedAnnotation<TestAnnotation>> stream() {\r\n    return MergedAnnotations.from(WithTestAnnotations.class).stream(TestAnnotation.class);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.WithTestAnnotations",
    "entityType": "class",
    "code": "",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests",
    "entityType": "class",
    "code": "@Test\r\nvoid typeInStringArrayWhenNameMatchesAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(TestAnnotation.class.getName())).accepts(annotation);\r\n}\n@Test\r\nvoid typeInStringArrayWhenNameDoesNotMatchRejects() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(MissingAnnotation.class.getName())).rejects(annotation);\r\n}\n@Test\r\nvoid typeInClassArrayWhenNameMatchesAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(TestAnnotation.class)).accepts(annotation);\r\n}\n@Test\r\nvoid typeInClassArrayWhenNameDoesNotMatchRejects() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(MissingAnnotation.class)).rejects(annotation);\r\n}\n@Test\r\nvoid typeInCollectionWhenMatchesStringInCollectionAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(Collections.singleton(TestAnnotation.class.getName()))).accepts(annotation);\r\n}\n@Test\r\nvoid typeInCollectionWhenMatchesClassInCollectionAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(Collections.singleton(TestAnnotation.class))).accepts(annotation);\r\n}\n@Test\r\nvoid typeInCollectionWhenDoesNotMatchAnyRejects() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(Arrays.asList(MissingAnnotation.class.getName(), MissingAnnotation.class))).rejects(annotation);\r\n}\n@Test\r\nvoid firstRunOfAcceptsOnlyFirstRun() {\r\n    List<MergedAnnotation<TestAnnotation>> filtered = MergedAnnotations.from(WithMultipleTestAnnotation.class).stream(TestAnnotation.class).filter(MergedAnnotationPredicates.firstRunOf(this::firstCharOfValue)).toList();\r\n    assertThat(filtered.stream().map(annotation -> annotation.getString(\"value\"))).containsExactly(\"a1\", \"a2\", \"a3\");\r\n}\n@Test\r\nvoid firstRunOfWhenValueExtractorIsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotationPredicates.firstRunOf(null));\r\n}\n@Test\r\nvoid uniqueAcceptsUniquely() {\r\n    List<MergedAnnotation<TestAnnotation>> filtered = MergedAnnotations.from(WithMultipleTestAnnotation.class).stream(TestAnnotation.class).filter(MergedAnnotationPredicates.unique(this::firstCharOfValue)).toList();\r\n    assertThat(filtered.stream().map(annotation -> annotation.getString(\"value\"))).containsExactly(\"a1\", \"b1\", \"c1\");\r\n}\n@Test\r\nvoid uniqueWhenKeyExtractorIsNullThrowsException() {\r\n    assertThatIllegalArgumentException().isThrownBy(() -> MergedAnnotationPredicates.unique(null));\r\n}\nprivate char firstCharOfValue(MergedAnnotation<TestAnnotation> annotation) {\r\n    return annotation.getString(\"value\").charAt(0);\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@Repeatable(TestAnnotations.class)\r\n@interface TestAnnotation {\r\n\r\n    String value() default \"\";\r\n}\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface TestAnnotations {\r\n\r\n    TestAnnotation[] value();\r\n}\n@interface MissingAnnotation {\r\n}\n@TestAnnotation(\"test\")\r\nstatic class WithTestAnnotation {\r\n}\n@TestAnnotation(\"a1\")\r\n@TestAnnotation(\"a2\")\r\n@TestAnnotation(\"a3\")\r\n@TestAnnotation(\"b1\")\r\n@TestAnnotation(\"b2\")\r\n@TestAnnotation(\"b3\")\r\n@TestAnnotation(\"c1\")\r\n@TestAnnotation(\"c2\")\r\n@TestAnnotation(\"c3\")\r\nstatic class WithMultipleTestAnnotation {\r\n}",
    "comment": "\n * Tests for {@link MergedAnnotationPredicates}.\n *\n * @author Phillip Webb\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInStringArrayWhenNameMatchesAccepts()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInStringArrayWhenNameMatchesAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(TestAnnotation.class.getName())).accepts(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInStringArrayWhenNameDoesNotMatchRejects()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInStringArrayWhenNameDoesNotMatchRejects() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(MissingAnnotation.class.getName())).rejects(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInClassArrayWhenNameMatchesAccepts()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInClassArrayWhenNameMatchesAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(TestAnnotation.class)).accepts(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInClassArrayWhenNameDoesNotMatchRejects()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInClassArrayWhenNameDoesNotMatchRejects() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(MissingAnnotation.class)).rejects(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInCollectionWhenMatchesStringInCollectionAccepts()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInCollectionWhenMatchesStringInCollectionAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(Collections.singleton(TestAnnotation.class.getName()))).accepts(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInCollectionWhenMatchesClassInCollectionAccepts()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInCollectionWhenMatchesClassInCollectionAccepts() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(Collections.singleton(TestAnnotation.class))).accepts(annotation);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicatesTests#typeInCollectionWhenDoesNotMatchAnyRejects()",
    "entityType": "method",
    "code": "@Test\r\nvoid typeInCollectionWhenDoesNotMatchAnyRejects() {\r\n    MergedAnnotation<TestAnnotation> annotation = MergedAnnotations.from(WithTestAnnotation.class).get(TestAnnotation.class);\r\n    assertThat(MergedAnnotationPredicates.typeIn(Arrays.asList(MissingAnnotation.class.getName(), MissingAnnotation.class))).rejects(annotation);\r\n}",
    "comment": ""
  }
]