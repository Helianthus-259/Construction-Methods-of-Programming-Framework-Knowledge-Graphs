[
  {
    "entityId": "org.springframework.aot.hint.ProxyHints#jdkProxyHints()",
    "entityType": "method",
    "code": "/**\r\n * Return the interface-based proxies that are required.\r\n * @return a stream of {@link JdkProxyHint}\r\n */\r\npublic Stream<JdkProxyHint> jdkProxyHints() {\r\n    return this.jdkProxies.stream();\r\n}",
    "comment": "\n\t * Return the interface-based proxies that are required.\n\t * @return a stream of {@link JdkProxyHint}\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ProxyHints#registerJdkProxy(Consumer<JdkProxyHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register a {@link JdkProxyHint}.\r\n * @param jdkProxyHint the consumer of the hint builder\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ProxyHints registerJdkProxy(Consumer<JdkProxyHint.Builder> jdkProxyHint) {\r\n    JdkProxyHint.Builder builder = new JdkProxyHint.Builder();\r\n    jdkProxyHint.accept(builder);\r\n    this.jdkProxies.add(builder.build());\r\n    return this;\r\n}",
    "comment": "\n\t * Register a {@link JdkProxyHint}.\n\t * @param jdkProxyHint the consumer of the hint builder\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ProxyHints#registerJdkProxy(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Register that a JDK proxy implementing the interfaces defined by the\r\n * specified {@linkplain TypeReference type references} is required.\r\n * @param proxiedInterfaces the type references for the interfaces the proxy\r\n * should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ProxyHints registerJdkProxy(TypeReference... proxiedInterfaces) {\r\n    return registerJdkProxy(jdkProxyHint -> jdkProxyHint.proxiedInterfaces(proxiedInterfaces));\r\n}",
    "comment": "\n\t * Register that a JDK proxy implementing the interfaces defined by the\n\t * specified {@linkplain TypeReference type references} is required.\n\t * @param proxiedInterfaces the type references for the interfaces the proxy\n\t * should implement\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ProxyHints#registerJdkProxy(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Register that a JDK proxy implementing the specified interfaces is\r\n * required.\r\n * <p>When registering a JDK proxy for Spring AOP, consider using\r\n * {@link org.springframework.aop.framework.AopProxyUtils#completeJdkProxyInterfaces(Class...)\r\n * AopProxyUtils.completeJdkProxyInterfaces()} for convenience.\r\n * @param proxiedInterfaces the interfaces the proxy should implement\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ProxyHints registerJdkProxy(Class<?>... proxiedInterfaces) {\r\n    return registerJdkProxy(jdkProxyHint -> jdkProxyHint.proxiedInterfaces(proxiedInterfaces));\r\n}",
    "comment": "\n\t * Register that a JDK proxy implementing the specified interfaces is\n\t * required.\n\t * <p>When registering a JDK proxy for Spring AOP, consider using\n\t * {@link org.springframework.aop.framework.AopProxyUtils#completeJdkProxyInterfaces(Class...)\n\t * AopProxyUtils.completeJdkProxyInterfaces()} for convenience.\n\t * @param proxiedInterfaces the interfaces the proxy should implement\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests",
    "entityType": "class",
    "code": "@Test\r\nvoid size() {\r\n    List<String> first = List.of(\"foo\", \"bar\", \"baz\");\r\n    List<String> second = List.of(\"qux\", \"quux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite).hasSize(5);\r\n}\n@Test\r\nvoid isEmpty() {\r\n    List<String> first = List.of(\"foo\", \"bar\", \"baz\");\r\n    List<String> second = List.of(\"qux\", \"quux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite).isNotEmpty();\r\n    composite = new CompositeCollection<>(Collections.emptyList(), Collections.emptyList());\r\n    assertThat(composite).isEmpty();\r\n}\n@Test\r\nvoid contains() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite.contains(\"foo\")).isTrue();\r\n    assertThat(composite.contains(\"bar\")).isTrue();\r\n    assertThat(composite.contains(\"baz\")).isTrue();\r\n    assertThat(composite.contains(\"qux\")).isTrue();\r\n    assertThat(composite.contains(\"quux\")).isFalse();\r\n}\n@Test\r\nvoid iterator() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    Iterator<String> iterator = composite.iterator();\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"foo\");\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"bar\");\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"baz\");\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"qux\");\r\n    assertThat(iterator).isExhausted();\r\n}\n@Test\r\nvoid toArray() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    Object[] array = composite.toArray();\r\n    assertThat(array).containsExactly(\"foo\", \"bar\", \"baz\", \"qux\");\r\n}\n@Test\r\nvoid toArrayArgs() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    String[] array = new String[composite.size()];\r\n    array = composite.toArray(array);\r\n    assertThat(array).containsExactly(\"foo\", \"bar\", \"baz\", \"qux\");\r\n}\n@Test\r\nvoid add() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.add(\"quux\"));\r\n}\n@Test\r\nvoid remove() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite.remove(\"foo\")).isTrue();\r\n    assertThat(composite.contains(\"foo\")).isFalse();\r\n    assertThat(first).containsExactly(\"bar\");\r\n    assertThat(composite.remove(\"quux\")).isFalse();\r\n}\n@Test\r\nvoid containsAll() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    List<String> all = new ArrayList<>(first);\r\n    all.addAll(second);\r\n    assertThat(composite.containsAll(all)).isTrue();\r\n    all.add(\"quux\");\r\n    assertThat(composite.containsAll(all)).isFalse();\r\n}\n@Test\r\nvoid addAll() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.addAll(List.of(\"quux\", \"corge\")));\r\n}\n@Test\r\nvoid removeAll() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    List<String> all = new ArrayList<>(first);\r\n    all.addAll(second);\r\n    assertThat(composite.removeAll(all)).isTrue();\r\n    assertThat(composite).isEmpty();\r\n    assertThat(first).isEmpty();\r\n    assertThat(second).isEmpty();\r\n}\n@Test\r\nvoid retainAll() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite.retainAll(List.of(\"bar\", \"baz\"))).isTrue();\r\n    assertThat(composite).containsExactly(\"bar\", \"baz\");\r\n    assertThat(first).containsExactly(\"bar\");\r\n    assertThat(second).containsExactly(\"baz\");\r\n}\n@Test\r\nvoid clear() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    composite.clear();\r\n    assertThat(composite).isEmpty();\r\n    assertThat(first).isEmpty();\r\n    assertThat(second).isEmpty();\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() {\r\n    List<String> first = List.of(\"foo\", \"bar\", \"baz\");\r\n    List<String> second = List.of(\"qux\", \"quux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite).hasSize(5);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#isEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmpty() {\r\n    List<String> first = List.of(\"foo\", \"bar\", \"baz\");\r\n    List<String> second = List.of(\"qux\", \"quux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite).isNotEmpty();\r\n    composite = new CompositeCollection<>(Collections.emptyList(), Collections.emptyList());\r\n    assertThat(composite).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#contains()",
    "entityType": "method",
    "code": "@Test\r\nvoid contains() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite.contains(\"foo\")).isTrue();\r\n    assertThat(composite.contains(\"bar\")).isTrue();\r\n    assertThat(composite.contains(\"baz\")).isTrue();\r\n    assertThat(composite.contains(\"qux\")).isTrue();\r\n    assertThat(composite.contains(\"quux\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#iterator()",
    "entityType": "method",
    "code": "@Test\r\nvoid iterator() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    Iterator<String> iterator = composite.iterator();\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"foo\");\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"bar\");\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"baz\");\r\n    assertThat(iterator).hasNext();\r\n    assertThat(iterator.next()).isEqualTo(\"qux\");\r\n    assertThat(iterator).isExhausted();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#toArray()",
    "entityType": "method",
    "code": "@Test\r\nvoid toArray() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    Object[] array = composite.toArray();\r\n    assertThat(array).containsExactly(\"foo\", \"bar\", \"baz\", \"qux\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#toArrayArgs()",
    "entityType": "method",
    "code": "@Test\r\nvoid toArrayArgs() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    String[] array = new String[composite.size()];\r\n    array = composite.toArray(array);\r\n    assertThat(array).containsExactly(\"foo\", \"bar\", \"baz\", \"qux\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#add()",
    "entityType": "method",
    "code": "@Test\r\nvoid add() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.add(\"quux\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite.remove(\"foo\")).isTrue();\r\n    assertThat(composite.contains(\"foo\")).isFalse();\r\n    assertThat(first).containsExactly(\"bar\");\r\n    assertThat(composite.remove(\"quux\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#containsAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsAll() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    List<String> all = new ArrayList<>(first);\r\n    all.addAll(second);\r\n    assertThat(composite.containsAll(all)).isTrue();\r\n    all.add(\"quux\");\r\n    assertThat(composite.containsAll(all)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#addAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid addAll() {\r\n    List<String> first = List.of(\"foo\", \"bar\");\r\n    List<String> second = List.of(\"baz\", \"qux\");\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.addAll(List.of(\"quux\", \"corge\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#removeAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid removeAll() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    List<String> all = new ArrayList<>(first);\r\n    all.addAll(second);\r\n    assertThat(composite.removeAll(all)).isTrue();\r\n    assertThat(composite).isEmpty();\r\n    assertThat(first).isEmpty();\r\n    assertThat(second).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#retainAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid retainAll() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    assertThat(composite.retainAll(List.of(\"bar\", \"baz\"))).isTrue();\r\n    assertThat(composite).containsExactly(\"bar\", \"baz\");\r\n    assertThat(first).containsExactly(\"bar\");\r\n    assertThat(second).containsExactly(\"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeCollectionTests#clear()",
    "entityType": "method",
    "code": "@Test\r\nvoid clear() {\r\n    List<String> first = new ArrayList<>(List.of(\"foo\", \"bar\"));\r\n    List<String> second = new ArrayList<>(List.of(\"baz\", \"qux\"));\r\n    CompositeCollection<String> composite = new CompositeCollection<>(first, second);\r\n    composite.clear();\r\n    assertThat(composite).isEmpty();\r\n    assertThat(first).isEmpty();\r\n    assertThat(second).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints",
    "entityType": "class",
    "code": "private final Map<TypeReference, TypeHint.Builder> types = new HashMap<>();\n/**\r\n * Return the types that require reflection.\r\n * @return the type hints\r\n */\r\npublic Stream<TypeHint> typeHints() {\r\n    return this.types.values().stream().map(TypeHint.Builder::build);\r\n}\n/**\r\n * Return the reflection hints for the type defined by the specified\r\n * {@link TypeReference}.\r\n * @param type the type to inspect\r\n * @return the reflection hints for this type, or {@code null}\r\n */\r\n@Nullable\r\npublic TypeHint getTypeHint(TypeReference type) {\r\n    Builder typeHintBuilder = this.types.get(type);\r\n    return (typeHintBuilder != null ? typeHintBuilder.build() : null);\r\n}\n/**\r\n * Return the reflection hints for the specified type.\r\n * @param type the type to inspect\r\n * @return the reflection hints for this type, or {@code null}\r\n */\r\n@Nullable\r\npublic TypeHint getTypeHint(Class<?> type) {\r\n    return getTypeHint(TypeReference.of(type));\r\n}\n/**\r\n * Register or customize reflection hints for the type defined by the\r\n * specified {@link TypeReference}.\r\n * @param type the type to customize\r\n * @param typeHint a builder to further customize hints for that type\r\n * @return {@code this}, to facilitate method chaining\r\n * @see #registerType(TypeReference, MemberCategory...)\r\n */\r\npublic ReflectionHints registerType(TypeReference type, Consumer<TypeHint.Builder> typeHint) {\r\n    Builder builder = this.types.computeIfAbsent(type, TypeHint.Builder::new);\r\n    typeHint.accept(builder);\r\n    return this;\r\n}\n/**\r\n * Register or customize reflection hints for the specified type\r\n * using the specified {@link MemberCategory MemberCategories}.\r\n * @param type the type to customize\r\n * @param memberCategories the member categories to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerType(TypeReference type, MemberCategory... memberCategories) {\r\n    return registerType(type, TypeHint.builtWith(memberCategories));\r\n}\n/**\r\n * Register or customize reflection hints for the specified type.\r\n * @param type the type to customize\r\n * @param typeHint a builder to further customize hints for that type\r\n * @return {@code this}, to facilitate method chaining\r\n * @see #registerType(Class, MemberCategory...)\r\n */\r\npublic ReflectionHints registerType(Class<?> type, Consumer<TypeHint.Builder> typeHint) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    if (type.getCanonicalName() != null) {\r\n        registerType(TypeReference.of(type), typeHint);\r\n    }\r\n    return this;\r\n}\n/**\r\n * Register or customize reflection hints for the specified type\r\n * using the specified {@link MemberCategory MemberCategories}.\r\n * @param type the type to customize\r\n * @param memberCategories the member categories to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerType(Class<?> type, MemberCategory... memberCategories) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    if (type.getCanonicalName() != null) {\r\n        registerType(TypeReference.of(type), memberCategories);\r\n    }\r\n    return this;\r\n}\n/**\r\n * Register or customize reflection hints for the specified type if it\r\n * is available using the specified {@link ClassLoader}.\r\n * @param classLoader the classloader to use to check if the type is present\r\n * @param typeName the type to customize\r\n * @param typeHint a builder to further customize hints for that type\r\n * @return {@code this}, to facilitate method chaining\r\n * @see #registerTypeIfPresent(ClassLoader, String, MemberCategory...)\r\n */\r\npublic ReflectionHints registerTypeIfPresent(@Nullable ClassLoader classLoader, String typeName, Consumer<TypeHint.Builder> typeHint) {\r\n    if (ClassUtils.isPresent(typeName, classLoader)) {\r\n        registerType(TypeReference.of(typeName), typeHint);\r\n    }\r\n    return this;\r\n}\n/**\r\n * Register or customize reflection hints for the specified type if it\r\n * is available using the specified {@link ClassLoader}.\r\n * @param classLoader the classloader to use to check if the type is present\r\n * @param typeName the type to customize\r\n * @param memberCategories the member categories to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerTypeIfPresent(@Nullable ClassLoader classLoader, String typeName, MemberCategory... memberCategories) {\r\n    return registerTypeIfPresent(classLoader, typeName, TypeHint.builtWith(memberCategories));\r\n}\n/**\r\n * Register or customize reflection hints for the types defined by the\r\n * specified list of {@link TypeReference type references}. The specified\r\n * {@code typeHint} consumer is invoked for each type.\r\n * @param types the types to customize\r\n * @param typeHint a builder to further customize hints for each type\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerTypes(Iterable<TypeReference> types, Consumer<TypeHint.Builder> typeHint) {\r\n    types.forEach(type -> registerType(type, typeHint));\r\n    return this;\r\n}\n/**\r\n * Register or customize reflection hints for all the interfaces implemented by\r\n * the given type and its parent classes, ignoring the common Java language interfaces.\r\n * The specified {@code typeHint} consumer is invoked for each type.\r\n * @param type the type to consider\r\n * @param typeHint a builder to further customize hints for each type\r\n * @return {@code this}, to facilitate method chaining\r\n * @since 6.2\r\n */\r\npublic ReflectionHints registerForInterfaces(Class<?> type, Consumer<TypeHint.Builder> typeHint) {\r\n    Class<?> currentClass = type;\r\n    while (currentClass != null && currentClass != Object.class) {\r\n        for (Class<?> interfaceType : currentClass.getInterfaces()) {\r\n            if (!ClassUtils.isJavaLanguageInterface(interfaceType)) {\r\n                this.registerType(interfaceType, typeHint);\r\n                registerForInterfaces(interfaceType, typeHint);\r\n            }\r\n        }\r\n        currentClass = currentClass.getSuperclass();\r\n    }\r\n    return this;\r\n}\n/**\r\n * Register the need for reflective field access on the specified {@link Field}.\r\n * @param field the field that requires reflective access\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerField(Field field) {\r\n    return registerType(TypeReference.of(field.getDeclaringClass()), typeHint -> typeHint.withField(field.getName()));\r\n}\n/**\r\n * Register the need for reflection on the specified {@link Constructor},\r\n * using the specified {@link ExecutableMode}.\r\n * @param constructor the constructor that requires reflection\r\n * @param mode the requested mode\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerConstructor(Constructor<?> constructor, ExecutableMode mode) {\r\n    return registerType(TypeReference.of(constructor.getDeclaringClass()), typeHint -> typeHint.withConstructor(mapParameters(constructor), mode));\r\n}\n/**\r\n * Register the need for reflection on the specified {@link Method},\r\n * using the specified {@link ExecutableMode}.\r\n * @param method the method that requires reflection\r\n * @param mode the requested mode\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerMethod(Method method, ExecutableMode mode) {\r\n    return registerType(TypeReference.of(method.getDeclaringClass()), typeHint -> typeHint.withMethod(method.getName(), mapParameters(method), mode));\r\n}\nprivate List<TypeReference> mapParameters(Executable executable) {\r\n    return TypeReference.listOf(executable.getParameterTypes());\r\n}",
    "comment": "\n * Gather the need for reflection at runtime.\n *\n * @author Stephane Nicoll\n * @author Phillip Webb\n * @author Andy Wilkinson\n * @author Sebastien Deleuze\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#typeHints()",
    "entityType": "method",
    "code": "/**\r\n * Return the types that require reflection.\r\n * @return the type hints\r\n */\r\npublic Stream<TypeHint> typeHints() {\r\n    return this.types.values().stream().map(TypeHint.Builder::build);\r\n}",
    "comment": "\n\t * Return the types that require reflection.\n\t * @return the type hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#getTypeHint(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Return the reflection hints for the type defined by the specified\r\n * {@link TypeReference}.\r\n * @param type the type to inspect\r\n * @return the reflection hints for this type, or {@code null}\r\n */\r\n@Nullable\r\npublic TypeHint getTypeHint(TypeReference type) {\r\n    Builder typeHintBuilder = this.types.get(type);\r\n    return (typeHintBuilder != null ? typeHintBuilder.build() : null);\r\n}",
    "comment": "\n\t * Return the reflection hints for the type defined by the specified\n\t * {@link TypeReference}.\n\t * @param type the type to inspect\n\t * @return the reflection hints for this type, or {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#getTypeHint(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Return the reflection hints for the specified type.\r\n * @param type the type to inspect\r\n * @return the reflection hints for this type, or {@code null}\r\n */\r\n@Nullable\r\npublic TypeHint getTypeHint(Class<?> type) {\r\n    return getTypeHint(TypeReference.of(type));\r\n}",
    "comment": "\n\t * Return the reflection hints for the specified type.\n\t * @param type the type to inspect\n\t * @return the reflection hints for this type, or {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerType(TypeReference,Consumer<TypeHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the type defined by the\r\n * specified {@link TypeReference}.\r\n * @param type the type to customize\r\n * @param typeHint a builder to further customize hints for that type\r\n * @return {@code this}, to facilitate method chaining\r\n * @see #registerType(TypeReference, MemberCategory...)\r\n */\r\npublic ReflectionHints registerType(TypeReference type, Consumer<TypeHint.Builder> typeHint) {\r\n    Builder builder = this.types.computeIfAbsent(type, TypeHint.Builder::new);\r\n    typeHint.accept(builder);\r\n    return this;\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the type defined by the\n\t * specified {@link TypeReference}.\n\t * @param type the type to customize\n\t * @param typeHint a builder to further customize hints for that type\n\t * @return {@code this}, to facilitate method chaining\n\t * @see #registerType(TypeReference, MemberCategory...)\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerType(TypeReference,MemberCategory)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the specified type\r\n * using the specified {@link MemberCategory MemberCategories}.\r\n * @param type the type to customize\r\n * @param memberCategories the member categories to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerType(TypeReference type, MemberCategory... memberCategories) {\r\n    return registerType(type, TypeHint.builtWith(memberCategories));\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the specified type\n\t * using the specified {@link MemberCategory MemberCategories}.\n\t * @param type the type to customize\n\t * @param memberCategories the member categories to apply\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerType(Class<?>,Consumer<TypeHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the specified type.\r\n * @param type the type to customize\r\n * @param typeHint a builder to further customize hints for that type\r\n * @return {@code this}, to facilitate method chaining\r\n * @see #registerType(Class, MemberCategory...)\r\n */\r\npublic ReflectionHints registerType(Class<?> type, Consumer<TypeHint.Builder> typeHint) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    if (type.getCanonicalName() != null) {\r\n        registerType(TypeReference.of(type), typeHint);\r\n    }\r\n    return this;\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the specified type.\n\t * @param type the type to customize\n\t * @param typeHint a builder to further customize hints for that type\n\t * @return {@code this}, to facilitate method chaining\n\t * @see #registerType(Class, MemberCategory...)\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerType(Class<?>,MemberCategory)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the specified type\r\n * using the specified {@link MemberCategory MemberCategories}.\r\n * @param type the type to customize\r\n * @param memberCategories the member categories to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerType(Class<?> type, MemberCategory... memberCategories) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    if (type.getCanonicalName() != null) {\r\n        registerType(TypeReference.of(type), memberCategories);\r\n    }\r\n    return this;\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the specified type\n\t * using the specified {@link MemberCategory MemberCategories}.\n\t * @param type the type to customize\n\t * @param memberCategories the member categories to apply\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerTypeIfPresent(ClassLoader,String,Consumer<TypeHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the specified type if it\r\n * is available using the specified {@link ClassLoader}.\r\n * @param classLoader the classloader to use to check if the type is present\r\n * @param typeName the type to customize\r\n * @param typeHint a builder to further customize hints for that type\r\n * @return {@code this}, to facilitate method chaining\r\n * @see #registerTypeIfPresent(ClassLoader, String, MemberCategory...)\r\n */\r\npublic ReflectionHints registerTypeIfPresent(@Nullable ClassLoader classLoader, String typeName, Consumer<TypeHint.Builder> typeHint) {\r\n    if (ClassUtils.isPresent(typeName, classLoader)) {\r\n        registerType(TypeReference.of(typeName), typeHint);\r\n    }\r\n    return this;\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the specified type if it\n\t * is available using the specified {@link ClassLoader}.\n\t * @param classLoader the classloader to use to check if the type is present\n\t * @param typeName the type to customize\n\t * @param typeHint a builder to further customize hints for that type\n\t * @return {@code this}, to facilitate method chaining\n\t * @see #registerTypeIfPresent(ClassLoader, String, MemberCategory...)\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerTypeIfPresent(ClassLoader,String,MemberCategory)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the specified type if it\r\n * is available using the specified {@link ClassLoader}.\r\n * @param classLoader the classloader to use to check if the type is present\r\n * @param typeName the type to customize\r\n * @param memberCategories the member categories to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerTypeIfPresent(@Nullable ClassLoader classLoader, String typeName, MemberCategory... memberCategories) {\r\n    return registerTypeIfPresent(classLoader, typeName, TypeHint.builtWith(memberCategories));\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the specified type if it\n\t * is available using the specified {@link ClassLoader}.\n\t * @param classLoader the classloader to use to check if the type is present\n\t * @param typeName the type to customize\n\t * @param memberCategories the member categories to apply\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerTypes(Iterable<TypeReference>,Consumer<TypeHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for the types defined by the\r\n * specified list of {@link TypeReference type references}. The specified\r\n * {@code typeHint} consumer is invoked for each type.\r\n * @param types the types to customize\r\n * @param typeHint a builder to further customize hints for each type\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerTypes(Iterable<TypeReference> types, Consumer<TypeHint.Builder> typeHint) {\r\n    types.forEach(type -> registerType(type, typeHint));\r\n    return this;\r\n}",
    "comment": "\n\t * Register or customize reflection hints for the types defined by the\n\t * specified list of {@link TypeReference type references}. The specified\n\t * {@code typeHint} consumer is invoked for each type.\n\t * @param types the types to customize\n\t * @param typeHint a builder to further customize hints for each type\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerForInterfaces(Class<?>,Consumer<TypeHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register or customize reflection hints for all the interfaces implemented by\r\n * the given type and its parent classes, ignoring the common Java language interfaces.\r\n * The specified {@code typeHint} consumer is invoked for each type.\r\n * @param type the type to consider\r\n * @param typeHint a builder to further customize hints for each type\r\n * @return {@code this}, to facilitate method chaining\r\n * @since 6.2\r\n */\r\npublic ReflectionHints registerForInterfaces(Class<?> type, Consumer<TypeHint.Builder> typeHint) {\r\n    Class<?> currentClass = type;\r\n    while (currentClass != null && currentClass != Object.class) {\r\n        for (Class<?> interfaceType : currentClass.getInterfaces()) {\r\n            if (!ClassUtils.isJavaLanguageInterface(interfaceType)) {\r\n                this.registerType(interfaceType, typeHint);\r\n                registerForInterfaces(interfaceType, typeHint);\r\n            }\r\n        }\r\n        currentClass = currentClass.getSuperclass();\r\n    }\r\n    return this;\r\n}",
    "comment": "\n\t * Register or customize reflection hints for all the interfaces implemented by\n\t * the given type and its parent classes, ignoring the common Java language interfaces.\n\t * The specified {@code typeHint} consumer is invoked for each type.\n\t * @param type the type to consider\n\t * @param typeHint a builder to further customize hints for each type\n\t * @return {@code this}, to facilitate method chaining\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerField(Field)",
    "entityType": "method",
    "code": "/**\r\n * Register the need for reflective field access on the specified {@link Field}.\r\n * @param field the field that requires reflective access\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerField(Field field) {\r\n    return registerType(TypeReference.of(field.getDeclaringClass()), typeHint -> typeHint.withField(field.getName()));\r\n}",
    "comment": "\n\t * Register the need for reflective field access on the specified {@link Field}.\n\t * @param field the field that requires reflective access\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerConstructor(Constructor<?>,ExecutableMode)",
    "entityType": "method",
    "code": "/**\r\n * Register the need for reflection on the specified {@link Constructor},\r\n * using the specified {@link ExecutableMode}.\r\n * @param constructor the constructor that requires reflection\r\n * @param mode the requested mode\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerConstructor(Constructor<?> constructor, ExecutableMode mode) {\r\n    return registerType(TypeReference.of(constructor.getDeclaringClass()), typeHint -> typeHint.withConstructor(mapParameters(constructor), mode));\r\n}",
    "comment": "\n\t * Register the need for reflection on the specified {@link Constructor},\n\t * using the specified {@link ExecutableMode}.\n\t * @param constructor the constructor that requires reflection\n\t * @param mode the requested mode\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#registerMethod(Method,ExecutableMode)",
    "entityType": "method",
    "code": "/**\r\n * Register the need for reflection on the specified {@link Method},\r\n * using the specified {@link ExecutableMode}.\r\n * @param method the method that requires reflection\r\n * @param mode the requested mode\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ReflectionHints registerMethod(Method method, ExecutableMode mode) {\r\n    return registerType(TypeReference.of(method.getDeclaringClass()), typeHint -> typeHint.withMethod(method.getName(), mapParameters(method), mode));\r\n}",
    "comment": "\n\t * Register the need for reflection on the specified {@link Method},\n\t * using the specified {@link ExecutableMode}.\n\t * @param method the method that requires reflection\n\t * @param mode the requested mode\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionHints#mapParameters(Executable)",
    "entityType": "method",
    "code": "private List<TypeReference> mapParameters(Executable executable) {\r\n    return TypeReference.listOf(executable.getParameterTypes());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIteratorTests",
    "entityType": "class",
    "code": "@Test\r\nvoid noIterators() {\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    assertThat(it.hasNext()).isFalse();\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(it::next);\r\n}\n@Test\r\nvoid singleIterator() {\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(Arrays.asList(\"0\", \"1\").iterator());\r\n    for (int i = 0; i < 2; i++) {\r\n        assertThat(it.hasNext()).isTrue();\r\n        assertThat(it.next()).isEqualTo(String.valueOf(i));\r\n    }\r\n    assertThat(it.hasNext()).isFalse();\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(it::next);\r\n}\n@Test\r\nvoid multipleIterators() {\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(Arrays.asList(\"0\", \"1\").iterator());\r\n    it.add(List.of(\"2\").iterator());\r\n    it.add(Arrays.asList(\"3\", \"4\").iterator());\r\n    for (int i = 0; i < 5; i++) {\r\n        assertThat(it.hasNext()).isTrue();\r\n        assertThat(it.next()).isEqualTo(String.valueOf(i));\r\n    }\r\n    assertThat(it.hasNext()).isFalse();\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(it::next);\r\n}\n@Test\r\nvoid inUse() {\r\n    List<String> list = Arrays.asList(\"0\", \"1\");\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(list.iterator());\r\n    it.hasNext();\r\n    assertThatIllegalStateException().isThrownBy(() -> it.add(list.iterator()));\r\n    CompositeIterator<String> it2 = new CompositeIterator<>();\r\n    it2.add(list.iterator());\r\n    it2.next();\r\n    assertThatIllegalStateException().isThrownBy(() -> it2.add(list.iterator()));\r\n}\n@Test\r\nvoid duplicateIterators() {\r\n    List<String> list = Arrays.asList(\"0\", \"1\");\r\n    Iterator<String> iterator = list.iterator();\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(iterator);\r\n    it.add(list.iterator());\r\n    assertThatIllegalArgumentException().isThrownBy(() -> it.add(iterator));\r\n}",
    "comment": "\n * Test case for {@link CompositeIterator}.\n *\n * @author Erwin Vervaet\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.util.CompositeIteratorTests#noIterators()",
    "entityType": "method",
    "code": "@Test\r\nvoid noIterators() {\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    assertThat(it.hasNext()).isFalse();\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(it::next);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIteratorTests#singleIterator()",
    "entityType": "method",
    "code": "@Test\r\nvoid singleIterator() {\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(Arrays.asList(\"0\", \"1\").iterator());\r\n    for (int i = 0; i < 2; i++) {\r\n        assertThat(it.hasNext()).isTrue();\r\n        assertThat(it.next()).isEqualTo(String.valueOf(i));\r\n    }\r\n    assertThat(it.hasNext()).isFalse();\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(it::next);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIteratorTests#multipleIterators()",
    "entityType": "method",
    "code": "@Test\r\nvoid multipleIterators() {\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(Arrays.asList(\"0\", \"1\").iterator());\r\n    it.add(List.of(\"2\").iterator());\r\n    it.add(Arrays.asList(\"3\", \"4\").iterator());\r\n    for (int i = 0; i < 5; i++) {\r\n        assertThat(it.hasNext()).isTrue();\r\n        assertThat(it.next()).isEqualTo(String.valueOf(i));\r\n    }\r\n    assertThat(it.hasNext()).isFalse();\r\n    assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(it::next);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIteratorTests#inUse()",
    "entityType": "method",
    "code": "@Test\r\nvoid inUse() {\r\n    List<String> list = Arrays.asList(\"0\", \"1\");\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(list.iterator());\r\n    it.hasNext();\r\n    assertThatIllegalStateException().isThrownBy(() -> it.add(list.iterator()));\r\n    CompositeIterator<String> it2 = new CompositeIterator<>();\r\n    it2.add(list.iterator());\r\n    it2.next();\r\n    assertThatIllegalStateException().isThrownBy(() -> it2.add(list.iterator()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeIteratorTests#duplicateIterators()",
    "entityType": "method",
    "code": "@Test\r\nvoid duplicateIterators() {\r\n    List<String> list = Arrays.asList(\"0\", \"1\");\r\n    Iterator<String> iterator = list.iterator();\r\n    CompositeIterator<String> it = new CompositeIterator<>();\r\n    it.add(iterator);\r\n    it.add(list.iterator());\r\n    assertThatIllegalArgumentException().isThrownBy(() -> it.add(iterator));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionTypeReference",
    "entityType": "class",
    "code": "private final Class<?> type;\nprivate ReflectionTypeReference(Class<?> type) {\r\n    super(type.getPackageName(), type.getSimpleName(), getEnclosingClass(type));\r\n    this.type = type;\r\n}\n@Nullable\r\nprivate static TypeReference getEnclosingClass(Class<?> type) {\r\n    Class<?> candidate = (type.isArray() ? type.componentType().getEnclosingClass() : type.getEnclosingClass());\r\n    return (candidate != null ? new ReflectionTypeReference(candidate) : null);\r\n}\nstatic ReflectionTypeReference of(Class<?> type) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.notNull(type.getCanonicalName(), \"'type.getCanonicalName()' must not be null\");\r\n    return new ReflectionTypeReference(type);\r\n}\n@Override\r\npublic String getCanonicalName() {\r\n    return this.type.getCanonicalName();\r\n}\n@Override\r\nprotected boolean isPrimitive() {\r\n    return this.type.isPrimitive() || (this.type.isArray() && this.type.componentType().isPrimitive());\r\n}",
    "comment": "\n * A {@link TypeReference} based on a {@link Class}.\n *\n * @author Stephane Nicoll\n * @author Sebastien Deleuze\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionTypeReference#getEnclosingClass(Class<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static TypeReference getEnclosingClass(Class<?> type) {\r\n    Class<?> candidate = (type.isArray() ? type.componentType().getEnclosingClass() : type.getEnclosingClass());\r\n    return (candidate != null ? new ReflectionTypeReference(candidate) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionTypeReference#of(Class<?>)",
    "entityType": "method",
    "code": "static ReflectionTypeReference of(Class<?> type) {\r\n    Assert.notNull(type, \"'type' must not be null\");\r\n    Assert.notNull(type.getCanonicalName(), \"'type.getCanonicalName()' must not be null\");\r\n    return new ReflectionTypeReference(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionTypeReference#getCanonicalName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getCanonicalName() {\r\n    return this.type.getCanonicalName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ReflectionTypeReference#isPrimitive()",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean isPrimitive() {\r\n    return this.type.isPrimitive() || (this.type.isArray() && this.type.componentType().isPrimitive());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceBundleHint",
    "entityType": "class",
    "code": "private final String baseName;\n@Nullable\r\nprivate final TypeReference reachableType;\nResourceBundleHint(Builder builder) {\r\n    this.baseName = builder.baseName;\r\n    this.reachableType = builder.reachableType;\r\n}\n/**\r\n * Return the {@code baseName} of the resource bundle.\r\n */\r\npublic String getBaseName() {\r\n    return this.baseName;\r\n}\n@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ResourceBundleHint that && this.baseName.equals(that.baseName) && Objects.equals(this.reachableType, that.reachableType)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.baseName, this.reachableType);\r\n}\n/**\r\n * Builder for {@link ResourceBundleHint}.\r\n */\r\npublic static class Builder {\r\n\r\n    private String baseName;\r\n\r\n    @Nullable\r\n    private TypeReference reachableType;\r\n\r\n    Builder(String baseName) {\r\n        this.baseName = baseName;\r\n    }\r\n\r\n    /**\r\n     * Make this hint conditional on the fact that the specified type can be resolved.\r\n     * @param reachableType the type that should be reachable for this hint to apply\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder onReachableType(TypeReference reachableType) {\r\n        this.reachableType = reachableType;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use the {@code baseName} of the resource bundle.\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder baseName(String baseName) {\r\n        this.baseName = baseName;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Create a {@link ResourceBundleHint} based on the state of this builder.\r\n     * @return a resource bundle hint\r\n     */\r\n    ResourceBundleHint build() {\r\n        return new ResourceBundleHint(this);\r\n    }\r\n}",
    "comment": "\n * A hint that describes the need to access a {@link ResourceBundle}.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceBundleHint#getBaseName()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code baseName} of the resource bundle.\r\n */\r\npublic String getBaseName() {\r\n    return this.baseName;\r\n}",
    "comment": "\n\t * Return the {@code baseName} of the resource bundle.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceBundleHint#getReachableType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceBundleHint#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ResourceBundleHint that && this.baseName.equals(that.baseName) && Objects.equals(this.reachableType, that.reachableType)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceBundleHint#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.baseName, this.reachableType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.Builder",
    "entityType": "class",
    "code": "private String baseName;\n@Nullable\r\nprivate TypeReference reachableType;\nBuilder(String baseName) {\r\n    this.baseName = baseName;\r\n}\n/**\r\n * Make this hint conditional on the fact that the specified type can be resolved.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder onReachableType(TypeReference reachableType) {\r\n    this.reachableType = reachableType;\r\n    return this;\r\n}\n/**\r\n * Use the {@code baseName} of the resource bundle.\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder baseName(String baseName) {\r\n    this.baseName = baseName;\r\n    return this;\r\n}\n/**\r\n * Create a {@link ResourceBundleHint} based on the state of this builder.\r\n * @return a resource bundle hint\r\n */\r\nResourceBundleHint build() {\r\n    return new ResourceBundleHint(this);\r\n}",
    "comment": "\n\t * Builder for {@link ResourceBundleHint}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#onReachableType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Make this hint conditional on the fact that the specified type can be resolved.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder onReachableType(TypeReference reachableType) {\r\n    this.reachableType = reachableType;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Make this hint conditional on the fact that the specified type can be resolved.\n\t\t * @param reachableType the type that should be reachable for this hint to apply\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#baseName(String)",
    "entityType": "method",
    "code": "/**\r\n * Use the {@code baseName} of the resource bundle.\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder baseName(String baseName) {\r\n    this.baseName = baseName;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Use the {@code baseName} of the resource bundle.\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#build()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link ResourceBundleHint} based on the state of this builder.\r\n * @return a resource bundle hint\r\n */\r\nResourceBundleHint build() {\r\n    return new ResourceBundleHint(this);\r\n}",
    "comment": "\n\t\t * Create a {@link ResourceBundleHint} based on the state of this builder.\n\t\t * @return a resource bundle hint\n\t\t "
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests",
    "entityType": "class",
    "code": "@Test\r\nvoid size() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite).hasSize(3);\r\n}\n@Test\r\nvoid isEmpty() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite).isNotEmpty();\r\n    composite = new CompositeMap<>(Collections.emptyMap(), Collections.emptyMap());\r\n    assertThat(composite).isEmpty();\r\n}\n@Test\r\nvoid containsKey() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.containsKey(\"foo\")).isTrue();\r\n    assertThat(composite.containsKey(\"bar\")).isFalse();\r\n    assertThat(composite.containsKey(\"baz\")).isTrue();\r\n    assertThat(composite.containsKey(\"qux\")).isFalse();\r\n    assertThat(composite.containsKey(\"quux\")).isTrue();\r\n    assertThat(composite.containsKey(\"corge\")).isFalse();\r\n}\n@Test\r\nvoid containsValue() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.containsValue(\"foo\")).isFalse();\r\n    assertThat(composite.containsValue(\"bar\")).isTrue();\r\n    assertThat(composite.containsValue(\"baz\")).isFalse();\r\n    assertThat(composite.containsValue(\"qux\")).isTrue();\r\n    assertThat(composite.containsValue(\"quux\")).isFalse();\r\n    assertThat(composite.containsValue(\"corge\")).isTrue();\r\n}\n@Test\r\nvoid get() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.get(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(composite.get(\"baz\")).isEqualTo(\"qux\");\r\n    assertThat(composite.get(\"quux\")).isEqualTo(\"corge\");\r\n    assertThat(composite.get(\"grault\")).isNull();\r\n}\n@Test\r\nvoid putUnsupported() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.put(\"grault\", \"garply\"));\r\n}\n@Test\r\nvoid putSupported() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second, (k, v) -> {\r\n        assertThat(k).isEqualTo(\"quux\");\r\n        assertThat(v).isEqualTo(\"corge\");\r\n        return \"grault\";\r\n    }, null);\r\n    assertThat(composite.put(\"quux\", \"corge\")).isEqualTo(\"grault\");\r\n}\n@Test\r\nvoid remove() {\r\n    Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n    Map<String, String> second = new HashMap<>(Map.of(\"quux\", \"corge\"));\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.remove(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(composite.containsKey(\"foo\")).isFalse();\r\n    assertThat(first).containsExactly(entry(\"baz\", \"qux\"));\r\n    assertThat(composite.remove(\"grault\")).isNull();\r\n}\n@Test\r\nvoid putAllUnsupported() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.putAll(Map.of(\"quux\", \"corge\", \"grault\", \"garply\")));\r\n}\n@Test\r\nvoid putAllPutFunction() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    AtomicBoolean functionInvoked = new AtomicBoolean();\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second, (k, v) -> {\r\n        assertThat(k).isEqualTo(\"quux\");\r\n        assertThat(v).isEqualTo(\"corge\");\r\n        functionInvoked.set(true);\r\n        return \"grault\";\r\n    }, null);\r\n    composite.putAll(Map.of(\"quux\", \"corge\"));\r\n    assertThat(functionInvoked).isTrue();\r\n}\n@Test\r\nvoid putAllPutAllFunction() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    AtomicBoolean functionInvoked = new AtomicBoolean();\r\n    Map<String, String> argument = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second, null, m -> {\r\n        assertThat(m).isSameAs(argument);\r\n        functionInvoked.set(true);\r\n    });\r\n    composite.putAll(argument);\r\n    assertThat(functionInvoked).isTrue();\r\n}\n@Test\r\nvoid clear() {\r\n    Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n    Map<String, String> second = new HashMap<>(Map.of(\"quux\", \"corge\"));\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    composite.clear();\r\n    assertThat(composite).isEmpty();\r\n    assertThat(first).isEmpty();\r\n    assertThat(second).isEmpty();\r\n}\n@Test\r\nvoid keySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<String> keySet = composite.keySet();\r\n    assertThat(keySet).containsExactly(\"foo\", \"baz\");\r\n}\n@Test\r\nvoid values() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Collection<String> values = composite.values();\r\n    assertThat(values).containsExactly(\"bar\", \"qux\");\r\n}\n@Test\r\nvoid entrySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<Map.Entry<String, String>> entries = composite.entrySet();\r\n    assertThat(entries).containsExactly(entry(\"foo\", \"bar\"), entry(\"baz\", \"qux\"));\r\n}\n@Nested\r\nclass CollisionTests {\r\n\r\n    @Test\r\n    void size() {\r\n        Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n        Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        assertThat(composite).hasSize(3);\r\n    }\r\n\r\n    @Test\r\n    void containsValue() {\r\n        Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n        Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        assertThat(composite.containsValue(\"bar\")).isTrue();\r\n        assertThat(composite.containsValue(\"qux\")).isTrue();\r\n        assertThat(composite.containsValue(\"quux\")).isFalse();\r\n        assertThat(composite.containsValue(\"grault\")).isTrue();\r\n    }\r\n\r\n    @Test\r\n    void get() {\r\n        Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n        Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        assertThat(composite.get(\"foo\")).isEqualTo(\"bar\");\r\n        assertThat(composite.get(\"baz\")).isEqualTo(\"qux\");\r\n        assertThat(composite.get(\"corge\")).isEqualTo(\"grault\");\r\n    }\r\n\r\n    @Test\r\n    void remove() {\r\n        Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n        Map<String, String> second = new HashMap<>(Map.of(\"baz\", \"quux\", \"corge\", \"grault\"));\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        assertThat(composite.remove(\"baz\")).isEqualTo(\"qux\");\r\n        assertThat(composite.containsKey(\"baz\")).isFalse();\r\n        assertThat(first).containsExactly(entry(\"foo\", \"bar\"));\r\n        assertThat(second).containsExactly(entry(\"corge\", \"grault\"));\r\n    }\r\n\r\n    @Test\r\n    void keySet() {\r\n        Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n        Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        Set<String> keySet = composite.keySet();\r\n        assertThat(keySet).containsExactlyInAnyOrder(\"foo\", \"baz\", \"corge\");\r\n    }\r\n\r\n    @Test\r\n    void values() {\r\n        Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n        Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        Collection<String> values = composite.values();\r\n        assertThat(values).containsExactlyInAnyOrder(\"bar\", \"qux\", \"grault\");\r\n    }\r\n\r\n    @Test\r\n    void entrySet() {\r\n        Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n        Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n        CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n        Set<Map.Entry<String, String>> entries = composite.entrySet();\r\n        assertThat(entries).containsExactlyInAnyOrder(entry(\"foo\", \"bar\"), entry(\"baz\", \"qux\"), entry(\"corge\", \"grault\"));\r\n    }\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite).hasSize(3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#isEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid isEmpty() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite).isNotEmpty();\r\n    composite = new CompositeMap<>(Collections.emptyMap(), Collections.emptyMap());\r\n    assertThat(composite).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#containsKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsKey() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.containsKey(\"foo\")).isTrue();\r\n    assertThat(composite.containsKey(\"bar\")).isFalse();\r\n    assertThat(composite.containsKey(\"baz\")).isTrue();\r\n    assertThat(composite.containsKey(\"qux\")).isFalse();\r\n    assertThat(composite.containsKey(\"quux\")).isTrue();\r\n    assertThat(composite.containsKey(\"corge\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#containsValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsValue() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.containsValue(\"foo\")).isFalse();\r\n    assertThat(composite.containsValue(\"bar\")).isTrue();\r\n    assertThat(composite.containsValue(\"baz\")).isFalse();\r\n    assertThat(composite.containsValue(\"qux\")).isTrue();\r\n    assertThat(composite.containsValue(\"quux\")).isFalse();\r\n    assertThat(composite.containsValue(\"corge\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#get()",
    "entityType": "method",
    "code": "@Test\r\nvoid get() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.get(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(composite.get(\"baz\")).isEqualTo(\"qux\");\r\n    assertThat(composite.get(\"quux\")).isEqualTo(\"corge\");\r\n    assertThat(composite.get(\"grault\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#putUnsupported()",
    "entityType": "method",
    "code": "@Test\r\nvoid putUnsupported() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.put(\"grault\", \"garply\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#putSupported()",
    "entityType": "method",
    "code": "@Test\r\nvoid putSupported() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second, (k, v) -> {\r\n        assertThat(k).isEqualTo(\"quux\");\r\n        assertThat(v).isEqualTo(\"corge\");\r\n        return \"grault\";\r\n    }, null);\r\n    assertThat(composite.put(\"quux\", \"corge\")).isEqualTo(\"grault\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n    Map<String, String> second = new HashMap<>(Map.of(\"quux\", \"corge\"));\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.remove(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(composite.containsKey(\"foo\")).isFalse();\r\n    assertThat(first).containsExactly(entry(\"baz\", \"qux\"));\r\n    assertThat(composite.remove(\"grault\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#putAllUnsupported()",
    "entityType": "method",
    "code": "@Test\r\nvoid putAllUnsupported() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> composite.putAll(Map.of(\"quux\", \"corge\", \"grault\", \"garply\")));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#putAllPutFunction()",
    "entityType": "method",
    "code": "@Test\r\nvoid putAllPutFunction() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    AtomicBoolean functionInvoked = new AtomicBoolean();\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second, (k, v) -> {\r\n        assertThat(k).isEqualTo(\"quux\");\r\n        assertThat(v).isEqualTo(\"corge\");\r\n        functionInvoked.set(true);\r\n        return \"grault\";\r\n    }, null);\r\n    composite.putAll(Map.of(\"quux\", \"corge\"));\r\n    assertThat(functionInvoked).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#putAllPutAllFunction()",
    "entityType": "method",
    "code": "@Test\r\nvoid putAllPutAllFunction() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    AtomicBoolean functionInvoked = new AtomicBoolean();\r\n    Map<String, String> argument = Map.of(\"quux\", \"corge\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second, null, m -> {\r\n        assertThat(m).isSameAs(argument);\r\n        functionInvoked.set(true);\r\n    });\r\n    composite.putAll(argument);\r\n    assertThat(functionInvoked).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#clear()",
    "entityType": "method",
    "code": "@Test\r\nvoid clear() {\r\n    Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n    Map<String, String> second = new HashMap<>(Map.of(\"quux\", \"corge\"));\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    composite.clear();\r\n    assertThat(composite).isEmpty();\r\n    assertThat(first).isEmpty();\r\n    assertThat(second).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#keySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid keySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<String> keySet = composite.keySet();\r\n    assertThat(keySet).containsExactly(\"foo\", \"baz\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#values()",
    "entityType": "method",
    "code": "@Test\r\nvoid values() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Collection<String> values = composite.values();\r\n    assertThat(values).containsExactly(\"bar\", \"qux\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CompositeMapTests#entrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid entrySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\");\r\n    Map<String, String> second = Map.of(\"baz\", \"qux\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<Map.Entry<String, String>> entries = composite.entrySet();\r\n    assertThat(entries).containsExactly(entry(\"foo\", \"bar\"), entry(\"baz\", \"qux\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests",
    "entityType": "class",
    "code": "@Test\r\nvoid size() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite).hasSize(3);\r\n}\n@Test\r\nvoid containsValue() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.containsValue(\"bar\")).isTrue();\r\n    assertThat(composite.containsValue(\"qux\")).isTrue();\r\n    assertThat(composite.containsValue(\"quux\")).isFalse();\r\n    assertThat(composite.containsValue(\"grault\")).isTrue();\r\n}\n@Test\r\nvoid get() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.get(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(composite.get(\"baz\")).isEqualTo(\"qux\");\r\n    assertThat(composite.get(\"corge\")).isEqualTo(\"grault\");\r\n}\n@Test\r\nvoid remove() {\r\n    Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n    Map<String, String> second = new HashMap<>(Map.of(\"baz\", \"quux\", \"corge\", \"grault\"));\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.remove(\"baz\")).isEqualTo(\"qux\");\r\n    assertThat(composite.containsKey(\"baz\")).isFalse();\r\n    assertThat(first).containsExactly(entry(\"foo\", \"bar\"));\r\n    assertThat(second).containsExactly(entry(\"corge\", \"grault\"));\r\n}\n@Test\r\nvoid keySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<String> keySet = composite.keySet();\r\n    assertThat(keySet).containsExactlyInAnyOrder(\"foo\", \"baz\", \"corge\");\r\n}\n@Test\r\nvoid values() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Collection<String> values = composite.values();\r\n    assertThat(values).containsExactlyInAnyOrder(\"bar\", \"qux\", \"grault\");\r\n}\n@Test\r\nvoid entrySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<Map.Entry<String, String>> entries = composite.entrySet();\r\n    assertThat(entries).containsExactlyInAnyOrder(entry(\"foo\", \"bar\"), entry(\"baz\", \"qux\"), entry(\"corge\", \"grault\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#size()",
    "entityType": "method",
    "code": "@Test\r\nvoid size() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite).hasSize(3);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#containsValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsValue() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.containsValue(\"bar\")).isTrue();\r\n    assertThat(composite.containsValue(\"qux\")).isTrue();\r\n    assertThat(composite.containsValue(\"quux\")).isFalse();\r\n    assertThat(composite.containsValue(\"grault\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#get()",
    "entityType": "method",
    "code": "@Test\r\nvoid get() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.get(\"foo\")).isEqualTo(\"bar\");\r\n    assertThat(composite.get(\"baz\")).isEqualTo(\"qux\");\r\n    assertThat(composite.get(\"corge\")).isEqualTo(\"grault\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#remove()",
    "entityType": "method",
    "code": "@Test\r\nvoid remove() {\r\n    Map<String, String> first = new HashMap<>(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\r\n    Map<String, String> second = new HashMap<>(Map.of(\"baz\", \"quux\", \"corge\", \"grault\"));\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    assertThat(composite.remove(\"baz\")).isEqualTo(\"qux\");\r\n    assertThat(composite.containsKey(\"baz\")).isFalse();\r\n    assertThat(first).containsExactly(entry(\"foo\", \"bar\"));\r\n    assertThat(second).containsExactly(entry(\"corge\", \"grault\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#keySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid keySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<String> keySet = composite.keySet();\r\n    assertThat(keySet).containsExactlyInAnyOrder(\"foo\", \"baz\", \"corge\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#values()",
    "entityType": "method",
    "code": "@Test\r\nvoid values() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Collection<String> values = composite.values();\r\n    assertThat(values).containsExactlyInAnyOrder(\"bar\", \"qux\", \"grault\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.CollisionTests#entrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid entrySet() {\r\n    Map<String, String> first = Map.of(\"foo\", \"bar\", \"baz\", \"qux\");\r\n    Map<String, String> second = Map.of(\"baz\", \"quux\", \"corge\", \"grault\");\r\n    CompositeMap<String, String> composite = new CompositeMap<>(first, second);\r\n    Set<Map.Entry<String, String>> entries = composite.entrySet();\r\n    assertThat(entries).containsExactlyInAnyOrder(entry(\"foo\", \"bar\"), entry(\"baz\", \"qux\"), entry(\"corge\", \"grault\"));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints",
    "entityType": "class",
    "code": "private final Set<TypeReference> types;\nprivate final List<ResourcePatternHints> resourcePatternHints;\nprivate final Set<ResourceBundleHint> resourceBundleHints;\npublic ResourceHints() {\r\n    this.types = new HashSet<>();\r\n    this.resourcePatternHints = new ArrayList<>();\r\n    this.resourceBundleHints = new LinkedHashSet<>();\r\n}\n/**\r\n * Return the resources that should be made available at runtime.\r\n * @return a stream of {@link ResourcePatternHints}\r\n */\r\npublic Stream<ResourcePatternHints> resourcePatternHints() {\r\n    Stream<ResourcePatternHints> patterns = this.resourcePatternHints.stream();\r\n    return (this.types.isEmpty() ? patterns : Stream.concat(Stream.of(typesPatternResourceHint()), patterns));\r\n}\n/**\r\n * Return the resource bundles that should be made available at runtime.\r\n * @return a stream of {@link ResourceBundleHint}\r\n */\r\npublic Stream<ResourceBundleHint> resourceBundleHints() {\r\n    return this.resourceBundleHints.stream();\r\n}\n/**\r\n * Register a pattern if the given {@code location} is available on the\r\n * classpath. This delegates to {@link ClassLoader#getResource(String)}\r\n * which validates directories as well. The location is not included in\r\n * the hint.\r\n * @param classLoader the classloader to use\r\n * @param location a '/'-separated path name that should exist\r\n * @param resourceHint a builder to customize the resource pattern\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerPatternIfPresent(@Nullable ClassLoader classLoader, String location, Consumer<ResourcePatternHints.Builder> resourceHint) {\r\n    ClassLoader classLoaderToUse = (classLoader != null ? classLoader : getClass().getClassLoader());\r\n    if (classLoaderToUse.getResource(location) != null) {\r\n        registerPattern(resourceHint);\r\n    }\r\n    return this;\r\n}\n/**\r\n * Register that the resources matching the specified pattern should be\r\n * made available at runtime.\r\n * @param resourceHint a builder to further customize the resource pattern\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerPattern(@Nullable Consumer<ResourcePatternHints.Builder> resourceHint) {\r\n    ResourcePatternHints.Builder builder = new ResourcePatternHints.Builder();\r\n    if (resourceHint != null) {\r\n        resourceHint.accept(builder);\r\n    }\r\n    this.resourcePatternHints.add(builder.build());\r\n    return this;\r\n}\n/**\r\n * Register that the resources matching the specified pattern should be\r\n * made available at runtime.\r\n * @param include a pattern of the resources to include (see {@link ResourcePatternHint} documentation)\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerPattern(String include) {\r\n    return registerPattern(builder -> builder.includes(include));\r\n}\n/**\r\n * Register that the supplied resource should be made available at runtime.\r\n * @param resource the resource to register\r\n * @throws IllegalArgumentException if the supplied resource is not a\r\n * {@link ClassPathResource} or does not {@linkplain Resource#exists() exist}\r\n * @see #registerPattern(String)\r\n * @see ClassPathResource#getPath()\r\n */\r\npublic void registerResource(Resource resource) {\r\n    if (resource instanceof ClassPathResource classPathResource && classPathResource.exists()) {\r\n        registerPattern(classPathResource.getPath());\r\n    } else {\r\n        throw new IllegalArgumentException(\"Resource must be a ClassPathResource that exists: \" + resource);\r\n    }\r\n}\n/**\r\n * Register that the bytecode of the type defined by the specified\r\n * {@link TypeReference} should be made available at runtime.\r\n * @param type the type to include\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerType(TypeReference type) {\r\n    this.types.add(type);\r\n    return this;\r\n}\n/**\r\n * Register that the bytecode of the specified type should be made\r\n * available at runtime.\r\n * @param type the type to include\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerType(Class<?> type) {\r\n    return registerType(TypeReference.of(type));\r\n}\n/**\r\n * Register that the resource bundle with the specified base name should\r\n * be made available at runtime.\r\n * @param baseName the base name of the resource bundle\r\n * @param resourceHint a builder to further customize the resource bundle\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerResourceBundle(String baseName, @Nullable Consumer<ResourceBundleHint.Builder> resourceHint) {\r\n    ResourceBundleHint.Builder builder = new ResourceBundleHint.Builder(baseName);\r\n    if (resourceHint != null) {\r\n        resourceHint.accept(builder);\r\n    }\r\n    this.resourceBundleHints.add(builder.build());\r\n    return this;\r\n}\n/**\r\n * Register that the resource bundle with the specified base name should\r\n * be made available at runtime.\r\n * @param baseName the base name of the resource bundle\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerResourceBundle(String baseName) {\r\n    return registerResourceBundle(baseName, null);\r\n}\nprivate ResourcePatternHints typesPatternResourceHint() {\r\n    ResourcePatternHints.Builder builder = new ResourcePatternHints.Builder();\r\n    this.types.forEach(type -> builder.includes(toIncludePattern(type)));\r\n    return builder.build();\r\n}\nprivate String toIncludePattern(TypeReference type) {\r\n    return type.getName().replace(\".\", \"/\") + \".class\";\r\n}",
    "comment": "\n * Gather the need for resources available at runtime.\n *\n * @author Stephane Nicoll\n * @author Sam Brannen\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.util.CompositeSetTests",
    "entityType": "class",
    "code": "@Test\r\nvoid testEquals() {\r\n    Set<String> first = Set.of(\"foo\", \"bar\");\r\n    Set<String> second = Set.of(\"baz\", \"qux\");\r\n    CompositeSet<String> composite = new CompositeSet<>(first, second);\r\n    Set<String> all = new HashSet<>(first);\r\n    all.addAll(second);\r\n    assertThat(composite.equals(all)).isTrue();\r\n    assertThat(composite.equals(first)).isFalse();\r\n    assertThat(composite.equals(second)).isFalse();\r\n    assertThat(composite.equals(Collections.emptySet())).isFalse();\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#resourcePatternHints()",
    "entityType": "method",
    "code": "/**\r\n * Return the resources that should be made available at runtime.\r\n * @return a stream of {@link ResourcePatternHints}\r\n */\r\npublic Stream<ResourcePatternHints> resourcePatternHints() {\r\n    Stream<ResourcePatternHints> patterns = this.resourcePatternHints.stream();\r\n    return (this.types.isEmpty() ? patterns : Stream.concat(Stream.of(typesPatternResourceHint()), patterns));\r\n}",
    "comment": "\n\t * Return the resources that should be made available at runtime.\n\t * @return a stream of {@link ResourcePatternHints}\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#resourceBundleHints()",
    "entityType": "method",
    "code": "/**\r\n * Return the resource bundles that should be made available at runtime.\r\n * @return a stream of {@link ResourceBundleHint}\r\n */\r\npublic Stream<ResourceBundleHint> resourceBundleHints() {\r\n    return this.resourceBundleHints.stream();\r\n}",
    "comment": "\n\t * Return the resource bundles that should be made available at runtime.\n\t * @return a stream of {@link ResourceBundleHint}\n\t "
  },
  {
    "entityId": "org.springframework.util.CompositeSetTests#testEquals()",
    "entityType": "method",
    "code": "@Test\r\nvoid testEquals() {\r\n    Set<String> first = Set.of(\"foo\", \"bar\");\r\n    Set<String> second = Set.of(\"baz\", \"qux\");\r\n    CompositeSet<String> composite = new CompositeSet<>(first, second);\r\n    Set<String> all = new HashSet<>(first);\r\n    all.addAll(second);\r\n    assertThat(composite.equals(all)).isTrue();\r\n    assertThat(composite.equals(first)).isFalse();\r\n    assertThat(composite.equals(second)).isFalse();\r\n    assertThat(composite.equals(Collections.emptySet())).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerPatternIfPresent(ClassLoader,String,Consumer<ResourcePatternHints.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register a pattern if the given {@code location} is available on the\r\n * classpath. This delegates to {@link ClassLoader#getResource(String)}\r\n * which validates directories as well. The location is not included in\r\n * the hint.\r\n * @param classLoader the classloader to use\r\n * @param location a '/'-separated path name that should exist\r\n * @param resourceHint a builder to customize the resource pattern\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerPatternIfPresent(@Nullable ClassLoader classLoader, String location, Consumer<ResourcePatternHints.Builder> resourceHint) {\r\n    ClassLoader classLoaderToUse = (classLoader != null ? classLoader : getClass().getClassLoader());\r\n    if (classLoaderToUse.getResource(location) != null) {\r\n        registerPattern(resourceHint);\r\n    }\r\n    return this;\r\n}",
    "comment": "\n\t * Register a pattern if the given {@code location} is available on the\n\t * classpath. This delegates to {@link ClassLoader#getResource(String)}\n\t * which validates directories as well. The location is not included in\n\t * the hint.\n\t * @param classLoader the classloader to use\n\t * @param location a '/'-separated path name that should exist\n\t * @param resourceHint a builder to customize the resource pattern\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerPattern(Consumer<ResourcePatternHints.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register that the resources matching the specified pattern should be\r\n * made available at runtime.\r\n * @param resourceHint a builder to further customize the resource pattern\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerPattern(@Nullable Consumer<ResourcePatternHints.Builder> resourceHint) {\r\n    ResourcePatternHints.Builder builder = new ResourcePatternHints.Builder();\r\n    if (resourceHint != null) {\r\n        resourceHint.accept(builder);\r\n    }\r\n    this.resourcePatternHints.add(builder.build());\r\n    return this;\r\n}",
    "comment": "\n\t * Register that the resources matching the specified pattern should be\n\t * made available at runtime.\n\t * @param resourceHint a builder to further customize the resource pattern\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerPattern(String)",
    "entityType": "method",
    "code": "/**\r\n * Register that the resources matching the specified pattern should be\r\n * made available at runtime.\r\n * @param include a pattern of the resources to include (see {@link ResourcePatternHint} documentation)\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerPattern(String include) {\r\n    return registerPattern(builder -> builder.includes(include));\r\n}",
    "comment": "\n\t * Register that the resources matching the specified pattern should be\n\t * made available at runtime.\n\t * @param include a pattern of the resources to include (see {@link ResourcePatternHint} documentation)\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerResource(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Register that the supplied resource should be made available at runtime.\r\n * @param resource the resource to register\r\n * @throws IllegalArgumentException if the supplied resource is not a\r\n * {@link ClassPathResource} or does not {@linkplain Resource#exists() exist}\r\n * @see #registerPattern(String)\r\n * @see ClassPathResource#getPath()\r\n */\r\npublic void registerResource(Resource resource) {\r\n    if (resource instanceof ClassPathResource classPathResource && classPathResource.exists()) {\r\n        registerPattern(classPathResource.getPath());\r\n    } else {\r\n        throw new IllegalArgumentException(\"Resource must be a ClassPathResource that exists: \" + resource);\r\n    }\r\n}",
    "comment": "\n\t * Register that the supplied resource should be made available at runtime.\n\t * @param resource the resource to register\n\t * @throws IllegalArgumentException if the supplied resource is not a\n\t * {@link ClassPathResource} or does not {@linkplain Resource#exists() exist}\n\t * @see #registerPattern(String)\n\t * @see ClassPathResource#getPath()\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Register that the bytecode of the type defined by the specified\r\n * {@link TypeReference} should be made available at runtime.\r\n * @param type the type to include\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerType(TypeReference type) {\r\n    this.types.add(type);\r\n    return this;\r\n}",
    "comment": "\n\t * Register that the bytecode of the type defined by the specified\n\t * {@link TypeReference} should be made available at runtime.\n\t * @param type the type to include\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerType(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Register that the bytecode of the specified type should be made\r\n * available at runtime.\r\n * @param type the type to include\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerType(Class<?> type) {\r\n    return registerType(TypeReference.of(type));\r\n}",
    "comment": "\n\t * Register that the bytecode of the specified type should be made\n\t * available at runtime.\n\t * @param type the type to include\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerResourceBundle(String,Consumer<ResourceBundleHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register that the resource bundle with the specified base name should\r\n * be made available at runtime.\r\n * @param baseName the base name of the resource bundle\r\n * @param resourceHint a builder to further customize the resource bundle\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerResourceBundle(String baseName, @Nullable Consumer<ResourceBundleHint.Builder> resourceHint) {\r\n    ResourceBundleHint.Builder builder = new ResourceBundleHint.Builder(baseName);\r\n    if (resourceHint != null) {\r\n        resourceHint.accept(builder);\r\n    }\r\n    this.resourceBundleHints.add(builder.build());\r\n    return this;\r\n}",
    "comment": "\n\t * Register that the resource bundle with the specified base name should\n\t * be made available at runtime.\n\t * @param baseName the base name of the resource bundle\n\t * @param resourceHint a builder to further customize the resource bundle\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#registerResourceBundle(String)",
    "entityType": "method",
    "code": "/**\r\n * Register that the resource bundle with the specified base name should\r\n * be made available at runtime.\r\n * @param baseName the base name of the resource bundle\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic ResourceHints registerResourceBundle(String baseName) {\r\n    return registerResourceBundle(baseName, null);\r\n}",
    "comment": "\n\t * Register that the resource bundle with the specified base name should\n\t * be made available at runtime.\n\t * @param baseName the base name of the resource bundle\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#typesPatternResourceHint()",
    "entityType": "method",
    "code": "private ResourcePatternHints typesPatternResourceHint() {\r\n    ResourcePatternHints.Builder builder = new ResourcePatternHints.Builder();\r\n    this.types.forEach(type -> builder.includes(toIncludePattern(type)));\r\n    return builder.build();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourceHints#toIncludePattern(TypeReference)",
    "entityType": "method",
    "code": "private String toIncludePattern(TypeReference type) {\r\n    return type.getName().replace(\".\", \"/\") + \".class\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapterTests",
    "entityType": "class",
    "code": "private Future<Integer> adaptee = mock();\nprivate FutureAdapter<String, Integer> adapter = new FutureAdapter<>(adaptee) {\r\n\r\n    @Override\r\n    protected String adapt(Integer adapteeResult) {\r\n        return adapteeResult.toString();\r\n    }\r\n};\n@Test\r\nvoid cancel() {\r\n    given(adaptee.cancel(true)).willReturn(true);\r\n    boolean result = adapter.cancel(true);\r\n    assertThat(result).isTrue();\r\n}\n@Test\r\nvoid isCancelled() {\r\n    given(adaptee.isCancelled()).willReturn(true);\r\n    boolean result = adapter.isCancelled();\r\n    assertThat(result).isTrue();\r\n}\n@Test\r\nvoid isDone() {\r\n    given(adaptee.isDone()).willReturn(true);\r\n    boolean result = adapter.isDone();\r\n    assertThat(result).isTrue();\r\n}\n@Test\r\nvoid get() throws Exception {\r\n    given(adaptee.get()).willReturn(42);\r\n    String result = adapter.get();\r\n    assertThat(result).isEqualTo(\"42\");\r\n}\n@Test\r\nvoid getTimeOut() throws Exception {\r\n    given(adaptee.get(1, TimeUnit.SECONDS)).willReturn(42);\r\n    String result = adapter.get(1, TimeUnit.SECONDS);\r\n    assertThat(result).isEqualTo(\"42\");\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapterTests#cancel()",
    "entityType": "method",
    "code": "@Test\r\nvoid cancel() {\r\n    given(adaptee.cancel(true)).willReturn(true);\r\n    boolean result = adapter.cancel(true);\r\n    assertThat(result).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapterTests#isCancelled()",
    "entityType": "method",
    "code": "@Test\r\nvoid isCancelled() {\r\n    given(adaptee.isCancelled()).willReturn(true);\r\n    boolean result = adapter.isCancelled();\r\n    assertThat(result).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapterTests#isDone()",
    "entityType": "method",
    "code": "@Test\r\nvoid isDone() {\r\n    given(adaptee.isDone()).willReturn(true);\r\n    boolean result = adapter.isDone();\r\n    assertThat(result).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapterTests#get()",
    "entityType": "method",
    "code": "@Test\r\nvoid get() throws Exception {\r\n    given(adaptee.get()).willReturn(42);\r\n    String result = adapter.get();\r\n    assertThat(result).isEqualTo(\"42\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureAdapterTests#getTimeOut()",
    "entityType": "method",
    "code": "@Test\r\nvoid getTimeOut() throws Exception {\r\n    given(adaptee.get(1, TimeUnit.SECONDS)).willReturn(42);\r\n    String result = adapter.get(1, TimeUnit.SECONDS);\r\n    assertThat(result).isEqualTo(\"42\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHint",
    "entityType": "class",
    "code": "private static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();\nprivate final String pattern;\n@Nullable\r\nprivate final TypeReference reachableType;\nResourcePatternHint(String pattern, @Nullable TypeReference reachableType) {\r\n    Assert.isTrue((\"/\".equals(pattern) || !pattern.startsWith(\"/\")), () -> \"Resource pattern [%s] must not start with a '/' unless it is the root directory\".formatted(pattern));\r\n    this.pattern = pattern;\r\n    this.reachableType = reachableType;\r\n}\n/**\r\n * Return the pattern to use for identifying the resources to match.\r\n */\r\npublic String getPattern() {\r\n    return this.pattern;\r\n}\n/**\r\n * Whether the given path matches the current glob pattern.\r\n * @param path the path to match against\r\n */\r\npublic boolean matches(String path) {\r\n    return PATH_MATCHER.match(this.pattern, path);\r\n}\n@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ResourcePatternHint that && this.pattern.equals(that.pattern) && Objects.equals(this.reachableType, that.reachableType)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.pattern, this.reachableType);\r\n}",
    "comment": "\n * A hint that describes resources that should be made available at runtime.\n *\n * <p>Each pattern may be a simple path which has a one-to-one mapping to a\n * resource on the classpath, or alternatively may contain the special\n * {@code *} character to indicate a wildcard match. For example:\n * <ul>\n *     <li>\"file.properties\": matches just the {@code file.properties}\n *         file at the root of the classpath.</li>\n *     <li>\"com/example/file.properties\": matches just the\n *         {@code file.properties} file in {@code com/example/}.</li>\n *     <li>\"*.properties\": matches all the files with a {@code .properties}\n *         extension at the root of the classpath.</li>\n *     <li>\"com/example/*.properties\": matches all the files with a {@code .properties}\n *         extension in {@code com/example/}.</li>\n *     <li>\"com/example/{@literal **}\": matches all the files in {@code com/example/}\n *         and its child directories at any depth.</li>\n *     <li>\"com/example/{@literal **}/*.properties\": matches all the files with a {@code .properties}\n *         extension in {@code com/example/} and its child directories at any depth.</li>\n * </ul>\n *\n * <p>A resource pattern must not start with a slash ({@code /}) unless it is the\n * root directory.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @author Sam Brannen\n * @since 6.0\n "
  }
]