[
  {
    "entityId": "org.springframework.core.io.support.PropertySourceProcessor#addPropertySource(PropertySource<?>)",
    "entityType": "method",
    "code": "private void addPropertySource(PropertySource<?> propertySource) {\r\n    String name = propertySource.getName();\r\n    MutablePropertySources propertySources = this.environment.getPropertySources();\r\n    if (this.propertySourceNames.contains(name)) {\r\n        // We've already added a version, we need to extend it\r\n        PropertySource<?> existing = propertySources.get(name);\r\n        if (existing != null) {\r\n            PropertySource<?> newSource = (propertySource instanceof ResourcePropertySource rps ? rps.withResourceName() : propertySource);\r\n            if (existing instanceof CompositePropertySource cps) {\r\n                cps.addFirstPropertySource(newSource);\r\n            } else {\r\n                if (existing instanceof ResourcePropertySource rps) {\r\n                    existing = rps.withResourceName();\r\n                }\r\n                CompositePropertySource composite = new CompositePropertySource(name);\r\n                composite.addPropertySource(newSource);\r\n                composite.addPropertySource(existing);\r\n                propertySources.replace(name, composite);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    if (this.propertySourceNames.isEmpty()) {\r\n        propertySources.addLast(propertySource);\r\n    } else {\r\n        String lastAdded = this.propertySourceNames.get(this.propertySourceNames.size() - 1);\r\n        propertySources.addBefore(lastAdded, propertySource);\r\n    }\r\n    this.propertySourceNames.add(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PropertySourceProcessor#instantiateClass(Class<? extends PropertySourceFactory>)",
    "entityType": "method",
    "code": "private static PropertySourceFactory instantiateClass(Class<? extends PropertySourceFactory> type) {\r\n    try {\r\n        Constructor<? extends PropertySourceFactory> constructor = type.getDeclaredConstructor();\r\n        ReflectionUtils.makeAccessible(constructor);\r\n        return constructor.newInstance();\r\n    } catch (Exception ex) {\r\n        throw new IllegalStateException(\"Failed to instantiate \" + type, ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.PropertySourceProcessor#isIgnorableException(Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the supplied exception can be ignored according to\r\n * {@code ignoreResourceNotFound} semantics.\r\n */\r\nprivate static boolean isIgnorableException(@Nullable Throwable ex) {\r\n    return (ex instanceof FileNotFoundException || ex instanceof UnknownHostException || ex instanceof SocketException);\r\n}",
    "comment": "\n\t * Determine if the supplied exception can be ignored according to\n\t * {@code ignoreResourceNotFound} semantics.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceArrayPropertyEditor",
    "entityType": "class",
    "code": "private static final Log logger = LogFactory.getLog(ResourceArrayPropertyEditor.class);\nprivate final ResourcePatternResolver resourcePatternResolver;\n@Nullable\r\nprivate PropertyResolver propertyResolver;\nprivate final boolean ignoreUnresolvablePlaceholders;\n/**\r\n * Create a new ResourceArrayPropertyEditor with a default\r\n * {@link PathMatchingResourcePatternResolver} and {@link StandardEnvironment}.\r\n * @see PathMatchingResourcePatternResolver\r\n * @see Environment\r\n */\r\npublic ResourceArrayPropertyEditor() {\r\n    this(new PathMatchingResourcePatternResolver(), null, true);\r\n}\n/**\r\n * Create a new ResourceArrayPropertyEditor with the given {@link ResourcePatternResolver}\r\n * and {@link PropertyResolver} (typically an {@link Environment}).\r\n * @param resourcePatternResolver the ResourcePatternResolver to use\r\n * @param propertyResolver the PropertyResolver to use\r\n */\r\npublic ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver, @Nullable PropertyResolver propertyResolver) {\r\n    this(resourcePatternResolver, propertyResolver, true);\r\n}\n/**\r\n * Create a new ResourceArrayPropertyEditor with the given {@link ResourcePatternResolver}\r\n * and {@link PropertyResolver} (typically an {@link Environment}).\r\n * @param resourcePatternResolver the ResourcePatternResolver to use\r\n * @param propertyResolver the PropertyResolver to use\r\n * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholders\r\n * if no corresponding system property could be found\r\n */\r\npublic ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver, @Nullable PropertyResolver propertyResolver, boolean ignoreUnresolvablePlaceholders) {\r\n    Assert.notNull(resourcePatternResolver, \"ResourcePatternResolver must not be null\");\r\n    this.resourcePatternResolver = resourcePatternResolver;\r\n    this.propertyResolver = propertyResolver;\r\n    this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;\r\n}\n/**\r\n * Treat the given text as a location pattern or comma delimited location patterns\r\n * and convert it to a Resource array.\r\n */\r\n@Override\r\npublic void setAsText(String text) {\r\n    String pattern = resolvePath(text).trim();\r\n    String[] locationPatterns = StringUtils.commaDelimitedListToStringArray(pattern);\r\n    if (locationPatterns.length == 1) {\r\n        setValue(getResources(locationPatterns[0]));\r\n    } else {\r\n        Resource[] resources = Arrays.stream(locationPatterns).map(String::trim).map(this::getResources).flatMap(Arrays::stream).toArray(Resource[]::new);\r\n        setValue(resources);\r\n    }\r\n}\nprivate Resource[] getResources(String locationPattern) {\r\n    try {\r\n        return this.resourcePatternResolver.getResources(locationPattern);\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Could not resolve resource location pattern [\" + locationPattern + \"]: \" + ex.getMessage());\r\n    }\r\n}\n/**\r\n * Treat the given value as a collection or array and convert it to a Resource array.\r\n * <p>Considers String elements as location patterns and takes Resource elements as-is.\r\n */\r\n@Override\r\npublic void setValue(Object value) throws IllegalArgumentException {\r\n    if (value instanceof Collection || (value instanceof Object[] && !(value instanceof Resource[]))) {\r\n        Collection<?> input = (value instanceof Collection<?> collection ? collection : Arrays.asList((Object[]) value));\r\n        Set<Resource> merged = new LinkedHashSet<>();\r\n        for (Object element : input) {\r\n            if (element instanceof String path) {\r\n                // A location pattern: resolve it into a Resource array.\r\n                // Might point to a single resource or to multiple resources.\r\n                String pattern = resolvePath(path.trim());\r\n                try {\r\n                    Resource[] resources = this.resourcePatternResolver.getResources(pattern);\r\n                    Collections.addAll(merged, resources);\r\n                } catch (IOException ex) {\r\n                    // ignore - might be an unresolved placeholder or non-existing base directory\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Could not retrieve resources for pattern '\" + pattern + \"'\", ex);\r\n                    }\r\n                }\r\n            } else if (element instanceof Resource resource) {\r\n                // A Resource object: add it to the result.\r\n                merged.add(resource);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Cannot convert element [\" + element + \"] to [\" + Resource.class.getName() + \"]: only location String and Resource object supported\");\r\n            }\r\n        }\r\n        super.setValue(merged.toArray(new Resource[0]));\r\n    } else {\r\n        // An arbitrary value: probably a String or a Resource array.\r\n        // setAsText will be called for a String; a Resource array will be used as-is.\r\n        super.setValue(value);\r\n    }\r\n}\n/**\r\n * Resolve the given path, replacing placeholders with\r\n * corresponding system property values if necessary.\r\n * @param path the original file path\r\n * @return the resolved file path\r\n * @see PropertyResolver#resolvePlaceholders\r\n * @see PropertyResolver#resolveRequiredPlaceholders(String)\r\n */\r\nprotected String resolvePath(String path) {\r\n    if (this.propertyResolver == null) {\r\n        this.propertyResolver = new StandardEnvironment();\r\n    }\r\n    return (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) : this.propertyResolver.resolveRequiredPlaceholders(path));\r\n}",
    "comment": "\n * Editor for {@link org.springframework.core.io.Resource} arrays, to\n * automatically convert {@code String} location patterns\n * (for example, {@code \"file:C:/my*.txt\"} or {@code \"classpath*:myfile.txt\"})\n * to {@code Resource} array properties. Can also translate a collection\n * or array of location patterns into a merged Resource array.\n *\n * <p>A path may contain {@code ${...}} placeholders, to be\n * resolved as {@link org.springframework.core.env.Environment} properties:\n * for example, {@code ${user.dir}}. Unresolvable placeholders are ignored by default.\n *\n * <p>Delegates to a {@link ResourcePatternResolver},\n * by default using a {@link PathMatchingResourcePatternResolver}.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @author Yanming Zhou\n * @author Stephane Nicoll\n * @since 1.1.2\n * @see org.springframework.core.io.Resource\n * @see ResourcePatternResolver\n * @see PathMatchingResourcePatternResolver\n "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceArrayPropertyEditor#setAsText(String)",
    "entityType": "method",
    "code": "/**\r\n * Treat the given text as a location pattern or comma delimited location patterns\r\n * and convert it to a Resource array.\r\n */\r\n@Override\r\npublic void setAsText(String text) {\r\n    String pattern = resolvePath(text).trim();\r\n    String[] locationPatterns = StringUtils.commaDelimitedListToStringArray(pattern);\r\n    if (locationPatterns.length == 1) {\r\n        setValue(getResources(locationPatterns[0]));\r\n    } else {\r\n        Resource[] resources = Arrays.stream(locationPatterns).map(String::trim).map(this::getResources).flatMap(Arrays::stream).toArray(Resource[]::new);\r\n        setValue(resources);\r\n    }\r\n}",
    "comment": "\n\t * Treat the given text as a location pattern or comma delimited location patterns\n\t * and convert it to a Resource array.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceArrayPropertyEditor#getResources(String)",
    "entityType": "method",
    "code": "private Resource[] getResources(String locationPattern) {\r\n    try {\r\n        return this.resourcePatternResolver.getResources(locationPattern);\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Could not resolve resource location pattern [\" + locationPattern + \"]: \" + ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceArrayPropertyEditor#setValue(Object)",
    "entityType": "method",
    "code": "/**\r\n * Treat the given value as a collection or array and convert it to a Resource array.\r\n * <p>Considers String elements as location patterns and takes Resource elements as-is.\r\n */\r\n@Override\r\npublic void setValue(Object value) throws IllegalArgumentException {\r\n    if (value instanceof Collection || (value instanceof Object[] && !(value instanceof Resource[]))) {\r\n        Collection<?> input = (value instanceof Collection<?> collection ? collection : Arrays.asList((Object[]) value));\r\n        Set<Resource> merged = new LinkedHashSet<>();\r\n        for (Object element : input) {\r\n            if (element instanceof String path) {\r\n                // A location pattern: resolve it into a Resource array.\r\n                // Might point to a single resource or to multiple resources.\r\n                String pattern = resolvePath(path.trim());\r\n                try {\r\n                    Resource[] resources = this.resourcePatternResolver.getResources(pattern);\r\n                    Collections.addAll(merged, resources);\r\n                } catch (IOException ex) {\r\n                    // ignore - might be an unresolved placeholder or non-existing base directory\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Could not retrieve resources for pattern '\" + pattern + \"'\", ex);\r\n                    }\r\n                }\r\n            } else if (element instanceof Resource resource) {\r\n                // A Resource object: add it to the result.\r\n                merged.add(resource);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Cannot convert element [\" + element + \"] to [\" + Resource.class.getName() + \"]: only location String and Resource object supported\");\r\n            }\r\n        }\r\n        super.setValue(merged.toArray(new Resource[0]));\r\n    } else {\r\n        // An arbitrary value: probably a String or a Resource array.\r\n        // setAsText will be called for a String; a Resource array will be used as-is.\r\n        super.setValue(value);\r\n    }\r\n}",
    "comment": "\n\t * Treat the given value as a collection or array and convert it to a Resource array.\n\t * <p>Considers String elements as location patterns and takes Resource elements as-is.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceArrayPropertyEditor#resolvePath(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given path, replacing placeholders with\r\n * corresponding system property values if necessary.\r\n * @param path the original file path\r\n * @return the resolved file path\r\n * @see PropertyResolver#resolvePlaceholders\r\n * @see PropertyResolver#resolveRequiredPlaceholders(String)\r\n */\r\nprotected String resolvePath(String path) {\r\n    if (this.propertyResolver == null) {\r\n        this.propertyResolver = new StandardEnvironment();\r\n    }\r\n    return (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) : this.propertyResolver.resolveRequiredPlaceholders(path));\r\n}",
    "comment": "\n\t * Resolve the given path, replacing placeholders with\n\t * corresponding system property values if necessary.\n\t * @param path the original file path\n\t * @return the resolved file path\n\t * @see PropertyResolver#resolvePlaceholders\n\t * @see PropertyResolver#resolveRequiredPlaceholders(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePatternResolver",
    "entityType": "class",
    "code": "/**\r\n * Pseudo URL prefix for all matching resources from the class path: {@code \"classpath*:\"}.\r\n * <p>This differs from ResourceLoader's {@code \"classpath:\"} URL prefix in\r\n * that it retrieves all matching resources for a given path &mdash; for\r\n * example, to locate all \"beans.xml\" files in the root of all deployed JAR\r\n * files you can use the location pattern {@code \"classpath*:/beans.xml\"}.\r\n * <p>As of Spring Framework 6.0, the semantics for the {@code \"classpath*:\"}\r\n * prefix have been expanded to include the module path as well as the class path.\r\n * @see org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX\r\n */\r\nString CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n/**\r\n * Resolve the given location pattern into {@code Resource} objects.\r\n * <p>Overlapping resource entries that point to the same physical\r\n * resource should be avoided, as far as possible. The result should\r\n * have set semantics.\r\n * @param locationPattern the location pattern to resolve\r\n * @return the corresponding {@code Resource} objects\r\n * @throws IOException in case of I/O errors\r\n */\r\nResource[] getResources(String locationPattern) throws IOException;",
    "comment": "\n * Strategy interface for resolving a location pattern (for example,\n * an Ant-style path pattern) into {@link Resource} objects.\n *\n * <p>This is an extension to the {@link org.springframework.core.io.ResourceLoader}\n * interface. A passed-in {@code ResourceLoader} (for example, an\n * {@link org.springframework.context.ApplicationContext} passed in via\n * {@link org.springframework.context.ResourceLoaderAware} when running in a context)\n * can be checked whether it implements this extended interface too.\n *\n * <p>{@link PathMatchingResourcePatternResolver} is a standalone implementation\n * that is usable outside an {@code ApplicationContext}, also used by\n * {@link ResourceArrayPropertyEditor} for populating {@code Resource} array bean\n * properties.\n *\n * <p>Can be used with any sort of location pattern &mdash; for example,\n * {@code \"/WEB-INF/*-context.xml\"}. However, input patterns have to match the\n * strategy implementation. This interface just specifies the conversion method\n * rather than a specific pattern format.\n *\n * <p>This interface also defines a {@value #CLASSPATH_ALL_URL_PREFIX} resource\n * prefix for all matching resources from the module path and the class path. Note\n * that the resource location may also contain placeholders &mdash; for example\n * {@code \"/beans-*.xml\"}. JAR files or different directories in the module path\n * or class path can contain multiple files of the same name.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 1.0.2\n * @see org.springframework.core.io.Resource\n * @see org.springframework.core.io.ResourceLoader\n * @see org.springframework.context.ApplicationContext\n * @see org.springframework.context.ResourceLoaderAware\n "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePatternResolver#getResources(String)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given location pattern into {@code Resource} objects.\r\n * <p>Overlapping resource entries that point to the same physical\r\n * resource should be avoided, as far as possible. The result should\r\n * have set semantics.\r\n * @param locationPattern the location pattern to resolve\r\n * @return the corresponding {@code Resource} objects\r\n * @throws IOException in case of I/O errors\r\n */\r\nResource[] getResources(String locationPattern) throws IOException;",
    "comment": "\n\t * Resolve the given location pattern into {@code Resource} objects.\n\t * <p>Overlapping resource entries that point to the same physical\n\t * resource should be avoided, as far as possible. The result should\n\t * have set semantics.\n\t * @param locationPattern the location pattern to resolve\n\t * @return the corresponding {@code Resource} objects\n\t * @throws IOException in case of I/O errors\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePatternUtils",
    "entityType": "class",
    "code": "/**\r\n * Return whether the given resource location is a URL: either a\r\n * special \"classpath\" or \"classpath*\" pseudo URL or a standard URL.\r\n * @param resourceLocation the location String to check\r\n * @return whether the location qualifies as a URL\r\n * @see ResourcePatternResolver#CLASSPATH_ALL_URL_PREFIX\r\n * @see org.springframework.util.ResourceUtils#CLASSPATH_URL_PREFIX\r\n * @see org.springframework.util.ResourceUtils#isUrl(String)\r\n * @see java.net.URL\r\n */\r\npublic static boolean isUrl(@Nullable String resourceLocation) {\r\n    return (resourceLocation != null && (resourceLocation.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX) || ResourceUtils.isUrl(resourceLocation)));\r\n}\n/**\r\n * Return a default {@link ResourcePatternResolver} for the given {@link ResourceLoader}.\r\n * <p>This might be the {@code ResourceLoader} itself, if it implements the\r\n * {@code ResourcePatternResolver} extension, or a default\r\n * {@link PathMatchingResourcePatternResolver} built on the given {@code ResourceLoader}.\r\n * @param resourceLoader the ResourceLoader to build a pattern resolver for\r\n * (may be {@code null} to indicate a default ResourceLoader)\r\n * @return the ResourcePatternResolver\r\n * @see PathMatchingResourcePatternResolver\r\n */\r\npublic static ResourcePatternResolver getResourcePatternResolver(@Nullable ResourceLoader resourceLoader) {\r\n    if (resourceLoader instanceof ResourcePatternResolver resolver) {\r\n        return resolver;\r\n    } else if (resourceLoader != null) {\r\n        return new PathMatchingResourcePatternResolver(resourceLoader);\r\n    } else {\r\n        return new PathMatchingResourcePatternResolver();\r\n    }\r\n}",
    "comment": "\n * Utility class for determining whether a given URL is a resource\n * location that can be loaded via a {@link ResourcePatternResolver}.\n *\n * <p>Callers will usually assume that a location is a relative path\n * if the {@link #isUrl(String)} method returns {@code false}.\n *\n * @author Juergen Hoeller\n * @since 1.2.3\n "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePatternUtils#isUrl(String)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the given resource location is a URL: either a\r\n * special \"classpath\" or \"classpath*\" pseudo URL or a standard URL.\r\n * @param resourceLocation the location String to check\r\n * @return whether the location qualifies as a URL\r\n * @see ResourcePatternResolver#CLASSPATH_ALL_URL_PREFIX\r\n * @see org.springframework.util.ResourceUtils#CLASSPATH_URL_PREFIX\r\n * @see org.springframework.util.ResourceUtils#isUrl(String)\r\n * @see java.net.URL\r\n */\r\npublic static boolean isUrl(@Nullable String resourceLocation) {\r\n    return (resourceLocation != null && (resourceLocation.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX) || ResourceUtils.isUrl(resourceLocation)));\r\n}",
    "comment": "\n\t * Return whether the given resource location is a URL: either a\n\t * special \"classpath\" or \"classpath*\" pseudo URL or a standard URL.\n\t * @param resourceLocation the location String to check\n\t * @return whether the location qualifies as a URL\n\t * @see ResourcePatternResolver#CLASSPATH_ALL_URL_PREFIX\n\t * @see org.springframework.util.ResourceUtils#CLASSPATH_URL_PREFIX\n\t * @see org.springframework.util.ResourceUtils#isUrl(String)\n\t * @see java.net.URL\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePatternUtils#getResourcePatternResolver(ResourceLoader)",
    "entityType": "method",
    "code": "/**\r\n * Return a default {@link ResourcePatternResolver} for the given {@link ResourceLoader}.\r\n * <p>This might be the {@code ResourceLoader} itself, if it implements the\r\n * {@code ResourcePatternResolver} extension, or a default\r\n * {@link PathMatchingResourcePatternResolver} built on the given {@code ResourceLoader}.\r\n * @param resourceLoader the ResourceLoader to build a pattern resolver for\r\n * (may be {@code null} to indicate a default ResourceLoader)\r\n * @return the ResourcePatternResolver\r\n * @see PathMatchingResourcePatternResolver\r\n */\r\npublic static ResourcePatternResolver getResourcePatternResolver(@Nullable ResourceLoader resourceLoader) {\r\n    if (resourceLoader instanceof ResourcePatternResolver resolver) {\r\n        return resolver;\r\n    } else if (resourceLoader != null) {\r\n        return new PathMatchingResourcePatternResolver(resourceLoader);\r\n    } else {\r\n        return new PathMatchingResourcePatternResolver();\r\n    }\r\n}",
    "comment": "\n\t * Return a default {@link ResourcePatternResolver} for the given {@link ResourceLoader}.\n\t * <p>This might be the {@code ResourceLoader} itself, if it implements the\n\t * {@code ResourcePatternResolver} extension, or a default\n\t * {@link PathMatchingResourcePatternResolver} built on the given {@code ResourceLoader}.\n\t * @param resourceLoader the ResourceLoader to build a pattern resolver for\n\t * (may be {@code null} to indicate a default ResourceLoader)\n\t * @return the ResourcePatternResolver\n\t * @see PathMatchingResourcePatternResolver\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePropertySource",
    "entityType": "class",
    "code": "/**\r\n * The original resource name, if different from the given name.\r\n */\r\n@Nullable\r\nprivate final String resourceName;\n/**\r\n * Create a PropertySource having the given name based on Properties\r\n * loaded from the given encoded resource.\r\n */\r\npublic ResourcePropertySource(String name, EncodedResource resource) throws IOException {\r\n    super(name, PropertiesLoaderUtils.loadProperties(resource));\r\n    this.resourceName = getNameForResource(resource.getResource());\r\n}\n/**\r\n * Create a PropertySource based on Properties loaded from the given resource.\r\n * The name of the PropertySource will be generated based on the\r\n * {@link Resource#getDescription() description} of the given resource.\r\n */\r\npublic ResourcePropertySource(EncodedResource resource) throws IOException {\r\n    super(getNameForResource(resource.getResource()), PropertiesLoaderUtils.loadProperties(resource));\r\n    this.resourceName = null;\r\n}\n/**\r\n * Create a PropertySource having the given name based on Properties\r\n * loaded from the given encoded resource.\r\n */\r\npublic ResourcePropertySource(String name, Resource resource) throws IOException {\r\n    super(name, PropertiesLoaderUtils.loadProperties(new EncodedResource(resource)));\r\n    this.resourceName = getNameForResource(resource);\r\n}\n/**\r\n * Create a PropertySource based on Properties loaded from the given resource.\r\n * The name of the PropertySource will be generated based on the\r\n * {@link Resource#getDescription() description} of the given resource.\r\n */\r\npublic ResourcePropertySource(Resource resource) throws IOException {\r\n    super(getNameForResource(resource), PropertiesLoaderUtils.loadProperties(new EncodedResource(resource)));\r\n    this.resourceName = null;\r\n}\n/**\r\n * Create a PropertySource having the given name based on Properties loaded from\r\n * the given resource location and using the given class loader to load the\r\n * resource (assuming it is prefixed with {@code classpath:}).\r\n */\r\npublic ResourcePropertySource(String name, String location, ClassLoader classLoader) throws IOException {\r\n    this(name, new DefaultResourceLoader(classLoader).getResource(location));\r\n}\n/**\r\n * Create a PropertySource based on Properties loaded from the given resource\r\n * location and use the given class loader to load the resource, assuming it is\r\n * prefixed with {@code classpath:}. The name of the PropertySource will be\r\n * generated based on the {@link Resource#getDescription() description} of the\r\n * resource.\r\n */\r\npublic ResourcePropertySource(String location, ClassLoader classLoader) throws IOException {\r\n    this(new DefaultResourceLoader(classLoader).getResource(location));\r\n}\n/**\r\n * Create a PropertySource having the given name based on Properties loaded from\r\n * the given resource location. The default thread context class loader will be\r\n * used to load the resource (assuming the location string is prefixed with\r\n * {@code classpath:}).\r\n */\r\npublic ResourcePropertySource(String name, String location) throws IOException {\r\n    this(name, new DefaultResourceLoader().getResource(location));\r\n}\n/**\r\n * Create a PropertySource based on Properties loaded from the given resource\r\n * location. The name of the PropertySource will be generated based on the\r\n * {@link Resource#getDescription() description} of the resource.\r\n */\r\npublic ResourcePropertySource(String location) throws IOException {\r\n    this(new DefaultResourceLoader().getResource(location));\r\n}\nprivate ResourcePropertySource(String name, @Nullable String resourceName, Map<String, Object> source) {\r\n    super(name, source);\r\n    this.resourceName = resourceName;\r\n}\n/**\r\n * Return a potentially adapted variant of this {@link ResourcePropertySource},\r\n * overriding the previously given (or derived) name with the specified name.\r\n * @since 4.0.4\r\n */\r\npublic ResourcePropertySource withName(String name) {\r\n    if (this.name.equals(name)) {\r\n        return this;\r\n    }\r\n    // Store the original resource name if necessary...\r\n    if (this.resourceName != null) {\r\n        if (this.resourceName.equals(name)) {\r\n            return new ResourcePropertySource(this.resourceName, null, this.source);\r\n        } else {\r\n            return new ResourcePropertySource(name, this.resourceName, this.source);\r\n        }\r\n    } else {\r\n        // Current name is resource name -> preserve it in the extra field...\r\n        return new ResourcePropertySource(name, this.name, this.source);\r\n    }\r\n}\n/**\r\n * Return a potentially adapted variant of this {@link ResourcePropertySource},\r\n * overriding the previously given name (if any) with the original resource name\r\n * (equivalent to the name generated by the name-less constructor variants).\r\n * @since 4.1\r\n */\r\npublic ResourcePropertySource withResourceName() {\r\n    if (this.resourceName == null) {\r\n        return this;\r\n    }\r\n    return new ResourcePropertySource(this.resourceName, null, this.source);\r\n}\n/**\r\n * Return the description for the given Resource; if the description is\r\n * empty, return the class name of the resource plus its identity hash code.\r\n * @see org.springframework.core.io.Resource#getDescription()\r\n */\r\nprivate static String getNameForResource(Resource resource) {\r\n    String name = resource.getDescription();\r\n    if (!StringUtils.hasText(name)) {\r\n        name = resource.getClass().getSimpleName() + \"@\" + System.identityHashCode(resource);\r\n    }\r\n    return name;\r\n}",
    "comment": "\n * Subclass of {@link PropertiesPropertySource} that loads a {@link Properties} object\n * from a given {@link org.springframework.core.io.Resource} or resource location such as\n * {@code \"classpath:/com/myco/foo.properties\"} or {@code \"file:/path/to/file.xml\"}.\n *\n * <p>Both traditional and XML-based properties file formats are supported; however, in\n * order for XML processing to take effect, the underlying {@code Resource}'s\n * {@link org.springframework.core.io.Resource#getFilename() getFilename()} method must\n * return a non-{@code null} value that ends in {@code \".xml\"}.\n *\n * @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.1\n * @see org.springframework.core.io.Resource\n * @see org.springframework.core.io.support.EncodedResource\n "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePropertySource#withName(String)",
    "entityType": "method",
    "code": "/**\r\n * Return a potentially adapted variant of this {@link ResourcePropertySource},\r\n * overriding the previously given (or derived) name with the specified name.\r\n * @since 4.0.4\r\n */\r\npublic ResourcePropertySource withName(String name) {\r\n    if (this.name.equals(name)) {\r\n        return this;\r\n    }\r\n    // Store the original resource name if necessary...\r\n    if (this.resourceName != null) {\r\n        if (this.resourceName.equals(name)) {\r\n            return new ResourcePropertySource(this.resourceName, null, this.source);\r\n        } else {\r\n            return new ResourcePropertySource(name, this.resourceName, this.source);\r\n        }\r\n    } else {\r\n        // Current name is resource name -> preserve it in the extra field...\r\n        return new ResourcePropertySource(name, this.name, this.source);\r\n    }\r\n}",
    "comment": "\n\t * Return a potentially adapted variant of this {@link ResourcePropertySource},\n\t * overriding the previously given (or derived) name with the specified name.\n\t * @since 4.0.4\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePropertySource#withResourceName()",
    "entityType": "method",
    "code": "/**\r\n * Return a potentially adapted variant of this {@link ResourcePropertySource},\r\n * overriding the previously given name (if any) with the original resource name\r\n * (equivalent to the name generated by the name-less constructor variants).\r\n * @since 4.1\r\n */\r\npublic ResourcePropertySource withResourceName() {\r\n    if (this.resourceName == null) {\r\n        return this;\r\n    }\r\n    return new ResourcePropertySource(this.resourceName, null, this.source);\r\n}",
    "comment": "\n\t * Return a potentially adapted variant of this {@link ResourcePropertySource},\n\t * overriding the previously given name (if any) with the original resource name\n\t * (equivalent to the name generated by the name-less constructor variants).\n\t * @since 4.1\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourcePropertySource#getNameForResource(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Return the description for the given Resource; if the description is\r\n * empty, return the class name of the resource plus its identity hash code.\r\n * @see org.springframework.core.io.Resource#getDescription()\r\n */\r\nprivate static String getNameForResource(Resource resource) {\r\n    String name = resource.getDescription();\r\n    if (!StringUtils.hasText(name)) {\r\n        name = resource.getClass().getSimpleName() + \"@\" + System.identityHashCode(resource);\r\n    }\r\n    return name;\r\n}",
    "comment": "\n\t * Return the description for the given Resource; if the description is\n\t * empty, return the class name of the resource plus its identity hash code.\n\t * @see org.springframework.core.io.Resource#getDescription()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceRegion",
    "entityType": "class",
    "code": "private final Resource resource;\nprivate final long position;\nprivate final long count;\n/**\r\n * Create a new {@code ResourceRegion} from a given {@link Resource}.\r\n * This region of a resource is represented by a start {@code position}\r\n * and a byte {@code count} within the given {@code Resource}.\r\n * @param resource a Resource\r\n * @param position the start position of the region in that resource\r\n * @param count the byte count of the region in that resource\r\n */\r\npublic ResourceRegion(Resource resource, long position, long count) {\r\n    Assert.notNull(resource, \"Resource must not be null\");\r\n    Assert.isTrue(position >= 0, \"'position' must be greater than or equal to 0\");\r\n    Assert.isTrue(count >= 0, \"'count' must be greater than or equal to 0\");\r\n    this.resource = resource;\r\n    this.position = position;\r\n    this.count = count;\r\n}\n/**\r\n * Return the underlying {@link Resource} for this {@code ResourceRegion}.\r\n */\r\npublic Resource getResource() {\r\n    return this.resource;\r\n}\n/**\r\n * Return the start position of this region in the underlying {@link Resource}.\r\n */\r\npublic long getPosition() {\r\n    return this.position;\r\n}\n/**\r\n * Return the byte count of this region in the underlying {@link Resource}.\r\n */\r\npublic long getCount() {\r\n    return this.count;\r\n}",
    "comment": "\n * Region of a {@link Resource} implementation, materialized by a {@code position}\n * within the {@link Resource} and a byte {@code count} for the length of that region.\n *\n * @author Arjen Poutsma\n * @since 4.3\n "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceRegion#getResource()",
    "entityType": "method",
    "code": "/**\r\n * Return the underlying {@link Resource} for this {@code ResourceRegion}.\r\n */\r\npublic Resource getResource() {\r\n    return this.resource;\r\n}",
    "comment": "\n\t * Return the underlying {@link Resource} for this {@code ResourceRegion}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceRegion#getPosition()",
    "entityType": "method",
    "code": "/**\r\n * Return the start position of this region in the underlying {@link Resource}.\r\n */\r\npublic long getPosition() {\r\n    return this.position;\r\n}",
    "comment": "\n\t * Return the start position of this region in the underlying {@link Resource}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ResourceRegion#getCount()",
    "entityType": "method",
    "code": "/**\r\n * Return the byte count of this region in the underlying {@link Resource}.\r\n */\r\npublic long getCount() {\r\n    return this.count;\r\n}",
    "comment": "\n\t * Return the byte count of this region in the underlying {@link Resource}.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader",
    "entityType": "class",
    "code": "/**\r\n * The location to look for factories.\r\n * <p>Can be present in multiple JAR files.\r\n */\r\npublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\nprivate static final FailureHandler THROWING_FAILURE_HANDLER = FailureHandler.throwing();\nprivate static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class);\nstatic final Map<ClassLoader, Map<String, SpringFactoriesLoader>> cache = new ConcurrentReferenceHashMap<>();\n@Nullable\r\nprivate final ClassLoader classLoader;\nprivate final Map<String, List<String>> factories;\n/**\r\n * Create a new {@link SpringFactoriesLoader} instance.\r\n * @param classLoader the classloader used to instantiate the factories\r\n * @param factories a map of factory class name to implementation class names\r\n * @since 6.0\r\n */\r\nprotected SpringFactoriesLoader(@Nullable ClassLoader classLoader, Map<String, List<String>> factories) {\r\n    this.classLoader = classLoader;\r\n    this.factories = factories;\r\n}\n/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\r\n * and a default argument resolver that expects a no-arg constructor.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>If a custom instantiation strategy is required, use {@code load(...)}\r\n * with a custom {@link ArgumentResolver ArgumentResolver} and/or\r\n * {@link FailureHandler FailureHandler}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @throws IllegalArgumentException if any factory implementation class cannot\r\n * be loaded or if an error occurs while instantiating any factory\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType) {\r\n    return load(factoryType, null, null);\r\n}\n/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\r\n * and the given argument resolver.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param argumentResolver strategy used to resolve constructor arguments by their type\r\n * @throws IllegalArgumentException if any factory implementation class cannot\r\n * be loaded or if an error occurs while instantiating any factory\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\r\n    return load(factoryType, argumentResolver, null);\r\n}\n/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\r\n * with custom failure handling provided by the given failure handler.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * <p>For any factory implementation class that cannot be loaded or error that\r\n * occurs while instantiating it, the given failure handler is called.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param failureHandler strategy used to handle factory instantiation failures\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler) {\r\n    return load(factoryType, null, failureHandler);\r\n}\n/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\r\n * the given argument resolver, and custom failure handling provided by the given\r\n * failure handler.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * <p>For any factory implementation class that cannot be loaded or error that\r\n * occurs while instantiating it, the given failure handler is called.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param argumentResolver strategy used to resolve constructor arguments by their type\r\n * @param failureHandler strategy used to handle factory instantiation failures\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver, @Nullable FailureHandler failureHandler) {\r\n    Assert.notNull(factoryType, \"'factoryType' must not be null\");\r\n    List<String> implementationNames = loadFactoryNames(factoryType);\r\n    logger.trace(LogMessage.format(\"Loaded [%s] names: %s\", factoryType.getName(), implementationNames));\r\n    List<T> result = new ArrayList<>(implementationNames.size());\r\n    FailureHandler failureHandlerToUse = (failureHandler != null) ? failureHandler : THROWING_FAILURE_HANDLER;\r\n    for (String implementationName : implementationNames) {\r\n        T factory = instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);\r\n        if (factory != null) {\r\n            result.add(factory);\r\n        }\r\n    }\r\n    AnnotationAwareOrderComparator.sort(result);\r\n    return result;\r\n}\nprivate List<String> loadFactoryNames(Class<?> factoryType) {\r\n    return this.factories.getOrDefault(factoryType.getName(), Collections.emptyList());\r\n}\n@Nullable\r\nprotected <T> T instantiateFactory(String implementationName, Class<T> type, @Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\r\n    try {\r\n        Class<?> factoryImplementationClass = ClassUtils.forName(implementationName, this.classLoader);\r\n        Assert.isTrue(type.isAssignableFrom(factoryImplementationClass), () -> \"Class [%s] is not assignable to factory type [%s]\".formatted(implementationName, type.getName()));\r\n        FactoryInstantiator<T> factoryInstantiator = FactoryInstantiator.forClass(factoryImplementationClass);\r\n        return factoryInstantiator.instantiate(argumentResolver);\r\n    } catch (Throwable ex) {\r\n        failureHandler.handleFailure(type, implementationName, ex);\r\n        return null;\r\n    }\r\n}\n/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * <p>For more advanced factory loading with {@link ArgumentResolver} or\r\n * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\r\n * to obtain a {@link SpringFactoriesLoader} instance.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param classLoader the ClassLoader to use for loading (can be {@code null}\r\n * to use the default)\r\n * @throws IllegalArgumentException if any factory implementation class cannot\r\n * be loaded or if an error occurs while instantiating any factory\r\n */\r\npublic static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {\r\n    return forDefaultResourceLocation(classLoader).load(factoryType);\r\n}\n/**\r\n * Load the fully qualified class names of factory implementations of the\r\n * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\r\n * class loader.\r\n * <p>As of Spring Framework 5.3, if a particular implementation class name\r\n * is discovered more than once for the given factory type, duplicates will\r\n * be ignored.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param classLoader the ClassLoader to use for loading resources; can be\r\n * {@code null} to use the default\r\n * @throws IllegalArgumentException if an error occurs while loading factory names\r\n * @see #loadFactories\r\n * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\r\n */\r\n@Deprecated(since = \"6.0\")\r\npublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\r\n    return forDefaultResourceLocation(classLoader).loadFactoryNames(factoryType);\r\n}\n/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the default class loader.\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forDefaultResourceLocation(ClassLoader)\r\n */\r\npublic static SpringFactoriesLoader forDefaultResourceLocation() {\r\n    return forDefaultResourceLocation(null);\r\n}\n/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\r\n * @param classLoader the ClassLoader to use for loading resources; can be\r\n * {@code null} to use the default\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forDefaultResourceLocation()\r\n */\r\npublic static SpringFactoriesLoader forDefaultResourceLocation(@Nullable ClassLoader classLoader) {\r\n    return forResourceLocation(FACTORIES_RESOURCE_LOCATION, classLoader);\r\n}\n/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from the given location,\r\n * using the default class loader.\r\n * @param resourceLocation the resource location to look for factories\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forResourceLocation(String, ClassLoader)\r\n */\r\npublic static SpringFactoriesLoader forResourceLocation(String resourceLocation) {\r\n    return forResourceLocation(resourceLocation, null);\r\n}\n/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from the given location,\r\n * using the given class loader.\r\n * @param resourceLocation the resource location to look for factories\r\n * @param classLoader the ClassLoader to use for loading resources;\r\n * can be {@code null} to use the default\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forResourceLocation(String)\r\n */\r\npublic static SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader) {\r\n    Assert.hasText(resourceLocation, \"'resourceLocation' must not be empty\");\r\n    ClassLoader resourceClassLoader = (classLoader != null ? classLoader : SpringFactoriesLoader.class.getClassLoader());\r\n    Map<String, SpringFactoriesLoader> loaders = cache.computeIfAbsent(resourceClassLoader, key -> new ConcurrentReferenceHashMap<>());\r\n    return loaders.computeIfAbsent(resourceLocation, key -> new SpringFactoriesLoader(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));\r\n}\nprotected static Map<String, List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\r\n    Map<String, List<String>> result = new LinkedHashMap<>();\r\n    try {\r\n        Enumeration<URL> urls = classLoader.getResources(resourceLocation);\r\n        while (urls.hasMoreElements()) {\r\n            UrlResource resource = new UrlResource(urls.nextElement());\r\n            Properties properties = PropertiesLoaderUtils.loadProperties(resource);\r\n            properties.forEach((name, value) -> {\r\n                String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) value);\r\n                List<String> implementations = result.computeIfAbsent(((String) name).trim(), key -> new ArrayList<>(factoryImplementationNames.length));\r\n                Arrays.stream(factoryImplementationNames).map(String::trim).forEach(implementations::add);\r\n            });\r\n        }\r\n        result.replaceAll(SpringFactoriesLoader::toDistinctUnmodifiableList);\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Unable to load factories from location [\" + resourceLocation + \"]\", ex);\r\n    }\r\n    return Collections.unmodifiableMap(result);\r\n}\nprivate static List<String> toDistinctUnmodifiableList(String factoryType, List<String> implementations) {\r\n    return implementations.stream().distinct().toList();\r\n}\n/**\r\n * Internal instantiator used to create the factory instance.\r\n * @since 6.0\r\n * @param <T> the instance implementation type\r\n */\r\nstatic final class FactoryInstantiator<T> {\r\n\r\n    private final Constructor<T> constructor;\r\n\r\n    private FactoryInstantiator(Constructor<T> constructor) {\r\n        ReflectionUtils.makeAccessible(constructor);\r\n        this.constructor = constructor;\r\n    }\r\n\r\n    T instantiate(@Nullable ArgumentResolver argumentResolver) throws Exception {\r\n        Object[] args = resolveArgs(argumentResolver);\r\n        if (KotlinDetector.isKotlinType(this.constructor.getDeclaringClass())) {\r\n            return KotlinDelegate.instantiate(this.constructor, args);\r\n        }\r\n        return this.constructor.newInstance(args);\r\n    }\r\n\r\n    private Object[] resolveArgs(@Nullable ArgumentResolver argumentResolver) {\r\n        Class<?>[] types = this.constructor.getParameterTypes();\r\n        return (argumentResolver != null ? Arrays.stream(types).map(argumentResolver::resolve).toArray() : new Object[types.length]);\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    static <T> FactoryInstantiator<T> forClass(Class<?> factoryImplementationClass) {\r\n        Constructor<?> constructor = findConstructor(factoryImplementationClass);\r\n        Assert.state(constructor != null, () -> \"Class [%s] has no suitable constructor\".formatted(factoryImplementationClass.getName()));\r\n        return new FactoryInstantiator<>((Constructor<T>) constructor);\r\n    }\r\n\r\n    @Nullable\r\n    private static Constructor<?> findConstructor(Class<?> factoryImplementationClass) {\r\n        // Same algorithm as BeanUtils.getResolvableConstructor\r\n        Constructor<?> constructor = findPrimaryKotlinConstructor(factoryImplementationClass);\r\n        constructor = (constructor != null ? constructor : findSingleConstructor(factoryImplementationClass.getConstructors()));\r\n        constructor = (constructor != null ? constructor : findSingleConstructor(factoryImplementationClass.getDeclaredConstructors()));\r\n        constructor = (constructor != null ? constructor : findDeclaredConstructor(factoryImplementationClass));\r\n        return constructor;\r\n    }\r\n\r\n    @Nullable\r\n    private static Constructor<?> findPrimaryKotlinConstructor(Class<?> factoryImplementationClass) {\r\n        return (KotlinDetector.isKotlinType(factoryImplementationClass) ? KotlinDelegate.findPrimaryConstructor(factoryImplementationClass) : null);\r\n    }\r\n\r\n    @Nullable\r\n    private static Constructor<?> findSingleConstructor(Constructor<?>[] constructors) {\r\n        return (constructors.length == 1 ? constructors[0] : null);\r\n    }\r\n\r\n    @Nullable\r\n    private static Constructor<?> findDeclaredConstructor(Class<?> factoryImplementationClass) {\r\n        try {\r\n            return factoryImplementationClass.getDeclaredConstructor();\r\n        } catch (NoSuchMethodException ex) {\r\n            return null;\r\n        }\r\n    }\r\n}\n/**\r\n * Nested class to avoid a hard dependency on Kotlin at runtime.\r\n * @since 6.0\r\n */\r\nprivate static class KotlinDelegate {\r\n\r\n    @Nullable\r\n    static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {\r\n        try {\r\n            KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));\r\n            if (primaryConstructor != null) {\r\n                Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor);\r\n                Assert.state(constructor != null, () -> \"Failed to find Java constructor for Kotlin primary constructor: \" + clazz.getName());\r\n                return constructor;\r\n            }\r\n        } catch (UnsupportedOperationException ex) {\r\n            // ignore\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static <T> T instantiate(Constructor<T> constructor, Object[] args) throws Exception {\r\n        KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(constructor);\r\n        if (kotlinConstructor == null) {\r\n            return constructor.newInstance(args);\r\n        }\r\n        makeAccessible(constructor, kotlinConstructor);\r\n        return instantiate(kotlinConstructor, convertArgs(args, kotlinConstructor.getParameters()));\r\n    }\r\n\r\n    private static <T> void makeAccessible(Constructor<T> constructor, KFunction<T> kotlinConstructor) {\r\n        if ((!Modifier.isPublic(constructor.getModifiers()) || !Modifier.isPublic(constructor.getDeclaringClass().getModifiers()))) {\r\n            KCallablesJvm.setAccessible(kotlinConstructor, true);\r\n        }\r\n    }\r\n\r\n    private static Map<KParameter, Object> convertArgs(Object[] args, List<KParameter> parameters) {\r\n        Map<KParameter, Object> result = CollectionUtils.newHashMap(parameters.size());\r\n        Assert.isTrue(args.length <= parameters.size(), \"Number of provided arguments should be less than or equal to the number of constructor parameters\");\r\n        for (int i = 0; i < args.length; i++) {\r\n            if (!parameters.get(i).isOptional() || args[i] != null) {\r\n                result.put(parameters.get(i), args[i]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private static <T> T instantiate(KFunction<T> kotlinConstructor, Map<KParameter, Object> args) {\r\n        return kotlinConstructor.callBy(args);\r\n    }\r\n}\n/**\r\n * Strategy for resolving constructor arguments based on their type.\r\n * @since 6.0\r\n * @see ArgumentResolver#of(Class, Object)\r\n * @see ArgumentResolver#ofSupplied(Class, Supplier)\r\n * @see ArgumentResolver#from(Function)\r\n */\r\n@FunctionalInterface\r\npublic interface ArgumentResolver {\r\n\r\n    /**\r\n     * Resolve the given argument if possible.\r\n     * @param <T> the argument type\r\n     * @param type the argument type\r\n     * @return the resolved argument value or {@code null}\r\n     */\r\n    @Nullable\r\n    <T> T resolve(Class<T> type);\r\n\r\n    /**\r\n     * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n     * with the given type and value.\r\n     * @param <T> the argument type\r\n     * @param type the argument type\r\n     * @param value the argument value\r\n     * @return a new composite {@link ArgumentResolver} instance\r\n     */\r\n    default <T> ArgumentResolver and(Class<T> type, T value) {\r\n        return and(ArgumentResolver.of(type, value));\r\n    }\r\n\r\n    /**\r\n     * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n     * with the given type and value.\r\n     * @param <T> the argument type\r\n     * @param type the argument type\r\n     * @param valueSupplier the argument value supplier\r\n     * @return a new composite {@link ArgumentResolver} instance\r\n     */\r\n    default <T> ArgumentResolver andSupplied(Class<T> type, Supplier<T> valueSupplier) {\r\n        return and(ArgumentResolver.ofSupplied(type, valueSupplier));\r\n    }\r\n\r\n    /**\r\n     * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n     * with the given resolver.\r\n     * @param argumentResolver the argument resolver to add\r\n     * @return a new composite {@link ArgumentResolver} instance\r\n     */\r\n    default ArgumentResolver and(ArgumentResolver argumentResolver) {\r\n        return from(type -> {\r\n            Object resolved = resolve(type);\r\n            return (resolved != null ? resolved : argumentResolver.resolve(type));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Factory method that returns an {@link ArgumentResolver} that always\r\n     * returns {@code null}.\r\n     * @return a new {@link ArgumentResolver} instance\r\n     */\r\n    static ArgumentResolver none() {\r\n        return from(type -> null);\r\n    }\r\n\r\n    /**\r\n     * Factory method that can be used to create an {@link ArgumentResolver}\r\n     * that resolves only the given type.\r\n     * @param <T> the argument type\r\n     * @param type the argument type\r\n     * @param value the argument value\r\n     * @return a new {@link ArgumentResolver} instance\r\n     */\r\n    static <T> ArgumentResolver of(Class<T> type, T value) {\r\n        return ofSupplied(type, () -> value);\r\n    }\r\n\r\n    /**\r\n     * Factory method that can be used to create an {@link ArgumentResolver}\r\n     * that resolves only the given type.\r\n     * @param <T> the argument type\r\n     * @param type the argument type\r\n     * @param valueSupplier the argument value supplier\r\n     * @return a new {@link ArgumentResolver} instance\r\n     */\r\n    static <T> ArgumentResolver ofSupplied(Class<T> type, Supplier<T> valueSupplier) {\r\n        return from(candidateType -> (candidateType.equals(type) ? valueSupplier.get() : null));\r\n    }\r\n\r\n    /**\r\n     * Factory method that creates a new {@link ArgumentResolver} from a\r\n     * lambda friendly function. The given function is provided with the\r\n     * argument type and must provide an instance of that type or {@code null}.\r\n     * @param function the resolver function\r\n     * @return a new {@link ArgumentResolver} instance backed by the function\r\n     */\r\n    static ArgumentResolver from(Function<Class<?>, @Nullable Object> function) {\r\n        return new ArgumentResolver() {\r\n\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            @Nullable\r\n            public <T> T resolve(Class<T> type) {\r\n                return (T) function.apply(type);\r\n            }\r\n        };\r\n    }\r\n}\n/**\r\n * Strategy for handling a failure that occurs when instantiating a factory.\r\n * @since 6.0\r\n * @see FailureHandler#throwing()\r\n * @see FailureHandler#logging(Log)\r\n */\r\n@FunctionalInterface\r\npublic interface FailureHandler {\r\n\r\n    /**\r\n     * Handle the {@code failure} that occurred when instantiating the\r\n     * {@code factoryImplementationName} that was expected to be of the\r\n     * given {@code factoryType}.\r\n     * @param factoryType the type of the factory\r\n     * @param factoryImplementationName the name of the factory implementation\r\n     * @param failure the failure that occurred\r\n     * @see #throwing()\r\n     * @see #logging\r\n     */\r\n    void handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure);\r\n\r\n    /**\r\n     * Create a new {@link FailureHandler} that handles errors by throwing an\r\n     * {@link IllegalArgumentException}.\r\n     * @return a new {@link FailureHandler} instance\r\n     * @see #throwing(BiFunction)\r\n     */\r\n    static FailureHandler throwing() {\r\n        return throwing(IllegalArgumentException::new);\r\n    }\r\n\r\n    /**\r\n     * Create a new {@link FailureHandler} that handles errors by throwing an\r\n     * exception.\r\n     * @param exceptionFactory factory used to create the exception\r\n     * @return a new {@link FailureHandler} instance\r\n     */\r\n    static FailureHandler throwing(BiFunction<String, Throwable, ? extends RuntimeException> exceptionFactory) {\r\n        return handleMessage((messageSupplier, failure) -> {\r\n            throw exceptionFactory.apply(messageSupplier.get(), failure);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new {@link FailureHandler} that handles errors by logging trace\r\n     * messages.\r\n     * @param logger the logger used to log messages\r\n     * @return a new {@link FailureHandler} instance\r\n     */\r\n    static FailureHandler logging(Log logger) {\r\n        return handleMessage((messageSupplier, failure) -> logger.trace(LogMessage.of(messageSupplier), failure));\r\n    }\r\n\r\n    /**\r\n     * Create a new {@link FailureHandler} that handles errors using a standard\r\n     * formatted message.\r\n     * @param messageHandler the message handler used to handle the problem\r\n     * @return a new {@link FailureHandler} instance\r\n     */\r\n    static FailureHandler handleMessage(BiConsumer<Supplier<String>, Throwable> messageHandler) {\r\n        return (factoryType, factoryImplementationName, failure) -> {\r\n            Supplier<String> messageSupplier = () -> \"Unable to instantiate factory class [%s] for factory type [%s]\".formatted(factoryImplementationName, factoryType.getName());\r\n            messageHandler.accept(messageSupplier, failure);\r\n        };\r\n    }\r\n}",
    "comment": "\n * General purpose factory loading mechanism for internal use within the framework.\n *\n * <p>{@code SpringFactoriesLoader} {@linkplain #loadFactories loads} and instantiates\n * factories of a given type from {@value #FACTORIES_RESOURCE_LOCATION} files which\n * may be present in multiple JAR files in the classpath. The {@code spring.factories}\n * file must be in {@link Properties} format, where the key is the fully qualified\n * name of the interface or abstract class, and the value is a comma-separated list of\n * implementation class names. For example:\n *\n * <pre class=\"code\">example.MyService=example.MyServiceImpl1,example.MyServiceImpl2</pre>\n *\n * where {@code example.MyService} is the name of the interface, and {@code MyServiceImpl1}\n * and {@code MyServiceImpl2} are two implementations.\n *\n * <p>Implementation classes <b>must</b> have a single resolvable constructor that will\n * be used to create the instance, either:\n * <ul>\n * <li>a primary or single constructor</li>\n * <li>a single public constructor</li>\n * <li>the default constructor</li>\n * </ul>\n *\n * <p>If the resolvable constructor has arguments, a suitable {@link ArgumentResolver\n * ArgumentResolver} should be provided. To customize how instantiation failures\n * are handled, consider providing a {@link FailureHandler FailureHandler}.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @author Andy Wilkinson\n * @author Madhura Bhave\n * @author Phillip Webb\n * @since 3.2\n "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#load(Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\r\n * and a default argument resolver that expects a no-arg constructor.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>If a custom instantiation strategy is required, use {@code load(...)}\r\n * with a custom {@link ArgumentResolver ArgumentResolver} and/or\r\n * {@link FailureHandler FailureHandler}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @throws IllegalArgumentException if any factory implementation class cannot\r\n * be loaded or if an error occurs while instantiating any factory\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType) {\r\n    return load(factoryType, null, null);\r\n}",
    "comment": "\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and a default argument resolver that expects a no-arg constructor.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>If a custom instantiation strategy is required, use {@code load(...)}\n\t * with a custom {@link ArgumentResolver ArgumentResolver} and/or\n\t * {@link FailureHandler FailureHandler}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#load(Class<T>,ArgumentResolver)",
    "entityType": "method",
    "code": "/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\r\n * and the given argument resolver.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param argumentResolver strategy used to resolve constructor arguments by their type\r\n * @throws IllegalArgumentException if any factory implementation class cannot\r\n * be loaded or if an error occurs while instantiating any factory\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver) {\r\n    return load(factoryType, argumentResolver, null);\r\n}",
    "comment": "\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * and the given argument resolver.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#load(Class<T>,FailureHandler)",
    "entityType": "method",
    "code": "/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\r\n * with custom failure handling provided by the given failure handler.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * <p>For any factory implementation class that cannot be loaded or error that\r\n * occurs while instantiating it, the given failure handler is called.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param failureHandler strategy used to handle factory instantiation failures\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType, @Nullable FailureHandler failureHandler) {\r\n    return load(factoryType, null, failureHandler);\r\n}",
    "comment": "\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader\n\t * with custom failure handling provided by the given failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#load(Class<T>,ArgumentResolver,FailureHandler)",
    "entityType": "method",
    "code": "/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\r\n * the given argument resolver, and custom failure handling provided by the given\r\n * failure handler.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * <p>For any factory implementation class that cannot be loaded or error that\r\n * occurs while instantiating it, the given failure handler is called.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param argumentResolver strategy used to resolve constructor arguments by their type\r\n * @param failureHandler strategy used to handle factory instantiation failures\r\n * @since 6.0\r\n */\r\npublic <T> List<T> load(Class<T> factoryType, @Nullable ArgumentResolver argumentResolver, @Nullable FailureHandler failureHandler) {\r\n    Assert.notNull(factoryType, \"'factoryType' must not be null\");\r\n    List<String> implementationNames = loadFactoryNames(factoryType);\r\n    logger.trace(LogMessage.format(\"Loaded [%s] names: %s\", factoryType.getName(), implementationNames));\r\n    List<T> result = new ArrayList<>(implementationNames.size());\r\n    FailureHandler failureHandlerToUse = (failureHandler != null) ? failureHandler : THROWING_FAILURE_HANDLER;\r\n    for (String implementationName : implementationNames) {\r\n        T factory = instantiateFactory(implementationName, factoryType, argumentResolver, failureHandlerToUse);\r\n        if (factory != null) {\r\n            result.add(factory);\r\n        }\r\n    }\r\n    AnnotationAwareOrderComparator.sort(result);\r\n    return result;\r\n}",
    "comment": "\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the configured class loader,\n\t * the given argument resolver, and custom failure handling provided by the given\n\t * failure handler.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For any factory implementation class that cannot be loaded or error that\n\t * occurs while instantiating it, the given failure handler is called.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param argumentResolver strategy used to resolve constructor arguments by their type\n\t * @param failureHandler strategy used to handle factory instantiation failures\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames(Class<?>)",
    "entityType": "method",
    "code": "private List<String> loadFactoryNames(Class<?> factoryType) {\r\n    return this.factories.getOrDefault(factoryType.getName(), Collections.emptyList());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#instantiateFactory(String,Class<T>,ArgumentResolver,FailureHandler)",
    "entityType": "method",
    "code": "@Nullable\r\nprotected <T> T instantiateFactory(String implementationName, Class<T> type, @Nullable ArgumentResolver argumentResolver, FailureHandler failureHandler) {\r\n    try {\r\n        Class<?> factoryImplementationClass = ClassUtils.forName(implementationName, this.classLoader);\r\n        Assert.isTrue(type.isAssignableFrom(factoryImplementationClass), () -> \"Class [%s] is not assignable to factory type [%s]\".formatted(implementationName, type.getName()));\r\n        FactoryInstantiator<T> factoryInstantiator = FactoryInstantiator.forClass(factoryImplementationClass);\r\n        return factoryInstantiator.instantiate(argumentResolver);\r\n    } catch (Throwable ex) {\r\n        failureHandler.handleFailure(type, implementationName, ex);\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#loadFactories(Class<T>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Load and instantiate the factory implementations of the given type from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\r\n * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\r\n * <p>As of Spring Framework 5.3, if duplicate implementation class names are\r\n * discovered for a given factory type, only one instance of the duplicated\r\n * implementation type will be instantiated.\r\n * <p>For more advanced factory loading with {@link ArgumentResolver} or\r\n * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\r\n * to obtain a {@link SpringFactoriesLoader} instance.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param classLoader the ClassLoader to use for loading (can be {@code null}\r\n * to use the default)\r\n * @throws IllegalArgumentException if any factory implementation class cannot\r\n * be loaded or if an error occurs while instantiating any factory\r\n */\r\npublic static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {\r\n    return forDefaultResourceLocation(classLoader).load(factoryType);\r\n}",
    "comment": "\n\t * Load and instantiate the factory implementations of the given type from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}.\n\t * <p>As of Spring Framework 5.3, if duplicate implementation class names are\n\t * discovered for a given factory type, only one instance of the duplicated\n\t * implementation type will be instantiated.\n\t * <p>For more advanced factory loading with {@link ArgumentResolver} or\n\t * {@link FailureHandler} support use {@link #forDefaultResourceLocation(ClassLoader)}\n\t * to obtain a {@link SpringFactoriesLoader} instance.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading (can be {@code null}\n\t * to use the default)\n\t * @throws IllegalArgumentException if any factory implementation class cannot\n\t * be loaded or if an error occurs while instantiating any factory\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames(Class<?>,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Load the fully qualified class names of factory implementations of the\r\n * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\r\n * class loader.\r\n * <p>As of Spring Framework 5.3, if a particular implementation class name\r\n * is discovered more than once for the given factory type, duplicates will\r\n * be ignored.\r\n * @param factoryType the interface or abstract class representing the factory\r\n * @param classLoader the ClassLoader to use for loading resources; can be\r\n * {@code null} to use the default\r\n * @throws IllegalArgumentException if an error occurs while loading factory names\r\n * @see #loadFactories\r\n * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\r\n */\r\n@Deprecated(since = \"6.0\")\r\npublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\r\n    return forDefaultResourceLocation(classLoader).loadFactoryNames(factoryType);\r\n}",
    "comment": "\n\t * Load the fully qualified class names of factory implementations of the\n\t * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given\n\t * class loader.\n\t * <p>As of Spring Framework 5.3, if a particular implementation class name\n\t * is discovered more than once for the given factory type, duplicates will\n\t * be ignored.\n\t * @param factoryType the interface or abstract class representing the factory\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @throws IllegalArgumentException if an error occurs while loading factory names\n\t * @see #loadFactories\n\t * @deprecated as of 6.0 in favor of {@link #load(Class, ArgumentResolver, FailureHandler)}\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#forDefaultResourceLocation()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the default class loader.\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forDefaultResourceLocation(ClassLoader)\r\n */\r\npublic static SpringFactoriesLoader forDefaultResourceLocation() {\r\n    return forDefaultResourceLocation(null);\r\n}",
    "comment": "\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the default class loader.\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation(ClassLoader)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#forDefaultResourceLocation(ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from\r\n * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\r\n * @param classLoader the ClassLoader to use for loading resources; can be\r\n * {@code null} to use the default\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forDefaultResourceLocation()\r\n */\r\npublic static SpringFactoriesLoader forDefaultResourceLocation(@Nullable ClassLoader classLoader) {\r\n    return forResourceLocation(FACTORIES_RESOURCE_LOCATION, classLoader);\r\n}",
    "comment": "\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from\n\t * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader.\n\t * @param classLoader the ClassLoader to use for loading resources; can be\n\t * {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forDefaultResourceLocation()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#forResourceLocation(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from the given location,\r\n * using the default class loader.\r\n * @param resourceLocation the resource location to look for factories\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forResourceLocation(String, ClassLoader)\r\n */\r\npublic static SpringFactoriesLoader forResourceLocation(String resourceLocation) {\r\n    return forResourceLocation(resourceLocation, null);\r\n}",
    "comment": "\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the default class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String, ClassLoader)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#forResourceLocation(String,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link SpringFactoriesLoader} instance that will load and\r\n * instantiate the factory implementations from the given location,\r\n * using the given class loader.\r\n * @param resourceLocation the resource location to look for factories\r\n * @param classLoader the ClassLoader to use for loading resources;\r\n * can be {@code null} to use the default\r\n * @return a {@link SpringFactoriesLoader} instance\r\n * @since 6.0\r\n * @see #forResourceLocation(String)\r\n */\r\npublic static SpringFactoriesLoader forResourceLocation(String resourceLocation, @Nullable ClassLoader classLoader) {\r\n    Assert.hasText(resourceLocation, \"'resourceLocation' must not be empty\");\r\n    ClassLoader resourceClassLoader = (classLoader != null ? classLoader : SpringFactoriesLoader.class.getClassLoader());\r\n    Map<String, SpringFactoriesLoader> loaders = cache.computeIfAbsent(resourceClassLoader, key -> new ConcurrentReferenceHashMap<>());\r\n    return loaders.computeIfAbsent(resourceLocation, key -> new SpringFactoriesLoader(classLoader, loadFactoriesResource(resourceClassLoader, resourceLocation)));\r\n}",
    "comment": "\n\t * Create a {@link SpringFactoriesLoader} instance that will load and\n\t * instantiate the factory implementations from the given location,\n\t * using the given class loader.\n\t * @param resourceLocation the resource location to look for factories\n\t * @param classLoader the ClassLoader to use for loading resources;\n\t * can be {@code null} to use the default\n\t * @return a {@link SpringFactoriesLoader} instance\n\t * @since 6.0\n\t * @see #forResourceLocation(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#loadFactoriesResource(ClassLoader,String)",
    "entityType": "method",
    "code": "protected static Map<String, List<String>> loadFactoriesResource(ClassLoader classLoader, String resourceLocation) {\r\n    Map<String, List<String>> result = new LinkedHashMap<>();\r\n    try {\r\n        Enumeration<URL> urls = classLoader.getResources(resourceLocation);\r\n        while (urls.hasMoreElements()) {\r\n            UrlResource resource = new UrlResource(urls.nextElement());\r\n            Properties properties = PropertiesLoaderUtils.loadProperties(resource);\r\n            properties.forEach((name, value) -> {\r\n                String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) value);\r\n                List<String> implementations = result.computeIfAbsent(((String) name).trim(), key -> new ArrayList<>(factoryImplementationNames.length));\r\n                Arrays.stream(factoryImplementationNames).map(String::trim).forEach(implementations::add);\r\n            });\r\n        }\r\n        result.replaceAll(SpringFactoriesLoader::toDistinctUnmodifiableList);\r\n    } catch (IOException ex) {\r\n        throw new IllegalArgumentException(\"Unable to load factories from location [\" + resourceLocation + \"]\", ex);\r\n    }\r\n    return Collections.unmodifiableMap(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.SpringFactoriesLoader#toDistinctUnmodifiableList(String,List<String>)",
    "entityType": "method",
    "code": "private static List<String> toDistinctUnmodifiableList(String factoryType, List<String> implementations) {\r\n    return implementations.stream().distinct().toList();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator",
    "entityType": "class",
    "code": "private final Constructor<T> constructor;\nprivate FactoryInstantiator(Constructor<T> constructor) {\r\n    ReflectionUtils.makeAccessible(constructor);\r\n    this.constructor = constructor;\r\n}\nT instantiate(@Nullable ArgumentResolver argumentResolver) throws Exception {\r\n    Object[] args = resolveArgs(argumentResolver);\r\n    if (KotlinDetector.isKotlinType(this.constructor.getDeclaringClass())) {\r\n        return KotlinDelegate.instantiate(this.constructor, args);\r\n    }\r\n    return this.constructor.newInstance(args);\r\n}\nprivate Object[] resolveArgs(@Nullable ArgumentResolver argumentResolver) {\r\n    Class<?>[] types = this.constructor.getParameterTypes();\r\n    return (argumentResolver != null ? Arrays.stream(types).map(argumentResolver::resolve).toArray() : new Object[types.length]);\r\n}\n@SuppressWarnings(\"unchecked\")\r\nstatic <T> FactoryInstantiator<T> forClass(Class<?> factoryImplementationClass) {\r\n    Constructor<?> constructor = findConstructor(factoryImplementationClass);\r\n    Assert.state(constructor != null, () -> \"Class [%s] has no suitable constructor\".formatted(factoryImplementationClass.getName()));\r\n    return new FactoryInstantiator<>((Constructor<T>) constructor);\r\n}\n@Nullable\r\nprivate static Constructor<?> findConstructor(Class<?> factoryImplementationClass) {\r\n    // Same algorithm as BeanUtils.getResolvableConstructor\r\n    Constructor<?> constructor = findPrimaryKotlinConstructor(factoryImplementationClass);\r\n    constructor = (constructor != null ? constructor : findSingleConstructor(factoryImplementationClass.getConstructors()));\r\n    constructor = (constructor != null ? constructor : findSingleConstructor(factoryImplementationClass.getDeclaredConstructors()));\r\n    constructor = (constructor != null ? constructor : findDeclaredConstructor(factoryImplementationClass));\r\n    return constructor;\r\n}\n@Nullable\r\nprivate static Constructor<?> findPrimaryKotlinConstructor(Class<?> factoryImplementationClass) {\r\n    return (KotlinDetector.isKotlinType(factoryImplementationClass) ? KotlinDelegate.findPrimaryConstructor(factoryImplementationClass) : null);\r\n}\n@Nullable\r\nprivate static Constructor<?> findSingleConstructor(Constructor<?>[] constructors) {\r\n    return (constructors.length == 1 ? constructors[0] : null);\r\n}\n@Nullable\r\nprivate static Constructor<?> findDeclaredConstructor(Class<?> factoryImplementationClass) {\r\n    try {\r\n        return factoryImplementationClass.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": "\n\t * Internal instantiator used to create the factory instance.\n\t * @since 6.0\n\t * @param <T> the instance implementation type\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#instantiate(ArgumentResolver)",
    "entityType": "method",
    "code": "T instantiate(@Nullable ArgumentResolver argumentResolver) throws Exception {\r\n    Object[] args = resolveArgs(argumentResolver);\r\n    if (KotlinDetector.isKotlinType(this.constructor.getDeclaringClass())) {\r\n        return KotlinDelegate.instantiate(this.constructor, args);\r\n    }\r\n    return this.constructor.newInstance(args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#resolveArgs(ArgumentResolver)",
    "entityType": "method",
    "code": "private Object[] resolveArgs(@Nullable ArgumentResolver argumentResolver) {\r\n    Class<?>[] types = this.constructor.getParameterTypes();\r\n    return (argumentResolver != null ? Arrays.stream(types).map(argumentResolver::resolve).toArray() : new Object[types.length]);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#forClass(Class<?>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\nstatic <T> FactoryInstantiator<T> forClass(Class<?> factoryImplementationClass) {\r\n    Constructor<?> constructor = findConstructor(factoryImplementationClass);\r\n    Assert.state(constructor != null, () -> \"Class [%s] has no suitable constructor\".formatted(factoryImplementationClass.getName()));\r\n    return new FactoryInstantiator<>((Constructor<T>) constructor);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#findConstructor(Class<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Constructor<?> findConstructor(Class<?> factoryImplementationClass) {\r\n    // Same algorithm as BeanUtils.getResolvableConstructor\r\n    Constructor<?> constructor = findPrimaryKotlinConstructor(factoryImplementationClass);\r\n    constructor = (constructor != null ? constructor : findSingleConstructor(factoryImplementationClass.getConstructors()));\r\n    constructor = (constructor != null ? constructor : findSingleConstructor(factoryImplementationClass.getDeclaredConstructors()));\r\n    constructor = (constructor != null ? constructor : findDeclaredConstructor(factoryImplementationClass));\r\n    return constructor;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#findPrimaryKotlinConstructor(Class<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Constructor<?> findPrimaryKotlinConstructor(Class<?> factoryImplementationClass) {\r\n    return (KotlinDetector.isKotlinType(factoryImplementationClass) ? KotlinDelegate.findPrimaryConstructor(factoryImplementationClass) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#findSingleConstructor(Constructor<?>[])",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Constructor<?> findSingleConstructor(Constructor<?>[] constructors) {\r\n    return (constructors.length == 1 ? constructors[0] : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.FactoryInstantiator#findDeclaredConstructor(Class<?>)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate static Constructor<?> findDeclaredConstructor(Class<?> factoryImplementationClass) {\r\n    try {\r\n        return factoryImplementationClass.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.KotlinDelegate",
    "entityType": "class",
    "code": "@Nullable\r\nstatic <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {\r\n    try {\r\n        KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));\r\n        if (primaryConstructor != null) {\r\n            Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor);\r\n            Assert.state(constructor != null, () -> \"Failed to find Java constructor for Kotlin primary constructor: \" + clazz.getName());\r\n            return constructor;\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // ignore\r\n    }\r\n    return null;\r\n}\nstatic <T> T instantiate(Constructor<T> constructor, Object[] args) throws Exception {\r\n    KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(constructor);\r\n    if (kotlinConstructor == null) {\r\n        return constructor.newInstance(args);\r\n    }\r\n    makeAccessible(constructor, kotlinConstructor);\r\n    return instantiate(kotlinConstructor, convertArgs(args, kotlinConstructor.getParameters()));\r\n}\nprivate static <T> void makeAccessible(Constructor<T> constructor, KFunction<T> kotlinConstructor) {\r\n    if ((!Modifier.isPublic(constructor.getModifiers()) || !Modifier.isPublic(constructor.getDeclaringClass().getModifiers()))) {\r\n        KCallablesJvm.setAccessible(kotlinConstructor, true);\r\n    }\r\n}\nprivate static Map<KParameter, Object> convertArgs(Object[] args, List<KParameter> parameters) {\r\n    Map<KParameter, Object> result = CollectionUtils.newHashMap(parameters.size());\r\n    Assert.isTrue(args.length <= parameters.size(), \"Number of provided arguments should be less than or equal to the number of constructor parameters\");\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (!parameters.get(i).isOptional() || args[i] != null) {\r\n            result.put(parameters.get(i), args[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\nprivate static <T> T instantiate(KFunction<T> kotlinConstructor, Map<KParameter, Object> args) {\r\n    return kotlinConstructor.callBy(args);\r\n}",
    "comment": "\n\t * Nested class to avoid a hard dependency on Kotlin at runtime.\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.KotlinDelegate#findPrimaryConstructor(Class<T>)",
    "entityType": "method",
    "code": "@Nullable\r\nstatic <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {\r\n    try {\r\n        KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz));\r\n        if (primaryConstructor != null) {\r\n            Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor);\r\n            Assert.state(constructor != null, () -> \"Failed to find Java constructor for Kotlin primary constructor: \" + clazz.getName());\r\n            return constructor;\r\n        }\r\n    } catch (UnsupportedOperationException ex) {\r\n        // ignore\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.KotlinDelegate#instantiate(Constructor<T>,Object[])",
    "entityType": "method",
    "code": "static <T> T instantiate(Constructor<T> constructor, Object[] args) throws Exception {\r\n    KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(constructor);\r\n    if (kotlinConstructor == null) {\r\n        return constructor.newInstance(args);\r\n    }\r\n    makeAccessible(constructor, kotlinConstructor);\r\n    return instantiate(kotlinConstructor, convertArgs(args, kotlinConstructor.getParameters()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.KotlinDelegate#makeAccessible(Constructor<T>,KFunction<T>)",
    "entityType": "method",
    "code": "private static <T> void makeAccessible(Constructor<T> constructor, KFunction<T> kotlinConstructor) {\r\n    if ((!Modifier.isPublic(constructor.getModifiers()) || !Modifier.isPublic(constructor.getDeclaringClass().getModifiers()))) {\r\n        KCallablesJvm.setAccessible(kotlinConstructor, true);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.KotlinDelegate#convertArgs(Object[],List<KParameter>)",
    "entityType": "method",
    "code": "private static Map<KParameter, Object> convertArgs(Object[] args, List<KParameter> parameters) {\r\n    Map<KParameter, Object> result = CollectionUtils.newHashMap(parameters.size());\r\n    Assert.isTrue(args.length <= parameters.size(), \"Number of provided arguments should be less than or equal to the number of constructor parameters\");\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (!parameters.get(i).isOptional() || args[i] != null) {\r\n            result.put(parameters.get(i), args[i]);\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.KotlinDelegate#instantiate(KFunction<T>,Map<KParameter,Object>)",
    "entityType": "method",
    "code": "private static <T> T instantiate(KFunction<T> kotlinConstructor, Map<KParameter, Object> args) {\r\n    return kotlinConstructor.callBy(args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver",
    "entityType": "class",
    "code": "/**\r\n * Resolve the given argument if possible.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @return the resolved argument value or {@code null}\r\n */\r\n@Nullable\r\n<T> T resolve(Class<T> type);\n/**\r\n * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n * with the given type and value.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param value the argument value\r\n * @return a new composite {@link ArgumentResolver} instance\r\n */\r\ndefault <T> ArgumentResolver and(Class<T> type, T value) {\r\n    return and(ArgumentResolver.of(type, value));\r\n}\n/**\r\n * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n * with the given type and value.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param valueSupplier the argument value supplier\r\n * @return a new composite {@link ArgumentResolver} instance\r\n */\r\ndefault <T> ArgumentResolver andSupplied(Class<T> type, Supplier<T> valueSupplier) {\r\n    return and(ArgumentResolver.ofSupplied(type, valueSupplier));\r\n}\n/**\r\n * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n * with the given resolver.\r\n * @param argumentResolver the argument resolver to add\r\n * @return a new composite {@link ArgumentResolver} instance\r\n */\r\ndefault ArgumentResolver and(ArgumentResolver argumentResolver) {\r\n    return from(type -> {\r\n        Object resolved = resolve(type);\r\n        return (resolved != null ? resolved : argumentResolver.resolve(type));\r\n    });\r\n}\n/**\r\n * Factory method that returns an {@link ArgumentResolver} that always\r\n * returns {@code null}.\r\n * @return a new {@link ArgumentResolver} instance\r\n */\r\nstatic ArgumentResolver none() {\r\n    return from(type -> null);\r\n}\n/**\r\n * Factory method that can be used to create an {@link ArgumentResolver}\r\n * that resolves only the given type.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param value the argument value\r\n * @return a new {@link ArgumentResolver} instance\r\n */\r\nstatic <T> ArgumentResolver of(Class<T> type, T value) {\r\n    return ofSupplied(type, () -> value);\r\n}\n/**\r\n * Factory method that can be used to create an {@link ArgumentResolver}\r\n * that resolves only the given type.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param valueSupplier the argument value supplier\r\n * @return a new {@link ArgumentResolver} instance\r\n */\r\nstatic <T> ArgumentResolver ofSupplied(Class<T> type, Supplier<T> valueSupplier) {\r\n    return from(candidateType -> (candidateType.equals(type) ? valueSupplier.get() : null));\r\n}\n/**\r\n * Factory method that creates a new {@link ArgumentResolver} from a\r\n * lambda friendly function. The given function is provided with the\r\n * argument type and must provide an instance of that type or {@code null}.\r\n * @param function the resolver function\r\n * @return a new {@link ArgumentResolver} instance backed by the function\r\n */\r\nstatic ArgumentResolver from(Function<Class<?>, @Nullable Object> function) {\r\n    return new ArgumentResolver() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        @Nullable\r\n        public <T> T resolve(Class<T> type) {\r\n            return (T) function.apply(type);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t * Strategy for resolving constructor arguments based on their type.\n\t * @since 6.0\n\t * @see ArgumentResolver#of(Class, Object)\n\t * @see ArgumentResolver#ofSupplied(Class, Supplier)\n\t * @see ArgumentResolver#from(Function)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#resolve(Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Resolve the given argument if possible.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @return the resolved argument value or {@code null}\r\n */\r\n@Nullable\r\n<T> T resolve(Class<T> type);",
    "comment": "\n\t\t * Resolve the given argument if possible.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @return the resolved argument value or {@code null}\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#and(Class<T>,T)",
    "entityType": "method",
    "code": "/**\r\n * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n * with the given type and value.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param value the argument value\r\n * @return a new composite {@link ArgumentResolver} instance\r\n */\r\ndefault <T> ArgumentResolver and(Class<T> type, T value) {\r\n    return and(ArgumentResolver.of(type, value));\r\n}",
    "comment": "\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#andSupplied(Class<T>,Supplier<T>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n * with the given type and value.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param valueSupplier the argument value supplier\r\n * @return a new composite {@link ArgumentResolver} instance\r\n */\r\ndefault <T> ArgumentResolver andSupplied(Class<T> type, Supplier<T> valueSupplier) {\r\n    return and(ArgumentResolver.ofSupplied(type, valueSupplier));\r\n}",
    "comment": "\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given type and value.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#and(ArgumentResolver)",
    "entityType": "method",
    "code": "/**\r\n * Create a new composed {@link ArgumentResolver} by combining this resolver\r\n * with the given resolver.\r\n * @param argumentResolver the argument resolver to add\r\n * @return a new composite {@link ArgumentResolver} instance\r\n */\r\ndefault ArgumentResolver and(ArgumentResolver argumentResolver) {\r\n    return from(type -> {\r\n        Object resolved = resolve(type);\r\n        return (resolved != null ? resolved : argumentResolver.resolve(type));\r\n    });\r\n}",
    "comment": "\n\t\t * Create a new composed {@link ArgumentResolver} by combining this resolver\n\t\t * with the given resolver.\n\t\t * @param argumentResolver the argument resolver to add\n\t\t * @return a new composite {@link ArgumentResolver} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#none()",
    "entityType": "method",
    "code": "/**\r\n * Factory method that returns an {@link ArgumentResolver} that always\r\n * returns {@code null}.\r\n * @return a new {@link ArgumentResolver} instance\r\n */\r\nstatic ArgumentResolver none() {\r\n    return from(type -> null);\r\n}",
    "comment": "\n\t\t * Factory method that returns an {@link ArgumentResolver} that always\n\t\t * returns {@code null}.\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#of(Class<T>,T)",
    "entityType": "method",
    "code": "/**\r\n * Factory method that can be used to create an {@link ArgumentResolver}\r\n * that resolves only the given type.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param value the argument value\r\n * @return a new {@link ArgumentResolver} instance\r\n */\r\nstatic <T> ArgumentResolver of(Class<T> type, T value) {\r\n    return ofSupplied(type, () -> value);\r\n}",
    "comment": "\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param value the argument value\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#ofSupplied(Class<T>,Supplier<T>)",
    "entityType": "method",
    "code": "/**\r\n * Factory method that can be used to create an {@link ArgumentResolver}\r\n * that resolves only the given type.\r\n * @param <T> the argument type\r\n * @param type the argument type\r\n * @param valueSupplier the argument value supplier\r\n * @return a new {@link ArgumentResolver} instance\r\n */\r\nstatic <T> ArgumentResolver ofSupplied(Class<T> type, Supplier<T> valueSupplier) {\r\n    return from(candidateType -> (candidateType.equals(type) ? valueSupplier.get() : null));\r\n}",
    "comment": "\n\t\t * Factory method that can be used to create an {@link ArgumentResolver}\n\t\t * that resolves only the given type.\n\t\t * @param <T> the argument type\n\t\t * @param type the argument type\n\t\t * @param valueSupplier the argument value supplier\n\t\t * @return a new {@link ArgumentResolver} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.ArgumentResolver#from(Function<Class<?>,Object>)",
    "entityType": "method",
    "code": "/**\r\n * Factory method that creates a new {@link ArgumentResolver} from a\r\n * lambda friendly function. The given function is provided with the\r\n * argument type and must provide an instance of that type or {@code null}.\r\n * @param function the resolver function\r\n * @return a new {@link ArgumentResolver} instance backed by the function\r\n */\r\nstatic ArgumentResolver from(Function<Class<?>, @Nullable Object> function) {\r\n    return new ArgumentResolver() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        @Nullable\r\n        public <T> T resolve(Class<T> type) {\r\n            return (T) function.apply(type);\r\n        }\r\n    };\r\n}",
    "comment": "\n\t\t * Factory method that creates a new {@link ArgumentResolver} from a\n\t\t * lambda friendly function. The given function is provided with the\n\t\t * argument type and must provide an instance of that type or {@code null}.\n\t\t * @param function the resolver function\n\t\t * @return a new {@link ArgumentResolver} instance backed by the function\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FailureHandler",
    "entityType": "class",
    "code": "/**\r\n * Handle the {@code failure} that occurred when instantiating the\r\n * {@code factoryImplementationName} that was expected to be of the\r\n * given {@code factoryType}.\r\n * @param factoryType the type of the factory\r\n * @param factoryImplementationName the name of the factory implementation\r\n * @param failure the failure that occurred\r\n * @see #throwing()\r\n * @see #logging\r\n */\r\nvoid handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure);\n/**\r\n * Create a new {@link FailureHandler} that handles errors by throwing an\r\n * {@link IllegalArgumentException}.\r\n * @return a new {@link FailureHandler} instance\r\n * @see #throwing(BiFunction)\r\n */\r\nstatic FailureHandler throwing() {\r\n    return throwing(IllegalArgumentException::new);\r\n}\n/**\r\n * Create a new {@link FailureHandler} that handles errors by throwing an\r\n * exception.\r\n * @param exceptionFactory factory used to create the exception\r\n * @return a new {@link FailureHandler} instance\r\n */\r\nstatic FailureHandler throwing(BiFunction<String, Throwable, ? extends RuntimeException> exceptionFactory) {\r\n    return handleMessage((messageSupplier, failure) -> {\r\n        throw exceptionFactory.apply(messageSupplier.get(), failure);\r\n    });\r\n}\n/**\r\n * Create a new {@link FailureHandler} that handles errors by logging trace\r\n * messages.\r\n * @param logger the logger used to log messages\r\n * @return a new {@link FailureHandler} instance\r\n */\r\nstatic FailureHandler logging(Log logger) {\r\n    return handleMessage((messageSupplier, failure) -> logger.trace(LogMessage.of(messageSupplier), failure));\r\n}\n/**\r\n * Create a new {@link FailureHandler} that handles errors using a standard\r\n * formatted message.\r\n * @param messageHandler the message handler used to handle the problem\r\n * @return a new {@link FailureHandler} instance\r\n */\r\nstatic FailureHandler handleMessage(BiConsumer<Supplier<String>, Throwable> messageHandler) {\r\n    return (factoryType, factoryImplementationName, failure) -> {\r\n        Supplier<String> messageSupplier = () -> \"Unable to instantiate factory class [%s] for factory type [%s]\".formatted(factoryImplementationName, factoryType.getName());\r\n        messageHandler.accept(messageSupplier, failure);\r\n    };\r\n}",
    "comment": "\n\t * Strategy for handling a failure that occurs when instantiating a factory.\n\t * @since 6.0\n\t * @see FailureHandler#throwing()\n\t * @see FailureHandler#logging(Log)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FailureHandler#handleFailure(Class<?>,String,Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Handle the {@code failure} that occurred when instantiating the\r\n * {@code factoryImplementationName} that was expected to be of the\r\n * given {@code factoryType}.\r\n * @param factoryType the type of the factory\r\n * @param factoryImplementationName the name of the factory implementation\r\n * @param failure the failure that occurred\r\n * @see #throwing()\r\n * @see #logging\r\n */\r\nvoid handleFailure(Class<?> factoryType, String factoryImplementationName, Throwable failure);",
    "comment": "\n\t\t * Handle the {@code failure} that occurred when instantiating the\n\t\t * {@code factoryImplementationName} that was expected to be of the\n\t\t * given {@code factoryType}.\n\t\t * @param factoryType the type of the factory\n\t\t * @param factoryImplementationName the name of the factory implementation\n\t\t * @param failure the failure that occurred\n\t\t * @see #throwing()\n\t\t * @see #logging\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FailureHandler#throwing()",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link FailureHandler} that handles errors by throwing an\r\n * {@link IllegalArgumentException}.\r\n * @return a new {@link FailureHandler} instance\r\n * @see #throwing(BiFunction)\r\n */\r\nstatic FailureHandler throwing() {\r\n    return throwing(IllegalArgumentException::new);\r\n}",
    "comment": "\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * {@link IllegalArgumentException}.\n\t\t * @return a new {@link FailureHandler} instance\n\t\t * @see #throwing(BiFunction)\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FailureHandler#throwing(BiFunction<String,Throwable,? extends RuntimeException>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link FailureHandler} that handles errors by throwing an\r\n * exception.\r\n * @param exceptionFactory factory used to create the exception\r\n * @return a new {@link FailureHandler} instance\r\n */\r\nstatic FailureHandler throwing(BiFunction<String, Throwable, ? extends RuntimeException> exceptionFactory) {\r\n    return handleMessage((messageSupplier, failure) -> {\r\n        throw exceptionFactory.apply(messageSupplier.get(), failure);\r\n    });\r\n}",
    "comment": "\n\t\t * Create a new {@link FailureHandler} that handles errors by throwing an\n\t\t * exception.\n\t\t * @param exceptionFactory factory used to create the exception\n\t\t * @return a new {@link FailureHandler} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FailureHandler#logging(Log)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link FailureHandler} that handles errors by logging trace\r\n * messages.\r\n * @param logger the logger used to log messages\r\n * @return a new {@link FailureHandler} instance\r\n */\r\nstatic FailureHandler logging(Log logger) {\r\n    return handleMessage((messageSupplier, failure) -> logger.trace(LogMessage.of(messageSupplier), failure));\r\n}",
    "comment": "\n\t\t * Create a new {@link FailureHandler} that handles errors by logging trace\n\t\t * messages.\n\t\t * @param logger the logger used to log messages\n\t\t * @return a new {@link FailureHandler} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.FailureHandler#handleMessage(BiConsumer<Supplier<String>,Throwable>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link FailureHandler} that handles errors using a standard\r\n * formatted message.\r\n * @param messageHandler the message handler used to handle the problem\r\n * @return a new {@link FailureHandler} instance\r\n */\r\nstatic FailureHandler handleMessage(BiConsumer<Supplier<String>, Throwable> messageHandler) {\r\n    return (factoryType, factoryImplementationName, failure) -> {\r\n        Supplier<String> messageSupplier = () -> \"Unable to instantiate factory class [%s] for factory type [%s]\".formatted(factoryImplementationName, factoryType.getName());\r\n        messageHandler.accept(messageSupplier, failure);\r\n    };\r\n}",
    "comment": "\n\t\t * Create a new {@link FailureHandler} that handles errors using a standard\n\t\t * formatted message.\n\t\t * @param messageHandler the message handler used to handle the problem\n\t\t * @return a new {@link FailureHandler} instance\n\t\t "
  },
  {
    "entityId": "org.springframework.core.io.support.VfsPatternUtils",
    "entityType": "class",
    "code": "@Nullable\r\nstatic Object getVisitorAttributes() {\r\n    return doGetVisitorAttributes();\r\n}\nstatic String getPath(Object resource) {\r\n    String path = doGetPath(resource);\r\n    return (path != null ? path : \"\");\r\n}\nstatic Object findRoot(URL url) throws IOException {\r\n    return getRoot(url);\r\n}\nstatic void visit(Object resource, InvocationHandler visitor) throws IOException {\r\n    Object visitorProxy = Proxy.newProxyInstance(VIRTUAL_FILE_VISITOR_INTERFACE.getClassLoader(), new Class<?>[] { VIRTUAL_FILE_VISITOR_INTERFACE }, visitor);\r\n    invokeVfsMethod(VIRTUAL_FILE_METHOD_VISIT, resource, visitorProxy);\r\n}",
    "comment": "\n * Artificial class used for accessing the {@link VfsUtils} methods\n * without exposing them to the entire world.\n *\n * @author Costin Leau\n * @since 3.0.3\n "
  },
  {
    "entityId": "org.springframework.core.io.support.VfsPatternUtils#getVisitorAttributes()",
    "entityType": "method",
    "code": "@Nullable\r\nstatic Object getVisitorAttributes() {\r\n    return doGetVisitorAttributes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.VfsPatternUtils#getPath(Object)",
    "entityType": "method",
    "code": "static String getPath(Object resource) {\r\n    String path = doGetPath(resource);\r\n    return (path != null ? path : \"\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.VfsPatternUtils#findRoot(URL)",
    "entityType": "method",
    "code": "static Object findRoot(URL url) throws IOException {\r\n    return getRoot(url);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.support.VfsPatternUtils#visit(Object,InvocationHandler)",
    "entityType": "method",
    "code": "static void visit(Object resource, InvocationHandler visitor) throws IOException {\r\n    Object visitorProxy = Proxy.newProxyInstance(VIRTUAL_FILE_VISITOR_INTERFACE.getClassLoader(), new Class<?>[] { VIRTUAL_FILE_VISITOR_INTERFACE }, visitor);\r\n    invokeVfsMethod(VIRTUAL_FILE_METHOD_VISIT, resource, visitorProxy);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.UrlResource",
    "entityType": "class",
    "code": "private static final String AUTHORIZATION = \"Authorization\";\n/**\r\n * Original URI, if available; used for URI and File access.\r\n */\r\n@Nullable\r\nprivate final URI uri;\n/**\r\n * Original URL, used for actual access.\r\n */\r\nprivate final URL url;\n/**\r\n * Cleaned URL String (with normalized path), used for comparisons.\r\n */\r\n@Nullable\r\nprivate volatile String cleanedUrl;\n/**\r\n * Create a new {@code UrlResource} based on the given URL object.\r\n * @param url a URL\r\n * @see #UrlResource(URI)\r\n * @see #UrlResource(String)\r\n */\r\npublic UrlResource(URL url) {\r\n    Assert.notNull(url, \"URL must not be null\");\r\n    this.uri = null;\r\n    this.url = url;\r\n}\n/**\r\n * Create a new {@code UrlResource} based on the given URI object.\r\n * @param uri a URI\r\n * @throws MalformedURLException if the given URL path is not valid\r\n * @since 2.5\r\n */\r\npublic UrlResource(URI uri) throws MalformedURLException {\r\n    Assert.notNull(uri, \"URI must not be null\");\r\n    this.uri = uri;\r\n    this.url = uri.toURL();\r\n}\n/**\r\n * Create a new {@code UrlResource} based on a URI path.\r\n * <p>Note: The given path needs to be pre-encoded if necessary.\r\n * @param path a URI path\r\n * @throws MalformedURLException if the given URI path is not valid\r\n * @see ResourceUtils#toURI(String)\r\n */\r\npublic UrlResource(String path) throws MalformedURLException {\r\n    Assert.notNull(path, \"Path must not be null\");\r\n    String cleanedPath = StringUtils.cleanPath(path);\r\n    URI uri;\r\n    URL url;\r\n    try {\r\n        // Prefer URI construction with toURL conversion (as of 6.1)\r\n        uri = ResourceUtils.toURI(cleanedPath);\r\n        url = uri.toURL();\r\n    } catch (URISyntaxException | IllegalArgumentException ex) {\r\n        uri = null;\r\n        url = ResourceUtils.toURL(path);\r\n    }\r\n    this.uri = uri;\r\n    this.url = url;\r\n    this.cleanedUrl = cleanedPath;\r\n}\n/**\r\n * Create a new {@code UrlResource} based on a URI specification.\r\n * <p>The given parts will automatically get encoded if necessary.\r\n * @param protocol the URL protocol to use (for example, \"jar\" or \"file\" - without colon);\r\n * also known as \"scheme\"\r\n * @param location the location (for example, the file path within that protocol);\r\n * also known as \"scheme-specific part\"\r\n * @throws MalformedURLException if the given URL specification is not valid\r\n * @see java.net.URI#URI(String, String, String)\r\n */\r\npublic UrlResource(String protocol, String location) throws MalformedURLException {\r\n    this(protocol, location, null);\r\n}\n/**\r\n * Create a new {@code UrlResource} based on a URI specification.\r\n * <p>The given parts will automatically get encoded if necessary.\r\n * @param protocol the URL protocol to use (for example, \"jar\" or \"file\" - without colon);\r\n * also known as \"scheme\"\r\n * @param location the location (for example, the file path within that protocol);\r\n * also known as \"scheme-specific part\"\r\n * @param fragment the fragment within that location (for example, anchor on an HTML page,\r\n * as following after a \"#\" separator)\r\n * @throws MalformedURLException if the given URL specification is not valid\r\n * @see java.net.URI#URI(String, String, String)\r\n */\r\npublic UrlResource(String protocol, String location, @Nullable String fragment) throws MalformedURLException {\r\n    try {\r\n        this.uri = new URI(protocol, location, fragment);\r\n        this.url = this.uri.toURL();\r\n    } catch (URISyntaxException ex) {\r\n        MalformedURLException exToThrow = new MalformedURLException(ex.getMessage());\r\n        exToThrow.initCause(ex);\r\n        throw exToThrow;\r\n    }\r\n}\n/**\r\n * Create a new {@code UrlResource} from the given {@link URI}.\r\n * <p>This factory method is a convenience for {@link #UrlResource(URI)} that\r\n * catches any {@link MalformedURLException} and rethrows it wrapped in an\r\n * {@link UncheckedIOException}; suitable for use in {@link java.util.stream.Stream}\r\n * and {@link java.util.Optional} APIs or other scenarios when a checked\r\n * {@link IOException} is undesirable.\r\n * @param uri a URI\r\n * @throws UncheckedIOException if the given URL path is not valid\r\n * @since 6.0\r\n * @see #UrlResource(URI)\r\n */\r\npublic static UrlResource from(URI uri) throws UncheckedIOException {\r\n    try {\r\n        return new UrlResource(uri);\r\n    } catch (MalformedURLException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}\n/**\r\n * Create a new {@code UrlResource} from the given URL path.\r\n * <p>This factory method is a convenience for {@link #UrlResource(String)}\r\n * that catches any {@link MalformedURLException} and rethrows it wrapped in an\r\n * {@link UncheckedIOException}; suitable for use in {@link java.util.stream.Stream}\r\n * and {@link java.util.Optional} APIs or other scenarios when a checked\r\n * {@link IOException} is undesirable.\r\n * @param path a URL path\r\n * @throws UncheckedIOException if the given URL path is not valid\r\n * @since 6.0\r\n * @see #UrlResource(String)\r\n */\r\npublic static UrlResource from(String path) throws UncheckedIOException {\r\n    try {\r\n        return new UrlResource(path);\r\n    } catch (MalformedURLException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}\n/**\r\n * Lazily determine a cleaned URL for the given original URL.\r\n */\r\nprivate String getCleanedUrl() {\r\n    String cleanedUrl = this.cleanedUrl;\r\n    if (cleanedUrl != null) {\r\n        return cleanedUrl;\r\n    }\r\n    String originalPath = (this.uri != null ? this.uri : this.url).toString();\r\n    cleanedUrl = StringUtils.cleanPath(originalPath);\r\n    this.cleanedUrl = cleanedUrl;\r\n    return cleanedUrl;\r\n}\n/**\r\n * This implementation opens an InputStream for the given URL.\r\n * <p>It sets the {@code useCaches} flag to {@code false},\r\n * mainly to avoid jar file locking on Windows.\r\n * @see java.net.URL#openConnection()\r\n * @see java.net.URLConnection#setUseCaches(boolean)\r\n * @see java.net.URLConnection#getInputStream()\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    URLConnection con = this.url.openConnection();\r\n    customizeConnection(con);\r\n    try {\r\n        return con.getInputStream();\r\n    } catch (IOException ex) {\r\n        // Close the HTTP connection (if applicable).\r\n        if (con instanceof HttpURLConnection httpConn) {\r\n            httpConn.disconnect();\r\n        }\r\n        throw ex;\r\n    }\r\n}\n@Override\r\nprotected void customizeConnection(URLConnection con) throws IOException {\r\n    super.customizeConnection(con);\r\n    String userInfo = this.url.getUserInfo();\r\n    if (userInfo != null) {\r\n        String encodedCredentials = Base64.getUrlEncoder().encodeToString(userInfo.getBytes());\r\n        con.setRequestProperty(AUTHORIZATION, \"Basic \" + encodedCredentials);\r\n    }\r\n}\n/**\r\n * This implementation returns the underlying URL reference.\r\n */\r\n@Override\r\npublic URL getURL() {\r\n    return this.url;\r\n}\n/**\r\n * This implementation returns the underlying URI directly,\r\n * if possible.\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    if (this.uri != null) {\r\n        return this.uri;\r\n    } else {\r\n        return super.getURI();\r\n    }\r\n}\n@Override\r\npublic boolean isFile() {\r\n    if (this.uri != null) {\r\n        return super.isFile(this.uri);\r\n    } else {\r\n        return super.isFile();\r\n    }\r\n}\n/**\r\n * This implementation returns a File reference for the underlying URL/URI,\r\n * provided that it refers to a file in the file system.\r\n * @see org.springframework.util.ResourceUtils#getFile(java.net.URL, String)\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    if (this.uri != null) {\r\n        return super.getFile(this.uri);\r\n    } else {\r\n        return super.getFile();\r\n    }\r\n}\n/**\r\n * This implementation creates a {@code UrlResource}, delegating to\r\n * {@link #createRelativeURL(String)} for adapting the relative path.\r\n * @see #createRelativeURL(String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) throws MalformedURLException {\r\n    return new UrlResource(createRelativeURL(relativePath));\r\n}\n/**\r\n * This delegate creates a {@code java.net.URL}, applying the given path\r\n * relative to the path of the underlying URL of this resource descriptor.\r\n * <p>A leading slash will get dropped; a \"#\" symbol will get encoded.\r\n * Note that this method effectively cleans the combined path as of 6.1.\r\n * @since 5.2\r\n * @see #createRelative(String)\r\n * @see ResourceUtils#toRelativeURL(URL, String)\r\n */\r\nprotected URL createRelativeURL(String relativePath) throws MalformedURLException {\r\n    if (relativePath.startsWith(\"/\")) {\r\n        relativePath = relativePath.substring(1);\r\n    }\r\n    return ResourceUtils.toRelativeURL(this.url, relativePath);\r\n}\n/**\r\n * This implementation returns the URL-decoded name of the file that this URL\r\n * refers to.\r\n * @see java.net.URL#getPath()\r\n * @see java.net.URLDecoder#decode(String, java.nio.charset.Charset)\r\n */\r\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    if (this.uri != null) {\r\n        String path = this.uri.getPath();\r\n        if (path != null) {\r\n            // Prefer URI path: decoded and has standard separators\r\n            return StringUtils.getFilename(this.uri.getPath());\r\n        }\r\n    }\r\n    // Otherwise, process URL path\r\n    String filename = StringUtils.getFilename(StringUtils.cleanPath(this.url.getPath()));\r\n    return (filename != null ? URLDecoder.decode(filename, StandardCharsets.UTF_8) : null);\r\n}\n/**\r\n * This implementation returns a description that includes the URL.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"URL [\" + (this.uri != null ? this.uri : this.url) + \"]\";\r\n}\n/**\r\n * This implementation compares the underlying URL references.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof UrlResource that && getCleanedUrl().equals(that.getCleanedUrl())));\r\n}\n/**\r\n * This implementation returns the hash code of the underlying URL reference.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return getCleanedUrl().hashCode();\r\n}",
    "comment": "\n * {@link Resource} implementation for {@code java.net.URL} locators.\n * Supports resolution as a {@code URL} and also as a {@code File} in\n * case of the {@code \"file:\"} protocol.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 28.12.2003\n * @see java.net.URL\n "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#from(URI)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@code UrlResource} from the given {@link URI}.\r\n * <p>This factory method is a convenience for {@link #UrlResource(URI)} that\r\n * catches any {@link MalformedURLException} and rethrows it wrapped in an\r\n * {@link UncheckedIOException}; suitable for use in {@link java.util.stream.Stream}\r\n * and {@link java.util.Optional} APIs or other scenarios when a checked\r\n * {@link IOException} is undesirable.\r\n * @param uri a URI\r\n * @throws UncheckedIOException if the given URL path is not valid\r\n * @since 6.0\r\n * @see #UrlResource(URI)\r\n */\r\npublic static UrlResource from(URI uri) throws UncheckedIOException {\r\n    try {\r\n        return new UrlResource(uri);\r\n    } catch (MalformedURLException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}",
    "comment": "\n\t * Create a new {@code UrlResource} from the given {@link URI}.\n\t * <p>This factory method is a convenience for {@link #UrlResource(URI)} that\n\t * catches any {@link MalformedURLException} and rethrows it wrapped in an\n\t * {@link UncheckedIOException}; suitable for use in {@link java.util.stream.Stream}\n\t * and {@link java.util.Optional} APIs or other scenarios when a checked\n\t * {@link IOException} is undesirable.\n\t * @param uri a URI\n\t * @throws UncheckedIOException if the given URL path is not valid\n\t * @since 6.0\n\t * @see #UrlResource(URI)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#from(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@code UrlResource} from the given URL path.\r\n * <p>This factory method is a convenience for {@link #UrlResource(String)}\r\n * that catches any {@link MalformedURLException} and rethrows it wrapped in an\r\n * {@link UncheckedIOException}; suitable for use in {@link java.util.stream.Stream}\r\n * and {@link java.util.Optional} APIs or other scenarios when a checked\r\n * {@link IOException} is undesirable.\r\n * @param path a URL path\r\n * @throws UncheckedIOException if the given URL path is not valid\r\n * @since 6.0\r\n * @see #UrlResource(String)\r\n */\r\npublic static UrlResource from(String path) throws UncheckedIOException {\r\n    try {\r\n        return new UrlResource(path);\r\n    } catch (MalformedURLException ex) {\r\n        throw new UncheckedIOException(ex);\r\n    }\r\n}",
    "comment": "\n\t * Create a new {@code UrlResource} from the given URL path.\n\t * <p>This factory method is a convenience for {@link #UrlResource(String)}\n\t * that catches any {@link MalformedURLException} and rethrows it wrapped in an\n\t * {@link UncheckedIOException}; suitable for use in {@link java.util.stream.Stream}\n\t * and {@link java.util.Optional} APIs or other scenarios when a checked\n\t * {@link IOException} is undesirable.\n\t * @param path a URL path\n\t * @throws UncheckedIOException if the given URL path is not valid\n\t * @since 6.0\n\t * @see #UrlResource(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getCleanedUrl()",
    "entityType": "method",
    "code": "/**\r\n * Lazily determine a cleaned URL for the given original URL.\r\n */\r\nprivate String getCleanedUrl() {\r\n    String cleanedUrl = this.cleanedUrl;\r\n    if (cleanedUrl != null) {\r\n        return cleanedUrl;\r\n    }\r\n    String originalPath = (this.uri != null ? this.uri : this.url).toString();\r\n    cleanedUrl = StringUtils.cleanPath(originalPath);\r\n    this.cleanedUrl = cleanedUrl;\r\n    return cleanedUrl;\r\n}",
    "comment": "\n\t * Lazily determine a cleaned URL for the given original URL.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getInputStream()",
    "entityType": "method",
    "code": "/**\r\n * This implementation opens an InputStream for the given URL.\r\n * <p>It sets the {@code useCaches} flag to {@code false},\r\n * mainly to avoid jar file locking on Windows.\r\n * @see java.net.URL#openConnection()\r\n * @see java.net.URLConnection#setUseCaches(boolean)\r\n * @see java.net.URLConnection#getInputStream()\r\n */\r\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    URLConnection con = this.url.openConnection();\r\n    customizeConnection(con);\r\n    try {\r\n        return con.getInputStream();\r\n    } catch (IOException ex) {\r\n        // Close the HTTP connection (if applicable).\r\n        if (con instanceof HttpURLConnection httpConn) {\r\n            httpConn.disconnect();\r\n        }\r\n        throw ex;\r\n    }\r\n}",
    "comment": "\n\t * This implementation opens an InputStream for the given URL.\n\t * <p>It sets the {@code useCaches} flag to {@code false},\n\t * mainly to avoid jar file locking on Windows.\n\t * @see java.net.URL#openConnection()\n\t * @see java.net.URLConnection#setUseCaches(boolean)\n\t * @see java.net.URLConnection#getInputStream()\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#customizeConnection(URLConnection)",
    "entityType": "method",
    "code": "@Override\r\nprotected void customizeConnection(URLConnection con) throws IOException {\r\n    super.customizeConnection(con);\r\n    String userInfo = this.url.getUserInfo();\r\n    if (userInfo != null) {\r\n        String encodedCredentials = Base64.getUrlEncoder().encodeToString(userInfo.getBytes());\r\n        con.setRequestProperty(AUTHORIZATION, \"Basic \" + encodedCredentials);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getURL()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying URL reference.\r\n */\r\n@Override\r\npublic URL getURL() {\r\n    return this.url;\r\n}",
    "comment": "\n\t * This implementation returns the underlying URL reference.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getURI()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the underlying URI directly,\r\n * if possible.\r\n */\r\n@Override\r\npublic URI getURI() throws IOException {\r\n    if (this.uri != null) {\r\n        return this.uri;\r\n    } else {\r\n        return super.getURI();\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns the underlying URI directly,\n\t * if possible.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#isFile()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isFile() {\r\n    if (this.uri != null) {\r\n        return super.isFile(this.uri);\r\n    } else {\r\n        return super.isFile();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getFile()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a File reference for the underlying URL/URI,\r\n * provided that it refers to a file in the file system.\r\n * @see org.springframework.util.ResourceUtils#getFile(java.net.URL, String)\r\n */\r\n@Override\r\npublic File getFile() throws IOException {\r\n    if (this.uri != null) {\r\n        return super.getFile(this.uri);\r\n    } else {\r\n        return super.getFile();\r\n    }\r\n}",
    "comment": "\n\t * This implementation returns a File reference for the underlying URL/URI,\n\t * provided that it refers to a file in the file system.\n\t * @see org.springframework.util.ResourceUtils#getFile(java.net.URL, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#createRelative(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation creates a {@code UrlResource}, delegating to\r\n * {@link #createRelativeURL(String)} for adapting the relative path.\r\n * @see #createRelativeURL(String)\r\n */\r\n@Override\r\npublic Resource createRelative(String relativePath) throws MalformedURLException {\r\n    return new UrlResource(createRelativeURL(relativePath));\r\n}",
    "comment": "\n\t * This implementation creates a {@code UrlResource}, delegating to\n\t * {@link #createRelativeURL(String)} for adapting the relative path.\n\t * @see #createRelativeURL(String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#createRelativeURL(String)",
    "entityType": "method",
    "code": "/**\r\n * This delegate creates a {@code java.net.URL}, applying the given path\r\n * relative to the path of the underlying URL of this resource descriptor.\r\n * <p>A leading slash will get dropped; a \"#\" symbol will get encoded.\r\n * Note that this method effectively cleans the combined path as of 6.1.\r\n * @since 5.2\r\n * @see #createRelative(String)\r\n * @see ResourceUtils#toRelativeURL(URL, String)\r\n */\r\nprotected URL createRelativeURL(String relativePath) throws MalformedURLException {\r\n    if (relativePath.startsWith(\"/\")) {\r\n        relativePath = relativePath.substring(1);\r\n    }\r\n    return ResourceUtils.toRelativeURL(this.url, relativePath);\r\n}",
    "comment": "\n\t * This delegate creates a {@code java.net.URL}, applying the given path\n\t * relative to the path of the underlying URL of this resource descriptor.\n\t * <p>A leading slash will get dropped; a \"#\" symbol will get encoded.\n\t * Note that this method effectively cleans the combined path as of 6.1.\n\t * @since 5.2\n\t * @see #createRelative(String)\n\t * @see ResourceUtils#toRelativeURL(URL, String)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getFilename()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the URL-decoded name of the file that this URL\r\n * refers to.\r\n * @see java.net.URL#getPath()\r\n * @see java.net.URLDecoder#decode(String, java.nio.charset.Charset)\r\n */\r\n@Override\r\n@Nullable\r\npublic String getFilename() {\r\n    if (this.uri != null) {\r\n        String path = this.uri.getPath();\r\n        if (path != null) {\r\n            // Prefer URI path: decoded and has standard separators\r\n            return StringUtils.getFilename(this.uri.getPath());\r\n        }\r\n    }\r\n    // Otherwise, process URL path\r\n    String filename = StringUtils.getFilename(StringUtils.cleanPath(this.url.getPath()));\r\n    return (filename != null ? URLDecoder.decode(filename, StandardCharsets.UTF_8) : null);\r\n}",
    "comment": "\n\t * This implementation returns the URL-decoded name of the file that this URL\n\t * refers to.\n\t * @see java.net.URL#getPath()\n\t * @see java.net.URLDecoder#decode(String, java.nio.charset.Charset)\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#getDescription()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns a description that includes the URL.\r\n */\r\n@Override\r\npublic String getDescription() {\r\n    return \"URL [\" + (this.uri != null ? this.uri : this.url) + \"]\";\r\n}",
    "comment": "\n\t * This implementation returns a description that includes the URL.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#equals(Object)",
    "entityType": "method",
    "code": "/**\r\n * This implementation compares the underlying URL references.\r\n */\r\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof UrlResource that && getCleanedUrl().equals(that.getCleanedUrl())));\r\n}",
    "comment": "\n\t * This implementation compares the underlying URL references.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.UrlResource#hashCode()",
    "entityType": "method",
    "code": "/**\r\n * This implementation returns the hash code of the underlying URL reference.\r\n */\r\n@Override\r\npublic int hashCode() {\r\n    return getCleanedUrl().hashCode();\r\n}",
    "comment": "\n\t * This implementation returns the hash code of the underlying URL reference.\n\t "
  },
  {
    "entityId": "org.springframework.core.io.VfsResource",
    "entityType": "class",
    "code": "private final Object resource;\n/**\r\n * Create a new {@code VfsResource} wrapping the given resource handle.\r\n * @param resource a {@code org.jboss.vfs.VirtualFile} instance\r\n * (untyped in order to avoid a static dependency on the VFS API)\r\n */\r\npublic VfsResource(Object resource) {\r\n    Assert.notNull(resource, \"VirtualFile must not be null\");\r\n    this.resource = resource;\r\n}\n@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    return VfsUtils.getInputStream(this.resource);\r\n}\n@Override\r\npublic boolean exists() {\r\n    return VfsUtils.exists(this.resource);\r\n}\n@Override\r\npublic boolean isReadable() {\r\n    return VfsUtils.isReadable(this.resource);\r\n}\n@Override\r\npublic URL getURL() throws IOException {\r\n    try {\r\n        return VfsUtils.getURL(this.resource);\r\n    } catch (Exception ex) {\r\n        throw new IOException(\"Failed to obtain URL for file \" + this.resource, ex);\r\n    }\r\n}\n@Override\r\npublic URI getURI() throws IOException {\r\n    try {\r\n        return VfsUtils.getURI(this.resource);\r\n    } catch (Exception ex) {\r\n        throw new IOException(\"Failed to obtain URI for \" + this.resource, ex);\r\n    }\r\n}\n@Override\r\npublic File getFile() throws IOException {\r\n    return VfsUtils.getFile(this.resource);\r\n}\n@Override\r\npublic long contentLength() throws IOException {\r\n    return VfsUtils.getSize(this.resource);\r\n}\n@Override\r\npublic long lastModified() throws IOException {\r\n    return VfsUtils.getLastModified(this.resource);\r\n}\n@Override\r\npublic Resource createRelative(String relativePath) throws IOException {\r\n    if (!relativePath.startsWith(\".\") && relativePath.contains(\"/\")) {\r\n        try {\r\n            return new VfsResource(VfsUtils.getChild(this.resource, relativePath));\r\n        } catch (IOException ex) {\r\n            // fall back to getRelative\r\n        }\r\n    }\r\n    return new VfsResource(VfsUtils.getRelative(ResourceUtils.toRelativeURL(getURL(), relativePath)));\r\n}\n@Override\r\npublic String getFilename() {\r\n    return VfsUtils.getName(this.resource);\r\n}\n@Override\r\npublic String getDescription() {\r\n    return \"VFS resource [\" + this.resource + \"]\";\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof VfsResource that && this.resource.equals(that.resource)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.resource.hashCode();\r\n}",
    "comment": "\n * JBoss VFS based {@link Resource} implementation.\n *\n * <p>As of Spring 4.0, this class supports VFS 3.x on JBoss AS 6+\n * (package {@code org.jboss.vfs}) and is in particular compatible with\n * JBoss AS 7 and WildFly 8+.\n *\n * @author Ales Justin\n * @author Juergen Hoeller\n * @author Costin Leau\n * @author Sam Brannen\n * @since 3.0\n "
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#getInputStream()",
    "entityType": "method",
    "code": "@Override\r\npublic InputStream getInputStream() throws IOException {\r\n    return VfsUtils.getInputStream(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#exists()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean exists() {\r\n    return VfsUtils.exists(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#isReadable()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isReadable() {\r\n    return VfsUtils.isReadable(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#getURL()",
    "entityType": "method",
    "code": "@Override\r\npublic URL getURL() throws IOException {\r\n    try {\r\n        return VfsUtils.getURL(this.resource);\r\n    } catch (Exception ex) {\r\n        throw new IOException(\"Failed to obtain URL for file \" + this.resource, ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#getURI()",
    "entityType": "method",
    "code": "@Override\r\npublic URI getURI() throws IOException {\r\n    try {\r\n        return VfsUtils.getURI(this.resource);\r\n    } catch (Exception ex) {\r\n        throw new IOException(\"Failed to obtain URI for \" + this.resource, ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#getFile()",
    "entityType": "method",
    "code": "@Override\r\npublic File getFile() throws IOException {\r\n    return VfsUtils.getFile(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#contentLength()",
    "entityType": "method",
    "code": "@Override\r\npublic long contentLength() throws IOException {\r\n    return VfsUtils.getSize(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#lastModified()",
    "entityType": "method",
    "code": "@Override\r\npublic long lastModified() throws IOException {\r\n    return VfsUtils.getLastModified(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#createRelative(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Resource createRelative(String relativePath) throws IOException {\r\n    if (!relativePath.startsWith(\".\") && relativePath.contains(\"/\")) {\r\n        try {\r\n            return new VfsResource(VfsUtils.getChild(this.resource, relativePath));\r\n        } catch (IOException ex) {\r\n            // fall back to getRelative\r\n        }\r\n    }\r\n    return new VfsResource(VfsUtils.getRelative(ResourceUtils.toRelativeURL(getURL(), relativePath)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#getFilename()",
    "entityType": "method",
    "code": "@Override\r\npublic String getFilename() {\r\n    return VfsUtils.getName(this.resource);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#getDescription()",
    "entityType": "method",
    "code": "@Override\r\npublic String getDescription() {\r\n    return \"VFS resource [\" + this.resource + \"]\";\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof VfsResource that && this.resource.equals(that.resource)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.io.VfsResource#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.resource.hashCode();\r\n}",
    "comment": ""
  }
]