[
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#filterAttributes(Predicate<String>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new view of the annotation with only attributes that match the\r\n * given predicate.\r\n * @param predicate a predicate used to filter attribute names\r\n * @return a filtered view of the annotation\r\n * @see #filterDefaultValues()\r\n * @see MergedAnnotationPredicates\r\n */\r\nMergedAnnotation<A> filterAttributes(Predicate<String> predicate);",
    "comment": "\n\t * Create a new view of the annotation with only attributes that match the\n\t * given predicate.\n\t * @param predicate a predicate used to filter attribute names\n\t * @return a filtered view of the annotation\n\t * @see #filterDefaultValues()\n\t * @see MergedAnnotationPredicates\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#withNonMergedAttributes()",
    "entityType": "method",
    "code": "/**\r\n * Create a new view of the annotation that exposes non-merged attribute values.\r\n * <p>Methods from this view will return attribute values with only alias mirroring\r\n * rules applied. Aliases to {@link #getMetaSource() meta-source} attributes will\r\n * not be applied.\r\n * @return a non-merged view of the annotation\r\n */\r\nMergedAnnotation<A> withNonMergedAttributes();",
    "comment": "\n\t * Create a new view of the annotation that exposes non-merged attribute values.\n\t * <p>Methods from this view will return attribute values with only alias mirroring\n\t * rules applied. Aliases to {@link #getMetaSource() meta-source} attributes will\n\t * not be applied.\n\t * @return a non-merged view of the annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#asAnnotationAttributes(Adapt)",
    "entityType": "method",
    "code": "/**\r\n * Create a new mutable {@link AnnotationAttributes} instance from this\r\n * merged annotation.\r\n * <p>The {@link Adapt adaptations} may be used to change the way that values\r\n * are added.\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return an immutable map containing the attributes and values\r\n */\r\nAnnotationAttributes asAnnotationAttributes(Adapt... adaptations);",
    "comment": "\n\t * Create a new mutable {@link AnnotationAttributes} instance from this\n\t * merged annotation.\n\t * <p>The {@link Adapt adaptations} may be used to change the way that values\n\t * are added.\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return an immutable map containing the attributes and values\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#asMap(Adapt)",
    "entityType": "method",
    "code": "/**\r\n * Get an immutable {@link Map} that contains all the annotation attributes.\r\n * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return an immutable map containing the attributes and values\r\n */\r\nMap<String, Object> asMap(Adapt... adaptations);",
    "comment": "\n\t * Get an immutable {@link Map} that contains all the annotation attributes.\n\t * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return an immutable map containing the attributes and values\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#asMap(Function<MergedAnnotation<?>,T>,Adapt)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Map} instance of the given type that contains all the annotation\r\n * attributes.\r\n * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\r\n * @param factory a map factory\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return a map containing the attributes and values\r\n */\r\n<T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations);",
    "comment": "\n\t * Create a new {@link Map} instance of the given type that contains all the annotation\n\t * attributes.\n\t * <p>The {@link Adapt adaptations} may be used to change the way that values are added.\n\t * @param factory a map factory\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return a map containing the attributes and values\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#synthesize()",
    "entityType": "method",
    "code": "/**\r\n * Create a type-safe synthesized version of this merged annotation that can\r\n * be used directly in code.\r\n * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\r\n * and as a result may incur a computational cost when first invoked.\r\n * <p>If this merged annotation was created {@linkplain #of(AnnotatedElement, Class, Map)\r\n * from} a map of annotation attributes or default attribute values, those\r\n * attributes will always be synthesized into an annotation instance.\r\n * <p>If this merged annotation was created {@linkplain #from(Annotation) from}\r\n * an annotation instance, that annotation will be returned unmodified if it is\r\n * not <em>synthesizable</em>. An annotation is considered synthesizable if\r\n * it has not already been synthesized and one of the following is true.\r\n * <ul>\r\n * <li>The annotation declares attributes annotated with {@link AliasFor @AliasFor}.</li>\r\n * <li>The annotation is a composed annotation that relies on convention-based\r\n * annotation attribute overrides in meta-annotations.</li>\r\n * <li>The annotation declares attributes that are annotations or arrays of\r\n * annotations that are themselves synthesizable.</li>\r\n * </ul>\r\n * @return a synthesized version of the annotation or the original annotation\r\n * unmodified\r\n * @throws NoSuchElementException on a missing annotation\r\n */\r\nA synthesize() throws NoSuchElementException;",
    "comment": "\n\t * Create a type-safe synthesized version of this merged annotation that can\n\t * be used directly in code.\n\t * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\n\t * and as a result may incur a computational cost when first invoked.\n\t * <p>If this merged annotation was created {@linkplain #of(AnnotatedElement, Class, Map)\n\t * from} a map of annotation attributes or default attribute values, those\n\t * attributes will always be synthesized into an annotation instance.\n\t * <p>If this merged annotation was created {@linkplain #from(Annotation) from}\n\t * an annotation instance, that annotation will be returned unmodified if it is\n\t * not <em>synthesizable</em>. An annotation is considered synthesizable if\n\t * it has not already been synthesized and one of the following is true.\n\t * <ul>\n\t * <li>The annotation declares attributes annotated with {@link AliasFor @AliasFor}.</li>\n\t * <li>The annotation is a composed annotation that relies on convention-based\n\t * annotation attribute overrides in meta-annotations.</li>\n\t * <li>The annotation declares attributes that are annotations or arrays of\n\t * annotations that are themselves synthesizable.</li>\n\t * </ul>\n\t * @return a synthesized version of the annotation or the original annotation\n\t * unmodified\n\t * @throws NoSuchElementException on a missing annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#synthesize(Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "/**\r\n * Optionally create a type-safe synthesized version of this annotation based\r\n * on a condition predicate.\r\n * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\r\n * and as a result may incur a computational cost when first invoked.\r\n * <p>Consult the documentation for {@link #synthesize()} for an explanation\r\n * of what is considered synthesizable.\r\n * @param condition the test to determine if the annotation can be synthesized\r\n * @return an optional containing the synthesized version of the annotation or\r\n * an empty optional if the condition doesn't match\r\n * @throws NoSuchElementException on a missing annotation\r\n * @see MergedAnnotationPredicates\r\n */\r\nOptional<A> synthesize(Predicate<? super MergedAnnotation<A>> condition) throws NoSuchElementException;",
    "comment": "\n\t * Optionally create a type-safe synthesized version of this annotation based\n\t * on a condition predicate.\n\t * <p>The result is synthesized using a JDK {@link java.lang.reflect.Proxy Proxy}\n\t * and as a result may incur a computational cost when first invoked.\n\t * <p>Consult the documentation for {@link #synthesize()} for an explanation\n\t * of what is considered synthesizable.\n\t * @param condition the test to determine if the annotation can be synthesized\n\t * @return an optional containing the synthesized version of the annotation or\n\t * an empty optional if the condition doesn't match\n\t * @throws NoSuchElementException on a missing annotation\n\t * @see MergedAnnotationPredicates\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#missing()",
    "entityType": "method",
    "code": "/**\r\n * Create a {@link MergedAnnotation} that represents a missing annotation\r\n * (i.e. one that is not present).\r\n * @return an instance representing a missing annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> missing() {\r\n    return MissingMergedAnnotation.getInstance();\r\n}",
    "comment": "\n\t * Create a {@link MergedAnnotation} that represents a missing annotation\n\t * (i.e. one that is not present).\n\t * @return an instance representing a missing annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#from(A)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotation} instance from the specified\r\n * annotation.\r\n * @param annotation the annotation to include\r\n * @return a {@link MergedAnnotation} instance containing the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> from(A annotation) {\r\n    return from(null, annotation);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotation} instance from the specified\n\t * annotation.\n\t * @param annotation the annotation to include\n\t * @return a {@link MergedAnnotation} instance containing the annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#from(Object,A)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotation} instance from the specified\r\n * annotation.\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations, and it will not be searched.\r\n * @param annotation the annotation to include\r\n * @return a {@link MergedAnnotation} instance for the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {\r\n    return TypeMappedAnnotation.from(source, annotation);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotation} instance from the specified\n\t * annotation.\n\t * @param source the source for the annotation. This source is used only for\n\t * information and logging. It does not need to <em>actually</em> contain\n\t * the specified annotations, and it will not be searched.\n\t * @param annotation the annotation to include\n\t * @return a {@link MergedAnnotation} instance for the annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#of(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type. The resulting annotation will not have any attribute\r\n * values but may still be used to query default values.\r\n * @param annotationType the annotation type\r\n * @return a {@link MergedAnnotation} instance for the annotation\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType) {\r\n    return of(null, annotationType, null);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type. The resulting annotation will not have any attribute\n\t * values but may still be used to query default values.\n\t * @param annotationType the annotation type\n\t * @return a {@link MergedAnnotation} instance for the annotation\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#of(Class<A>,Map<String,?>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n * @see #of(AnnotatedElement, Class, Map)\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return of(null, annotationType, attributes);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type with attribute values supplied by a map.\n\t * @param annotationType the annotation type\n\t * @param attributes the annotation attributes or {@code null} if just default\n\t * values should be used\n\t * @return a {@link MergedAnnotation} instance for the annotation and attributes\n\t * @see #of(AnnotatedElement, Class, Map)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#of(AnnotatedElement,Class<A>,Map<String,?>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations and it will not be searched.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable AnnotatedElement source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return of(null, source, annotationType, attributes);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type with attribute values supplied by a map.\n\t * @param source the source for the annotation. This source is used only for\n\t * information and logging. It does not need to <em>actually</em> contain\n\t * the specified annotations and it will not be searched.\n\t * @param annotationType the annotation type\n\t * @param attributes the annotation attributes or {@code null} if just default\n\t * values should be used\n\t * @return a {@link MergedAnnotation} instance for the annotation and attributes\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotation#of(ClassLoader,Object,Class<A>,Map<String,?>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotation} instance of the specified\r\n * annotation type with attribute values supplied by a map.\r\n * @param classLoader the class loader used to resolve class attributes\r\n * @param source the source for the annotation. This source is used only for\r\n * information and logging. It does not need to <em>actually</em> contain\r\n * the specified annotations and it will not be searched.\r\n * @param annotationType the annotation type\r\n * @param attributes the annotation attributes or {@code null} if just default\r\n * values should be used\r\n * @return a {@link MergedAnnotation} instance for the annotation and attributes\r\n */\r\nstatic <A extends Annotation> MergedAnnotation<A> of(@Nullable ClassLoader classLoader, @Nullable Object source, Class<A> annotationType, @Nullable Map<String, ?> attributes) {\r\n    return TypeMappedAnnotation.of(classLoader, source, annotationType, attributes);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotation} instance of the specified\n\t * annotation type with attribute values supplied by a map.\n\t * @param classLoader the class loader used to resolve class attributes\n\t * @param source the source for the annotation. This source is used only for\n\t * information and logging. It does not need to <em>actually</em> contain\n\t * the specified annotations and it will not be searched.\n\t * @param annotationType the annotation type\n\t * @param attributes the annotation attributes or {@code null} if just default\n\t * values should be used\n\t * @return a {@link MergedAnnotation} instance for the annotation and attributes\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors",
    "entityType": "class",
    "code": "private static final Characteristics[] NO_CHARACTERISTICS = {};\nprivate static final Characteristics[] IDENTITY_FINISH_CHARACTERISTICS = { Characteristics.IDENTITY_FINISH };\nprivate MergedAnnotationCollectors() {\r\n}\n/**\r\n * Create a new {@link Collector} that accumulates merged annotations to a\r\n * {@link LinkedHashSet} containing {@linkplain MergedAnnotation#synthesize()\r\n * synthesized} versions.\r\n * <p>The collector returned by this method is effectively equivalent to\r\n * {@code Collectors.mapping(MergedAnnotation::synthesize, Collectors.toCollection(LinkedHashSet::new))}\r\n * but avoids the creation of a composite collector.\r\n * @param <A> the annotation type\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into a {@link Set}\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Set<A>> toAnnotationSet() {\r\n    return Collector.of(LinkedHashSet::new, (set, annotation) -> set.add(annotation.synthesize()), MergedAnnotationCollectors::combiner);\r\n}\n/**\r\n * Create a new {@link Collector} that accumulates merged annotations to an\r\n * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\r\n * synthesized} versions.\r\n * @param <A> the annotation type\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into an {@code Annotation[]}\r\n * @see #toAnnotationArray(IntFunction)\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Annotation[]> toAnnotationArray() {\r\n    return toAnnotationArray(Annotation[]::new);\r\n}\n/**\r\n * Create a new {@link Collector} that accumulates merged annotations to an\r\n * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\r\n * synthesized} versions.\r\n * @param <A> the annotation type\r\n * @param <R> the resulting array type\r\n * @param generator a function which produces a new array of the desired\r\n * type and the provided length\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into an annotation array\r\n * @see #toAnnotationArray\r\n */\r\npublic static <R extends Annotation, A extends R> Collector<MergedAnnotation<A>, ?, R[]> toAnnotationArray(IntFunction<R[]> generator) {\r\n    return Collector.of(ArrayList::new, (list, annotation) -> list.add(annotation.synthesize()), MergedAnnotationCollectors::combiner, list -> list.toArray(generator.apply(list.size())));\r\n}\n/**\r\n * Create a new {@link Collector} that accumulates merged annotations to a\r\n * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\r\n * added} from each merged annotation\r\n * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\r\n * @param <A> the annotation type\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into a {@link LinkedMultiValueMap}\r\n * @see #toMultiValueMap(Function, MergedAnnotation.Adapt...)\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ? extends @Nullable Object, @Nullable MultiValueMap<String, @Nullable Object>> toMultiValueMap(Adapt... adaptations) {\r\n    return toMultiValueMap((MultiValueMap<String, @Nullable Object> t) -> t, adaptations);\r\n}\n/**\r\n * Create a new {@link Collector} that accumulates merged annotations to a\r\n * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\r\n * added} from each merged annotation\r\n * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\r\n * @param <A> the annotation type\r\n * @param finisher the finisher function for the new {@link MultiValueMap}\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into a {@link LinkedMultiValueMap}\r\n * @see #toMultiValueMap(MergedAnnotation.Adapt...)\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ? extends @Nullable Object, @Nullable MultiValueMap<String, @Nullable Object>> toMultiValueMap(Function<MultiValueMap<String, @Nullable Object>, @Nullable MultiValueMap<String, @Nullable Object>> finisher, Adapt... adaptations) {\r\n    Characteristics[] characteristics = (isSameInstance(finisher, Function.identity()) ? IDENTITY_FINISH_CHARACTERISTICS : NO_CHARACTERISTICS);\r\n    return Collector.of(LinkedMultiValueMap::new, (MultiValueMap<String, @Nullable Object> map, MergedAnnotation<A> annotation) -> annotation.asMap(adaptations).forEach(map::add), MergedAnnotationCollectors::combiner, finisher, characteristics);\r\n}\nprivate static boolean isSameInstance(Object instance, Object candidate) {\r\n    return instance == candidate;\r\n}\n/**\r\n * {@link Collector#combiner() Combiner} for collections.\r\n * <p>This method is only invoked if the {@link java.util.stream.Stream} is\r\n * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\r\n */\r\nprivate static <E, C extends Collection<E>> C combiner(C collection, C additions) {\r\n    collection.addAll(additions);\r\n    return collection;\r\n}\n/**\r\n * {@link Collector#combiner() Combiner} for multi-value maps.\r\n * <p>This method is only invoked if the {@link java.util.stream.Stream} is\r\n * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\r\n */\r\nprivate static <K, V> MultiValueMap<K, @Nullable V> combiner(MultiValueMap<K, @Nullable V> map, MultiValueMap<K, @Nullable V> additions) {\r\n    map.addAll(additions);\r\n    return map;\r\n}",
    "comment": "\n * {@link Collector} implementations that provide various reduction operations for\n * {@link MergedAnnotation} instances.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#toAnnotationSet()",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Collector} that accumulates merged annotations to a\r\n * {@link LinkedHashSet} containing {@linkplain MergedAnnotation#synthesize()\r\n * synthesized} versions.\r\n * <p>The collector returned by this method is effectively equivalent to\r\n * {@code Collectors.mapping(MergedAnnotation::synthesize, Collectors.toCollection(LinkedHashSet::new))}\r\n * but avoids the creation of a composite collector.\r\n * @param <A> the annotation type\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into a {@link Set}\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Set<A>> toAnnotationSet() {\r\n    return Collector.of(LinkedHashSet::new, (set, annotation) -> set.add(annotation.synthesize()), MergedAnnotationCollectors::combiner);\r\n}",
    "comment": "\n\t * Create a new {@link Collector} that accumulates merged annotations to a\n\t * {@link LinkedHashSet} containing {@linkplain MergedAnnotation#synthesize()\n\t * synthesized} versions.\n\t * <p>The collector returned by this method is effectively equivalent to\n\t * {@code Collectors.mapping(MergedAnnotation::synthesize, Collectors.toCollection(LinkedHashSet::new))}\n\t * but avoids the creation of a composite collector.\n\t * @param <A> the annotation type\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into a {@link Set}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#toAnnotationArray()",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Collector} that accumulates merged annotations to an\r\n * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\r\n * synthesized} versions.\r\n * @param <A> the annotation type\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into an {@code Annotation[]}\r\n * @see #toAnnotationArray(IntFunction)\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Annotation[]> toAnnotationArray() {\r\n    return toAnnotationArray(Annotation[]::new);\r\n}",
    "comment": "\n\t * Create a new {@link Collector} that accumulates merged annotations to an\n\t * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\n\t * synthesized} versions.\n\t * @param <A> the annotation type\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into an {@code Annotation[]}\n\t * @see #toAnnotationArray(IntFunction)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#toAnnotationArray(IntFunction<R[]>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Collector} that accumulates merged annotations to an\r\n * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\r\n * synthesized} versions.\r\n * @param <A> the annotation type\r\n * @param <R> the resulting array type\r\n * @param generator a function which produces a new array of the desired\r\n * type and the provided length\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into an annotation array\r\n * @see #toAnnotationArray\r\n */\r\npublic static <R extends Annotation, A extends R> Collector<MergedAnnotation<A>, ?, R[]> toAnnotationArray(IntFunction<R[]> generator) {\r\n    return Collector.of(ArrayList::new, (list, annotation) -> list.add(annotation.synthesize()), MergedAnnotationCollectors::combiner, list -> list.toArray(generator.apply(list.size())));\r\n}",
    "comment": "\n\t * Create a new {@link Collector} that accumulates merged annotations to an\n\t * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()\n\t * synthesized} versions.\n\t * @param <A> the annotation type\n\t * @param <R> the resulting array type\n\t * @param generator a function which produces a new array of the desired\n\t * type and the provided length\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into an annotation array\n\t * @see #toAnnotationArray\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#toMultiValueMap(Adapt)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Collector} that accumulates merged annotations to a\r\n * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\r\n * added} from each merged annotation\r\n * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\r\n * @param <A> the annotation type\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into a {@link LinkedMultiValueMap}\r\n * @see #toMultiValueMap(Function, MergedAnnotation.Adapt...)\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ? extends @Nullable Object, @Nullable MultiValueMap<String, @Nullable Object>> toMultiValueMap(Adapt... adaptations) {\r\n    return toMultiValueMap((MultiValueMap<String, @Nullable Object> t) -> t, adaptations);\r\n}",
    "comment": "\n\t * Create a new {@link Collector} that accumulates merged annotations to a\n\t * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\n\t * added} from each merged annotation\n\t * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\n\t * @param <A> the annotation type\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into a {@link LinkedMultiValueMap}\n\t * @see #toMultiValueMap(Function, MergedAnnotation.Adapt...)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#toMultiValueMap(Function<MultiValueMap<String,Object>,MultiValueMap<String,Object>>,Adapt)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Collector} that accumulates merged annotations to a\r\n * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\r\n * added} from each merged annotation\r\n * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\r\n * @param <A> the annotation type\r\n * @param finisher the finisher function for the new {@link MultiValueMap}\r\n * @param adaptations the adaptations that should be applied to the annotation values\r\n * @return a {@link Collector} which collects and synthesizes the\r\n * annotations into a {@link LinkedMultiValueMap}\r\n * @see #toMultiValueMap(MergedAnnotation.Adapt...)\r\n */\r\npublic static <A extends Annotation> Collector<MergedAnnotation<A>, ? extends @Nullable Object, @Nullable MultiValueMap<String, @Nullable Object>> toMultiValueMap(Function<MultiValueMap<String, @Nullable Object>, @Nullable MultiValueMap<String, @Nullable Object>> finisher, Adapt... adaptations) {\r\n    Characteristics[] characteristics = (isSameInstance(finisher, Function.identity()) ? IDENTITY_FINISH_CHARACTERISTICS : NO_CHARACTERISTICS);\r\n    return Collector.of(LinkedMultiValueMap::new, (MultiValueMap<String, @Nullable Object> map, MergedAnnotation<A> annotation) -> annotation.asMap(adaptations).forEach(map::add), MergedAnnotationCollectors::combiner, finisher, characteristics);\r\n}",
    "comment": "\n\t * Create a new {@link Collector} that accumulates merged annotations to a\n\t * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)\n\t * added} from each merged annotation\n\t * {@linkplain MergedAnnotation#asMap(Adapt...) as a map}.\n\t * @param <A> the annotation type\n\t * @param finisher the finisher function for the new {@link MultiValueMap}\n\t * @param adaptations the adaptations that should be applied to the annotation values\n\t * @return a {@link Collector} which collects and synthesizes the\n\t * annotations into a {@link LinkedMultiValueMap}\n\t * @see #toMultiValueMap(MergedAnnotation.Adapt...)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#isSameInstance(Object,Object)",
    "entityType": "method",
    "code": "private static boolean isSameInstance(Object instance, Object candidate) {\r\n    return instance == candidate;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#combiner(C,C)",
    "entityType": "method",
    "code": "/**\r\n * {@link Collector#combiner() Combiner} for collections.\r\n * <p>This method is only invoked if the {@link java.util.stream.Stream} is\r\n * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\r\n */\r\nprivate static <E, C extends Collection<E>> C combiner(C collection, C additions) {\r\n    collection.addAll(additions);\r\n    return collection;\r\n}",
    "comment": "\n\t * {@link Collector#combiner() Combiner} for collections.\n\t * <p>This method is only invoked if the {@link java.util.stream.Stream} is\n\t * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationCollectors#combiner(MultiValueMap<K,V>,MultiValueMap<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * {@link Collector#combiner() Combiner} for multi-value maps.\r\n * <p>This method is only invoked if the {@link java.util.stream.Stream} is\r\n * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\r\n */\r\nprivate static <K, V> MultiValueMap<K, @Nullable V> combiner(MultiValueMap<K, @Nullable V> map, MultiValueMap<K, @Nullable V> additions) {\r\n    map.addAll(additions);\r\n    return map;\r\n}",
    "comment": "\n\t * {@link Collector#combiner() Combiner} for multi-value maps.\n\t * <p>This method is only invoked if the {@link java.util.stream.Stream} is\n\t * processed in {@linkplain java.util.stream.Stream#parallel() parallel}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicates",
    "entityType": "class",
    "code": "private MergedAnnotationPredicates() {\r\n}\n/**\r\n * Create a new {@link Predicate} that evaluates to {@code true} if the name of the\r\n * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\r\n * the specified array.\r\n * @param <A> the annotation type\r\n * @param typeNames the names that should be matched\r\n * @return a {@link Predicate} to test the annotation type\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(String... typeNames) {\r\n    return annotation -> ObjectUtils.containsElement(typeNames, annotation.getType().getName());\r\n}\n/**\r\n * Create a new {@link Predicate} that evaluates to {@code true} if the\r\n * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\r\n * the specified array.\r\n * @param <A> the annotation type\r\n * @param types the types that should be matched\r\n * @return a {@link Predicate} to test the annotation type\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Class<?>... types) {\r\n    return annotation -> ObjectUtils.containsElement(types, annotation.getType());\r\n}\n/**\r\n * Create a new {@link Predicate} that evaluates to {@code true} if the\r\n * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\r\n * the specified collection.\r\n * @param <A> the annotation type\r\n * @param types the type names or classes that should be matched\r\n * @return a {@link Predicate} to test the annotation type\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Collection<?> types) {\r\n    return annotation -> types.stream().map(type -> type instanceof Class<?> clazz ? clazz.getName() : type.toString()).anyMatch(typeName -> typeName.equals(annotation.getType().getName()));\r\n}\n/**\r\n * Create a new stateful, single use {@link Predicate} that matches only\r\n * the first run of an extracted value. For example,\r\n * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\r\n * will match the first annotation, and any subsequent runs that have the\r\n * same distance.\r\n * <p>NOTE: This predicate only matches the first run. Once the extracted\r\n * value changes, the predicate always returns {@code false}. For example,\r\n * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\r\n * only the first two will match.\r\n * @param valueExtractor function used to extract the value to check\r\n * @return a {@link Predicate} that matches the first run of the extracted\r\n * values\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(Function<? super MergedAnnotation<A>, ?> valueExtractor) {\r\n    return new FirstRunOfPredicate<>(valueExtractor);\r\n}\n/**\r\n * Create a new stateful, single use {@link Predicate} that matches\r\n * annotations that are unique based on the extracted key. For example\r\n * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\r\n * match the first time a unique type is encountered.\r\n * @param keyExtractor function used to extract the key used to test for\r\n * uniqueness\r\n * @return a {@link Predicate} that matches a unique annotation based on the\r\n * extracted key\r\n */\r\npublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(Function<? super MergedAnnotation<A>, K> keyExtractor) {\r\n    return new UniquePredicate<>(keyExtractor);\r\n}\n/**\r\n * {@link Predicate} implementation used for\r\n * {@link MergedAnnotationPredicates#firstRunOf(Function)}.\r\n */\r\nprivate static class FirstRunOfPredicate<A extends Annotation> implements Predicate<MergedAnnotation<A>> {\r\n\r\n    private final Function<? super MergedAnnotation<A>, ?> valueExtractor;\r\n\r\n    private boolean hasLastValue;\r\n\r\n    @SuppressWarnings(\"NullAway.Init\")\r\n    private Object lastValue;\r\n\r\n    FirstRunOfPredicate(Function<? super MergedAnnotation<A>, ?> valueExtractor) {\r\n        Assert.notNull(valueExtractor, \"Value extractor must not be null\");\r\n        this.valueExtractor = valueExtractor;\r\n    }\r\n\r\n    @Override\r\n    public boolean test(MergedAnnotation<A> annotation) {\r\n        if (!this.hasLastValue) {\r\n            this.hasLastValue = true;\r\n            this.lastValue = this.valueExtractor.apply(annotation);\r\n        }\r\n        Object value = this.valueExtractor.apply(annotation);\r\n        return ObjectUtils.nullSafeEquals(value, this.lastValue);\r\n    }\r\n}\n/**\r\n * {@link Predicate} implementation used for\r\n * {@link MergedAnnotationPredicates#unique(Function)}.\r\n */\r\nprivate static class UniquePredicate<A extends Annotation, K> implements Predicate<MergedAnnotation<A>> {\r\n\r\n    private final Function<? super MergedAnnotation<A>, K> keyExtractor;\r\n\r\n    private final Set<K> seen = new HashSet<>();\r\n\r\n    UniquePredicate(Function<? super MergedAnnotation<A>, K> keyExtractor) {\r\n        Assert.notNull(keyExtractor, \"Key extractor must not be null\");\r\n        this.keyExtractor = keyExtractor;\r\n    }\r\n\r\n    @Override\r\n    public boolean test(MergedAnnotation<A> annotation) {\r\n        K key = this.keyExtractor.apply(annotation);\r\n        return this.seen.add(key);\r\n    }\r\n}",
    "comment": "\n * Predicate implementations that provide various test operations for\n * {@link MergedAnnotation MergedAnnotations}.\n *\n * @author Phillip Webb\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicates#typeIn(String)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Predicate} that evaluates to {@code true} if the name of the\r\n * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\r\n * the specified array.\r\n * @param <A> the annotation type\r\n * @param typeNames the names that should be matched\r\n * @return a {@link Predicate} to test the annotation type\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(String... typeNames) {\r\n    return annotation -> ObjectUtils.containsElement(typeNames, annotation.getType().getName());\r\n}",
    "comment": "\n\t * Create a new {@link Predicate} that evaluates to {@code true} if the name of the\n\t * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified array.\n\t * @param <A> the annotation type\n\t * @param typeNames the names that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicates#typeIn(Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Predicate} that evaluates to {@code true} if the\r\n * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\r\n * the specified array.\r\n * @param <A> the annotation type\r\n * @param types the types that should be matched\r\n * @return a {@link Predicate} to test the annotation type\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Class<?>... types) {\r\n    return annotation -> ObjectUtils.containsElement(types, annotation.getType());\r\n}",
    "comment": "\n\t * Create a new {@link Predicate} that evaluates to {@code true} if the\n\t * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified array.\n\t * @param <A> the annotation type\n\t * @param types the types that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicates#typeIn(Collection<?>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link Predicate} that evaluates to {@code true} if the\r\n * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\r\n * the specified collection.\r\n * @param <A> the annotation type\r\n * @param types the type names or classes that should be matched\r\n * @return a {@link Predicate} to test the annotation type\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Collection<?> types) {\r\n    return annotation -> types.stream().map(type -> type instanceof Class<?> clazz ? clazz.getName() : type.toString()).anyMatch(typeName -> typeName.equals(annotation.getType().getName()));\r\n}",
    "comment": "\n\t * Create a new {@link Predicate} that evaluates to {@code true} if the\n\t * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified collection.\n\t * @param <A> the annotation type\n\t * @param types the type names or classes that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicates#firstRunOf(Function<? super MergedAnnotation<A>,?>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new stateful, single use {@link Predicate} that matches only\r\n * the first run of an extracted value. For example,\r\n * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\r\n * will match the first annotation, and any subsequent runs that have the\r\n * same distance.\r\n * <p>NOTE: This predicate only matches the first run. Once the extracted\r\n * value changes, the predicate always returns {@code false}. For example,\r\n * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\r\n * only the first two will match.\r\n * @param valueExtractor function used to extract the value to check\r\n * @return a {@link Predicate} that matches the first run of the extracted\r\n * values\r\n */\r\npublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(Function<? super MergedAnnotation<A>, ?> valueExtractor) {\r\n    return new FirstRunOfPredicate<>(valueExtractor);\r\n}",
    "comment": "\n\t * Create a new stateful, single use {@link Predicate} that matches only\n\t * the first run of an extracted value. For example,\n\t * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}\n\t * will match the first annotation, and any subsequent runs that have the\n\t * same distance.\n\t * <p>NOTE: This predicate only matches the first run. Once the extracted\n\t * value changes, the predicate always returns {@code false}. For example,\n\t * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then\n\t * only the first two will match.\n\t * @param valueExtractor function used to extract the value to check\n\t * @return a {@link Predicate} that matches the first run of the extracted\n\t * values\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationPredicates#unique(Function<? super MergedAnnotation<A>,K>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new stateful, single use {@link Predicate} that matches\r\n * annotations that are unique based on the extracted key. For example\r\n * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\r\n * match the first time a unique type is encountered.\r\n * @param keyExtractor function used to extract the key used to test for\r\n * uniqueness\r\n * @return a {@link Predicate} that matches a unique annotation based on the\r\n * extracted key\r\n */\r\npublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(Function<? super MergedAnnotation<A>, K> keyExtractor) {\r\n    return new UniquePredicate<>(keyExtractor);\r\n}",
    "comment": "\n\t * Create a new stateful, single use {@link Predicate} that matches\n\t * annotations that are unique based on the extracted key. For example\n\t * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will\n\t * match the first time a unique type is encountered.\n\t * @param keyExtractor function used to extract the key used to test for\n\t * uniqueness\n\t * @return a {@link Predicate} that matches a unique annotation based on the\n\t * extracted key\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.FirstRunOfPredicate",
    "entityType": "class",
    "code": "private final Function<? super MergedAnnotation<A>, ?> valueExtractor;\nprivate boolean hasLastValue;\n@SuppressWarnings(\"NullAway.Init\")\r\nprivate Object lastValue;\nFirstRunOfPredicate(Function<? super MergedAnnotation<A>, ?> valueExtractor) {\r\n    Assert.notNull(valueExtractor, \"Value extractor must not be null\");\r\n    this.valueExtractor = valueExtractor;\r\n}\n@Override\r\npublic boolean test(MergedAnnotation<A> annotation) {\r\n    if (!this.hasLastValue) {\r\n        this.hasLastValue = true;\r\n        this.lastValue = this.valueExtractor.apply(annotation);\r\n    }\r\n    Object value = this.valueExtractor.apply(annotation);\r\n    return ObjectUtils.nullSafeEquals(value, this.lastValue);\r\n}",
    "comment": "\n\t * {@link Predicate} implementation used for\n\t * {@link MergedAnnotationPredicates#firstRunOf(Function)}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.FirstRunOfPredicate#test(MergedAnnotation<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(MergedAnnotation<A> annotation) {\r\n    if (!this.hasLastValue) {\r\n        this.hasLastValue = true;\r\n        this.lastValue = this.valueExtractor.apply(annotation);\r\n    }\r\n    Object value = this.valueExtractor.apply(annotation);\r\n    return ObjectUtils.nullSafeEquals(value, this.lastValue);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.UniquePredicate",
    "entityType": "class",
    "code": "private final Function<? super MergedAnnotation<A>, K> keyExtractor;\nprivate final Set<K> seen = new HashSet<>();\nUniquePredicate(Function<? super MergedAnnotation<A>, K> keyExtractor) {\r\n    Assert.notNull(keyExtractor, \"Key extractor must not be null\");\r\n    this.keyExtractor = keyExtractor;\r\n}\n@Override\r\npublic boolean test(MergedAnnotation<A> annotation) {\r\n    K key = this.keyExtractor.apply(annotation);\r\n    return this.seen.add(key);\r\n}",
    "comment": "\n\t * {@link Predicate} implementation used for\n\t * {@link MergedAnnotationPredicates#unique(Function)}.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.UniquePredicate#test(MergedAnnotation<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean test(MergedAnnotation<A> annotation) {\r\n    K key = this.keyExtractor.apply(annotation);\r\n    return this.seen.add(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations",
    "entityType": "class",
    "code": "/**\r\n * Determine if the specified annotation type is either directly present or\r\n * meta-present.\r\n * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\r\n * @param annotationType the annotation type to check\r\n * @return {@code true} if the annotation is present\r\n */\r\n<A extends Annotation> boolean isPresent(Class<A> annotationType);\n/**\r\n * Determine if the specified annotation type is either directly present or\r\n * meta-present.\r\n * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to check\r\n * @return {@code true} if the annotation is present\r\n */\r\nboolean isPresent(String annotationType);\n/**\r\n * Determine if the specified annotation type is directly present.\r\n * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\r\n * @param annotationType the annotation type to check\r\n * @return {@code true} if the annotation is directly present\r\n */\r\n<A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType);\n/**\r\n * Determine if the specified annotation type is directly present.\r\n * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to check\r\n * @return {@code true} if the annotation is directly present\r\n */\r\nboolean isDirectlyPresent(String annotationType);\n/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the annotation type to get\r\n * @return a {@link MergedAnnotation} instance\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType);\n/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the annotation type to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate);\n/**\r\n * Get a matching annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the annotation type to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @param selector a selector used to choose the most appropriate annotation\r\n * within an aggregate, or {@code null} to select the\r\n * {@linkplain MergedAnnotationSelectors#nearest() nearest}\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n * @see MergedAnnotationSelectors\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector);\n/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to get\r\n * @return a {@link MergedAnnotation} instance\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(String annotationType);\n/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate);\n/**\r\n * Get a matching annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @param selector a selector used to choose the most appropriate annotation\r\n * within an aggregate, or {@code null} to select the\r\n * {@linkplain MergedAnnotationSelectors#nearest() nearest}\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n * @see MergedAnnotationSelectors\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector);\n/**\r\n * Stream all annotations and meta-annotations that match the specified\r\n * type.\r\n * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\r\n * @param annotationType the annotation type to match\r\n * @return a stream of matching annotations\r\n */\r\n<A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType);\n/**\r\n * Stream all annotations and meta-annotations that match the specified\r\n * type.\r\n * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to match\r\n * @return a stream of matching annotations\r\n */\r\n<A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType);\n/**\r\n * Stream all annotations and meta-annotations contained in this collection.\r\n * <p>The resulting stream is ordered first by the\r\n * {@linkplain MergedAnnotation#getAggregateIndex() aggregate index} and then\r\n * by the annotation distance (with the closest annotations first). This ordering\r\n * means that, for most use-cases, the most suitable annotations appear\r\n * earliest in the stream.\r\n * @return a stream of annotations\r\n */\r\nStream<MergedAnnotation<Annotation>> stream();\n/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element.\r\n * <p>The resulting instance will not include any inherited annotations. If\r\n * you want to include those as well you should use\r\n * {@link #from(AnnotatedElement, SearchStrategy)} with an appropriate\r\n * {@link SearchStrategy}.\r\n * @param element the source element\r\n * @return a {@code MergedAnnotations} instance containing the element's\r\n * annotations\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element) {\r\n    return from(element, SearchStrategy.DIRECT);\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements.\r\n * @param element the source element\r\n * @param searchStrategy the search strategy to use\r\n * @return a {@code MergedAnnotations} instance containing the merged\r\n * element annotations\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy) {\r\n    return from(element, searchStrategy, RepeatableContainers.standardRepeatables());\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements.\r\n * @param element the source element\r\n * @param searchStrategy the search strategy to use\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the element annotations or the meta-annotations\r\n * @return a {@code MergedAnnotations} instance containing the merged\r\n * element annotations\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, RepeatableContainers repeatableContainers) {\r\n    return from(element, searchStrategy, repeatableContainers, AnnotationFilter.PLAIN);\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements.\r\n * @param element the source element\r\n * @param searchStrategy the search strategy to use\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the element annotations or the meta-annotations\r\n * @param annotationFilter an annotation filter used to restrict the\r\n * annotations considered\r\n * @return a {@code MergedAnnotations} instance containing the merged\r\n * annotations for the supplied element\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    return from(element, searchStrategy, Search.never, repeatableContainers, annotationFilter);\r\n}\nprivate static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    Assert.notNull(element, \"AnnotatedElement must not be null\");\r\n    Assert.notNull(searchStrategy, \"SearchStrategy must not be null\");\r\n    Assert.notNull(searchEnclosingClass, \"Predicate must not be null\");\r\n    Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n    Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n    return TypeMappedAnnotations.from(element, searchStrategy, searchEnclosingClass, repeatableContainers, annotationFilter);\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param annotations the annotations to include\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n * @see #from(Object, Annotation...)\r\n */\r\nstatic MergedAnnotations from(Annotation... annotations) {\r\n    return from(annotations, annotations);\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param source the source for the annotations. This source is used only\r\n * for information and logging. It does not need to <em>actually</em>\r\n * contain the specified annotations, and it will not be searched.\r\n * @param annotations the annotations to include\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n * @see #from(Annotation...)\r\n * @see #from(AnnotatedElement)\r\n */\r\nstatic MergedAnnotations from(Object source, Annotation... annotations) {\r\n    return from(source, annotations, RepeatableContainers.standardRepeatables());\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param source the source for the annotations. This source is used only\r\n * for information and logging. It does not need to <em>actually</em>\r\n * contain the specified annotations, and it will not be searched.\r\n * @param annotations the annotations to include\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * meta-annotations\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n */\r\nstatic MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers) {\r\n    return from(source, annotations, repeatableContainers, AnnotationFilter.PLAIN);\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param source the source for the annotations. This source is used only\r\n * for information and logging. It does not need to <em>actually</em>\r\n * contain the specified annotations, and it will not be searched.\r\n * @param annotations the annotations to include\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * meta-annotations\r\n * @param annotationFilter an annotation filter used to restrict the\r\n * annotations considered\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n */\r\nstatic MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n    Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n    return TypeMappedAnnotations.from(source, annotations, repeatableContainers, annotationFilter);\r\n}\n/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * collection of directly present annotations. This method allows a\r\n * {@code MergedAnnotations} instance to be created from annotations that\r\n * are not necessarily loaded using reflection. The provided annotations\r\n * must all be {@link MergedAnnotation#isDirectlyPresent() directly present}\r\n * and must have an {@link MergedAnnotation#getAggregateIndex() aggregate\r\n * index} of {@code 0}.\r\n * <p>The resulting {@code MergedAnnotations} instance will contain both the\r\n * specified annotations and any meta-annotations that can be read using\r\n * reflection.\r\n * @param annotations the annotations to include\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n * @see MergedAnnotation#of(ClassLoader, Object, Class, java.util.Map)\r\n */\r\nstatic MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {\r\n    return MergedAnnotationsCollection.of(annotations);\r\n}\n/**\r\n * Find merged annotations using the supplied {@link SearchStrategy} and a\r\n * fluent API for configuring and performing the search.\r\n * <p>See {@link Search} for details.\r\n * @param searchStrategy the search strategy to use\r\n * @return a {@code Search} instance to perform the search\r\n * @since 6.0\r\n */\r\nstatic Search search(SearchStrategy searchStrategy) {\r\n    Assert.notNull(searchStrategy, \"SearchStrategy must not be null\");\r\n    return new Search(searchStrategy);\r\n}\n/**\r\n * Fluent API for configuring the search algorithm used in the\r\n * {@link MergedAnnotations} model and performing a search.\r\n *\r\n * <ul>\r\n * <li>Configuration starts with an invocation of\r\n * {@link MergedAnnotations#search(SearchStrategy)}, specifying which\r\n * {@link SearchStrategy} to use.</li>\r\n * <li>Optional configuration can be provided via one of the {@code with*()}\r\n * methods.</li>\r\n * <li>The actual search is performed by invoking {@link #from(AnnotatedElement)}\r\n * with the source element from which the search should begin.</li>\r\n * </ul>\r\n *\r\n * <p>For example, the following performs a search on {@code MyClass} within\r\n * the entire type hierarchy of that class while ignoring repeatable annotations.\r\n *\r\n * <pre class=\"code\">\r\n * MergedAnnotations mergedAnnotations =\r\n *     MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\r\n *         .withRepeatableContainers(RepeatableContainers.none())\r\n *         .from(MyClass.class);\r\n * </pre>\r\n *\r\n * <p>If you wish to reuse search configuration to perform the same type of search\r\n * on multiple elements, you can save the {@code Search} instance as demonstrated\r\n * in the following example.\r\n *\r\n * <pre class=\"code\">\r\n * Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\r\n *                     .withRepeatableContainers(RepeatableContainers.none());\r\n *\r\n * MergedAnnotations mergedAnnotations = search.from(MyClass.class);\r\n * // do something with the MergedAnnotations for MyClass\r\n * mergedAnnotations = search.from(AnotherClass.class);\r\n * // do something with the MergedAnnotations for AnotherClass\r\n * </pre>\r\n *\r\n * @since 6.0\r\n */\r\nfinal class Search {\r\n\r\n    static final Predicate<Class<?>> always = clazz -> true;\r\n\r\n    static final Predicate<Class<?>> never = clazz -> false;\r\n\r\n    private final SearchStrategy searchStrategy;\r\n\r\n    private Predicate<Class<?>> searchEnclosingClass = never;\r\n\r\n    private RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables();\r\n\r\n    private AnnotationFilter annotationFilter = AnnotationFilter.PLAIN;\r\n\r\n    private Search(SearchStrategy searchStrategy) {\r\n        this.searchStrategy = searchStrategy;\r\n    }\r\n\r\n    /**\r\n     * Configure whether the search algorithm should search on\r\n     * {@linkplain Class#getEnclosingClass() enclosing classes}.\r\n     * <p>This feature is disabled by default and is only supported when using\r\n     * {@link SearchStrategy#TYPE_HIERARCHY}.\r\n     * <p>Enclosing classes will be recursively searched if the supplied\r\n     * {@link Predicate} evaluates to {@code true}. Typically, the predicate\r\n     * will be used to differentiate between <em>inner classes</em> and\r\n     * {@code static} nested classes.\r\n     * <ul>\r\n     * <li>To limit the enclosing class search to inner classes, provide\r\n     * {@link org.springframework.util.ClassUtils#isInnerClass(Class) ClassUtils::isInnerClass}\r\n     * as the predicate.</li>\r\n     * <li>To limit the enclosing class search to static nested classes, provide\r\n     * {@link org.springframework.util.ClassUtils#isStaticClass(Class) ClassUtils::isStaticClass}\r\n     * as the predicate.</li>\r\n     * <li>To force the algorithm to always search enclosing classes, provide\r\n     * {@code clazz -> true} as the predicate.</li>\r\n     * <li>For any other use case, provide a custom predicate.</li>\r\n     * </ul>\r\n     * <p><strong>WARNING:</strong> if the supplied predicate always evaluates\r\n     * to {@code true}, the algorithm will search recursively for annotations\r\n     * on an enclosing class for any source type, regardless whether the source\r\n     * type is an <em>inner class</em>, a {@code static} nested class, or a\r\n     * nested interface. Thus, it may find more annotations than you would expect.\r\n     * @param searchEnclosingClass a predicate which evaluates to {@code true}\r\n     * if a search should be performed on the enclosing class of the class\r\n     * supplied to the predicate\r\n     * @return this {@code Search} instance for chained method invocations\r\n     * @see SearchStrategy#TYPE_HIERARCHY\r\n     * @see #withRepeatableContainers(RepeatableContainers)\r\n     * @see #withAnnotationFilter(AnnotationFilter)\r\n     * @see #from(AnnotatedElement)\r\n     */\r\n    public Search withEnclosingClasses(Predicate<Class<?>> searchEnclosingClass) {\r\n        Assert.notNull(searchEnclosingClass, \"Predicate must not be null\");\r\n        Assert.state(this.searchStrategy == SearchStrategy.TYPE_HIERARCHY, \"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\r\n        this.searchEnclosingClass = searchEnclosingClass;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configure the {@link RepeatableContainers} to use.\r\n     * <p>Defaults to {@link RepeatableContainers#standardRepeatables()}.\r\n     * @param repeatableContainers the repeatable containers that may be used\r\n     * by annotations or meta-annotations\r\n     * @return this {@code Search} instance for chained method invocations\r\n     * @see #withAnnotationFilter(AnnotationFilter)\r\n     * @see #from(AnnotatedElement)\r\n     */\r\n    public Search withRepeatableContainers(RepeatableContainers repeatableContainers) {\r\n        Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n        this.repeatableContainers = repeatableContainers;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configure the {@link AnnotationFilter} to use.\r\n     * <p>Defaults to {@link AnnotationFilter#PLAIN}.\r\n     * @param annotationFilter an annotation filter used to restrict the\r\n     * annotations considered\r\n     * @return this {@code Search} instance for chained method invocations\r\n     * @see #withRepeatableContainers(RepeatableContainers)\r\n     * @see #from(AnnotatedElement)\r\n     */\r\n    public Search withAnnotationFilter(AnnotationFilter annotationFilter) {\r\n        Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n        this.annotationFilter = annotationFilter;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Perform a search for merged annotations beginning with the supplied\r\n     * {@link AnnotatedElement} (such as a {@link Class} or {@link Method}),\r\n     * using the configuration in this {@code Search} instance.\r\n     * @param element the source element\r\n     * @return a new {@link MergedAnnotations} instance containing all\r\n     * annotations and meta-annotations from the specified element and,\r\n     * depending on the {@link SearchStrategy}, related inherited elements\r\n     * @see #withEnclosingClasses(Predicate)\r\n     * @see #withRepeatableContainers(RepeatableContainers)\r\n     * @see #withAnnotationFilter(AnnotationFilter)\r\n     * @see MergedAnnotations#from(AnnotatedElement, SearchStrategy, RepeatableContainers, AnnotationFilter)\r\n     */\r\n    public MergedAnnotations from(AnnotatedElement element) {\r\n        return MergedAnnotations.from(element, this.searchStrategy, this.searchEnclosingClass, this.repeatableContainers, this.annotationFilter);\r\n    }\r\n}\n/**\r\n * Search strategies supported by {@link MergedAnnotations#search(SearchStrategy)}\r\n * as well as {@link MergedAnnotations#from(AnnotatedElement, SearchStrategy)}\r\n * and variants of that method.\r\n *\r\n * <p>Each strategy creates a different set of aggregates that will be\r\n * combined to create the final {@link MergedAnnotations}.\r\n */\r\nenum SearchStrategy {\r\n\r\n    /**\r\n     * Find only directly declared annotations, without considering\r\n     * {@link Inherited @Inherited} annotations and without searching\r\n     * superclasses or implemented interfaces.\r\n     */\r\n    DIRECT,\r\n    /**\r\n     * Find all directly declared annotations as well as any\r\n     * {@link Inherited @Inherited} superclass annotations.\r\n     * <p>This strategy is only really useful when used with {@link Class}\r\n     * types since the {@link Inherited @Inherited} annotation is ignored for\r\n     * all other {@linkplain AnnotatedElement annotated elements}.\r\n     * <p>This strategy does not search implemented interfaces.\r\n     */\r\n    INHERITED_ANNOTATIONS,\r\n    /**\r\n     * Find all directly declared and superclass annotations.\r\n     * <p>This strategy is similar to {@link #INHERITED_ANNOTATIONS} except\r\n     * the annotations do not need to be meta-annotated with\r\n     * {@link Inherited @Inherited}.\r\n     * <p>This strategy does not search implemented interfaces.\r\n     */\r\n    SUPERCLASS,\r\n    /**\r\n     * Perform a full search of the entire type hierarchy, including\r\n     * superclasses and implemented interfaces.\r\n     * <p>When combined with {@link Search#withEnclosingClasses(Predicate)},\r\n     * {@linkplain Class#getEnclosingClass() enclosing classes} will also be\r\n     * recursively searched if the supplied {@link Predicate} evaluates to\r\n     * {@code true}.\r\n     * <p>Superclass and enclosing class annotations do not need to be\r\n     * meta-annotated with {@link Inherited @Inherited}.\r\n     */\r\n    TYPE_HIERARCHY\r\n}",
    "comment": "\n * Provides access to a collection of merged annotations, usually obtained\n * from a source such as a {@link Class} or {@link Method}.\n *\n * <p>Each merged annotation represents a view where the attribute values may be\n * \"merged\" from different source values, typically:\n *\n * <ul>\n * <li>Explicit and Implicit {@link AliasFor @AliasFor} declarations on one or\n * more attributes within the annotation</li>\n * <li>Explicit {@link AliasFor @AliasFor} declarations for a meta-annotation</li>\n * <li>Convention based attribute aliases for a meta-annotation</li>\n * <li>From a meta-annotation declaration</li>\n * </ul>\n *\n * <p>For example, a {@code @PostMapping} annotation might be defined as follows:\n *\n * <pre class=\"code\">\n * &#064;Retention(RetentionPolicy.RUNTIME)\n * &#064;RequestMapping(method = RequestMethod.POST)\n * public &#064;interface PostMapping {\n *\n *     &#064;AliasFor(attribute = \"path\")\n *     String[] value() default {};\n *\n *     &#064;AliasFor(attribute = \"value\")\n *     String[] path() default {};\n * }\n * </pre>\n *\n * <p>If a method is annotated with {@code @PostMapping(\"/home\")} it will contain\n * merged annotations for both {@code @PostMapping} and the meta-annotation\n * {@code @RequestMapping}. The merged view of the {@code @RequestMapping}\n * annotation will contain the following attributes:\n *\n * <p><table border=\"1\">\n * <tr>\n * <th>Name</th>\n * <th>Value</th>\n * <th>Source</th>\n * </tr>\n * <tr>\n * <td>value</td>\n * <td>\"/home\"</td>\n * <td>Declared in {@code @PostMapping}</td>\n * </tr>\n * <tr>\n * <td>path</td>\n * <td>\"/home\"</td>\n * <td>Explicit {@code @AliasFor}</td>\n * </tr>\n * <tr>\n * <td>method</td>\n * <td>RequestMethod.POST</td>\n * <td>Declared in meta-annotation</td>\n * </tr>\n * </table>\n *\n * <p>{@code MergedAnnotations} can be obtained {@linkplain #from(AnnotatedElement)\n * from} any Java {@link AnnotatedElement}. They may also be used for sources that\n * don't use reflection (such as those that directly parse bytecode).\n *\n * <p>Different {@linkplain SearchStrategy search strategies} can be used to locate\n * related source elements that contain the annotations to be aggregated. For\n * example, the following code uses {@link SearchStrategy#TYPE_HIERARCHY} to\n * search for annotations on {@code MyClass} as well as in superclasses and implemented\n * interfaces.\n *\n * <pre class=\"code\">\n * MergedAnnotations mergedAnnotations =\n *     MergedAnnotations.search(TYPE_HIERARCHY).from(MyClass.class);\n * </pre>\n *\n * <p>From a {@code MergedAnnotations} instance you can either\n * {@linkplain #get(String) get} a single annotation, or {@linkplain #stream()\n * stream all annotations} or just those that match {@linkplain #stream(String)\n * a specific type}. You can also quickly tell if an annotation\n * {@linkplain #isPresent(String) is present}.\n *\n * <p>Here are some typical examples:\n *\n * <pre class=\"code\">\n * // is an annotation present or meta-present?\n * mergedAnnotations.isPresent(ExampleAnnotation.class);\n *\n * // get the merged \"value\" attribute of ExampleAnnotation (either directly or\n * // meta-present)\n * mergedAnnotations.get(ExampleAnnotation.class).getString(\"value\");\n *\n * // get all meta-annotations but no directly present annotations\n * mergedAnnotations.stream().filter(MergedAnnotation::isMetaPresent);\n *\n * // get all ExampleAnnotation declarations (including any meta-annotations) and\n * // print the merged \"value\" attributes\n * mergedAnnotations.stream(ExampleAnnotation.class)\n *     .map(mergedAnnotation -&gt; mergedAnnotation.getString(\"value\"))\n *     .forEach(System.out::println);\n * </pre>\n *\n * <p><b>NOTE: The {@code MergedAnnotations} API and its underlying model have\n * been designed for composable annotations in Spring's common component model,\n * with a focus on attribute aliasing and meta-annotation relationships.</b>\n * There is no support for retrieving plain Java annotations with this API;\n * please use standard Java reflection or Spring's {@link AnnotationUtils}\n * for simple annotation retrieval purposes.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n * @see MergedAnnotation\n * @see MergedAnnotationCollectors\n * @see MergedAnnotationPredicates\n * @see MergedAnnotationSelectors\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#isPresent(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified annotation type is either directly present or\r\n * meta-present.\r\n * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\r\n * @param annotationType the annotation type to check\r\n * @return {@code true} if the annotation is present\r\n */\r\n<A extends Annotation> boolean isPresent(Class<A> annotationType);",
    "comment": "\n\t * Determine if the specified annotation type is either directly present or\n\t * meta-present.\n\t * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\n\t * @param annotationType the annotation type to check\n\t * @return {@code true} if the annotation is present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#isPresent(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified annotation type is either directly present or\r\n * meta-present.\r\n * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to check\r\n * @return {@code true} if the annotation is present\r\n */\r\nboolean isPresent(String annotationType);",
    "comment": "\n\t * Determine if the specified annotation type is either directly present or\n\t * meta-present.\n\t * <p>Equivalent to calling {@code get(annotationType).isPresent()}.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to check\n\t * @return {@code true} if the annotation is present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#isDirectlyPresent(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified annotation type is directly present.\r\n * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\r\n * @param annotationType the annotation type to check\r\n * @return {@code true} if the annotation is directly present\r\n */\r\n<A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType);",
    "comment": "\n\t * Determine if the specified annotation type is directly present.\n\t * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\n\t * @param annotationType the annotation type to check\n\t * @return {@code true} if the annotation is directly present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#isDirectlyPresent(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the specified annotation type is directly present.\r\n * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to check\r\n * @return {@code true} if the annotation is directly present\r\n */\r\nboolean isDirectlyPresent(String annotationType);",
    "comment": "\n\t * Determine if the specified annotation type is directly present.\n\t * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to check\n\t * @return {@code true} if the annotation is directly present\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#get(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the annotation type to get\r\n * @return a {@link MergedAnnotation} instance\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType);",
    "comment": "\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the annotation type to get\n\t * @return a {@link MergedAnnotation} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#get(Class<A>,Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the annotation type to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate);",
    "comment": "\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the annotation type to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#get(Class<A>,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get a matching annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the annotation type to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @param selector a selector used to choose the most appropriate annotation\r\n * within an aggregate, or {@code null} to select the\r\n * {@linkplain MergedAnnotationSelectors#nearest() nearest}\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n * @see MergedAnnotationSelectors\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector);",
    "comment": "\n\t * Get a matching annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the annotation type to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @param selector a selector used to choose the most appropriate annotation\n\t * within an aggregate, or {@code null} to select the\n\t * {@linkplain MergedAnnotationSelectors#nearest() nearest}\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t * @see MergedAnnotationSelectors\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#get(String)",
    "entityType": "method",
    "code": "/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to get\r\n * @return a {@link MergedAnnotation} instance\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(String annotationType);",
    "comment": "\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to get\n\t * @return a {@link MergedAnnotation} instance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#get(String,Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "/**\r\n * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\r\n * annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate);",
    "comment": "\n\t * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching\n\t * annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#get(String,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "/**\r\n * Get a matching annotation or meta-annotation of the specified type, or\r\n * {@link MergedAnnotation#missing()} if none is present.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to get\r\n * @param predicate a predicate that must match, or {@code null} if only\r\n * type matching is required\r\n * @param selector a selector used to choose the most appropriate annotation\r\n * within an aggregate, or {@code null} to select the\r\n * {@linkplain MergedAnnotationSelectors#nearest() nearest}\r\n * @return a {@link MergedAnnotation} instance\r\n * @see MergedAnnotationPredicates\r\n * @see MergedAnnotationSelectors\r\n */\r\n<A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector);",
    "comment": "\n\t * Get a matching annotation or meta-annotation of the specified type, or\n\t * {@link MergedAnnotation#missing()} if none is present.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to get\n\t * @param predicate a predicate that must match, or {@code null} if only\n\t * type matching is required\n\t * @param selector a selector used to choose the most appropriate annotation\n\t * within an aggregate, or {@code null} to select the\n\t * {@linkplain MergedAnnotationSelectors#nearest() nearest}\n\t * @return a {@link MergedAnnotation} instance\n\t * @see MergedAnnotationPredicates\n\t * @see MergedAnnotationSelectors\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#stream(Class<A>)",
    "entityType": "method",
    "code": "/**\r\n * Stream all annotations and meta-annotations that match the specified\r\n * type.\r\n * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\r\n * @param annotationType the annotation type to match\r\n * @return a stream of matching annotations\r\n */\r\n<A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType);",
    "comment": "\n\t * Stream all annotations and meta-annotations that match the specified\n\t * type.\n\t * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\n\t * @param annotationType the annotation type to match\n\t * @return a stream of matching annotations\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#stream(String)",
    "entityType": "method",
    "code": "/**\r\n * Stream all annotations and meta-annotations that match the specified\r\n * type.\r\n * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\r\n * @param annotationType the fully qualified class name of the annotation type\r\n * to match\r\n * @return a stream of matching annotations\r\n */\r\n<A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType);",
    "comment": "\n\t * Stream all annotations and meta-annotations that match the specified\n\t * type.\n\t * <p>The resulting stream follows the same ordering rules as {@link #stream()}.\n\t * @param annotationType the fully qualified class name of the annotation type\n\t * to match\n\t * @return a stream of matching annotations\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#stream()",
    "entityType": "method",
    "code": "/**\r\n * Stream all annotations and meta-annotations contained in this collection.\r\n * <p>The resulting stream is ordered first by the\r\n * {@linkplain MergedAnnotation#getAggregateIndex() aggregate index} and then\r\n * by the annotation distance (with the closest annotations first). This ordering\r\n * means that, for most use-cases, the most suitable annotations appear\r\n * earliest in the stream.\r\n * @return a stream of annotations\r\n */\r\nStream<MergedAnnotation<Annotation>> stream();",
    "comment": "\n\t * Stream all annotations and meta-annotations contained in this collection.\n\t * <p>The resulting stream is ordered first by the\n\t * {@linkplain MergedAnnotation#getAggregateIndex() aggregate index} and then\n\t * by the annotation distance (with the closest annotations first). This ordering\n\t * means that, for most use-cases, the most suitable annotations appear\n\t * earliest in the stream.\n\t * @return a stream of annotations\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element.\r\n * <p>The resulting instance will not include any inherited annotations. If\r\n * you want to include those as well you should use\r\n * {@link #from(AnnotatedElement, SearchStrategy)} with an appropriate\r\n * {@link SearchStrategy}.\r\n * @param element the source element\r\n * @return a {@code MergedAnnotations} instance containing the element's\r\n * annotations\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element) {\r\n    return from(element, SearchStrategy.DIRECT);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element.\n\t * <p>The resulting instance will not include any inherited annotations. If\n\t * you want to include those as well you should use\n\t * {@link #from(AnnotatedElement, SearchStrategy)} with an appropriate\n\t * {@link SearchStrategy}.\n\t * @param element the source element\n\t * @return a {@code MergedAnnotations} instance containing the element's\n\t * annotations\n\t * @see #search(SearchStrategy)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(AnnotatedElement,SearchStrategy)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements.\r\n * @param element the source element\r\n * @param searchStrategy the search strategy to use\r\n * @return a {@code MergedAnnotations} instance containing the merged\r\n * element annotations\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy) {\r\n    return from(element, searchStrategy, RepeatableContainers.standardRepeatables());\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element and,\n\t * depending on the {@link SearchStrategy}, related inherited elements.\n\t * @param element the source element\n\t * @param searchStrategy the search strategy to use\n\t * @return a {@code MergedAnnotations} instance containing the merged\n\t * element annotations\n\t * @see #search(SearchStrategy)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(AnnotatedElement,SearchStrategy,RepeatableContainers)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements.\r\n * @param element the source element\r\n * @param searchStrategy the search strategy to use\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the element annotations or the meta-annotations\r\n * @return a {@code MergedAnnotations} instance containing the merged\r\n * element annotations\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, RepeatableContainers repeatableContainers) {\r\n    return from(element, searchStrategy, repeatableContainers, AnnotationFilter.PLAIN);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element and,\n\t * depending on the {@link SearchStrategy}, related inherited elements.\n\t * @param element the source element\n\t * @param searchStrategy the search strategy to use\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the element annotations or the meta-annotations\n\t * @return a {@code MergedAnnotations} instance containing the merged\n\t * element annotations\n\t * @see #search(SearchStrategy)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(AnnotatedElement,SearchStrategy,RepeatableContainers,AnnotationFilter)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements.\r\n * @param element the source element\r\n * @param searchStrategy the search strategy to use\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * the element annotations or the meta-annotations\r\n * @param annotationFilter an annotation filter used to restrict the\r\n * annotations considered\r\n * @return a {@code MergedAnnotations} instance containing the merged\r\n * annotations for the supplied element\r\n * @see #search(SearchStrategy)\r\n */\r\nstatic MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    return from(element, searchStrategy, Search.never, repeatableContainers, annotationFilter);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance containing all\n\t * annotations and meta-annotations from the specified element and,\n\t * depending on the {@link SearchStrategy}, related inherited elements.\n\t * @param element the source element\n\t * @param searchStrategy the search strategy to use\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * the element annotations or the meta-annotations\n\t * @param annotationFilter an annotation filter used to restrict the\n\t * annotations considered\n\t * @return a {@code MergedAnnotations} instance containing the merged\n\t * annotations for the supplied element\n\t * @see #search(SearchStrategy)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(AnnotatedElement,SearchStrategy,Predicate<Class<?>>,RepeatableContainers,AnnotationFilter)",
    "entityType": "method",
    "code": "private static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy, Predicate<Class<?>> searchEnclosingClass, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    Assert.notNull(element, \"AnnotatedElement must not be null\");\r\n    Assert.notNull(searchStrategy, \"SearchStrategy must not be null\");\r\n    Assert.notNull(searchEnclosingClass, \"Predicate must not be null\");\r\n    Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n    Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n    return TypeMappedAnnotations.from(element, searchStrategy, searchEnclosingClass, repeatableContainers, annotationFilter);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param annotations the annotations to include\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n * @see #from(Object, Annotation...)\r\n */\r\nstatic MergedAnnotations from(Annotation... annotations) {\r\n    return from(annotations, annotations);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param annotations the annotations to include\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t * @see #from(Object, Annotation...)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(Object,Annotation)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param source the source for the annotations. This source is used only\r\n * for information and logging. It does not need to <em>actually</em>\r\n * contain the specified annotations, and it will not be searched.\r\n * @param annotations the annotations to include\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n * @see #from(Annotation...)\r\n * @see #from(AnnotatedElement)\r\n */\r\nstatic MergedAnnotations from(Object source, Annotation... annotations) {\r\n    return from(source, annotations, RepeatableContainers.standardRepeatables());\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param source the source for the annotations. This source is used only\n\t * for information and logging. It does not need to <em>actually</em>\n\t * contain the specified annotations, and it will not be searched.\n\t * @param annotations the annotations to include\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t * @see #from(Annotation...)\n\t * @see #from(AnnotatedElement)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(Object,Annotation[],RepeatableContainers)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param source the source for the annotations. This source is used only\r\n * for information and logging. It does not need to <em>actually</em>\r\n * contain the specified annotations, and it will not be searched.\r\n * @param annotations the annotations to include\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * meta-annotations\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n */\r\nstatic MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers) {\r\n    return from(source, annotations, repeatableContainers, AnnotationFilter.PLAIN);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param source the source for the annotations. This source is used only\n\t * for information and logging. It does not need to <em>actually</em>\n\t * contain the specified annotations, and it will not be searched.\n\t * @param annotations the annotations to include\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * meta-annotations\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#from(Object,Annotation[],RepeatableContainers,AnnotationFilter)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * annotations.\r\n * @param source the source for the annotations. This source is used only\r\n * for information and logging. It does not need to <em>actually</em>\r\n * contain the specified annotations, and it will not be searched.\r\n * @param annotations the annotations to include\r\n * @param repeatableContainers the repeatable containers that may be used by\r\n * meta-annotations\r\n * @param annotationFilter an annotation filter used to restrict the\r\n * annotations considered\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n */\r\nstatic MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {\r\n    Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n    Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n    return TypeMappedAnnotations.from(source, annotations, repeatableContainers, annotationFilter);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * annotations.\n\t * @param source the source for the annotations. This source is used only\n\t * for information and logging. It does not need to <em>actually</em>\n\t * contain the specified annotations, and it will not be searched.\n\t * @param annotations the annotations to include\n\t * @param repeatableContainers the repeatable containers that may be used by\n\t * meta-annotations\n\t * @param annotationFilter an annotation filter used to restrict the\n\t * annotations considered\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#of(Collection<MergedAnnotation<?>>)",
    "entityType": "method",
    "code": "/**\r\n * Create a new {@link MergedAnnotations} instance from the specified\r\n * collection of directly present annotations. This method allows a\r\n * {@code MergedAnnotations} instance to be created from annotations that\r\n * are not necessarily loaded using reflection. The provided annotations\r\n * must all be {@link MergedAnnotation#isDirectlyPresent() directly present}\r\n * and must have an {@link MergedAnnotation#getAggregateIndex() aggregate\r\n * index} of {@code 0}.\r\n * <p>The resulting {@code MergedAnnotations} instance will contain both the\r\n * specified annotations and any meta-annotations that can be read using\r\n * reflection.\r\n * @param annotations the annotations to include\r\n * @return a {@code MergedAnnotations} instance containing the annotations\r\n * @see MergedAnnotation#of(ClassLoader, Object, Class, java.util.Map)\r\n */\r\nstatic MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {\r\n    return MergedAnnotationsCollection.of(annotations);\r\n}",
    "comment": "\n\t * Create a new {@link MergedAnnotations} instance from the specified\n\t * collection of directly present annotations. This method allows a\n\t * {@code MergedAnnotations} instance to be created from annotations that\n\t * are not necessarily loaded using reflection. The provided annotations\n\t * must all be {@link MergedAnnotation#isDirectlyPresent() directly present}\n\t * and must have an {@link MergedAnnotation#getAggregateIndex() aggregate\n\t * index} of {@code 0}.\n\t * <p>The resulting {@code MergedAnnotations} instance will contain both the\n\t * specified annotations and any meta-annotations that can be read using\n\t * reflection.\n\t * @param annotations the annotations to include\n\t * @return a {@code MergedAnnotations} instance containing the annotations\n\t * @see MergedAnnotation#of(ClassLoader, Object, Class, java.util.Map)\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotations#search(SearchStrategy)",
    "entityType": "method",
    "code": "/**\r\n * Find merged annotations using the supplied {@link SearchStrategy} and a\r\n * fluent API for configuring and performing the search.\r\n * <p>See {@link Search} for details.\r\n * @param searchStrategy the search strategy to use\r\n * @return a {@code Search} instance to perform the search\r\n * @since 6.0\r\n */\r\nstatic Search search(SearchStrategy searchStrategy) {\r\n    Assert.notNull(searchStrategy, \"SearchStrategy must not be null\");\r\n    return new Search(searchStrategy);\r\n}",
    "comment": "\n\t * Find merged annotations using the supplied {@link SearchStrategy} and a\n\t * fluent API for configuring and performing the search.\n\t * <p>See {@link Search} for details.\n\t * @param searchStrategy the search strategy to use\n\t * @return a {@code Search} instance to perform the search\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Search",
    "entityType": "class",
    "code": "static final Predicate<Class<?>> always = clazz -> true;\nstatic final Predicate<Class<?>> never = clazz -> false;\nprivate final SearchStrategy searchStrategy;\nprivate Predicate<Class<?>> searchEnclosingClass = never;\nprivate RepeatableContainers repeatableContainers = RepeatableContainers.standardRepeatables();\nprivate AnnotationFilter annotationFilter = AnnotationFilter.PLAIN;\nprivate Search(SearchStrategy searchStrategy) {\r\n    this.searchStrategy = searchStrategy;\r\n}\n/**\r\n * Configure whether the search algorithm should search on\r\n * {@linkplain Class#getEnclosingClass() enclosing classes}.\r\n * <p>This feature is disabled by default and is only supported when using\r\n * {@link SearchStrategy#TYPE_HIERARCHY}.\r\n * <p>Enclosing classes will be recursively searched if the supplied\r\n * {@link Predicate} evaluates to {@code true}. Typically, the predicate\r\n * will be used to differentiate between <em>inner classes</em> and\r\n * {@code static} nested classes.\r\n * <ul>\r\n * <li>To limit the enclosing class search to inner classes, provide\r\n * {@link org.springframework.util.ClassUtils#isInnerClass(Class) ClassUtils::isInnerClass}\r\n * as the predicate.</li>\r\n * <li>To limit the enclosing class search to static nested classes, provide\r\n * {@link org.springframework.util.ClassUtils#isStaticClass(Class) ClassUtils::isStaticClass}\r\n * as the predicate.</li>\r\n * <li>To force the algorithm to always search enclosing classes, provide\r\n * {@code clazz -> true} as the predicate.</li>\r\n * <li>For any other use case, provide a custom predicate.</li>\r\n * </ul>\r\n * <p><strong>WARNING:</strong> if the supplied predicate always evaluates\r\n * to {@code true}, the algorithm will search recursively for annotations\r\n * on an enclosing class for any source type, regardless whether the source\r\n * type is an <em>inner class</em>, a {@code static} nested class, or a\r\n * nested interface. Thus, it may find more annotations than you would expect.\r\n * @param searchEnclosingClass a predicate which evaluates to {@code true}\r\n * if a search should be performed on the enclosing class of the class\r\n * supplied to the predicate\r\n * @return this {@code Search} instance for chained method invocations\r\n * @see SearchStrategy#TYPE_HIERARCHY\r\n * @see #withRepeatableContainers(RepeatableContainers)\r\n * @see #withAnnotationFilter(AnnotationFilter)\r\n * @see #from(AnnotatedElement)\r\n */\r\npublic Search withEnclosingClasses(Predicate<Class<?>> searchEnclosingClass) {\r\n    Assert.notNull(searchEnclosingClass, \"Predicate must not be null\");\r\n    Assert.state(this.searchStrategy == SearchStrategy.TYPE_HIERARCHY, \"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\r\n    this.searchEnclosingClass = searchEnclosingClass;\r\n    return this;\r\n}\n/**\r\n * Configure the {@link RepeatableContainers} to use.\r\n * <p>Defaults to {@link RepeatableContainers#standardRepeatables()}.\r\n * @param repeatableContainers the repeatable containers that may be used\r\n * by annotations or meta-annotations\r\n * @return this {@code Search} instance for chained method invocations\r\n * @see #withAnnotationFilter(AnnotationFilter)\r\n * @see #from(AnnotatedElement)\r\n */\r\npublic Search withRepeatableContainers(RepeatableContainers repeatableContainers) {\r\n    Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n    this.repeatableContainers = repeatableContainers;\r\n    return this;\r\n}\n/**\r\n * Configure the {@link AnnotationFilter} to use.\r\n * <p>Defaults to {@link AnnotationFilter#PLAIN}.\r\n * @param annotationFilter an annotation filter used to restrict the\r\n * annotations considered\r\n * @return this {@code Search} instance for chained method invocations\r\n * @see #withRepeatableContainers(RepeatableContainers)\r\n * @see #from(AnnotatedElement)\r\n */\r\npublic Search withAnnotationFilter(AnnotationFilter annotationFilter) {\r\n    Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n    this.annotationFilter = annotationFilter;\r\n    return this;\r\n}\n/**\r\n * Perform a search for merged annotations beginning with the supplied\r\n * {@link AnnotatedElement} (such as a {@link Class} or {@link Method}),\r\n * using the configuration in this {@code Search} instance.\r\n * @param element the source element\r\n * @return a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements\r\n * @see #withEnclosingClasses(Predicate)\r\n * @see #withRepeatableContainers(RepeatableContainers)\r\n * @see #withAnnotationFilter(AnnotationFilter)\r\n * @see MergedAnnotations#from(AnnotatedElement, SearchStrategy, RepeatableContainers, AnnotationFilter)\r\n */\r\npublic MergedAnnotations from(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, this.searchStrategy, this.searchEnclosingClass, this.repeatableContainers, this.annotationFilter);\r\n}",
    "comment": "\n\t * Fluent API for configuring the search algorithm used in the\n\t * {@link MergedAnnotations} model and performing a search.\n\t *\n\t * <ul>\n\t * <li>Configuration starts with an invocation of\n\t * {@link MergedAnnotations#search(SearchStrategy)}, specifying which\n\t * {@link SearchStrategy} to use.</li>\n\t * <li>Optional configuration can be provided via one of the {@code with*()}\n\t * methods.</li>\n\t * <li>The actual search is performed by invoking {@link #from(AnnotatedElement)}\n\t * with the source element from which the search should begin.</li>\n\t * </ul>\n\t *\n\t * <p>For example, the following performs a search on {@code MyClass} within\n\t * the entire type hierarchy of that class while ignoring repeatable annotations.\n\t *\n\t * <pre class=\"code\">\n\t * MergedAnnotations mergedAnnotations =\n\t *     MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t *         .withRepeatableContainers(RepeatableContainers.none())\n\t *         .from(MyClass.class);\n\t * </pre>\n\t *\n\t * <p>If you wish to reuse search configuration to perform the same type of search\n\t * on multiple elements, you can save the {@code Search} instance as demonstrated\n\t * in the following example.\n\t *\n\t * <pre class=\"code\">\n\t * Search search = MergedAnnotations.search(SearchStrategy.TYPE_HIERARCHY)\n\t *                     .withRepeatableContainers(RepeatableContainers.none());\n\t *\n\t * MergedAnnotations mergedAnnotations = search.from(MyClass.class);\n\t * // do something with the MergedAnnotations for MyClass\n\t * mergedAnnotations = search.from(AnotherClass.class);\n\t * // do something with the MergedAnnotations for AnotherClass\n\t * </pre>\n\t *\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Search#withEnclosingClasses(Predicate<Class<?>>)",
    "entityType": "method",
    "code": "/**\r\n * Configure whether the search algorithm should search on\r\n * {@linkplain Class#getEnclosingClass() enclosing classes}.\r\n * <p>This feature is disabled by default and is only supported when using\r\n * {@link SearchStrategy#TYPE_HIERARCHY}.\r\n * <p>Enclosing classes will be recursively searched if the supplied\r\n * {@link Predicate} evaluates to {@code true}. Typically, the predicate\r\n * will be used to differentiate between <em>inner classes</em> and\r\n * {@code static} nested classes.\r\n * <ul>\r\n * <li>To limit the enclosing class search to inner classes, provide\r\n * {@link org.springframework.util.ClassUtils#isInnerClass(Class) ClassUtils::isInnerClass}\r\n * as the predicate.</li>\r\n * <li>To limit the enclosing class search to static nested classes, provide\r\n * {@link org.springframework.util.ClassUtils#isStaticClass(Class) ClassUtils::isStaticClass}\r\n * as the predicate.</li>\r\n * <li>To force the algorithm to always search enclosing classes, provide\r\n * {@code clazz -> true} as the predicate.</li>\r\n * <li>For any other use case, provide a custom predicate.</li>\r\n * </ul>\r\n * <p><strong>WARNING:</strong> if the supplied predicate always evaluates\r\n * to {@code true}, the algorithm will search recursively for annotations\r\n * on an enclosing class for any source type, regardless whether the source\r\n * type is an <em>inner class</em>, a {@code static} nested class, or a\r\n * nested interface. Thus, it may find more annotations than you would expect.\r\n * @param searchEnclosingClass a predicate which evaluates to {@code true}\r\n * if a search should be performed on the enclosing class of the class\r\n * supplied to the predicate\r\n * @return this {@code Search} instance for chained method invocations\r\n * @see SearchStrategy#TYPE_HIERARCHY\r\n * @see #withRepeatableContainers(RepeatableContainers)\r\n * @see #withAnnotationFilter(AnnotationFilter)\r\n * @see #from(AnnotatedElement)\r\n */\r\npublic Search withEnclosingClasses(Predicate<Class<?>> searchEnclosingClass) {\r\n    Assert.notNull(searchEnclosingClass, \"Predicate must not be null\");\r\n    Assert.state(this.searchStrategy == SearchStrategy.TYPE_HIERARCHY, \"A custom 'searchEnclosingClass' predicate can only be combined with SearchStrategy.TYPE_HIERARCHY\");\r\n    this.searchEnclosingClass = searchEnclosingClass;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Configure whether the search algorithm should search on\n\t\t * {@linkplain Class#getEnclosingClass() enclosing classes}.\n\t\t * <p>This feature is disabled by default and is only supported when using\n\t\t * {@link SearchStrategy#TYPE_HIERARCHY}.\n\t\t * <p>Enclosing classes will be recursively searched if the supplied\n\t\t * {@link Predicate} evaluates to {@code true}. Typically, the predicate\n\t\t * will be used to differentiate between <em>inner classes</em> and\n\t\t * {@code static} nested classes.\n\t\t * <ul>\n\t\t * <li>To limit the enclosing class search to inner classes, provide\n\t\t * {@link org.springframework.util.ClassUtils#isInnerClass(Class) ClassUtils::isInnerClass}\n\t\t * as the predicate.</li>\n\t\t * <li>To limit the enclosing class search to static nested classes, provide\n\t\t * {@link org.springframework.util.ClassUtils#isStaticClass(Class) ClassUtils::isStaticClass}\n\t\t * as the predicate.</li>\n\t\t * <li>To force the algorithm to always search enclosing classes, provide\n\t\t * {@code clazz -> true} as the predicate.</li>\n\t\t * <li>For any other use case, provide a custom predicate.</li>\n\t\t * </ul>\n\t\t * <p><strong>WARNING:</strong> if the supplied predicate always evaluates\n\t\t * to {@code true}, the algorithm will search recursively for annotations\n\t\t * on an enclosing class for any source type, regardless whether the source\n\t\t * type is an <em>inner class</em>, a {@code static} nested class, or a\n\t\t * nested interface. Thus, it may find more annotations than you would expect.\n\t\t * @param searchEnclosingClass a predicate which evaluates to {@code true}\n\t\t * if a search should be performed on the enclosing class of the class\n\t\t * supplied to the predicate\n\t\t * @return this {@code Search} instance for chained method invocations\n\t\t * @see SearchStrategy#TYPE_HIERARCHY\n\t\t * @see #withRepeatableContainers(RepeatableContainers)\n\t\t * @see #withAnnotationFilter(AnnotationFilter)\n\t\t * @see #from(AnnotatedElement)\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Search#withRepeatableContainers(RepeatableContainers)",
    "entityType": "method",
    "code": "/**\r\n * Configure the {@link RepeatableContainers} to use.\r\n * <p>Defaults to {@link RepeatableContainers#standardRepeatables()}.\r\n * @param repeatableContainers the repeatable containers that may be used\r\n * by annotations or meta-annotations\r\n * @return this {@code Search} instance for chained method invocations\r\n * @see #withAnnotationFilter(AnnotationFilter)\r\n * @see #from(AnnotatedElement)\r\n */\r\npublic Search withRepeatableContainers(RepeatableContainers repeatableContainers) {\r\n    Assert.notNull(repeatableContainers, \"RepeatableContainers must not be null\");\r\n    this.repeatableContainers = repeatableContainers;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Configure the {@link RepeatableContainers} to use.\n\t\t * <p>Defaults to {@link RepeatableContainers#standardRepeatables()}.\n\t\t * @param repeatableContainers the repeatable containers that may be used\n\t\t * by annotations or meta-annotations\n\t\t * @return this {@code Search} instance for chained method invocations\n\t\t * @see #withAnnotationFilter(AnnotationFilter)\n\t\t * @see #from(AnnotatedElement)\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Search#withAnnotationFilter(AnnotationFilter)",
    "entityType": "method",
    "code": "/**\r\n * Configure the {@link AnnotationFilter} to use.\r\n * <p>Defaults to {@link AnnotationFilter#PLAIN}.\r\n * @param annotationFilter an annotation filter used to restrict the\r\n * annotations considered\r\n * @return this {@code Search} instance for chained method invocations\r\n * @see #withRepeatableContainers(RepeatableContainers)\r\n * @see #from(AnnotatedElement)\r\n */\r\npublic Search withAnnotationFilter(AnnotationFilter annotationFilter) {\r\n    Assert.notNull(annotationFilter, \"AnnotationFilter must not be null\");\r\n    this.annotationFilter = annotationFilter;\r\n    return this;\r\n}",
    "comment": "\n\t\t * Configure the {@link AnnotationFilter} to use.\n\t\t * <p>Defaults to {@link AnnotationFilter#PLAIN}.\n\t\t * @param annotationFilter an annotation filter used to restrict the\n\t\t * annotations considered\n\t\t * @return this {@code Search} instance for chained method invocations\n\t\t * @see #withRepeatableContainers(RepeatableContainers)\n\t\t * @see #from(AnnotatedElement)\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Search#from(AnnotatedElement)",
    "entityType": "method",
    "code": "/**\r\n * Perform a search for merged annotations beginning with the supplied\r\n * {@link AnnotatedElement} (such as a {@link Class} or {@link Method}),\r\n * using the configuration in this {@code Search} instance.\r\n * @param element the source element\r\n * @return a new {@link MergedAnnotations} instance containing all\r\n * annotations and meta-annotations from the specified element and,\r\n * depending on the {@link SearchStrategy}, related inherited elements\r\n * @see #withEnclosingClasses(Predicate)\r\n * @see #withRepeatableContainers(RepeatableContainers)\r\n * @see #withAnnotationFilter(AnnotationFilter)\r\n * @see MergedAnnotations#from(AnnotatedElement, SearchStrategy, RepeatableContainers, AnnotationFilter)\r\n */\r\npublic MergedAnnotations from(AnnotatedElement element) {\r\n    return MergedAnnotations.from(element, this.searchStrategy, this.searchEnclosingClass, this.repeatableContainers, this.annotationFilter);\r\n}",
    "comment": "\n\t\t * Perform a search for merged annotations beginning with the supplied\n\t\t * {@link AnnotatedElement} (such as a {@link Class} or {@link Method}),\n\t\t * using the configuration in this {@code Search} instance.\n\t\t * @param element the source element\n\t\t * @return a new {@link MergedAnnotations} instance containing all\n\t\t * annotations and meta-annotations from the specified element and,\n\t\t * depending on the {@link SearchStrategy}, related inherited elements\n\t\t * @see #withEnclosingClasses(Predicate)\n\t\t * @see #withRepeatableContainers(RepeatableContainers)\n\t\t * @see #withAnnotationFilter(AnnotationFilter)\n\t\t * @see MergedAnnotations#from(AnnotatedElement, SearchStrategy, RepeatableContainers, AnnotationFilter)\n\t\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection",
    "entityType": "class",
    "code": "private final MergedAnnotation<?>[] annotations;\nprivate final AnnotationTypeMappings[] mappings;\nprivate MergedAnnotationsCollection(Collection<MergedAnnotation<?>> annotations) {\r\n    Assert.notNull(annotations, \"Annotations must not be null\");\r\n    this.annotations = annotations.toArray(new MergedAnnotation<?>[0]);\r\n    this.mappings = new AnnotationTypeMappings[this.annotations.length];\r\n    for (int i = 0; i < this.annotations.length; i++) {\r\n        MergedAnnotation<?> annotation = this.annotations[i];\r\n        Assert.notNull(annotation, \"Annotation must not be null\");\r\n        Assert.isTrue(annotation.isDirectlyPresent(), \"Annotation must be directly present\");\r\n        Assert.isTrue(annotation.getAggregateIndex() == 0, \"Annotation must have aggregate index of zero\");\r\n        this.mappings[i] = AnnotationTypeMappings.forAnnotationType(annotation.getType());\r\n    }\r\n}\n@Override\r\npublic Iterator<MergedAnnotation<Annotation>> iterator() {\r\n    return Spliterators.iterator(spliterator());\r\n}\n@Override\r\npublic Spliterator<MergedAnnotation<Annotation>> spliterator() {\r\n    return spliterator(null);\r\n}\nprivate <A extends Annotation> Spliterator<MergedAnnotation<A>> spliterator(@Nullable Object annotationType) {\r\n    return new AnnotationsSpliterator<>(annotationType);\r\n}\n@Override\r\npublic <A extends Annotation> boolean isPresent(Class<A> annotationType) {\r\n    return isPresent(annotationType, false);\r\n}\n@Override\r\npublic boolean isPresent(String annotationType) {\r\n    return isPresent(annotationType, false);\r\n}\n@Override\r\npublic <A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType) {\r\n    return isPresent(annotationType, true);\r\n}\n@Override\r\npublic boolean isDirectlyPresent(String annotationType) {\r\n    return isPresent(annotationType, true);\r\n}\nprivate boolean isPresent(Object requiredType, boolean directOnly) {\r\n    for (MergedAnnotation<?> annotation : this.annotations) {\r\n        Class<? extends Annotation> type = annotation.getType();\r\n        if (type == requiredType || type.getName().equals(requiredType)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!directOnly) {\r\n        for (AnnotationTypeMappings mappings : this.mappings) {\r\n            for (int i = 1; i < mappings.size(); i++) {\r\n                AnnotationTypeMapping mapping = mappings.get(i);\r\n                if (isMappingForType(mapping, requiredType)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType) {\r\n    return get(annotationType, null, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    MergedAnnotation<A> result = find(annotationType, predicate, selector);\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType) {\r\n    return get(annotationType, null, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}\n@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    MergedAnnotation<A> result = find(annotationType, predicate, selector);\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate <A extends Annotation> MergedAnnotation<A> find(Object requiredType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    if (selector == null) {\r\n        selector = MergedAnnotationSelectors.nearest();\r\n    }\r\n    MergedAnnotation<A> result = null;\r\n    for (int i = 0; i < this.annotations.length; i++) {\r\n        MergedAnnotation<?> root = this.annotations[i];\r\n        if (root != null) {\r\n            AnnotationTypeMappings mappings = this.mappings[i];\r\n            for (int mappingIndex = 0; mappingIndex < mappings.size(); mappingIndex++) {\r\n                AnnotationTypeMapping mapping = mappings.get(mappingIndex);\r\n                if (!isMappingForType(mapping, requiredType)) {\r\n                    continue;\r\n                }\r\n                MergedAnnotation<A> candidate = (mappingIndex == 0 ? (MergedAnnotation<A>) root : TypeMappedAnnotation.createIfPossible(mapping, root, IntrospectionFailureLogger.INFO));\r\n                if (candidate != null && (predicate == null || predicate.test(candidate))) {\r\n                    if (selector.isBestCandidate(candidate)) {\r\n                        return candidate;\r\n                    }\r\n                    result = (result != null ? selector.select(result, candidate) : candidate);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\n@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType) {\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}\n@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}\n@Override\r\npublic Stream<MergedAnnotation<Annotation>> stream() {\r\n    return StreamSupport.stream(spliterator(), false);\r\n}\nprivate static boolean isMappingForType(AnnotationTypeMapping mapping, @Nullable Object requiredType) {\r\n    if (requiredType == null) {\r\n        return true;\r\n    }\r\n    Class<? extends Annotation> actualType = mapping.getAnnotationType();\r\n    return (actualType == requiredType || actualType.getName().equals(requiredType));\r\n}\nstatic MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {\r\n    Assert.notNull(annotations, \"Annotations must not be null\");\r\n    if (annotations.isEmpty()) {\r\n        return TypeMappedAnnotations.NONE;\r\n    }\r\n    return new MergedAnnotationsCollection(annotations);\r\n}\nprivate class AnnotationsSpliterator<A extends Annotation> implements Spliterator<MergedAnnotation<A>> {\r\n\r\n    @Nullable\r\n    private final Object requiredType;\r\n\r\n    private final int[] mappingCursors;\r\n\r\n    public AnnotationsSpliterator(@Nullable Object requiredType) {\r\n        this.mappingCursors = new int[annotations.length];\r\n        this.requiredType = requiredType;\r\n    }\r\n\r\n    @Override\r\n    public boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n        int lowestDistance = Integer.MAX_VALUE;\r\n        int annotationResult = -1;\r\n        for (int annotationIndex = 0; annotationIndex < annotations.length; annotationIndex++) {\r\n            AnnotationTypeMapping mapping = getNextSuitableMapping(annotationIndex);\r\n            if (mapping != null && mapping.getDistance() < lowestDistance) {\r\n                annotationResult = annotationIndex;\r\n                lowestDistance = mapping.getDistance();\r\n            }\r\n            if (lowestDistance == 0) {\r\n                break;\r\n            }\r\n        }\r\n        if (annotationResult != -1) {\r\n            MergedAnnotation<A> mergedAnnotation = createMergedAnnotationIfPossible(annotationResult, this.mappingCursors[annotationResult]);\r\n            this.mappingCursors[annotationResult]++;\r\n            if (mergedAnnotation == null) {\r\n                return tryAdvance(action);\r\n            }\r\n            action.accept(mergedAnnotation);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Nullable\r\n    private AnnotationTypeMapping getNextSuitableMapping(int annotationIndex) {\r\n        AnnotationTypeMapping mapping;\r\n        do {\r\n            mapping = getMapping(annotationIndex, this.mappingCursors[annotationIndex]);\r\n            if (mapping != null && isMappingForType(mapping, this.requiredType)) {\r\n                return mapping;\r\n            }\r\n            this.mappingCursors[annotationIndex]++;\r\n        } while (mapping != null);\r\n        return null;\r\n    }\r\n\r\n    @Nullable\r\n    private AnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n        AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[annotationIndex];\r\n        return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    private MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex) {\r\n        MergedAnnotation<?> root = annotations[annotationIndex];\r\n        if (mappingIndex == 0) {\r\n            return (MergedAnnotation<A>) root;\r\n        }\r\n        IntrospectionFailureLogger logger = (this.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\r\n        return TypeMappedAnnotation.createIfPossible(mappings[annotationIndex].get(mappingIndex), root, logger);\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public Spliterator<MergedAnnotation<A>> trySplit() {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public long estimateSize() {\r\n        int size = 0;\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[i];\r\n            int numberOfMappings = mappings.size();\r\n            numberOfMappings -= Math.min(this.mappingCursors[i], mappings.size());\r\n            size += numberOfMappings;\r\n        }\r\n        return size;\r\n    }\r\n\r\n    @Override\r\n    public int characteristics() {\r\n        return NONNULL | IMMUTABLE;\r\n    }\r\n}",
    "comment": "\n * {@link MergedAnnotations} implementation backed by a {@link Collection} of\n * {@link MergedAnnotation} instances that represent direct annotations.\n *\n * @author Phillip Webb\n * @since 5.2\n * @see MergedAnnotations#of(Collection)\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<MergedAnnotation<Annotation>> iterator() {\r\n    return Spliterators.iterator(spliterator());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<MergedAnnotation<Annotation>> spliterator() {\r\n    return spliterator(null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#spliterator(Object)",
    "entityType": "method",
    "code": "private <A extends Annotation> Spliterator<MergedAnnotation<A>> spliterator(@Nullable Object annotationType) {\r\n    return new AnnotationsSpliterator<>(annotationType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#isPresent(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> boolean isPresent(Class<A> annotationType) {\r\n    return isPresent(annotationType, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#isPresent(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isPresent(String annotationType) {\r\n    return isPresent(annotationType, false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#isDirectlyPresent(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType) {\r\n    return isPresent(annotationType, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#isDirectlyPresent(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isDirectlyPresent(String annotationType) {\r\n    return isPresent(annotationType, true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#isPresent(Object,boolean)",
    "entityType": "method",
    "code": "private boolean isPresent(Object requiredType, boolean directOnly) {\r\n    for (MergedAnnotation<?> annotation : this.annotations) {\r\n        Class<? extends Annotation> type = annotation.getType();\r\n        if (type == requiredType || type.getName().equals(requiredType)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!directOnly) {\r\n        for (AnnotationTypeMappings mappings : this.mappings) {\r\n            for (int i = 1; i < mappings.size(); i++) {\r\n                AnnotationTypeMapping mapping = mappings.get(i);\r\n                if (isMappingForType(mapping, requiredType)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#get(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType) {\r\n    return get(annotationType, null, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#get(Class<A>,Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#get(Class<A>,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    MergedAnnotation<A> result = find(annotationType, predicate, selector);\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#get(String)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType) {\r\n    return get(annotationType, null, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#get(String,Predicate<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate) {\r\n    return get(annotationType, predicate, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#get(String,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> MergedAnnotation<A> get(String annotationType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    MergedAnnotation<A> result = find(annotationType, predicate, selector);\r\n    return (result != null ? result : MergedAnnotation.missing());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#find(Object,Predicate<? super MergedAnnotation<A>>,MergedAnnotationSelector<A>)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate <A extends Annotation> MergedAnnotation<A> find(Object requiredType, @Nullable Predicate<? super MergedAnnotation<A>> predicate, @Nullable MergedAnnotationSelector<A> selector) {\r\n    if (selector == null) {\r\n        selector = MergedAnnotationSelectors.nearest();\r\n    }\r\n    MergedAnnotation<A> result = null;\r\n    for (int i = 0; i < this.annotations.length; i++) {\r\n        MergedAnnotation<?> root = this.annotations[i];\r\n        if (root != null) {\r\n            AnnotationTypeMappings mappings = this.mappings[i];\r\n            for (int mappingIndex = 0; mappingIndex < mappings.size(); mappingIndex++) {\r\n                AnnotationTypeMapping mapping = mappings.get(mappingIndex);\r\n                if (!isMappingForType(mapping, requiredType)) {\r\n                    continue;\r\n                }\r\n                MergedAnnotation<A> candidate = (mappingIndex == 0 ? (MergedAnnotation<A>) root : TypeMappedAnnotation.createIfPossible(mapping, root, IntrospectionFailureLogger.INFO));\r\n                if (candidate != null && (predicate == null || predicate.test(candidate))) {\r\n                    if (selector.isBestCandidate(candidate)) {\r\n                        return candidate;\r\n                    }\r\n                    result = (result != null ? selector.select(result, candidate) : candidate);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#stream(Class<A>)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType) {\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#stream(String)",
    "entityType": "method",
    "code": "@Override\r\npublic <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {\r\n    return StreamSupport.stream(spliterator(annotationType), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#stream()",
    "entityType": "method",
    "code": "@Override\r\npublic Stream<MergedAnnotation<Annotation>> stream() {\r\n    return StreamSupport.stream(spliterator(), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#isMappingForType(AnnotationTypeMapping,Object)",
    "entityType": "method",
    "code": "private static boolean isMappingForType(AnnotationTypeMapping mapping, @Nullable Object requiredType) {\r\n    if (requiredType == null) {\r\n        return true;\r\n    }\r\n    Class<? extends Annotation> actualType = mapping.getAnnotationType();\r\n    return (actualType == requiredType || actualType.getName().equals(requiredType));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationsCollection#of(Collection<MergedAnnotation<?>>)",
    "entityType": "method",
    "code": "static MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {\r\n    Assert.notNull(annotations, \"Annotations must not be null\");\r\n    if (annotations.isEmpty()) {\r\n        return TypeMappedAnnotations.NONE;\r\n    }\r\n    return new MergedAnnotationsCollection(annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final Object requiredType;\nprivate final int[] mappingCursors;\npublic AnnotationsSpliterator(@Nullable Object requiredType) {\r\n    this.mappingCursors = new int[annotations.length];\r\n    this.requiredType = requiredType;\r\n}\n@Override\r\npublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n    int lowestDistance = Integer.MAX_VALUE;\r\n    int annotationResult = -1;\r\n    for (int annotationIndex = 0; annotationIndex < annotations.length; annotationIndex++) {\r\n        AnnotationTypeMapping mapping = getNextSuitableMapping(annotationIndex);\r\n        if (mapping != null && mapping.getDistance() < lowestDistance) {\r\n            annotationResult = annotationIndex;\r\n            lowestDistance = mapping.getDistance();\r\n        }\r\n        if (lowestDistance == 0) {\r\n            break;\r\n        }\r\n    }\r\n    if (annotationResult != -1) {\r\n        MergedAnnotation<A> mergedAnnotation = createMergedAnnotationIfPossible(annotationResult, this.mappingCursors[annotationResult]);\r\n        this.mappingCursors[annotationResult]++;\r\n        if (mergedAnnotation == null) {\r\n            return tryAdvance(action);\r\n        }\r\n        action.accept(mergedAnnotation);\r\n        return true;\r\n    }\r\n    return false;\r\n}\n@Nullable\r\nprivate AnnotationTypeMapping getNextSuitableMapping(int annotationIndex) {\r\n    AnnotationTypeMapping mapping;\r\n    do {\r\n        mapping = getMapping(annotationIndex, this.mappingCursors[annotationIndex]);\r\n        if (mapping != null && isMappingForType(mapping, this.requiredType)) {\r\n            return mapping;\r\n        }\r\n        this.mappingCursors[annotationIndex]++;\r\n    } while (mapping != null);\r\n    return null;\r\n}\n@Nullable\r\nprivate AnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n    AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[annotationIndex];\r\n    return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n}\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex) {\r\n    MergedAnnotation<?> root = annotations[annotationIndex];\r\n    if (mappingIndex == 0) {\r\n        return (MergedAnnotation<A>) root;\r\n    }\r\n    IntrospectionFailureLogger logger = (this.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\r\n    return TypeMappedAnnotation.createIfPossible(mappings[annotationIndex].get(mappingIndex), root, logger);\r\n}\n@Override\r\n@Nullable\r\npublic Spliterator<MergedAnnotation<A>> trySplit() {\r\n    return null;\r\n}\n@Override\r\npublic long estimateSize() {\r\n    int size = 0;\r\n    for (int i = 0; i < annotations.length; i++) {\r\n        AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[i];\r\n        int numberOfMappings = mappings.size();\r\n        numberOfMappings -= Math.min(this.mappingCursors[i], mappings.size());\r\n        size += numberOfMappings;\r\n    }\r\n    return size;\r\n}\n@Override\r\npublic int characteristics() {\r\n    return NONNULL | IMMUTABLE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#tryAdvance(Consumer<? super MergedAnnotation<A>>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {\r\n    int lowestDistance = Integer.MAX_VALUE;\r\n    int annotationResult = -1;\r\n    for (int annotationIndex = 0; annotationIndex < annotations.length; annotationIndex++) {\r\n        AnnotationTypeMapping mapping = getNextSuitableMapping(annotationIndex);\r\n        if (mapping != null && mapping.getDistance() < lowestDistance) {\r\n            annotationResult = annotationIndex;\r\n            lowestDistance = mapping.getDistance();\r\n        }\r\n        if (lowestDistance == 0) {\r\n            break;\r\n        }\r\n    }\r\n    if (annotationResult != -1) {\r\n        MergedAnnotation<A> mergedAnnotation = createMergedAnnotationIfPossible(annotationResult, this.mappingCursors[annotationResult]);\r\n        this.mappingCursors[annotationResult]++;\r\n        if (mergedAnnotation == null) {\r\n            return tryAdvance(action);\r\n        }\r\n        action.accept(mergedAnnotation);\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#getNextSuitableMapping(int)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate AnnotationTypeMapping getNextSuitableMapping(int annotationIndex) {\r\n    AnnotationTypeMapping mapping;\r\n    do {\r\n        mapping = getMapping(annotationIndex, this.mappingCursors[annotationIndex]);\r\n        if (mapping != null && isMappingForType(mapping, this.requiredType)) {\r\n            return mapping;\r\n        }\r\n        this.mappingCursors[annotationIndex]++;\r\n    } while (mapping != null);\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#getMapping(int,int)",
    "entityType": "method",
    "code": "@Nullable\r\nprivate AnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {\r\n    AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[annotationIndex];\r\n    return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#createMergedAnnotationIfPossible(int,int)",
    "entityType": "method",
    "code": "@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nprivate MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex) {\r\n    MergedAnnotation<?> root = annotations[annotationIndex];\r\n    if (mappingIndex == 0) {\r\n        return (MergedAnnotation<A>) root;\r\n    }\r\n    IntrospectionFailureLogger logger = (this.requiredType != null ? IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);\r\n    return TypeMappedAnnotation.createIfPossible(mappings[annotationIndex].get(mappingIndex), root, logger);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#trySplit()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Spliterator<MergedAnnotation<A>> trySplit() {\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#estimateSize()",
    "entityType": "method",
    "code": "@Override\r\npublic long estimateSize() {\r\n    int size = 0;\r\n    for (int i = 0; i < annotations.length; i++) {\r\n        AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[i];\r\n        int numberOfMappings = mappings.size();\r\n        numberOfMappings -= Math.min(this.mappingCursors[i], mappings.size());\r\n        size += numberOfMappings;\r\n    }\r\n    return size;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.AnnotationsSpliterator#characteristics()",
    "entityType": "method",
    "code": "@Override\r\npublic int characteristics() {\r\n    return NONNULL | IMMUTABLE;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationSelector",
    "entityType": "class",
    "code": "/**\r\n * Determine if the existing annotation is known to be the best\r\n * candidate and any subsequent selections may be skipped.\r\n * @param annotation the annotation to check\r\n * @return {@code true} if the annotation is known to be the best candidate\r\n */\r\ndefault boolean isBestCandidate(MergedAnnotation<A> annotation) {\r\n    return false;\r\n}\n/**\r\n * Select the annotation that should be used.\r\n * @param existing an existing annotation returned from an earlier result\r\n * @param candidate a candidate annotation that may be better suited\r\n * @return the most appropriate annotation from the {@code existing} or\r\n * {@code candidate}\r\n */\r\nMergedAnnotation<A> select(MergedAnnotation<A> existing, MergedAnnotation<A> candidate);",
    "comment": "\n * Strategy interface used to select between two {@link MergedAnnotation}\n * instances.\n *\n * @author Phillip Webb\n * @since 5.2\n * @param <A> the annotation type\n * @see MergedAnnotationSelectors\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationSelector#isBestCandidate(MergedAnnotation<A>)",
    "entityType": "method",
    "code": "/**\r\n * Determine if the existing annotation is known to be the best\r\n * candidate and any subsequent selections may be skipped.\r\n * @param annotation the annotation to check\r\n * @return {@code true} if the annotation is known to be the best candidate\r\n */\r\ndefault boolean isBestCandidate(MergedAnnotation<A> annotation) {\r\n    return false;\r\n}",
    "comment": "\n\t * Determine if the existing annotation is known to be the best\n\t * candidate and any subsequent selections may be skipped.\n\t * @param annotation the annotation to check\n\t * @return {@code true} if the annotation is known to be the best candidate\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationSelector#select(MergedAnnotation<A>,MergedAnnotation<A>)",
    "entityType": "method",
    "code": "/**\r\n * Select the annotation that should be used.\r\n * @param existing an existing annotation returned from an earlier result\r\n * @param candidate a candidate annotation that may be better suited\r\n * @return the most appropriate annotation from the {@code existing} or\r\n * {@code candidate}\r\n */\r\nMergedAnnotation<A> select(MergedAnnotation<A> existing, MergedAnnotation<A> candidate);",
    "comment": "\n\t * Select the annotation that should be used.\n\t * @param existing an existing annotation returned from an earlier result\n\t * @param candidate a candidate annotation that may be better suited\n\t * @return the most appropriate annotation from the {@code existing} or\n\t * {@code candidate}\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationSelectors",
    "entityType": "class",
    "code": "private static final MergedAnnotationSelector<?> NEAREST = new Nearest();\nprivate static final MergedAnnotationSelector<?> FIRST_DIRECTLY_DECLARED = new FirstDirectlyDeclared();\nprivate MergedAnnotationSelectors() {\r\n}\n/**\r\n * Select the nearest annotation, i.e. the one with the lowest distance.\r\n * @return a selector that picks the annotation with the lowest distance\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <A extends Annotation> MergedAnnotationSelector<A> nearest() {\r\n    return (MergedAnnotationSelector<A>) NEAREST;\r\n}\n/**\r\n * Select the first directly declared annotation when possible. If no direct\r\n * annotations are declared then the nearest annotation is selected.\r\n * @return a selector that picks the first directly declared annotation whenever possible\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <A extends Annotation> MergedAnnotationSelector<A> firstDirectlyDeclared() {\r\n    return (MergedAnnotationSelector<A>) FIRST_DIRECTLY_DECLARED;\r\n}\n/**\r\n * {@link MergedAnnotationSelector} to select the nearest annotation.\r\n */\r\nprivate static class Nearest implements MergedAnnotationSelector<Annotation> {\r\n\r\n    @Override\r\n    public boolean isBestCandidate(MergedAnnotation<Annotation> annotation) {\r\n        return annotation.getDistance() == 0;\r\n    }\r\n\r\n    @Override\r\n    public MergedAnnotation<Annotation> select(MergedAnnotation<Annotation> existing, MergedAnnotation<Annotation> candidate) {\r\n        if (candidate.getDistance() < existing.getDistance()) {\r\n            return candidate;\r\n        }\r\n        return existing;\r\n    }\r\n}\n/**\r\n * {@link MergedAnnotationSelector} to select the first directly declared\r\n * annotation.\r\n */\r\nprivate static class FirstDirectlyDeclared implements MergedAnnotationSelector<Annotation> {\r\n\r\n    @Override\r\n    public boolean isBestCandidate(MergedAnnotation<Annotation> annotation) {\r\n        return annotation.getDistance() == 0;\r\n    }\r\n\r\n    @Override\r\n    public MergedAnnotation<Annotation> select(MergedAnnotation<Annotation> existing, MergedAnnotation<Annotation> candidate) {\r\n        if (existing.getDistance() > 0 && candidate.getDistance() == 0) {\r\n            return candidate;\r\n        }\r\n        return existing;\r\n    }\r\n}",
    "comment": "\n * {@link MergedAnnotationSelector} implementations that provide various options\n * for {@link MergedAnnotation} instances.\n *\n * @author Phillip Webb\n * @since 5.2\n * @see MergedAnnotations#get(Class, Predicate, MergedAnnotationSelector)\n * @see MergedAnnotations#get(String, Predicate, MergedAnnotationSelector)\n "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationSelectors#nearest()",
    "entityType": "method",
    "code": "/**\r\n * Select the nearest annotation, i.e. the one with the lowest distance.\r\n * @return a selector that picks the annotation with the lowest distance\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <A extends Annotation> MergedAnnotationSelector<A> nearest() {\r\n    return (MergedAnnotationSelector<A>) NEAREST;\r\n}",
    "comment": "\n\t * Select the nearest annotation, i.e. the one with the lowest distance.\n\t * @return a selector that picks the annotation with the lowest distance\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.MergedAnnotationSelectors#firstDirectlyDeclared()",
    "entityType": "method",
    "code": "/**\r\n * Select the first directly declared annotation when possible. If no direct\r\n * annotations are declared then the nearest annotation is selected.\r\n * @return a selector that picks the first directly declared annotation whenever possible\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <A extends Annotation> MergedAnnotationSelector<A> firstDirectlyDeclared() {\r\n    return (MergedAnnotationSelector<A>) FIRST_DIRECTLY_DECLARED;\r\n}",
    "comment": "\n\t * Select the first directly declared annotation when possible. If no direct\n\t * annotations are declared then the nearest annotation is selected.\n\t * @return a selector that picks the first directly declared annotation whenever possible\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Nearest",
    "entityType": "class",
    "code": "@Override\r\npublic boolean isBestCandidate(MergedAnnotation<Annotation> annotation) {\r\n    return annotation.getDistance() == 0;\r\n}\n@Override\r\npublic MergedAnnotation<Annotation> select(MergedAnnotation<Annotation> existing, MergedAnnotation<Annotation> candidate) {\r\n    if (candidate.getDistance() < existing.getDistance()) {\r\n        return candidate;\r\n    }\r\n    return existing;\r\n}",
    "comment": "\n\t * {@link MergedAnnotationSelector} to select the nearest annotation.\n\t "
  },
  {
    "entityId": "org.springframework.core.annotation.Nearest#isBestCandidate(MergedAnnotation<Annotation>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isBestCandidate(MergedAnnotation<Annotation> annotation) {\r\n    return annotation.getDistance() == 0;\r\n}",
    "comment": ""
  }
]