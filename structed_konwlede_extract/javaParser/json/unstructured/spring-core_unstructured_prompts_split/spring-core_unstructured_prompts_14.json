[
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHint#getPattern()",
    "entityType": "method",
    "code": "/**\r\n * Return the pattern to use for identifying the resources to match.\r\n */\r\npublic String getPattern() {\r\n    return this.pattern;\r\n}",
    "comment": "\n\t * Return the pattern to use for identifying the resources to match.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHint#matches(String)",
    "entityType": "method",
    "code": "/**\r\n * Whether the given path matches the current glob pattern.\r\n * @param path the path to match against\r\n */\r\npublic boolean matches(String path) {\r\n    return PATH_MATCHER.match(this.pattern, path);\r\n}",
    "comment": "\n\t * Whether the given path matches the current glob pattern.\n\t * @param path the path to match against\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHint#getReachableType()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic TypeReference getReachableType() {\r\n    return this.reachableType;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHint#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof ResourcePatternHint that && this.pattern.equals(that.pattern) && Objects.equals(this.reachableType, that.reachableType)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHint#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return Objects.hash(this.pattern, this.reachableType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtilsTests",
    "entityType": "class",
    "code": "@Test\r\nvoid callAsyncNormal() throws ExecutionException, InterruptedException {\r\n    String foo = \"Foo\";\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> foo);\r\n    assertThat(future.get()).isEqualTo(foo);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isEqualTo(foo);\r\n        assertThat(throwable).isNull();\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}\n@Test\r\nvoid callAsyncException() throws InterruptedException {\r\n    RuntimeException ex = new RuntimeException(\"Foo\");\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> {\r\n        throw ex;\r\n    });\r\n    assertThatExceptionOfType(ExecutionException.class).isThrownBy(future::get).withCause(ex);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isNull();\r\n        assertThat(throwable).isInstanceOf(CompletionException.class).hasCause(ex);\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}\n@Test\r\nvoid callAsyncNormalExecutor() throws ExecutionException, InterruptedException {\r\n    String foo = \"Foo\";\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> foo, new SimpleAsyncTaskExecutor());\r\n    assertThat(future.get()).isEqualTo(foo);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isEqualTo(foo);\r\n        assertThat(throwable).isNull();\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}\n@Test\r\nvoid callAsyncExceptionExecutor() throws InterruptedException {\r\n    RuntimeException ex = new RuntimeException(\"Foo\");\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> {\r\n        throw ex;\r\n    }, new SimpleAsyncTaskExecutor());\r\n    assertThatExceptionOfType(ExecutionException.class).isThrownBy(future::get).withCause(ex);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isNull();\r\n        assertThat(throwable).isInstanceOf(CompletionException.class).hasCause(ex);\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}",
    "comment": "\n * @author Arjen Poutsma\n "
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtilsTests#callAsyncNormal()",
    "entityType": "method",
    "code": "@Test\r\nvoid callAsyncNormal() throws ExecutionException, InterruptedException {\r\n    String foo = \"Foo\";\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> foo);\r\n    assertThat(future.get()).isEqualTo(foo);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isEqualTo(foo);\r\n        assertThat(throwable).isNull();\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtilsTests#callAsyncException()",
    "entityType": "method",
    "code": "@Test\r\nvoid callAsyncException() throws InterruptedException {\r\n    RuntimeException ex = new RuntimeException(\"Foo\");\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> {\r\n        throw ex;\r\n    });\r\n    assertThatExceptionOfType(ExecutionException.class).isThrownBy(future::get).withCause(ex);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isNull();\r\n        assertThat(throwable).isInstanceOf(CompletionException.class).hasCause(ex);\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtilsTests#callAsyncNormalExecutor()",
    "entityType": "method",
    "code": "@Test\r\nvoid callAsyncNormalExecutor() throws ExecutionException, InterruptedException {\r\n    String foo = \"Foo\";\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> foo, new SimpleAsyncTaskExecutor());\r\n    assertThat(future.get()).isEqualTo(foo);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isEqualTo(foo);\r\n        assertThat(throwable).isNull();\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.concurrent.FutureUtilsTests#callAsyncExceptionExecutor()",
    "entityType": "method",
    "code": "@Test\r\nvoid callAsyncExceptionExecutor() throws InterruptedException {\r\n    RuntimeException ex = new RuntimeException(\"Foo\");\r\n    CompletableFuture<String> future = FutureUtils.callAsync(() -> {\r\n        throw ex;\r\n    }, new SimpleAsyncTaskExecutor());\r\n    assertThatExceptionOfType(ExecutionException.class).isThrownBy(future::get).withCause(ex);\r\n    assertThat(future.isCancelled()).isFalse();\r\n    assertThat(future.isDone()).isTrue();\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    future.whenComplete((s, throwable) -> {\r\n        assertThat(s).isNull();\r\n        assertThat(throwable).isInstanceOf(CompletionException.class).hasCause(ex);\r\n        latch.countDown();\r\n    });\r\n    latch.await();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHints",
    "entityType": "class",
    "code": "private final List<ResourcePatternHint> includes;\nprivate ResourcePatternHints(Builder builder) {\r\n    this.includes = new ArrayList<>(builder.includes);\r\n}\n/**\r\n * Return the include patterns to use to identify the resources to match.\r\n * @return the include patterns\r\n */\r\npublic List<ResourcePatternHint> getIncludes() {\r\n    return this.includes;\r\n}\n/**\r\n * Builder for {@link ResourcePatternHints}.\r\n */\r\npublic static class Builder {\r\n\r\n    private final Set<ResourcePatternHint> includes = new LinkedHashSet<>();\r\n\r\n    Builder() {\r\n    }\r\n\r\n    /**\r\n     * Include resources matching the specified glob patterns.\r\n     * @param reachableType the type that should be reachable for this hint to apply\r\n     * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder includes(@Nullable TypeReference reachableType, String... includes) {\r\n        Arrays.stream(includes).map(this::expandToIncludeDirectories).flatMap(List::stream).map(include -> new ResourcePatternHint(include, reachableType)).forEach(this.includes::add);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Expand the supplied include pattern into multiple patterns that include\r\n     * all parent directories for the ultimate resource or resources.\r\n     * <p>This is necessary to support classpath scanning within a GraalVM\r\n     * native image.\r\n     * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/29403\">gh-29403</a>\r\n     */\r\n    private List<String> expandToIncludeDirectories(String includePattern) {\r\n        // Resource in root or no explicit subdirectories?\r\n        if (!includePattern.contains(\"/\")) {\r\n            // Include the root directory as well as the pattern\r\n            return List.of(\"/\", includePattern);\r\n        }\r\n        List<String> includePatterns = new ArrayList<>();\r\n        // Ensure the root directory and original pattern are always included\r\n        includePatterns.add(\"/\");\r\n        includePatterns.add(includePattern);\r\n        StringBuilder path = new StringBuilder();\r\n        for (String pathElement : includePattern.split(\"/\")) {\r\n            if (pathElement.isEmpty()) {\r\n                // Skip empty path elements\r\n                continue;\r\n            }\r\n            if (pathElement.contains(\"*\")) {\r\n                // Stop at the first encountered wildcard, since we cannot reliably reason\r\n                // any further about the directory structure below this path element.\r\n                break;\r\n            }\r\n            if (!path.isEmpty()) {\r\n                path.append(\"/\");\r\n            }\r\n            path.append(pathElement);\r\n            includePatterns.add(path.toString());\r\n        }\r\n        return includePatterns;\r\n    }\r\n\r\n    /**\r\n     * Include resources matching the specified glob patterns.\r\n     * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\r\n     * @return {@code this}, to facilitate method chaining\r\n     */\r\n    public Builder includes(String... includes) {\r\n        return includes(null, includes);\r\n    }\r\n\r\n    /**\r\n     * Create {@link ResourcePatternHints} based on the state of this\r\n     * builder.\r\n     * @return resource pattern hints\r\n     */\r\n    ResourcePatternHints build() {\r\n        return new ResourcePatternHints(this);\r\n    }\r\n}",
    "comment": "\n * A collection of {@link ResourcePatternHint} describing whether resources should\n * be made available at runtime using a matching algorithm based on include/exclude\n * patterns.\n *\n * @author Stephane Nicoll\n * @author Brian Clozel\n * @author Sam Brannen\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.ResourcePatternHints#getIncludes()",
    "entityType": "method",
    "code": "/**\r\n * Return the include patterns to use to identify the resources to match.\r\n * @return the include patterns\r\n */\r\npublic List<ResourcePatternHint> getIncludes() {\r\n    return this.includes;\r\n}",
    "comment": "\n\t * Return the include patterns to use to identify the resources to match.\n\t * @return the include patterns\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder",
    "entityType": "class",
    "code": "private final Set<ResourcePatternHint> includes = new LinkedHashSet<>();\nBuilder() {\r\n}\n/**\r\n * Include resources matching the specified glob patterns.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder includes(@Nullable TypeReference reachableType, String... includes) {\r\n    Arrays.stream(includes).map(this::expandToIncludeDirectories).flatMap(List::stream).map(include -> new ResourcePatternHint(include, reachableType)).forEach(this.includes::add);\r\n    return this;\r\n}\n/**\r\n * Expand the supplied include pattern into multiple patterns that include\r\n * all parent directories for the ultimate resource or resources.\r\n * <p>This is necessary to support classpath scanning within a GraalVM\r\n * native image.\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/29403\">gh-29403</a>\r\n */\r\nprivate List<String> expandToIncludeDirectories(String includePattern) {\r\n    // Resource in root or no explicit subdirectories?\r\n    if (!includePattern.contains(\"/\")) {\r\n        // Include the root directory as well as the pattern\r\n        return List.of(\"/\", includePattern);\r\n    }\r\n    List<String> includePatterns = new ArrayList<>();\r\n    // Ensure the root directory and original pattern are always included\r\n    includePatterns.add(\"/\");\r\n    includePatterns.add(includePattern);\r\n    StringBuilder path = new StringBuilder();\r\n    for (String pathElement : includePattern.split(\"/\")) {\r\n        if (pathElement.isEmpty()) {\r\n            // Skip empty path elements\r\n            continue;\r\n        }\r\n        if (pathElement.contains(\"*\")) {\r\n            // Stop at the first encountered wildcard, since we cannot reliably reason\r\n            // any further about the directory structure below this path element.\r\n            break;\r\n        }\r\n        if (!path.isEmpty()) {\r\n            path.append(\"/\");\r\n        }\r\n        path.append(pathElement);\r\n        includePatterns.add(path.toString());\r\n    }\r\n    return includePatterns;\r\n}\n/**\r\n * Include resources matching the specified glob patterns.\r\n * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder includes(String... includes) {\r\n    return includes(null, includes);\r\n}\n/**\r\n * Create {@link ResourcePatternHints} based on the state of this\r\n * builder.\r\n * @return resource pattern hints\r\n */\r\nResourcePatternHints build() {\r\n    return new ResourcePatternHints(this);\r\n}",
    "comment": "\n\t * Builder for {@link ResourcePatternHints}.\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#includes(TypeReference,String)",
    "entityType": "method",
    "code": "/**\r\n * Include resources matching the specified glob patterns.\r\n * @param reachableType the type that should be reachable for this hint to apply\r\n * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder includes(@Nullable TypeReference reachableType, String... includes) {\r\n    Arrays.stream(includes).map(this::expandToIncludeDirectories).flatMap(List::stream).map(include -> new ResourcePatternHint(include, reachableType)).forEach(this.includes::add);\r\n    return this;\r\n}",
    "comment": "\n\t\t * Include resources matching the specified glob patterns.\n\t\t * @param reachableType the type that should be reachable for this hint to apply\n\t\t * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#expandToIncludeDirectories(String)",
    "entityType": "method",
    "code": "/**\r\n * Expand the supplied include pattern into multiple patterns that include\r\n * all parent directories for the ultimate resource or resources.\r\n * <p>This is necessary to support classpath scanning within a GraalVM\r\n * native image.\r\n * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/29403\">gh-29403</a>\r\n */\r\nprivate List<String> expandToIncludeDirectories(String includePattern) {\r\n    // Resource in root or no explicit subdirectories?\r\n    if (!includePattern.contains(\"/\")) {\r\n        // Include the root directory as well as the pattern\r\n        return List.of(\"/\", includePattern);\r\n    }\r\n    List<String> includePatterns = new ArrayList<>();\r\n    // Ensure the root directory and original pattern are always included\r\n    includePatterns.add(\"/\");\r\n    includePatterns.add(includePattern);\r\n    StringBuilder path = new StringBuilder();\r\n    for (String pathElement : includePattern.split(\"/\")) {\r\n        if (pathElement.isEmpty()) {\r\n            // Skip empty path elements\r\n            continue;\r\n        }\r\n        if (pathElement.contains(\"*\")) {\r\n            // Stop at the first encountered wildcard, since we cannot reliably reason\r\n            // any further about the directory structure below this path element.\r\n            break;\r\n        }\r\n        if (!path.isEmpty()) {\r\n            path.append(\"/\");\r\n        }\r\n        path.append(pathElement);\r\n        includePatterns.add(path.toString());\r\n    }\r\n    return includePatterns;\r\n}",
    "comment": "\n\t\t * Expand the supplied include pattern into multiple patterns that include\n\t\t * all parent directories for the ultimate resource or resources.\n\t\t * <p>This is necessary to support classpath scanning within a GraalVM\n\t\t * native image.\n\t\t * @see <a href=\"https://github.com/spring-projects/spring-framework/issues/29403\">gh-29403</a>\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#includes(String)",
    "entityType": "method",
    "code": "/**\r\n * Include resources matching the specified glob patterns.\r\n * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic Builder includes(String... includes) {\r\n    return includes(null, includes);\r\n}",
    "comment": "\n\t\t * Include resources matching the specified glob patterns.\n\t\t * @param includes the include patterns (see {@link ResourcePatternHint} documentation)\n\t\t * @return {@code this}, to facilitate method chaining\n\t\t "
  },
  {
    "entityId": "org.springframework.aot.hint.Builder#build()",
    "entityType": "method",
    "code": "/**\r\n * Create {@link ResourcePatternHints} based on the state of this\r\n * builder.\r\n * @return resource pattern hints\r\n */\r\nResourcePatternHints build() {\r\n    return new ResourcePatternHints(this);\r\n}",
    "comment": "\n\t\t * Create {@link ResourcePatternHints} based on the state of this\n\t\t * builder.\n\t\t * @return resource pattern hints\n\t\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCacheTests",
    "entityType": "class",
    "code": "private final ConcurrentLruCache<String, String> cache = new ConcurrentLruCache<>(2, key -> key + \"value\");\n@Test\r\nvoid zeroCapacity() {\r\n    ConcurrentLruCache<String, String> cache = new ConcurrentLruCache<>(0, key -> key + \"value\");\r\n    assertThat(cache.capacity()).isZero();\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.contains(\"k1\")).isFalse();\r\n    assertThat(cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.contains(\"k1\")).isFalse();\r\n    assertThat(cache.contains(\"k2\")).isFalse();\r\n    assertThat(cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.contains(\"k1\")).isFalse();\r\n    assertThat(cache.contains(\"k2\")).isFalse();\r\n    assertThat(cache.contains(\"k3\")).isFalse();\r\n}\n@Test\r\nvoid getAndSize() {\r\n    assertThat(this.cache.capacity()).isEqualTo(2);\r\n    assertThat(this.cache.size()).isEqualTo(0);\r\n    assertThat(this.cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(this.cache.size()).isEqualTo(1);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    assertThat(this.cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isFalse();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    assertThat(this.cache.contains(\"k3\")).isTrue();\r\n}\n@Test\r\nvoid removeAndSize() {\r\n    assertThat(this.cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(this.cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    this.cache.remove(\"k2\");\r\n    assertThat(this.cache.size()).isEqualTo(1);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.contains(\"k3\")).isTrue();\r\n}\n@Test\r\nvoid clearAndSize() {\r\n    assertThat(this.cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(this.cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    this.cache.clear();\r\n    assertThat(this.cache.size()).isEqualTo(0);\r\n    assertThat(this.cache.contains(\"k1\")).isFalse();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(this.cache.size()).isEqualTo(1);\r\n    assertThat(this.cache.contains(\"k1\")).isFalse();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.contains(\"k3\")).isTrue();\r\n}",
    "comment": "\n * Tests for {@link ConcurrentLruCache}.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n "
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCacheTests#zeroCapacity()",
    "entityType": "method",
    "code": "@Test\r\nvoid zeroCapacity() {\r\n    ConcurrentLruCache<String, String> cache = new ConcurrentLruCache<>(0, key -> key + \"value\");\r\n    assertThat(cache.capacity()).isZero();\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.contains(\"k1\")).isFalse();\r\n    assertThat(cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.contains(\"k1\")).isFalse();\r\n    assertThat(cache.contains(\"k2\")).isFalse();\r\n    assertThat(cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(cache.size()).isZero();\r\n    assertThat(cache.contains(\"k1\")).isFalse();\r\n    assertThat(cache.contains(\"k2\")).isFalse();\r\n    assertThat(cache.contains(\"k3\")).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCacheTests#getAndSize()",
    "entityType": "method",
    "code": "@Test\r\nvoid getAndSize() {\r\n    assertThat(this.cache.capacity()).isEqualTo(2);\r\n    assertThat(this.cache.size()).isEqualTo(0);\r\n    assertThat(this.cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(this.cache.size()).isEqualTo(1);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    assertThat(this.cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isFalse();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    assertThat(this.cache.contains(\"k3\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCacheTests#removeAndSize()",
    "entityType": "method",
    "code": "@Test\r\nvoid removeAndSize() {\r\n    assertThat(this.cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(this.cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    this.cache.remove(\"k2\");\r\n    assertThat(this.cache.size()).isEqualTo(1);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.contains(\"k3\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentLruCacheTests#clearAndSize()",
    "entityType": "method",
    "code": "@Test\r\nvoid clearAndSize() {\r\n    assertThat(this.cache.get(\"k1\")).isEqualTo(\"k1value\");\r\n    assertThat(this.cache.get(\"k2\")).isEqualTo(\"k2value\");\r\n    assertThat(this.cache.size()).isEqualTo(2);\r\n    assertThat(this.cache.contains(\"k1\")).isTrue();\r\n    assertThat(this.cache.contains(\"k2\")).isTrue();\r\n    this.cache.clear();\r\n    assertThat(this.cache.size()).isEqualTo(0);\r\n    assertThat(this.cache.contains(\"k1\")).isFalse();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.get(\"k3\")).isEqualTo(\"k3value\");\r\n    assertThat(this.cache.size()).isEqualTo(1);\r\n    assertThat(this.cache.contains(\"k1\")).isFalse();\r\n    assertThat(this.cache.contains(\"k2\")).isFalse();\r\n    assertThat(this.cache.contains(\"k3\")).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHints",
    "entityType": "class",
    "code": "private final ReflectionHints reflection = new ReflectionHints();\nprivate final ResourceHints resources = new ResourceHints();\nprivate final SerializationHints serialization = new SerializationHints();\nprivate final ProxyHints proxies = new ProxyHints();\nprivate final ReflectionHints jni = new ReflectionHints();\n/**\r\n * Provide access to reflection-based hints.\r\n * @return reflection hints\r\n */\r\npublic ReflectionHints reflection() {\r\n    return this.reflection;\r\n}\n/**\r\n * Provide access to resource-based hints.\r\n * @return resource hints\r\n */\r\npublic ResourceHints resources() {\r\n    return this.resources;\r\n}\n/**\r\n * Provide access to serialization-based hints.\r\n * @return serialization hints\r\n */\r\npublic SerializationHints serialization() {\r\n    return this.serialization;\r\n}\n/**\r\n * Provide access to proxy-based hints.\r\n * @return proxy hints\r\n */\r\npublic ProxyHints proxies() {\r\n    return this.proxies;\r\n}\n/**\r\n * Provide access to jni-based hints.\r\n * @return jni hints\r\n */\r\npublic ReflectionHints jni() {\r\n    return this.jni;\r\n}",
    "comment": "\n * Gather hints that can be used to optimize the application runtime.\n *\n * <p>Use of reflection can be recorded for individual members of a type, as\n * well as broader {@linkplain MemberCategory member categories}. Access to\n * resources can be specified using patterns or the base name of a resource\n * bundle.\n *\n * <p>Hints that require the need for Java serialization of proxies can be\n * recorded as well.\n *\n * @author Stephane Nicoll\n * @author Janne Valkealahti\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHints#reflection()",
    "entityType": "method",
    "code": "/**\r\n * Provide access to reflection-based hints.\r\n * @return reflection hints\r\n */\r\npublic ReflectionHints reflection() {\r\n    return this.reflection;\r\n}",
    "comment": "\n\t * Provide access to reflection-based hints.\n\t * @return reflection hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHints#resources()",
    "entityType": "method",
    "code": "/**\r\n * Provide access to resource-based hints.\r\n * @return resource hints\r\n */\r\npublic ResourceHints resources() {\r\n    return this.resources;\r\n}",
    "comment": "\n\t * Provide access to resource-based hints.\n\t * @return resource hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHints#serialization()",
    "entityType": "method",
    "code": "/**\r\n * Provide access to serialization-based hints.\r\n * @return serialization hints\r\n */\r\npublic SerializationHints serialization() {\r\n    return this.serialization;\r\n}",
    "comment": "\n\t * Provide access to serialization-based hints.\n\t * @return serialization hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHints#proxies()",
    "entityType": "method",
    "code": "/**\r\n * Provide access to proxy-based hints.\r\n * @return proxy hints\r\n */\r\npublic ProxyHints proxies() {\r\n    return this.proxies;\r\n}",
    "comment": "\n\t * Provide access to proxy-based hints.\n\t * @return proxy hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHints#jni()",
    "entityType": "method",
    "code": "/**\r\n * Provide access to jni-based hints.\r\n * @return jni hints\r\n */\r\npublic ReflectionHints jni() {\r\n    return this.jni;\r\n}",
    "comment": "\n\t * Provide access to jni-based hints.\n\t * @return jni hints\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHintsRegistrar",
    "entityType": "class",
    "code": "/**\r\n * Contribute hints to the given {@link RuntimeHints} instance.\r\n * @param hints the hints contributed so far for the deployment unit\r\n * @param classLoader the classloader, or {@code null} if even the system\r\n * ClassLoader is not accessible\r\n */\r\nvoid registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader);",
    "comment": "\n * Contract for registering {@link RuntimeHints} based on the {@link ClassLoader}\n * of the deployment unit. Implementations should, if possible, use the specified\n * {@link ClassLoader} to determine if hints have to be contributed.\n *\n * <p>Implementations of this interface can be registered dynamically by using\n * {@link org.springframework.context.annotation.ImportRuntimeHints @ImportRuntimeHints}\n * or statically in {@code META-INF/spring/aot.factories} by using the fully-qualified\n * class name of this interface as the key. A standard no-arg constructor is required\n * for implementations.\n *\n * @author Brian Clozel\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.RuntimeHintsRegistrar#registerHints(RuntimeHints,ClassLoader)",
    "entityType": "method",
    "code": "/**\r\n * Contribute hints to the given {@link RuntimeHints} instance.\r\n * @param hints the hints contributed so far for the deployment unit\r\n * @param classLoader the classloader, or {@code null} if even the system\r\n * ClassLoader is not accessible\r\n */\r\nvoid registerHints(RuntimeHints hints, @Nullable ClassLoader classLoader);",
    "comment": "\n\t * Contribute hints to the given {@link RuntimeHints} instance.\n\t * @param hints the hints contributed so far for the deployment unit\n\t * @param classLoader the classloader, or {@code null} if even the system\n\t * ClassLoader is not accessible\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.SerializationHints",
    "entityType": "class",
    "code": "private final Set<JavaSerializationHint> javaSerializationHints;\npublic SerializationHints() {\r\n    this.javaSerializationHints = new LinkedHashSet<>();\r\n}\n/**\r\n * Return the {@link JavaSerializationHint java serialization hints} for types\r\n * that need to be serialized using Java serialization at runtime.\r\n * @return a stream of {@link JavaSerializationHint java serialization hints}\r\n */\r\npublic Stream<JavaSerializationHint> javaSerializationHints() {\r\n    return this.javaSerializationHints.stream();\r\n}\n/**\r\n * Register that the type defined by the specified {@link TypeReference}\r\n * need to be serialized using java serialization.\r\n * @param type the type to register\r\n * @param serializationHint a builder to further customize the serialization\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(TypeReference type, @Nullable Consumer<JavaSerializationHint.Builder> serializationHint) {\r\n    JavaSerializationHint.Builder builder = new JavaSerializationHint.Builder(type);\r\n    if (serializationHint != null) {\r\n        serializationHint.accept(builder);\r\n    }\r\n    this.javaSerializationHints.add(builder.build());\r\n    return this;\r\n}\n/**\r\n * Register that the type defined by the specified {@link TypeReference}\r\n * need to be serialized using java serialization.\r\n * @param type the type to register\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(TypeReference type) {\r\n    return registerType(type, null);\r\n}\n/**\r\n * Register that the specified type need to be serialized using java\r\n * serialization.\r\n * @param type the type to register\r\n * @param serializationHint a builder to further customize the serialization\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(Class<? extends Serializable> type, @Nullable Consumer<JavaSerializationHint.Builder> serializationHint) {\r\n    return registerType(TypeReference.of(type), serializationHint);\r\n}\n/**\r\n * Register that the specified type need to be serialized using java\r\n * serialization.\r\n * @param type the type to register\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(Class<? extends Serializable> type) {\r\n    return registerType(type, null);\r\n}",
    "comment": "\n * Gather the need for Java serialization at runtime.\n *\n * @author Stephane Nicoll\n * @since 6.0\n * @see Serializable\n "
  },
  {
    "entityId": "org.springframework.aot.hint.SerializationHints#javaSerializationHints()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link JavaSerializationHint java serialization hints} for types\r\n * that need to be serialized using Java serialization at runtime.\r\n * @return a stream of {@link JavaSerializationHint java serialization hints}\r\n */\r\npublic Stream<JavaSerializationHint> javaSerializationHints() {\r\n    return this.javaSerializationHints.stream();\r\n}",
    "comment": "\n\t * Return the {@link JavaSerializationHint java serialization hints} for types\n\t * that need to be serialized using Java serialization at runtime.\n\t * @return a stream of {@link JavaSerializationHint java serialization hints}\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.SerializationHints#registerType(TypeReference,Consumer<JavaSerializationHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register that the type defined by the specified {@link TypeReference}\r\n * need to be serialized using java serialization.\r\n * @param type the type to register\r\n * @param serializationHint a builder to further customize the serialization\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(TypeReference type, @Nullable Consumer<JavaSerializationHint.Builder> serializationHint) {\r\n    JavaSerializationHint.Builder builder = new JavaSerializationHint.Builder(type);\r\n    if (serializationHint != null) {\r\n        serializationHint.accept(builder);\r\n    }\r\n    this.javaSerializationHints.add(builder.build());\r\n    return this;\r\n}",
    "comment": "\n\t * Register that the type defined by the specified {@link TypeReference}\n\t * need to be serialized using java serialization.\n\t * @param type the type to register\n\t * @param serializationHint a builder to further customize the serialization\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.SerializationHints#registerType(TypeReference)",
    "entityType": "method",
    "code": "/**\r\n * Register that the type defined by the specified {@link TypeReference}\r\n * need to be serialized using java serialization.\r\n * @param type the type to register\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(TypeReference type) {\r\n    return registerType(type, null);\r\n}",
    "comment": "\n\t * Register that the type defined by the specified {@link TypeReference}\n\t * need to be serialized using java serialization.\n\t * @param type the type to register\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.SerializationHints#registerType(Class<? extends Serializable>,Consumer<JavaSerializationHint.Builder>)",
    "entityType": "method",
    "code": "/**\r\n * Register that the specified type need to be serialized using java\r\n * serialization.\r\n * @param type the type to register\r\n * @param serializationHint a builder to further customize the serialization\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(Class<? extends Serializable> type, @Nullable Consumer<JavaSerializationHint.Builder> serializationHint) {\r\n    return registerType(TypeReference.of(type), serializationHint);\r\n}",
    "comment": "\n\t * Register that the specified type need to be serialized using java\n\t * serialization.\n\t * @param type the type to register\n\t * @param serializationHint a builder to further customize the serialization\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.aot.hint.SerializationHints#registerType(Class<? extends Serializable>)",
    "entityType": "method",
    "code": "/**\r\n * Register that the specified type need to be serialized using java\r\n * serialization.\r\n * @param type the type to register\r\n * @return {@code this}, to facilitate method chaining\r\n */\r\npublic SerializationHints registerType(Class<? extends Serializable> type) {\r\n    return registerType(type, null);\r\n}",
    "comment": "\n\t * Register that the specified type need to be serialized using java\n\t * serialization.\n\t * @param type the type to register\n\t * @return {@code this}, to facilitate method chaining\n\t "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests",
    "entityType": "class",
    "code": "private static final Comparator<? super String> NULL_SAFE_STRING_SORT = Comparators.nullsLow();\nprivate TestWeakConcurrentCache<Integer, String> map = new TestWeakConcurrentCache<>();\n@Test\r\nvoid shouldCreateWithDefaults() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>();\r\n    assertThat(map.getSegmentsSize()).isEqualTo(16);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(1);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.75f);\r\n}\n@Test\r\nvoid shouldCreateWithInitialCapacity() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(32);\r\n    assertThat(map.getSegmentsSize()).isEqualTo(16);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.75f);\r\n}\n@Test\r\nvoid shouldCreateWithInitialCapacityAndLoadFactor() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(32, 0.5f);\r\n    assertThat(map.getSegmentsSize()).isEqualTo(16);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.5f);\r\n}\n@Test\r\nvoid shouldCreateWithInitialCapacityAndConcurrentLevel() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(16, 2);\r\n    assertThat(map.getSegmentsSize()).isEqualTo(2);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(8);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.75f);\r\n}\n@Test\r\nvoid shouldCreateFullyCustom() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(5, 0.5f, 3);\r\n    // concurrencyLevel of 3 ends up as 4 (nearest power of 2)\r\n    assertThat(map.getSegmentsSize()).isEqualTo(4);\r\n    // initialCapacity is 5/4 (rounded up, to nearest power of 2)\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.5f);\r\n}\n@Test\r\nvoid shouldNeedNonNegativeInitialCapacity() {\r\n    assertThatNoException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(0, 1));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(-1, 1)).withMessageContaining(\"Initial capacity must not be negative\");\r\n}\n@Test\r\nvoid shouldNeedPositiveLoadFactor() {\r\n    assertThatNoException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(0, 0.1f, 1));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(0, 0.0f, 1)).withMessageContaining(\"Load factor must be positive\");\r\n}\n@Test\r\nvoid shouldNeedPositiveConcurrencyLevel() {\r\n    assertThatNoException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(1, 1));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(1, 0)).withMessageContaining(\"Concurrency level must be positive\");\r\n}\n@Test\r\nvoid shouldPutAndGet() {\r\n    // NOTE we are using mock references so we don't need to worry about GC\r\n    assertThat(this.map).isEmpty();\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map).hasSize(1);\r\n    this.map.put(123, \"123b\");\r\n    assertThat(this.map).hasSize(1);\r\n    this.map.put(123, null);\r\n    assertThat(this.map).hasSize(1);\r\n}\n@Test\r\nvoid shouldReplaceOnDoublePut() {\r\n    this.map.put(123, \"321\");\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n}\n@Test\r\nvoid shouldPutNullKey() {\r\n    assertThat(this.map.get(null)).isNull();\r\n    assertThat(this.map.getOrDefault(null, \"456\")).isEqualTo(\"456\");\r\n    this.map.put(null, \"123\");\r\n    assertThat(this.map.get(null)).isEqualTo(\"123\");\r\n    assertThat(this.map.getOrDefault(null, \"456\")).isEqualTo(\"123\");\r\n}\n@Test\r\nvoid shouldPutNullValue() {\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.getOrDefault(123, \"456\")).isEqualTo(\"456\");\r\n    this.map.put(123, \"321\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"321\");\r\n    assertThat(this.map.getOrDefault(123, \"456\")).isEqualTo(\"321\");\r\n    this.map.put(123, null);\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.getOrDefault(123, \"456\")).isNull();\r\n}\n@Test\r\nvoid shouldGetWithNoItems() {\r\n    assertThat(this.map.get(123)).isNull();\r\n}\n@Test\r\nvoid shouldApplySupplementalHash() {\r\n    Integer key = 123;\r\n    this.map.put(key, \"123\");\r\n    assertThat(this.map.getSupplementalHash()).isNotEqualTo(key.hashCode());\r\n    assertThat(this.map.getSupplementalHash() >> 30 & 0xFF).isNotEqualTo(0);\r\n}\n@Test\r\nvoid shouldGetFollowingNexts() {\r\n    // Use loadFactor to disable resize\r\n    this.map = new TestWeakConcurrentCache<>(1, 10.0f, 1);\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(1);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.get(3)).isEqualTo(\"3\");\r\n    assertThat(this.map.get(4)).isNull();\r\n}\n@Test\r\nvoid shouldResize() {\r\n    this.map = new TestWeakConcurrentCache<>(1, 0.75f, 1);\r\n    this.map.put(1, \"1\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(1);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    this.map.put(2, \"2\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    this.map.put(3, \"3\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(4);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.get(3)).isEqualTo(\"3\");\r\n    this.map.put(4, \"4\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(8);\r\n    assertThat(this.map.get(4)).isEqualTo(\"4\");\r\n    // Putting again should not increase the count\r\n    for (int i = 1; i <= 5; i++) {\r\n        this.map.put(i, String.valueOf(i));\r\n    }\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(8);\r\n    assertThat(this.map.get(5)).isEqualTo(\"5\");\r\n}\n@Test\r\nvoid shouldPurgeOnGet() {\r\n    this.map = new TestWeakConcurrentCache<>(1, 0.75f, 1);\r\n    for (int i = 1; i <= 5; i++) {\r\n        this.map.put(i, String.valueOf(i));\r\n    }\r\n    this.map.getMockReference(1, Restructure.NEVER).queueForPurge();\r\n    this.map.getMockReference(3, Restructure.NEVER).queueForPurge();\r\n    assertThat(this.map.getReference(1, Restructure.WHEN_NECESSARY)).isNull();\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.getReference(3, Restructure.WHEN_NECESSARY)).isNull();\r\n    assertThat(this.map.get(4)).isEqualTo(\"4\");\r\n    assertThat(this.map.get(5)).isEqualTo(\"5\");\r\n}\n@Test\r\nvoid shouldPurgeOnPut() {\r\n    this.map = new TestWeakConcurrentCache<>(1, 0.75f, 1);\r\n    for (int i = 1; i <= 5; i++) {\r\n        this.map.put(i, String.valueOf(i));\r\n    }\r\n    this.map.getMockReference(1, Restructure.NEVER).queueForPurge();\r\n    this.map.getMockReference(3, Restructure.NEVER).queueForPurge();\r\n    this.map.put(1, \"1\");\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.getReference(3, Restructure.WHEN_NECESSARY)).isNull();\r\n    assertThat(this.map.get(4)).isEqualTo(\"4\");\r\n    assertThat(this.map.get(5)).isEqualTo(\"5\");\r\n}\n@Test\r\nvoid shouldPutIfAbsent() {\r\n    assertThat(this.map.putIfAbsent(123, \"123\")).isNull();\r\n    assertThat(this.map.putIfAbsent(123, \"123b\")).isEqualTo(\"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n}\n@Test\r\nvoid shouldPutIfAbsentWithNullValue() {\r\n    assertThat(this.map.putIfAbsent(123, null)).isNull();\r\n    assertThat(this.map.putIfAbsent(123, \"123\")).isNull();\r\n    assertThat(this.map.get(123)).isNull();\r\n}\n@Test\r\nvoid shouldPutIfAbsentWithNullKey() {\r\n    assertThat(this.map.putIfAbsent(null, \"123\")).isNull();\r\n    assertThat(this.map.putIfAbsent(null, \"123b\")).isEqualTo(\"123\");\r\n    assertThat(this.map.get(null)).isEqualTo(\"123\");\r\n}\n@Test\r\nvoid shouldRemoveKeyAndValue() {\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.remove(123, \"456\")).isFalse();\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map.remove(123, \"123\")).isTrue();\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map).isEmpty();\r\n}\n@Test\r\nvoid shouldRemoveKeyAndValueWithExistingNull() {\r\n    this.map.put(123, null);\r\n    assertThat(this.map.remove(123, \"456\")).isFalse();\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.remove(123, null)).isTrue();\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map).isEmpty();\r\n}\n@Test\r\nvoid shouldReplaceOldValueWithNewValue() {\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.replace(123, \"456\", \"789\")).isFalse();\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map.replace(123, \"123\", \"789\")).isTrue();\r\n    assertThat(this.map.get(123)).isEqualTo(\"789\");\r\n}\n@Test\r\nvoid shouldReplaceOldNullValueWithNewValue() {\r\n    this.map.put(123, null);\r\n    assertThat(this.map.replace(123, \"456\", \"789\")).isFalse();\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.replace(123, null, \"789\")).isTrue();\r\n    assertThat(this.map.get(123)).isEqualTo(\"789\");\r\n}\n@Test\r\nvoid shouldReplaceValue() {\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.replace(123, \"456\")).isEqualTo(\"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"456\");\r\n}\n@Test\r\nvoid shouldReplaceNullValue() {\r\n    this.map.put(123, null);\r\n    assertThat(this.map.replace(123, \"456\")).isNull();\r\n    assertThat(this.map.get(123)).isEqualTo(\"456\");\r\n}\n@Test\r\nvoid shouldGetSize() {\r\n    assertThat(this.map).isEmpty();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(123, null);\r\n    this.map.put(456, \"456\");\r\n    assertThat(this.map).hasSize(2);\r\n}\n@Test\r\nvoid shouldSupportIsEmpty() {\r\n    assertThat(this.map).isEmpty();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(123, null);\r\n    this.map.put(456, \"456\");\r\n    assertThat(this.map).isNotEmpty();\r\n}\n@Test\r\nvoid shouldContainKey() {\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map.containsKey(456)).isFalse();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    assertThat(this.map.containsKey(123)).isTrue();\r\n    assertThat(this.map.containsKey(456)).isTrue();\r\n}\n@Test\r\nvoid shouldContainValue() {\r\n    assertThat(this.map.containsValue(\"123\")).isFalse();\r\n    assertThat(this.map.containsValue(null)).isFalse();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    assertThat(this.map.containsValue(\"123\")).isTrue();\r\n    assertThat(this.map.containsValue(null)).isTrue();\r\n}\n@Test\r\nvoid shouldRemoveWhenKeyIsInMap() {\r\n    this.map.put(123, null);\r\n    this.map.put(456, \"456\");\r\n    this.map.put(null, \"789\");\r\n    assertThat(this.map.remove(123)).isNull();\r\n    assertThat(this.map.remove(456)).isEqualTo(\"456\");\r\n    assertThat(this.map.remove(null)).isEqualTo(\"789\");\r\n    assertThat(this.map).isEmpty();\r\n}\n@Test\r\nvoid shouldRemoveWhenKeyIsNotInMap() {\r\n    assertThat(this.map.remove(123)).isNull();\r\n    assertThat(this.map.remove(null)).isNull();\r\n    assertThat(this.map).isEmpty();\r\n}\n@Test\r\nvoid shouldPutAll() {\r\n    Map<Integer, String> m = new HashMap<>();\r\n    m.put(123, \"123\");\r\n    m.put(456, null);\r\n    m.put(null, \"789\");\r\n    this.map.putAll(m);\r\n    assertThat(this.map).hasSize(3);\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map.get(456)).isNull();\r\n    assertThat(this.map.get(null)).isEqualTo(\"789\");\r\n}\n@Test\r\nvoid shouldClear() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    this.map.clear();\r\n    assertThat(this.map).isEmpty();\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map.containsKey(456)).isFalse();\r\n    assertThat(this.map.containsKey(null)).isFalse();\r\n}\n@Test\r\nvoid shouldGetKeySet() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    Set<Integer> expected = new HashSet<>();\r\n    expected.add(123);\r\n    expected.add(456);\r\n    expected.add(null);\r\n    assertThat(this.map.keySet()).isEqualTo(expected);\r\n}\n@Test\r\nvoid shouldGetValues() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    List<String> actual = new ArrayList<>(this.map.values());\r\n    List<String> expected = new ArrayList<>();\r\n    expected.add(\"123\");\r\n    expected.add(null);\r\n    expected.add(\"789\");\r\n    actual.sort(NULL_SAFE_STRING_SORT);\r\n    expected.sort(NULL_SAFE_STRING_SORT);\r\n    assertThat(actual).isEqualTo(expected);\r\n}\n@Test\r\nvoid shouldGetEntrySet() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    HashMap<Integer, String> expected = new HashMap<>();\r\n    expected.put(123, \"123\");\r\n    expected.put(456, null);\r\n    expected.put(null, \"789\");\r\n    assertThat(this.map.entrySet()).isEqualTo(expected.entrySet());\r\n}\n@Test\r\nvoid shouldGetEntrySetFollowingNext() {\r\n    // Use loadFactor to disable resize\r\n    this.map = new TestWeakConcurrentCache<>(1, 10.0f, 1);\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    HashMap<Integer, String> expected = new HashMap<>();\r\n    expected.put(1, \"1\");\r\n    expected.put(2, \"2\");\r\n    expected.put(3, \"3\");\r\n    assertThat(this.map.entrySet()).isEqualTo(expected.entrySet());\r\n}\n@Test\r\nvoid shouldRemoveViaEntrySet() {\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    Iterator<Map.Entry<Integer, String>> iterator = this.map.entrySet().iterator();\r\n    iterator.next();\r\n    iterator.next();\r\n    iterator.remove();\r\n    assertThatIllegalStateException().isThrownBy(iterator::remove);\r\n    iterator.next();\r\n    assertThat(iterator.hasNext()).isFalse();\r\n    assertThat(this.map).hasSize(2);\r\n    assertThat(this.map.containsKey(2)).isFalse();\r\n}\n@Test\r\nvoid shouldSetViaEntrySet() {\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    Iterator<Map.Entry<Integer, String>> iterator = this.map.entrySet().iterator();\r\n    iterator.next();\r\n    iterator.next().setValue(\"2b\");\r\n    iterator.next();\r\n    assertThat(iterator.hasNext()).isFalse();\r\n    assertThat(this.map).hasSize(3);\r\n    assertThat(this.map.get(2)).isEqualTo(\"2b\");\r\n}\n@Test\r\nvoid containsViaEntrySet() {\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    Set<Map.Entry<Integer, String>> entrySet = this.map.entrySet();\r\n    Set<Map.Entry<Integer, String>> copy = new HashMap<>(this.map).entrySet();\r\n    copy.forEach(entry -> assertThat(entrySet).contains(entry));\r\n    this.map.put(1, \"A\");\r\n    this.map.put(2, \"B\");\r\n    this.map.put(3, \"C\");\r\n    copy.forEach(entry -> assertThat(entrySet).doesNotContain(entry));\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    copy.forEach(entry -> assertThat(entrySet).contains(entry));\r\n    entrySet.clear();\r\n    copy.forEach(entry -> assertThat(entrySet).doesNotContain(entry));\r\n}\n@Test\r\nvoid shouldSupportNullReference() {\r\n    // GC could happen during restructure so we must be able to create a reference for a null entry\r\n    map.createReferenceManager().createReference(null, 1234, null);\r\n}\nprivate static class TestWeakConcurrentCache<K, V> extends ConcurrentReferenceHashMap<K, V> {\r\n\r\n    private int supplementalHash;\r\n\r\n    private final LinkedList<MockReference<K, V>> queue = new LinkedList<>();\r\n\r\n    public TestWeakConcurrentCache() {\r\n        super();\r\n    }\r\n\r\n    public TestWeakConcurrentCache(int initialCapacity, float loadFactor, int concurrencyLevel) {\r\n        super(initialCapacity, loadFactor, concurrencyLevel);\r\n    }\r\n\r\n    @Override\r\n    protected int getHash(@Nullable Object o) {\r\n        // For testing we want more control of the hash\r\n        this.supplementalHash = super.getHash(o);\r\n        return (o != null ? o.hashCode() : 0);\r\n    }\r\n\r\n    public int getSupplementalHash() {\r\n        return this.supplementalHash;\r\n    }\r\n\r\n    @Override\r\n    protected ReferenceManager createReferenceManager() {\r\n        return new ReferenceManager() {\r\n\r\n            @Override\r\n            public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\r\n                return new MockReference<>(entry, hash, next, TestWeakConcurrentCache.this.queue);\r\n            }\r\n\r\n            @Override\r\n            public Reference<K, V> pollForPurge() {\r\n                return TestWeakConcurrentCache.this.queue.isEmpty() ? null : TestWeakConcurrentCache.this.queue.removeFirst();\r\n            }\r\n        };\r\n    }\r\n\r\n    public MockReference<K, V> getMockReference(K key, Restructure restructure) {\r\n        return (MockReference<K, V>) super.getReference(key, restructure);\r\n    }\r\n}\nprivate static class MockReference<K, V> implements Reference<K, V> {\r\n\r\n    private final int hash;\r\n\r\n    private Entry<K, V> entry;\r\n\r\n    private final Reference<K, V> next;\r\n\r\n    private final LinkedList<MockReference<K, V>> queue;\r\n\r\n    public MockReference(Entry<K, V> entry, int hash, Reference<K, V> next, LinkedList<MockReference<K, V>> queue) {\r\n        this.hash = hash;\r\n        this.entry = entry;\r\n        this.next = next;\r\n        this.queue = queue;\r\n    }\r\n\r\n    @Override\r\n    public Entry<K, V> get() {\r\n        return this.entry;\r\n    }\r\n\r\n    @Override\r\n    public int getHash() {\r\n        return this.hash;\r\n    }\r\n\r\n    @Override\r\n    public Reference<K, V> getNext() {\r\n        return this.next;\r\n    }\r\n\r\n    @Override\r\n    public void release() {\r\n        this.queue.add(this);\r\n        this.entry = null;\r\n    }\r\n\r\n    public void queueForPurge() {\r\n        this.queue.add(this);\r\n    }\r\n}",
    "comment": "\n * Tests for {@link ConcurrentReferenceHashMap}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldCreateWithDefaults()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCreateWithDefaults() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>();\r\n    assertThat(map.getSegmentsSize()).isEqualTo(16);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(1);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.75f);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldCreateWithInitialCapacity()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCreateWithInitialCapacity() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(32);\r\n    assertThat(map.getSegmentsSize()).isEqualTo(16);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.75f);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldCreateWithInitialCapacityAndLoadFactor()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCreateWithInitialCapacityAndLoadFactor() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(32, 0.5f);\r\n    assertThat(map.getSegmentsSize()).isEqualTo(16);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.5f);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldCreateWithInitialCapacityAndConcurrentLevel()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCreateWithInitialCapacityAndConcurrentLevel() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(16, 2);\r\n    assertThat(map.getSegmentsSize()).isEqualTo(2);\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(8);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.75f);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldCreateFullyCustom()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldCreateFullyCustom() {\r\n    ConcurrentReferenceHashMap<Integer, String> map = new ConcurrentReferenceHashMap<>(5, 0.5f, 3);\r\n    // concurrencyLevel of 3 ends up as 4 (nearest power of 2)\r\n    assertThat(map.getSegmentsSize()).isEqualTo(4);\r\n    // initialCapacity is 5/4 (rounded up, to nearest power of 2)\r\n    assertThat(map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(map.getLoadFactor()).isEqualTo(0.5f);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldNeedNonNegativeInitialCapacity()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldNeedNonNegativeInitialCapacity() {\r\n    assertThatNoException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(0, 1));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(-1, 1)).withMessageContaining(\"Initial capacity must not be negative\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldNeedPositiveLoadFactor()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldNeedPositiveLoadFactor() {\r\n    assertThatNoException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(0, 0.1f, 1));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(0, 0.0f, 1)).withMessageContaining(\"Load factor must be positive\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldNeedPositiveConcurrencyLevel()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldNeedPositiveConcurrencyLevel() {\r\n    assertThatNoException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(1, 1));\r\n    assertThatIllegalArgumentException().isThrownBy(() -> new ConcurrentReferenceHashMap<Integer, String>(1, 0)).withMessageContaining(\"Concurrency level must be positive\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutAndGet()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutAndGet() {\r\n    // NOTE we are using mock references so we don't need to worry about GC\r\n    assertThat(this.map).isEmpty();\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map).hasSize(1);\r\n    this.map.put(123, \"123b\");\r\n    assertThat(this.map).hasSize(1);\r\n    this.map.put(123, null);\r\n    assertThat(this.map).hasSize(1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldReplaceOnDoublePut()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldReplaceOnDoublePut() {\r\n    this.map.put(123, \"321\");\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutNullKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutNullKey() {\r\n    assertThat(this.map.get(null)).isNull();\r\n    assertThat(this.map.getOrDefault(null, \"456\")).isEqualTo(\"456\");\r\n    this.map.put(null, \"123\");\r\n    assertThat(this.map.get(null)).isEqualTo(\"123\");\r\n    assertThat(this.map.getOrDefault(null, \"456\")).isEqualTo(\"123\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutNullValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutNullValue() {\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.getOrDefault(123, \"456\")).isEqualTo(\"456\");\r\n    this.map.put(123, \"321\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"321\");\r\n    assertThat(this.map.getOrDefault(123, \"456\")).isEqualTo(\"321\");\r\n    this.map.put(123, null);\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.getOrDefault(123, \"456\")).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetWithNoItems()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetWithNoItems() {\r\n    assertThat(this.map.get(123)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldApplySupplementalHash()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldApplySupplementalHash() {\r\n    Integer key = 123;\r\n    this.map.put(key, \"123\");\r\n    assertThat(this.map.getSupplementalHash()).isNotEqualTo(key.hashCode());\r\n    assertThat(this.map.getSupplementalHash() >> 30 & 0xFF).isNotEqualTo(0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetFollowingNexts()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetFollowingNexts() {\r\n    // Use loadFactor to disable resize\r\n    this.map = new TestWeakConcurrentCache<>(1, 10.0f, 1);\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(1);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.get(3)).isEqualTo(\"3\");\r\n    assertThat(this.map.get(4)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldResize()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldResize() {\r\n    this.map = new TestWeakConcurrentCache<>(1, 0.75f, 1);\r\n    this.map.put(1, \"1\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(1);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    this.map.put(2, \"2\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(2);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    this.map.put(3, \"3\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(4);\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.get(3)).isEqualTo(\"3\");\r\n    this.map.put(4, \"4\");\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(8);\r\n    assertThat(this.map.get(4)).isEqualTo(\"4\");\r\n    // Putting again should not increase the count\r\n    for (int i = 1; i <= 5; i++) {\r\n        this.map.put(i, String.valueOf(i));\r\n    }\r\n    assertThat(this.map.getSegment(0).getSize()).isEqualTo(8);\r\n    assertThat(this.map.get(5)).isEqualTo(\"5\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPurgeOnGet()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPurgeOnGet() {\r\n    this.map = new TestWeakConcurrentCache<>(1, 0.75f, 1);\r\n    for (int i = 1; i <= 5; i++) {\r\n        this.map.put(i, String.valueOf(i));\r\n    }\r\n    this.map.getMockReference(1, Restructure.NEVER).queueForPurge();\r\n    this.map.getMockReference(3, Restructure.NEVER).queueForPurge();\r\n    assertThat(this.map.getReference(1, Restructure.WHEN_NECESSARY)).isNull();\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.getReference(3, Restructure.WHEN_NECESSARY)).isNull();\r\n    assertThat(this.map.get(4)).isEqualTo(\"4\");\r\n    assertThat(this.map.get(5)).isEqualTo(\"5\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPurgeOnPut()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPurgeOnPut() {\r\n    this.map = new TestWeakConcurrentCache<>(1, 0.75f, 1);\r\n    for (int i = 1; i <= 5; i++) {\r\n        this.map.put(i, String.valueOf(i));\r\n    }\r\n    this.map.getMockReference(1, Restructure.NEVER).queueForPurge();\r\n    this.map.getMockReference(3, Restructure.NEVER).queueForPurge();\r\n    this.map.put(1, \"1\");\r\n    assertThat(this.map.get(1)).isEqualTo(\"1\");\r\n    assertThat(this.map.get(2)).isEqualTo(\"2\");\r\n    assertThat(this.map.getReference(3, Restructure.WHEN_NECESSARY)).isNull();\r\n    assertThat(this.map.get(4)).isEqualTo(\"4\");\r\n    assertThat(this.map.get(5)).isEqualTo(\"5\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutIfAbsent()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutIfAbsent() {\r\n    assertThat(this.map.putIfAbsent(123, \"123\")).isNull();\r\n    assertThat(this.map.putIfAbsent(123, \"123b\")).isEqualTo(\"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutIfAbsentWithNullValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutIfAbsentWithNullValue() {\r\n    assertThat(this.map.putIfAbsent(123, null)).isNull();\r\n    assertThat(this.map.putIfAbsent(123, \"123\")).isNull();\r\n    assertThat(this.map.get(123)).isNull();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutIfAbsentWithNullKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutIfAbsentWithNullKey() {\r\n    assertThat(this.map.putIfAbsent(null, \"123\")).isNull();\r\n    assertThat(this.map.putIfAbsent(null, \"123b\")).isEqualTo(\"123\");\r\n    assertThat(this.map.get(null)).isEqualTo(\"123\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldRemoveKeyAndValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldRemoveKeyAndValue() {\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.remove(123, \"456\")).isFalse();\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map.remove(123, \"123\")).isTrue();\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldRemoveKeyAndValueWithExistingNull()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldRemoveKeyAndValueWithExistingNull() {\r\n    this.map.put(123, null);\r\n    assertThat(this.map.remove(123, \"456\")).isFalse();\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.remove(123, null)).isTrue();\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldReplaceOldValueWithNewValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldReplaceOldValueWithNewValue() {\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.replace(123, \"456\", \"789\")).isFalse();\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map.replace(123, \"123\", \"789\")).isTrue();\r\n    assertThat(this.map.get(123)).isEqualTo(\"789\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldReplaceOldNullValueWithNewValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldReplaceOldNullValueWithNewValue() {\r\n    this.map.put(123, null);\r\n    assertThat(this.map.replace(123, \"456\", \"789\")).isFalse();\r\n    assertThat(this.map.get(123)).isNull();\r\n    assertThat(this.map.replace(123, null, \"789\")).isTrue();\r\n    assertThat(this.map.get(123)).isEqualTo(\"789\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldReplaceValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldReplaceValue() {\r\n    this.map.put(123, \"123\");\r\n    assertThat(this.map.replace(123, \"456\")).isEqualTo(\"123\");\r\n    assertThat(this.map.get(123)).isEqualTo(\"456\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldReplaceNullValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldReplaceNullValue() {\r\n    this.map.put(123, null);\r\n    assertThat(this.map.replace(123, \"456\")).isNull();\r\n    assertThat(this.map.get(123)).isEqualTo(\"456\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetSize()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetSize() {\r\n    assertThat(this.map).isEmpty();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(123, null);\r\n    this.map.put(456, \"456\");\r\n    assertThat(this.map).hasSize(2);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldSupportIsEmpty()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldSupportIsEmpty() {\r\n    assertThat(this.map).isEmpty();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(123, null);\r\n    this.map.put(456, \"456\");\r\n    assertThat(this.map).isNotEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldContainKey()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldContainKey() {\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map.containsKey(456)).isFalse();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    assertThat(this.map.containsKey(123)).isTrue();\r\n    assertThat(this.map.containsKey(456)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldContainValue()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldContainValue() {\r\n    assertThat(this.map.containsValue(\"123\")).isFalse();\r\n    assertThat(this.map.containsValue(null)).isFalse();\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    assertThat(this.map.containsValue(\"123\")).isTrue();\r\n    assertThat(this.map.containsValue(null)).isTrue();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldRemoveWhenKeyIsInMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldRemoveWhenKeyIsInMap() {\r\n    this.map.put(123, null);\r\n    this.map.put(456, \"456\");\r\n    this.map.put(null, \"789\");\r\n    assertThat(this.map.remove(123)).isNull();\r\n    assertThat(this.map.remove(456)).isEqualTo(\"456\");\r\n    assertThat(this.map.remove(null)).isEqualTo(\"789\");\r\n    assertThat(this.map).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldRemoveWhenKeyIsNotInMap()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldRemoveWhenKeyIsNotInMap() {\r\n    assertThat(this.map.remove(123)).isNull();\r\n    assertThat(this.map.remove(null)).isNull();\r\n    assertThat(this.map).isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldPutAll()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldPutAll() {\r\n    Map<Integer, String> m = new HashMap<>();\r\n    m.put(123, \"123\");\r\n    m.put(456, null);\r\n    m.put(null, \"789\");\r\n    this.map.putAll(m);\r\n    assertThat(this.map).hasSize(3);\r\n    assertThat(this.map.get(123)).isEqualTo(\"123\");\r\n    assertThat(this.map.get(456)).isNull();\r\n    assertThat(this.map.get(null)).isEqualTo(\"789\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldClear()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldClear() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    this.map.clear();\r\n    assertThat(this.map).isEmpty();\r\n    assertThat(this.map.containsKey(123)).isFalse();\r\n    assertThat(this.map.containsKey(456)).isFalse();\r\n    assertThat(this.map.containsKey(null)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetKeySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetKeySet() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    Set<Integer> expected = new HashSet<>();\r\n    expected.add(123);\r\n    expected.add(456);\r\n    expected.add(null);\r\n    assertThat(this.map.keySet()).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetValues()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetValues() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    List<String> actual = new ArrayList<>(this.map.values());\r\n    List<String> expected = new ArrayList<>();\r\n    expected.add(\"123\");\r\n    expected.add(null);\r\n    expected.add(\"789\");\r\n    actual.sort(NULL_SAFE_STRING_SORT);\r\n    expected.sort(NULL_SAFE_STRING_SORT);\r\n    assertThat(actual).isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetEntrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetEntrySet() {\r\n    this.map.put(123, \"123\");\r\n    this.map.put(456, null);\r\n    this.map.put(null, \"789\");\r\n    HashMap<Integer, String> expected = new HashMap<>();\r\n    expected.put(123, \"123\");\r\n    expected.put(456, null);\r\n    expected.put(null, \"789\");\r\n    assertThat(this.map.entrySet()).isEqualTo(expected.entrySet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldGetEntrySetFollowingNext()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldGetEntrySetFollowingNext() {\r\n    // Use loadFactor to disable resize\r\n    this.map = new TestWeakConcurrentCache<>(1, 10.0f, 1);\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    HashMap<Integer, String> expected = new HashMap<>();\r\n    expected.put(1, \"1\");\r\n    expected.put(2, \"2\");\r\n    expected.put(3, \"3\");\r\n    assertThat(this.map.entrySet()).isEqualTo(expected.entrySet());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldRemoveViaEntrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldRemoveViaEntrySet() {\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    Iterator<Map.Entry<Integer, String>> iterator = this.map.entrySet().iterator();\r\n    iterator.next();\r\n    iterator.next();\r\n    iterator.remove();\r\n    assertThatIllegalStateException().isThrownBy(iterator::remove);\r\n    iterator.next();\r\n    assertThat(iterator.hasNext()).isFalse();\r\n    assertThat(this.map).hasSize(2);\r\n    assertThat(this.map.containsKey(2)).isFalse();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldSetViaEntrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldSetViaEntrySet() {\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    Iterator<Map.Entry<Integer, String>> iterator = this.map.entrySet().iterator();\r\n    iterator.next();\r\n    iterator.next().setValue(\"2b\");\r\n    iterator.next();\r\n    assertThat(iterator.hasNext()).isFalse();\r\n    assertThat(this.map).hasSize(3);\r\n    assertThat(this.map.get(2)).isEqualTo(\"2b\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#containsViaEntrySet()",
    "entityType": "method",
    "code": "@Test\r\nvoid containsViaEntrySet() {\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    Set<Map.Entry<Integer, String>> entrySet = this.map.entrySet();\r\n    Set<Map.Entry<Integer, String>> copy = new HashMap<>(this.map).entrySet();\r\n    copy.forEach(entry -> assertThat(entrySet).contains(entry));\r\n    this.map.put(1, \"A\");\r\n    this.map.put(2, \"B\");\r\n    this.map.put(3, \"C\");\r\n    copy.forEach(entry -> assertThat(entrySet).doesNotContain(entry));\r\n    this.map.put(1, \"1\");\r\n    this.map.put(2, \"2\");\r\n    this.map.put(3, \"3\");\r\n    copy.forEach(entry -> assertThat(entrySet).contains(entry));\r\n    entrySet.clear();\r\n    copy.forEach(entry -> assertThat(entrySet).doesNotContain(entry));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.ConcurrentReferenceHashMapTests#shouldSupportNullReference()",
    "entityType": "method",
    "code": "@Test\r\nvoid shouldSupportNullReference() {\r\n    // GC could happen during restructure so we must be able to create a reference for a null entry\r\n    map.createReferenceManager().createReference(null, 1234, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TestWeakConcurrentCache",
    "entityType": "class",
    "code": "private int supplementalHash;\nprivate final LinkedList<MockReference<K, V>> queue = new LinkedList<>();\npublic TestWeakConcurrentCache() {\r\n    super();\r\n}\npublic TestWeakConcurrentCache(int initialCapacity, float loadFactor, int concurrencyLevel) {\r\n    super(initialCapacity, loadFactor, concurrencyLevel);\r\n}\n@Override\r\nprotected int getHash(@Nullable Object o) {\r\n    // For testing we want more control of the hash\r\n    this.supplementalHash = super.getHash(o);\r\n    return (o != null ? o.hashCode() : 0);\r\n}\npublic int getSupplementalHash() {\r\n    return this.supplementalHash;\r\n}\n@Override\r\nprotected ReferenceManager createReferenceManager() {\r\n    return new ReferenceManager() {\r\n\r\n        @Override\r\n        public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\r\n            return new MockReference<>(entry, hash, next, TestWeakConcurrentCache.this.queue);\r\n        }\r\n\r\n        @Override\r\n        public Reference<K, V> pollForPurge() {\r\n            return TestWeakConcurrentCache.this.queue.isEmpty() ? null : TestWeakConcurrentCache.this.queue.removeFirst();\r\n        }\r\n    };\r\n}\npublic MockReference<K, V> getMockReference(K key, Restructure restructure) {\r\n    return (MockReference<K, V>) super.getReference(key, restructure);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TestWeakConcurrentCache#getHash(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected int getHash(@Nullable Object o) {\r\n    // For testing we want more control of the hash\r\n    this.supplementalHash = super.getHash(o);\r\n    return (o != null ? o.hashCode() : 0);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TestWeakConcurrentCache#getSupplementalHash()",
    "entityType": "method",
    "code": "public int getSupplementalHash() {\r\n    return this.supplementalHash;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TestWeakConcurrentCache#createReferenceManager()",
    "entityType": "method",
    "code": "@Override\r\nprotected ReferenceManager createReferenceManager() {\r\n    return new ReferenceManager() {\r\n\r\n        @Override\r\n        public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\r\n            return new MockReference<>(entry, hash, next, TestWeakConcurrentCache.this.queue);\r\n        }\r\n\r\n        @Override\r\n        public Reference<K, V> pollForPurge() {\r\n            return TestWeakConcurrentCache.this.queue.isEmpty() ? null : TestWeakConcurrentCache.this.queue.removeFirst();\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.TestWeakConcurrentCache#getMockReference(K,Restructure)",
    "entityType": "method",
    "code": "public MockReference<K, V> getMockReference(K key, Restructure restructure) {\r\n    return (MockReference<K, V>) super.getReference(key, restructure);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockReference",
    "entityType": "class",
    "code": "private final int hash;\nprivate Entry<K, V> entry;\nprivate final Reference<K, V> next;\nprivate final LinkedList<MockReference<K, V>> queue;\npublic MockReference(Entry<K, V> entry, int hash, Reference<K, V> next, LinkedList<MockReference<K, V>> queue) {\r\n    this.hash = hash;\r\n    this.entry = entry;\r\n    this.next = next;\r\n    this.queue = queue;\r\n}\n@Override\r\npublic Entry<K, V> get() {\r\n    return this.entry;\r\n}\n@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}\n@Override\r\npublic Reference<K, V> getNext() {\r\n    return this.next;\r\n}\n@Override\r\npublic void release() {\r\n    this.queue.add(this);\r\n    this.entry = null;\r\n}\npublic void queueForPurge() {\r\n    this.queue.add(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockReference#get()",
    "entityType": "method",
    "code": "@Override\r\npublic Entry<K, V> get() {\r\n    return this.entry;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockReference#getHash()",
    "entityType": "method",
    "code": "@Override\r\npublic int getHash() {\r\n    return this.hash;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockReference#getNext()",
    "entityType": "method",
    "code": "@Override\r\npublic Reference<K, V> getNext() {\r\n    return this.next;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockReference#release()",
    "entityType": "method",
    "code": "@Override\r\npublic void release() {\r\n    this.queue.add(this);\r\n    this.entry = null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MockReference#queueForPurge()",
    "entityType": "method",
    "code": "public void queueForPurge() {\r\n    this.queue.add(this);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtilsTests",
    "entityType": "class",
    "code": "private byte[] bytes;\n@BeforeEach\r\nvoid createBytes() throws UnsupportedEncodingException {\r\n    bytes = \"Hello World\".getBytes(StandardCharsets.UTF_8);\r\n}\n@Test\r\nvoid md5() throws IOException {\r\n    byte[] expected = new byte[] { -0x4f, 0xa, -0x73, -0x4f, 0x64, -0x20, 0x75, 0x41, 0x5, -0x49, -0x57, -0x65, -0x19, 0x2e, 0x3f, -0x1b };\r\n    byte[] result = DigestUtils.md5Digest(bytes);\r\n    assertThat(result).as(\"Invalid hash\").isEqualTo(expected);\r\n    result = DigestUtils.md5Digest(new ByteArrayInputStream(bytes));\r\n    assertThat(result).as(\"Invalid hash\").isEqualTo(expected);\r\n}\n@Test\r\nvoid md5Hex() throws IOException {\r\n    String expected = \"b10a8db164e0754105b7a99be72e3fe5\";\r\n    String hash = DigestUtils.md5DigestAsHex(bytes);\r\n    assertThat(hash).as(\"Invalid hash\").isEqualTo(expected);\r\n    hash = DigestUtils.md5DigestAsHex(new ByteArrayInputStream(bytes));\r\n    assertThat(hash).as(\"Invalid hash\").isEqualTo(expected);\r\n}\n@Test\r\nvoid md5StringBuilder() throws IOException {\r\n    String expected = \"b10a8db164e0754105b7a99be72e3fe5\";\r\n    StringBuilder builder = new StringBuilder();\r\n    DigestUtils.appendMd5DigestAsHex(bytes, builder);\r\n    assertThat(builder.toString()).as(\"Invalid hash\").isEqualTo(expected);\r\n    builder = new StringBuilder();\r\n    DigestUtils.appendMd5DigestAsHex(new ByteArrayInputStream(bytes), builder);\r\n    assertThat(builder.toString()).as(\"Invalid hash\").isEqualTo(expected);\r\n}",
    "comment": "\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n "
  },
  {
    "entityId": "org.springframework.util.DigestUtilsTests#createBytes()",
    "entityType": "method",
    "code": "@BeforeEach\r\nvoid createBytes() throws UnsupportedEncodingException {\r\n    bytes = \"Hello World\".getBytes(StandardCharsets.UTF_8);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtilsTests#md5()",
    "entityType": "method",
    "code": "@Test\r\nvoid md5() throws IOException {\r\n    byte[] expected = new byte[] { -0x4f, 0xa, -0x73, -0x4f, 0x64, -0x20, 0x75, 0x41, 0x5, -0x49, -0x57, -0x65, -0x19, 0x2e, 0x3f, -0x1b };\r\n    byte[] result = DigestUtils.md5Digest(bytes);\r\n    assertThat(result).as(\"Invalid hash\").isEqualTo(expected);\r\n    result = DigestUtils.md5Digest(new ByteArrayInputStream(bytes));\r\n    assertThat(result).as(\"Invalid hash\").isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtilsTests#md5Hex()",
    "entityType": "method",
    "code": "@Test\r\nvoid md5Hex() throws IOException {\r\n    String expected = \"b10a8db164e0754105b7a99be72e3fe5\";\r\n    String hash = DigestUtils.md5DigestAsHex(bytes);\r\n    assertThat(hash).as(\"Invalid hash\").isEqualTo(expected);\r\n    hash = DigestUtils.md5DigestAsHex(new ByteArrayInputStream(bytes));\r\n    assertThat(hash).as(\"Invalid hash\").isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.DigestUtilsTests#md5StringBuilder()",
    "entityType": "method",
    "code": "@Test\r\nvoid md5StringBuilder() throws IOException {\r\n    String expected = \"b10a8db164e0754105b7a99be72e3fe5\";\r\n    StringBuilder builder = new StringBuilder();\r\n    DigestUtils.appendMd5DigestAsHex(bytes, builder);\r\n    assertThat(builder.toString()).as(\"Invalid hash\").isEqualTo(expected);\r\n    builder = new StringBuilder();\r\n    DigestUtils.appendMd5DigestAsHex(new ByteArrayInputStream(bytes), builder);\r\n    assertThat(builder.toString()).as(\"Invalid hash\").isEqualTo(expected);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference",
    "entityType": "class",
    "code": "private static final List<String> PRIMITIVE_NAMES = List.of(\"boolean\", \"byte\", \"short\", \"int\", \"long\", \"char\", \"float\", \"double\", \"void\");\n@Nullable\r\nprivate String canonicalName;\nSimpleTypeReference(String packageName, String simpleName, @Nullable TypeReference enclosingType) {\r\n    super(packageName, simpleName, enclosingType);\r\n}\nstatic SimpleTypeReference of(String className) {\r\n    Assert.notNull(className, \"'className' must not be null\");\r\n    if (!isValidClassName(className)) {\r\n        throw new IllegalStateException(\"Invalid class name '\" + className + \"'\");\r\n    }\r\n    if (!className.contains(\"$\")) {\r\n        return createTypeReference(className);\r\n    }\r\n    String[] elements = className.split(\"(?<!\\\\$)\\\\$(?!\\\\$)\");\r\n    SimpleTypeReference typeReference = createTypeReference(elements[0]);\r\n    for (int i = 1; i < elements.length; i++) {\r\n        typeReference = new SimpleTypeReference(typeReference.getPackageName(), elements[i], typeReference);\r\n    }\r\n    return typeReference;\r\n}\nprivate static boolean isValidClassName(String className) {\r\n    for (String s : className.split(\"\\\\.\", -1)) {\r\n        String candidate = s.replace(\"[\", \"\").replace(\"]\", \"\");\r\n        if (!SourceVersion.isIdentifier(candidate)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\nprivate static SimpleTypeReference createTypeReference(String className) {\r\n    int i = className.lastIndexOf('.');\r\n    if (i != -1) {\r\n        return new SimpleTypeReference(className.substring(0, i), className.substring(i + 1), null);\r\n    } else {\r\n        String packageName = (isPrimitive(className) ? \"java.lang\" : \"\");\r\n        return new SimpleTypeReference(packageName, className, null);\r\n    }\r\n}\n@Override\r\npublic String getCanonicalName() {\r\n    if (this.canonicalName == null) {\r\n        StringBuilder names = new StringBuilder();\r\n        buildName(this, names);\r\n        this.canonicalName = addPackageIfNecessary(names.toString());\r\n    }\r\n    return this.canonicalName;\r\n}\n@Override\r\nprotected boolean isPrimitive() {\r\n    return isPrimitive(getSimpleName());\r\n}\nprivate static boolean isPrimitive(String name) {\r\n    return PRIMITIVE_NAMES.stream().anyMatch(name::startsWith);\r\n}\nprivate static void buildName(@Nullable TypeReference type, StringBuilder sb) {\r\n    if (type == null) {\r\n        return;\r\n    }\r\n    String typeName = (type.getEnclosingType() != null ? \".\" + type.getSimpleName() : type.getSimpleName());\r\n    sb.insert(0, typeName);\r\n    buildName(type.getEnclosingType(), sb);\r\n}",
    "comment": "\n * A {@link TypeReference} based on fully qualified name.\n *\n * @author Stephane Nicoll\n * @since 6.0\n "
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#of(String)",
    "entityType": "method",
    "code": "static SimpleTypeReference of(String className) {\r\n    Assert.notNull(className, \"'className' must not be null\");\r\n    if (!isValidClassName(className)) {\r\n        throw new IllegalStateException(\"Invalid class name '\" + className + \"'\");\r\n    }\r\n    if (!className.contains(\"$\")) {\r\n        return createTypeReference(className);\r\n    }\r\n    String[] elements = className.split(\"(?<!\\\\$)\\\\$(?!\\\\$)\");\r\n    SimpleTypeReference typeReference = createTypeReference(elements[0]);\r\n    for (int i = 1; i < elements.length; i++) {\r\n        typeReference = new SimpleTypeReference(typeReference.getPackageName(), elements[i], typeReference);\r\n    }\r\n    return typeReference;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#isValidClassName(String)",
    "entityType": "method",
    "code": "private static boolean isValidClassName(String className) {\r\n    for (String s : className.split(\"\\\\.\", -1)) {\r\n        String candidate = s.replace(\"[\", \"\").replace(\"]\", \"\");\r\n        if (!SourceVersion.isIdentifier(candidate)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.aot.hint.SimpleTypeReference#createTypeReference(String)",
    "entityType": "method",
    "code": "private static SimpleTypeReference createTypeReference(String className) {\r\n    int i = className.lastIndexOf('.');\r\n    if (i != -1) {\r\n        return new SimpleTypeReference(className.substring(0, i), className.substring(i + 1), null);\r\n    } else {\r\n        String packageName = (isPrimitive(className) ? \"java.lang\" : \"\");\r\n        return new SimpleTypeReference(packageName, className, null);\r\n    }\r\n}",
    "comment": ""
  }
]