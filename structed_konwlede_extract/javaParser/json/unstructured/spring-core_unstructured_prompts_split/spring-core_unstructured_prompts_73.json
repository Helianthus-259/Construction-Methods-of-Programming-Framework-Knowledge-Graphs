[
  {
    "entityId": "org.springframework.core.type.classreading.MetadataReader#getClassMetadata()",
    "entityType": "method",
    "code": "/**\r\n * Read basic class metadata for the underlying class.\r\n */\r\nClassMetadata getClassMetadata();",
    "comment": "\n\t * Read basic class metadata for the underlying class.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.MetadataReader#getAnnotationMetadata()",
    "entityType": "method",
    "code": "/**\r\n * Read full annotation metadata for the underlying class,\r\n * including metadata for annotated methods.\r\n */\r\nAnnotationMetadata getAnnotationMetadata();",
    "comment": "\n\t * Read full annotation metadata for the underlying class,\n\t * including metadata for annotated methods.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.MetadataReaderFactory",
    "entityType": "class",
    "code": "/**\r\n * Obtain a MetadataReader for the given class name.\r\n * @param className the class name (to be resolved to a \".class\" file)\r\n * @return a holder for the ClassReader instance (never {@code null})\r\n * @throws ClassFormatException in case of an incompatible class format\r\n * @throws IOException in case of I/O failure\r\n */\r\nMetadataReader getMetadataReader(String className) throws IOException;\n/**\r\n * Obtain a MetadataReader for the given resource.\r\n * @param resource the resource (pointing to a \".class\" file)\r\n * @return a holder for the ClassReader instance (never {@code null})\r\n * @throws ClassFormatException in case of an incompatible class format\r\n * @throws IOException in case of I/O failure\r\n */\r\nMetadataReader getMetadataReader(Resource resource) throws IOException;",
    "comment": "\n * Factory interface for {@link MetadataReader} instances.\n * Allows for caching a MetadataReader per original resource.\n *\n * @author Juergen Hoeller\n * @since 2.5\n * @see SimpleMetadataReaderFactory\n * @see CachingMetadataReaderFactory\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.MetadataReaderFactory#getMetadataReader(String)",
    "entityType": "method",
    "code": "/**\r\n * Obtain a MetadataReader for the given class name.\r\n * @param className the class name (to be resolved to a \".class\" file)\r\n * @return a holder for the ClassReader instance (never {@code null})\r\n * @throws ClassFormatException in case of an incompatible class format\r\n * @throws IOException in case of I/O failure\r\n */\r\nMetadataReader getMetadataReader(String className) throws IOException;",
    "comment": "\n\t * Obtain a MetadataReader for the given class name.\n\t * @param className the class name (to be resolved to a \".class\" file)\n\t * @return a holder for the ClassReader instance (never {@code null})\n\t * @throws ClassFormatException in case of an incompatible class format\n\t * @throws IOException in case of I/O failure\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.MetadataReaderFactory#getMetadataReader(Resource)",
    "entityType": "method",
    "code": "/**\r\n * Obtain a MetadataReader for the given resource.\r\n * @param resource the resource (pointing to a \".class\" file)\r\n * @return a holder for the ClassReader instance (never {@code null})\r\n * @throws ClassFormatException in case of an incompatible class format\r\n * @throws IOException in case of I/O failure\r\n */\r\nMetadataReader getMetadataReader(Resource resource) throws IOException;",
    "comment": "\n\t * Obtain a MetadataReader for the given resource.\n\t * @param resource the resource (pointing to a \".class\" file)\n\t * @return a holder for the ClassReader instance (never {@code null})\n\t * @throws ClassFormatException in case of an incompatible class format\n\t * @throws IOException in case of I/O failure\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata",
    "entityType": "class",
    "code": "private final String className;\nprivate final int access;\n@Nullable\r\nprivate final String enclosingClassName;\n@Nullable\r\nprivate final String superClassName;\nprivate final boolean independentInnerClass;\nprivate final Set<String> interfaceNames;\nprivate final Set<String> memberClassNames;\nprivate final Set<MethodMetadata> declaredMethods;\nprivate final MergedAnnotations mergedAnnotations;\n@Nullable\r\nprivate Set<String> annotationTypes;\nSimpleAnnotationMetadata(String className, int access, @Nullable String enclosingClassName, @Nullable String superClassName, boolean independentInnerClass, Set<String> interfaceNames, Set<String> memberClassNames, Set<MethodMetadata> declaredMethods, MergedAnnotations mergedAnnotations) {\r\n    this.className = className;\r\n    this.access = access;\r\n    this.enclosingClassName = enclosingClassName;\r\n    this.superClassName = superClassName;\r\n    this.independentInnerClass = independentInnerClass;\r\n    this.interfaceNames = interfaceNames;\r\n    this.memberClassNames = memberClassNames;\r\n    this.declaredMethods = declaredMethods;\r\n    this.mergedAnnotations = mergedAnnotations;\r\n}\n@Override\r\npublic String getClassName() {\r\n    return this.className;\r\n}\n@Override\r\npublic boolean isInterface() {\r\n    return (this.access & Opcodes.ACC_INTERFACE) != 0;\r\n}\n@Override\r\npublic boolean isAnnotation() {\r\n    return (this.access & Opcodes.ACC_ANNOTATION) != 0;\r\n}\n@Override\r\npublic boolean isAbstract() {\r\n    return (this.access & Opcodes.ACC_ABSTRACT) != 0;\r\n}\n@Override\r\npublic boolean isFinal() {\r\n    return (this.access & Opcodes.ACC_FINAL) != 0;\r\n}\n@Override\r\npublic boolean isIndependent() {\r\n    return (this.enclosingClassName == null || this.independentInnerClass);\r\n}\n@Override\r\n@Nullable\r\npublic String getEnclosingClassName() {\r\n    return this.enclosingClassName;\r\n}\n@Override\r\n@Nullable\r\npublic String getSuperClassName() {\r\n    return this.superClassName;\r\n}\n@Override\r\npublic String[] getInterfaceNames() {\r\n    return StringUtils.toStringArray(this.interfaceNames);\r\n}\n@Override\r\npublic String[] getMemberClassNames() {\r\n    return StringUtils.toStringArray(this.memberClassNames);\r\n}\n@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.mergedAnnotations;\r\n}\n@Override\r\npublic Set<String> getAnnotationTypes() {\r\n    Set<String> annotationTypes = this.annotationTypes;\r\n    if (annotationTypes == null) {\r\n        annotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\r\n        this.annotationTypes = annotationTypes;\r\n    }\r\n    return annotationTypes;\r\n}\n@Override\r\npublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\r\n    Set<MethodMetadata> result = new LinkedHashSet<>(4);\r\n    for (MethodMetadata annotatedMethod : this.declaredMethods) {\r\n        if (annotatedMethod.isAnnotated(annotationName)) {\r\n            result.add(annotatedMethod);\r\n        }\r\n    }\r\n    return Collections.unmodifiableSet(result);\r\n}\n@Override\r\npublic Set<MethodMetadata> getDeclaredMethods() {\r\n    return Collections.unmodifiableSet(this.declaredMethods);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof SimpleAnnotationMetadata that && this.className.equals(that.className)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.className.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.className;\r\n}",
    "comment": "\n * {@link AnnotationMetadata} created from a\n * {@link SimpleAnnotationMetadataReadingVisitor}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getClassName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getClassName() {\r\n    return this.className;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#isInterface()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isInterface() {\r\n    return (this.access & Opcodes.ACC_INTERFACE) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#isAnnotation()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAnnotation() {\r\n    return (this.access & Opcodes.ACC_ANNOTATION) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#isAbstract()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAbstract() {\r\n    return (this.access & Opcodes.ACC_ABSTRACT) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#isFinal()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isFinal() {\r\n    return (this.access & Opcodes.ACC_FINAL) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#isIndependent()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isIndependent() {\r\n    return (this.enclosingClassName == null || this.independentInnerClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getEnclosingClassName()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getEnclosingClassName() {\r\n    return this.enclosingClassName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getSuperClassName()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic String getSuperClassName() {\r\n    return this.superClassName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getInterfaceNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getInterfaceNames() {\r\n    return StringUtils.toStringArray(this.interfaceNames);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getMemberClassNames()",
    "entityType": "method",
    "code": "@Override\r\npublic String[] getMemberClassNames() {\r\n    return StringUtils.toStringArray(this.memberClassNames);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.mergedAnnotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getAnnotationTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<String> getAnnotationTypes() {\r\n    Set<String> annotationTypes = this.annotationTypes;\r\n    if (annotationTypes == null) {\r\n        annotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\r\n        this.annotationTypes = annotationTypes;\r\n    }\r\n    return annotationTypes;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getAnnotatedMethods(String)",
    "entityType": "method",
    "code": "@Override\r\npublic Set<MethodMetadata> getAnnotatedMethods(String annotationName) {\r\n    Set<MethodMetadata> result = new LinkedHashSet<>(4);\r\n    for (MethodMetadata annotatedMethod : this.declaredMethods) {\r\n        if (annotatedMethod.isAnnotated(annotationName)) {\r\n            result.add(annotatedMethod);\r\n        }\r\n    }\r\n    return Collections.unmodifiableSet(result);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#getDeclaredMethods()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<MethodMetadata> getDeclaredMethods() {\r\n    return Collections.unmodifiableSet(this.declaredMethods);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof SimpleAnnotationMetadata that && this.className.equals(that.className)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.className.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadata#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.className;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final ClassLoader classLoader;\nprivate String className = \"\";\nprivate int access;\n@Nullable\r\nprivate String superClassName;\n@Nullable\r\nprivate String enclosingClassName;\nprivate boolean independentInnerClass;\nprivate final Set<String> interfaceNames = new LinkedHashSet<>(4);\nprivate final Set<String> memberClassNames = new LinkedHashSet<>(4);\nprivate final Set<MergedAnnotation<?>> annotations = new LinkedHashSet<>(4);\nprivate final Set<MethodMetadata> declaredMethods = new LinkedHashSet<>(4);\n@Nullable\r\nprivate SimpleAnnotationMetadata metadata;\n@Nullable\r\nprivate Source source;\nSimpleAnnotationMetadataReadingVisitor(@Nullable ClassLoader classLoader) {\r\n    super(SpringAsmInfo.ASM_VERSION);\r\n    this.classLoader = classLoader;\r\n}\n@Override\r\npublic void visit(int version, int access, String name, String signature, @Nullable String supername, String[] interfaces) {\r\n    this.className = toClassName(name);\r\n    this.access = access;\r\n    if (supername != null && !isInterface(access)) {\r\n        this.superClassName = toClassName(supername);\r\n    }\r\n    for (String element : interfaces) {\r\n        this.interfaceNames.add(toClassName(element));\r\n    }\r\n}\n@Override\r\npublic void visitOuterClass(String owner, String name, String desc) {\r\n    this.enclosingClassName = toClassName(owner);\r\n}\n@Override\r\npublic void visitInnerClass(String name, @Nullable String outerName, String innerName, int access) {\r\n    if (outerName != null) {\r\n        String className = toClassName(name);\r\n        String outerClassName = toClassName(outerName);\r\n        if (this.className.equals(className)) {\r\n            this.enclosingClassName = outerClassName;\r\n            this.independentInnerClass = ((access & Opcodes.ACC_STATIC) != 0);\r\n        } else if (this.className.equals(outerClassName)) {\r\n            this.memberClassNames.add(className);\r\n        }\r\n    }\r\n}\n@Override\r\n@Nullable\r\npublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\r\n    return MergedAnnotationReadingVisitor.get(this.classLoader, getSource(), descriptor, visible, this.annotations::add);\r\n}\n@Override\r\n@Nullable\r\npublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\r\n    // Skip bridge methods and constructors - we're only interested in original user methods.\r\n    if (isBridge(access) || name.equals(\"<init>\")) {\r\n        return null;\r\n    }\r\n    return new SimpleMethodMetadataReadingVisitor(this.classLoader, this.className, access, name, descriptor, this.declaredMethods::add);\r\n}\n@Override\r\npublic void visitEnd() {\r\n    MergedAnnotations annotations = MergedAnnotations.of(this.annotations);\r\n    this.metadata = new SimpleAnnotationMetadata(this.className, this.access, this.enclosingClassName, this.superClassName, this.independentInnerClass, this.interfaceNames, this.memberClassNames, this.declaredMethods, annotations);\r\n}\npublic SimpleAnnotationMetadata getMetadata() {\r\n    Assert.state(this.metadata != null, \"AnnotationMetadata not initialized\");\r\n    return this.metadata;\r\n}\nprivate Source getSource() {\r\n    Source source = this.source;\r\n    if (source == null) {\r\n        source = new Source(this.className);\r\n        this.source = source;\r\n    }\r\n    return source;\r\n}\nprivate String toClassName(String name) {\r\n    return ClassUtils.convertResourcePathToClassName(name);\r\n}\nprivate boolean isBridge(int access) {\r\n    return (access & Opcodes.ACC_BRIDGE) != 0;\r\n}\nprivate boolean isInterface(int access) {\r\n    return (access & Opcodes.ACC_INTERFACE) != 0;\r\n}\n/**\r\n * {@link MergedAnnotation} source.\r\n */\r\nprivate static final class Source {\r\n\r\n    private final String className;\r\n\r\n    Source(String className) {\r\n        this.className = className;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        return (this == other || (other instanceof Source that && this.className.equals(that.className)));\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return this.className.hashCode();\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return this.className;\r\n    }\r\n}",
    "comment": "\n * ASM class visitor that creates {@link SimpleAnnotationMetadata}.\n *\n * @author Phillip Webb\n * @author Juergen Hoeller\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#visit(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visit(int version, int access, String name, String signature, @Nullable String supername, String[] interfaces) {\r\n    this.className = toClassName(name);\r\n    this.access = access;\r\n    if (supername != null && !isInterface(access)) {\r\n        this.superClassName = toClassName(supername);\r\n    }\r\n    for (String element : interfaces) {\r\n        this.interfaceNames.add(toClassName(element));\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#visitOuterClass(String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitOuterClass(String owner, String name, String desc) {\r\n    this.enclosingClassName = toClassName(owner);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#visitInnerClass(String,String,String,int)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitInnerClass(String name, @Nullable String outerName, String innerName, int access) {\r\n    if (outerName != null) {\r\n        String className = toClassName(name);\r\n        String outerClassName = toClassName(outerName);\r\n        if (this.className.equals(className)) {\r\n            this.enclosingClassName = outerClassName;\r\n            this.independentInnerClass = ((access & Opcodes.ACC_STATIC) != 0);\r\n        } else if (this.className.equals(outerClassName)) {\r\n            this.memberClassNames.add(className);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\r\n    return MergedAnnotationReadingVisitor.get(this.classLoader, getSource(), descriptor, visible, this.annotations::add);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#visitMethod(int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\r\n    // Skip bridge methods and constructors - we're only interested in original user methods.\r\n    if (isBridge(access) || name.equals(\"<init>\")) {\r\n        return null;\r\n    }\r\n    return new SimpleMethodMetadataReadingVisitor(this.classLoader, this.className, access, name, descriptor, this.declaredMethods::add);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    MergedAnnotations annotations = MergedAnnotations.of(this.annotations);\r\n    this.metadata = new SimpleAnnotationMetadata(this.className, this.access, this.enclosingClassName, this.superClassName, this.independentInnerClass, this.interfaceNames, this.memberClassNames, this.declaredMethods, annotations);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#getMetadata()",
    "entityType": "method",
    "code": "public SimpleAnnotationMetadata getMetadata() {\r\n    Assert.state(this.metadata != null, \"AnnotationMetadata not initialized\");\r\n    return this.metadata;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#getSource()",
    "entityType": "method",
    "code": "private Source getSource() {\r\n    Source source = this.source;\r\n    if (source == null) {\r\n        source = new Source(this.className);\r\n        this.source = source;\r\n    }\r\n    return source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#toClassName(String)",
    "entityType": "method",
    "code": "private String toClassName(String name) {\r\n    return ClassUtils.convertResourcePathToClassName(name);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#isBridge(int)",
    "entityType": "method",
    "code": "private boolean isBridge(int access) {\r\n    return (access & Opcodes.ACC_BRIDGE) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor#isInterface(int)",
    "entityType": "method",
    "code": "private boolean isInterface(int access) {\r\n    return (access & Opcodes.ACC_INTERFACE) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source",
    "entityType": "class",
    "code": "private final String className;\nSource(String className) {\r\n    this.className = className;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Source that && this.className.equals(that.className)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.className.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.className;\r\n}",
    "comment": "\n\t * {@link MergedAnnotation} source.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof Source that && this.className.equals(that.className)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.className.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.className;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReader",
    "entityType": "class",
    "code": "private static final int PARSING_OPTIONS = (ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES);\nprivate final Resource resource;\nprivate final AnnotationMetadata annotationMetadata;\nSimpleMetadataReader(Resource resource, @Nullable ClassLoader classLoader) throws IOException {\r\n    SimpleAnnotationMetadataReadingVisitor visitor = new SimpleAnnotationMetadataReadingVisitor(classLoader);\r\n    getClassReader(resource).accept(visitor, PARSING_OPTIONS);\r\n    this.resource = resource;\r\n    this.annotationMetadata = visitor.getMetadata();\r\n}\nprivate static ClassReader getClassReader(Resource resource) throws IOException {\r\n    try (InputStream is = resource.getInputStream()) {\r\n        try {\r\n            return new ClassReader(is);\r\n        } catch (IllegalArgumentException ex) {\r\n            throw new ClassFormatException(\"ASM ClassReader failed to parse class file - \" + \"probably due to a new Java class file version that is not supported yet. \" + \"Consider compiling with a lower '-target' or upgrade your framework version. \" + \"Affected class: \" + resource, ex);\r\n        }\r\n    }\r\n}\n@Override\r\npublic Resource getResource() {\r\n    return this.resource;\r\n}\n@Override\r\npublic ClassMetadata getClassMetadata() {\r\n    return this.annotationMetadata;\r\n}\n@Override\r\npublic AnnotationMetadata getAnnotationMetadata() {\r\n    return this.annotationMetadata;\r\n}",
    "comment": "\n * {@link MetadataReader} implementation based on an ASM\n * {@link org.springframework.asm.ClassReader}.\n *\n * @author Juergen Hoeller\n * @author Costin Leau\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReader#getClassReader(Resource)",
    "entityType": "method",
    "code": "private static ClassReader getClassReader(Resource resource) throws IOException {\r\n    try (InputStream is = resource.getInputStream()) {\r\n        try {\r\n            return new ClassReader(is);\r\n        } catch (IllegalArgumentException ex) {\r\n            throw new ClassFormatException(\"ASM ClassReader failed to parse class file - \" + \"probably due to a new Java class file version that is not supported yet. \" + \"Consider compiling with a lower '-target' or upgrade your framework version. \" + \"Affected class: \" + resource, ex);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReader#getResource()",
    "entityType": "method",
    "code": "@Override\r\npublic Resource getResource() {\r\n    return this.resource;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReader#getClassMetadata()",
    "entityType": "method",
    "code": "@Override\r\npublic ClassMetadata getClassMetadata() {\r\n    return this.annotationMetadata;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReader#getAnnotationMetadata()",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationMetadata getAnnotationMetadata() {\r\n    return this.annotationMetadata;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReaderFactory",
    "entityType": "class",
    "code": "private final ResourceLoader resourceLoader;\n/**\r\n * Create a new SimpleMetadataReaderFactory for the default class loader.\r\n */\r\npublic SimpleMetadataReaderFactory() {\r\n    this.resourceLoader = new DefaultResourceLoader();\r\n}\n/**\r\n * Create a new SimpleMetadataReaderFactory for the given resource loader.\r\n * @param resourceLoader the Spring ResourceLoader to use\r\n * (also determines the ClassLoader to use)\r\n */\r\npublic SimpleMetadataReaderFactory(@Nullable ResourceLoader resourceLoader) {\r\n    this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader());\r\n}\n/**\r\n * Create a new SimpleMetadataReaderFactory for the given class loader.\r\n * @param classLoader the ClassLoader to use\r\n */\r\npublic SimpleMetadataReaderFactory(@Nullable ClassLoader classLoader) {\r\n    this.resourceLoader = (classLoader != null ? new DefaultResourceLoader(classLoader) : new DefaultResourceLoader());\r\n}\n/**\r\n * Return the ResourceLoader that this MetadataReaderFactory has been\r\n * constructed with.\r\n */\r\npublic final ResourceLoader getResourceLoader() {\r\n    return this.resourceLoader;\r\n}\n@Override\r\npublic MetadataReader getMetadataReader(String className) throws IOException {\r\n    try {\r\n        String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;\r\n        Resource resource = this.resourceLoader.getResource(resourcePath);\r\n        return getMetadataReader(resource);\r\n    } catch (FileNotFoundException ex) {\r\n        // Maybe an inner class name using the dot name syntax? Need to use the dollar syntax here...\r\n        // ClassUtils.forName has an equivalent check for resolution into Class references later on.\r\n        int lastDotIndex = className.lastIndexOf('.');\r\n        if (lastDotIndex != -1) {\r\n            String innerClassName = className.substring(0, lastDotIndex) + '$' + className.substring(lastDotIndex + 1);\r\n            String innerClassResourcePath = ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(innerClassName) + ClassUtils.CLASS_FILE_SUFFIX;\r\n            Resource innerClassResource = this.resourceLoader.getResource(innerClassResourcePath);\r\n            if (innerClassResource.exists()) {\r\n                return getMetadataReader(innerClassResource);\r\n            }\r\n        }\r\n        throw ex;\r\n    }\r\n}\n@Override\r\npublic MetadataReader getMetadataReader(Resource resource) throws IOException {\r\n    return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());\r\n}",
    "comment": "\n * Simple implementation of the {@link MetadataReaderFactory} interface,\n * creating a new ASM {@link org.springframework.asm.ClassReader} for every request.\n *\n * @author Juergen Hoeller\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReaderFactory#getResourceLoader()",
    "entityType": "method",
    "code": "/**\r\n * Return the ResourceLoader that this MetadataReaderFactory has been\r\n * constructed with.\r\n */\r\npublic final ResourceLoader getResourceLoader() {\r\n    return this.resourceLoader;\r\n}",
    "comment": "\n\t * Return the ResourceLoader that this MetadataReaderFactory has been\n\t * constructed with.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReaderFactory#getMetadataReader(String)",
    "entityType": "method",
    "code": "@Override\r\npublic MetadataReader getMetadataReader(String className) throws IOException {\r\n    try {\r\n        String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;\r\n        Resource resource = this.resourceLoader.getResource(resourcePath);\r\n        return getMetadataReader(resource);\r\n    } catch (FileNotFoundException ex) {\r\n        // Maybe an inner class name using the dot name syntax? Need to use the dollar syntax here...\r\n        // ClassUtils.forName has an equivalent check for resolution into Class references later on.\r\n        int lastDotIndex = className.lastIndexOf('.');\r\n        if (lastDotIndex != -1) {\r\n            String innerClassName = className.substring(0, lastDotIndex) + '$' + className.substring(lastDotIndex + 1);\r\n            String innerClassResourcePath = ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(innerClassName) + ClassUtils.CLASS_FILE_SUFFIX;\r\n            Resource innerClassResource = this.resourceLoader.getResource(innerClassResourcePath);\r\n            if (innerClassResource.exists()) {\r\n                return getMetadataReader(innerClassResource);\r\n            }\r\n        }\r\n        throw ex;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMetadataReaderFactory#getMetadataReader(Resource)",
    "entityType": "method",
    "code": "@Override\r\npublic MetadataReader getMetadataReader(Resource resource) throws IOException {\r\n    return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata",
    "entityType": "class",
    "code": "private final String methodName;\nprivate final int access;\nprivate final String declaringClassName;\nprivate final String returnTypeName;\n// The source implements equals(), hashCode(), and toString() for the underlying method.\r\nprivate final Object source;\nprivate final MergedAnnotations annotations;\nSimpleMethodMetadata(String methodName, int access, String declaringClassName, String returnTypeName, Object source, MergedAnnotations annotations) {\r\n    this.methodName = methodName;\r\n    this.access = access;\r\n    this.declaringClassName = declaringClassName;\r\n    this.returnTypeName = returnTypeName;\r\n    this.source = source;\r\n    this.annotations = annotations;\r\n}\n@Override\r\npublic String getMethodName() {\r\n    return this.methodName;\r\n}\n@Override\r\npublic String getDeclaringClassName() {\r\n    return this.declaringClassName;\r\n}\n@Override\r\npublic String getReturnTypeName() {\r\n    return this.returnTypeName;\r\n}\n@Override\r\npublic boolean isAbstract() {\r\n    return (this.access & Opcodes.ACC_ABSTRACT) != 0;\r\n}\n@Override\r\npublic boolean isStatic() {\r\n    return (this.access & Opcodes.ACC_STATIC) != 0;\r\n}\n@Override\r\npublic boolean isFinal() {\r\n    return (this.access & Opcodes.ACC_FINAL) != 0;\r\n}\n@Override\r\npublic boolean isOverridable() {\r\n    return !isStatic() && !isFinal() && !isPrivate();\r\n}\nprivate boolean isPrivate() {\r\n    return (this.access & Opcodes.ACC_PRIVATE) != 0;\r\n}\n@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.annotations;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof SimpleMethodMetadata that && this.source.equals(that.source)));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.source.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.source.toString();\r\n}",
    "comment": "\n * {@link MethodMetadata} created from a {@link SimpleMethodMetadataReadingVisitor}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#getMethodName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getMethodName() {\r\n    return this.methodName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#getDeclaringClassName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getDeclaringClassName() {\r\n    return this.declaringClassName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#getReturnTypeName()",
    "entityType": "method",
    "code": "@Override\r\npublic String getReturnTypeName() {\r\n    return this.returnTypeName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#isAbstract()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isAbstract() {\r\n    return (this.access & Opcodes.ACC_ABSTRACT) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#isStatic()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isStatic() {\r\n    return (this.access & Opcodes.ACC_STATIC) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#isFinal()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isFinal() {\r\n    return (this.access & Opcodes.ACC_FINAL) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#isOverridable()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isOverridable() {\r\n    return !isStatic() && !isFinal() && !isPrivate();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#isPrivate()",
    "entityType": "method",
    "code": "private boolean isPrivate() {\r\n    return (this.access & Opcodes.ACC_PRIVATE) != 0;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#getAnnotations()",
    "entityType": "method",
    "code": "@Override\r\npublic MergedAnnotations getAnnotations() {\r\n    return this.annotations;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || (other instanceof SimpleMethodMetadata that && this.source.equals(that.source)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.source.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadata#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.source.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadataReadingVisitor",
    "entityType": "class",
    "code": "@Nullable\r\nprivate final ClassLoader classLoader;\nprivate final String declaringClassName;\nprivate final int access;\nprivate final String methodName;\nprivate final String descriptor;\nprivate final List<MergedAnnotation<?>> annotations = new ArrayList<>(4);\nprivate final Consumer<SimpleMethodMetadata> consumer;\n@Nullable\r\nprivate Source source;\nSimpleMethodMetadataReadingVisitor(@Nullable ClassLoader classLoader, String declaringClassName, int access, String methodName, String descriptor, Consumer<SimpleMethodMetadata> consumer) {\r\n    super(SpringAsmInfo.ASM_VERSION);\r\n    this.classLoader = classLoader;\r\n    this.declaringClassName = declaringClassName;\r\n    this.access = access;\r\n    this.methodName = methodName;\r\n    this.descriptor = descriptor;\r\n    this.consumer = consumer;\r\n}\n@Override\r\n@Nullable\r\npublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\r\n    return MergedAnnotationReadingVisitor.get(this.classLoader, getSource(), descriptor, visible, this.annotations::add);\r\n}\n@Override\r\npublic void visitEnd() {\r\n    String returnTypeName = Type.getReturnType(this.descriptor).getClassName();\r\n    MergedAnnotations annotations = MergedAnnotations.of(this.annotations);\r\n    SimpleMethodMetadata metadata = new SimpleMethodMetadata(this.methodName, this.access, this.declaringClassName, returnTypeName, getSource(), annotations);\r\n    this.consumer.accept(metadata);\r\n}\nprivate Object getSource() {\r\n    Source source = this.source;\r\n    if (source == null) {\r\n        source = new Source(this.declaringClassName, this.methodName, this.descriptor);\r\n        this.source = source;\r\n    }\r\n    return source;\r\n}\n/**\r\n * {@link MergedAnnotation} source.\r\n */\r\nstatic final class Source {\r\n\r\n    private final String declaringClassName;\r\n\r\n    private final String methodName;\r\n\r\n    private final String descriptor;\r\n\r\n    @Nullable\r\n    private String toStringValue;\r\n\r\n    Source(String declaringClassName, String methodName, String descriptor) {\r\n        this.declaringClassName = declaringClassName;\r\n        this.methodName = methodName;\r\n        this.descriptor = descriptor;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = 1;\r\n        result = 31 * result + this.declaringClassName.hashCode();\r\n        result = 31 * result + this.methodName.hashCode();\r\n        result = 31 * result + this.descriptor.hashCode();\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(@Nullable Object other) {\r\n        if (this == other) {\r\n            return true;\r\n        }\r\n        if (other == null || getClass() != other.getClass()) {\r\n            return false;\r\n        }\r\n        Source otherSource = (Source) other;\r\n        return (this.declaringClassName.equals(otherSource.declaringClassName) && this.methodName.equals(otherSource.methodName) && this.descriptor.equals(otherSource.descriptor));\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String value = this.toStringValue;\r\n        if (value == null) {\r\n            StringBuilder builder = new StringBuilder();\r\n            builder.append(this.declaringClassName);\r\n            builder.append('.');\r\n            builder.append(this.methodName);\r\n            Type[] argumentTypes = Type.getArgumentTypes(this.descriptor);\r\n            builder.append('(');\r\n            for (int i = 0; i < argumentTypes.length; i++) {\r\n                if (i != 0) {\r\n                    builder.append(',');\r\n                }\r\n                builder.append(argumentTypes[i].getClassName());\r\n            }\r\n            builder.append(')');\r\n            value = builder.toString();\r\n            this.toStringValue = value;\r\n        }\r\n        return value;\r\n    }\r\n}",
    "comment": "\n * ASM method visitor that creates {@link SimpleMethodMetadata}.\n *\n * @author Phillip Webb\n * @author Sam Brannen\n * @author Juergen Hoeller\n * @since 5.2\n "
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadataReadingVisitor#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\r\n    return MergedAnnotationReadingVisitor.get(this.classLoader, getSource(), descriptor, visible, this.annotations::add);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadataReadingVisitor#visitEnd()",
    "entityType": "method",
    "code": "@Override\r\npublic void visitEnd() {\r\n    String returnTypeName = Type.getReturnType(this.descriptor).getClassName();\r\n    MergedAnnotations annotations = MergedAnnotations.of(this.annotations);\r\n    SimpleMethodMetadata metadata = new SimpleMethodMetadata(this.methodName, this.access, this.declaringClassName, returnTypeName, getSource(), annotations);\r\n    this.consumer.accept(metadata);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.SimpleMethodMetadataReadingVisitor#getSource()",
    "entityType": "method",
    "code": "private Object getSource() {\r\n    Source source = this.source;\r\n    if (source == null) {\r\n        source = new Source(this.declaringClassName, this.methodName, this.descriptor);\r\n        this.source = source;\r\n    }\r\n    return source;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source",
    "entityType": "class",
    "code": "private final String declaringClassName;\nprivate final String methodName;\nprivate final String descriptor;\n@Nullable\r\nprivate String toStringValue;\nSource(String declaringClassName, String methodName, String descriptor) {\r\n    this.declaringClassName = declaringClassName;\r\n    this.methodName = methodName;\r\n    this.descriptor = descriptor;\r\n}\n@Override\r\npublic int hashCode() {\r\n    int result = 1;\r\n    result = 31 * result + this.declaringClassName.hashCode();\r\n    result = 31 * result + this.methodName.hashCode();\r\n    result = 31 * result + this.descriptor.hashCode();\r\n    return result;\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    Source otherSource = (Source) other;\r\n    return (this.declaringClassName.equals(otherSource.declaringClassName) && this.methodName.equals(otherSource.methodName) && this.descriptor.equals(otherSource.descriptor));\r\n}\n@Override\r\npublic String toString() {\r\n    String value = this.toStringValue;\r\n    if (value == null) {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(this.declaringClassName);\r\n        builder.append('.');\r\n        builder.append(this.methodName);\r\n        Type[] argumentTypes = Type.getArgumentTypes(this.descriptor);\r\n        builder.append('(');\r\n        for (int i = 0; i < argumentTypes.length; i++) {\r\n            if (i != 0) {\r\n                builder.append(',');\r\n            }\r\n            builder.append(argumentTypes[i].getClassName());\r\n        }\r\n        builder.append(')');\r\n        value = builder.toString();\r\n        this.toStringValue = value;\r\n    }\r\n    return value;\r\n}",
    "comment": "\n\t * {@link MergedAnnotation} source.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    int result = 1;\r\n    result = 31 * result + this.declaringClassName.hashCode();\r\n    result = 31 * result + this.methodName.hashCode();\r\n    result = 31 * result + this.descriptor.hashCode();\r\n    return result;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    Source otherSource = (Source) other;\r\n    return (this.declaringClassName.equals(otherSource.declaringClassName) && this.methodName.equals(otherSource.methodName) && this.descriptor.equals(otherSource.descriptor));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.classreading.Source#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    String value = this.toStringValue;\r\n    if (value == null) {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(this.declaringClassName);\r\n        builder.append('.');\r\n        builder.append(this.methodName);\r\n        Type[] argumentTypes = Type.getArgumentTypes(this.descriptor);\r\n        builder.append('(');\r\n        for (int i = 0; i < argumentTypes.length; i++) {\r\n            if (i != 0) {\r\n                builder.append(',');\r\n            }\r\n            builder.append(argumentTypes[i].getClassName());\r\n        }\r\n        builder.append(')');\r\n        value = builder.toString();\r\n        this.toStringValue = value;\r\n    }\r\n    return value;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractClassTestingTypeFilter",
    "entityType": "class",
    "code": "@Override\r\npublic final boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    return match(metadataReader.getClassMetadata());\r\n}\n/**\r\n * Determine a match based on the given ClassMetadata object.\r\n * @param metadata the ClassMetadata object\r\n * @return whether this filter matches on the specified type\r\n */\r\nprotected abstract boolean match(ClassMetadata metadata);",
    "comment": "\n * Type filter that exposes a\n * {@link org.springframework.core.type.ClassMetadata} object\n * to subclasses, for class testing purposes.\n *\n * @author Rod Johnson\n * @author Costin Leau\n * @author Juergen Hoeller\n * @since 2.5\n * @see #match(org.springframework.core.type.ClassMetadata)\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractClassTestingTypeFilter#match(MetadataReader,MetadataReaderFactory)",
    "entityType": "method",
    "code": "@Override\r\npublic final boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    return match(metadataReader.getClassMetadata());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractClassTestingTypeFilter#match(ClassMetadata)",
    "entityType": "method",
    "code": "/**\r\n * Determine a match based on the given ClassMetadata object.\r\n * @param metadata the ClassMetadata object\r\n * @return whether this filter matches on the specified type\r\n */\r\nprotected abstract boolean match(ClassMetadata metadata);",
    "comment": "\n\t * Determine a match based on the given ClassMetadata object.\n\t * @param metadata the ClassMetadata object\n\t * @return whether this filter matches on the specified type\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter",
    "entityType": "class",
    "code": "protected final Log logger = LogFactory.getLog(getClass());\nprivate final boolean considerInherited;\nprivate final boolean considerInterfaces;\nprotected AbstractTypeHierarchyTraversingFilter(boolean considerInherited, boolean considerInterfaces) {\r\n    this.considerInherited = considerInherited;\r\n    this.considerInterfaces = considerInterfaces;\r\n}\n@Override\r\npublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    // This method optimizes avoiding unnecessary creation of ClassReaders\r\n    // as well as visiting over those readers.\r\n    if (matchSelf(metadataReader)) {\r\n        return true;\r\n    }\r\n    ClassMetadata metadata = metadataReader.getClassMetadata();\r\n    if (matchClassName(metadata.getClassName())) {\r\n        return true;\r\n    }\r\n    if (this.considerInherited) {\r\n        String superClassName = metadata.getSuperClassName();\r\n        if (superClassName != null) {\r\n            // Optimization to avoid creating ClassReader for superclass.\r\n            Boolean superClassMatch = matchSuperClass(superClassName);\r\n            if (superClassMatch != null) {\r\n                if (superClassMatch) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                // Need to read superclass to determine a match...\r\n                try {\r\n                    if (match(superClassName, metadataReaderFactory)) {\r\n                        return true;\r\n                    }\r\n                } catch (IOException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Could not read superclass [\" + superClassName + \"] of type-filtered class [\" + metadata.getClassName() + \"]\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (this.considerInterfaces) {\r\n        for (String ifc : metadata.getInterfaceNames()) {\r\n            // Optimization to avoid creating ClassReader for superclass\r\n            Boolean interfaceMatch = matchInterface(ifc);\r\n            if (interfaceMatch != null) {\r\n                if (interfaceMatch) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                // Need to read interface to determine a match...\r\n                try {\r\n                    if (match(ifc, metadataReaderFactory)) {\r\n                        return true;\r\n                    }\r\n                } catch (IOException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Could not read interface [\" + ifc + \"] for type-filtered class [\" + metadata.getClassName() + \"]\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\nprivate boolean match(String className, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    return match(metadataReaderFactory.getMetadataReader(className), metadataReaderFactory);\r\n}\n/**\r\n * Override this to match self characteristics alone. Typically,\r\n * the implementation will use a visitor to extract information\r\n * to perform matching.\r\n */\r\nprotected boolean matchSelf(MetadataReader metadataReader) {\r\n    return false;\r\n}\n/**\r\n * Override this to match on type name.\r\n */\r\nprotected boolean matchClassName(String className) {\r\n    return false;\r\n}\n/**\r\n * Override this to match on supertype name.\r\n */\r\n@Nullable\r\nprotected Boolean matchSuperClass(String superClassName) {\r\n    return null;\r\n}\n/**\r\n * Override this to match on interface type name.\r\n */\r\n@Nullable\r\nprotected Boolean matchInterface(String interfaceName) {\r\n    return null;\r\n}",
    "comment": "\n * Type filter that is aware of traversing over hierarchy.\n *\n * <p>This filter is useful when matching needs to be made based on potentially the\n * whole class/interface hierarchy. The algorithm employed uses a succeed-fast\n * strategy: if at any time a match is declared, no further processing is\n * carried out.\n *\n * @author Ramnivas Laddad\n * @author Mark Fisher\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#match(MetadataReader,MetadataReaderFactory)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    // This method optimizes avoiding unnecessary creation of ClassReaders\r\n    // as well as visiting over those readers.\r\n    if (matchSelf(metadataReader)) {\r\n        return true;\r\n    }\r\n    ClassMetadata metadata = metadataReader.getClassMetadata();\r\n    if (matchClassName(metadata.getClassName())) {\r\n        return true;\r\n    }\r\n    if (this.considerInherited) {\r\n        String superClassName = metadata.getSuperClassName();\r\n        if (superClassName != null) {\r\n            // Optimization to avoid creating ClassReader for superclass.\r\n            Boolean superClassMatch = matchSuperClass(superClassName);\r\n            if (superClassMatch != null) {\r\n                if (superClassMatch) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                // Need to read superclass to determine a match...\r\n                try {\r\n                    if (match(superClassName, metadataReaderFactory)) {\r\n                        return true;\r\n                    }\r\n                } catch (IOException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Could not read superclass [\" + superClassName + \"] of type-filtered class [\" + metadata.getClassName() + \"]\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (this.considerInterfaces) {\r\n        for (String ifc : metadata.getInterfaceNames()) {\r\n            // Optimization to avoid creating ClassReader for superclass\r\n            Boolean interfaceMatch = matchInterface(ifc);\r\n            if (interfaceMatch != null) {\r\n                if (interfaceMatch) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                // Need to read interface to determine a match...\r\n                try {\r\n                    if (match(ifc, metadataReaderFactory)) {\r\n                        return true;\r\n                    }\r\n                } catch (IOException ex) {\r\n                    if (logger.isDebugEnabled()) {\r\n                        logger.debug(\"Could not read interface [\" + ifc + \"] for type-filtered class [\" + metadata.getClassName() + \"]\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#match(String,MetadataReaderFactory)",
    "entityType": "method",
    "code": "private boolean match(String className, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    return match(metadataReaderFactory.getMetadataReader(className), metadataReaderFactory);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#matchSelf(MetadataReader)",
    "entityType": "method",
    "code": "/**\r\n * Override this to match self characteristics alone. Typically,\r\n * the implementation will use a visitor to extract information\r\n * to perform matching.\r\n */\r\nprotected boolean matchSelf(MetadataReader metadataReader) {\r\n    return false;\r\n}",
    "comment": "\n\t * Override this to match self characteristics alone. Typically,\n\t * the implementation will use a visitor to extract information\n\t * to perform matching.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#matchClassName(String)",
    "entityType": "method",
    "code": "/**\r\n * Override this to match on type name.\r\n */\r\nprotected boolean matchClassName(String className) {\r\n    return false;\r\n}",
    "comment": "\n\t * Override this to match on type name.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#matchSuperClass(String)",
    "entityType": "method",
    "code": "/**\r\n * Override this to match on supertype name.\r\n */\r\n@Nullable\r\nprotected Boolean matchSuperClass(String superClassName) {\r\n    return null;\r\n}",
    "comment": "\n\t * Override this to match on supertype name.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter#matchInterface(String)",
    "entityType": "method",
    "code": "/**\r\n * Override this to match on interface type name.\r\n */\r\n@Nullable\r\nprotected Boolean matchInterface(String interfaceName) {\r\n    return null;\r\n}",
    "comment": "\n\t * Override this to match on interface type name.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AnnotationTypeFilter",
    "entityType": "class",
    "code": "private final Class<? extends Annotation> annotationType;\nprivate final boolean considerMetaAnnotations;\n/**\r\n * Create a new {@code AnnotationTypeFilter} for the given annotation type.\r\n * <p>The filter will also match meta-annotations. To disable the\r\n * meta-annotation matching, use the constructor that accepts a\r\n * '{@code considerMetaAnnotations}' argument.\r\n * <p>The filter will not match interfaces.\r\n * @param annotationType the annotation type to match\r\n */\r\npublic AnnotationTypeFilter(Class<? extends Annotation> annotationType) {\r\n    this(annotationType, true, false);\r\n}\n/**\r\n * Create a new {@code AnnotationTypeFilter} for the given annotation type.\r\n * <p>The filter will not match interfaces.\r\n * @param annotationType the annotation type to match\r\n * @param considerMetaAnnotations whether to also match on meta-annotations\r\n */\r\npublic AnnotationTypeFilter(Class<? extends Annotation> annotationType, boolean considerMetaAnnotations) {\r\n    this(annotationType, considerMetaAnnotations, false);\r\n}\n/**\r\n * Create a new {@code AnnotationTypeFilter} for the given annotation type.\r\n * @param annotationType the annotation type to match\r\n * @param considerMetaAnnotations whether to also match on meta-annotations\r\n * @param considerInterfaces whether to also match interfaces\r\n */\r\npublic AnnotationTypeFilter(Class<? extends Annotation> annotationType, boolean considerMetaAnnotations, boolean considerInterfaces) {\r\n    super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);\r\n    this.annotationType = annotationType;\r\n    this.considerMetaAnnotations = considerMetaAnnotations;\r\n}\n/**\r\n * Return the {@link Annotation} that this instance is using to filter\r\n * candidates.\r\n * @since 5.0\r\n */\r\npublic final Class<? extends Annotation> getAnnotationType() {\r\n    return this.annotationType;\r\n}\n@Override\r\nprotected boolean matchSelf(MetadataReader metadataReader) {\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    return metadata.hasAnnotation(this.annotationType.getName()) || (this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName()));\r\n}\n@Override\r\n@Nullable\r\nprotected Boolean matchSuperClass(String superClassName) {\r\n    return hasAnnotation(superClassName);\r\n}\n@Override\r\n@Nullable\r\nprotected Boolean matchInterface(String interfaceName) {\r\n    return hasAnnotation(interfaceName);\r\n}\n@Nullable\r\nprotected Boolean hasAnnotation(String typeName) {\r\n    if (Object.class.getName().equals(typeName)) {\r\n        return false;\r\n    } else if (typeName.startsWith(\"java\")) {\r\n        if (!this.annotationType.getName().startsWith(\"java\")) {\r\n            // Standard Java types do not have non-standard annotations on them ->\r\n            // skip any load attempt, in particular for Java language interfaces.\r\n            return false;\r\n        }\r\n        try {\r\n            Class<?> clazz = ClassUtils.forName(typeName, getClass().getClassLoader());\r\n            return ((this.considerMetaAnnotations ? AnnotationUtils.getAnnotation(clazz, this.annotationType) : clazz.getAnnotation(this.annotationType)) != null);\r\n        } catch (Throwable ex) {\r\n            // Class not regularly loadable - can't determine a match that way.\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": "\n * A simple {@link TypeFilter} which matches classes with a given annotation,\n * checking inherited annotations as well.\n *\n * <p>By default, the matching logic mirrors that of\n * {@link AnnotationUtils#getAnnotation(java.lang.reflect.AnnotatedElement, Class)},\n * supporting annotations that are <em>present</em> or <em>meta-present</em> for a\n * single level of meta-annotations. The search for meta-annotations may be disabled.\n * Similarly, the search for annotations on interfaces may optionally be enabled.\n * Consult the various constructors in this class for details.\n *\n * @author Mark Fisher\n * @author Ramnivas Laddad\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.AnnotationTypeFilter#getAnnotationType()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@link Annotation} that this instance is using to filter\r\n * candidates.\r\n * @since 5.0\r\n */\r\npublic final Class<? extends Annotation> getAnnotationType() {\r\n    return this.annotationType;\r\n}",
    "comment": "\n\t * Return the {@link Annotation} that this instance is using to filter\n\t * candidates.\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AnnotationTypeFilter#matchSelf(MetadataReader)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean matchSelf(MetadataReader metadataReader) {\r\n    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();\r\n    return metadata.hasAnnotation(this.annotationType.getName()) || (this.considerMetaAnnotations && metadata.hasMetaAnnotation(this.annotationType.getName()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AnnotationTypeFilter#matchSuperClass(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected Boolean matchSuperClass(String superClassName) {\r\n    return hasAnnotation(superClassName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AnnotationTypeFilter#matchInterface(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected Boolean matchInterface(String interfaceName) {\r\n    return hasAnnotation(interfaceName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AnnotationTypeFilter#hasAnnotation(String)",
    "entityType": "method",
    "code": "@Nullable\r\nprotected Boolean hasAnnotation(String typeName) {\r\n    if (Object.class.getName().equals(typeName)) {\r\n        return false;\r\n    } else if (typeName.startsWith(\"java\")) {\r\n        if (!this.annotationType.getName().startsWith(\"java\")) {\r\n            // Standard Java types do not have non-standard annotations on them ->\r\n            // skip any load attempt, in particular for Java language interfaces.\r\n            return false;\r\n        }\r\n        try {\r\n            Class<?> clazz = ClassUtils.forName(typeName, getClass().getClassLoader());\r\n            return ((this.considerMetaAnnotations ? AnnotationUtils.getAnnotation(clazz, this.annotationType) : clazz.getAnnotation(this.annotationType)) != null);\r\n        } catch (Throwable ex) {\r\n            // Class not regularly loadable - can't determine a match that way.\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AspectJTypeFilter",
    "entityType": "class",
    "code": "private final World world;\nprivate final TypePattern typePattern;\npublic AspectJTypeFilter(String typePatternExpression, @Nullable ClassLoader classLoader) {\r\n    this.world = new BcelWorld(classLoader, IMessageHandler.THROW, null);\r\n    this.world.setBehaveInJava5Way(true);\r\n    PatternParser patternParser = new PatternParser(typePatternExpression);\r\n    TypePattern typePattern = patternParser.parseTypePattern();\r\n    typePattern.resolve(this.world);\r\n    IScope scope = new SimpleScope(this.world, new FormalBinding[0]);\r\n    this.typePattern = typePattern.resolveBindings(scope, Bindings.NONE, false, false);\r\n}\n@Override\r\npublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    String className = metadataReader.getClassMetadata().getClassName();\r\n    ResolvedType resolvedType = this.world.resolve(className);\r\n    return this.typePattern.matchesStatically(resolvedType);\r\n}",
    "comment": "\n * Type filter that uses AspectJ type pattern for matching.\n *\n * <p>A critical implementation details of this type filter is that it does not\n * load the class being examined to match with a type pattern.\n *\n * @author Ramnivas Laddad\n * @author Juergen Hoeller\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.AspectJTypeFilter#match(MetadataReader,MetadataReaderFactory)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {\r\n    String className = metadataReader.getClassMetadata().getClassName();\r\n    ResolvedType resolvedType = this.world.resolve(className);\r\n    return this.typePattern.matchesStatically(resolvedType);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AssignableTypeFilter",
    "entityType": "class",
    "code": "private final Class<?> targetType;\n/**\r\n * Create a new AssignableTypeFilter for the given type.\r\n * @param targetType the type to match\r\n */\r\npublic AssignableTypeFilter(Class<?> targetType) {\r\n    super(true, true);\r\n    this.targetType = targetType;\r\n}\n/**\r\n * Return the {@code type} that this instance is using to filter candidates.\r\n * @since 5.0\r\n */\r\npublic final Class<?> getTargetType() {\r\n    return this.targetType;\r\n}\n@Override\r\nprotected boolean matchClassName(String className) {\r\n    return this.targetType.getName().equals(className);\r\n}\n@Override\r\n@Nullable\r\nprotected Boolean matchSuperClass(String superClassName) {\r\n    return matchTargetType(superClassName);\r\n}\n@Override\r\n@Nullable\r\nprotected Boolean matchInterface(String interfaceName) {\r\n    return matchTargetType(interfaceName);\r\n}\n@Nullable\r\nprotected Boolean matchTargetType(String typeName) {\r\n    if (this.targetType.getName().equals(typeName)) {\r\n        return true;\r\n    } else if (Object.class.getName().equals(typeName)) {\r\n        return false;\r\n    } else if (typeName.startsWith(\"java\")) {\r\n        try {\r\n            Class<?> clazz = ClassUtils.forName(typeName, getClass().getClassLoader());\r\n            return this.targetType.isAssignableFrom(clazz);\r\n        } catch (Throwable ex) {\r\n            // Class not regularly loadable - can't determine a match that way.\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": "\n * A simple filter which matches classes that are assignable to a given type.\n *\n * @author Rod Johnson\n * @author Mark Fisher\n * @author Ramnivas Laddad\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.AssignableTypeFilter#getTargetType()",
    "entityType": "method",
    "code": "/**\r\n * Return the {@code type} that this instance is using to filter candidates.\r\n * @since 5.0\r\n */\r\npublic final Class<?> getTargetType() {\r\n    return this.targetType;\r\n}",
    "comment": "\n\t * Return the {@code type} that this instance is using to filter candidates.\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.core.type.filter.AssignableTypeFilter#matchClassName(String)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean matchClassName(String className) {\r\n    return this.targetType.getName().equals(className);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AssignableTypeFilter#matchSuperClass(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected Boolean matchSuperClass(String superClassName) {\r\n    return matchTargetType(superClassName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AssignableTypeFilter#matchInterface(String)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\nprotected Boolean matchInterface(String interfaceName) {\r\n    return matchTargetType(interfaceName);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.AssignableTypeFilter#matchTargetType(String)",
    "entityType": "method",
    "code": "@Nullable\r\nprotected Boolean matchTargetType(String typeName) {\r\n    if (this.targetType.getName().equals(typeName)) {\r\n        return true;\r\n    } else if (Object.class.getName().equals(typeName)) {\r\n        return false;\r\n    } else if (typeName.startsWith(\"java\")) {\r\n        try {\r\n            Class<?> clazz = ClassUtils.forName(typeName, getClass().getClassLoader());\r\n            return this.targetType.isAssignableFrom(clazz);\r\n        } catch (Throwable ex) {\r\n            // Class not regularly loadable - can't determine a match that way.\r\n        }\r\n    }\r\n    return null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.RegexPatternTypeFilter",
    "entityType": "class",
    "code": "private final Pattern pattern;\npublic RegexPatternTypeFilter(Pattern pattern) {\r\n    Assert.notNull(pattern, \"Pattern must not be null\");\r\n    this.pattern = pattern;\r\n}\n@Override\r\nprotected boolean match(ClassMetadata metadata) {\r\n    return this.pattern.matcher(metadata.getClassName()).matches();\r\n}",
    "comment": "\n * A simple filter for matching a fully-qualified class name with a regex {@link Pattern}.\n *\n * @author Mark Fisher\n * @author Juergen Hoeller\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.RegexPatternTypeFilter#match(ClassMetadata)",
    "entityType": "method",
    "code": "@Override\r\nprotected boolean match(ClassMetadata metadata) {\r\n    return this.pattern.matcher(metadata.getClassName()).matches();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.core.type.filter.TypeFilter",
    "entityType": "class",
    "code": "/**\r\n * Determine whether this filter matches for the class described by\r\n * the given metadata.\r\n * @param metadataReader the metadata reader for the target class\r\n * @param metadataReaderFactory a factory for obtaining metadata readers\r\n * for other classes (such as superclasses and interfaces)\r\n * @return whether this filter matches\r\n * @throws IOException in case of I/O failure when reading metadata\r\n */\r\nboolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException;",
    "comment": "\n * Base interface for type filters using a\n * {@link org.springframework.core.type.classreading.MetadataReader}.\n *\n * @author Costin Leau\n * @author Juergen Hoeller\n * @author Mark Fisher\n * @since 2.5\n "
  },
  {
    "entityId": "org.springframework.core.type.filter.TypeFilter#match(MetadataReader,MetadataReaderFactory)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether this filter matches for the class described by\r\n * the given metadata.\r\n * @param metadataReader the metadata reader for the target class\r\n * @param metadataReaderFactory a factory for obtaining metadata readers\r\n * for other classes (such as superclasses and interfaces)\r\n * @return whether this filter matches\r\n * @throws IOException in case of I/O failure when reading metadata\r\n */\r\nboolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException;",
    "comment": "\n\t * Determine whether this filter matches for the class described by\n\t * the given metadata.\n\t * @param metadataReader the metadata reader for the target class\n\t * @param metadataReaderFactory a factory for obtaining metadata readers\n\t * for other classes (such as superclasses and interfaces)\n\t * @return whether this filter matches\n\t * @throws IOException in case of I/O failure when reading metadata\n\t "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata",
    "entityType": "class",
    "code": "/**\r\n * Get the name of the underlying method.\r\n */\r\nString getMethodName();\n/**\r\n * Get the fully-qualified name of the class that declares the underlying method.\r\n */\r\nString getDeclaringClassName();\n/**\r\n * Get the fully-qualified name of the underlying method's declared return type.\r\n * @since 4.2\r\n */\r\nString getReturnTypeName();\n/**\r\n * Determine whether the underlying method is effectively abstract:\r\n * i.e. marked as abstract in a class or declared as a regular,\r\n * non-default method in an interface.\r\n * @since 4.2\r\n */\r\nboolean isAbstract();\n/**\r\n * Determine whether the underlying method is declared as 'static'.\r\n */\r\nboolean isStatic();\n/**\r\n * Determine whether the underlying method is marked as 'final'.\r\n */\r\nboolean isFinal();\n/**\r\n * Determine whether the underlying method is overridable,\r\n * i.e. not marked as static, final, or private.\r\n */\r\nboolean isOverridable();",
    "comment": "\n * Interface that defines abstract access to the annotations of a specific\n * method, in a form that does not require that method's class to be loaded yet.\n *\n * @author Juergen Hoeller\n * @author Mark Pollack\n * @author Chris Beams\n * @author Phillip Webb\n * @since 3.0\n * @see StandardMethodMetadata\n * @see AnnotationMetadata#getAnnotatedMethods\n * @see AnnotatedTypeMetadata\n "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata#getMethodName()",
    "entityType": "method",
    "code": "/**\r\n * Get the name of the underlying method.\r\n */\r\nString getMethodName();",
    "comment": "\n\t * Get the name of the underlying method.\n\t "
  },
  {
    "entityId": "org.springframework.core.type.MethodMetadata#getDeclaringClassName()",
    "entityType": "method",
    "code": "/**\r\n * Get the fully-qualified name of the class that declares the underlying method.\r\n */\r\nString getDeclaringClassName();",
    "comment": "\n\t * Get the fully-qualified name of the class that declares the underlying method.\n\t "
  }
]