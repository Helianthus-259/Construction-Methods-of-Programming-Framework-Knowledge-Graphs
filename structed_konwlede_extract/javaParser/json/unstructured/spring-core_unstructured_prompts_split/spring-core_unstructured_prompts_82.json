[
  {
    "entityId": "org.springframework.util.MultiValueMap#add(K,V)",
    "entityType": "method",
    "code": "/**\r\n * Add the given single value to the current list of values for the given key.\r\n * @param key the key\r\n * @param value the value to be added\r\n */\r\nvoid add(K key, @Nullable V value);",
    "comment": "\n\t * Add the given single value to the current list of values for the given key.\n\t * @param key the key\n\t * @param value the value to be added\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#addAll(K,List<? extends V>)",
    "entityType": "method",
    "code": "/**\r\n * Add all the values of the given list to the current list of values for the given key.\r\n * @param key they key\r\n * @param values the values to be added\r\n * @since 5.0\r\n */\r\nvoid addAll(K key, List<? extends V> values);",
    "comment": "\n\t * Add all the values of the given list to the current list of values for the given key.\n\t * @param key they key\n\t * @param values the values to be added\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#addAll(MultiValueMap<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Add all the values of the given {@code MultiValueMap} to the current values.\r\n * @param values the values to be added\r\n * @since 5.0\r\n */\r\nvoid addAll(MultiValueMap<K, V> values);",
    "comment": "\n\t * Add all the values of the given {@code MultiValueMap} to the current values.\n\t * @param values the values to be added\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
    "entityType": "method",
    "code": "/**\r\n * {@link #add(Object, Object) Add} the given value, only when the map does not\r\n * {@link #containsKey(Object) contain} the given key.\r\n * @param key the key\r\n * @param value the value to be added\r\n * @since 5.2\r\n */\r\ndefault void addIfAbsent(K key, @Nullable V value) {\r\n    if (!containsKey(key)) {\r\n        add(key, value);\r\n    }\r\n}",
    "comment": "\n\t * {@link #add(Object, Object) Add} the given value, only when the map does not\n\t * {@link #containsKey(Object) contain} the given key.\n\t * @param key the key\n\t * @param value the value to be added\n\t * @since 5.2\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#set(K,V)",
    "entityType": "method",
    "code": "/**\r\n * Set the given single value under the given key.\r\n * @param key the key\r\n * @param value the value to set\r\n */\r\nvoid set(K key, @Nullable V value);",
    "comment": "\n\t * Set the given single value under the given key.\n\t * @param key the key\n\t * @param value the value to set\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#setAll(Map<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Set the given values under.\r\n * @param values the values.\r\n */\r\nvoid setAll(Map<K, V> values);",
    "comment": "\n\t * Set the given values under.\n\t * @param values the values.\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#toSingleValueMap()",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code Map} with the first values contained in this {@code MultiValueMap}.\r\n * The difference between this method and {@link #asSingleValueMap()} is\r\n * that this method returns a copy of the entries of this map, whereas\r\n * the latter returns a view.\r\n * @return a single value representation of this map\r\n */\r\nMap<K, V> toSingleValueMap();",
    "comment": "\n\t * Return a {@code Map} with the first values contained in this {@code MultiValueMap}.\n\t * The difference between this method and {@link #asSingleValueMap()} is\n\t * that this method returns a copy of the entries of this map, whereas\n\t * the latter returns a view.\n\t * @return a single value representation of this map\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#asSingleValueMap()",
    "entityType": "method",
    "code": "/**\r\n * Return this map as a {@code Map} with the first values contained in this\r\n * {@code MultiValueMap}.\r\n * <p>The difference between this method and {@link #toSingleValueMap()} is\r\n * that this method returns a view of the entries of this map, whereas\r\n * the latter returns a copy.\r\n * @return a single value representation of this map\r\n * @since 6.2\r\n */\r\ndefault Map<K, V> asSingleValueMap() {\r\n    return new MultiToSingleValueMapAdapter<>(this);\r\n}",
    "comment": "\n\t * Return this map as a {@code Map} with the first values contained in this\n\t * {@code MultiValueMap}.\n\t * <p>The difference between this method and {@link #toSingleValueMap()} is\n\t * that this method returns a view of the entries of this map, whereas\n\t * the latter returns a copy.\n\t * @return a single value representation of this map\n\t * @since 6.2\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code MultiValueMap<K, V>} that adapts the given single-value\r\n * {@code Map<K, V>}.\r\n * <p>The returned map cannot map multiple values to the same key,\r\n * and doing so results in an {@link UnsupportedOperationException}.\r\n * Use {@link #fromMultiValue(Map)} to support multiple values.\r\n * @param map the map to be adapted\r\n * @param <K> the key type\r\n * @param <V> the value element type\r\n * @return a multi-value-map that delegates to {@code map}\r\n * @since 6.2\r\n * @see #fromMultiValue(Map)\r\n */\r\nstatic <K, V> MultiValueMap<K, V> fromSingleValue(Map<K, V> map) {\r\n    Assert.notNull(map, \"Map must not be null\");\r\n    return new SingleToMultiValueMapAdapter<>(map);\r\n}",
    "comment": "\n\t * Return a {@code MultiValueMap<K, V>} that adapts the given single-value\n\t * {@code Map<K, V>}.\n\t * <p>The returned map cannot map multiple values to the same key,\n\t * and doing so results in an {@link UnsupportedOperationException}.\n\t * Use {@link #fromMultiValue(Map)} to support multiple values.\n\t * @param map the map to be adapted\n\t * @param <K> the key type\n\t * @param <V> the value element type\n\t * @return a multi-value-map that delegates to {@code map}\n\t * @since 6.2\n\t * @see #fromMultiValue(Map)\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMap#fromMultiValue(Map<K,List<V>>)",
    "entityType": "method",
    "code": "/**\r\n * Return a {@code MultiValueMap<K, V>} that adapts the given multi-value\r\n * {@code Map<K, List<V>>}.\r\n * @param map the map to be adapted\r\n * @param <K> the key type\r\n * @param <V> the value element type\r\n * @return a multi-value-map that delegates to {@code map}\r\n * @since 6.2\r\n * @see #fromSingleValue(Map)\r\n */\r\nstatic <K, V> MultiValueMap<K, V> fromMultiValue(Map<K, List<V>> map) {\r\n    Assert.notNull(map, \"Map must not be null\");\r\n    return new MultiValueMapAdapter<>(map);\r\n}",
    "comment": "\n\t * Return a {@code MultiValueMap<K, V>} that adapts the given multi-value\n\t * {@code Map<K, List<V>>}.\n\t * @param map the map to be adapted\n\t * @param <K> the key type\n\t * @param <V> the value element type\n\t * @return a multi-value-map that delegates to {@code map}\n\t * @since 6.2\n\t * @see #fromSingleValue(Map)\n\t "
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter",
    "entityType": "class",
    "code": "private final Map<K, List<V>> targetMap;\n/**\r\n * Wrap the given target {@link Map} as a {@link MultiValueMap} adapter.\r\n * @param targetMap the plain target {@code Map}\r\n */\r\npublic MultiValueMapAdapter(Map<K, List<V>> targetMap) {\r\n    Assert.notNull(targetMap, \"'targetMap' must not be null\");\r\n    this.targetMap = targetMap;\r\n}\n// MultiValueMap implementation\r\n@Override\r\n@Nullable\r\npublic V getFirst(K key) {\r\n    List<V> values = this.targetMap.get(key);\r\n    return (!CollectionUtils.isEmpty(values) ? values.get(0) : null);\r\n}\n@Override\r\npublic void add(K key, @Nullable V value) {\r\n    List<V> values = this.targetMap.computeIfAbsent(key, k -> new ArrayList<>(1));\r\n    values.add(value);\r\n}\n@Override\r\npublic void addAll(K key, List<? extends V> values) {\r\n    List<V> currentValues = this.targetMap.computeIfAbsent(key, k -> new ArrayList<>(values.size()));\r\n    currentValues.addAll(values);\r\n}\n@Override\r\npublic void addAll(MultiValueMap<K, V> values) {\r\n    values.forEach(this::addAll);\r\n}\n@Override\r\npublic void set(K key, @Nullable V value) {\r\n    List<V> values = new ArrayList<>(1);\r\n    values.add(value);\r\n    this.targetMap.put(key, values);\r\n}\n@Override\r\npublic void setAll(Map<K, V> values) {\r\n    values.forEach(this::set);\r\n}\n@Override\r\npublic Map<K, V> toSingleValueMap() {\r\n    Map<K, V> singleValueMap = CollectionUtils.newLinkedHashMap(this.targetMap.size());\r\n    this.targetMap.forEach((key, values) -> {\r\n        if (!CollectionUtils.isEmpty(values)) {\r\n            singleValueMap.put(key, values.get(0));\r\n        }\r\n    });\r\n    return singleValueMap;\r\n}\n// Map implementation\r\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}\n@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}\n@Override\r\npublic boolean containsKey(Object key) {\r\n    return this.targetMap.containsKey(key);\r\n}\n@Override\r\npublic boolean containsValue(Object value) {\r\n    return this.targetMap.containsValue(value);\r\n}\n@Override\r\n@Nullable\r\npublic List<V> get(Object key) {\r\n    return this.targetMap.get(key);\r\n}\n@Override\r\n@Nullable\r\npublic List<V> put(K key, List<V> value) {\r\n    return this.targetMap.put(key, value);\r\n}\n@Override\r\n@Nullable\r\npublic List<V> putIfAbsent(K key, List<V> value) {\r\n    return this.targetMap.putIfAbsent(key, value);\r\n}\n@Override\r\n@Nullable\r\npublic List<V> remove(Object key) {\r\n    return this.targetMap.remove(key);\r\n}\n@Override\r\npublic void putAll(Map<? extends K, ? extends List<V>> map) {\r\n    this.targetMap.putAll(map);\r\n}\n@Override\r\npublic void clear() {\r\n    this.targetMap.clear();\r\n}\n@Override\r\npublic Set<K> keySet() {\r\n    return this.targetMap.keySet();\r\n}\n@Override\r\npublic Collection<List<V>> values() {\r\n    return this.targetMap.values();\r\n}\n@Override\r\npublic Set<Entry<K, List<V>>> entrySet() {\r\n    return this.targetMap.entrySet();\r\n}\n@Override\r\npublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\r\n    this.targetMap.forEach(action);\r\n}\n@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || this.targetMap.equals(other));\r\n}\n@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}\n@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": "\n * Adapts a given {@link Map} to the {@link MultiValueMap} contract.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 5.3\n * @param <K> the key type\n * @param <V> the value element type\n * @see CollectionUtils#toMultiValueMap\n * @see LinkedMultiValueMap\n "
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#getFirst(K)",
    "entityType": "method",
    "code": "// MultiValueMap implementation\r\n@Override\r\n@Nullable\r\npublic V getFirst(K key) {\r\n    List<V> values = this.targetMap.get(key);\r\n    return (!CollectionUtils.isEmpty(values) ? values.get(0) : null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#add(K,V)",
    "entityType": "method",
    "code": "@Override\r\npublic void add(K key, @Nullable V value) {\r\n    List<V> values = this.targetMap.computeIfAbsent(key, k -> new ArrayList<>(1));\r\n    values.add(value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#addAll(K,List<? extends V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void addAll(K key, List<? extends V> values) {\r\n    List<V> currentValues = this.targetMap.computeIfAbsent(key, k -> new ArrayList<>(values.size()));\r\n    currentValues.addAll(values);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void addAll(MultiValueMap<K, V> values) {\r\n    values.forEach(this::addAll);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#set(K,V)",
    "entityType": "method",
    "code": "@Override\r\npublic void set(K key, @Nullable V value) {\r\n    List<V> values = new ArrayList<>(1);\r\n    values.add(value);\r\n    this.targetMap.put(key, values);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#setAll(Map<K,V>)",
    "entityType": "method",
    "code": "@Override\r\npublic void setAll(Map<K, V> values) {\r\n    values.forEach(this::set);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#toSingleValueMap()",
    "entityType": "method",
    "code": "@Override\r\npublic Map<K, V> toSingleValueMap() {\r\n    Map<K, V> singleValueMap = CollectionUtils.newLinkedHashMap(this.targetMap.size());\r\n    this.targetMap.forEach((key, values) -> {\r\n        if (!CollectionUtils.isEmpty(values)) {\r\n            singleValueMap.put(key, values.get(0));\r\n        }\r\n    });\r\n    return singleValueMap;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#size()",
    "entityType": "method",
    "code": "// Map implementation\r\n@Override\r\npublic int size() {\r\n    return this.targetMap.size();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#isEmpty()",
    "entityType": "method",
    "code": "@Override\r\npublic boolean isEmpty() {\r\n    return this.targetMap.isEmpty();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#containsKey(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return this.targetMap.containsKey(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#containsValue(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean containsValue(Object value) {\r\n    return this.targetMap.containsValue(value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#get(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> get(Object key) {\r\n    return this.targetMap.get(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#put(K,List<V>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> put(K key, List<V> value) {\r\n    return this.targetMap.put(key, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> putIfAbsent(K key, List<V> value) {\r\n    return this.targetMap.putIfAbsent(key, value);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic List<V> remove(Object key) {\r\n    return this.targetMap.remove(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void putAll(Map<? extends K, ? extends List<V>> map) {\r\n    this.targetMap.putAll(map);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    this.targetMap.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#keySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<K> keySet() {\r\n    return this.targetMap.keySet();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#values()",
    "entityType": "method",
    "code": "@Override\r\npublic Collection<List<V>> values() {\r\n    return this.targetMap.values();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#entrySet()",
    "entityType": "method",
    "code": "@Override\r\npublic Set<Entry<K, List<V>>> entrySet() {\r\n    return this.targetMap.entrySet();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(BiConsumer<? super K, ? super List<V>> action) {\r\n    this.targetMap.forEach(action);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || this.targetMap.equals(other));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.targetMap.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.MultiValueMapAdapter#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.targetMap.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.NumberUtils",
    "entityType": "class",
    "code": "private static final BigInteger LONG_MIN = BigInteger.valueOf(Long.MIN_VALUE);\nprivate static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n/**\r\n * Standard number types (all immutable):\r\n * Byte, Short, Integer, Long, BigInteger, Float, Double, BigDecimal.\r\n */\r\npublic static final Set<Class<?>> STANDARD_NUMBER_TYPES = Set.of(Byte.class, Short.class, Integer.class, Long.class, BigInteger.class, Float.class, Double.class, BigDecimal.class);\n/**\r\n * Convert the given number into an instance of the given target class.\r\n * @param number the number to convert\r\n * @param targetClass the target class to convert to\r\n * @return the converted number\r\n * @throws IllegalArgumentException if the target class is not supported\r\n * (i.e. not a standard Number subclass as included in the JDK)\r\n * @see java.lang.Byte\r\n * @see java.lang.Short\r\n * @see java.lang.Integer\r\n * @see java.lang.Long\r\n * @see java.math.BigInteger\r\n * @see java.lang.Float\r\n * @see java.lang.Double\r\n * @see java.math.BigDecimal\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass) throws IllegalArgumentException {\r\n    Assert.notNull(number, \"Number must not be null\");\r\n    Assert.notNull(targetClass, \"Target class must not be null\");\r\n    if (targetClass.isInstance(number)) {\r\n        return (T) number;\r\n    } else if (Byte.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\r\n            raiseOverflowException(number, targetClass);\r\n        }\r\n        return (T) Byte.valueOf(number.byteValue());\r\n    } else if (Short.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\r\n            raiseOverflowException(number, targetClass);\r\n        }\r\n        return (T) Short.valueOf(number.shortValue());\r\n    } else if (Integer.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\r\n            raiseOverflowException(number, targetClass);\r\n        }\r\n        return (T) Integer.valueOf(number.intValue());\r\n    } else if (Long.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        return (T) Long.valueOf(value);\r\n    } else if (BigInteger.class == targetClass) {\r\n        if (number instanceof BigDecimal bigDecimal) {\r\n            // do not lose precision - use BigDecimal's own conversion\r\n            return (T) bigDecimal.toBigInteger();\r\n        }\r\n        // original value is not a Big* number - use standard long conversion\r\n        return (T) BigInteger.valueOf(number.longValue());\r\n    } else if (Float.class == targetClass) {\r\n        return (T) Float.valueOf(number.floatValue());\r\n    } else if (Double.class == targetClass) {\r\n        return (T) Double.valueOf(number.doubleValue());\r\n    } else if (BigDecimal.class == targetClass) {\r\n        // always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\r\n        // (see BigDecimal javadoc for details)\r\n        return (T) new BigDecimal(number.toString());\r\n    } else {\r\n        throw new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" + number.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\r\n    }\r\n}\n/**\r\n * Check for a {@code BigInteger}/{@code BigDecimal} long overflow\r\n * before returning the given number as a long value.\r\n * @param number the number to convert\r\n * @param targetClass the target class to convert to\r\n * @return the long value, if convertible without overflow\r\n * @throws IllegalArgumentException if there is an overflow\r\n * @see #raiseOverflowException\r\n */\r\nprivate static long checkedLongValue(Number number, Class<? extends Number> targetClass) {\r\n    BigInteger bigInt = null;\r\n    if (number instanceof BigInteger bigInteger) {\r\n        bigInt = bigInteger;\r\n    } else if (number instanceof BigDecimal bigDecimal) {\r\n        bigInt = bigDecimal.toBigInteger();\r\n    }\r\n    // Effectively analogous to JDK 8's BigInteger.longValueExact()\r\n    if (bigInt != null && (bigInt.compareTo(LONG_MIN) < 0 || bigInt.compareTo(LONG_MAX) > 0)) {\r\n        raiseOverflowException(number, targetClass);\r\n    }\r\n    return number.longValue();\r\n}\n/**\r\n * Raise an <em>overflow</em> exception for the given number and target class.\r\n * @param number the number we tried to convert\r\n * @param targetClass the target class we tried to convert to\r\n * @throws IllegalArgumentException if there is an overflow\r\n */\r\nprivate static void raiseOverflowException(Number number, Class<?> targetClass) {\r\n    throw new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" + number.getClass().getName() + \"] to target class [\" + targetClass.getName() + \"]: overflow\");\r\n}\n/**\r\n * Parse the given {@code text} into a {@link Number} instance of the given\r\n * target class, using the corresponding {@code decode} / {@code valueOf} method.\r\n * <p>Trims all whitespace (leading, trailing, and in between characters) from\r\n * the input {@code String} before attempting to parse the number.\r\n * <p>Supports numbers in hex format (with leading \"0x\", \"0X\", or \"#\") as well.\r\n * @param text the text to convert\r\n * @param targetClass the target class to parse into\r\n * @return the parsed number\r\n * @throws IllegalArgumentException if the target class is not supported\r\n * (i.e. not a standard Number subclass as included in the JDK)\r\n * @see Byte#decode\r\n * @see Short#decode\r\n * @see Integer#decode\r\n * @see Long#decode\r\n * @see #decodeBigInteger(String)\r\n * @see Float#valueOf\r\n * @see Double#valueOf\r\n * @see java.math.BigDecimal#BigDecimal(String)\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Number> T parseNumber(String text, Class<T> targetClass) {\r\n    Assert.notNull(text, \"Text must not be null\");\r\n    Assert.notNull(targetClass, \"Target class must not be null\");\r\n    String trimmed = StringUtils.trimAllWhitespace(text);\r\n    if (Byte.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));\r\n    } else if (Short.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));\r\n    } else if (Integer.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));\r\n    } else if (Long.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));\r\n    } else if (BigInteger.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed));\r\n    } else if (Float.class == targetClass) {\r\n        return (T) Float.valueOf(trimmed);\r\n    } else if (Double.class == targetClass) {\r\n        return (T) Double.valueOf(trimmed);\r\n    } else if (BigDecimal.class == targetClass || Number.class == targetClass) {\r\n        return (T) new BigDecimal(trimmed);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Cannot convert String [\" + text + \"] to target class [\" + targetClass.getName() + \"]\");\r\n    }\r\n}\n/**\r\n * Parse the given {@code text} into a {@link Number} instance of the\r\n * given target class, using the supplied {@link NumberFormat}.\r\n * <p>Trims the input {@code String} before attempting to parse the number.\r\n * @param text the text to convert\r\n * @param targetClass the target class to parse into\r\n * @param numberFormat the {@code NumberFormat} to use for parsing (if\r\n * {@code null}, this method falls back to {@link #parseNumber(String, Class)})\r\n * @return the parsed number\r\n * @throws IllegalArgumentException if the target class is not supported\r\n * (i.e. not a standard Number subclass as included in the JDK)\r\n * @see java.text.NumberFormat#parse\r\n * @see #convertNumberToTargetClass\r\n * @see #parseNumber(String, Class)\r\n */\r\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\npublic static <T extends Number> T parseNumber(String text, Class<T> targetClass, @Nullable NumberFormat numberFormat) {\r\n    if (numberFormat != null) {\r\n        Assert.notNull(text, \"Text must not be null\");\r\n        Assert.notNull(targetClass, \"Target class must not be null\");\r\n        DecimalFormat decimalFormat = null;\r\n        boolean resetBigDecimal = false;\r\n        if (numberFormat instanceof DecimalFormat dc) {\r\n            decimalFormat = dc;\r\n            if (BigDecimal.class == targetClass && !decimalFormat.isParseBigDecimal()) {\r\n                decimalFormat.setParseBigDecimal(true);\r\n                resetBigDecimal = true;\r\n            }\r\n        }\r\n        try {\r\n            Number number = numberFormat.parse(StringUtils.trimAllWhitespace(text));\r\n            return convertNumberToTargetClass(number, targetClass);\r\n        } catch (ParseException ex) {\r\n            throw new IllegalArgumentException(\"Could not parse number: \" + ex.getMessage());\r\n        } finally {\r\n            if (resetBigDecimal) {\r\n                decimalFormat.setParseBigDecimal(false);\r\n            }\r\n        }\r\n    } else {\r\n        return parseNumber(text, targetClass);\r\n    }\r\n}\n/**\r\n * Determine whether the given {@code value} String indicates a hex number,\r\n * i.e. needs to be passed into {@code Integer.decode} instead of\r\n * {@code Integer.valueOf}, etc.\r\n */\r\nprivate static boolean isHexNumber(String value) {\r\n    int index = (value.startsWith(\"-\") ? 1 : 0);\r\n    return (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index) || value.startsWith(\"#\", index));\r\n}\n/**\r\n * Decode a {@link java.math.BigInteger} from the supplied {@link String} value.\r\n * <p>Supports decimal, hex, and octal notation.\r\n * @see BigInteger#BigInteger(String, int)\r\n */\r\nprivate static BigInteger decodeBigInteger(String value) {\r\n    int radix = 10;\r\n    int index = 0;\r\n    boolean negative = false;\r\n    // Handle minus sign, if present.\r\n    if (value.startsWith(\"-\")) {\r\n        negative = true;\r\n        index++;\r\n    }\r\n    // Handle radix specifier, if present.\r\n    if (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index)) {\r\n        index += 2;\r\n        radix = 16;\r\n    } else if (value.startsWith(\"#\", index)) {\r\n        index++;\r\n        radix = 16;\r\n    } else if (value.startsWith(\"0\", index) && value.length() > 1 + index) {\r\n        index++;\r\n        radix = 8;\r\n    }\r\n    BigInteger result = new BigInteger(value.substring(index), radix);\r\n    return (negative ? result.negate() : result);\r\n}",
    "comment": "\n * Miscellaneous utility methods for number conversion and parsing.\n * <p>Mainly for internal use within the framework; consider Apache's\n * Commons Lang for a more comprehensive suite of number utilities.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 1.1.2\n "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given number into an instance of the given target class.\r\n * @param number the number to convert\r\n * @param targetClass the target class to convert to\r\n * @return the converted number\r\n * @throws IllegalArgumentException if the target class is not supported\r\n * (i.e. not a standard Number subclass as included in the JDK)\r\n * @see java.lang.Byte\r\n * @see java.lang.Short\r\n * @see java.lang.Integer\r\n * @see java.lang.Long\r\n * @see java.math.BigInteger\r\n * @see java.lang.Float\r\n * @see java.lang.Double\r\n * @see java.math.BigDecimal\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass) throws IllegalArgumentException {\r\n    Assert.notNull(number, \"Number must not be null\");\r\n    Assert.notNull(targetClass, \"Target class must not be null\");\r\n    if (targetClass.isInstance(number)) {\r\n        return (T) number;\r\n    } else if (Byte.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\r\n            raiseOverflowException(number, targetClass);\r\n        }\r\n        return (T) Byte.valueOf(number.byteValue());\r\n    } else if (Short.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\r\n            raiseOverflowException(number, targetClass);\r\n        }\r\n        return (T) Short.valueOf(number.shortValue());\r\n    } else if (Integer.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {\r\n            raiseOverflowException(number, targetClass);\r\n        }\r\n        return (T) Integer.valueOf(number.intValue());\r\n    } else if (Long.class == targetClass) {\r\n        long value = checkedLongValue(number, targetClass);\r\n        return (T) Long.valueOf(value);\r\n    } else if (BigInteger.class == targetClass) {\r\n        if (number instanceof BigDecimal bigDecimal) {\r\n            // do not lose precision - use BigDecimal's own conversion\r\n            return (T) bigDecimal.toBigInteger();\r\n        }\r\n        // original value is not a Big* number - use standard long conversion\r\n        return (T) BigInteger.valueOf(number.longValue());\r\n    } else if (Float.class == targetClass) {\r\n        return (T) Float.valueOf(number.floatValue());\r\n    } else if (Double.class == targetClass) {\r\n        return (T) Double.valueOf(number.doubleValue());\r\n    } else if (BigDecimal.class == targetClass) {\r\n        // always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)\r\n        // (see BigDecimal javadoc for details)\r\n        return (T) new BigDecimal(number.toString());\r\n    } else {\r\n        throw new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" + number.getClass().getName() + \"] to unsupported target class [\" + targetClass.getName() + \"]\");\r\n    }\r\n}",
    "comment": "\n\t * Convert the given number into an instance of the given target class.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the converted number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.lang.Byte\n\t * @see java.lang.Short\n\t * @see java.lang.Integer\n\t * @see java.lang.Long\n\t * @see java.math.BigInteger\n\t * @see java.lang.Float\n\t * @see java.lang.Double\n\t * @see java.math.BigDecimal\n\t "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
    "entityType": "method",
    "code": "/**\r\n * Check for a {@code BigInteger}/{@code BigDecimal} long overflow\r\n * before returning the given number as a long value.\r\n * @param number the number to convert\r\n * @param targetClass the target class to convert to\r\n * @return the long value, if convertible without overflow\r\n * @throws IllegalArgumentException if there is an overflow\r\n * @see #raiseOverflowException\r\n */\r\nprivate static long checkedLongValue(Number number, Class<? extends Number> targetClass) {\r\n    BigInteger bigInt = null;\r\n    if (number instanceof BigInteger bigInteger) {\r\n        bigInt = bigInteger;\r\n    } else if (number instanceof BigDecimal bigDecimal) {\r\n        bigInt = bigDecimal.toBigInteger();\r\n    }\r\n    // Effectively analogous to JDK 8's BigInteger.longValueExact()\r\n    if (bigInt != null && (bigInt.compareTo(LONG_MIN) < 0 || bigInt.compareTo(LONG_MAX) > 0)) {\r\n        raiseOverflowException(number, targetClass);\r\n    }\r\n    return number.longValue();\r\n}",
    "comment": "\n\t * Check for a {@code BigInteger}/{@code BigDecimal} long overflow\n\t * before returning the given number as a long value.\n\t * @param number the number to convert\n\t * @param targetClass the target class to convert to\n\t * @return the long value, if convertible without overflow\n\t * @throws IllegalArgumentException if there is an overflow\n\t * @see #raiseOverflowException\n\t "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Raise an <em>overflow</em> exception for the given number and target class.\r\n * @param number the number we tried to convert\r\n * @param targetClass the target class we tried to convert to\r\n * @throws IllegalArgumentException if there is an overflow\r\n */\r\nprivate static void raiseOverflowException(Number number, Class<?> targetClass) {\r\n    throw new IllegalArgumentException(\"Could not convert number [\" + number + \"] of type [\" + number.getClass().getName() + \"] to target class [\" + targetClass.getName() + \"]: overflow\");\r\n}",
    "comment": "\n\t * Raise an <em>overflow</em> exception for the given number and target class.\n\t * @param number the number we tried to convert\n\t * @param targetClass the target class we tried to convert to\n\t * @throws IllegalArgumentException if there is an overflow\n\t "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
    "entityType": "method",
    "code": "/**\r\n * Parse the given {@code text} into a {@link Number} instance of the given\r\n * target class, using the corresponding {@code decode} / {@code valueOf} method.\r\n * <p>Trims all whitespace (leading, trailing, and in between characters) from\r\n * the input {@code String} before attempting to parse the number.\r\n * <p>Supports numbers in hex format (with leading \"0x\", \"0X\", or \"#\") as well.\r\n * @param text the text to convert\r\n * @param targetClass the target class to parse into\r\n * @return the parsed number\r\n * @throws IllegalArgumentException if the target class is not supported\r\n * (i.e. not a standard Number subclass as included in the JDK)\r\n * @see Byte#decode\r\n * @see Short#decode\r\n * @see Integer#decode\r\n * @see Long#decode\r\n * @see #decodeBigInteger(String)\r\n * @see Float#valueOf\r\n * @see Double#valueOf\r\n * @see java.math.BigDecimal#BigDecimal(String)\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T extends Number> T parseNumber(String text, Class<T> targetClass) {\r\n    Assert.notNull(text, \"Text must not be null\");\r\n    Assert.notNull(targetClass, \"Target class must not be null\");\r\n    String trimmed = StringUtils.trimAllWhitespace(text);\r\n    if (Byte.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));\r\n    } else if (Short.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));\r\n    } else if (Integer.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));\r\n    } else if (Long.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));\r\n    } else if (BigInteger.class == targetClass) {\r\n        return (T) (isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed));\r\n    } else if (Float.class == targetClass) {\r\n        return (T) Float.valueOf(trimmed);\r\n    } else if (Double.class == targetClass) {\r\n        return (T) Double.valueOf(trimmed);\r\n    } else if (BigDecimal.class == targetClass || Number.class == targetClass) {\r\n        return (T) new BigDecimal(trimmed);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Cannot convert String [\" + text + \"] to target class [\" + targetClass.getName() + \"]\");\r\n    }\r\n}",
    "comment": "\n\t * Parse the given {@code text} into a {@link Number} instance of the given\n\t * target class, using the corresponding {@code decode} / {@code valueOf} method.\n\t * <p>Trims all whitespace (leading, trailing, and in between characters) from\n\t * the input {@code String} before attempting to parse the number.\n\t * <p>Supports numbers in hex format (with leading \"0x\", \"0X\", or \"#\") as well.\n\t * @param text the text to convert\n\t * @param targetClass the target class to parse into\n\t * @return the parsed number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see Byte#decode\n\t * @see Short#decode\n\t * @see Integer#decode\n\t * @see Long#decode\n\t * @see #decodeBigInteger(String)\n\t * @see Float#valueOf\n\t * @see Double#valueOf\n\t * @see java.math.BigDecimal#BigDecimal(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
    "entityType": "method",
    "code": "/**\r\n * Parse the given {@code text} into a {@link Number} instance of the\r\n * given target class, using the supplied {@link NumberFormat}.\r\n * <p>Trims the input {@code String} before attempting to parse the number.\r\n * @param text the text to convert\r\n * @param targetClass the target class to parse into\r\n * @param numberFormat the {@code NumberFormat} to use for parsing (if\r\n * {@code null}, this method falls back to {@link #parseNumber(String, Class)})\r\n * @return the parsed number\r\n * @throws IllegalArgumentException if the target class is not supported\r\n * (i.e. not a standard Number subclass as included in the JDK)\r\n * @see java.text.NumberFormat#parse\r\n * @see #convertNumberToTargetClass\r\n * @see #parseNumber(String, Class)\r\n */\r\n// Dataflow analysis limitation\r\n@SuppressWarnings(\"NullAway\")\r\npublic static <T extends Number> T parseNumber(String text, Class<T> targetClass, @Nullable NumberFormat numberFormat) {\r\n    if (numberFormat != null) {\r\n        Assert.notNull(text, \"Text must not be null\");\r\n        Assert.notNull(targetClass, \"Target class must not be null\");\r\n        DecimalFormat decimalFormat = null;\r\n        boolean resetBigDecimal = false;\r\n        if (numberFormat instanceof DecimalFormat dc) {\r\n            decimalFormat = dc;\r\n            if (BigDecimal.class == targetClass && !decimalFormat.isParseBigDecimal()) {\r\n                decimalFormat.setParseBigDecimal(true);\r\n                resetBigDecimal = true;\r\n            }\r\n        }\r\n        try {\r\n            Number number = numberFormat.parse(StringUtils.trimAllWhitespace(text));\r\n            return convertNumberToTargetClass(number, targetClass);\r\n        } catch (ParseException ex) {\r\n            throw new IllegalArgumentException(\"Could not parse number: \" + ex.getMessage());\r\n        } finally {\r\n            if (resetBigDecimal) {\r\n                decimalFormat.setParseBigDecimal(false);\r\n            }\r\n        }\r\n    } else {\r\n        return parseNumber(text, targetClass);\r\n    }\r\n}",
    "comment": "\n\t * Parse the given {@code text} into a {@link Number} instance of the\n\t * given target class, using the supplied {@link NumberFormat}.\n\t * <p>Trims the input {@code String} before attempting to parse the number.\n\t * @param text the text to convert\n\t * @param targetClass the target class to parse into\n\t * @param numberFormat the {@code NumberFormat} to use for parsing (if\n\t * {@code null}, this method falls back to {@link #parseNumber(String, Class)})\n\t * @return the parsed number\n\t * @throws IllegalArgumentException if the target class is not supported\n\t * (i.e. not a standard Number subclass as included in the JDK)\n\t * @see java.text.NumberFormat#parse\n\t * @see #convertNumberToTargetClass\n\t * @see #parseNumber(String, Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#isHexNumber(String)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given {@code value} String indicates a hex number,\r\n * i.e. needs to be passed into {@code Integer.decode} instead of\r\n * {@code Integer.valueOf}, etc.\r\n */\r\nprivate static boolean isHexNumber(String value) {\r\n    int index = (value.startsWith(\"-\") ? 1 : 0);\r\n    return (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index) || value.startsWith(\"#\", index));\r\n}",
    "comment": "\n\t * Determine whether the given {@code value} String indicates a hex number,\n\t * i.e. needs to be passed into {@code Integer.decode} instead of\n\t * {@code Integer.valueOf}, etc.\n\t "
  },
  {
    "entityId": "org.springframework.util.NumberUtils#decodeBigInteger(String)",
    "entityType": "method",
    "code": "/**\r\n * Decode a {@link java.math.BigInteger} from the supplied {@link String} value.\r\n * <p>Supports decimal, hex, and octal notation.\r\n * @see BigInteger#BigInteger(String, int)\r\n */\r\nprivate static BigInteger decodeBigInteger(String value) {\r\n    int radix = 10;\r\n    int index = 0;\r\n    boolean negative = false;\r\n    // Handle minus sign, if present.\r\n    if (value.startsWith(\"-\")) {\r\n        negative = true;\r\n        index++;\r\n    }\r\n    // Handle radix specifier, if present.\r\n    if (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index)) {\r\n        index += 2;\r\n        radix = 16;\r\n    } else if (value.startsWith(\"#\", index)) {\r\n        index++;\r\n        radix = 16;\r\n    } else if (value.startsWith(\"0\", index) && value.length() > 1 + index) {\r\n        index++;\r\n        radix = 8;\r\n    }\r\n    BigInteger result = new BigInteger(value.substring(index), radix);\r\n    return (negative ? result.negate() : result);\r\n}",
    "comment": "\n\t * Decode a {@link java.math.BigInteger} from the supplied {@link String} value.\n\t * <p>Supports decimal, hex, and octal notation.\n\t * @see BigInteger#BigInteger(String, int)\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils",
    "entityType": "class",
    "code": "private static final String EMPTY_STRING = \"\";\nprivate static final String NULL_STRING = \"null\";\nprivate static final String ARRAY_START = \"{\";\nprivate static final String ARRAY_END = \"}\";\nprivate static final String EMPTY_ARRAY = ARRAY_START + ARRAY_END;\nprivate static final String ARRAY_ELEMENT_SEPARATOR = \", \";\nprivate static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\nprivate static final String NON_EMPTY_ARRAY = ARRAY_START + \"...\" + ARRAY_END;\nprivate static final String COLLECTION = \"[...]\";\nprivate static final String MAP = NON_EMPTY_ARRAY;\n/**\r\n * Return whether the given throwable is a checked exception:\r\n * that is, neither a RuntimeException nor an Error.\r\n * @param ex the throwable to check\r\n * @return whether the throwable is a checked exception\r\n * @see java.lang.Exception\r\n * @see java.lang.RuntimeException\r\n * @see java.lang.Error\r\n */\r\npublic static boolean isCheckedException(Throwable ex) {\r\n    return !(ex instanceof RuntimeException || ex instanceof Error);\r\n}\n/**\r\n * Check whether the given exception is compatible with the specified\r\n * exception types, as declared in a {@code throws} clause.\r\n * @param ex the exception to check\r\n * @param declaredExceptions the exception types declared in the throws clause\r\n * @return whether the given exception is compatible\r\n */\r\npublic static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>@Nullable ... declaredExceptions) {\r\n    if (!isCheckedException(ex)) {\r\n        return true;\r\n    }\r\n    if (declaredExceptions != null) {\r\n        for (Class<?> declaredException : declaredExceptions) {\r\n            if (declaredException.isInstance(ex)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Determine whether the given object is an array:\r\n * either an Object array or a primitive array.\r\n * @param obj the object to check\r\n */\r\n@Contract(\"null -> false\")\r\npublic static boolean isArray(@Nullable Object obj) {\r\n    return (obj != null && obj.getClass().isArray());\r\n}\n/**\r\n * Determine whether the given array is empty:\r\n * i.e. {@code null} or of zero length.\r\n * @param array the array to check\r\n * @see #isEmpty(Object)\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Object @Nullable [] array) {\r\n    return (array == null || array.length == 0);\r\n}\n/**\r\n * Determine whether the given object is empty.\r\n * <p>This method supports the following object types.\r\n * <ul>\r\n * <li>{@code Optional}: considered empty if not {@link Optional#isPresent()}</li>\r\n * <li>{@code Array}: considered empty if its length is zero</li>\r\n * <li>{@link CharSequence}: considered empty if its length is zero</li>\r\n * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>\r\n * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>\r\n * </ul>\r\n * <p>If the given object is non-null and not one of the aforementioned\r\n * supported types, this method returns {@code false}.\r\n * @param obj the object to check\r\n * @return {@code true} if the object is {@code null} or <em>empty</em>\r\n * @since 4.2\r\n * @see Optional#isPresent()\r\n * @see ObjectUtils#isEmpty(Object[])\r\n * @see StringUtils#hasLength(CharSequence)\r\n * @see CollectionUtils#isEmpty(java.util.Collection)\r\n * @see CollectionUtils#isEmpty(java.util.Map)\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return true;\r\n    }\r\n    if (obj instanceof Optional<?> optional) {\r\n        return optional.isEmpty();\r\n    }\r\n    if (obj instanceof CharSequence charSequence) {\r\n        return charSequence.isEmpty();\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        return Array.getLength(obj) == 0;\r\n    }\r\n    if (obj instanceof Collection<?> collection) {\r\n        return collection.isEmpty();\r\n    }\r\n    if (obj instanceof Map<?, ?> map) {\r\n        return map.isEmpty();\r\n    }\r\n    // else\r\n    return false;\r\n}\n/**\r\n * Unwrap the given object which is potentially a {@link java.util.Optional}.\r\n * @param obj the candidate object\r\n * @return either the value held within the {@code Optional}, {@code null}\r\n * if the {@code Optional} is empty, or simply the given object as-is\r\n * @since 5.0\r\n */\r\n@Nullable\r\npublic static Object unwrapOptional(@Nullable Object obj) {\r\n    if (obj instanceof Optional<?> optional) {\r\n        Object result = optional.orElse(null);\r\n        Assert.isTrue(!(result instanceof Optional), \"Multi-level Optional usage not supported\");\r\n        return result;\r\n    }\r\n    return obj;\r\n}\n/**\r\n * Check whether the given array contains the given element.\r\n * @param array the array to check (may be {@code null},\r\n * in which case the return value will always be {@code false})\r\n * @param element the element to check for\r\n * @return whether the element has been found in the given array\r\n */\r\npublic static boolean containsElement(@Nullable Object @Nullable [] array, @Nullable Object element) {\r\n    if (array == null) {\r\n        return false;\r\n    }\r\n    for (Object arrayEle : array) {\r\n        if (nullSafeEquals(arrayEle, element)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Check whether the given array of enum constants contains a constant with the given name,\r\n * ignoring case when determining a match.\r\n * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\r\n * @param constant the constant name to find (must not be null or empty string)\r\n * @return whether the constant has been found in the given array\r\n */\r\npublic static boolean containsConstant(Enum<?>[] enumValues, String constant) {\r\n    return containsConstant(enumValues, constant, false);\r\n}\n/**\r\n * Check whether the given array of enum constants contains a constant with the given name.\r\n * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\r\n * @param constant the constant name to find (must not be null or empty string)\r\n * @param caseSensitive whether case is significant in determining a match\r\n * @return whether the constant has been found in the given array\r\n */\r\npublic static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\r\n    for (Enum<?> candidate : enumValues) {\r\n        if (caseSensitive ? candidate.toString().equals(constant) : candidate.toString().equalsIgnoreCase(constant)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n/**\r\n * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.\r\n * @param <E> the concrete Enum type\r\n * @param enumValues the array of all Enum constants in question, usually per {@code Enum.values()}\r\n * @param constant the constant to get the enum value of\r\n * @throws IllegalArgumentException if the given constant is not found in the given array\r\n * of enum values. Use {@link #containsConstant(Enum[], String)} as a guard to avoid this exception.\r\n */\r\npublic static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {\r\n    for (E candidate : enumValues) {\r\n        if (candidate.toString().equalsIgnoreCase(constant)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Constant [\" + constant + \"] does not exist in enum type \" + enumValues.getClass().componentType().getName());\r\n}\n/**\r\n * Append the given object to the given array, returning a new array\r\n * consisting of the input array contents plus the given object.\r\n * @param array the array to append to (can be {@code null})\r\n * @param obj the object to append\r\n * @return the new array (of the same component type; never {@code null})\r\n */\r\npublic static <A, O extends A> A[] addObjectToArray(A @Nullable [] array, @Nullable O obj) {\r\n    return addObjectToArray(array, obj, (array != null ? array.length : 0));\r\n}\n/**\r\n * Add the given object to the given array at the specified position, returning\r\n * a new array consisting of the input array contents plus the given object.\r\n * @param array the array to add to (can be {@code null})\r\n * @param obj the object to append\r\n * @param position the position at which to add the object\r\n * @return the new array (of the same component type; never {@code null})\r\n * @since 6.0\r\n */\r\n@Nullable\r\npublic static <A, O extends A> A[] addObjectToArray(A @Nullable [] array, @Nullable O obj, int position) {\r\n    Class<?> componentType = Object.class;\r\n    if (array != null) {\r\n        componentType = array.getClass().componentType();\r\n    } else if (obj != null) {\r\n        componentType = obj.getClass();\r\n    }\r\n    int newArrayLength = (array != null ? array.length + 1 : 1);\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    A[] newArray = (A[]) Array.newInstance(componentType, newArrayLength);\r\n    if (array != null) {\r\n        System.arraycopy(array, 0, newArray, 0, position);\r\n        System.arraycopy(array, position, newArray, position + 1, array.length - position);\r\n    }\r\n    newArray[position] = obj;\r\n    return newArray;\r\n}\n/**\r\n * Convert the given array (which may be a primitive array) to an object array (if\r\n * necessary, to an array of primitive wrapper objects).\r\n * <p>A {@code null} source value or empty primitive array will be converted to an\r\n * empty Object array.\r\n * @param source the (potentially primitive) array\r\n * @return the corresponding object array (never {@code null})\r\n * @throws IllegalArgumentException if the parameter is not an array\r\n */\r\npublic static Object[] toObjectArray(@Nullable Object source) {\r\n    if (source instanceof Object[] objects) {\r\n        return objects;\r\n    }\r\n    if (source == null) {\r\n        return EMPTY_OBJECT_ARRAY;\r\n    }\r\n    if (!source.getClass().isArray()) {\r\n        throw new IllegalArgumentException(\"Source is not an array: \" + source);\r\n    }\r\n    int length = Array.getLength(source);\r\n    if (length == 0) {\r\n        return EMPTY_OBJECT_ARRAY;\r\n    }\r\n    Class<?> wrapperType = Array.get(source, 0).getClass();\r\n    Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);\r\n    for (int i = 0; i < length; i++) {\r\n        newArray[i] = Array.get(source, i);\r\n    }\r\n    return newArray;\r\n}\n//---------------------------------------------------------------------\r\n// Convenience methods for content-based equality/hash-code handling\r\n//---------------------------------------------------------------------\r\n/**\r\n * Determine if the given objects are equal, returning {@code true} if\r\n * both are {@code null} or {@code false} if only one is {@code null}.\r\n * <p>Compares arrays with {@code Arrays.equals}, performing an equality\r\n * check based on the array elements rather than the array reference.\r\n * @param o1 first Object to compare\r\n * @param o2 second Object to compare\r\n * @return whether the given objects are equal\r\n * @see Object#equals(Object)\r\n * @see java.util.Arrays#equals\r\n */\r\n@Contract(\"null, null -> true; null, _ -> false; _, null -> false\")\r\npublic static boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2) {\r\n    if (o1 == o2) {\r\n        return true;\r\n    }\r\n    if (o1 == null || o2 == null) {\r\n        return false;\r\n    }\r\n    if (o1.equals(o2)) {\r\n        return true;\r\n    }\r\n    if (o1.getClass().isArray() && o2.getClass().isArray()) {\r\n        return arrayEquals(o1, o2);\r\n    }\r\n    return false;\r\n}\n/**\r\n * Compare the given arrays with {@code Arrays.equals}, performing an equality\r\n * check based on the array elements rather than the array reference.\r\n * @param o1 first array to compare\r\n * @param o2 second array to compare\r\n * @return whether the given objects are equal\r\n * @see #nullSafeEquals(Object, Object)\r\n * @see java.util.Arrays#equals\r\n */\r\nprivate static boolean arrayEquals(Object o1, Object o2) {\r\n    if (o1 instanceof Object[] objects1 && o2 instanceof Object[] objects2) {\r\n        return Arrays.equals(objects1, objects2);\r\n    }\r\n    if (o1 instanceof boolean[] booleans1 && o2 instanceof boolean[] booleans2) {\r\n        return Arrays.equals(booleans1, booleans2);\r\n    }\r\n    if (o1 instanceof byte[] bytes1 && o2 instanceof byte[] bytes2) {\r\n        return Arrays.equals(bytes1, bytes2);\r\n    }\r\n    if (o1 instanceof char[] chars1 && o2 instanceof char[] chars2) {\r\n        return Arrays.equals(chars1, chars2);\r\n    }\r\n    if (o1 instanceof double[] doubles1 && o2 instanceof double[] doubles2) {\r\n        return Arrays.equals(doubles1, doubles2);\r\n    }\r\n    if (o1 instanceof float[] floats1 && o2 instanceof float[] floats2) {\r\n        return Arrays.equals(floats1, floats2);\r\n    }\r\n    if (o1 instanceof int[] ints1 && o2 instanceof int[] ints2) {\r\n        return Arrays.equals(ints1, ints2);\r\n    }\r\n    if (o1 instanceof long[] longs1 && o2 instanceof long[] longs2) {\r\n        return Arrays.equals(longs1, longs2);\r\n    }\r\n    if (o1 instanceof short[] shorts1 && o2 instanceof short[] shorts2) {\r\n        return Arrays.equals(shorts1, shorts2);\r\n    }\r\n    return false;\r\n}\n/**\r\n * Return a hash code for the given elements, delegating to\r\n * {@link #nullSafeHashCode(Object)} for each element. Contrary\r\n * to {@link Objects#hash(Object...)}, this method can handle an\r\n * element that is an array.\r\n * @param elements the elements to be hashed\r\n * @return a hash value of the elements\r\n * @since 6.1\r\n */\r\npublic static int nullSafeHash(@Nullable Object@Nullable ... elements) {\r\n    if (elements == null) {\r\n        return 0;\r\n    }\r\n    int result = 1;\r\n    for (Object element : elements) {\r\n        result = 31 * result + nullSafeHashCode(element);\r\n    }\r\n    return result;\r\n}\n/**\r\n * Return a hash code for the given object; typically the value of\r\n * {@code Object#hashCode()}}. If the object is an array,\r\n * this method will delegate to any of the {@code Arrays.hashCode}\r\n * methods. If the object is {@code null}, this method returns 0.\r\n * @see Object#hashCode()\r\n * @see Arrays\r\n */\r\npublic static int nullSafeHashCode(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        if (obj instanceof Object[] objects) {\r\n            return Arrays.hashCode(objects);\r\n        }\r\n        if (obj instanceof boolean[] booleans) {\r\n            return Arrays.hashCode(booleans);\r\n        }\r\n        if (obj instanceof byte[] bytes) {\r\n            return Arrays.hashCode(bytes);\r\n        }\r\n        if (obj instanceof char[] chars) {\r\n            return Arrays.hashCode(chars);\r\n        }\r\n        if (obj instanceof double[] doubles) {\r\n            return Arrays.hashCode(doubles);\r\n        }\r\n        if (obj instanceof float[] floats) {\r\n            return Arrays.hashCode(floats);\r\n        }\r\n        if (obj instanceof int[] ints) {\r\n            return Arrays.hashCode(ints);\r\n        }\r\n        if (obj instanceof long[] longs) {\r\n            return Arrays.hashCode(longs);\r\n        }\r\n        if (obj instanceof short[] shorts) {\r\n            return Arrays.hashCode(shorts);\r\n        }\r\n    }\r\n    return obj.hashCode();\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(Object[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(Object @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(boolean[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(boolean @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(byte[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(byte @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(char[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(char @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(double[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(double @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(float[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(float @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(int[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(int @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(long[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(long @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(short[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(short @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}\n//---------------------------------------------------------------------\r\n// Convenience methods for toString output\r\n//---------------------------------------------------------------------\r\n/**\r\n * Return a String representation of an object's overall identity.\r\n * @param obj the object (may be {@code null})\r\n * @return the object's identity as String representation,\r\n * or an empty String if the object was {@code null}\r\n */\r\npublic static String identityToString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return EMPTY_STRING;\r\n    }\r\n    return obj.getClass().getName() + \"@\" + getIdentityHexString(obj);\r\n}\n/**\r\n * Return a hex String form of an object's identity hash code.\r\n * @param obj the object\r\n * @return the object's identity code in hex notation\r\n */\r\npublic static String getIdentityHexString(Object obj) {\r\n    return Integer.toHexString(System.identityHashCode(obj));\r\n}\n/**\r\n * Return a content-based String representation if {@code obj} is\r\n * not {@code null}; otherwise returns an empty String.\r\n * <p>Differs from {@link #nullSafeToString(Object)} in that it returns\r\n * an empty String rather than \"null\" for a {@code null} value.\r\n * @param obj the object to build a display String for\r\n * @return a display String representation of {@code obj}\r\n * @see #nullSafeToString(Object)\r\n */\r\npublic static String getDisplayString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return EMPTY_STRING;\r\n    }\r\n    return nullSafeToString(obj);\r\n}\n/**\r\n * Determine the class name for the given object.\r\n * <p>Returns a {@code \"null\"} String if {@code obj} is {@code null}.\r\n * @param obj the object to introspect (may be {@code null})\r\n * @return the corresponding class name\r\n */\r\npublic static String nullSafeClassName(@Nullable Object obj) {\r\n    return (obj != null ? obj.getClass().getName() : NULL_STRING);\r\n}\n/**\r\n * Return a String representation of the specified Object.\r\n * <p>Builds a String representation of the contents in case of an array.\r\n * Returns a {@code \"null\"} String if {@code obj} is {@code null}.\r\n * @param obj the object to build a String representation for\r\n * @return a String representation of {@code obj}\r\n * @see #nullSafeConciseToString(Object)\r\n */\r\npublic static String nullSafeToString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (obj instanceof String string) {\r\n        return string;\r\n    }\r\n    if (obj instanceof Object[] objects) {\r\n        return nullSafeToString(objects);\r\n    }\r\n    if (obj instanceof boolean[] booleans) {\r\n        return nullSafeToString(booleans);\r\n    }\r\n    if (obj instanceof byte[] bytes) {\r\n        return nullSafeToString(bytes);\r\n    }\r\n    if (obj instanceof char[] chars) {\r\n        return nullSafeToString(chars);\r\n    }\r\n    if (obj instanceof double[] doubles) {\r\n        return nullSafeToString(doubles);\r\n    }\r\n    if (obj instanceof float[] floats) {\r\n        return nullSafeToString(floats);\r\n    }\r\n    if (obj instanceof int[] ints) {\r\n        return nullSafeToString(ints);\r\n    }\r\n    if (obj instanceof long[] longs) {\r\n        return nullSafeToString(longs);\r\n    }\r\n    if (obj instanceof short[] shorts) {\r\n        return nullSafeToString(shorts);\r\n    }\r\n    String str = obj.toString();\r\n    return (str != null ? str : EMPTY_STRING);\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(@Nullable Object @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    int length = array.length;\r\n    if (length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (Object o : array) {\r\n        stringJoiner.add(String.valueOf(o));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(boolean @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    int length = array.length;\r\n    if (length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (boolean b : array) {\r\n        stringJoiner.add(String.valueOf(b));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(byte @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (byte b : array) {\r\n        stringJoiner.add(String.valueOf(b));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(char @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (char c : array) {\r\n        stringJoiner.add('\\'' + String.valueOf(c) + '\\'');\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(double @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (double d : array) {\r\n        stringJoiner.add(String.valueOf(d));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(float @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (float f : array) {\r\n        stringJoiner.add(String.valueOf(f));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(int @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (int i : array) {\r\n        stringJoiner.add(String.valueOf(i));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(long @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    int length = array.length;\r\n    if (length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (long l : array) {\r\n        stringJoiner.add(String.valueOf(l));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(short @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (short s : array) {\r\n        stringJoiner.add(String.valueOf(s));\r\n    }\r\n    return stringJoiner.toString();\r\n}\n/**\r\n * Generate a null-safe, concise string representation of the supplied object\r\n * as described below.\r\n * <p>Favor this method over {@link #nullSafeToString(Object)} when you need\r\n * the length of the generated string to be limited.\r\n * <p>Returns:\r\n * <ul>\r\n * <li>{@code \"null\"} if {@code obj} is {@code null}</li>\r\n * <li>{@code \"Optional.empty\"} if {@code obj} is an empty {@link Optional}</li>\r\n * <li>{@code \"Optional[<concise-string>]\"} if {@code obj} is a non-empty {@code Optional},\r\n * where {@code <concise-string>} is the result of invoking this method on the object\r\n * contained in the {@code Optional}</li>\r\n * <li>{@code \";\"} if {@code obj} is an empty array</li>\r\n * <li>{@code \"{...}\"} if {@code obj} is a {@link Map} or a non-empty array</li>\r\n * <li>{@code \"[...]\"} if {@code obj} is a {@link Collection}</li>\r\n * <li>{@linkplain Class#getName() Class name} if {@code obj} is a {@link Class}</li>\r\n * <li>{@linkplain Charset#name() Charset name} if {@code obj} is a {@link Charset}</li>\r\n * <li>{@linkplain TimeZone#getID() TimeZone ID} if {@code obj} is a {@link TimeZone}</li>\r\n * <li>{@linkplain ZoneId#getId() Zone ID} if {@code obj} is a {@link ZoneId}</li>\r\n * <li>Potentially {@linkplain StringUtils#truncate(CharSequence) truncated string}\r\n * if {@code obj} is a {@link String} or {@link CharSequence}</li>\r\n * <li>Potentially {@linkplain StringUtils#truncate(CharSequence) truncated string}\r\n * if {@code obj} is a <em>simple value type</em> whose {@code toString()} method\r\n * returns a non-null value</li>\r\n * <li>Otherwise, a string representation of the object's type name concatenated\r\n * with {@code \"@\"} and a hex string form of the object's identity hash code</li>\r\n * </ul>\r\n * <p>In the context of this method, a <em>simple value type</em> is any of the following:\r\n * primitive wrapper (excluding {@link Void}), {@link Enum}, {@link Number},\r\n * {@link java.util.Date Date}, {@link java.time.temporal.Temporal Temporal},\r\n * {@link java.io.File File}, {@link java.nio.file.Path Path},\r\n * {@link java.net.URI URI}, {@link java.net.URL URL},\r\n * {@link java.net.InetAddress InetAddress}, {@link java.util.Currency Currency},\r\n * {@link java.util.Locale Locale}, {@link java.util.UUID UUID},\r\n * {@link java.util.regex.Pattern Pattern}.\r\n * @param obj the object to build a string representation for\r\n * @return a concise string representation of the supplied object\r\n * @since 5.3.27\r\n * @see #nullSafeToString(Object)\r\n * @see StringUtils#truncate(CharSequence)\r\n * @see ClassUtils#isSimpleValueType(Class)\r\n */\r\npublic static String nullSafeConciseToString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (obj instanceof Optional<?> optional) {\r\n        return (optional.isEmpty() ? \"Optional.empty\" : \"Optional[%s]\".formatted(nullSafeConciseToString(optional.get())));\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        return (Array.getLength(obj) == 0 ? EMPTY_ARRAY : NON_EMPTY_ARRAY);\r\n    }\r\n    if (obj instanceof Collection) {\r\n        return COLLECTION;\r\n    }\r\n    if (obj instanceof Map) {\r\n        return MAP;\r\n    }\r\n    if (obj instanceof Class<?> clazz) {\r\n        return clazz.getName();\r\n    }\r\n    if (obj instanceof Charset charset) {\r\n        return charset.name();\r\n    }\r\n    if (obj instanceof TimeZone timeZone) {\r\n        return timeZone.getID();\r\n    }\r\n    if (obj instanceof ZoneId zoneId) {\r\n        return zoneId.getId();\r\n    }\r\n    if (obj instanceof CharSequence charSequence) {\r\n        return StringUtils.truncate(charSequence);\r\n    }\r\n    Class<?> type = obj.getClass();\r\n    if (ClassUtils.isSimpleValueType(type)) {\r\n        String str = obj.toString();\r\n        if (str != null) {\r\n            return StringUtils.truncate(str);\r\n        }\r\n    }\r\n    return type.getTypeName() + \"@\" + getIdentityHexString(obj);\r\n}",
    "comment": "\n * Miscellaneous object utility methods.\n *\n * <p>Mainly for internal use within the framework.\n *\n * <p>Thanks to Alex Ruiz for contributing several enhancements to this class!\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rod Johnson\n * @author Rob Harrop\n * @author Chris Beams\n * @author Sam Brannen\n * @since 19.03.2004\n * @see ClassUtils\n * @see CollectionUtils\n * @see StringUtils\n "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
    "entityType": "method",
    "code": "/**\r\n * Return whether the given throwable is a checked exception:\r\n * that is, neither a RuntimeException nor an Error.\r\n * @param ex the throwable to check\r\n * @return whether the throwable is a checked exception\r\n * @see java.lang.Exception\r\n * @see java.lang.RuntimeException\r\n * @see java.lang.Error\r\n */\r\npublic static boolean isCheckedException(Throwable ex) {\r\n    return !(ex instanceof RuntimeException || ex instanceof Error);\r\n}",
    "comment": "\n\t * Return whether the given throwable is a checked exception:\n\t * that is, neither a RuntimeException nor an Error.\n\t * @param ex the throwable to check\n\t * @return whether the throwable is a checked exception\n\t * @see java.lang.Exception\n\t * @see java.lang.RuntimeException\n\t * @see java.lang.Error\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given exception is compatible with the specified\r\n * exception types, as declared in a {@code throws} clause.\r\n * @param ex the exception to check\r\n * @param declaredExceptions the exception types declared in the throws clause\r\n * @return whether the given exception is compatible\r\n */\r\npublic static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>@Nullable ... declaredExceptions) {\r\n    if (!isCheckedException(ex)) {\r\n        return true;\r\n    }\r\n    if (declaredExceptions != null) {\r\n        for (Class<?> declaredException : declaredExceptions) {\r\n            if (declaredException.isInstance(ex)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Check whether the given exception is compatible with the specified\n\t * exception types, as declared in a {@code throws} clause.\n\t * @param ex the exception to check\n\t * @param declaredExceptions the exception types declared in the throws clause\n\t * @return whether the given exception is compatible\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#isArray(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given object is an array:\r\n * either an Object array or a primitive array.\r\n * @param obj the object to check\r\n */\r\n@Contract(\"null -> false\")\r\npublic static boolean isArray(@Nullable Object obj) {\r\n    return (obj != null && obj.getClass().isArray());\r\n}",
    "comment": "\n\t * Determine whether the given object is an array:\n\t * either an Object array or a primitive array.\n\t * @param obj the object to check\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given array is empty:\r\n * i.e. {@code null} or of zero length.\r\n * @param array the array to check\r\n * @see #isEmpty(Object)\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Object @Nullable [] array) {\r\n    return (array == null || array.length == 0);\r\n}",
    "comment": "\n\t * Determine whether the given array is empty:\n\t * i.e. {@code null} or of zero length.\n\t * @param array the array to check\n\t * @see #isEmpty(Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#isEmpty(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine whether the given object is empty.\r\n * <p>This method supports the following object types.\r\n * <ul>\r\n * <li>{@code Optional}: considered empty if not {@link Optional#isPresent()}</li>\r\n * <li>{@code Array}: considered empty if its length is zero</li>\r\n * <li>{@link CharSequence}: considered empty if its length is zero</li>\r\n * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>\r\n * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>\r\n * </ul>\r\n * <p>If the given object is non-null and not one of the aforementioned\r\n * supported types, this method returns {@code false}.\r\n * @param obj the object to check\r\n * @return {@code true} if the object is {@code null} or <em>empty</em>\r\n * @since 4.2\r\n * @see Optional#isPresent()\r\n * @see ObjectUtils#isEmpty(Object[])\r\n * @see StringUtils#hasLength(CharSequence)\r\n * @see CollectionUtils#isEmpty(java.util.Collection)\r\n * @see CollectionUtils#isEmpty(java.util.Map)\r\n */\r\n@Contract(\"null -> true\")\r\npublic static boolean isEmpty(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return true;\r\n    }\r\n    if (obj instanceof Optional<?> optional) {\r\n        return optional.isEmpty();\r\n    }\r\n    if (obj instanceof CharSequence charSequence) {\r\n        return charSequence.isEmpty();\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        return Array.getLength(obj) == 0;\r\n    }\r\n    if (obj instanceof Collection<?> collection) {\r\n        return collection.isEmpty();\r\n    }\r\n    if (obj instanceof Map<?, ?> map) {\r\n        return map.isEmpty();\r\n    }\r\n    // else\r\n    return false;\r\n}",
    "comment": "\n\t * Determine whether the given object is empty.\n\t * <p>This method supports the following object types.\n\t * <ul>\n\t * <li>{@code Optional}: considered empty if not {@link Optional#isPresent()}</li>\n\t * <li>{@code Array}: considered empty if its length is zero</li>\n\t * <li>{@link CharSequence}: considered empty if its length is zero</li>\n\t * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>\n\t * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>\n\t * </ul>\n\t * <p>If the given object is non-null and not one of the aforementioned\n\t * supported types, this method returns {@code false}.\n\t * @param obj the object to check\n\t * @return {@code true} if the object is {@code null} or <em>empty</em>\n\t * @since 4.2\n\t * @see Optional#isPresent()\n\t * @see ObjectUtils#isEmpty(Object[])\n\t * @see StringUtils#hasLength(CharSequence)\n\t * @see CollectionUtils#isEmpty(java.util.Collection)\n\t * @see CollectionUtils#isEmpty(java.util.Map)\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#unwrapOptional(Object)",
    "entityType": "method",
    "code": "/**\r\n * Unwrap the given object which is potentially a {@link java.util.Optional}.\r\n * @param obj the candidate object\r\n * @return either the value held within the {@code Optional}, {@code null}\r\n * if the {@code Optional} is empty, or simply the given object as-is\r\n * @since 5.0\r\n */\r\n@Nullable\r\npublic static Object unwrapOptional(@Nullable Object obj) {\r\n    if (obj instanceof Optional<?> optional) {\r\n        Object result = optional.orElse(null);\r\n        Assert.isTrue(!(result instanceof Optional), \"Multi-level Optional usage not supported\");\r\n        return result;\r\n    }\r\n    return obj;\r\n}",
    "comment": "\n\t * Unwrap the given object which is potentially a {@link java.util.Optional}.\n\t * @param obj the candidate object\n\t * @return either the value held within the {@code Optional}, {@code null}\n\t * if the {@code Optional} is empty, or simply the given object as-is\n\t * @since 5.0\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#containsElement(Object[],Object)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given array contains the given element.\r\n * @param array the array to check (may be {@code null},\r\n * in which case the return value will always be {@code false})\r\n * @param element the element to check for\r\n * @return whether the element has been found in the given array\r\n */\r\npublic static boolean containsElement(@Nullable Object @Nullable [] array, @Nullable Object element) {\r\n    if (array == null) {\r\n        return false;\r\n    }\r\n    for (Object arrayEle : array) {\r\n        if (nullSafeEquals(arrayEle, element)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Check whether the given array contains the given element.\n\t * @param array the array to check (may be {@code null},\n\t * in which case the return value will always be {@code false})\n\t * @param element the element to check for\n\t * @return whether the element has been found in the given array\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given array of enum constants contains a constant with the given name,\r\n * ignoring case when determining a match.\r\n * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\r\n * @param constant the constant name to find (must not be null or empty string)\r\n * @return whether the constant has been found in the given array\r\n */\r\npublic static boolean containsConstant(Enum<?>[] enumValues, String constant) {\r\n    return containsConstant(enumValues, constant, false);\r\n}",
    "comment": "\n\t * Check whether the given array of enum constants contains a constant with the given name,\n\t * ignoring case when determining a match.\n\t * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\n\t * @param constant the constant name to find (must not be null or empty string)\n\t * @return whether the constant has been found in the given array\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * Check whether the given array of enum constants contains a constant with the given name.\r\n * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\r\n * @param constant the constant name to find (must not be null or empty string)\r\n * @param caseSensitive whether case is significant in determining a match\r\n * @return whether the constant has been found in the given array\r\n */\r\npublic static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\r\n    for (Enum<?> candidate : enumValues) {\r\n        if (caseSensitive ? candidate.toString().equals(constant) : candidate.toString().equalsIgnoreCase(constant)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Check whether the given array of enum constants contains a constant with the given name.\n\t * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}\n\t * @param constant the constant name to find (must not be null or empty string)\n\t * @param caseSensitive whether case is significant in determining a match\n\t * @return whether the constant has been found in the given array\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
    "entityType": "method",
    "code": "/**\r\n * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.\r\n * @param <E> the concrete Enum type\r\n * @param enumValues the array of all Enum constants in question, usually per {@code Enum.values()}\r\n * @param constant the constant to get the enum value of\r\n * @throws IllegalArgumentException if the given constant is not found in the given array\r\n * of enum values. Use {@link #containsConstant(Enum[], String)} as a guard to avoid this exception.\r\n */\r\npublic static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {\r\n    for (E candidate : enumValues) {\r\n        if (candidate.toString().equalsIgnoreCase(constant)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Constant [\" + constant + \"] does not exist in enum type \" + enumValues.getClass().componentType().getName());\r\n}",
    "comment": "\n\t * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.\n\t * @param <E> the concrete Enum type\n\t * @param enumValues the array of all Enum constants in question, usually per {@code Enum.values()}\n\t * @param constant the constant to get the enum value of\n\t * @throws IllegalArgumentException if the given constant is not found in the given array\n\t * of enum values. Use {@link #containsConstant(Enum[], String)} as a guard to avoid this exception.\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O)",
    "entityType": "method",
    "code": "/**\r\n * Append the given object to the given array, returning a new array\r\n * consisting of the input array contents plus the given object.\r\n * @param array the array to append to (can be {@code null})\r\n * @param obj the object to append\r\n * @return the new array (of the same component type; never {@code null})\r\n */\r\npublic static <A, O extends A> A[] addObjectToArray(A @Nullable [] array, @Nullable O obj) {\r\n    return addObjectToArray(array, obj, (array != null ? array.length : 0));\r\n}",
    "comment": "\n\t * Append the given object to the given array, returning a new array\n\t * consisting of the input array contents plus the given object.\n\t * @param array the array to append to (can be {@code null})\n\t * @param obj the object to append\n\t * @return the new array (of the same component type; never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
    "entityType": "method",
    "code": "/**\r\n * Add the given object to the given array at the specified position, returning\r\n * a new array consisting of the input array contents plus the given object.\r\n * @param array the array to add to (can be {@code null})\r\n * @param obj the object to append\r\n * @param position the position at which to add the object\r\n * @return the new array (of the same component type; never {@code null})\r\n * @since 6.0\r\n */\r\n@Nullable\r\npublic static <A, O extends A> A[] addObjectToArray(A @Nullable [] array, @Nullable O obj, int position) {\r\n    Class<?> componentType = Object.class;\r\n    if (array != null) {\r\n        componentType = array.getClass().componentType();\r\n    } else if (obj != null) {\r\n        componentType = obj.getClass();\r\n    }\r\n    int newArrayLength = (array != null ? array.length + 1 : 1);\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    A[] newArray = (A[]) Array.newInstance(componentType, newArrayLength);\r\n    if (array != null) {\r\n        System.arraycopy(array, 0, newArray, 0, position);\r\n        System.arraycopy(array, position, newArray, position + 1, array.length - position);\r\n    }\r\n    newArray[position] = obj;\r\n    return newArray;\r\n}",
    "comment": "\n\t * Add the given object to the given array at the specified position, returning\n\t * a new array consisting of the input array contents plus the given object.\n\t * @param array the array to add to (can be {@code null})\n\t * @param obj the object to append\n\t * @param position the position at which to add the object\n\t * @return the new array (of the same component type; never {@code null})\n\t * @since 6.0\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
    "entityType": "method",
    "code": "/**\r\n * Convert the given array (which may be a primitive array) to an object array (if\r\n * necessary, to an array of primitive wrapper objects).\r\n * <p>A {@code null} source value or empty primitive array will be converted to an\r\n * empty Object array.\r\n * @param source the (potentially primitive) array\r\n * @return the corresponding object array (never {@code null})\r\n * @throws IllegalArgumentException if the parameter is not an array\r\n */\r\npublic static Object[] toObjectArray(@Nullable Object source) {\r\n    if (source instanceof Object[] objects) {\r\n        return objects;\r\n    }\r\n    if (source == null) {\r\n        return EMPTY_OBJECT_ARRAY;\r\n    }\r\n    if (!source.getClass().isArray()) {\r\n        throw new IllegalArgumentException(\"Source is not an array: \" + source);\r\n    }\r\n    int length = Array.getLength(source);\r\n    if (length == 0) {\r\n        return EMPTY_OBJECT_ARRAY;\r\n    }\r\n    Class<?> wrapperType = Array.get(source, 0).getClass();\r\n    Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);\r\n    for (int i = 0; i < length; i++) {\r\n        newArray[i] = Array.get(source, i);\r\n    }\r\n    return newArray;\r\n}",
    "comment": "\n\t * Convert the given array (which may be a primitive array) to an object array (if\n\t * necessary, to an array of primitive wrapper objects).\n\t * <p>A {@code null} source value or empty primitive array will be converted to an\n\t * empty Object array.\n\t * @param source the (potentially primitive) array\n\t * @return the corresponding object array (never {@code null})\n\t * @throws IllegalArgumentException if the parameter is not an array\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Convenience methods for content-based equality/hash-code handling\r\n//---------------------------------------------------------------------\r\n/**\r\n * Determine if the given objects are equal, returning {@code true} if\r\n * both are {@code null} or {@code false} if only one is {@code null}.\r\n * <p>Compares arrays with {@code Arrays.equals}, performing an equality\r\n * check based on the array elements rather than the array reference.\r\n * @param o1 first Object to compare\r\n * @param o2 second Object to compare\r\n * @return whether the given objects are equal\r\n * @see Object#equals(Object)\r\n * @see java.util.Arrays#equals\r\n */\r\n@Contract(\"null, null -> true; null, _ -> false; _, null -> false\")\r\npublic static boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2) {\r\n    if (o1 == o2) {\r\n        return true;\r\n    }\r\n    if (o1 == null || o2 == null) {\r\n        return false;\r\n    }\r\n    if (o1.equals(o2)) {\r\n        return true;\r\n    }\r\n    if (o1.getClass().isArray() && o2.getClass().isArray()) {\r\n        return arrayEquals(o1, o2);\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Determine if the given objects are equal, returning {@code true} if\n\t * both are {@code null} or {@code false} if only one is {@code null}.\n\t * <p>Compares arrays with {@code Arrays.equals}, performing an equality\n\t * check based on the array elements rather than the array reference.\n\t * @param o1 first Object to compare\n\t * @param o2 second Object to compare\n\t * @return whether the given objects are equal\n\t * @see Object#equals(Object)\n\t * @see java.util.Arrays#equals\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
    "entityType": "method",
    "code": "/**\r\n * Compare the given arrays with {@code Arrays.equals}, performing an equality\r\n * check based on the array elements rather than the array reference.\r\n * @param o1 first array to compare\r\n * @param o2 second array to compare\r\n * @return whether the given objects are equal\r\n * @see #nullSafeEquals(Object, Object)\r\n * @see java.util.Arrays#equals\r\n */\r\nprivate static boolean arrayEquals(Object o1, Object o2) {\r\n    if (o1 instanceof Object[] objects1 && o2 instanceof Object[] objects2) {\r\n        return Arrays.equals(objects1, objects2);\r\n    }\r\n    if (o1 instanceof boolean[] booleans1 && o2 instanceof boolean[] booleans2) {\r\n        return Arrays.equals(booleans1, booleans2);\r\n    }\r\n    if (o1 instanceof byte[] bytes1 && o2 instanceof byte[] bytes2) {\r\n        return Arrays.equals(bytes1, bytes2);\r\n    }\r\n    if (o1 instanceof char[] chars1 && o2 instanceof char[] chars2) {\r\n        return Arrays.equals(chars1, chars2);\r\n    }\r\n    if (o1 instanceof double[] doubles1 && o2 instanceof double[] doubles2) {\r\n        return Arrays.equals(doubles1, doubles2);\r\n    }\r\n    if (o1 instanceof float[] floats1 && o2 instanceof float[] floats2) {\r\n        return Arrays.equals(floats1, floats2);\r\n    }\r\n    if (o1 instanceof int[] ints1 && o2 instanceof int[] ints2) {\r\n        return Arrays.equals(ints1, ints2);\r\n    }\r\n    if (o1 instanceof long[] longs1 && o2 instanceof long[] longs2) {\r\n        return Arrays.equals(longs1, longs2);\r\n    }\r\n    if (o1 instanceof short[] shorts1 && o2 instanceof short[] shorts2) {\r\n        return Arrays.equals(shorts1, shorts2);\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Compare the given arrays with {@code Arrays.equals}, performing an equality\n\t * check based on the array elements rather than the array reference.\n\t * @param o1 first array to compare\n\t * @param o2 second array to compare\n\t * @return whether the given objects are equal\n\t * @see #nullSafeEquals(Object, Object)\n\t * @see java.util.Arrays#equals\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code for the given elements, delegating to\r\n * {@link #nullSafeHashCode(Object)} for each element. Contrary\r\n * to {@link Objects#hash(Object...)}, this method can handle an\r\n * element that is an array.\r\n * @param elements the elements to be hashed\r\n * @return a hash value of the elements\r\n * @since 6.1\r\n */\r\npublic static int nullSafeHash(@Nullable Object@Nullable ... elements) {\r\n    if (elements == null) {\r\n        return 0;\r\n    }\r\n    int result = 1;\r\n    for (Object element : elements) {\r\n        result = 31 * result + nullSafeHashCode(element);\r\n    }\r\n    return result;\r\n}",
    "comment": "\n\t * Return a hash code for the given elements, delegating to\n\t * {@link #nullSafeHashCode(Object)} for each element. Contrary\n\t * to {@link Objects#hash(Object...)}, this method can handle an\n\t * element that is an array.\n\t * @param elements the elements to be hashed\n\t * @return a hash value of the elements\n\t * @since 6.1\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code for the given object; typically the value of\r\n * {@code Object#hashCode()}}. If the object is an array,\r\n * this method will delegate to any of the {@code Arrays.hashCode}\r\n * methods. If the object is {@code null}, this method returns 0.\r\n * @see Object#hashCode()\r\n * @see Arrays\r\n */\r\npublic static int nullSafeHashCode(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return 0;\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        if (obj instanceof Object[] objects) {\r\n            return Arrays.hashCode(objects);\r\n        }\r\n        if (obj instanceof boolean[] booleans) {\r\n            return Arrays.hashCode(booleans);\r\n        }\r\n        if (obj instanceof byte[] bytes) {\r\n            return Arrays.hashCode(bytes);\r\n        }\r\n        if (obj instanceof char[] chars) {\r\n            return Arrays.hashCode(chars);\r\n        }\r\n        if (obj instanceof double[] doubles) {\r\n            return Arrays.hashCode(doubles);\r\n        }\r\n        if (obj instanceof float[] floats) {\r\n            return Arrays.hashCode(floats);\r\n        }\r\n        if (obj instanceof int[] ints) {\r\n            return Arrays.hashCode(ints);\r\n        }\r\n        if (obj instanceof long[] longs) {\r\n            return Arrays.hashCode(longs);\r\n        }\r\n        if (obj instanceof short[] shorts) {\r\n            return Arrays.hashCode(shorts);\r\n        }\r\n    }\r\n    return obj.hashCode();\r\n}",
    "comment": "\n\t * Return a hash code for the given object; typically the value of\n\t * {@code Object#hashCode()}}. If the object is an array,\n\t * this method will delegate to any of the {@code Arrays.hashCode}\n\t * methods. If the object is {@code null}, this method returns 0.\n\t * @see Object#hashCode()\n\t * @see Arrays\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(Object[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(Object @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(Object[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(boolean[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(boolean @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(boolean[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(byte[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(byte @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(byte[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(char[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(char @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(char[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(double[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(double[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(double @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(double[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(float[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(float[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(float @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(float[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(int[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(int[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(int @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(int[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(long[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(long[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(long @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(long[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeHashCode(short[])",
    "entityType": "method",
    "code": "/**\r\n * Return a hash code based on the contents of the specified array.\r\n * If {@code array} is {@code null}, this method returns 0.\r\n * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(short[])}\r\n */\r\n@Deprecated(since = \"6.1\")\r\npublic static int nullSafeHashCode(short @Nullable [] array) {\r\n    return Arrays.hashCode(array);\r\n}",
    "comment": "\n\t * Return a hash code based on the contents of the specified array.\n\t * If {@code array} is {@code null}, this method returns 0.\n\t * @deprecated as of 6.1 in favor of {@link Arrays#hashCode(short[])}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#identityToString(Object)",
    "entityType": "method",
    "code": "//---------------------------------------------------------------------\r\n// Convenience methods for toString output\r\n//---------------------------------------------------------------------\r\n/**\r\n * Return a String representation of an object's overall identity.\r\n * @param obj the object (may be {@code null})\r\n * @return the object's identity as String representation,\r\n * or an empty String if the object was {@code null}\r\n */\r\npublic static String identityToString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return EMPTY_STRING;\r\n    }\r\n    return obj.getClass().getName() + \"@\" + getIdentityHexString(obj);\r\n}",
    "comment": "\n\t * Return a String representation of an object's overall identity.\n\t * @param obj the object (may be {@code null})\n\t * @return the object's identity as String representation,\n\t * or an empty String if the object was {@code null}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#getIdentityHexString(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a hex String form of an object's identity hash code.\r\n * @param obj the object\r\n * @return the object's identity code in hex notation\r\n */\r\npublic static String getIdentityHexString(Object obj) {\r\n    return Integer.toHexString(System.identityHashCode(obj));\r\n}",
    "comment": "\n\t * Return a hex String form of an object's identity hash code.\n\t * @param obj the object\n\t * @return the object's identity code in hex notation\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#getDisplayString(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a content-based String representation if {@code obj} is\r\n * not {@code null}; otherwise returns an empty String.\r\n * <p>Differs from {@link #nullSafeToString(Object)} in that it returns\r\n * an empty String rather than \"null\" for a {@code null} value.\r\n * @param obj the object to build a display String for\r\n * @return a display String representation of {@code obj}\r\n * @see #nullSafeToString(Object)\r\n */\r\npublic static String getDisplayString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return EMPTY_STRING;\r\n    }\r\n    return nullSafeToString(obj);\r\n}",
    "comment": "\n\t * Return a content-based String representation if {@code obj} is\n\t * not {@code null}; otherwise returns an empty String.\n\t * <p>Differs from {@link #nullSafeToString(Object)} in that it returns\n\t * an empty String rather than \"null\" for a {@code null} value.\n\t * @param obj the object to build a display String for\n\t * @return a display String representation of {@code obj}\n\t * @see #nullSafeToString(Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeClassName(Object)",
    "entityType": "method",
    "code": "/**\r\n * Determine the class name for the given object.\r\n * <p>Returns a {@code \"null\"} String if {@code obj} is {@code null}.\r\n * @param obj the object to introspect (may be {@code null})\r\n * @return the corresponding class name\r\n */\r\npublic static String nullSafeClassName(@Nullable Object obj) {\r\n    return (obj != null ? obj.getClass().getName() : NULL_STRING);\r\n}",
    "comment": "\n\t * Determine the class name for the given object.\n\t * <p>Returns a {@code \"null\"} String if {@code obj} is {@code null}.\n\t * @param obj the object to introspect (may be {@code null})\n\t * @return the corresponding class name\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the specified Object.\r\n * <p>Builds a String representation of the contents in case of an array.\r\n * Returns a {@code \"null\"} String if {@code obj} is {@code null}.\r\n * @param obj the object to build a String representation for\r\n * @return a String representation of {@code obj}\r\n * @see #nullSafeConciseToString(Object)\r\n */\r\npublic static String nullSafeToString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (obj instanceof String string) {\r\n        return string;\r\n    }\r\n    if (obj instanceof Object[] objects) {\r\n        return nullSafeToString(objects);\r\n    }\r\n    if (obj instanceof boolean[] booleans) {\r\n        return nullSafeToString(booleans);\r\n    }\r\n    if (obj instanceof byte[] bytes) {\r\n        return nullSafeToString(bytes);\r\n    }\r\n    if (obj instanceof char[] chars) {\r\n        return nullSafeToString(chars);\r\n    }\r\n    if (obj instanceof double[] doubles) {\r\n        return nullSafeToString(doubles);\r\n    }\r\n    if (obj instanceof float[] floats) {\r\n        return nullSafeToString(floats);\r\n    }\r\n    if (obj instanceof int[] ints) {\r\n        return nullSafeToString(ints);\r\n    }\r\n    if (obj instanceof long[] longs) {\r\n        return nullSafeToString(longs);\r\n    }\r\n    if (obj instanceof short[] shorts) {\r\n        return nullSafeToString(shorts);\r\n    }\r\n    String str = obj.toString();\r\n    return (str != null ? str : EMPTY_STRING);\r\n}",
    "comment": "\n\t * Return a String representation of the specified Object.\n\t * <p>Builds a String representation of the contents in case of an array.\n\t * Returns a {@code \"null\"} String if {@code obj} is {@code null}.\n\t * @param obj the object to build a String representation for\n\t * @return a String representation of {@code obj}\n\t * @see #nullSafeConciseToString(Object)\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(@Nullable Object @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    int length = array.length;\r\n    if (length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (Object o : array) {\r\n        stringJoiner.add(String.valueOf(o));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(boolean @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    int length = array.length;\r\n    if (length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (boolean b : array) {\r\n        stringJoiner.add(String.valueOf(b));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(byte @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (byte b : array) {\r\n        stringJoiner.add(String.valueOf(b));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(char @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (char c : array) {\r\n        stringJoiner.add('\\'' + String.valueOf(c) + '\\'');\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(double @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (double d : array) {\r\n        stringJoiner.add(String.valueOf(d));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(float @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (float f : array) {\r\n        stringJoiner.add(String.valueOf(f));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(int @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (int i : array) {\r\n        stringJoiner.add(String.valueOf(i));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(long @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    int length = array.length;\r\n    if (length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (long l : array) {\r\n        stringJoiner.add(String.valueOf(l));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
    "entityType": "method",
    "code": "/**\r\n * Return a String representation of the contents of the specified array.\r\n * <p>The String representation consists of a list of the array's elements,\r\n * enclosed in curly braces ({@code \";\"}). Adjacent elements are separated\r\n * by the characters {@code \", \"} (a comma followed by a space).\r\n * Returns a {@code \"null\"} String if {@code array} is {@code null}.\r\n * @param array the array to build a String representation for\r\n * @return a String representation of {@code array}\r\n */\r\npublic static String nullSafeToString(short @Nullable [] array) {\r\n    if (array == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (array.length == 0) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\r\n    for (short s : array) {\r\n        stringJoiner.add(String.valueOf(s));\r\n    }\r\n    return stringJoiner.toString();\r\n}",
    "comment": "\n\t * Return a String representation of the contents of the specified array.\n\t * <p>The String representation consists of a list of the array's elements,\n\t * enclosed in curly braces ({@code \"{}\"}). Adjacent elements are separated\n\t * by the characters {@code \", \"} (a comma followed by a space).\n\t * Returns a {@code \"null\"} String if {@code array} is {@code null}.\n\t * @param array the array to build a String representation for\n\t * @return a String representation of {@code array}\n\t "
  },
  {
    "entityId": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
    "entityType": "method",
    "code": "/**\r\n * Generate a null-safe, concise string representation of the supplied object\r\n * as described below.\r\n * <p>Favor this method over {@link #nullSafeToString(Object)} when you need\r\n * the length of the generated string to be limited.\r\n * <p>Returns:\r\n * <ul>\r\n * <li>{@code \"null\"} if {@code obj} is {@code null}</li>\r\n * <li>{@code \"Optional.empty\"} if {@code obj} is an empty {@link Optional}</li>\r\n * <li>{@code \"Optional[<concise-string>]\"} if {@code obj} is a non-empty {@code Optional},\r\n * where {@code <concise-string>} is the result of invoking this method on the object\r\n * contained in the {@code Optional}</li>\r\n * <li>{@code \";\"} if {@code obj} is an empty array</li>\r\n * <li>{@code \"{...}\"} if {@code obj} is a {@link Map} or a non-empty array</li>\r\n * <li>{@code \"[...]\"} if {@code obj} is a {@link Collection}</li>\r\n * <li>{@linkplain Class#getName() Class name} if {@code obj} is a {@link Class}</li>\r\n * <li>{@linkplain Charset#name() Charset name} if {@code obj} is a {@link Charset}</li>\r\n * <li>{@linkplain TimeZone#getID() TimeZone ID} if {@code obj} is a {@link TimeZone}</li>\r\n * <li>{@linkplain ZoneId#getId() Zone ID} if {@code obj} is a {@link ZoneId}</li>\r\n * <li>Potentially {@linkplain StringUtils#truncate(CharSequence) truncated string}\r\n * if {@code obj} is a {@link String} or {@link CharSequence}</li>\r\n * <li>Potentially {@linkplain StringUtils#truncate(CharSequence) truncated string}\r\n * if {@code obj} is a <em>simple value type</em> whose {@code toString()} method\r\n * returns a non-null value</li>\r\n * <li>Otherwise, a string representation of the object's type name concatenated\r\n * with {@code \"@\"} and a hex string form of the object's identity hash code</li>\r\n * </ul>\r\n * <p>In the context of this method, a <em>simple value type</em> is any of the following:\r\n * primitive wrapper (excluding {@link Void}), {@link Enum}, {@link Number},\r\n * {@link java.util.Date Date}, {@link java.time.temporal.Temporal Temporal},\r\n * {@link java.io.File File}, {@link java.nio.file.Path Path},\r\n * {@link java.net.URI URI}, {@link java.net.URL URL},\r\n * {@link java.net.InetAddress InetAddress}, {@link java.util.Currency Currency},\r\n * {@link java.util.Locale Locale}, {@link java.util.UUID UUID},\r\n * {@link java.util.regex.Pattern Pattern}.\r\n * @param obj the object to build a string representation for\r\n * @return a concise string representation of the supplied object\r\n * @since 5.3.27\r\n * @see #nullSafeToString(Object)\r\n * @see StringUtils#truncate(CharSequence)\r\n * @see ClassUtils#isSimpleValueType(Class)\r\n */\r\npublic static String nullSafeConciseToString(@Nullable Object obj) {\r\n    if (obj == null) {\r\n        return NULL_STRING;\r\n    }\r\n    if (obj instanceof Optional<?> optional) {\r\n        return (optional.isEmpty() ? \"Optional.empty\" : \"Optional[%s]\".formatted(nullSafeConciseToString(optional.get())));\r\n    }\r\n    if (obj.getClass().isArray()) {\r\n        return (Array.getLength(obj) == 0 ? EMPTY_ARRAY : NON_EMPTY_ARRAY);\r\n    }\r\n    if (obj instanceof Collection) {\r\n        return COLLECTION;\r\n    }\r\n    if (obj instanceof Map) {\r\n        return MAP;\r\n    }\r\n    if (obj instanceof Class<?> clazz) {\r\n        return clazz.getName();\r\n    }\r\n    if (obj instanceof Charset charset) {\r\n        return charset.name();\r\n    }\r\n    if (obj instanceof TimeZone timeZone) {\r\n        return timeZone.getID();\r\n    }\r\n    if (obj instanceof ZoneId zoneId) {\r\n        return zoneId.getId();\r\n    }\r\n    if (obj instanceof CharSequence charSequence) {\r\n        return StringUtils.truncate(charSequence);\r\n    }\r\n    Class<?> type = obj.getClass();\r\n    if (ClassUtils.isSimpleValueType(type)) {\r\n        String str = obj.toString();\r\n        if (str != null) {\r\n            return StringUtils.truncate(str);\r\n        }\r\n    }\r\n    return type.getTypeName() + \"@\" + getIdentityHexString(obj);\r\n}",
    "comment": "\n\t * Generate a null-safe, concise string representation of the supplied object\n\t * as described below.\n\t * <p>Favor this method over {@link #nullSafeToString(Object)} when you need\n\t * the length of the generated string to be limited.\n\t * <p>Returns:\n\t * <ul>\n\t * <li>{@code \"null\"} if {@code obj} is {@code null}</li>\n\t * <li>{@code \"Optional.empty\"} if {@code obj} is an empty {@link Optional}</li>\n\t * <li>{@code \"Optional[<concise-string>]\"} if {@code obj} is a non-empty {@code Optional},\n\t * where {@code <concise-string>} is the result of invoking this method on the object\n\t * contained in the {@code Optional}</li>\n\t * <li>{@code \"{}\"} if {@code obj} is an empty array</li>\n\t * <li>{@code \"{...}\"} if {@code obj} is a {@link Map} or a non-empty array</li>\n\t * <li>{@code \"[...]\"} if {@code obj} is a {@link Collection}</li>\n\t * <li>{@linkplain Class#getName() Class name} if {@code obj} is a {@link Class}</li>\n\t * <li>{@linkplain Charset#name() Charset name} if {@code obj} is a {@link Charset}</li>\n\t * <li>{@linkplain TimeZone#getID() TimeZone ID} if {@code obj} is a {@link TimeZone}</li>\n\t * <li>{@linkplain ZoneId#getId() Zone ID} if {@code obj} is a {@link ZoneId}</li>\n\t * <li>Potentially {@linkplain StringUtils#truncate(CharSequence) truncated string}\n\t * if {@code obj} is a {@link String} or {@link CharSequence}</li>\n\t * <li>Potentially {@linkplain StringUtils#truncate(CharSequence) truncated string}\n\t * if {@code obj} is a <em>simple value type</em> whose {@code toString()} method\n\t * returns a non-null value</li>\n\t * <li>Otherwise, a string representation of the object's type name concatenated\n\t * with {@code \"@\"} and a hex string form of the object's identity hash code</li>\n\t * </ul>\n\t * <p>In the context of this method, a <em>simple value type</em> is any of the following:\n\t * primitive wrapper (excluding {@link Void}), {@link Enum}, {@link Number},\n\t * {@link java.util.Date Date}, {@link java.time.temporal.Temporal Temporal},\n\t * {@link java.io.File File}, {@link java.nio.file.Path Path},\n\t * {@link java.net.URI URI}, {@link java.net.URL URL},\n\t * {@link java.net.InetAddress InetAddress}, {@link java.util.Currency Currency},\n\t * {@link java.util.Locale Locale}, {@link java.util.UUID UUID},\n\t * {@link java.util.regex.Pattern Pattern}.\n\t * @param obj the object to build a string representation for\n\t * @return a concise string representation of the supplied object\n\t * @since 5.3.27\n\t * @see #nullSafeToString(Object)\n\t * @see StringUtils#truncate(CharSequence)\n\t * @see ClassUtils#isSimpleValueType(Class)\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher",
    "entityType": "class",
    "code": "/**\r\n * Does the given {@code path} represent a pattern that can be matched\r\n * by an implementation of this interface?\r\n * <p>If the return value is {@code false}, then the {@link #match}\r\n * method does not have to be used because direct equality comparisons\r\n * on the static path Strings will lead to the same result.\r\n * @param path the path to check\r\n * @return {@code true} if the given {@code path} represents a pattern\r\n */\r\nboolean isPattern(String path);\n/**\r\n * Match the given {@code path} against the given {@code pattern},\r\n * according to this PathMatcher's matching strategy.\r\n * @param pattern the pattern to match against\r\n * @param path the path to test\r\n * @return {@code true} if the supplied {@code path} matched,\r\n * {@code false} if it didn't\r\n */\r\nboolean match(String pattern, String path);\n/**\r\n * Match the given {@code path} against the corresponding part of the given\r\n * {@code pattern}, according to this PathMatcher's matching strategy.\r\n * <p>Determines whether the pattern at least matches as far as the given base\r\n * path goes, assuming that a full path may then match as well.\r\n * @param pattern the pattern to match against\r\n * @param path the path to test\r\n * @return {@code true} if the supplied {@code path} matched,\r\n * {@code false} if it didn't\r\n */\r\nboolean matchStart(String pattern, String path);\n/**\r\n * Given a pattern and a full path, determine the pattern-mapped part.\r\n * <p>This method is supposed to find out which part of the path is matched\r\n * dynamically through an actual pattern, that is, it strips off a statically\r\n * defined leading path from the given full path, returning only the actually\r\n * pattern-matched part of the path.\r\n * <p>For example: For \"myroot/*.html\" as pattern and \"myroot/myfile.html\"\r\n * as full path, this method should return \"myfile.html\". The detailed\r\n * determination rules are specified to this PathMatcher's matching strategy.\r\n * <p>A simple implementation may return the given full path as-is in case\r\n * of an actual pattern, and the empty String in case of the pattern not\r\n * containing any dynamic parts (i.e. the {@code pattern} parameter being\r\n * a static path that wouldn't qualify as an actual {@link #isPattern pattern}).\r\n * A sophisticated implementation will differentiate between the static parts\r\n * and the dynamic parts of the given path pattern.\r\n * @param pattern the path pattern\r\n * @param path the full path to introspect\r\n * @return the pattern-mapped part of the given {@code path}\r\n * (never {@code null})\r\n */\r\nString extractPathWithinPattern(String pattern, String path);\n/**\r\n * Given a pattern and a full path, extract the URI template variables. URI template\r\n * variables are expressed through curly brackets ('{' and '}').\r\n * <p>For example: For pattern \"/hotels/{hotel}\" and path \"/hotels/1\", this method will\r\n * return a map containing \"hotel\" &rarr; \"1\".\r\n * @param pattern the path pattern, possibly containing URI templates\r\n * @param path the full path to extract template variables from\r\n * @return a map, containing variable names as keys; variables values as values\r\n */\r\nMap<String, String> extractUriTemplateVariables(String pattern, String path);\n/**\r\n * Given a full path, returns a {@link Comparator} suitable for sorting patterns\r\n * in order of explicitness for that path.\r\n * <p>The full algorithm used depends on the underlying implementation,\r\n * but generally, the returned {@code Comparator} will\r\n * {@linkplain java.util.List#sort(java.util.Comparator) sort}\r\n * a list so that more specific patterns come before generic patterns.\r\n * @param path the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\nComparator<String> getPatternComparator(String path);\n/**\r\n * Combines two patterns into a new pattern that is returned.\r\n * <p>The full algorithm used for combining the two pattern depends on the underlying implementation.\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException when the two patterns cannot be combined\r\n */\r\nString combine(String pattern1, String pattern2);",
    "comment": "\n * Strategy interface for {@code String}-based path matching.\n *\n * <p>Used by {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver},\n * {@link org.springframework.web.servlet.handler.AbstractUrlHandlerMapping},\n * and {@link org.springframework.web.servlet.mvc.WebContentInterceptor}.\n *\n * <p>The default implementation is {@link AntPathMatcher}, supporting the\n * Ant-style pattern syntax.\n *\n * @author Juergen Hoeller\n * @since 1.2\n * @see AntPathMatcher\n "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#isPattern(String)",
    "entityType": "method",
    "code": "/**\r\n * Does the given {@code path} represent a pattern that can be matched\r\n * by an implementation of this interface?\r\n * <p>If the return value is {@code false}, then the {@link #match}\r\n * method does not have to be used because direct equality comparisons\r\n * on the static path Strings will lead to the same result.\r\n * @param path the path to check\r\n * @return {@code true} if the given {@code path} represents a pattern\r\n */\r\nboolean isPattern(String path);",
    "comment": "\n\t * Does the given {@code path} represent a pattern that can be matched\n\t * by an implementation of this interface?\n\t * <p>If the return value is {@code false}, then the {@link #match}\n\t * method does not have to be used because direct equality comparisons\n\t * on the static path Strings will lead to the same result.\n\t * @param path the path to check\n\t * @return {@code true} if the given {@code path} represents a pattern\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#match(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Match the given {@code path} against the given {@code pattern},\r\n * according to this PathMatcher's matching strategy.\r\n * @param pattern the pattern to match against\r\n * @param path the path to test\r\n * @return {@code true} if the supplied {@code path} matched,\r\n * {@code false} if it didn't\r\n */\r\nboolean match(String pattern, String path);",
    "comment": "\n\t * Match the given {@code path} against the given {@code pattern},\n\t * according to this PathMatcher's matching strategy.\n\t * @param pattern the pattern to match against\n\t * @param path the path to test\n\t * @return {@code true} if the supplied {@code path} matched,\n\t * {@code false} if it didn't\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#matchStart(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Match the given {@code path} against the corresponding part of the given\r\n * {@code pattern}, according to this PathMatcher's matching strategy.\r\n * <p>Determines whether the pattern at least matches as far as the given base\r\n * path goes, assuming that a full path may then match as well.\r\n * @param pattern the pattern to match against\r\n * @param path the path to test\r\n * @return {@code true} if the supplied {@code path} matched,\r\n * {@code false} if it didn't\r\n */\r\nboolean matchStart(String pattern, String path);",
    "comment": "\n\t * Match the given {@code path} against the corresponding part of the given\n\t * {@code pattern}, according to this PathMatcher's matching strategy.\n\t * <p>Determines whether the pattern at least matches as far as the given base\n\t * path goes, assuming that a full path may then match as well.\n\t * @param pattern the pattern to match against\n\t * @param path the path to test\n\t * @return {@code true} if the supplied {@code path} matched,\n\t * {@code false} if it didn't\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Given a pattern and a full path, determine the pattern-mapped part.\r\n * <p>This method is supposed to find out which part of the path is matched\r\n * dynamically through an actual pattern, that is, it strips off a statically\r\n * defined leading path from the given full path, returning only the actually\r\n * pattern-matched part of the path.\r\n * <p>For example: For \"myroot/*.html\" as pattern and \"myroot/myfile.html\"\r\n * as full path, this method should return \"myfile.html\". The detailed\r\n * determination rules are specified to this PathMatcher's matching strategy.\r\n * <p>A simple implementation may return the given full path as-is in case\r\n * of an actual pattern, and the empty String in case of the pattern not\r\n * containing any dynamic parts (i.e. the {@code pattern} parameter being\r\n * a static path that wouldn't qualify as an actual {@link #isPattern pattern}).\r\n * A sophisticated implementation will differentiate between the static parts\r\n * and the dynamic parts of the given path pattern.\r\n * @param pattern the path pattern\r\n * @param path the full path to introspect\r\n * @return the pattern-mapped part of the given {@code path}\r\n * (never {@code null})\r\n */\r\nString extractPathWithinPattern(String pattern, String path);",
    "comment": "\n\t * Given a pattern and a full path, determine the pattern-mapped part.\n\t * <p>This method is supposed to find out which part of the path is matched\n\t * dynamically through an actual pattern, that is, it strips off a statically\n\t * defined leading path from the given full path, returning only the actually\n\t * pattern-matched part of the path.\n\t * <p>For example: For \"myroot/*.html\" as pattern and \"myroot/myfile.html\"\n\t * as full path, this method should return \"myfile.html\". The detailed\n\t * determination rules are specified to this PathMatcher's matching strategy.\n\t * <p>A simple implementation may return the given full path as-is in case\n\t * of an actual pattern, and the empty String in case of the pattern not\n\t * containing any dynamic parts (i.e. the {@code pattern} parameter being\n\t * a static path that wouldn't qualify as an actual {@link #isPattern pattern}).\n\t * A sophisticated implementation will differentiate between the static parts\n\t * and the dynamic parts of the given path pattern.\n\t * @param pattern the path pattern\n\t * @param path the full path to introspect\n\t * @return the pattern-mapped part of the given {@code path}\n\t * (never {@code null})\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#extractUriTemplateVariables(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Given a pattern and a full path, extract the URI template variables. URI template\r\n * variables are expressed through curly brackets ('{' and '}').\r\n * <p>For example: For pattern \"/hotels/{hotel}\" and path \"/hotels/1\", this method will\r\n * return a map containing \"hotel\" &rarr; \"1\".\r\n * @param pattern the path pattern, possibly containing URI templates\r\n * @param path the full path to extract template variables from\r\n * @return a map, containing variable names as keys; variables values as values\r\n */\r\nMap<String, String> extractUriTemplateVariables(String pattern, String path);",
    "comment": "\n\t * Given a pattern and a full path, extract the URI template variables. URI template\n\t * variables are expressed through curly brackets ('{' and '}').\n\t * <p>For example: For pattern \"/hotels/{hotel}\" and path \"/hotels/1\", this method will\n\t * return a map containing \"hotel\" &rarr; \"1\".\n\t * @param pattern the path pattern, possibly containing URI templates\n\t * @param path the full path to extract template variables from\n\t * @return a map, containing variable names as keys; variables values as values\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#getPatternComparator(String)",
    "entityType": "method",
    "code": "/**\r\n * Given a full path, returns a {@link Comparator} suitable for sorting patterns\r\n * in order of explicitness for that path.\r\n * <p>The full algorithm used depends on the underlying implementation,\r\n * but generally, the returned {@code Comparator} will\r\n * {@linkplain java.util.List#sort(java.util.Comparator) sort}\r\n * a list so that more specific patterns come before generic patterns.\r\n * @param path the full path to use for comparison\r\n * @return a comparator capable of sorting patterns in order of explicitness\r\n */\r\nComparator<String> getPatternComparator(String path);",
    "comment": "\n\t * Given a full path, returns a {@link Comparator} suitable for sorting patterns\n\t * in order of explicitness for that path.\n\t * <p>The full algorithm used depends on the underlying implementation,\n\t * but generally, the returned {@code Comparator} will\n\t * {@linkplain java.util.List#sort(java.util.Comparator) sort}\n\t * a list so that more specific patterns come before generic patterns.\n\t * @param path the full path to use for comparison\n\t * @return a comparator capable of sorting patterns in order of explicitness\n\t "
  },
  {
    "entityId": "org.springframework.util.PathMatcher#combine(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Combines two patterns into a new pattern that is returned.\r\n * <p>The full algorithm used for combining the two pattern depends on the underlying implementation.\r\n * @param pattern1 the first pattern\r\n * @param pattern2 the second pattern\r\n * @return the combination of the two patterns\r\n * @throws IllegalArgumentException when the two patterns cannot be combined\r\n */\r\nString combine(String pattern1, String pattern2);",
    "comment": "\n\t * Combines two patterns into a new pattern that is returned.\n\t * <p>The full algorithm used for combining the two pattern depends on the underlying implementation.\n\t * @param pattern1 the first pattern\n\t * @param pattern2 the second pattern\n\t * @return the combination of the two patterns\n\t * @throws IllegalArgumentException when the two patterns cannot be combined\n\t "
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtils",
    "entityType": "class",
    "code": "/**\r\n * Match a String against the given pattern, supporting direct equality as\r\n * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\r\n * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\r\n * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\r\n * @param pattern the pattern to match against\r\n * @param str the String to match\r\n * @return whether the String matches the given pattern\r\n */\r\npublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\r\n    if (pattern == null || str == null) {\r\n        return false;\r\n    }\r\n    int firstIndex = pattern.indexOf('*');\r\n    if (firstIndex == -1) {\r\n        return pattern.equals(str);\r\n    }\r\n    if (firstIndex == 0) {\r\n        if (pattern.length() == 1) {\r\n            return true;\r\n        }\r\n        int nextIndex = pattern.indexOf('*', 1);\r\n        if (nextIndex == -1) {\r\n            return str.endsWith(pattern.substring(1));\r\n        }\r\n        String part = pattern.substring(1, nextIndex);\r\n        if (part.isEmpty()) {\r\n            return simpleMatch(pattern.substring(nextIndex), str);\r\n        }\r\n        int partIndex = str.indexOf(part);\r\n        while (partIndex != -1) {\r\n            if (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\r\n                return true;\r\n            }\r\n            partIndex = str.indexOf(part, partIndex + 1);\r\n        }\r\n        return false;\r\n    }\r\n    return (str.length() >= firstIndex && pattern.startsWith(str.substring(0, firstIndex)) && simpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\r\n}\n/**\r\n * Match a String against the given patterns, supporting direct equality as\r\n * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\r\n * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\r\n * <p>Returns {@code false} if the supplied String is {@code null} or if the\r\n * supplied patterns array is {@code null} or empty.\r\n * @param patterns the patterns to match against\r\n * @param str the String to match\r\n * @return whether the String matches any of the given patterns\r\n */\r\npublic static boolean simpleMatch(String @Nullable [] patterns, @Nullable String str) {\r\n    if (patterns != null) {\r\n        for (String pattern : patterns) {\r\n            if (simpleMatch(pattern, str)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n * Utility methods for simple pattern matching, in particular for Spring's typical\n * {@code xxx*}, {@code *xxx}, {@code *xxx*}, and {@code xxx*yyy} pattern styles.\n *\n * @author Juergen Hoeller\n * @since 2.0\n "
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Match a String against the given pattern, supporting direct equality as\r\n * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\r\n * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\r\n * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\r\n * @param pattern the pattern to match against\r\n * @param str the String to match\r\n * @return whether the String matches the given pattern\r\n */\r\npublic static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {\r\n    if (pattern == null || str == null) {\r\n        return false;\r\n    }\r\n    int firstIndex = pattern.indexOf('*');\r\n    if (firstIndex == -1) {\r\n        return pattern.equals(str);\r\n    }\r\n    if (firstIndex == 0) {\r\n        if (pattern.length() == 1) {\r\n            return true;\r\n        }\r\n        int nextIndex = pattern.indexOf('*', 1);\r\n        if (nextIndex == -1) {\r\n            return str.endsWith(pattern.substring(1));\r\n        }\r\n        String part = pattern.substring(1, nextIndex);\r\n        if (part.isEmpty()) {\r\n            return simpleMatch(pattern.substring(nextIndex), str);\r\n        }\r\n        int partIndex = str.indexOf(part);\r\n        while (partIndex != -1) {\r\n            if (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {\r\n                return true;\r\n            }\r\n            partIndex = str.indexOf(part, partIndex + 1);\r\n        }\r\n        return false;\r\n    }\r\n    return (str.length() >= firstIndex && pattern.startsWith(str.substring(0, firstIndex)) && simpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));\r\n}",
    "comment": "\n\t * Match a String against the given pattern, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String or pattern is {@code null}.\n\t * @param pattern the pattern to match against\n\t * @param str the String to match\n\t * @return whether the String matches the given pattern\n\t "
  },
  {
    "entityId": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
    "entityType": "method",
    "code": "/**\r\n * Match a String against the given patterns, supporting direct equality as\r\n * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\r\n * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\r\n * <p>Returns {@code false} if the supplied String is {@code null} or if the\r\n * supplied patterns array is {@code null} or empty.\r\n * @param patterns the patterns to match against\r\n * @param str the String to match\r\n * @return whether the String matches any of the given patterns\r\n */\r\npublic static boolean simpleMatch(String @Nullable [] patterns, @Nullable String str) {\r\n    if (patterns != null) {\r\n        for (String pattern : patterns) {\r\n            if (simpleMatch(pattern, str)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}",
    "comment": "\n\t * Match a String against the given patterns, supporting direct equality as\n\t * well as the following simple pattern styles: {@code xxx*}, {@code *xxx},\n\t * {@code *xxx*}, and {@code xxx*yyy} (with an arbitrary number of pattern parts).\n\t * <p>Returns {@code false} if the supplied String is {@code null} or if the\n\t * supplied patterns array is {@code null} or empty.\n\t * @param patterns the patterns to match against\n\t * @param str the String to match\n\t * @return whether the String matches any of the given patterns\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser",
    "entityType": "class",
    "code": "private static final Log logger = LogFactory.getLog(PlaceholderParser.class);\nprivate static final Map<String, String> wellKnownSimplePrefixes = Map.of(\"}\", \"{\", \"]\", \"[\", \")\", \"(\");\nprivate final String prefix;\nprivate final String suffix;\nprivate final String simplePrefix;\n@Nullable\r\nprivate final String separator;\nprivate final boolean ignoreUnresolvablePlaceholders;\n@Nullable\r\nprivate final Character escape;\n/**\r\n * Create an instance using the specified input for the parser.\r\n * @param prefix the prefix that denotes the start of a placeholder\r\n * @param suffix the suffix that denotes the end of a placeholder\r\n * @param separator the separating character between the placeholder\r\n * variable and the associated default value, if any\r\n * @param escape the character to use at the beginning of a placeholder\r\n * prefix or separator to escape it and render it as is\r\n * @param ignoreUnresolvablePlaceholders whether unresolvable placeholders\r\n * should be ignored ({@code true}) or cause an exception ({@code false})\r\n */\r\nPlaceholderParser(String prefix, String suffix, @Nullable String separator, @Nullable Character escape, boolean ignoreUnresolvablePlaceholders) {\r\n    this.prefix = prefix;\r\n    this.suffix = suffix;\r\n    String simplePrefixForSuffix = wellKnownSimplePrefixes.get(this.suffix);\r\n    if (simplePrefixForSuffix != null && this.prefix.endsWith(simplePrefixForSuffix)) {\r\n        this.simplePrefix = simplePrefixForSuffix;\r\n    } else {\r\n        this.simplePrefix = this.prefix;\r\n    }\r\n    this.separator = separator;\r\n    this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;\r\n    this.escape = escape;\r\n}\n/**\r\n * Replace all placeholders of format {@code ${name}} with the value returned\r\n * from the supplied {@link PlaceholderResolver}.\r\n * @param value the value containing the placeholders to be replaced\r\n * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\r\n * @return the supplied value with placeholders replaced inline\r\n */\r\npublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\r\n    Assert.notNull(value, \"'value' must not be null\");\r\n    ParsedValue parsedValue = parse(value);\r\n    PartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver, this.prefix, this.suffix, this.ignoreUnresolvablePlaceholders, candidate -> parse(candidate, false));\r\n    return parsedValue.resolve(resolutionContext);\r\n}\n/**\r\n * Parse the specified value.\r\n * @param value the value containing the placeholders to be replaced\r\n * @return the different parts that have been identified\r\n */\r\nParsedValue parse(String value) {\r\n    List<Part> parts = parse(value, false);\r\n    return new ParsedValue(value, parts);\r\n}\nprivate List<Part> parse(String value, boolean inPlaceholder) {\r\n    LinkedList<Part> parts = new LinkedList<>();\r\n    int startIndex = nextStartPrefix(value, 0);\r\n    if (startIndex == -1) {\r\n        Part part = (inPlaceholder ? createSimplePlaceholderPart(value) : new TextPart(value));\r\n        parts.add(part);\r\n        return parts;\r\n    }\r\n    int position = 0;\r\n    while (startIndex != -1) {\r\n        int endIndex = nextValidEndPrefix(value, startIndex);\r\n        if (endIndex == -1) {\r\n            // Not a valid placeholder, consume the prefix and continue\r\n            addText(value, position, startIndex + this.prefix.length(), parts);\r\n            position = startIndex + this.prefix.length();\r\n            startIndex = nextStartPrefix(value, position);\r\n        } else if (isEscaped(value, startIndex)) {\r\n            // Not a valid index, accumulate and skip the escape character\r\n            addText(value, position, startIndex - 1, parts);\r\n            addText(value, startIndex, startIndex + this.prefix.length(), parts);\r\n            position = startIndex + this.prefix.length();\r\n            startIndex = nextStartPrefix(value, position);\r\n        } else {\r\n            // Found valid placeholder, recursive parsing\r\n            addText(value, position, startIndex, parts);\r\n            String placeholder = value.substring(startIndex + this.prefix.length(), endIndex);\r\n            List<Part> placeholderParts = parse(placeholder, true);\r\n            parts.addAll(placeholderParts);\r\n            startIndex = nextStartPrefix(value, endIndex + this.suffix.length());\r\n            position = endIndex + this.suffix.length();\r\n        }\r\n    }\r\n    // Add rest of text if necessary\r\n    addText(value, position, value.length(), parts);\r\n    return (inPlaceholder ? List.of(createNestedPlaceholderPart(value, parts)) : parts);\r\n}\nprivate SimplePlaceholderPart createSimplePlaceholderPart(String text) {\r\n    ParsedSection section = parseSection(text);\r\n    return new SimplePlaceholderPart(text, section.key(), section.fallback());\r\n}\nprivate NestedPlaceholderPart createNestedPlaceholderPart(String text, List<Part> parts) {\r\n    if (this.separator == null) {\r\n        return new NestedPlaceholderPart(text, parts, null);\r\n    }\r\n    List<Part> keyParts = new ArrayList<>();\r\n    List<Part> defaultParts = new ArrayList<>();\r\n    for (int i = 0; i < parts.size(); i++) {\r\n        Part part = parts.get(i);\r\n        if (!(part instanceof TextPart)) {\r\n            keyParts.add(part);\r\n        } else {\r\n            String candidate = part.text();\r\n            ParsedSection section = parseSection(candidate);\r\n            keyParts.add(new TextPart(section.key()));\r\n            if (section.fallback() != null) {\r\n                defaultParts.add(new TextPart(section.fallback()));\r\n                defaultParts.addAll(parts.subList(i + 1, parts.size()));\r\n                return new NestedPlaceholderPart(text, keyParts, defaultParts);\r\n            }\r\n        }\r\n    }\r\n    return new NestedPlaceholderPart(text, keyParts, null);\r\n}\n/**\r\n * Parse an input value that may contain a separator character and return a\r\n * {@link ParsedValue}. If a valid separator character has been identified, the\r\n * given {@code value} is split between a {@code key} and a {@code fallback}. If not,\r\n * only the {@code key} is set.\r\n * <p>\r\n * The returned key may be different from the original value as escaped\r\n * separators, if any, are resolved.\r\n * @param value the value to parse\r\n * @return the parsed section\r\n */\r\nprivate ParsedSection parseSection(String value) {\r\n    if (this.separator == null || !value.contains(this.separator)) {\r\n        return new ParsedSection(value, null);\r\n    }\r\n    int position = 0;\r\n    int index = value.indexOf(this.separator, position);\r\n    StringBuilder buffer = new StringBuilder();\r\n    while (index != -1) {\r\n        if (isEscaped(value, index)) {\r\n            // Accumulate, without the escape character.\r\n            buffer.append(value, position, index - 1);\r\n            buffer.append(value, index, index + this.separator.length());\r\n            position = index + this.separator.length();\r\n            index = value.indexOf(this.separator, position);\r\n        } else {\r\n            buffer.append(value, position, index);\r\n            String key = buffer.toString();\r\n            String fallback = value.substring(index + this.separator.length());\r\n            return new ParsedSection(key, fallback);\r\n        }\r\n    }\r\n    buffer.append(value, position, value.length());\r\n    return new ParsedSection(buffer.toString(), null);\r\n}\nprivate static void addText(String value, int start, int end, LinkedList<Part> parts) {\r\n    if (start > end) {\r\n        return;\r\n    }\r\n    String text = value.substring(start, end);\r\n    if (!text.isEmpty()) {\r\n        if (!parts.isEmpty()) {\r\n            Part current = parts.removeLast();\r\n            if (current instanceof TextPart textPart) {\r\n                parts.add(new TextPart(textPart.text() + text));\r\n            } else {\r\n                parts.add(current);\r\n                parts.add(new TextPart(text));\r\n            }\r\n        } else {\r\n            parts.add(new TextPart(text));\r\n        }\r\n    }\r\n}\nprivate int nextStartPrefix(String value, int index) {\r\n    return value.indexOf(this.prefix, index);\r\n}\nprivate int nextValidEndPrefix(String value, int startIndex) {\r\n    int index = startIndex + this.prefix.length();\r\n    int withinNestedPlaceholder = 0;\r\n    while (index < value.length()) {\r\n        if (StringUtils.substringMatch(value, index, this.suffix)) {\r\n            if (withinNestedPlaceholder > 0) {\r\n                withinNestedPlaceholder--;\r\n                index = index + this.suffix.length();\r\n            } else {\r\n                return index;\r\n            }\r\n        } else if (StringUtils.substringMatch(value, index, this.simplePrefix)) {\r\n            withinNestedPlaceholder++;\r\n            index = index + this.simplePrefix.length();\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    return -1;\r\n}\nprivate boolean isEscaped(String value, int index) {\r\n    return (this.escape != null && index > 0 && value.charAt(index - 1) == this.escape);\r\n}\nrecord ParsedSection(String key, @Nullable String fallback) {\r\n}\n/**\r\n * Provide the necessary context to handle and resolve underlying placeholders.\r\n */\r\nstatic class PartResolutionContext implements PlaceholderResolver {\r\n\r\n    private final String prefix;\r\n\r\n    private final String suffix;\r\n\r\n    private final boolean ignoreUnresolvablePlaceholders;\r\n\r\n    private final Function<String, List<Part>> parser;\r\n\r\n    private final PlaceholderResolver resolver;\r\n\r\n    @Nullable\r\n    private Set<String> visitedPlaceholders;\r\n\r\n    PartResolutionContext(PlaceholderResolver resolver, String prefix, String suffix, boolean ignoreUnresolvablePlaceholders, Function<String, List<Part>> parser) {\r\n        this.prefix = prefix;\r\n        this.suffix = suffix;\r\n        this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;\r\n        this.parser = parser;\r\n        this.resolver = resolver;\r\n    }\r\n\r\n    @Override\r\n    @Nullable\r\n    public String resolvePlaceholder(String placeholderName) {\r\n        String value = this.resolver.resolvePlaceholder(placeholderName);\r\n        if (value != null && logger.isTraceEnabled()) {\r\n            logger.trace(\"Resolved placeholder '\" + placeholderName + \"'\");\r\n        }\r\n        return value;\r\n    }\r\n\r\n    public String handleUnresolvablePlaceholder(String key, String text) {\r\n        if (this.ignoreUnresolvablePlaceholders) {\r\n            return toPlaceholderText(key);\r\n        }\r\n        String originalValue = (!key.equals(text) ? toPlaceholderText(text) : null);\r\n        throw new PlaceholderResolutionException(\"Could not resolve placeholder '%s'\".formatted(key), key, originalValue);\r\n    }\r\n\r\n    private String toPlaceholderText(String text) {\r\n        return this.prefix + text + this.suffix;\r\n    }\r\n\r\n    public List<Part> parse(String text) {\r\n        return this.parser.apply(text);\r\n    }\r\n\r\n    public void flagPlaceholderAsVisited(String placeholder) {\r\n        if (this.visitedPlaceholders == null) {\r\n            this.visitedPlaceholders = new HashSet<>(4);\r\n        }\r\n        if (!this.visitedPlaceholders.add(placeholder)) {\r\n            throw new PlaceholderResolutionException(\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\r\n        }\r\n    }\r\n\r\n    public void removePlaceholder(String placeholder) {\r\n        Assert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");\r\n        this.visitedPlaceholders.remove(placeholder);\r\n    }\r\n}\n/**\r\n * A part is a section of a String containing placeholders to replace.\r\n */\r\ninterface Part {\r\n\r\n    /**\r\n     * Resolve this part using the specified {@link PartResolutionContext}.\r\n     * @param resolutionContext the context to use\r\n     * @return the resolved part\r\n     */\r\n    String resolve(PartResolutionContext resolutionContext);\r\n\r\n    /**\r\n     * Provide a textual representation of this part.\r\n     * @return the raw text that this part defines\r\n     */\r\n    String text();\r\n\r\n    /**\r\n     * Return a String that appends the resolution of the specified parts.\r\n     * @param parts the parts to resolve\r\n     * @param resolutionContext the context to use for the resolution\r\n     * @return a concatenation of the supplied parts with placeholders replaced inline\r\n     */\r\n    static String resolveAll(Iterable<Part> parts, PartResolutionContext resolutionContext) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (Part part : parts) {\r\n            sb.append(part.resolve(resolutionContext));\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\n/**\r\n * A representation of the parsing of an input string.\r\n * @param text the raw input string\r\n * @param parts the parts that appear in the string, in order\r\n */\r\nrecord ParsedValue(String text, List<Part> parts) {\r\n\r\n    public String resolve(PartResolutionContext resolutionContext) {\r\n        try {\r\n            return Part.resolveAll(this.parts, resolutionContext);\r\n        } catch (PlaceholderResolutionException ex) {\r\n            throw ex.withValue(this.text);\r\n        }\r\n    }\r\n}\n/**\r\n * A base {@link Part} implementation.\r\n */\r\nabstract static class AbstractPart implements Part {\r\n\r\n    private final String text;\r\n\r\n    protected AbstractPart(String text) {\r\n        this.text = text;\r\n    }\r\n\r\n    @Override\r\n    public String text() {\r\n        return this.text;\r\n    }\r\n\r\n    /**\r\n     * Resolve the placeholder with the given {@code key}. If the result of such\r\n     * resolution return other placeholders, those are resolved as well until the\r\n     * resolution no longer contains any placeholders.\r\n     * @param resolutionContext the resolution context to use\r\n     * @param key the initial placeholder\r\n     * @return the full resolution of the given {@code key} or {@code null} if\r\n     * the placeholder has no value to begin with\r\n     */\r\n    @Nullable\r\n    protected String resolveRecursively(PartResolutionContext resolutionContext, String key) {\r\n        String resolvedValue = resolutionContext.resolvePlaceholder(key);\r\n        if (resolvedValue != null) {\r\n            resolutionContext.flagPlaceholderAsVisited(key);\r\n            // Let's check if we need to recursively resolve that value\r\n            List<Part> nestedParts = resolutionContext.parse(resolvedValue);\r\n            String value = toText(nestedParts);\r\n            if (!isTextOnly(nestedParts)) {\r\n                value = new ParsedValue(resolvedValue, nestedParts).resolve(resolutionContext);\r\n            }\r\n            resolutionContext.removePlaceholder(key);\r\n            return value;\r\n        }\r\n        // Not found\r\n        return null;\r\n    }\r\n\r\n    private boolean isTextOnly(List<Part> parts) {\r\n        return parts.stream().allMatch(TextPart.class::isInstance);\r\n    }\r\n\r\n    private String toText(List<Part> parts) {\r\n        StringBuilder sb = new StringBuilder();\r\n        parts.forEach(part -> sb.append(part.text()));\r\n        return sb.toString();\r\n    }\r\n}\n/**\r\n * A {@link Part} implementation that does not contain a valid placeholder.\r\n */\r\nstatic class TextPart extends AbstractPart {\r\n\r\n    /**\r\n     * Create a new instance.\r\n     * @param text the raw (and resolved) text\r\n     */\r\n    public TextPart(String text) {\r\n        super(text);\r\n    }\r\n\r\n    @Override\r\n    public String resolve(PartResolutionContext resolutionContext) {\r\n        return text();\r\n    }\r\n}\n/**\r\n * A {@link Part} implementation that represents a single placeholder with\r\n * a hard-coded fallback.\r\n */\r\nstatic class SimplePlaceholderPart extends AbstractPart {\r\n\r\n    private final String key;\r\n\r\n    @Nullable\r\n    private final String fallback;\r\n\r\n    /**\r\n     * Create a new instance.\r\n     * @param text the raw text\r\n     * @param key the key of the placeholder\r\n     * @param fallback the fallback to use, if any\r\n     */\r\n    public SimplePlaceholderPart(String text, String key, @Nullable String fallback) {\r\n        super(text);\r\n        this.key = key;\r\n        this.fallback = fallback;\r\n    }\r\n\r\n    @Override\r\n    public String resolve(PartResolutionContext resolutionContext) {\r\n        String value = resolveRecursively(resolutionContext);\r\n        if (value != null) {\r\n            return value;\r\n        } else if (this.fallback != null) {\r\n            return this.fallback;\r\n        }\r\n        return resolutionContext.handleUnresolvablePlaceholder(this.key, text());\r\n    }\r\n\r\n    @Nullable\r\n    private String resolveRecursively(PartResolutionContext resolutionContext) {\r\n        if (!this.text().equals(this.key)) {\r\n            String value = resolveRecursively(resolutionContext, this.text());\r\n            if (value != null) {\r\n                return value;\r\n            }\r\n        }\r\n        return resolveRecursively(resolutionContext, this.key);\r\n    }\r\n}\n/**\r\n * A {@link Part} implementation that represents a single placeholder\r\n * containing nested placeholders.\r\n */\r\nstatic class NestedPlaceholderPart extends AbstractPart {\r\n\r\n    private final List<Part> keyParts;\r\n\r\n    @Nullable\r\n    private final List<Part> defaultParts;\r\n\r\n    /**\r\n     * Create a new instance.\r\n     * @param text the raw text of the root placeholder\r\n     * @param keyParts the parts of the key\r\n     * @param defaultParts the parts of the fallback, if any\r\n     */\r\n    NestedPlaceholderPart(String text, List<Part> keyParts, @Nullable List<Part> defaultParts) {\r\n        super(text);\r\n        this.keyParts = keyParts;\r\n        this.defaultParts = defaultParts;\r\n    }\r\n\r\n    @Override\r\n    public String resolve(PartResolutionContext resolutionContext) {\r\n        String resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\r\n        String value = resolveRecursively(resolutionContext, resolvedKey);\r\n        if (value != null) {\r\n            return value;\r\n        } else if (this.defaultParts != null) {\r\n            return Part.resolveAll(this.defaultParts, resolutionContext);\r\n        }\r\n        return resolutionContext.handleUnresolvablePlaceholder(resolvedKey, text());\r\n    }\r\n}",
    "comment": "\n * Parser for Strings that have placeholder values in them. In its simplest form,\n * a placeholder takes the form of {@code ${name}}, where {@code name} is the key\n * that can be resolved using a {@link PlaceholderResolver PlaceholderResolver},\n * <code>${</code> the prefix, and <code>}</code> the suffix.\n *\n * <p>A placeholder can also have a default value if its key does not represent a\n * known property. The default value is separated from the key using a\n * {@code separator}. For instance {@code ${name:John}} resolves to {@code John} if\n * the placeholder resolver does not provide a value for the {@code name}\n * property.\n *\n * <p>Placeholders can also have a more complex structure, and the resolution of\n * a given key can involve the resolution of nested placeholders. Default values\n * can also have placeholders.\n *\n * <p>For situations where the syntax of a valid placeholder matches a String that\n * must be rendered as is, the placeholder can be escaped using an {@code escape}\n * character. For instance {@code \\${name}} resolves as {@code ${name}}.\n *\n * <p>The prefix, suffix, separator, and escape characters are configurable. Only\n * the prefix and suffix are mandatory, and the support for default values or\n * escaping is conditional on providing non-null values for them.\n *\n * <p>This parser makes sure to resolves placeholders as lazily as possible.\n *\n * @author Stephane Nicoll\n * @since 6.2\n "
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
    "entityType": "method",
    "code": "/**\r\n * Replace all placeholders of format {@code ${name}} with the value returned\r\n * from the supplied {@link PlaceholderResolver}.\r\n * @param value the value containing the placeholders to be replaced\r\n * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\r\n * @return the supplied value with placeholders replaced inline\r\n */\r\npublic String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\r\n    Assert.notNull(value, \"'value' must not be null\");\r\n    ParsedValue parsedValue = parse(value);\r\n    PartResolutionContext resolutionContext = new PartResolutionContext(placeholderResolver, this.prefix, this.suffix, this.ignoreUnresolvablePlaceholders, candidate -> parse(candidate, false));\r\n    return parsedValue.resolve(resolutionContext);\r\n}",
    "comment": "\n\t * Replace all placeholders of format {@code ${name}} with the value returned\n\t * from the supplied {@link PlaceholderResolver}.\n\t * @param value the value containing the placeholders to be replaced\n\t * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement\n\t * @return the supplied value with placeholders replaced inline\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#parse(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the specified value.\r\n * @param value the value containing the placeholders to be replaced\r\n * @return the different parts that have been identified\r\n */\r\nParsedValue parse(String value) {\r\n    List<Part> parts = parse(value, false);\r\n    return new ParsedValue(value, parts);\r\n}",
    "comment": "\n\t * Parse the specified value.\n\t * @param value the value containing the placeholders to be replaced\n\t * @return the different parts that have been identified\n\t "
  },
  {
    "entityId": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
    "entityType": "method",
    "code": "private List<Part> parse(String value, boolean inPlaceholder) {\r\n    LinkedList<Part> parts = new LinkedList<>();\r\n    int startIndex = nextStartPrefix(value, 0);\r\n    if (startIndex == -1) {\r\n        Part part = (inPlaceholder ? createSimplePlaceholderPart(value) : new TextPart(value));\r\n        parts.add(part);\r\n        return parts;\r\n    }\r\n    int position = 0;\r\n    while (startIndex != -1) {\r\n        int endIndex = nextValidEndPrefix(value, startIndex);\r\n        if (endIndex == -1) {\r\n            // Not a valid placeholder, consume the prefix and continue\r\n            addText(value, position, startIndex + this.prefix.length(), parts);\r\n            position = startIndex + this.prefix.length();\r\n            startIndex = nextStartPrefix(value, position);\r\n        } else if (isEscaped(value, startIndex)) {\r\n            // Not a valid index, accumulate and skip the escape character\r\n            addText(value, position, startIndex - 1, parts);\r\n            addText(value, startIndex, startIndex + this.prefix.length(), parts);\r\n            position = startIndex + this.prefix.length();\r\n            startIndex = nextStartPrefix(value, position);\r\n        } else {\r\n            // Found valid placeholder, recursive parsing\r\n            addText(value, position, startIndex, parts);\r\n            String placeholder = value.substring(startIndex + this.prefix.length(), endIndex);\r\n            List<Part> placeholderParts = parse(placeholder, true);\r\n            parts.addAll(placeholderParts);\r\n            startIndex = nextStartPrefix(value, endIndex + this.suffix.length());\r\n            position = endIndex + this.suffix.length();\r\n        }\r\n    }\r\n    // Add rest of text if necessary\r\n    addText(value, position, value.length(), parts);\r\n    return (inPlaceholder ? List.of(createNestedPlaceholderPart(value, parts)) : parts);\r\n}",
    "comment": ""
  }
]