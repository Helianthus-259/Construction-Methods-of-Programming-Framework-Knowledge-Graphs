[
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#filterArray(Object[])",
    "entityType": "method",
    "code": "private void filterArray(Object[] array) {\r\n    for (int i = 0; i < array.length; i++) {\r\n        if (array[i] instanceof List<?> list) {\r\n            array[i] = Collections.unmodifiableList(list);\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#iterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Iterator<List<V>> iterator() {\r\n    Iterator<List<V>> iterator = this.delegate.iterator();\r\n    return new Iterator<>() {\r\n\r\n        @Override\r\n        public boolean hasNext() {\r\n            return iterator.hasNext();\r\n        }\r\n\r\n        @Override\r\n        public List<V> next() {\r\n            return Collections.unmodifiableList(iterator.next());\r\n        }\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#forEach(Consumer<? super List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEach(Consumer<? super List<V>> action) {\r\n    this.delegate.forEach(list -> action.accept(Collections.unmodifiableList(list)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
    "entityType": "method",
    "code": "@Override\r\npublic Spliterator<List<V>> spliterator() {\r\n    return new UnmodifiableValueSpliterator<>(this.delegate.spliterator());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#stream()",
    "entityType": "method",
    "code": "@Override\r\npublic Stream<List<V>> stream() {\r\n    return StreamSupport.stream(spliterator(), false);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#parallelStream()",
    "entityType": "method",
    "code": "@Override\r\npublic Stream<List<V>> parallelStream() {\r\n    return StreamSupport.stream(spliterator(), true);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(@Nullable Object other) {\r\n    return (this == other || this.delegate.equals(other));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return this.delegate.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return this.delegate.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#add(List<V>)",
    "entityType": "method",
    "code": "// unsupported\r\n@Override\r\npublic boolean add(List<V> ts) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean remove(Object o) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean addAll(Collection<? extends List<V>> c) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#removeAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean removeAll(Collection<?> c) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#retainAll(Collection<?>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean retainAll(Collection<?> c) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean removeIf(Predicate<? super List<V>> filter) {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueCollection#clear()",
    "entityType": "method",
    "code": "@Override\r\npublic void clear() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator",
    "entityType": "class",
    "code": "private final Spliterator<List<T>> delegate;\npublic UnmodifiableValueSpliterator(Spliterator<List<T>> delegate) {\r\n    this.delegate = delegate;\r\n}\n@Override\r\npublic boolean tryAdvance(Consumer<? super List<T>> action) {\r\n    return this.delegate.tryAdvance(l -> action.accept(Collections.unmodifiableList(l)));\r\n}\n@Override\r\npublic void forEachRemaining(Consumer<? super List<T>> action) {\r\n    this.delegate.forEachRemaining(l -> action.accept(Collections.unmodifiableList(l)));\r\n}\n@Override\r\n@Nullable\r\npublic Spliterator<List<T>> trySplit() {\r\n    Spliterator<List<T>> split = this.delegate.trySplit();\r\n    if (split != null) {\r\n        return new UnmodifiableValueSpliterator<>(split);\r\n    } else {\r\n        return null;\r\n    }\r\n}\n@Override\r\npublic long estimateSize() {\r\n    return this.delegate.estimateSize();\r\n}\n@Override\r\npublic long getExactSizeIfKnown() {\r\n    return this.delegate.getExactSizeIfKnown();\r\n}\n@Override\r\npublic int characteristics() {\r\n    return this.delegate.characteristics();\r\n}\n@Override\r\npublic boolean hasCharacteristics(int characteristics) {\r\n    return this.delegate.hasCharacteristics(characteristics);\r\n}\n@Override\r\npublic Comparator<? super List<T>> getComparator() {\r\n    return this.delegate.getComparator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#tryAdvance(Consumer<? super List<T>>)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean tryAdvance(Consumer<? super List<T>> action) {\r\n    return this.delegate.tryAdvance(l -> action.accept(Collections.unmodifiableList(l)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#forEachRemaining(Consumer<? super List<T>>)",
    "entityType": "method",
    "code": "@Override\r\npublic void forEachRemaining(Consumer<? super List<T>> action) {\r\n    this.delegate.forEachRemaining(l -> action.accept(Collections.unmodifiableList(l)));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#trySplit()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic Spliterator<List<T>> trySplit() {\r\n    Spliterator<List<T>> split = this.delegate.trySplit();\r\n    if (split != null) {\r\n        return new UnmodifiableValueSpliterator<>(split);\r\n    } else {\r\n        return null;\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#estimateSize()",
    "entityType": "method",
    "code": "@Override\r\npublic long estimateSize() {\r\n    return this.delegate.estimateSize();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#getExactSizeIfKnown()",
    "entityType": "method",
    "code": "@Override\r\npublic long getExactSizeIfKnown() {\r\n    return this.delegate.getExactSizeIfKnown();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#characteristics()",
    "entityType": "method",
    "code": "@Override\r\npublic int characteristics() {\r\n    return this.delegate.characteristics();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#hasCharacteristics(int)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean hasCharacteristics(int characteristics) {\r\n    return this.delegate.hasCharacteristics(characteristics);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UnmodifiableValueSpliterator#getComparator()",
    "entityType": "method",
    "code": "@Override\r\npublic Comparator<? super List<T>> getComparator() {\r\n    return this.delegate.getComparator();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.UpdateMessageDigestInputStream",
    "entityType": "class",
    "code": "/**\r\n * Update the message digest with the rest of the bytes in this stream.\r\n * <p>Using this method is more optimized since it avoids creating new\r\n * byte arrays for each call.\r\n * @param messageDigest the message digest to update\r\n * @throws IOException when propagated from {@link #read()}\r\n */\r\npublic void updateMessageDigest(MessageDigest messageDigest) throws IOException {\r\n    int data;\r\n    while ((data = read()) != -1) {\r\n        messageDigest.update((byte) data);\r\n    }\r\n}\n/**\r\n * Update the message digest with the next len bytes in this stream.\r\n * <p>Using this method is more optimized since it avoids creating new\r\n * byte arrays for each call.\r\n * @param messageDigest the message digest to update\r\n * @param len how many bytes to read from this stream and use to update the message digest\r\n * @throws IOException when propagated from {@link #read()}\r\n */\r\npublic void updateMessageDigest(MessageDigest messageDigest, int len) throws IOException {\r\n    int data;\r\n    int bytesRead = 0;\r\n    while (bytesRead < len && (data = read()) != -1) {\r\n        messageDigest.update((byte) data);\r\n        bytesRead++;\r\n    }\r\n}",
    "comment": "\n * Extension of {@link java.io.InputStream} that allows for optimized\n * implementations of message digesting.\n *\n * @author Craig Andrews\n * @since 4.2\n "
  },
  {
    "entityId": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
    "entityType": "method",
    "code": "/**\r\n * Update the message digest with the rest of the bytes in this stream.\r\n * <p>Using this method is more optimized since it avoids creating new\r\n * byte arrays for each call.\r\n * @param messageDigest the message digest to update\r\n * @throws IOException when propagated from {@link #read()}\r\n */\r\npublic void updateMessageDigest(MessageDigest messageDigest) throws IOException {\r\n    int data;\r\n    while ((data = read()) != -1) {\r\n        messageDigest.update((byte) data);\r\n    }\r\n}",
    "comment": "\n\t * Update the message digest with the rest of the bytes in this stream.\n\t * <p>Using this method is more optimized since it avoids creating new\n\t * byte arrays for each call.\n\t * @param messageDigest the message digest to update\n\t * @throws IOException when propagated from {@link #read()}\n\t "
  },
  {
    "entityId": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
    "entityType": "method",
    "code": "/**\r\n * Update the message digest with the next len bytes in this stream.\r\n * <p>Using this method is more optimized since it avoids creating new\r\n * byte arrays for each call.\r\n * @param messageDigest the message digest to update\r\n * @param len how many bytes to read from this stream and use to update the message digest\r\n * @throws IOException when propagated from {@link #read()}\r\n */\r\npublic void updateMessageDigest(MessageDigest messageDigest, int len) throws IOException {\r\n    int data;\r\n    int bytesRead = 0;\r\n    while (bytesRead < len && (data = read()) != -1) {\r\n        messageDigest.update((byte) data);\r\n        bytesRead++;\r\n    }\r\n}",
    "comment": "\n\t * Update the message digest with the next len bytes in this stream.\n\t * <p>Using this method is more optimized since it avoids creating new\n\t * byte arrays for each call.\n\t * @param messageDigest the message digest to update\n\t * @param len how many bytes to read from this stream and use to update the message digest\n\t * @throws IOException when propagated from {@link #read()}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler",
    "entityType": "class",
    "code": "private final List<Map<String, String>> namespaceMappings = new ArrayList<>();\nprivate boolean inCData;\n@Override\r\npublic final void startDocument() throws SAXException {\r\n    removeAllNamespaceMappings();\r\n    newNamespaceMapping();\r\n    try {\r\n        startDocumentInternal();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle startDocument: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void endDocument() throws SAXException {\r\n    removeAllNamespaceMappings();\r\n    try {\r\n        endDocumentInternal();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle endDocument: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void startPrefixMapping(String prefix, String uri) {\r\n    currentNamespaceMapping().put(prefix, uri);\r\n}\n@Override\r\npublic final void endPrefixMapping(String prefix) ;\n@Override\r\npublic final void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {\r\n    try {\r\n        startElementInternal(toQName(uri, qName), atts, currentNamespaceMapping());\r\n        newNamespaceMapping();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle startElement: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void endElement(String uri, String localName, String qName) throws SAXException {\r\n    try {\r\n        endElementInternal(toQName(uri, qName), currentNamespaceMapping());\r\n        removeNamespaceMapping();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle endElement: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void characters(char[] ch, int start, int length) throws SAXException {\r\n    try {\r\n        String data = new String(ch, start, length);\r\n        if (!this.inCData) {\r\n            charactersInternal(data);\r\n        } else {\r\n            cDataInternal(data);\r\n        }\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle characters: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\r\n    try {\r\n        ignorableWhitespaceInternal(new String(ch, start, length));\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle ignorableWhitespace:\" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void processingInstruction(String target, String data) throws SAXException {\r\n    try {\r\n        processingInstructionInternal(target, data);\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle processingInstruction: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void skippedEntity(String name) throws SAXException {\r\n    try {\r\n        skippedEntityInternal(name);\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle skippedEntity: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void startDTD(String name, @Nullable String publicId, String systemId) throws SAXException {\r\n    try {\r\n        StringBuilder builder = new StringBuilder(\"<!DOCTYPE \");\r\n        builder.append(name);\r\n        if (publicId != null) {\r\n            builder.append(\" PUBLIC \\\"\");\r\n            builder.append(publicId);\r\n            builder.append(\"\\\" \\\"\");\r\n        } else {\r\n            builder.append(\" SYSTEM \\\"\");\r\n        }\r\n        builder.append(systemId);\r\n        builder.append(\"\\\">\");\r\n        dtdInternal(builder.toString());\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle startDTD: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic final void endDTD() throws SAXException ;\n@Override\r\npublic final void startCDATA() throws SAXException {\r\n    this.inCData = true;\r\n}\n@Override\r\npublic final void endCDATA() throws SAXException {\r\n    this.inCData = false;\r\n}\n@Override\r\npublic final void comment(char[] ch, int start, int length) throws SAXException {\r\n    try {\r\n        commentInternal(new String(ch, start, length));\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle comment: \" + ex.getMessage(), ex);\r\n    }\r\n}\n@Override\r\npublic void startEntity(String name) throws SAXException ;\n@Override\r\npublic void endEntity(String name) throws SAXException ;\n/**\r\n * Convert a namespace URI and DOM or SAX qualified name to a {@code QName}. The\r\n * qualified name can have the form {@code prefix:localname} or {@code localName}.\r\n * @param namespaceUri the namespace URI\r\n * @param qualifiedName the qualified name\r\n * @return a QName\r\n */\r\nprotected QName toQName(String namespaceUri, String qualifiedName) {\r\n    int idx = qualifiedName.indexOf(':');\r\n    if (idx == -1) {\r\n        return new QName(namespaceUri, qualifiedName);\r\n    } else {\r\n        String prefix = qualifiedName.substring(0, idx);\r\n        String localPart = qualifiedName.substring(idx + 1);\r\n        return new QName(namespaceUri, localPart, prefix);\r\n    }\r\n}\nprotected boolean isNamespaceDeclaration(QName qName) {\r\n    String prefix = qName.getPrefix();\r\n    String localPart = qName.getLocalPart();\r\n    return (XMLConstants.XMLNS_ATTRIBUTE.equals(localPart) && prefix.isEmpty()) || (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) && !localPart.isEmpty());\r\n}\nprivate Map<String, String> currentNamespaceMapping() {\r\n    return this.namespaceMappings.get(this.namespaceMappings.size() - 1);\r\n}\nprivate void newNamespaceMapping() {\r\n    this.namespaceMappings.add(new HashMap<>());\r\n}\nprivate void removeNamespaceMapping() {\r\n    this.namespaceMappings.remove(this.namespaceMappings.size() - 1);\r\n}\nprivate void removeAllNamespaceMappings() {\r\n    this.namespaceMappings.clear();\r\n}\nprotected abstract void startDocumentInternal() throws XMLStreamException;\nprotected abstract void endDocumentInternal() throws XMLStreamException;\nprotected abstract void startElementInternal(QName name, Attributes attributes, Map<String, String> namespaceMapping) throws XMLStreamException;\nprotected abstract void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException;\nprotected abstract void charactersInternal(String data) throws XMLStreamException;\nprotected abstract void cDataInternal(String data) throws XMLStreamException;\nprotected abstract void ignorableWhitespaceInternal(String data) throws XMLStreamException;\nprotected abstract void processingInstructionInternal(String target, String data) throws XMLStreamException;\nprotected abstract void skippedEntityInternal(String name) throws XMLStreamException;\nprotected abstract void dtdInternal(String dtd) throws XMLStreamException;\nprotected abstract void commentInternal(String comment) throws XMLStreamException;",
    "comment": "\n * Abstract base class for SAX {@code ContentHandler} and {@code LexicalHandler}\n * implementations that use StAX as a basis. All methods delegate to internal template\n * methods, capable of throwing a {@code XMLStreamException}. Additionally, a namespace\n * context stack is used to keep track of declared namespaces.\n *\n * @author Arjen Poutsma\n * @since 4.0.3\n "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
    "entityType": "method",
    "code": "@Override\r\npublic final void startDocument() throws SAXException {\r\n    removeAllNamespaceMappings();\r\n    newNamespaceMapping();\r\n    try {\r\n        startDocumentInternal();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle startDocument: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
    "entityType": "method",
    "code": "@Override\r\npublic final void endDocument() throws SAXException {\r\n    removeAllNamespaceMappings();\r\n    try {\r\n        endDocumentInternal();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle endDocument: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startPrefixMapping(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void startPrefixMapping(String prefix, String uri) {\r\n    currentNamespaceMapping().put(prefix, uri);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endPrefixMapping(String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void endPrefixMapping(String prefix) ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startElement(String,String,String,Attributes)",
    "entityType": "method",
    "code": "@Override\r\npublic final void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {\r\n    try {\r\n        startElementInternal(toQName(uri, qName), atts, currentNamespaceMapping());\r\n        newNamespaceMapping();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle startElement: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void endElement(String uri, String localName, String qName) throws SAXException {\r\n    try {\r\n        endElementInternal(toQName(uri, qName), currentNamespaceMapping());\r\n        removeNamespaceMapping();\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle endElement: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic final void characters(char[] ch, int start, int length) throws SAXException {\r\n    try {\r\n        String data = new String(ch, start, length);\r\n        if (!this.inCData) {\r\n            charactersInternal(data);\r\n        } else {\r\n            cDataInternal(data);\r\n        }\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle characters: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic final void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {\r\n    try {\r\n        ignorableWhitespaceInternal(new String(ch, start, length));\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle ignorableWhitespace:\" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void processingInstruction(String target, String data) throws SAXException {\r\n    try {\r\n        processingInstructionInternal(target, data);\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle processingInstruction: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void skippedEntity(String name) throws SAXException {\r\n    try {\r\n        skippedEntityInternal(name);\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle skippedEntity: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startDTD(String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic final void startDTD(String name, @Nullable String publicId, String systemId) throws SAXException {\r\n    try {\r\n        StringBuilder builder = new StringBuilder(\"<!DOCTYPE \");\r\n        builder.append(name);\r\n        if (publicId != null) {\r\n            builder.append(\" PUBLIC \\\"\");\r\n            builder.append(publicId);\r\n            builder.append(\"\\\" \\\"\");\r\n        } else {\r\n            builder.append(\" SYSTEM \\\"\");\r\n        }\r\n        builder.append(systemId);\r\n        builder.append(\"\\\">\");\r\n        dtdInternal(builder.toString());\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle startDTD: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endDTD()",
    "entityType": "method",
    "code": "@Override\r\npublic final void endDTD() throws SAXException ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startCDATA()",
    "entityType": "method",
    "code": "@Override\r\npublic final void startCDATA() throws SAXException {\r\n    this.inCData = true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endCDATA()",
    "entityType": "method",
    "code": "@Override\r\npublic final void endCDATA() throws SAXException {\r\n    this.inCData = false;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
    "entityType": "method",
    "code": "@Override\r\npublic final void comment(char[] ch, int start, int length) throws SAXException {\r\n    try {\r\n        commentInternal(new String(ch, start, length));\r\n    } catch (XMLStreamException ex) {\r\n        throw new SAXException(\"Could not handle comment: \" + ex.getMessage(), ex);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startEntity(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void startEntity(String name) throws SAXException ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endEntity(String)",
    "entityType": "method",
    "code": "@Override\r\npublic void endEntity(String name) throws SAXException ;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#toQName(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Convert a namespace URI and DOM or SAX qualified name to a {@code QName}. The\r\n * qualified name can have the form {@code prefix:localname} or {@code localName}.\r\n * @param namespaceUri the namespace URI\r\n * @param qualifiedName the qualified name\r\n * @return a QName\r\n */\r\nprotected QName toQName(String namespaceUri, String qualifiedName) {\r\n    int idx = qualifiedName.indexOf(':');\r\n    if (idx == -1) {\r\n        return new QName(namespaceUri, qualifiedName);\r\n    } else {\r\n        String prefix = qualifiedName.substring(0, idx);\r\n        String localPart = qualifiedName.substring(idx + 1);\r\n        return new QName(namespaceUri, localPart, prefix);\r\n    }\r\n}",
    "comment": "\n\t * Convert a namespace URI and DOM or SAX qualified name to a {@code QName}. The\n\t * qualified name can have the form {@code prefix:localname} or {@code localName}.\n\t * @param namespaceUri the namespace URI\n\t * @param qualifiedName the qualified name\n\t * @return a QName\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#isNamespaceDeclaration(QName)",
    "entityType": "method",
    "code": "protected boolean isNamespaceDeclaration(QName qName) {\r\n    String prefix = qName.getPrefix();\r\n    String localPart = qName.getLocalPart();\r\n    return (XMLConstants.XMLNS_ATTRIBUTE.equals(localPart) && prefix.isEmpty()) || (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) && !localPart.isEmpty());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#currentNamespaceMapping()",
    "entityType": "method",
    "code": "private Map<String, String> currentNamespaceMapping() {\r\n    return this.namespaceMappings.get(this.namespaceMappings.size() - 1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#newNamespaceMapping()",
    "entityType": "method",
    "code": "private void newNamespaceMapping() {\r\n    this.namespaceMappings.add(new HashMap<>());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#removeNamespaceMapping()",
    "entityType": "method",
    "code": "private void removeNamespaceMapping() {\r\n    this.namespaceMappings.remove(this.namespaceMappings.size() - 1);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#removeAllNamespaceMappings()",
    "entityType": "method",
    "code": "private void removeAllNamespaceMappings() {\r\n    this.namespaceMappings.clear();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startDocumentInternal()",
    "entityType": "method",
    "code": "protected abstract void startDocumentInternal() throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endDocumentInternal()",
    "entityType": "method",
    "code": "protected abstract void endDocumentInternal() throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#startElementInternal(QName,Attributes,Map<String,String>)",
    "entityType": "method",
    "code": "protected abstract void startElementInternal(QName name, Attributes attributes, Map<String, String> namespaceMapping) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#endElementInternal(QName,Map<String,String>)",
    "entityType": "method",
    "code": "protected abstract void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#charactersInternal(String)",
    "entityType": "method",
    "code": "protected abstract void charactersInternal(String data) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#cDataInternal(String)",
    "entityType": "method",
    "code": "protected abstract void cDataInternal(String data) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespaceInternal(String)",
    "entityType": "method",
    "code": "protected abstract void ignorableWhitespaceInternal(String data) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#processingInstructionInternal(String,String)",
    "entityType": "method",
    "code": "protected abstract void processingInstructionInternal(String target, String data) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#skippedEntityInternal(String)",
    "entityType": "method",
    "code": "protected abstract void skippedEntityInternal(String name) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#dtdInternal(String)",
    "entityType": "method",
    "code": "protected abstract void dtdInternal(String dtd) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String)",
    "entityType": "method",
    "code": "protected abstract void commentInternal(String comment) throws XMLStreamException;",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader",
    "entityType": "class",
    "code": "private static final String NAMESPACES_FEATURE_NAME = \"http://xml.org/sax/features/namespaces\";\nprivate static final String NAMESPACE_PREFIXES_FEATURE_NAME = \"http://xml.org/sax/features/namespace-prefixes\";\nprivate static final String IS_STANDALONE_FEATURE_NAME = \"http://xml.org/sax/features/is-standalone\";\nprivate boolean namespacesFeature = true;\nprivate boolean namespacePrefixesFeature = false;\n@Nullable\r\nprivate Boolean isStandalone;\nprivate final Map<String, String> namespaces = new LinkedHashMap<>();\n@Override\r\npublic boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    return switch(name) {\r\n        case NAMESPACES_FEATURE_NAME ->\r\n            this.namespacesFeature;\r\n        case NAMESPACE_PREFIXES_FEATURE_NAME ->\r\n            this.namespacePrefixesFeature;\r\n        case IS_STANDALONE_FEATURE_NAME ->\r\n            {\r\n                if (this.isStandalone != null) {\r\n                    yield this.isStandalone;\r\n                } else {\r\n                    throw new SAXNotSupportedException(\"startDocument() callback not completed yet\");\r\n                }\r\n            }\r\n        default ->\r\n            super.getFeature(name);\r\n    };\r\n}\n@Override\r\npublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (NAMESPACES_FEATURE_NAME.equals(name)) {\r\n        this.namespacesFeature = value;\r\n    } else if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\r\n        this.namespacePrefixesFeature = value;\r\n    } else {\r\n        super.setFeature(name, value);\r\n    }\r\n}\nprotected void setStandalone(boolean standalone) {\r\n    this.isStandalone = standalone;\r\n}\n/**\r\n * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces} is turned on.\r\n */\r\nprotected boolean hasNamespacesFeature() {\r\n    return this.namespacesFeature;\r\n}\n/**\r\n * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces-prefixes} is turned on.\r\n */\r\nprotected boolean hasNamespacePrefixesFeature() {\r\n    return this.namespacePrefixesFeature;\r\n}\n/**\r\n * Convert a {@code QName} to a qualified name, as used by DOM and SAX.\r\n * The returned string has a format of {@code prefix:localName} if the\r\n * prefix is set, or just {@code localName} if not.\r\n * @param qName the {@code QName}\r\n * @return the qualified name\r\n */\r\nprotected String toQualifiedName(QName qName) {\r\n    String prefix = qName.getPrefix();\r\n    if (!StringUtils.hasLength(prefix)) {\r\n        return qName.getLocalPart();\r\n    } else {\r\n        return prefix + \":\" + qName.getLocalPart();\r\n    }\r\n}\n/**\r\n * Parse the StAX XML reader passed at construction-time.\r\n * <p><b>NOTE:</b>: The given {@code InputSource} is not read, but ignored.\r\n * @param ignored is ignored\r\n * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\r\n */\r\n@Override\r\npublic final void parse(InputSource ignored) throws SAXException {\r\n    parse();\r\n}\n/**\r\n * Parse the StAX XML reader passed at construction-time.\r\n * <p><b>NOTE:</b>: The given system identifier is not read, but ignored.\r\n * @param ignored is ignored\r\n * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\r\n */\r\n@Override\r\npublic final void parse(String ignored) throws SAXException {\r\n    parse();\r\n}\nprivate void parse() throws SAXException {\r\n    try {\r\n        parseInternal();\r\n    } catch (XMLStreamException ex) {\r\n        Locator locator = null;\r\n        if (ex.getLocation() != null) {\r\n            locator = new StaxLocator(ex.getLocation());\r\n        }\r\n        SAXParseException saxException = new SAXParseException(ex.getMessage(), locator, ex);\r\n        if (getErrorHandler() != null) {\r\n            getErrorHandler().fatalError(saxException);\r\n        } else {\r\n            throw saxException;\r\n        }\r\n    }\r\n}\n/**\r\n * Template method that parses the StAX reader passed at construction-time.\r\n */\r\nprotected abstract void parseInternal() throws SAXException, XMLStreamException;\n/**\r\n * Start the prefix mapping for the given prefix.\r\n * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\r\n */\r\nprotected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {\r\n    if (getContentHandler() != null && StringUtils.hasLength(namespace)) {\r\n        if (prefix == null) {\r\n            prefix = \"\";\r\n        }\r\n        if (!namespace.equals(this.namespaces.get(prefix))) {\r\n            getContentHandler().startPrefixMapping(prefix, namespace);\r\n            this.namespaces.put(prefix, namespace);\r\n        }\r\n    }\r\n}\n/**\r\n * End the prefix mapping for the given prefix.\r\n * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\r\n */\r\nprotected void endPrefixMapping(String prefix) throws SAXException {\r\n    if (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\r\n        getContentHandler().endPrefixMapping(prefix);\r\n        this.namespaces.remove(prefix);\r\n    }\r\n}\n/**\r\n * Implementation of the {@code Locator} interface based on a given StAX {@code Location}.\r\n * @see Locator\r\n * @see Location\r\n */\r\nprivate static class StaxLocator implements Locator {\r\n\r\n    private final Location location;\r\n\r\n    public StaxLocator(Location location) {\r\n        this.location = location;\r\n    }\r\n\r\n    @Override\r\n    public String getPublicId() {\r\n        return this.location.getPublicId();\r\n    }\r\n\r\n    @Override\r\n    public String getSystemId() {\r\n        return this.location.getSystemId();\r\n    }\r\n\r\n    @Override\r\n    public int getLineNumber() {\r\n        return this.location.getLineNumber();\r\n    }\r\n\r\n    @Override\r\n    public int getColumnNumber() {\r\n        return this.location.getColumnNumber();\r\n    }\r\n}",
    "comment": "\n * Abstract base class for SAX {@code XMLReader} implementations that use StAX as a basis.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n * @see #setContentHandler(org.xml.sax.ContentHandler)\n * @see #setDTDHandler(org.xml.sax.DTDHandler)\n * @see #setEntityResolver(org.xml.sax.EntityResolver)\n * @see #setErrorHandler(org.xml.sax.ErrorHandler)\n "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#getFeature(String)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    return switch(name) {\r\n        case NAMESPACES_FEATURE_NAME ->\r\n            this.namespacesFeature;\r\n        case NAMESPACE_PREFIXES_FEATURE_NAME ->\r\n            this.namespacePrefixesFeature;\r\n        case IS_STANDALONE_FEATURE_NAME ->\r\n            {\r\n                if (this.isStandalone != null) {\r\n                    yield this.isStandalone;\r\n                } else {\r\n                    throw new SAXNotSupportedException(\"startDocument() callback not completed yet\");\r\n                }\r\n            }\r\n        default ->\r\n            super.getFeature(name);\r\n    };\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (NAMESPACES_FEATURE_NAME.equals(name)) {\r\n        this.namespacesFeature = value;\r\n    } else if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {\r\n        this.namespacePrefixesFeature = value;\r\n    } else {\r\n        super.setFeature(name, value);\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#setStandalone(boolean)",
    "entityType": "method",
    "code": "protected void setStandalone(boolean standalone) {\r\n    this.isStandalone = standalone;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacesFeature()",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces} is turned on.\r\n */\r\nprotected boolean hasNamespacesFeature() {\r\n    return this.namespacesFeature;\r\n}",
    "comment": "\n\t * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces} is turned on.\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacePrefixesFeature()",
    "entityType": "method",
    "code": "/**\r\n * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces-prefixes} is turned on.\r\n */\r\nprotected boolean hasNamespacePrefixesFeature() {\r\n    return this.namespacePrefixesFeature;\r\n}",
    "comment": "\n\t * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces-prefixes} is turned on.\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#toQualifiedName(QName)",
    "entityType": "method",
    "code": "/**\r\n * Convert a {@code QName} to a qualified name, as used by DOM and SAX.\r\n * The returned string has a format of {@code prefix:localName} if the\r\n * prefix is set, or just {@code localName} if not.\r\n * @param qName the {@code QName}\r\n * @return the qualified name\r\n */\r\nprotected String toQualifiedName(QName qName) {\r\n    String prefix = qName.getPrefix();\r\n    if (!StringUtils.hasLength(prefix)) {\r\n        return qName.getLocalPart();\r\n    } else {\r\n        return prefix + \":\" + qName.getLocalPart();\r\n    }\r\n}",
    "comment": "\n\t * Convert a {@code QName} to a qualified name, as used by DOM and SAX.\n\t * The returned string has a format of {@code prefix:localName} if the\n\t * prefix is set, or just {@code localName} if not.\n\t * @param qName the {@code QName}\n\t * @return the qualified name\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
    "entityType": "method",
    "code": "/**\r\n * Parse the StAX XML reader passed at construction-time.\r\n * <p><b>NOTE:</b>: The given {@code InputSource} is not read, but ignored.\r\n * @param ignored is ignored\r\n * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\r\n */\r\n@Override\r\npublic final void parse(InputSource ignored) throws SAXException {\r\n    parse();\r\n}",
    "comment": "\n\t * Parse the StAX XML reader passed at construction-time.\n\t * <p><b>NOTE:</b>: The given {@code InputSource} is not read, but ignored.\n\t * @param ignored is ignored\n\t * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
    "entityType": "method",
    "code": "/**\r\n * Parse the StAX XML reader passed at construction-time.\r\n * <p><b>NOTE:</b>: The given system identifier is not read, but ignored.\r\n * @param ignored is ignored\r\n * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\r\n */\r\n@Override\r\npublic final void parse(String ignored) throws SAXException {\r\n    parse();\r\n}",
    "comment": "\n\t * Parse the StAX XML reader passed at construction-time.\n\t * <p><b>NOTE:</b>: The given system identifier is not read, but ignored.\n\t * @param ignored is ignored\n\t * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
    "entityType": "method",
    "code": "private void parse() throws SAXException {\r\n    try {\r\n        parseInternal();\r\n    } catch (XMLStreamException ex) {\r\n        Locator locator = null;\r\n        if (ex.getLocation() != null) {\r\n            locator = new StaxLocator(ex.getLocation());\r\n        }\r\n        SAXParseException saxException = new SAXParseException(ex.getMessage(), locator, ex);\r\n        if (getErrorHandler() != null) {\r\n            getErrorHandler().fatalError(saxException);\r\n        } else {\r\n            throw saxException;\r\n        }\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#parseInternal()",
    "entityType": "method",
    "code": "/**\r\n * Template method that parses the StAX reader passed at construction-time.\r\n */\r\nprotected abstract void parseInternal() throws SAXException, XMLStreamException;",
    "comment": "\n\t * Template method that parses the StAX reader passed at construction-time.\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
    "entityType": "method",
    "code": "/**\r\n * Start the prefix mapping for the given prefix.\r\n * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\r\n */\r\nprotected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {\r\n    if (getContentHandler() != null && StringUtils.hasLength(namespace)) {\r\n        if (prefix == null) {\r\n            prefix = \"\";\r\n        }\r\n        if (!namespace.equals(this.namespaces.get(prefix))) {\r\n            getContentHandler().startPrefixMapping(prefix, namespace);\r\n            this.namespaces.put(prefix, namespace);\r\n        }\r\n    }\r\n}",
    "comment": "\n\t * Start the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
    "entityType": "method",
    "code": "/**\r\n * End the prefix mapping for the given prefix.\r\n * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\r\n */\r\nprotected void endPrefixMapping(String prefix) throws SAXException {\r\n    if (getContentHandler() != null && this.namespaces.containsKey(prefix)) {\r\n        getContentHandler().endPrefixMapping(prefix);\r\n        this.namespaces.remove(prefix);\r\n    }\r\n}",
    "comment": "\n\t * End the prefix mapping for the given prefix.\n\t * @see org.xml.sax.ContentHandler#endPrefixMapping(String)\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxLocator",
    "entityType": "class",
    "code": "private final Location location;\npublic StaxLocator(Location location) {\r\n    this.location = location;\r\n}\n@Override\r\npublic String getPublicId() {\r\n    return this.location.getPublicId();\r\n}\n@Override\r\npublic String getSystemId() {\r\n    return this.location.getSystemId();\r\n}\n@Override\r\npublic int getLineNumber() {\r\n    return this.location.getLineNumber();\r\n}\n@Override\r\npublic int getColumnNumber() {\r\n    return this.location.getColumnNumber();\r\n}",
    "comment": "\n\t * Implementation of the {@code Locator} interface based on a given StAX {@code Location}.\n\t * @see Locator\n\t * @see Location\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.StaxLocator#getPublicId()",
    "entityType": "method",
    "code": "@Override\r\npublic String getPublicId() {\r\n    return this.location.getPublicId();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxLocator#getSystemId()",
    "entityType": "method",
    "code": "@Override\r\npublic String getSystemId() {\r\n    return this.location.getSystemId();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxLocator#getLineNumber()",
    "entityType": "method",
    "code": "@Override\r\npublic int getLineNumber() {\r\n    return this.location.getLineNumber();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.StaxLocator#getColumnNumber()",
    "entityType": "method",
    "code": "@Override\r\npublic int getColumnNumber() {\r\n    return this.location.getColumnNumber();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLEventReader",
    "entityType": "class",
    "code": "private boolean closed;\n@Override\r\npublic Object next() {\r\n    try {\r\n        return nextEvent();\r\n    } catch (XMLStreamException ex) {\r\n        throw new NoSuchElementException(ex.getMessage());\r\n    }\r\n}\n@Override\r\npublic void remove() {\r\n    throw new UnsupportedOperationException(\"remove not supported on \" + ClassUtils.getShortName(getClass()));\r\n}\n/**\r\n * This implementation throws an {@code IllegalArgumentException} for any property.\r\n * @throws IllegalArgumentException when called\r\n */\r\n@Override\r\npublic Object getProperty(String name) throws IllegalArgumentException {\r\n    throw new IllegalArgumentException(\"Property not supported: [\" + name + \"]\");\r\n}\n@Override\r\npublic void close() {\r\n    this.closed = true;\r\n}\n/**\r\n * Check if the reader is closed, and throws a {@code XMLStreamException} if so.\r\n * @throws XMLStreamException if the reader is closed\r\n * @see #close()\r\n */\r\nprotected void checkIfClosed() throws XMLStreamException {\r\n    if (this.closed) {\r\n        throw new XMLStreamException(\"XMLEventReader has been closed\");\r\n    }\r\n}",
    "comment": "\n * Abstract base class for {@code XMLEventReader}s.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 5.0\n "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLEventReader#next()",
    "entityType": "method",
    "code": "@Override\r\npublic Object next() {\r\n    try {\r\n        return nextEvent();\r\n    } catch (XMLStreamException ex) {\r\n        throw new NoSuchElementException(ex.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLEventReader#remove()",
    "entityType": "method",
    "code": "@Override\r\npublic void remove() {\r\n    throw new UnsupportedOperationException(\"remove not supported on \" + ClassUtils.getShortName(getClass()));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLEventReader#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws an {@code IllegalArgumentException} for any property.\r\n * @throws IllegalArgumentException when called\r\n */\r\n@Override\r\npublic Object getProperty(String name) throws IllegalArgumentException {\r\n    throw new IllegalArgumentException(\"Property not supported: [\" + name + \"]\");\r\n}",
    "comment": "\n\t * This implementation throws an {@code IllegalArgumentException} for any property.\n\t * @throws IllegalArgumentException when called\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLEventReader#close()",
    "entityType": "method",
    "code": "@Override\r\npublic void close() {\r\n    this.closed = true;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
    "entityType": "method",
    "code": "/**\r\n * Check if the reader is closed, and throws a {@code XMLStreamException} if so.\r\n * @throws XMLStreamException if the reader is closed\r\n * @see #close()\r\n */\r\nprotected void checkIfClosed() throws XMLStreamException {\r\n    if (this.closed) {\r\n        throw new XMLStreamException(\"XMLEventReader has been closed\");\r\n    }\r\n}",
    "comment": "\n\t * Check if the reader is closed, and throws a {@code XMLStreamException} if so.\n\t * @throws XMLStreamException if the reader is closed\n\t * @see #close()\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader",
    "entityType": "class",
    "code": "@Nullable\r\nprivate DTDHandler dtdHandler;\n@Nullable\r\nprivate ContentHandler contentHandler;\n@Nullable\r\nprivate EntityResolver entityResolver;\n@Nullable\r\nprivate ErrorHandler errorHandler;\n@Nullable\r\nprivate LexicalHandler lexicalHandler;\n@Override\r\npublic void setContentHandler(@Nullable ContentHandler contentHandler) {\r\n    this.contentHandler = contentHandler;\r\n}\n@Override\r\n@Nullable\r\npublic ContentHandler getContentHandler() {\r\n    return this.contentHandler;\r\n}\n@Override\r\npublic void setDTDHandler(@Nullable DTDHandler dtdHandler) {\r\n    this.dtdHandler = dtdHandler;\r\n}\n@Override\r\n@Nullable\r\npublic DTDHandler getDTDHandler() {\r\n    return this.dtdHandler;\r\n}\n@Override\r\npublic void setEntityResolver(@Nullable EntityResolver entityResolver) {\r\n    this.entityResolver = entityResolver;\r\n}\n@Override\r\n@Nullable\r\npublic EntityResolver getEntityResolver() {\r\n    return this.entityResolver;\r\n}\n@Override\r\npublic void setErrorHandler(@Nullable ErrorHandler errorHandler) {\r\n    this.errorHandler = errorHandler;\r\n}\n@Override\r\n@Nullable\r\npublic ErrorHandler getErrorHandler() {\r\n    return this.errorHandler;\r\n}\n@Nullable\r\nprotected LexicalHandler getLexicalHandler() {\r\n    return this.lexicalHandler;\r\n}\n/**\r\n * This implementation throws a {@code SAXNotRecognizedException} exception\r\n * for any feature outside the \"http://xml.org/sax/features/\" namespace\r\n * and returns {@code false} for any feature within.\r\n */\r\n@Override\r\npublic boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (name.startsWith(\"http://xml.org/sax/features/\")) {\r\n        return false;\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}\n/**\r\n * This implementation throws a {@code SAXNotRecognizedException} exception\r\n * for any feature outside the \"http://xml.org/sax/features/\" namespace\r\n * and accepts a {@code false} value for any feature within.\r\n */\r\n@Override\r\npublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (name.startsWith(\"http://xml.org/sax/features/\")) {\r\n        if (value) {\r\n            throw new SAXNotSupportedException(name);\r\n        }\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}\n/**\r\n * Throws a {@code SAXNotRecognizedException} exception when the given property does not signify a lexical\r\n * handler. The property name for a lexical handler is {@code http://xml.org/sax/properties/lexical-handler}.\r\n */\r\n@Override\r\n@Nullable\r\npublic Object getProperty(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (\"http://xml.org/sax/properties/lexical-handler\".equals(name)) {\r\n        return this.lexicalHandler;\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}\n/**\r\n * Throws a {@code SAXNotRecognizedException} exception when the given property does not signify a lexical\r\n * handler. The property name for a lexical handler is {@code http://xml.org/sax/properties/lexical-handler}.\r\n */\r\n@Override\r\npublic void setProperty(String name, Object value) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (\"http://xml.org/sax/properties/lexical-handler\".equals(name)) {\r\n        this.lexicalHandler = (LexicalHandler) value;\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}",
    "comment": "\n * Abstract base class for SAX {@code XMLReader} implementations.\n * Contains properties as defined in {@link XMLReader}, and does not recognize any features.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n * @see #setContentHandler(org.xml.sax.ContentHandler)\n * @see #setDTDHandler(org.xml.sax.DTDHandler)\n * @see #setEntityResolver(org.xml.sax.EntityResolver)\n * @see #setErrorHandler(org.xml.sax.ErrorHandler)\n "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#setContentHandler(ContentHandler)",
    "entityType": "method",
    "code": "@Override\r\npublic void setContentHandler(@Nullable ContentHandler contentHandler) {\r\n    this.contentHandler = contentHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getContentHandler()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic ContentHandler getContentHandler() {\r\n    return this.contentHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#setDTDHandler(DTDHandler)",
    "entityType": "method",
    "code": "@Override\r\npublic void setDTDHandler(@Nullable DTDHandler dtdHandler) {\r\n    this.dtdHandler = dtdHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getDTDHandler()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic DTDHandler getDTDHandler() {\r\n    return this.dtdHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#setEntityResolver(EntityResolver)",
    "entityType": "method",
    "code": "@Override\r\npublic void setEntityResolver(@Nullable EntityResolver entityResolver) {\r\n    this.entityResolver = entityResolver;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getEntityResolver()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic EntityResolver getEntityResolver() {\r\n    return this.entityResolver;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#setErrorHandler(ErrorHandler)",
    "entityType": "method",
    "code": "@Override\r\npublic void setErrorHandler(@Nullable ErrorHandler errorHandler) {\r\n    this.errorHandler = errorHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getErrorHandler()",
    "entityType": "method",
    "code": "@Override\r\n@Nullable\r\npublic ErrorHandler getErrorHandler() {\r\n    return this.errorHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getLexicalHandler()",
    "entityType": "method",
    "code": "@Nullable\r\nprotected LexicalHandler getLexicalHandler() {\r\n    return this.lexicalHandler;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getFeature(String)",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws a {@code SAXNotRecognizedException} exception\r\n * for any feature outside the \"http://xml.org/sax/features/\" namespace\r\n * and returns {@code false} for any feature within.\r\n */\r\n@Override\r\npublic boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (name.startsWith(\"http://xml.org/sax/features/\")) {\r\n        return false;\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}",
    "comment": "\n\t * This implementation throws a {@code SAXNotRecognizedException} exception\n\t * for any feature outside the \"http://xml.org/sax/features/\" namespace\n\t * and returns {@code false} for any feature within.\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
    "entityType": "method",
    "code": "/**\r\n * This implementation throws a {@code SAXNotRecognizedException} exception\r\n * for any feature outside the \"http://xml.org/sax/features/\" namespace\r\n * and accepts a {@code false} value for any feature within.\r\n */\r\n@Override\r\npublic void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (name.startsWith(\"http://xml.org/sax/features/\")) {\r\n        if (value) {\r\n            throw new SAXNotSupportedException(name);\r\n        }\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}",
    "comment": "\n\t * This implementation throws a {@code SAXNotRecognizedException} exception\n\t * for any feature outside the \"http://xml.org/sax/features/\" namespace\n\t * and accepts a {@code false} value for any feature within.\n\t "
  },
  {
    "entityId": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
    "entityType": "method",
    "code": "/**\r\n * Throws a {@code SAXNotRecognizedException} exception when the given property does not signify a lexical\r\n * handler. The property name for a lexical handler is {@code http://xml.org/sax/properties/lexical-handler}.\r\n */\r\n@Override\r\n@Nullable\r\npublic Object getProperty(String name) throws SAXNotRecognizedException, SAXNotSupportedException {\r\n    if (\"http://xml.org/sax/properties/lexical-handler\".equals(name)) {\r\n        return this.lexicalHandler;\r\n    } else {\r\n        throw new SAXNotRecognizedException(name);\r\n    }\r\n}",
    "comment": "\n\t * Throws a {@code SAXNotRecognizedException} exception when the given property does not signify a lexical\n\t * handler. The property name for a lexical handler is {@code http://xml.org/sax/properties/lexical-handler}.\n\t "
  }
]