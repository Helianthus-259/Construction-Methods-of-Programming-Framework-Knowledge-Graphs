[
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getMethod(Method)",
    "entityType": "method",
    "code": "public FastMethod getMethod(Method method) {\r\n    return new FastMethod(this, method);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getConstructor(Constructor)",
    "entityType": "method",
    "code": "public FastConstructor getConstructor(Constructor constructor) {\r\n    return new FastConstructor(this, constructor);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getMethod(String,Class[])",
    "entityType": "method",
    "code": "public FastMethod getMethod(String name, Class[] parameterTypes) {\r\n    try {\r\n        return getMethod(type.getMethod(name, parameterTypes));\r\n    } catch (NoSuchMethodException e) {\r\n        throw new NoSuchMethodError(e.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getConstructor(Class[])",
    "entityType": "method",
    "code": "public FastConstructor getConstructor(Class[] parameterTypes) {\r\n    try {\r\n        return getConstructor(type.getConstructor(parameterTypes));\r\n    } catch (NoSuchMethodException e) {\r\n        throw new NoSuchMethodError(e.getMessage());\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getName()",
    "entityType": "method",
    "code": "public String getName() {\r\n    return type.getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getJavaClass()",
    "entityType": "method",
    "code": "public Class getJavaClass() {\r\n    return type;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return type.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return type.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null || !(o instanceof FastClass that)) {\r\n        return false;\r\n    }\r\n    return type.equals(that.type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getIndex(String,Class[])",
    "entityType": "method",
    "code": "/**\r\n * Return the index of the matching method. The index may be used\r\n * later to invoke the method with less overhead. If more than one\r\n * method matches (i.e. they differ by return type only), one is\r\n * chosen arbitrarily.\r\n * @see #invoke(int, Object, Object[])\r\n * @param name the method name\r\n * @param parameterTypes the parameter array\r\n * @return the index, or <code>-1</code> if none is found.\r\n */\r\nabstract public int getIndex(String name, Class[] parameterTypes);",
    "comment": "\n     * Return the index of the matching method. The index may be used\n     * later to invoke the method with less overhead. If more than one\n     * method matches (i.e. they differ by return type only), one is\n     * chosen arbitrarily.\n     * @see #invoke(int, Object, Object[])\n     * @param name the method name\n     * @param parameterTypes the parameter array\n     * @return the index, or <code>-1</code> if none is found.\n     "
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getIndex(Class[])",
    "entityType": "method",
    "code": "/**\r\n * Return the index of the matching constructor. The index may be used\r\n * later to create a new instance with less overhead.\r\n * @see #newInstance(int, Object[])\r\n * @param parameterTypes the parameter array\r\n * @return the constructor index, or <code>-1</code> if none is found.\r\n */\r\nabstract public int getIndex(Class[] parameterTypes);",
    "comment": "\n     * Return the index of the matching constructor. The index may be used\n     * later to create a new instance with less overhead.\n     * @see #newInstance(int, Object[])\n     * @param parameterTypes the parameter array\n     * @return the constructor index, or <code>-1</code> if none is found.\n     "
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#invoke(int,Object,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Invoke the method with the specified index.\r\n * @see getIndex(name, Class[])\r\n * @param index the method index\r\n * @param obj the object the underlying method is invoked from\r\n * @param args the arguments used for the method call\r\n * @throws java.lang.reflect.InvocationTargetException if the underlying method throws an exception\r\n */\r\nabstract public Object invoke(int index, Object obj, Object[] args) throws InvocationTargetException;",
    "comment": "\n     * Invoke the method with the specified index.\n     * @see getIndex(name, Class[])\n     * @param index the method index\n     * @param obj the object the underlying method is invoked from\n     * @param args the arguments used for the method call\n     * @throws java.lang.reflect.InvocationTargetException if the underlying method throws an exception\n     "
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#newInstance(int,Object[])",
    "entityType": "method",
    "code": "/**\r\n * Create a new instance using the specified constructor index and arguments.\r\n * @see getIndex(Class[])\r\n * @param index the constructor index\r\n * @param args the arguments passed to the constructor\r\n * @throws java.lang.reflect.InvocationTargetException if the constructor throws an exception\r\n */\r\nabstract public Object newInstance(int index, Object[] args) throws InvocationTargetException;",
    "comment": "\n     * Create a new instance using the specified constructor index and arguments.\n     * @see getIndex(Class[])\n     * @param index the constructor index\n     * @param args the arguments passed to the constructor\n     * @throws java.lang.reflect.InvocationTargetException if the constructor throws an exception\n     "
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getIndex(Signature)",
    "entityType": "method",
    "code": "abstract public int getIndex(Signature sig);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getMaxIndex()",
    "entityType": "method",
    "code": "/**\r\n * Returns the maximum method index for this class.\r\n */\r\nabstract public int getMaxIndex();",
    "comment": "\n     * Returns the maximum method index for this class.\n     "
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClass#getSignatureWithoutReturnType(String,Class[])",
    "entityType": "method",
    "code": "protected static String getSignatureWithoutReturnType(String name, Class[] parameterTypes) {\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(name);\r\n    sb.append('(');\r\n    for (Class parameterType : parameterTypes) {\r\n        sb.append(Type.getDescriptor(parameterType));\r\n    }\r\n    sb.append(')');\r\n    return sb.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(FastClass.class.getName());\nprivate Class type;\npublic Generator() {\r\n    super(SOURCE);\r\n}\npublic void setType(Class type) {\r\n    this.type = type;\r\n}\npublic FastClass create() {\r\n    setNamePrefix(type.getName());\r\n    return (FastClass) super.create(type.getName());\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return type.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(type);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    new FastClassEmitter(v, getClassName(), type);\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type, new Class[] { Class.class }, new Object[] { this.type });\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setType(Class)",
    "entityType": "method",
    "code": "public void setType(Class type) {\r\n    this.type = type;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#create()",
    "entityType": "method",
    "code": "public FastClass create() {\r\n    setNamePrefix(type.getName());\r\n    return (FastClass) super.create(type.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return type.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws Exception {\r\n    new FastClassEmitter(v, getClassName(), type);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ReflectUtils.newInstance(type, new Class[] { Class.class }, new Object[] { this.type });\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return instance;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClassEmitter",
    "entityType": "class",
    "code": "private static final Signature CSTRUCT_CLASS = TypeUtils.parseConstructor(\"Class\");\nprivate static final Signature METHOD_GET_INDEX = TypeUtils.parseSignature(\"int getIndex(String, Class[])\");\nprivate static final Signature SIGNATURE_GET_INDEX = new Signature(\"getIndex\", Type.INT_TYPE, new Type[] { Constants.TYPE_SIGNATURE });\nprivate static final Signature TO_STRING = TypeUtils.parseSignature(\"String toString()\");\nprivate static final Signature CONSTRUCTOR_GET_INDEX = TypeUtils.parseSignature(\"int getIndex(Class[])\");\nprivate static final Signature INVOKE = TypeUtils.parseSignature(\"Object invoke(int, Object, Object[])\");\nprivate static final Signature NEW_INSTANCE = TypeUtils.parseSignature(\"Object newInstance(int, Object[])\");\nprivate static final Signature GET_MAX_INDEX = TypeUtils.parseSignature(\"int getMaxIndex()\");\nprivate static final Signature GET_SIGNATURE_WITHOUT_RETURN_TYPE = TypeUtils.parseSignature(\"String getSignatureWithoutReturnType(String, Class[])\");\nprivate static final Type FAST_CLASS = TypeUtils.parseType(\"org.springframework.cglib.reflect.FastClass\");\nprivate static final Type ILLEGAL_ARGUMENT_EXCEPTION = TypeUtils.parseType(\"IllegalArgumentException\");\nprivate static final Type INVOCATION_TARGET_EXCEPTION = TypeUtils.parseType(\"java.lang.reflect.InvocationTargetException\");\nprivate static final Type[] INVOCATION_TARGET_EXCEPTION_ARRAY = { INVOCATION_TARGET_EXCEPTION };\npublic FastClassEmitter(ClassVisitor v, String className, Class type) {\r\n    super(v);\r\n    Type base = Type.getType(type);\r\n    begin_class(Constants.V1_8, Constants.ACC_PUBLIC, className, FAST_CLASS, null, Constants.SOURCE_FILE);\r\n    // constructor\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_CLASS, null);\r\n    e.load_this();\r\n    e.load_args();\r\n    e.super_invoke_constructor(CSTRUCT_CLASS);\r\n    e.return_value();\r\n    e.end_method();\r\n    VisibilityPredicate vp = new VisibilityPredicate(type, false);\r\n    List methods = ReflectUtils.addAllMethods(type, new ArrayList());\r\n    CollectionUtils.filter(methods, vp);\r\n    CollectionUtils.filter(methods, new DuplicatesPredicate());\r\n    List constructors = new ArrayList(Arrays.asList(type.getDeclaredConstructors()));\r\n    CollectionUtils.filter(constructors, vp);\r\n    // getIndex(String)\r\n    emitIndexBySignature(methods);\r\n    // getIndex(String, Class[])\r\n    emitIndexByClassArray(methods);\r\n    // getIndex(Class[])\r\n    e = begin_method(Constants.ACC_PUBLIC, CONSTRUCTOR_GET_INDEX, null);\r\n    e.load_args();\r\n    List info = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\r\n    EmitUtils.constructor_switch(e, info, new GetIndexCallback(e, info));\r\n    e.end_method();\r\n    // invoke(int, Object, Object[])\r\n    e = begin_method(Constants.ACC_PUBLIC, INVOKE, INVOCATION_TARGET_EXCEPTION_ARRAY);\r\n    e.load_arg(1);\r\n    e.checkcast(base);\r\n    e.load_arg(0);\r\n    invokeSwitchHelper(e, methods, 2, base);\r\n    e.end_method();\r\n    // newInstance(int, Object[])\r\n    e = begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, INVOCATION_TARGET_EXCEPTION_ARRAY);\r\n    e.new_instance(base);\r\n    e.dup();\r\n    e.load_arg(0);\r\n    invokeSwitchHelper(e, constructors, 1, base);\r\n    e.end_method();\r\n    // getMaxIndex()\r\n    e = begin_method(Constants.ACC_PUBLIC, GET_MAX_INDEX, null);\r\n    e.push(methods.size() - 1);\r\n    e.return_value();\r\n    e.end_method();\r\n    end_class();\r\n}\n// TODO: support constructor indices (\"<init>\")\r\nprivate void emitIndexBySignature(List methods) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SIGNATURE_GET_INDEX, null);\r\n    List signatures = CollectionUtils.transform(methods, obj -> ReflectUtils.getSignature((Method) obj).toString());\r\n    e.load_arg(0);\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n    signatureSwitchHelper(e, signatures);\r\n    e.end_method();\r\n}\n// TODO\r\nprivate static final int TOO_MANY_METHODS = 100;\nprivate void emitIndexByClassArray(List methods) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, METHOD_GET_INDEX, null);\r\n    if (methods.size() > TOO_MANY_METHODS) {\r\n        // hack for big classes\r\n        List signatures = CollectionUtils.transform(methods, obj -> {\r\n            String s = ReflectUtils.getSignature((Method) obj).toString();\r\n            return s.substring(0, s.lastIndexOf(')') + 1);\r\n        });\r\n        e.load_args();\r\n        e.invoke_static(FAST_CLASS, GET_SIGNATURE_WITHOUT_RETURN_TYPE);\r\n        signatureSwitchHelper(e, signatures);\r\n    } else {\r\n        e.load_args();\r\n        List info = CollectionUtils.transform(methods, MethodInfoTransformer.getInstance());\r\n        EmitUtils.method_switch(e, info, new GetIndexCallback(e, info));\r\n    }\r\n    e.end_method();\r\n}\nprivate void signatureSwitchHelper(final CodeEmitter e, final List signatures) {\r\n    ObjectSwitchCallback callback = new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            // TODO: remove linear indexOf\r\n            e.push(signatures.indexOf(key));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.push(-1);\r\n            e.return_value();\r\n        }\r\n    };\r\n    EmitUtils.string_switch(e, (String[]) signatures.toArray(new String[signatures.size()]), Constants.SWITCH_STYLE_HASH, callback);\r\n}\nprivate static void invokeSwitchHelper(final CodeEmitter e, List members, final int arg, final Type base) {\r\n    final List info = CollectionUtils.transform(members, MethodInfoTransformer.getInstance());\r\n    final Label illegalArg = e.make_label();\r\n    Block block = e.begin_block();\r\n    e.process_switch(getIntRange(info.size()), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) {\r\n            MethodInfo method = (MethodInfo) info.get(key);\r\n            Type[] types = method.getSignature().getArgumentTypes();\r\n            for (int i = 0; i < types.length; i++) {\r\n                e.load_arg(arg);\r\n                e.aaload(i);\r\n                e.unbox(types[i]);\r\n            }\r\n            // TODO: change method lookup process so MethodInfo will already reference base\r\n            // instead of superclass when superclass method is inaccessible\r\n            e.invoke(method, base);\r\n            if (!TypeUtils.isConstructor(method)) {\r\n                e.box(method.getSignature().getReturnType());\r\n            }\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.goTo(illegalArg);\r\n        }\r\n    });\r\n    block.end();\r\n    EmitUtils.wrap_throwable(block, INVOCATION_TARGET_EXCEPTION);\r\n    e.mark(illegalArg);\r\n    e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Cannot find matching method/constructor\");\r\n}\nprivate static class GetIndexCallback implements ObjectSwitchCallback {\r\n\r\n    private CodeEmitter e;\r\n\r\n    private Map indexes = new HashMap();\r\n\r\n    public GetIndexCallback(CodeEmitter e, List methods) {\r\n        this.e = e;\r\n        int index = 0;\r\n        for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n            indexes.put(it.next(), index++);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void processCase(Object key, Label end) {\r\n        e.push(((Integer) indexes.get(key)));\r\n        e.return_value();\r\n    }\r\n\r\n    @Override\r\n    public void processDefault() {\r\n        e.push(-1);\r\n        e.return_value();\r\n    }\r\n}\nprivate static int[] getIntRange(int length) {\r\n    int[] range = new int[length];\r\n    for (int i = 0; i < length; i++) {\r\n        range[i] = i;\r\n    }\r\n    return range;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClassEmitter#emitIndexBySignature(List)",
    "entityType": "method",
    "code": "// TODO: support constructor indices (\"<init>\")\r\nprivate void emitIndexBySignature(List methods) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SIGNATURE_GET_INDEX, null);\r\n    List signatures = CollectionUtils.transform(methods, obj -> ReflectUtils.getSignature((Method) obj).toString());\r\n    e.load_arg(0);\r\n    e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\r\n    signatureSwitchHelper(e, signatures);\r\n    e.end_method();\r\n}",
    "comment": " TODO: support constructor indices (\"<init>\")"
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClassEmitter#emitIndexByClassArray(List)",
    "entityType": "method",
    "code": "private void emitIndexByClassArray(List methods) {\r\n    CodeEmitter e = begin_method(Constants.ACC_PUBLIC, METHOD_GET_INDEX, null);\r\n    if (methods.size() > TOO_MANY_METHODS) {\r\n        // hack for big classes\r\n        List signatures = CollectionUtils.transform(methods, obj -> {\r\n            String s = ReflectUtils.getSignature((Method) obj).toString();\r\n            return s.substring(0, s.lastIndexOf(')') + 1);\r\n        });\r\n        e.load_args();\r\n        e.invoke_static(FAST_CLASS, GET_SIGNATURE_WITHOUT_RETURN_TYPE);\r\n        signatureSwitchHelper(e, signatures);\r\n    } else {\r\n        e.load_args();\r\n        List info = CollectionUtils.transform(methods, MethodInfoTransformer.getInstance());\r\n        EmitUtils.method_switch(e, info, new GetIndexCallback(e, info));\r\n    }\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClassEmitter#signatureSwitchHelper(CodeEmitter,List)",
    "entityType": "method",
    "code": "private void signatureSwitchHelper(final CodeEmitter e, final List signatures) {\r\n    ObjectSwitchCallback callback = new ObjectSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(Object key, Label end) {\r\n            // TODO: remove linear indexOf\r\n            e.push(signatures.indexOf(key));\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.push(-1);\r\n            e.return_value();\r\n        }\r\n    };\r\n    EmitUtils.string_switch(e, (String[]) signatures.toArray(new String[signatures.size()]), Constants.SWITCH_STYLE_HASH, callback);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClassEmitter#invokeSwitchHelper(CodeEmitter,List,int,Type)",
    "entityType": "method",
    "code": "private static void invokeSwitchHelper(final CodeEmitter e, List members, final int arg, final Type base) {\r\n    final List info = CollectionUtils.transform(members, MethodInfoTransformer.getInstance());\r\n    final Label illegalArg = e.make_label();\r\n    Block block = e.begin_block();\r\n    e.process_switch(getIntRange(info.size()), new ProcessSwitchCallback() {\r\n\r\n        @Override\r\n        public void processCase(int key, Label end) {\r\n            MethodInfo method = (MethodInfo) info.get(key);\r\n            Type[] types = method.getSignature().getArgumentTypes();\r\n            for (int i = 0; i < types.length; i++) {\r\n                e.load_arg(arg);\r\n                e.aaload(i);\r\n                e.unbox(types[i]);\r\n            }\r\n            // TODO: change method lookup process so MethodInfo will already reference base\r\n            // instead of superclass when superclass method is inaccessible\r\n            e.invoke(method, base);\r\n            if (!TypeUtils.isConstructor(method)) {\r\n                e.box(method.getSignature().getReturnType());\r\n            }\r\n            e.return_value();\r\n        }\r\n\r\n        @Override\r\n        public void processDefault() {\r\n            e.goTo(illegalArg);\r\n        }\r\n    });\r\n    block.end();\r\n    EmitUtils.wrap_throwable(block, INVOCATION_TARGET_EXCEPTION);\r\n    e.mark(illegalArg);\r\n    e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Cannot find matching method/constructor\");\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastClassEmitter#getIntRange(int)",
    "entityType": "method",
    "code": "private static int[] getIntRange(int length) {\r\n    int[] range = new int[length];\r\n    for (int i = 0; i < length; i++) {\r\n        range[i] = i;\r\n    }\r\n    return range;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.GetIndexCallback",
    "entityType": "class",
    "code": "private CodeEmitter e;\nprivate Map indexes = new HashMap();\npublic GetIndexCallback(CodeEmitter e, List methods) {\r\n    this.e = e;\r\n    int index = 0;\r\n    for (Iterator it = methods.iterator(); it.hasNext(); ) {\r\n        indexes.put(it.next(), index++);\r\n    }\r\n}\n@Override\r\npublic void processCase(Object key, Label end) {\r\n    e.push(((Integer) indexes.get(key)));\r\n    e.return_value();\r\n}\n@Override\r\npublic void processDefault() {\r\n    e.push(-1);\r\n    e.return_value();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.GetIndexCallback#processCase(Object,Label)",
    "entityType": "method",
    "code": "@Override\r\npublic void processCase(Object key, Label end) {\r\n    e.push(((Integer) indexes.get(key)));\r\n    e.return_value();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.GetIndexCallback#processDefault()",
    "entityType": "method",
    "code": "@Override\r\npublic void processDefault() {\r\n    e.push(-1);\r\n    e.return_value();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastConstructor",
    "entityType": "class",
    "code": "FastConstructor(FastClass fc, Constructor constructor) {\r\n    super(fc, constructor, fc.getIndex(constructor.getParameterTypes()));\r\n}\n@Override\r\npublic Class[] getParameterTypes() {\r\n    return ((Constructor) member).getParameterTypes();\r\n}\n@Override\r\npublic Class[] getExceptionTypes() {\r\n    return ((Constructor) member).getExceptionTypes();\r\n}\npublic Object newInstance() throws InvocationTargetException {\r\n    return fc.newInstance(index, null);\r\n}\npublic Object newInstance(Object[] args) throws InvocationTargetException {\r\n    return fc.newInstance(index, args);\r\n}\npublic Constructor getJavaConstructor() {\r\n    return (Constructor) member;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastConstructor#getParameterTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Class[] getParameterTypes() {\r\n    return ((Constructor) member).getParameterTypes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastConstructor#getExceptionTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Class[] getExceptionTypes() {\r\n    return ((Constructor) member).getExceptionTypes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastConstructor#newInstance()",
    "entityType": "method",
    "code": "public Object newInstance() throws InvocationTargetException {\r\n    return fc.newInstance(index, null);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastConstructor#newInstance(Object[])",
    "entityType": "method",
    "code": "public Object newInstance(Object[] args) throws InvocationTargetException {\r\n    return fc.newInstance(index, args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastConstructor#getJavaConstructor()",
    "entityType": "method",
    "code": "public Constructor getJavaConstructor() {\r\n    return (Constructor) member;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember",
    "entityType": "class",
    "code": "protected FastClass fc;\nprotected Member member;\nprotected int index;\nprotected FastMember(FastClass fc, Member member, int index) {\r\n    this.fc = fc;\r\n    this.member = member;\r\n    this.index = index;\r\n}\nabstract public Class[] getParameterTypes();\nabstract public Class[] getExceptionTypes();\npublic int getIndex() {\r\n    return index;\r\n}\npublic String getName() {\r\n    return member.getName();\r\n}\npublic Class getDeclaringClass() {\r\n    return fc.getJavaClass();\r\n}\npublic int getModifiers() {\r\n    return member.getModifiers();\r\n}\n@Override\r\npublic String toString() {\r\n    return member.toString();\r\n}\n@Override\r\npublic int hashCode() {\r\n    return member.hashCode();\r\n}\n@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null || !(o instanceof FastMember other)) {\r\n        return false;\r\n    }\r\n    return member.equals(other.member);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#getParameterTypes()",
    "entityType": "method",
    "code": "abstract public Class[] getParameterTypes();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#getExceptionTypes()",
    "entityType": "method",
    "code": "abstract public Class[] getExceptionTypes();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#getIndex()",
    "entityType": "method",
    "code": "public int getIndex() {\r\n    return index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#getName()",
    "entityType": "method",
    "code": "public String getName() {\r\n    return member.getName();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#getDeclaringClass()",
    "entityType": "method",
    "code": "public Class getDeclaringClass() {\r\n    return fc.getJavaClass();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#getModifiers()",
    "entityType": "method",
    "code": "public int getModifiers() {\r\n    return member.getModifiers();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#toString()",
    "entityType": "method",
    "code": "@Override\r\npublic String toString() {\r\n    return member.toString();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return member.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMember#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null || !(o instanceof FastMember other)) {\r\n        return false;\r\n    }\r\n    return member.equals(other.member);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod",
    "entityType": "class",
    "code": "FastMethod(FastClass fc, Method method) {\r\n    super(fc, method, helper(fc, method));\r\n}\nprivate static int helper(FastClass fc, Method method) {\r\n    int index = fc.getIndex(new Signature(method.getName(), Type.getMethodDescriptor(method)));\r\n    if (index < 0) {\r\n        Class[] types = method.getParameterTypes();\r\n        System.err.println(\"hash=\" + method.getName().hashCode() + \" size=\" + types.length);\r\n        for (int i = 0; i < types.length; i++) {\r\n            System.err.println(\"  types[\" + i + \"]=\" + types[i].getName());\r\n        }\r\n        throw new IllegalArgumentException(\"Cannot find method \" + method);\r\n    }\r\n    return index;\r\n}\npublic Class getReturnType() {\r\n    return ((Method) member).getReturnType();\r\n}\n@Override\r\npublic Class[] getParameterTypes() {\r\n    return ((Method) member).getParameterTypes();\r\n}\n@Override\r\npublic Class[] getExceptionTypes() {\r\n    return ((Method) member).getExceptionTypes();\r\n}\npublic Object invoke(Object obj, Object[] args) throws InvocationTargetException {\r\n    return fc.invoke(index, obj, args);\r\n}\npublic Method getJavaMethod() {\r\n    return (Method) member;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod#helper(FastClass,Method)",
    "entityType": "method",
    "code": "private static int helper(FastClass fc, Method method) {\r\n    int index = fc.getIndex(new Signature(method.getName(), Type.getMethodDescriptor(method)));\r\n    if (index < 0) {\r\n        Class[] types = method.getParameterTypes();\r\n        System.err.println(\"hash=\" + method.getName().hashCode() + \" size=\" + types.length);\r\n        for (int i = 0; i < types.length; i++) {\r\n            System.err.println(\"  types[\" + i + \"]=\" + types[i].getName());\r\n        }\r\n        throw new IllegalArgumentException(\"Cannot find method \" + method);\r\n    }\r\n    return index;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod#getReturnType()",
    "entityType": "method",
    "code": "public Class getReturnType() {\r\n    return ((Method) member).getReturnType();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod#getParameterTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Class[] getParameterTypes() {\r\n    return ((Method) member).getParameterTypes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod#getExceptionTypes()",
    "entityType": "method",
    "code": "@Override\r\npublic Class[] getExceptionTypes() {\r\n    return ((Method) member).getExceptionTypes();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod#invoke(Object,Object[])",
    "entityType": "method",
    "code": "public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\r\n    return fc.invoke(index, obj, args);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.FastMethod#getJavaMethod()",
    "entityType": "method",
    "code": "public Method getJavaMethod() {\r\n    return (Method) member;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate",
    "entityType": "class",
    "code": "private static final MethodDelegateKey KEY_FACTORY = (MethodDelegateKey) KeyFactory.create(MethodDelegateKey.class, KeyFactory.CLASS_BY_NAME);\nprotected Object target;\nprotected String eqMethod;\ninterface MethodDelegateKey {\r\n\r\n    Object newInstance(Class delegateClass, String methodName, Class iface);\r\n}\npublic static MethodDelegate createStatic(Class targetClass, String methodName, Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setTargetClass(targetClass);\r\n    gen.setMethodName(methodName);\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}\npublic static MethodDelegate create(Object target, String methodName, Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setTarget(target);\r\n    gen.setMethodName(methodName);\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}\n@Override\r\npublic boolean equals(Object obj) {\r\n    MethodDelegate other = (MethodDelegate) obj;\r\n    return (other != null && target == other.target) && eqMethod.equals(other.eqMethod);\r\n}\n@Override\r\npublic int hashCode() {\r\n    return target.hashCode() ^ eqMethod.hashCode();\r\n}\npublic Object getTarget() {\r\n    return target;\r\n}\nabstract public MethodDelegate newInstance(Object target);\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(MethodDelegate.class.getName());\r\n\r\n    private static final Type METHOD_DELEGATE = TypeUtils.parseType(\"org.springframework.cglib.reflect.MethodDelegate\");\r\n\r\n    private static final Signature NEW_INSTANCE = new Signature(\"newInstance\", METHOD_DELEGATE, new Type[] { Constants.TYPE_OBJECT });\r\n\r\n    private Object target;\r\n\r\n    private Class targetClass;\r\n\r\n    private String methodName;\r\n\r\n    private Class iface;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    public void setTarget(Object target) {\r\n        this.target = target;\r\n        this.targetClass = target.getClass();\r\n    }\r\n\r\n    public void setTargetClass(Class targetClass) {\r\n        this.targetClass = targetClass;\r\n    }\r\n\r\n    public void setMethodName(String methodName) {\r\n        this.methodName = methodName;\r\n    }\r\n\r\n    public void setInterface(Class iface) {\r\n        this.iface = iface;\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return targetClass.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(targetClass);\r\n    }\r\n\r\n    public MethodDelegate create() {\r\n        setNamePrefix(targetClass.getName());\r\n        Object key = KEY_FACTORY.newInstance(targetClass, methodName, iface);\r\n        return (MethodDelegate) super.create(key);\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        return ((MethodDelegate) ReflectUtils.newInstance(type)).newInstance(target);\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return ((MethodDelegate) instance).newInstance(target);\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor v) throws NoSuchMethodException {\r\n        Method proxy = ReflectUtils.findInterfaceMethod(iface);\r\n        final Method method = targetClass.getMethod(methodName, proxy.getParameterTypes());\r\n        if (!proxy.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n            throw new IllegalArgumentException(\"incompatible return types\");\r\n        }\r\n        MethodInfo methodInfo = ReflectUtils.getMethodInfo(method);\r\n        boolean isStatic = TypeUtils.isStatic(methodInfo.getModifiers());\r\n        if ((target == null) ^ isStatic) {\r\n            throw new IllegalArgumentException(\"Static method \" + (isStatic ? \"not \" : \"\") + \"expected\");\r\n        }\r\n        ClassEmitter ce = new ClassEmitter(v);\r\n        CodeEmitter e;\r\n        ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), METHOD_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n        ce.declare_field(Constants.PRIVATE_FINAL_STATIC, \"eqMethod\", Constants.TYPE_STRING, null);\r\n        EmitUtils.null_constructor(ce);\r\n        // generate proxied method\r\n        MethodInfo proxied = ReflectUtils.getMethodInfo(iface.getDeclaredMethods()[0]);\r\n        int modifiers = Constants.ACC_PUBLIC;\r\n        if ((proxied.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n            modifiers |= Constants.ACC_VARARGS;\r\n        }\r\n        e = EmitUtils.begin_method(ce, proxied, modifiers);\r\n        e.load_this();\r\n        e.super_getfield(\"target\", Constants.TYPE_OBJECT);\r\n        e.checkcast(methodInfo.getClassInfo().getType());\r\n        e.load_args();\r\n        e.invoke(methodInfo);\r\n        e.return_value();\r\n        e.end_method();\r\n        // newInstance\r\n        e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n        e.new_instance_this();\r\n        e.dup();\r\n        e.dup2();\r\n        e.invoke_constructor_this();\r\n        e.getfield(\"eqMethod\");\r\n        e.super_putfield(\"eqMethod\", Constants.TYPE_STRING);\r\n        e.load_arg(0);\r\n        e.super_putfield(\"target\", Constants.TYPE_OBJECT);\r\n        e.return_value();\r\n        e.end_method();\r\n        // static initializer\r\n        e = ce.begin_static();\r\n        e.push(methodInfo.getSignature().toString());\r\n        e.putfield(\"eqMethod\");\r\n        e.return_value();\r\n        e.end_method();\r\n        ce.end_class();\r\n    }\r\n}",
    "comment": "\n * <b>DOCUMENTATION FROM APACHE AVALON DELEGATE CLASS</b>\n *\n * <p>\n * Delegates are a typesafe pointer to another method.  Since Java does not\n * have language support for such a construct, this utility will construct\n * a proxy that forwards method calls to any method with the same signature.\n * This utility is inspired in part by the C# delegate mechanism.  We\n * implemented it in a Java-centric manner.\n * </p>\n *\n * <h2>Delegate</h2>\n * <p>\n *   Any interface with one method can become the interface for a delegate.\n *   Consider the example below:\n * </p>\n *\n * <pre>\n *   public interface MainDelegate {\n *       int main(String[] args);\n *   }\n * </pre>\n *\n * <p>\n *   The interface above is an example of an interface that can become a\n *   delegate.  It has only one method, and the interface is public.  In\n *   order to create a delegate for that method, all we have to do is\n *   call <code>MethodDelegate.create(this, \"alternateMain\", MainDelegate.class)</code>.\n *   The following program will show how to use it:\n * </p>\n *\n * <pre>\n *   public class Main {\n *       public static int main( String[] args ) {\n *           Main newMain = new Main();\n *           MainDelegate start = (MainDelegate)\n *               MethodDelegate.create(newMain, \"alternateMain\", MainDelegate.class);\n *           return start.main( args );\n *       }\n *\n *       public int alternateMain( String[] args ) {\n *           for (int i = 0; i &lt; args.length; i++) {\n *               System.out.println( args[i] );\n *           }\n *           return args.length;\n *       }\n *   }\n * </pre>\n *\n * <p>\n *   By themselves, delegates don't do much.  Their true power lies in the fact that\n *   they can be treated like objects, and passed to other methods.  In fact that is\n *   one of the key building blocks of building Intelligent Agents which in tern are\n *   the foundation of artificial intelligence.  In the above program, we could have\n *   easily created the delegate to match the static <code>main</code> method by\n *   substituting the delegate creation call with this:\n *   <code>MethodDelegate.createStatic(getClass(), \"main\", MainDelegate.class)</code>.\n * </p>\n * <p>\n *   Another key use for Delegates is to register event listeners.  It is much easier\n *   to have all the code for your events separated out into methods instead of individual\n *   classes.  One of the ways Java gets around that is to create anonymous classes.\n *   They are particularly troublesome because many Debuggers do not know what to do\n *   with them.  Anonymous classes tend to duplicate alot of code as well.  We can\n *   use any interface with one declared method to forward events to any method that\n *   matches the signature (although the method name can be different).\n * </p>\n *\n * <h3>Equality</h3>\n *  The criteria that we use to test if two delegates are equal are:\n *   <ul>\n *     <li>\n *       They both refer to the same instance.  That is, the <code>instance</code>\n *       parameter passed to the newDelegate method was the same for both. The\n *       instances are compared with the identity equality operator, <code>==</code>.\n *     </li>\n *     <li>They refer to the same method as resolved by <code>Method.equals</code>.</li>\n *   </ul>\n *\n * @version $Id: MethodDelegate.java,v 1.25 2006/03/05 02:43:19 herbyderby Exp $\n "
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate#createStatic(Class,String,Class)",
    "entityType": "method",
    "code": "public static MethodDelegate createStatic(Class targetClass, String methodName, Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setTargetClass(targetClass);\r\n    gen.setMethodName(methodName);\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate#create(Object,String,Class)",
    "entityType": "method",
    "code": "public static MethodDelegate create(Object target, String methodName, Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setTarget(target);\r\n    gen.setMethodName(methodName);\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate#equals(Object)",
    "entityType": "method",
    "code": "@Override\r\npublic boolean equals(Object obj) {\r\n    MethodDelegate other = (MethodDelegate) obj;\r\n    return (other != null && target == other.target) && eqMethod.equals(other.eqMethod);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate#hashCode()",
    "entityType": "method",
    "code": "@Override\r\npublic int hashCode() {\r\n    return target.hashCode() ^ eqMethod.hashCode();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate#getTarget()",
    "entityType": "method",
    "code": "public Object getTarget() {\r\n    return target;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegate#newInstance(Object)",
    "entityType": "method",
    "code": "abstract public MethodDelegate newInstance(Object target);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegateKey",
    "entityType": "class",
    "code": "Object newInstance(Class delegateClass, String methodName, Class iface);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MethodDelegateKey#newInstance(Class,String,Class)",
    "entityType": "method",
    "code": "Object newInstance(Class delegateClass, String methodName, Class iface);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(MethodDelegate.class.getName());\nprivate static final Type METHOD_DELEGATE = TypeUtils.parseType(\"org.springframework.cglib.reflect.MethodDelegate\");\nprivate static final Signature NEW_INSTANCE = new Signature(\"newInstance\", METHOD_DELEGATE, new Type[] { Constants.TYPE_OBJECT });\nprivate Object target;\nprivate Class targetClass;\nprivate String methodName;\nprivate Class iface;\npublic Generator() {\r\n    super(SOURCE);\r\n}\npublic void setTarget(Object target) {\r\n    this.target = target;\r\n    this.targetClass = target.getClass();\r\n}\npublic void setTargetClass(Class targetClass) {\r\n    this.targetClass = targetClass;\r\n}\npublic void setMethodName(String methodName) {\r\n    this.methodName = methodName;\r\n}\npublic void setInterface(Class iface) {\r\n    this.iface = iface;\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return targetClass.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(targetClass);\r\n}\npublic MethodDelegate create() {\r\n    setNamePrefix(targetClass.getName());\r\n    Object key = KEY_FACTORY.newInstance(targetClass, methodName, iface);\r\n    return (MethodDelegate) super.create(key);\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((MethodDelegate) ReflectUtils.newInstance(type)).newInstance(target);\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((MethodDelegate) instance).newInstance(target);\r\n}\n@Override\r\npublic void generateClass(ClassVisitor v) throws NoSuchMethodException {\r\n    Method proxy = ReflectUtils.findInterfaceMethod(iface);\r\n    final Method method = targetClass.getMethod(methodName, proxy.getParameterTypes());\r\n    if (!proxy.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n        throw new IllegalArgumentException(\"incompatible return types\");\r\n    }\r\n    MethodInfo methodInfo = ReflectUtils.getMethodInfo(method);\r\n    boolean isStatic = TypeUtils.isStatic(methodInfo.getModifiers());\r\n    if ((target == null) ^ isStatic) {\r\n        throw new IllegalArgumentException(\"Static method \" + (isStatic ? \"not \" : \"\") + \"expected\");\r\n    }\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    CodeEmitter e;\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), METHOD_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n    ce.declare_field(Constants.PRIVATE_FINAL_STATIC, \"eqMethod\", Constants.TYPE_STRING, null);\r\n    EmitUtils.null_constructor(ce);\r\n    // generate proxied method\r\n    MethodInfo proxied = ReflectUtils.getMethodInfo(iface.getDeclaredMethods()[0]);\r\n    int modifiers = Constants.ACC_PUBLIC;\r\n    if ((proxied.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n        modifiers |= Constants.ACC_VARARGS;\r\n    }\r\n    e = EmitUtils.begin_method(ce, proxied, modifiers);\r\n    e.load_this();\r\n    e.super_getfield(\"target\", Constants.TYPE_OBJECT);\r\n    e.checkcast(methodInfo.getClassInfo().getType());\r\n    e.load_args();\r\n    e.invoke(methodInfo);\r\n    e.return_value();\r\n    e.end_method();\r\n    // newInstance\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n    e.new_instance_this();\r\n    e.dup();\r\n    e.dup2();\r\n    e.invoke_constructor_this();\r\n    e.getfield(\"eqMethod\");\r\n    e.super_putfield(\"eqMethod\", Constants.TYPE_STRING);\r\n    e.load_arg(0);\r\n    e.super_putfield(\"target\", Constants.TYPE_OBJECT);\r\n    e.return_value();\r\n    e.end_method();\r\n    // static initializer\r\n    e = ce.begin_static();\r\n    e.push(methodInfo.getSignature().toString());\r\n    e.putfield(\"eqMethod\");\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setTarget(Object)",
    "entityType": "method",
    "code": "public void setTarget(Object target) {\r\n    this.target = target;\r\n    this.targetClass = target.getClass();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setTargetClass(Class)",
    "entityType": "method",
    "code": "public void setTargetClass(Class targetClass) {\r\n    this.targetClass = targetClass;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setMethodName(String)",
    "entityType": "method",
    "code": "public void setMethodName(String methodName) {\r\n    this.methodName = methodName;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setInterface(Class)",
    "entityType": "method",
    "code": "public void setInterface(Class iface) {\r\n    this.iface = iface;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return targetClass.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(targetClass);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#create()",
    "entityType": "method",
    "code": "public MethodDelegate create() {\r\n    setNamePrefix(targetClass.getName());\r\n    Object key = KEY_FACTORY.newInstance(targetClass, methodName, iface);\r\n    return (MethodDelegate) super.create(key);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    return ((MethodDelegate) ReflectUtils.newInstance(type)).newInstance(target);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((MethodDelegate) instance).newInstance(target);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor v) throws NoSuchMethodException {\r\n    Method proxy = ReflectUtils.findInterfaceMethod(iface);\r\n    final Method method = targetClass.getMethod(methodName, proxy.getParameterTypes());\r\n    if (!proxy.getReturnType().isAssignableFrom(method.getReturnType())) {\r\n        throw new IllegalArgumentException(\"incompatible return types\");\r\n    }\r\n    MethodInfo methodInfo = ReflectUtils.getMethodInfo(method);\r\n    boolean isStatic = TypeUtils.isStatic(methodInfo.getModifiers());\r\n    if ((target == null) ^ isStatic) {\r\n        throw new IllegalArgumentException(\"Static method \" + (isStatic ? \"not \" : \"\") + \"expected\");\r\n    }\r\n    ClassEmitter ce = new ClassEmitter(v);\r\n    CodeEmitter e;\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), METHOD_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n    ce.declare_field(Constants.PRIVATE_FINAL_STATIC, \"eqMethod\", Constants.TYPE_STRING, null);\r\n    EmitUtils.null_constructor(ce);\r\n    // generate proxied method\r\n    MethodInfo proxied = ReflectUtils.getMethodInfo(iface.getDeclaredMethods()[0]);\r\n    int modifiers = Constants.ACC_PUBLIC;\r\n    if ((proxied.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n        modifiers |= Constants.ACC_VARARGS;\r\n    }\r\n    e = EmitUtils.begin_method(ce, proxied, modifiers);\r\n    e.load_this();\r\n    e.super_getfield(\"target\", Constants.TYPE_OBJECT);\r\n    e.checkcast(methodInfo.getClassInfo().getType());\r\n    e.load_args();\r\n    e.invoke(methodInfo);\r\n    e.return_value();\r\n    e.end_method();\r\n    // newInstance\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n    e.new_instance_this();\r\n    e.dup();\r\n    e.dup2();\r\n    e.invoke_constructor_this();\r\n    e.getfield(\"eqMethod\");\r\n    e.super_putfield(\"eqMethod\", Constants.TYPE_STRING);\r\n    e.load_arg(0);\r\n    e.super_putfield(\"target\", Constants.TYPE_OBJECT);\r\n    e.return_value();\r\n    e.end_method();\r\n    // static initializer\r\n    e = ce.begin_static();\r\n    e.push(methodInfo.getSignature().toString());\r\n    e.putfield(\"eqMethod\");\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate",
    "entityType": "class",
    "code": "protected Object[] targets = {};\nprotected MulticastDelegate() {\r\n}\npublic List getTargets() {\r\n    return new ArrayList(Arrays.asList(targets));\r\n}\nabstract public MulticastDelegate add(Object target);\nprotected MulticastDelegate addHelper(Object target) {\r\n    MulticastDelegate copy = newInstance();\r\n    copy.targets = new Object[targets.length + 1];\r\n    System.arraycopy(targets, 0, copy.targets, 0, targets.length);\r\n    copy.targets[targets.length] = target;\r\n    return copy;\r\n}\npublic MulticastDelegate remove(Object target) {\r\n    for (int i = targets.length - 1; i >= 0; i--) {\r\n        if (targets[i].equals(target)) {\r\n            MulticastDelegate copy = newInstance();\r\n            copy.targets = new Object[targets.length - 1];\r\n            System.arraycopy(targets, 0, copy.targets, 0, i);\r\n            System.arraycopy(targets, i + 1, copy.targets, i, targets.length - i - 1);\r\n            return copy;\r\n        }\r\n    }\r\n    return this;\r\n}\nabstract public MulticastDelegate newInstance();\npublic static MulticastDelegate create(Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}\npublic static class Generator extends AbstractClassGenerator {\r\n\r\n    private static final Source SOURCE = new Source(MulticastDelegate.class.getName());\r\n\r\n    private static final Type MULTICAST_DELEGATE = TypeUtils.parseType(\"org.springframework.cglib.reflect.MulticastDelegate\");\r\n\r\n    private static final Signature NEW_INSTANCE = new Signature(\"newInstance\", MULTICAST_DELEGATE, new Type[0]);\r\n\r\n    private static final Signature ADD_DELEGATE = new Signature(\"add\", MULTICAST_DELEGATE, new Type[] { Constants.TYPE_OBJECT });\r\n\r\n    private static final Signature ADD_HELPER = new Signature(\"addHelper\", MULTICAST_DELEGATE, new Type[] { Constants.TYPE_OBJECT });\r\n\r\n    private Class iface;\r\n\r\n    public Generator() {\r\n        super(SOURCE);\r\n    }\r\n\r\n    @Override\r\n    protected ClassLoader getDefaultClassLoader() {\r\n        return iface.getClassLoader();\r\n    }\r\n\r\n    @Override\r\n    protected ProtectionDomain getProtectionDomain() {\r\n        return ReflectUtils.getProtectionDomain(iface);\r\n    }\r\n\r\n    public void setInterface(Class iface) {\r\n        this.iface = iface;\r\n    }\r\n\r\n    public MulticastDelegate create() {\r\n        setNamePrefix(MulticastDelegate.class.getName());\r\n        return (MulticastDelegate) super.create(iface.getName());\r\n    }\r\n\r\n    @Override\r\n    public void generateClass(ClassVisitor cv) {\r\n        final MethodInfo method = ReflectUtils.getMethodInfo(ReflectUtils.findInterfaceMethod(iface));\r\n        ClassEmitter ce = new ClassEmitter(cv);\r\n        ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), MULTICAST_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n        EmitUtils.null_constructor(ce);\r\n        // generate proxied method\r\n        emitProxy(ce, method);\r\n        // newInstance\r\n        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n        e.new_instance_this();\r\n        e.dup();\r\n        e.invoke_constructor_this();\r\n        e.return_value();\r\n        e.end_method();\r\n        // add\r\n        e = ce.begin_method(Constants.ACC_PUBLIC, ADD_DELEGATE, null);\r\n        e.load_this();\r\n        e.load_arg(0);\r\n        e.checkcast(Type.getType(iface));\r\n        e.invoke_virtual_this(ADD_HELPER);\r\n        e.return_value();\r\n        e.end_method();\r\n        ce.end_class();\r\n    }\r\n\r\n    private void emitProxy(ClassEmitter ce, final MethodInfo method) {\r\n        int modifiers = Constants.ACC_PUBLIC;\r\n        if ((method.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n            modifiers |= Constants.ACC_VARARGS;\r\n        }\r\n        final CodeEmitter e = EmitUtils.begin_method(ce, method, modifiers);\r\n        Type returnType = method.getSignature().getReturnType();\r\n        final boolean returns = returnType != Type.VOID_TYPE;\r\n        Local result = null;\r\n        if (returns) {\r\n            result = e.make_local(returnType);\r\n            e.zero_or_null(returnType);\r\n            e.store_local(result);\r\n        }\r\n        e.load_this();\r\n        e.super_getfield(\"targets\", Constants.TYPE_OBJECT_ARRAY);\r\n        final Local result2 = result;\r\n        EmitUtils.process_array(e, Constants.TYPE_OBJECT_ARRAY, type -> {\r\n            e.checkcast(Type.getType(iface));\r\n            e.load_args();\r\n            e.invoke(method);\r\n            if (returns) {\r\n                e.store_local(result2);\r\n            }\r\n        });\r\n        if (returns) {\r\n            e.load_local(result);\r\n        }\r\n        e.return_value();\r\n        e.end_method();\r\n    }\r\n\r\n    @Override\r\n    protected Object firstInstance(Class type) {\r\n        // make a new instance in case first object is used with a long list of targets\r\n        return ((MulticastDelegate) ReflectUtils.newInstance(type)).newInstance();\r\n    }\r\n\r\n    @Override\r\n    protected Object nextInstance(Object instance) {\r\n        return ((MulticastDelegate) instance).newInstance();\r\n    }\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate#getTargets()",
    "entityType": "method",
    "code": "public List getTargets() {\r\n    return new ArrayList(Arrays.asList(targets));\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate#add(Object)",
    "entityType": "method",
    "code": "abstract public MulticastDelegate add(Object target);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate#addHelper(Object)",
    "entityType": "method",
    "code": "protected MulticastDelegate addHelper(Object target) {\r\n    MulticastDelegate copy = newInstance();\r\n    copy.targets = new Object[targets.length + 1];\r\n    System.arraycopy(targets, 0, copy.targets, 0, targets.length);\r\n    copy.targets[targets.length] = target;\r\n    return copy;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate#remove(Object)",
    "entityType": "method",
    "code": "public MulticastDelegate remove(Object target) {\r\n    for (int i = targets.length - 1; i >= 0; i--) {\r\n        if (targets[i].equals(target)) {\r\n            MulticastDelegate copy = newInstance();\r\n            copy.targets = new Object[targets.length - 1];\r\n            System.arraycopy(targets, 0, copy.targets, 0, i);\r\n            System.arraycopy(targets, i + 1, copy.targets, i, targets.length - i - 1);\r\n            return copy;\r\n        }\r\n    }\r\n    return this;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate#newInstance()",
    "entityType": "method",
    "code": "abstract public MulticastDelegate newInstance();",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.MulticastDelegate#create(Class)",
    "entityType": "method",
    "code": "public static MulticastDelegate create(Class iface) {\r\n    Generator gen = new Generator();\r\n    gen.setInterface(iface);\r\n    return gen.create();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator",
    "entityType": "class",
    "code": "private static final Source SOURCE = new Source(MulticastDelegate.class.getName());\nprivate static final Type MULTICAST_DELEGATE = TypeUtils.parseType(\"org.springframework.cglib.reflect.MulticastDelegate\");\nprivate static final Signature NEW_INSTANCE = new Signature(\"newInstance\", MULTICAST_DELEGATE, new Type[0]);\nprivate static final Signature ADD_DELEGATE = new Signature(\"add\", MULTICAST_DELEGATE, new Type[] { Constants.TYPE_OBJECT });\nprivate static final Signature ADD_HELPER = new Signature(\"addHelper\", MULTICAST_DELEGATE, new Type[] { Constants.TYPE_OBJECT });\nprivate Class iface;\npublic Generator() {\r\n    super(SOURCE);\r\n}\n@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return iface.getClassLoader();\r\n}\n@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(iface);\r\n}\npublic void setInterface(Class iface) {\r\n    this.iface = iface;\r\n}\npublic MulticastDelegate create() {\r\n    setNamePrefix(MulticastDelegate.class.getName());\r\n    return (MulticastDelegate) super.create(iface.getName());\r\n}\n@Override\r\npublic void generateClass(ClassVisitor cv) {\r\n    final MethodInfo method = ReflectUtils.getMethodInfo(ReflectUtils.findInterfaceMethod(iface));\r\n    ClassEmitter ce = new ClassEmitter(cv);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), MULTICAST_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(ce);\r\n    // generate proxied method\r\n    emitProxy(ce, method);\r\n    // newInstance\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n    e.new_instance_this();\r\n    e.dup();\r\n    e.invoke_constructor_this();\r\n    e.return_value();\r\n    e.end_method();\r\n    // add\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, ADD_DELEGATE, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.checkcast(Type.getType(iface));\r\n    e.invoke_virtual_this(ADD_HELPER);\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}\nprivate void emitProxy(ClassEmitter ce, final MethodInfo method) {\r\n    int modifiers = Constants.ACC_PUBLIC;\r\n    if ((method.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n        modifiers |= Constants.ACC_VARARGS;\r\n    }\r\n    final CodeEmitter e = EmitUtils.begin_method(ce, method, modifiers);\r\n    Type returnType = method.getSignature().getReturnType();\r\n    final boolean returns = returnType != Type.VOID_TYPE;\r\n    Local result = null;\r\n    if (returns) {\r\n        result = e.make_local(returnType);\r\n        e.zero_or_null(returnType);\r\n        e.store_local(result);\r\n    }\r\n    e.load_this();\r\n    e.super_getfield(\"targets\", Constants.TYPE_OBJECT_ARRAY);\r\n    final Local result2 = result;\r\n    EmitUtils.process_array(e, Constants.TYPE_OBJECT_ARRAY, type -> {\r\n        e.checkcast(Type.getType(iface));\r\n        e.load_args();\r\n        e.invoke(method);\r\n        if (returns) {\r\n            e.store_local(result2);\r\n        }\r\n    });\r\n    if (returns) {\r\n        e.load_local(result);\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}\n@Override\r\nprotected Object firstInstance(Class type) {\r\n    // make a new instance in case first object is used with a long list of targets\r\n    return ((MulticastDelegate) ReflectUtils.newInstance(type)).newInstance();\r\n}\n@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((MulticastDelegate) instance).newInstance();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getDefaultClassLoader()",
    "entityType": "method",
    "code": "@Override\r\nprotected ClassLoader getDefaultClassLoader() {\r\n    return iface.getClassLoader();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#getProtectionDomain()",
    "entityType": "method",
    "code": "@Override\r\nprotected ProtectionDomain getProtectionDomain() {\r\n    return ReflectUtils.getProtectionDomain(iface);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#setInterface(Class)",
    "entityType": "method",
    "code": "public void setInterface(Class iface) {\r\n    this.iface = iface;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#create()",
    "entityType": "method",
    "code": "public MulticastDelegate create() {\r\n    setNamePrefix(MulticastDelegate.class.getName());\r\n    return (MulticastDelegate) super.create(iface.getName());\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#generateClass(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void generateClass(ClassVisitor cv) {\r\n    final MethodInfo method = ReflectUtils.getMethodInfo(ReflectUtils.findInterfaceMethod(iface));\r\n    ClassEmitter ce = new ClassEmitter(cv);\r\n    ce.begin_class(Constants.V1_8, Constants.ACC_PUBLIC, getClassName(), MULTICAST_DELEGATE, new Type[] { Type.getType(iface) }, Constants.SOURCE_FILE);\r\n    EmitUtils.null_constructor(ce);\r\n    // generate proxied method\r\n    emitProxy(ce, method);\r\n    // newInstance\r\n    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\r\n    e.new_instance_this();\r\n    e.dup();\r\n    e.invoke_constructor_this();\r\n    e.return_value();\r\n    e.end_method();\r\n    // add\r\n    e = ce.begin_method(Constants.ACC_PUBLIC, ADD_DELEGATE, null);\r\n    e.load_this();\r\n    e.load_arg(0);\r\n    e.checkcast(Type.getType(iface));\r\n    e.invoke_virtual_this(ADD_HELPER);\r\n    e.return_value();\r\n    e.end_method();\r\n    ce.end_class();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#emitProxy(ClassEmitter,MethodInfo)",
    "entityType": "method",
    "code": "private void emitProxy(ClassEmitter ce, final MethodInfo method) {\r\n    int modifiers = Constants.ACC_PUBLIC;\r\n    if ((method.getModifiers() & Constants.ACC_VARARGS) == Constants.ACC_VARARGS) {\r\n        modifiers |= Constants.ACC_VARARGS;\r\n    }\r\n    final CodeEmitter e = EmitUtils.begin_method(ce, method, modifiers);\r\n    Type returnType = method.getSignature().getReturnType();\r\n    final boolean returns = returnType != Type.VOID_TYPE;\r\n    Local result = null;\r\n    if (returns) {\r\n        result = e.make_local(returnType);\r\n        e.zero_or_null(returnType);\r\n        e.store_local(result);\r\n    }\r\n    e.load_this();\r\n    e.super_getfield(\"targets\", Constants.TYPE_OBJECT_ARRAY);\r\n    final Local result2 = result;\r\n    EmitUtils.process_array(e, Constants.TYPE_OBJECT_ARRAY, type -> {\r\n        e.checkcast(Type.getType(iface));\r\n        e.load_args();\r\n        e.invoke(method);\r\n        if (returns) {\r\n            e.store_local(result2);\r\n        }\r\n    });\r\n    if (returns) {\r\n        e.load_local(result);\r\n    }\r\n    e.return_value();\r\n    e.end_method();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#firstInstance(Class)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object firstInstance(Class type) {\r\n    // make a new instance in case first object is used with a long list of targets\r\n    return ((MulticastDelegate) ReflectUtils.newInstance(type)).newInstance();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.reflect.Generator#nextInstance(Object)",
    "entityType": "method",
    "code": "@Override\r\nprotected Object nextInstance(Object instance) {\r\n    return ((MulticastDelegate) instance).newInstance();\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.SpringCglibInfo",
    "entityType": "class",
    "code": "",
    "comment": "\n * Empty class used to ensure that the {@code org.springframework.cglib}\n * package is processed during javadoc generation.\n *\n * <p>See <a href=\"package-summary.html\">package-level javadocs</a> for more\n * information on {@code org.springframework.cglib}.\n *\n * @author Chris Beams\n * @since 3.2\n "
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer",
    "entityType": "class",
    "code": "private ClassTransformer pass;\nprivate ClassVisitor target;\n@Override\r\npublic void setTarget(ClassVisitor target) {\r\n    super.setTarget(target);\r\n    pass.setTarget(target);\r\n}\nprotected AbstractClassFilterTransformer(ClassTransformer pass) {\r\n    this.pass = pass;\r\n}\nabstract protected boolean accept(int version, int access, String name, String signature, String superName, String[] interfaces);\n@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\r\n    target = accept(version, access, name, signature, superName, interfaces) ? pass : cv;\r\n    target.visit(version, access, name, signature, superName, interfaces);\r\n}\n@Override\r\npublic void visitSource(String source, String debug) {\r\n    target.visitSource(source, debug);\r\n}\n@Override\r\npublic void visitOuterClass(String owner, String name, String desc) {\r\n    target.visitOuterClass(owner, name, desc);\r\n}\n@Override\r\npublic AnnotationVisitor visitAnnotation(String desc, boolean visible) {\r\n    return target.visitAnnotation(desc, visible);\r\n}\n@Override\r\npublic void visitAttribute(Attribute attr) {\r\n    target.visitAttribute(attr);\r\n}\n@Override\r\npublic void visitInnerClass(String name, String outerName, String innerName, int access) {\r\n    target.visitInnerClass(name, outerName, innerName, access);\r\n}\n@Override\r\npublic FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {\r\n    return target.visitField(access, name, desc, signature, value);\r\n}\n@Override\r\npublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\r\n    return target.visitMethod(access, name, desc, signature, exceptions);\r\n}\n@Override\r\npublic void visitEnd() {\r\n    target.visitEnd();\r\n    // just to be safe\r\n    target = null;\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer#setTarget(ClassVisitor)",
    "entityType": "method",
    "code": "@Override\r\npublic void setTarget(ClassVisitor target) {\r\n    super.setTarget(target);\r\n    pass.setTarget(target);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer#accept(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "abstract protected boolean accept(int version, int access, String name, String signature, String superName, String[] interfaces);",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer#visit(int,int,String,String,String,String[])",
    "entityType": "method",
    "code": "@Override\r\npublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\r\n    target = accept(version, access, name, signature, superName, interfaces) ? pass : cv;\r\n    target.visit(version, access, name, signature, superName, interfaces);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer#visitSource(String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitSource(String source, String debug) {\r\n    target.visitSource(source, debug);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer#visitOuterClass(String,String,String)",
    "entityType": "method",
    "code": "@Override\r\npublic void visitOuterClass(String owner, String name, String desc) {\r\n    target.visitOuterClass(owner, name, desc);\r\n}",
    "comment": ""
  },
  {
    "entityId": "org.springframework.cglib.transform.AbstractClassFilterTransformer#visitAnnotation(String,boolean)",
    "entityType": "method",
    "code": "@Override\r\npublic AnnotationVisitor visitAnnotation(String desc, boolean visible) {\r\n    return target.visitAnnotation(desc, visible);\r\n}",
    "comment": ""
  }
]