{
    "relationships": [
        {
            "head": "org.springframework.util.SerializationUtilsTests#cloneException()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "cloneException",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SerializationUtilsTests#cloneException()",
            "head_type": "method",
            "relation": "have",
            "tail": "SerializationUtils.clone(ex)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SerializationUtilsTests#cloneException()",
            "head_type": "method",
            "relation": "have",
            "tail": "IllegalArgumentException ex = new IllegalArgumentException(\"foo\");",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SerializationUtilsTests#cloneException()",
            "head_type": "method",
            "relation": "have",
            "tail": "assertThat(SerializationUtils.clone(ex)).hasMessage(\"foo\").isNotSameAs(ex);",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SerializationUtilsTests#cloneException()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.SerializationUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SerializationUtilsTests#cloneException()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "IllegalArgumentException",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "getFirst",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "add",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "addAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "set",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "setAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "size",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "isEmpty",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "containsKey",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "containsValue",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "get",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "put",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "remove",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "putAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "clear",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "keySet",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "values",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "entrySet",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "forEach",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "SingleToMultiValueMapAdapter",
            "tail_type": "class"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "getFirst",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "add",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "addAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "set",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "setAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "size",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "isEmpty",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "containsKey",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "containsValue",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "get",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "put",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "remove",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "putAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "clear",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "keySet",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "values",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "entrySet",
            "tail_type": "apiFunction"
        },
        {
            "head": "SingleToMultiValueMapAdapter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "forEach",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#setUp()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "setup",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#setUp()",
            "head_type": "method",
            "relation": "have",
            "tail": "setup",
            "tail_type": "useSampleCode"
        },
        {
            "head": "setup",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#setUp()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#setUp()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#setUp()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#getFirst()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "getFirst",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#getFirst()",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#getFirst()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "add elements to the adapter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
            "head_type": "method",
            "relation": "have",
            "tail": "void add() { this.adapter.add(\"corge\", \"grault\"); assertThat(this.adapter.getFirst(\"corge\")).isEqualTo(\"grault\"); assertThat(this.delegate.get(\"corge\")).isEqualTo(\"grault\"); assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.add(\"foo\", \"garply\")); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "SingleToMultiValueMapAdapter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "UnsupportedOperationException",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
            "head_type": "method",
            "relation": "have",
            "tail": "Adding elements to the adapter and verifying their presence, throwing an exception if an unsupported operation is attempted.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#add()",
            "head_type": "method",
            "relation": "have",
            "tail": "Design principle focused on ensuring the adapter correctly handles element addition and exception scenarios.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#addAll()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "adding multiple values to a map",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#addAll()",
            "head_type": "method",
            "relation": "have",
            "tail": "MultiValueMap<String, String> map = new LinkedMultiValueMap<>(); map.add(\"corge\", \"grault\"); this.adapter.addAll(map); assertThat(this.adapter.getFirst(\"corge\")).isEqualTo(\"grault\"); assertThat(this.delegate.get(\"corge\")).isEqualTo(\"grault\"); assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.adapter.addAll(map));",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#addAll()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "MultiValueMap",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#addAll()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "UnsupportedOperationException",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#addAll()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "SingleToMultiValueMapAdapterTests",
            "tail_type": "class"
        },
        {
            "head": "adding multiple values to a map",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "map operations",
            "tail_type": "useScenario"
        },
        {
            "head": "MultiValueMap",
            "head_type": "class",
            "relation": "designPrincipleInterpretation",
            "tail": "A MultiValueMap is a specialized map that allows multiple values to be associated with a single key. It is particularly useful in scenarios where a key-value relationship needs to handle multiple values for the same key, such as storing a list of items associated with a particular category.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "UnsupportedOperationException",
            "head_type": "class",
            "relation": "relatedConceptInterpretation",
            "tail": "The UnsupportedOperationException is thrown to indicate that the requested operation is not supported. This exception is typically used in situations where an operation is not implemented or is intentionally left unsupported, such as in an immutable data structure where modifications are not allowed.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#set()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "mapValueSetting",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#set()",
            "head_type": "method",
            "relation": "have",
            "tail": "mapValueSettingSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "mapValueSettingSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "mapValueSettingSampleCodeContent",
            "tail_type": "codeContent"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#setAll()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "map manipulation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#setAll()",
            "head_type": "method",
            "relation": "have",
            "tail": "map manipulation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "map manipulation sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "map manipulation sample code content",
            "tail_type": "useSampleCodeContent"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#size()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "size determination",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#size()",
            "head_type": "method",
            "relation": "have",
            "tail": "size determination sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "size determination sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "package org.springframework.util;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class SingleToMultiValueMapAdapterTests {\n\n    @Test\n    void size() {\n        assertThat(this.adapter.size()).isEqualTo(this.delegate.size()).isEqualTo(2);\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#isEmpty()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check emptiness of adapter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#isEmpty()",
            "head_type": "method",
            "relation": "have",
            "tail": "Sample code for checking emptiness of adapter",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Sample code for checking emptiness of adapter",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "java\nimport org.junit.jupiter.api.Test;\nimport org.springframework.util.SingleToMultiValueMapAdapter;\nimport java.util.Collections;\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass SingleToMultiValueMapAdapterTests {\n\n    private SingleToMultiValueMapAdapter<String, String> adapter = new SingleToMultiValueMapAdapter<>();\n\n    @Test\n    void isEmpty() {\n        assertThat(this.adapter.isEmpty()).isFalse();\n        this.adapter = new SingleToMultiValueMapAdapter<>(Collections.emptyMap());\n        assertThat(this.adapter.isEmpty()).isTrue();\n    }\n}\n",
            "tail_type": "code"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#isEmpty()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "SingleToMultiValueMapAdapter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#isEmpty()",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for isEmpty()",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "related concept interpretation for isEmpty()",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "The isEmpty() method is used to check if the adapter is empty. It returns true if the adapter does not contain any elements, and false otherwise.",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#isEmpty()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for isEmpty()",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "design principle interpretation for isEmpty()",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "The design principle behind the isEmpty() method is to provide a simple and efficient way to check the emptiness of the adapter, ensuring that the method performs the check in constant time.",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsKey()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check key existence",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsKey()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for checking key existence",
            "tail_type": "useSampleCode"
        },
        {
            "head": "check key existence",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "verify if a key exists in the adapter",
            "tail_type": "useScenario"
        },
        {
            "head": "sample code for checking key existence",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "complete example for using containsKey method",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsKey()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsValue()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "containsValue",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsValue()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#containsValue() sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#get()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "retrieving values from a map",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#get()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "package org.springframework.util;\n\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class SingleToMultiValueMapAdapterTests {\n\n    @Test\n    void get() {\n        assertThat(this.adapter.get(\"foo\")).isEqualTo(List.of(\"bar\"));\n        assertThat(this.adapter.get(\"qux\")).isEqualTo(List.of(\"quux\"));\n        assertThat(this.adapter.get(\"corge\")).isNull();\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "map modification",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "no multiple values for a single key",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "modifying map entries",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "have",
            "tail": "map modification example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "SingleToMultiValueMapAdapter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "have",
            "tail": "map modification concept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#put()",
            "head_type": "method",
            "relation": "have",
            "tail": "map modification design",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#remove()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "remove",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#remove()",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#remove()_useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#remove()_useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#remove()_useSampleCode_content",
            "tail_type": "content"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#putAll()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "add entries to a map",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#putAll()",
            "head_type": "method",
            "relation": "have",
            "tail": "MultiValueMap is used to store multiple values for a single key",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#putAll()",
            "head_type": "method",
            "relation": "have",
            "tail": "Testing the putAll method of SingleToMultiValueMapAdapter",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#putAll()",
            "head_type": "method",
            "relation": "have",
            "tail": "package org.springframework.util;\n\nimport java.util.LinkedHashMap;\nimport java.util.LinkedMultiValueMap;\nimport java.util.Map;\nimport org.junit.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class SingleToMultiValueMapAdapterTests {\n\n    @Test\n    public void putAll() {\n        LinkedMultiValueMap<String, String> map = new LinkedMultiValueMap<>();\n        map.add(\"foo\", \"baz\");\n        map.add(\"qux\", null);\n        map.add(\"grault\", \"garply\");\n        this.adapter.putAll(map);\n        assertThat(this.delegate).containsExactly(Map.entry(\"foo\", \"baz\"), Map.entry(\"qux\", null), Map.entry(\"grault\", \"garply\"));\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#clear()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "clearing contents",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#clear()",
            "head_type": "method",
            "relation": "have",
            "tail": "void clear() { this.adapter.clear(); assertThat(this.adapter).isEmpty(); assertThat(this.delegate).isEmpty(); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#clear()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#keySet()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "keySetRetrieval",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#keySet()",
            "head_type": "method",
            "relation": "have",
            "tail": "keySetRetrievalSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "keySetRetrievalSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#keySet()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "values retrieval",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
            "head_type": "method",
            "relation": "have",
            "tail": "assertion of values",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
            "head_type": "method",
            "relation": "have",
            "tail": "test method example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "test method example",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
            "tail_type": "method"
        },
        {
            "head": "values retrieval",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
            "tail_type": "method"
        },
        {
            "head": "assertion of values",
            "head_type": "useScenario",
            "relation": "applied_to",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#values()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#entrySet()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "entrySet",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#entrySet()",
            "head_type": "method",
            "relation": "have",
            "tail": "entrySet() method test",
            "tail_type": "useSampleCode"
        },
        {
            "head": "entrySet() method test",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#entrySet()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#forEach()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "forEach",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.SingleToMultiValueMapAdapterTests#forEach()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.SingleToMultiValueMapAdapterTests#forEach()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StopWatch",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "StopWatch usage constraints",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "StopWatch usage scenarios",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "have",
            "tail": "StopWatch sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "have",
            "tail": "StopWatch related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "have",
            "tail": "StopWatch design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "StopWatch",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stopWatch",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "lastTaskInfo",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "stopWatch",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "lastTaskInfo",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeGettingTimings()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeStop()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "test StopWatch failure scenario",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeStop()",
            "head_type": "method",
            "relation": "have",
            "tail": "void failureToStartBeforeStop() { assertThatIllegalStateException().isThrownBy(stopWatch::stop); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeStop()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StopWatch",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeStop()",
            "head_type": "method",
            "relation": "have",
            "tail": "This method tests the scenario where stopping a StopWatch before starting it throws an IllegalStateException.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#failureToStartBeforeStop()",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle followed here is to ensure that the StopWatch is in a valid state before performing operations on it.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stopWatch.start()",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stopWatch.isRunning()",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stopWatch.stop()",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "assertThatIllegalStateException().isThrownBy(stopWatch::start)",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#rejectsStartTwice()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StopWatchTests#validUsage()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "StopWatch Testing",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatchTests#validUsage()",
            "head_type": "method",
            "relation": "have",
            "tail": "StopWatch Usage Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "StopWatch Usage Sample Code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Complete StopWatch Usage Example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StopWatchTests#validUsage()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StopWatch",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StopWatch",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "Timing and Task Management",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StopWatch",
            "head_type": "class",
            "relation": "have",
            "tail": "StopWatch Design Principles",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StopWatch Design Principles",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "Principles of StopWatch Design",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StopWatchTests#validUsageDoesNotKeepTaskList()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stopWatchFunctionality",
            "tail_type": "apiFunction"
        },
        {
            "head": "stopWatchFunctionality",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "stopWatchFunctionalitySampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "stopWatchFunctionalitySampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "stopWatchFunctionalitySampleCodeContent",
            "tail_type": "useSampleCodeContent"
        },
        {
            "head": "org.springframework.util.StopWatchTests#validUsageDoesNotKeepTaskList()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StopWatch",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyToByteArray",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyToByteArray",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyToByteArray sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyToString",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyToString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyToString sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyBytes",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyBytes sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyString",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyString sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyStream",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyStream sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyRangeWithinBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyRangeWithinBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeWithinBuffer sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyRangeBeyondBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyRangeBeyondBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeBeyondBuffer sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.copyRangeBeyondAvailable",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copyRangeBeyondAvailable",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeBeyondAvailable sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.nonClosingInputStream",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.nonClosingInputStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.nonClosingInputStream sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "StreamUtils.nonClosingOutputStream",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.nonClosingOutputStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.nonClosingOutputStream sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "StreamUtils.copyToByteArray",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy to byte array scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyToString",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy to string scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyBytes",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy bytes scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyString",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy string scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyStream",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy stream scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyRangeWithinBuffer",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy range within buffer scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyRangeBeyondBuffer",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy range beyond buffer scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.copyRangeBeyondAvailable",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "copy range beyond available scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.nonClosingInputStream",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "non closing input stream scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.nonClosingOutputStream",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "non closing output stream scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "StreamUtils.nonClosingInputStream",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "input stream must be non-null",
            "tail_type": "useConstraint"
        },
        {
            "head": "StreamUtils.nonClosingOutputStream",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "output stream must be non-null",
            "tail_type": "useConstraint"
        },
        {
            "head": "StreamUtils.copyRangeWithinBuffer",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "range must be within buffer limits",
            "tail_type": "useConstraint"
        },
        {
            "head": "StreamUtils.copyRangeBeyondBuffer",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "range must be beyond buffer limits",
            "tail_type": "useConstraint"
        },
        {
            "head": "StreamUtils.copyRangeBeyondAvailable",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "range must be beyond available data",
            "tail_type": "useConstraint"
        },
        {
            "head": "StreamUtils.copyToByteArray",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyToByteArray related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyToString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyToString related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyBytes related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyString related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyStream related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyRangeWithinBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeWithinBuffer related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyRangeBeyondBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeBeyondBuffer related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyRangeBeyondAvailable",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeBeyondAvailable related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.nonClosingInputStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.nonClosingInputStream related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.nonClosingOutputStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.nonClosingOutputStream related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyToByteArray",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyToByteArray design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyToString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyToString design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyBytes design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyString design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyStream design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyRangeWithinBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeWithinBuffer design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyRangeBeyondBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeBeyondBuffer design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.copyRangeBeyondAvailable",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copyRangeBeyondAvailable design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.nonClosingInputStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.nonClosingInputStream design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "StreamUtils.nonClosingOutputStream",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.nonClosingOutputStream design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "setupRandomBytes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "extendString",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "stringLengthConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "initializeStringForTest",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "have",
            "tail": "setupRandomBytesSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "have",
            "tail": "extendStringSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "have",
            "tail": "randomBytesRelatedConcept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "have",
            "tail": "stringLengthDesignPrinciple",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#setup()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "StreamUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyToByteArray()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "copyToByteArray",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyToByteArray()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.StreamUtilsTests#copyToByteArray()",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyToString()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "copyToString",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyToString()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "completeSampleCode",
            "tail_type": "completeSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyBytes()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "copy bytes from an input stream to an output stream",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyBytes()",
            "head_type": "method",
            "relation": "have",
            "tail": "StreamUtils.copy(bytes, out)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "StreamUtils.copy(bytes, out)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.util.StreamUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyBytes()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StreamUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyBytes()",
            "head_type": "method",
            "relation": "have",
            "tail": "Verify that the bytes written to the output stream match the input bytes",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyString()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "StreamUtils.copy",
            "tail_type": "apiFunction"
        },
        {
            "head": "StreamUtils.copy",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StreamUtils.copy(string, charset, out)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "StreamUtils.copy(string, charset, out)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "ByteArrayOutputStream",
            "tail_type": "class"
        },
        {
            "head": "StreamUtils.copy(string, charset, out)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "Charset",
            "tail_type": "class"
        },
        {
            "head": "StreamUtils.copy(string, charset, out)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "string",
            "tail_type": "class"
        },
        {
            "head": "StreamUtils.copy(string, charset, out)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "out",
            "tail_type": "class"
        },
        {
            "head": "StreamUtils.copy",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Copy a string to an output stream.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copy",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Ensure efficient and accurate string copying.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyStream()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Stream Copying",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyStream()",
            "head_type": "method",
            "relation": "have",
            "tail": "Stream Copying Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Stream Copying Sample Code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Complete Example for Stream Copying",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeWithinBuffer()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "copyRangeWithinBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeWithinBuffer()",
            "head_type": "method",
            "relation": "have",
            "tail": "StreamUtils.copyRange() usage example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "StreamUtils.copyRange() usage example",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Copy data within a specified range from an input stream to an output stream.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "StreamUtils.copyRange() usage example",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Ensure efficient data handling by specifying start and end positions.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondBuffer()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "copying a range of data from an input stream to an output stream",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondBuffer()",
            "head_type": "method",
            "relation": "have",
            "tail": "StreamUtils.copyRange(in, out, 0, 8200)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "StreamUtils.copyRange(in, out, 0, 8200)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.util.StreamUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondBuffer()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StreamUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondBuffer()",
            "head_type": "method",
            "relation": "have",
            "tail": "This method tests the functionality of copying a range of data from an input stream to an output stream, ensuring that the data is copied correctly even when the range extends beyond the buffer size.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondBuffer()",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind this method is to ensure robustness and correctness in data copying operations, handling edge cases such as ranges that exceed buffer limits.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "tail": "copyRangeBeyondAvailable",
            "head_type": "method",
            "relation": "haveFunction",
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondAvailable()",
            "tail_type": "apiFunction"
        },
        {
            "tail": "StreamUtils.copyRange",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.util.StreamUtilsTests#copyRangeBeyondAvailable()",
            "tail_type": "useSampleCode"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "Arrays.copyOfRange",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "apiFunction"
        },
        {
            "tail": "StreamUtils",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayOutputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "tail": "ByteArrayInputStream",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange",
            "tail_type": "class"
        },
        {
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "head": "StreamUtils.copyRange"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingInputStream()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "nonClosingInputStream",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingInputStream()",
            "head_type": "method",
            "relation": "have",
            "tail": "nonClosingInputStreamSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "nonClosingInputStreamSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.util.StreamUtilsTests#nonClosingInputStream()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingOutputStream()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "nonClosingOutputStream",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingOutputStream()",
            "head_type": "method",
            "relation": "have",
            "tail": "OutputStream source = mock(); OutputStream nonClosing = StreamUtils.nonClosing(source); nonClosing.write(1); nonClosing.write(bytes); nonClosing.write(bytes, 1, 2); nonClosing.close(); InOrder ordered = inOrder(source); ordered.verify(source).write(1); ordered.verify(source).write(bytes, 0, bytes.length); ordered.verify(source).write(bytes, 1, 2); ordered.verify(source, never()).close();",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingOutputStream()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "OutputStream",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingOutputStream()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "StreamUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StreamUtilsTests#nonClosingOutputStream()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "InOrder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "readStream",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "inputStream cannot be null",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "read the content of an input stream into a byte array",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException { ... }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method reads data from an InputStream and stores it in a ByteArrayOutputStream, handling potential issues with some InputStream implementations.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStream(InputStream,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle is to ensure robustness and efficiency when reading streams, handling edge cases like null inputs and misbehaving streams.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "readStream",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeBufferSize(InputStream)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "computeBufferSize",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeBufferSize(InputStream)",
            "head_type": "method",
            "relation": "have",
            "tail": "InputStream bufferSize computation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "computeBufferSize",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "InputStream bufferSize computation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeBufferSize(InputStream)",
            "head_type": "method",
            "relation": "have",
            "tail": "Ensure buffer size is adequate for input stream",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeBufferSize(InputStream)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design principle for buffer size calculation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "getAccess()",
            "tail_type": "apiFunction"
        },
        {
            "head": "getAccess()",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Returns the class's access flags (see {@link Opcodes}). This value may not reflect Deprecated and Synthetic flags when bytecode is before 1.5 and those flags are represented by attributes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "getAccess()",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "public int getAccess() { return readUnsignedShort(header); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "getAccess()",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "This method is used to retrieve the access flags of a class, which indicate how the class can be accessed (e.g., public, private) and any other modifiers (e.g., abstract, static). The access flags are represented as a bitmask of values from the Opcodes interface.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "Opcodes",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "ClassVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#getClassName()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "get internal class name",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getClassName()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "must follow Type#getInternalName() format",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#getClassName()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class internal name retrieval",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#getClassName()",
            "head_type": "method",
            "relation": "have",
            "tail": "public String getClassName() { return readClass(header + 2, new char[maxStringLength]); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#getClassName()",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is used to retrieve the internal name of the class, which is essential for operations that depend on the class's internal structure.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getClassName()",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind this method is to provide a straightforward and efficient way to access class metadata, which is crucial for various reflective operations and class transformations.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getClassName()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "getSuperClassName",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "mustNotBeObjectClass",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "interfaceSuperClassRetrieval",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "have",
            "tail": "interfaceSuperClassRetrievalSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "have",
            "tail": "classInternalNameExplanation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrinciplesOfClassReader",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Type",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#getSuperName()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#getInterfaces()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "get internal names of implemented interfaces",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getInterfaces()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "return only directly implemented interfaces",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#getInterfaces()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class analysis and inspection",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#getInterfaces()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for getting interfaces",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#getInterfaces()",
            "head_type": "method",
            "relation": "have",
            "tail": "explanation of internal names and interface inheritance",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getInterfaces()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principles behind interface retrieval",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getInterfaces()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassVisitor",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getInterfaces()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit JVMS ClassFile structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "parsing options must be one or more of #SKIP_CODE, #SKIP_DEBUG, #SKIP_FRAMES or #EXPAND_FRAMES",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class parsing",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for visiting a class with options",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for class visiting",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for flexible parsing",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#accept(ClassVisitor,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModuleAttributes(ClassVisitor,Context,int,int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "readModuleAttributes",
            "tail_type": "apiFunction"
        },
        {
            "head": "readModuleAttributes",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "moduleOffset must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "readModuleAttributes",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "parsing module attributes in a class file",
            "tail_type": "useScenario"
        },
        {
            "head": "readModuleAttributes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "complete example for using readModuleAttributes",
            "tail_type": "useSampleCode"
        },
        {
            "head": "readModuleAttributes",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "readModuleAttributes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related concept interpretation for readModuleAttributes",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "readModuleAttributes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle interpretation for readModuleAttributes",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readRecordComponent(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read record component",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readRecordComponent(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class parsing",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readRecordComponent(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit record component",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readRecordComponent(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "RecordComponentVisitor usage",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readRecordComponent(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for reading and visiting record components",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "read record component",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read JVMS field_info structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "field_info structure constraints",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "field parsing scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "field parsing sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for field parsing",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for field parsing",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#readField(ClassVisitor,Context,int)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read JVMS method_info structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "parsing a class",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related to parsing JVMS structures",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readMethod(ClassVisitor,Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle explanation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "read JVMS method_info structure",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visit method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "read JVMS method_info structure",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related to parsing JVMS structures",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "read JVMS method_info structure",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle explanation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "parsing a class",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "visit method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "parsing a class",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "related to parsing JVMS structures",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "parsing a class",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "design principle explanation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visit method",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "related to parsing JVMS structures",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visit method",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "design principle explanation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "related to parsing JVMS structures",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "design principle explanation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "handle bytecode offset",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "concurrency issues related to mutable data",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "MethodVisitor instances can get the bytecode offset of each visited instruction",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses can override this method to store the argument in a mutable field",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Handles the bytecode offset of the next instruction to be visited in accept(ClassVisitor,int)",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "The default implementation of this method does nothing",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#readBytecodeInstructionOffset(int)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "readLabel",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "bytecodeOffset must be within labels array bounds",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "bytecode offset to label mapping",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Returns the label corresponding to the given bytecode offset",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Efficient label management",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "public Label readLabel(final int bytecodeOffset, final Label[] labels) { if (bytecodeOffset >= labels.length) { return new Label(); } if (labels[bytecodeOffset] == null) { labels[bytecodeOffset] = new Label(); } return labels[bytecodeOffset]; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#readLabel(int,Label[])",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "createLabel",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "bytecodeOffset",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "method bytecode offset",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "createLabel sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "createLabel sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#createLabel(int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "createLabel",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#createDebugLabel(int,Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "createDebugLabel",
            "tail_type": "apiFunction"
        },
        {
            "head": "createDebugLabel",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "existing label for the given bytecode offset",
            "tail_type": "useConstraint"
        },
        {
            "head": "createDebugLabel",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "bytecode offset in a method",
            "tail_type": "useScenario"
        },
        {
            "head": "createDebugLabel",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "sample code for createDebugLabel",
            "tail_type": "useSampleCode"
        },
        {
            "head": "createDebugLabel",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related concept interpretation for createDebugLabel",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "createDebugLabel",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle interpretation for createDebugLabel",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "createDebugLabel",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "parse Runtime[In]VisibleTypeAnnotations attribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "Runtime[In]VisibleTypeAnnotations attribute constraints",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "parsing type annotations in a class file",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading type annotations",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "parse Runtime[In]VisibleTypeAnnotations attribute",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related concept interpretation for type annotations parsing",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "parse Runtime[In]VisibleTypeAnnotations attribute",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle interpretation for type annotations parsing",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "getTypeAnnotationBytecodeOffset",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "typeAnnotationOffsets must not be null and typeAnnotationIndex must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "retrieving bytecode offset for type annotations",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for getTypeAnnotationBytecodeOffset",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "head_type": "method",
            "relation": "have",
            "tail": "explanation of type annotations and their offsets",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principles behind efficient bytecode processing",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getTypeAnnotationBytecodeOffset(int[],int)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "parsing JVMS type_annotation structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "extract target_type, target_info, and target_path",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) { ... }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Parses the header of a JVMS type_annotation structure to extract its target_type, target_info and target_path (the result is stored in the given context), and returns the start offset of the rest of the type_annotation structure.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design principle involves parsing and extracting specific data from a type_annotation structure, ensuring efficient data handling and integration within the context of the class being parsed.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readTypeAnnotationTarget(Context,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read Runtime[In]VisibleParameterAnnotations attribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "make visitor visit parameter annotations",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "Runtime[In]VisibleParameterAnnotations attribute constraints",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "parsing class file annotations",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading parameter annotations",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concepts in annotation processing",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principles for annotation reading methods",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readParameterAnnotations(MethodVisitor,Context,int,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Context",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "readElementValues",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "readElementValuesSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "readElementValuesSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "readElementValuesRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValues(AnnotationVisitor,int,boolean,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "readElementValuesDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read JVMS 'element_value' structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "annotationVisitor must not be null",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading element_value structures from class file buffer",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading element_value structures",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for reading element_value structures",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readElementValue(AnnotationVisitor,int,String,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading element_value structures",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "read JVMS 'element_value' structure",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "computing implicit frame",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "method descriptor must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "parsing class methods",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for computing implicit frame",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for implicit frame",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#computeImplicitFrame(Context)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for implicit frame computation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read JVMS 'stack_map_frame' structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "stack_map_frame_offset must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "parsing legacy StackMap attributes",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading stack_map_frame",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for stack_map_frame",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStackMapFrame(int,boolean,boolean,Context)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading stack_map_frame",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readVerificationTypeInfo(int,Object[],int,char[],Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "readVerificationTypeInfo",
            "tail_type": "apiFunction"
        },
        {
            "head": "readVerificationTypeInfo",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "verificationTypeInfoOffsetMustBeValid",
            "tail_type": "useConstraint"
        },
        {
            "head": "readVerificationTypeInfo",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "storingVerificationTypeInfo",
            "tail_type": "useScenario"
        },
        {
            "head": "readVerificationTypeInfo",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "sampleCodeForReadVerificationTypeInfo",
            "tail_type": "useSampleCode"
        },
        {
            "head": "readVerificationTypeInfo",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "verificationTypeInfoStructure",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "readVerificationTypeInfo",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "designPrinciplesOfReadVerificationTypeInfo",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readVerificationTypeInfo(int,Object[],int,char[],Label[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "getFirstAttributeOffset",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
            "head_type": "method",
            "relation": "have",
            "tail": "Returns the offset in the class file buffer of the first ClassFile's 'attributes' array field entry",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
            "head_type": "method",
            "relation": "have",
            "tail": "The method calculates the offset by skipping various fields such as access_flags, this_class, super_class, interfaces_count, and interfaces array. It then reads the fields_count and skips the 'fields' array, including attributes for each field. Similarly, it skips the methods_count and 'methods' fields, and finally skips the ClassFile's attributes_count field to determine the correct offset.",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getFirstAttributeOffset()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "have",
            "tail": "ClassReader is responsible for parsing class files and providing methods to read and interpret various components of the class file structure.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read BootstrapMethods attribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "maxStringLength must be a conservative estimate",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "computing offsets of bootstrap methods",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBootstrapMethodsAttribute(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read non standard JVMS 'attribute' structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "attribute type must match one of the prototypes",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "parsing attributes during class visit",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading an attribute",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for reading attributes",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for attribute reading",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#readAttribute(Attribute[],String,int,int,char[],int,Label[])",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItemCount()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "get number of entries in the class's constant pool table",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItemCount()",
            "head_type": "method",
            "relation": "have",
            "tail": "Returns the number of entries in the class's constant pool table.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getItemCount()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "utility methods for low level parsing",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "have",
            "tail": "Utility methods: low level parsing",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItem(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "get start offset of cp_info structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItem(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItem(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItem(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "get start offset of cp_info structure",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItem(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is intended for Attribute subclasses, and is normally not needed by class generators or adapters.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#getItem(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method returns the start offset of a JVMS 'cp_info' structure in the ClassReader, which is used to read the constant pool entries.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getItem(int)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader#getMaxStringLength()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "getMaxStringLength",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "have",
            "tail": "getMaxStringLength()",
            "tail_type": "method"
        },
        {
            "head": "getMaxStringLength",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Returns a conservative estimate of the maximum length of the strings contained in the class's constant pool table.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader#getMaxStringLength()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "designPrincipleInterpretation",
            "tail": "The design principle of the ClassReader class is to provide a way to read and parse class files.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "have",
            "tail": "The related concept is that the constant pool table contains strings and other constants used by the class.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "have",
            "tail": "public int getMaxStringLength() { return maxStringLength; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read a byte value",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Reads a byte value in this ClassReader",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "public int readByte(final int offset) { return classFileBuffer[offset] & 0xFF; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is intended for Attribute subclasses, and is normally not needed by class generators or adapters",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readByte(int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read several bytes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Reads several bytes in this ClassReader",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is intended for Attribute subclasses, and is normally not needed by class generators or adapters",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "public byte[] readBytes(final int offset, final int length) { byte[] result = new byte[length]; System.arraycopy(classFileBuffer, offset, result, 0, length); return result; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readBytes(int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read unsigned short value",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading unsigned short",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for reading unsigned short",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading unsigned short",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUnsignedShort(int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "read unsigned short value",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read signed short value",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading short value",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for reading short value",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading short value",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readShort(int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read signed int value",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading int value",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for reading int value",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading int value",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readInt(int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read signed long value",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "class generators or adapters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading a signed long value",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "interpretation of related concepts",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readLong(int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Utf8 constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "buffer must be sufficiently large",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading CONSTANT_Utf8 entries in class's constant pool",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading CONSTANT_Utf8 entries",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for CONSTANT_Utf8 entries",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading CONSTANT_Utf8 entries",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUTF8(int,char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Utf8 constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "charBuffer must be sufficiently large",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading CONSTANT_Utf8 entry from class's constant pool table",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading CONSTANT_Utf8 entry",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for CONSTANT_Utf8 entry",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading CONSTANT_Utf8 entry",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read UTF8 string",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "charBuffer must be sufficiently large",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "charBuffer must be sufficiently large. It is not automatically resized.",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Reads an UTF8 string in classFileBuffer",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Efficiently reads UTF8 strings from a byte array, handling variable-length encoding",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readUtf(int,int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {\n    int currentOffset = utfOffset;\n    int endOffset = currentOffset + utfLength;\n    int strLength = 0;\n    byte[] classBuffer = classFileBuffer;\n    while (currentOffset < endOffset) {\n        int currentByte = classBuffer[currentOffset++];\n        if ((currentByte & 0x80) == 0) {\n            charBuffer[strLength++] = (char) (currentByte & 0x7F);\n        } else if ((currentByte & 0xE0) == 0xC0) {\n            charBuffer[strLength++] = (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n        } else {\n            charBuffer[strLength++] = (char) (((currentByte & 0xF) << 12) + ((classBuffer[currentOffset++] & 0x3F) << 6) + (classBuffer[currentOffset++] & 0x3F));\n        }\n    }\n    return new String(charBuffer, 0, strLength);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStringish(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or CONSTANT_Package constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStringish(int[char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses, not needed by class generators or adapters",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStringish(int[char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is intended for Attribute subclasses, and is normally not needed by class generators or adapters",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStringish(int[char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is intended for Attribute subclasses, and is normally not needed by class generators or adapters. It reads specific types of constant pool entries based on the provided offset and character buffer, returning the corresponding string value.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStringish(int[char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "private String readStringish(final int offset, final char[] charBuffer) {\n    // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry\n    // designated by the first two bytes of this cp_info.\n    return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readStringish(int[char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Class constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading CONSTANT_Class entry in constant pool",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading CONSTANT_Class entry",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": " CONSTANT_Class entry in constant pool",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for reading CONSTANT_Class entry",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readClass(int,char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Module constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "intended for Attribute subclasses",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading CONSTANT_Module entry in class's constant pool table",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "public String readModule(final int offset, final char[] charBuffer) { return readStringish(offset, charBuffer); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readModule(int[char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Package constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "buffer must be sufficiently large",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading CONSTANT_Package entry from constant pool",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading CONSTANT_Package entry",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": " CONSTANT_Package is a type of constant pool entry",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for reading constant pool entries efficiently",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readPackage(int[char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read CONSTANT_Dynamic constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "charBuffer must be sufficiently large",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "reading CONSTANT_Dynamic entry from class's constant pool table",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for reading CONSTANT_Dynamic entry",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for CONSTANT_Dynamic",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading CONSTANT_Dynamic",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConstantDynamic(int[char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "read numeric or string constant pool entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "buffer must be sufficiently large",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "Attribute subclasses",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "read numeric or string constant pool entry sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for reading constant pool entries",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int,char[])",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for reading constant pool entries",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ClassReader#readConst(int[char[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ClassReader",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "hasLength",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String) useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForValidValues(String) useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "package org.springframework.util;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class StringUtilsTests {\n\n    @ParameterizedTest\n    @ValueSource(strings = { \"text\", \"  text  \", \"  \", \"\\t\", \"\\n text\" })\n    void hasLengthForValidValues(String value) {\n        assertThat(StringUtils.hasLength(value)).isTrue();\n    }\n}",
            "tail_type": "code"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "hasLength",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "value cannot be null or empty",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "checking if a string has length",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "void hasLengthForInvalidValues(String value) {\n    assertThat(StringUtils.hasLength(value)).isFalse();\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "StringUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasLengthForInvalidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "hasText",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String) useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StringUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String) relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.StringUtilsTests#hasTextForValidValues(String) designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForInvalidValues(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "hasTextForInvalidValues",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#hasTextForInvalidValues(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "hasTextForInvalidValuesSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "hasTextForInvalidValuesSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.util.StringUtilsTests#hasTextForInvalidValues(String) Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#containsWhitespace()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check for whitespace",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#containsWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for checking whitespace",
            "tail_type": "useSampleCode"
        },
        {
            "head": "check for whitespace",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "string manipulation",
            "tail_type": "useScenario"
        },
        {
            "head": "check for whitespace",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "input must be a string",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#containsWhitespace()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StringUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtils",
            "head_type": "class",
            "relation": "designPrincipleInterpretation",
            "tail": "Utility class for string operations",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtils",
            "head_type": "class",
            "relation": "relatedConceptInterpretation",
            "tail": "String manipulation and validation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimWhitespace()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "trimming whitespace",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "removing leading and trailing whitespace from a string",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "use of assertions to verify the output of the trimWhitespace method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimWhitespace()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "StringUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "the method is deprecated and should not be used in new code",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimAllWhitespace()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "trimming whitespace",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimAllWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.util.StringUtilsTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimAllWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimAllWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimAllWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "trimLeadingWhitespace",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(null) is null",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\"\") is empty",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\" \") is empty",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\"\\t\") is empty",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\"\\n\") is empty",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\" \\t\\n\") is empty",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\" a\") == \"a\"",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\"a \") == \"a \"",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\" a \") == \"a \"",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\" a b \") == \"a b \"",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingWhitespace(\" a b  c \") == \"a b  c \"",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingWhitespace()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StringUtils",
            "tail_type": "class"
        },
        {
            "tail": "trimTrailingWhitespace",
            "head_type": "method",
            "relation": "haveFunction",
            "head": "org.springframework.util.StringUtilsTests#trimTrailingWhitespace()",
            "tail_type": "apiFunction"
        },
        {
            "tail": "org.springframework.util.StringUtilsTests",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.util.StringUtilsTests#trimTrailingWhitespace()",
            "tail_type": "class"
        },
        {
            "tail": "org.springframework.util.StringUtilsTests",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "head": "trimTrailingWhitespace",
            "tail_type": "class"
        },
        {
            "tail": "Removes trailing whitespace from a given string",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.util.StringUtilsTests#trimTrailingWhitespace()",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "tail": "Efficiency and readability are considered in the design",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.util.StringUtilsTests#trimTrailingWhitespace()",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "tail": "package org.springframework.util;\n\nimport static org.assertj.core.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StringUtilsTests {\n\n    @Test\n    @SuppressWarnings(\"deprecation\")\n    void trimTrailingWhitespace() {\n        assertThat(StringUtils.trimTrailingWhitespace(null)).isNull();\n        assertThat(StringUtils.trimTrailingWhitespace(\"\")).isEmpty();\n        assertThat(StringUtils.trimTrailingWhitespace(\" \")).isEmpty();\n        assertThat(StringUtils.trimTrailingWhitespace(\"\\t\")).isEmpty();\n        assertThat(StringUtils.trimTrailingWhitespace(\"\\n\")).isEmpty();\n        assertThat(StringUtils.trimTrailingWhitespace(\" \\t\\n\")).isEmpty();\n        assertThat(StringUtils.trimTrailingWhitespace(\"a \")).isEqualTo(\"a\");\n        assertThat(StringUtils.trimTrailingWhitespace(\" a\")).isEqualTo(\" a\");\n        assertThat(StringUtils.trimTrailingWhitespace(\" a \")).isEqualTo(\" a\");\n        assertThat(StringUtils.trimTrailingWhitespace(\" a b \")).isEqualTo(\" a b\");\n        assertThat(StringUtils.trimTrailingWhitespace(\" a b  c \")).isEqualTo(\" a b  c\");\n    }\n}",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.util.StringUtilsTests#trimTrailingWhitespace()",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingCharacter()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "trimLeadingCharacter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimLeadingCharacter()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimLeadingCharacter(null, ' ')",
            "tail_type": "useSampleCode"
        },
        {
            "head": "trimLeadingCharacter",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "null or empty string input",
            "tail_type": "useScenario"
        },
        {
            "head": "trimLeadingCharacter",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "string with leading character to trim",
            "tail_type": "useScenario"
        },
        {
            "head": "trimLeadingCharacter",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "character to trim must be specified",
            "tail_type": "useConstraint"
        },
        {
            "head": "trimLeadingCharacter",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Removes leading character from a string if present",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "trimLeadingCharacter",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Design principle: Simplify string manipulation by providing utility methods",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimTrailingCharacter()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "trimTrailingCharacter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimTrailingCharacter()",
            "head_type": "method",
            "relation": "have",
            "tail": "StringUtils.trimTrailingCharacter(null, ' ')",
            "tail_type": "useSampleCode"
        },
        {
            "head": "trimTrailingCharacter",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "StringUtils.trimTrailingCharacter(null, ' ')",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#trimTrailingCharacter()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "StringUtils",
            "tail_type": "class"
        },
        {
            "head": "trimTrailingCharacter",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "StringUtils",
            "tail_type": "class"
        },
        {
            "head": "StringUtils.trimTrailingCharacter(null, ' ')",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "StringUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#matchesCharacter()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "matchesCharacter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#matchesCharacter()",
            "head_type": "method",
            "relation": "have",
            "tail": "void matchesCharacter() {    assertThat(StringUtils.matchesCharacter(null, '/')).isFalse();    assertThat(StringUtils.matchesCharacter(\"/a\", '/')).isFalse();    assertThat(StringUtils.matchesCharacter(\"a\", '/')).isFalse();    assertThat(StringUtils.matchesCharacter(\"/\", '/')).isTrue();}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.util.StringUtilsTests#matchesCharacter()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.util.StringUtils",
            "tail_type": "class"
        }
    ]
}