{
    "relationships": [
        {
            "head": "org.springframework.asm.MethodWriter#visitInsnAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitInsnAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitInsnAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsnAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitInsnAnnotation sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitInsnAnnotation(int,TypePath,String,boolean) sample code content",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTryCatchBlock",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)_useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)_useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)_useSampleCode_content",
            "tail_type": "content"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTryCatchAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitTryCatchAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitTryCatchAnnotation sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Complete visitTryCatchAnnotation example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLocalVariable(String,String,String,Label,Label,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit local variable",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLocalVariable(String,String,String,Label,Label,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitLocalVariable sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLocalVariable sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitLocalVariable(String,String,String,Label,Label,int) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLocalVariableAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitLocalVariableAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitLocalVariableAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLocalVariableAnnotation sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Complete sample code for visitLocalVariableAnnotation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "relatedConceptInterpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "Detailed explanation of related concepts",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "designPrincipleInterpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "Detailed explanation of design principles",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMaxs(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitMaxs",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMaxs(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitMaxsSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitMaxsSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitMaxsCompleteExample",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "compute stack map frames",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "method must have a valid stack map",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "bytecode manipulation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "head_type": "method",
            "relation": "have",
            "tail": "related to exception handling and control flow",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle of ensuring method stack integrity",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "head_type": "method",
            "relation": "have",
            "tail": "complete sample code for stack map frame computation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "compute stack map frames",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "tail_type": "method"
        },
        {
            "head": "method must have a valid stack map",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "tail_type": "method"
        },
        {
            "head": "bytecode manipulation",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "tail_type": "method"
        },
        {
            "head": "related to exception handling and control flow",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "tail_type": "method"
        },
        {
            "head": "design principle of ensuring method stack integrity",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "tail_type": "method"
        },
        {
            "head": "complete sample code for stack map frame computation",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#computeAllFrames()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMaxStackAndLocal()",
            "head_type": "method",
            "relation": "haveFuntion",
            "tail": "compute maximum stack size",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMaxStackAndLocal()",
            "head_type": "method",
            "relation": "have",
            "tail": "Computes the maximum stack size of the method.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMaxStackAndLocal()",
            "head_type": "method",
            "relation": "have",
            "tail": "private void computeMaxStackAndLocal() {\n    // Complete the control flow graph with exception handler blocks.\n    Handler handler = firstHandler;\n    while (handler != null) {\n        Label handlerBlock = handler.handlerPc;\n        Label handlerRangeBlock = handler.startPc;\n        Label handlerRangeEnd = handler.endPc;\n        // Add handlerBlock as a successor of all the basic blocks in the exception handler range.\n        while (handlerRangeBlock != handlerRangeEnd) {\n            if ((handlerRangeBlock.flags & Label.FLAG_SUBROUTINE_CALLER) == 0) {\n                handlerRangeBlock.outgoingEdges = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);\n            } else {\n                // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing\n                // edges to preserve the hypothesis about JSR block successors order (see\n                // {@link #visitJumpInsn}).\n                handlerRangeBlock.outgoingEdges.nextEdge.nextEdge = new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);\n            }\n            handlerRangeBlock = handlerRangeBlock.nextBasicBlock;\n        }\n        handler = handler.nextHandler;\n    }\n    // Complete the control flow graph with the successor blocks of subroutines, if needed.\n    if (hasSubroutines) {\n        // First step: find the subroutines. This step determines, for each basic block, to which\n        // subroutine(s) it belongs. Start with the main \"subroutine\":\n        short numSubroutines = 1;\n        firstBasicBlock.markSubroutine(numSubroutines);\n        // Then, mark the subroutines called by the main subroutine, then the subroutines called by\n        // those called by the main subroutine, etc.\n        for (short currentSubroutine = 1; currentSubroutine <= numSubroutines; ++currentSubroutine) {\n            Label basicBlock = firstBasicBlock;\n            while (basicBlock != null) {\n                if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0 && basicBlock.subroutineId == currentSubroutine) {\n                    Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;\n                    if (jsrTarget.subroutineId == 0) {\n                        // If this subroutine has not been marked yet, find its basic blocks.\n                        jsrTarget.markSubroutine(++numSubroutines);\n                    }\n                }\n                basicBlock = basicBlock.nextBasicBlock;\n            }\n        }\n        // Second step: find the successors in the control flow graph of each subroutine basic block\n        // 'r' ending with a RET instruction. These successors are the virtual successors of the basic\n        // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.\n        Label basicBlock = firstBasicBlock;\n        while (basicBlock != null) {\n            if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\n                // By construction, jsr targets are stored in the second outgoing edge of basic blocks\n                // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).\n                Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;\n                subroutine.addSubroutineRetSuccessors(basicBlock);\n            }\n            basicBlock = basicBlock.nextBasicBlock;\n        }\n    }\n    // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks\n    // whose input stack size has changed) and, while there are blocks to process, remove one\n    // from the list, update the input stack size of its successor blocks in the control flow\n    // graph, and add these blocks to the list of blocks to process (if not already done).\n    Label listOfBlocksToProcess = firstBasicBlock;\n    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\n    int maxStackSize = maxStack;\n    while (listOfBlocksToProcess != Label.EMPTY_LIST) {\n        // Remove a basic block from the list of blocks to process. Note that we don't reset\n        // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already\n        // processed basic blocks.\n        Label basicBlock = listOfBlocksToProcess;\n        listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;\n        // Compute the (absolute) input stack size and maximum stack size of this block.\n        int inputStackTop = basicBlock.inputStackSize;\n        int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;\n        // Update the absolute maximum stack size of the method.\n        if (maxBlockStackSize > maxStackSize) {\n            maxStackSize = maxBlockStackSize;\n        }\n        // Update the input stack size of the successor blocks of basicBlock in the control flow\n        // graph, and add these blocks to the list of blocks to process, if not already done.\n        Edge outgoingEdge = basicBlock.outgoingEdges;\n        if ((basicBlock.flags & Label.FLAG_SUBROUTINE_CALLER) != 0) {\n            // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual\n            // edges which lead to the instruction just after the jsr, and do not correspond to a\n            // possible execution path (see {@link #visitJumpInsn} and\n            // {@link Label#FLAG_SUBROUTINE_CALLER}).\n            outgoingEdge = outgoingEdge.nextEdge;\n        }\n        while (outgoingEdge != null) {\n            Label successorBlock = outgoingEdge.successor;\n            if (successorBlock.nextListElement == null) {\n                successorBlock.inputStackSize = (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);\n                successorBlock.nextListElement = listOfBlocksToProcess;\n                listOfBlocksToProcess = successorBlock;\n            }\n            outgoingEdge = outgoingEdge.nextEdge;\n        }\n    }\n    this.maxStack = maxStackSize;\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "No Operation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Implementation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Explanation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Design Principle",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#addSuccessorToCurrentBasicBlock(int,Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "addSuccessorToCurrentBasicBlock",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#addSuccessorToCurrentBasicBlock(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Utility methods: control flow analysis algorithm",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#addSuccessorToCurrentBasicBlock(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Adds a successor to the currentBasicBlock in the control flow graph",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#addSuccessorToCurrentBasicBlock(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "endCurrentBasicBlock",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "mustBeCalledAfterInstructionPutInCode",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "noSuccessorBasicBlock",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "have",
            "tail": "sampleCodeEndCurrentBasicBlock",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretationEndCurrentBasicBlock",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretationEndCurrentBasicBlock",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#endCurrentBasicBlockWithNoSuccessor()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit stack map frame",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "frame length must be sufficient",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "bytecode manipulation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitFrameStart sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "stack map frame explanation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "bytecode optimization principles",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameStart(int,int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Setting an abstract type in currentFrame",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Sets an abstract type in currentFrame",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "void visitAbstractType(final int frameIndex, final int abstractType) { currentFrame[frameIndex] = abstractType; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method sets an abstract type at a specified index in the current frame.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAbstractType(int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Ends the visit of currentFrame",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "current frame is the first one, which is implicit in StackMapTable",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "Resets currentFrame to null after writing it in the StackMapTable entries",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitFrameEnd() {\n    if (previousFrame != null) {\n        if (stackMapTableEntries == null) {\n            stackMapTableEntries = new ByteVector();\n        }\n        putFrame();\n        ++stackMapTableNumberOfEntries;\n    }\n    previousFrame = currentFrame;\n    currentFrame = null;\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "The method visitFrameEnd() is used to end the visit of the current frame and write it into the StackMapTable entries. It updates the number of entries in the StackMapTable, except for the first frame which is implicit. After writing, it resets the currentFrame to null.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind visitFrameEnd() is to manage the StackMapTable entries efficiently by ensuring that each frame is correctly written and updated. It emphasizes the importance of maintaining accurate stack map information for bytecode verification.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrameEnd()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrame()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Compresses and writes currentFrame in a new StackMapTable entry",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrame()",
            "head_type": "method",
            "relation": "have",
            "tail": "Compresses and writes currentFrame in a new StackMapTable entry",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrame()",
            "head_type": "method",
            "relation": "have",
            "tail": "Related to StackMap attribute entry generation and compression",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrame()",
            "head_type": "method",
            "relation": "have",
            "tail": "Follows the design principle of efficient memory usage and performance optimization",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#putFrame()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "puts abstract types",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "JVMS verification_type_info format",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "StackMapTable attributes",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "private void putAbstractTypes(final int start, final int end) { for (int i = start; i < end; ++i) { Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Puts some abstract types of currentFrame in stackMapTableEntries, using the JVMS verification_type_info format used in StackMapTable attributes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is designed to efficiently manage and optimize the storage of abstract types within the stack map table entries, adhering to the Java Virtual Machine Specification's verification type info format.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putAbstractTypes(int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Frame",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "putsFrameElementType",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "typeFormatConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "stackMapTableAttributeScenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "stackMapTableAttributeUsageSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "stackMapTableVerificationInfoInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "stackMapTableDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Opcodes",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Frame",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Label",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putFrameType(Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.SymbolTable",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "copyMethodAttributes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "noMethodVisitorBetweenClassReaderAndMethodWriter",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "justAfterMethodWriterCreation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "copyMethodAttributesSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "copyMethodAttributesRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "copyMethodAttributesDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.ClassReader",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#canCopyMethodAttributes(ClassReader,boolean,boolean,int,int,int)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "set source for method attributes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "methodInfoOffset and methodInfoLength must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "copying attributes from a source",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "void setMethodAttributesSource(final int methodInfoOffset, final int methodInfoLength) {\n    // Don't copy the attributes yet, instead store their location in the source class reader so\n    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes\n    // of the method_info JVMS structure.\n    this.sourceOffset = methodInfoOffset + 6;\n    this.sourceLength = methodInfoLength - 6;\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#setMethodAttributesSource(int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "compute method info size",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "compute method info size sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "compute method info size sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "computeMethodInfoSize() method sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "computeMethodInfoSize() method related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "computeMethodInfoSize() method related concept interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "JVMS structure interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#computeMethodInfoSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "computeMethodInfoSize() method design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "computeMethodInfoSize() method design principle interpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "efficient computation of method info size",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "puts content of method_info JVMS structure into ByteVector",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "output must be a valid ByteVector",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "generating method_info structure for Java Virtual Machine",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "related to JVMS structure generation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle of efficient bytecode manipulation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "complete sample code for putting method_info structure into ByteVector",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#putMethodInfo(ByteVector)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "collectAttributePrototypes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "have",
            "tail": "Collects the attributes of this method into the given set of attribute prototypes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is used to gather all attributes associated with a method and add them to a set of attribute prototypes. It ensures that all relevant metadata about the method is captured in the attribute prototypes set.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "have",
            "tail": "package org.springframework.asm;\n\nimport java.util.Set;\n\npublic class MethodWriter {\n    // Assuming other necessary fields and methods exist\n    \n    public void collectAttributePrototypes(Attribute.Set attributePrototypes) {\n        attributePrototypes.addAttributes(firstAttribute);\n        attributePrototypes.addAttributes(firstCodeAttribute);\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testEncode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testEncodeAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testEncodeError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testEncodeCancel",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testEncodeEmpty",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "expectBytes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "expectString",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "encoder",
            "tail_type": "apiFunction"
        },
        {
            "head": "testEncode",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Encoder#encode",
            "tail_type": "useScenario"
        },
        {
            "head": "testEncodeAll",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Encoder#encode",
            "tail_type": "useScenario"
        },
        {
            "head": "testEncodeError",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Encoder#encode",
            "tail_type": "useScenario"
        },
        {
            "head": "testEncodeCancel",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Encoder#encode",
            "tail_type": "useScenario"
        },
        {
            "head": "testEncodeEmpty",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Encoder#encode",
            "tail_type": "useScenario"
        },
        {
            "head": "expectBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Consumer<DataBuffer>",
            "tail_type": "useSampleCode"
        },
        {
            "head": "expectString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Consumer<DataBuffer>",
            "tail_type": "useSampleCode"
        },
        {
            "head": "encoder",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Encoder<T>",
            "tail_type": "useSampleCode"
        },
        {
            "head": "InputException",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "testEncodeError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#canEncode()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "test Encoder#canEncode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#canEncode()",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Encoder#canEncode",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#canEncode()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Encoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encode()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "test Encoder#encode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encode()",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Encoder#encode, possibly using testEncodeAll or other helper methods.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encode()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Encoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encode()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testEncodeAll",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "test a variety of encoding scenarios",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Helper method that tests for a variety of encoding scenarios",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "invokes several test methods including testEncode, testEncodeError, testEncodeCancel, and testEncodeEmpty",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Consumer to verify the output",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "test a variety of decoding scenarios",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Helper method that tests for a variety of decoding scenarios",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "invokes several test methods including testEncode, testEncodeError, testEncodeCancel, and testEncodeEmpty",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code demonstrating the use of the method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeAll(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "encode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Test a standard encode scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected <T> void testEncode(Publisher<? extends T> input, Class<? extends T> inputClass, Consumer<StepVerifier.FirstStep<DataBuffer>> stepConsumer) { testEncode(input, ResolvableType.forClass(inputClass), null, null, stepConsumer); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Encoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method tests the encoding functionality of an encoder by providing input data and verifying the output using StepVerifier.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,Class<? extends T>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle followed here is to ensure that the encoder correctly handles the encoding process, verifying its behavior under standard conditions.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "testEncode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "testEncodeSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "testEncodeSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "testEncodeCompleteSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncode(Publisher<? extends T>,ResolvableType,MimeType,Map<String,Object>,Consumer<StepVerifier.FirstStep<DataBuffer>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "testEncodeError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "inputStreamError",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "encoderErrorHandling",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "encoderErrorHandlingSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "encoderErrorHandlingConcept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "encoderDesignPrinciple",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "testEncodeError",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "tail_type": "method"
        },
        {
            "head": "inputStreamError",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "tail_type": "method"
        },
        {
            "head": "encoderErrorHandling",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "tail_type": "method"
        },
        {
            "head": "encoderErrorHandlingSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "tail_type": "method"
        },
        {
            "head": "encoderErrorHandlingConcept",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "tail_type": "method"
        },
        {
            "head": "encoderDesignPrinciple",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeError(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "encode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "input stream cancellation",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": " canceled input stream handling",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": " canceled input stream handling sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Reactive streams concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Encoder design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeCancel(Publisher<?>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "encode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "input stream is empty",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "The output is expected to be empty as well",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected void testEncodeEmpty(ResolvableType inputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n    Flux<?> input = Flux.empty();\n    Flux<DataBuffer> result = encoder().encode(input, this.bufferFactory, inputType, mimeType, hints);\n    StepVerifier.create(result).verifyComplete();\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method tests the encoding functionality when the input stream is empty. It verifies that the encoder produces an empty output when given an empty input.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#testEncodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind this test method is to ensure that the encoder can handle empty input streams gracefully, producing an empty output as expected. This is crucial for ensuring robustness and preventing unexpected behavior in applications that might encounter empty streams during encoding processes.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectBytes(byte[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "expectBytes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectBytes(byte[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Create a result consumer that expects the given bytes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectBytes(byte[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Consumer<DataBuffer> expectBytes(byte[] expected)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "expectBytes",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "The expected bytes must be provided as input.",
            "tail_type": "useConstraint"
        },
        {
            "head": "expectBytes",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Testing data buffer equality against expected bytes.",
            "tail_type": "useScenario"
        },
        {
            "head": "expectBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Consumer<DataBuffer> expectBytes(byte[] expected)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "expectBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Creates a consumer that checks if the data buffer matches the expected bytes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "expectBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Design principle: Encapsulation of test expectations within a consumer.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectString(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Create a result consumer that expects the given string, using the UTF-8 encoding",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectString(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Consumer<DataBuffer>",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectString(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectString(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#expectString(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encoder()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "encoder",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encoder()",
            "head_type": "method",
            "relation": "have",
            "tail": " encoder() method in AbstractEncoderTests ",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractEncoderTests#encoder()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractEncoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.InputException",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testEncodeError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.InputException",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "testEncodeError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitMainClass",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitPackage",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitRequire",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitExport",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitOpen",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitUse",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitProvide",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitEnd",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitMainClass",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "mainClass",
            "tail_type": "useScenario"
        },
        {
            "head": "visitPackage",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "packaze",
            "tail_type": "useScenario"
        },
        {
            "head": "visitRequire",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "module",
            "tail_type": "useScenario"
        },
        {
            "head": "visitExport",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "exported package",
            "tail_type": "useScenario"
        },
        {
            "head": "visitOpen",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "opened package",
            "tail_type": "useScenario"
        },
        {
            "head": "visitUse",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "service",
            "tail_type": "useScenario"
        },
        {
            "head": "visitProvide",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "service implementation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitEnd",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "module end",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor",
            "head_type": "class",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit the main class of the current module",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit the main class of the current module",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "the internal name of the main class of the current module",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "the internal name of the main class of the current module",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitMainClass(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit a package of the current module",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit a package of the current module",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitPackage(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit module dependency",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "module name must be fully qualified",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "specifying module dependencies in a module descriptor",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitRequire(final String module, final int access, final String version) { if (mv != null) { mv.visitRequire(module, access, version); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "related to Java module system and ASM library",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle of modularity and dependency management in Java",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleVisitor",
            "tail_type": "class"
        },
        {
            "tail": "visitExport",
            "head_type": "method",
            "relation": "haveFunction",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "apiFunction"
        },
        {
            "tail": "access flag must be ACC_SYNTHETIC or ACC_MANDATED",
            "head_type": "method",
            "relation": "constrained_by",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "useConstraint"
        },
        {
            "tail": "exporting a package from a module",
            "head_type": "method",
            "relation": "applied_to",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "useScenario"
        },
        {
            "tail": "sample code for visiting an exported package",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "useSampleCode"
        },
        {
            "tail": "explanation of module export in Java",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "tail": "design principles of ModuleVisitor",
            "head_type": "method",
            "relation": "have",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "tail": "org.springframework.asm.ModuleVisitor",
            "head_type": "method",
            "relation": "associated_with",
            "head": "org.springframework.asm.ModuleVisitor#visitExport(String,int,String)",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitOpen",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "access flag must be ACC_SYNTHETIC or ACC_MANDATED",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "open package of the current module",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for visiting an open package",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "explanation of open package and access flags",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle behind visiting open packages",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitUse(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit a service used by the current module",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitUse(String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "the name must be the internal name of an interface or a class",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitUse(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitUse(final String service) { if (mv != null) { mv.visitUse(service); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitUse(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Related to visiting services in a module, ensuring the service name is an internal name of an interface or class.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitUse(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Follows the principle of ensuring that module service names are strictly interface or class internal names for consistency and reliability.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit an implementation of a service",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit an implementation of a service",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitProvide(final String service, final String... providers) {    if (mv != null) {        mv.visitProvide(service, providers);    }}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method is used to visit an implementation of a service, where the internal name of the service and its providers are specified.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitProvide(String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind this method is to provide a way to specify the implementations of a service in a module.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visiting the end of the module",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "informs the visitor that everything has been visited",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "this method is the last one to be called",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for visiting the end of the module",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for visiting the end of the module",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "module attribute generation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "JVMS specification compliance",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "Java module attribute creation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "Java Virtual Machine Specification (JVMS) module attribute",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "module attribute structure",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "module attribute generation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "module attribute generation sample code",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitMainClass(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitMainClass",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitMainClass(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitMainClass(String) Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitMainClass(String) Sample Code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitMainClass(String) Code Content",
            "tail_type": "codeContent"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitPackage(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitPackage",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitPackage(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitPackage(String) useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitPackage(String) useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitPackage(String) useSampleCode Content",
            "tail_type": "Content"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitRequire",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitRequire(String,int,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitRequire",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitOpen",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitOpen(String,int,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitOpen",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitUse(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitUse",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitUse(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitUse(String)",
            "tail_type": "method"
        },
        {
            "head": "visitUse",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitUse(String)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitUse",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Records the use of a service by the module.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitUse",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Ensure that the service name is correctly resolved and indexed.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitProvide(String,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitProvide",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitProvide(String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitProvide(String,String) Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitProvide(String,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitProvide(String,String) Sample Code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.ModuleWriter#visitProvide(String,String) Code Content",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "No Operation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Implementation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Explanation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation Design Principle",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#getAttributeCount()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "ModuleWriter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#getAttributeCount()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "getAttributeCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#getAttributeCount()",
            "head_type": "method",
            "relation": "have",
            "tail": "Returns the number of Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#getAttributeCount()",
            "head_type": "method",
            "relation": "have",
            "tail": "The method calculates the total number of Module, ModulePackages, and ModuleMainClass attributes that the ModuleWriter instance has generated. It returns an integer value between 1 and 3, depending on whether packageCount is greater than 0 and whether mainClassIndex is greater than 0.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#getAttributeCount()",
            "head_type": "method",
            "relation": "have",
            "tail": "java\npackage org.springframework.asm;\n\npublic class ModuleWriter {\n    private int packageCount;\n    private int mainClassIndex;\n\n    public int getAttributeCount() {\n        return 1 + (packageCount > 0 ? 1 : 0) + (mainClassIndex > 0 ? 1 : 0);\n    }\n}\n",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "compute the size of module attributes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "must have a valid symbol table",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "generating module attributes for a class",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for computing module attribute size",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.ModuleWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "interpretation of module attribute concepts",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#computeAttributesSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principles behind module attribute size computation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#putAttributes(ByteVector)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "puts the Module, ModulePackages and ModuleMainClass attributes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#putAttributes(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "void putAttributes(final ByteVector output) { ... }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#putAttributes(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter in the given ByteVector.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.ModuleWriter#putAttributes(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is used to write module-related attributes to a ByteVector. It handles various module attributes such as module name, flags, version, and counts for requires, exports, opens, uses, and provides. It also deals with module packages and the main class if present.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "MockPropertySource",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "setProperty",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "withProperty",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "MockPropertySource requires a Properties object",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "Testing scenarios",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "have",
            "tail": "Sample code for MockPropertySource",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "have",
            "tail": "Related concept interpretation for MockPropertySource",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "have",
            "tail": "Design principle interpretation for MockPropertySource",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.mock.env.MockEnvironment",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "setProperty",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Properties",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#setProperty(String,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "method chaining",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "fluent-style use",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "returns the current instance",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "method chaining",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "MockPropertySource",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.env.MockPropertySource#withProperty(String,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "determine if the current code is running in the Eclipse IDE",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils",
            "head_type": "class",
            "relation": "have",
            "tail": "runningInEclipse() method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "runningInEclipse() method",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.ide.IdeUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils",
            "head_type": "class",
            "relation": "have",
            "tail": "test utilities related to IDEs",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils",
            "head_type": "class",
            "relation": "have",
            "tail": "author Sam Brannen",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils",
            "head_type": "class",
            "relation": "have",
            "tail": "since 6.2",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils#runningInEclipse()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "determine if running in Eclipse IDE",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils#runningInEclipse()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for runningInEclipse()",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils#runningInEclipse()",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for runningInEclipse()",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils#runningInEclipse()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for runningInEclipse()",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.ide.IdeUtils#runningInEclipse()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.ide.IdeUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "buffer allocation and release verification",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "head_type": "class",
            "relation": "have",
            "tail": "related concept interpretation for buffer allocation and release verification",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "head_type": "class",
            "relation": "have",
            "tail": "design principle interpretation for buffer allocation and release verification",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "buffer allocation and release verification",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "verification of data buffer allocations and releases",
            "tail_type": "useScenario"
        },
        {
            "head": "buffer allocation and release verification",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "must ensure all allocated buffers are released to avoid memory leaks",
            "tail_type": "useConstraint"
        },
        {
            "head": "buffer allocation and release verification",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "sample code for buffer allocation and release verification",
            "tail_type": "useSampleCode"
        },
        {
            "head": "related concept interpretation for buffer allocation and release verification",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "importance of releasing resources to prevent memory leaks",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "design principle interpretation for buffer allocation and release verification",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "ensuring robust resource management in data buffer operations",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createDataBuffer(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "createDataBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createDataBuffer(int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "tail_type": "class"
        },
        {
            "head": "createDataBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "protected DataBuffer createDataBuffer(int capacity) {\n    return this.bufferFactory.allocateBuffer(capacity);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "createDataBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Creates a DataBuffer with the specified capacity.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "createDataBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "This method is designed to allocate a new DataBuffer instance with a given capacity. It utilizes the bufferFactory to allocate the buffer, ensuring that the buffer is properly sized to handle the specified capacity.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stringBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "DataBuffer",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "byteBuffer",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "StandardCharsets",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Converts a string to a DataBuffer",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Efficient Data Handling",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringBuffer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected DataBuffer stringBuffer(String value) {\n    return byteBuffer(value.getBytes(StandardCharsets.UTF_8));\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#deferStringBuffer(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "deferStringBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "deferStringBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "deferStringBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "deferStringBuffer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "deferStringBuffer(String)",
            "tail_type": "method"
        },
        {
            "head": "deferStringBuffer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "deferStringBuffer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "deferStringBuffer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#byteBuffer(byte[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "byteBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#byteBuffer(byte[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#byteBuffer(byte[])",
            "head_type": "method",
            "relation": "have",
            "tail": "protected DataBuffer byteBuffer(byte[] value) {\n    DataBuffer buffer = this.bufferFactory.allocateBuffer(value.length);\n    buffer.write(value);\n    return buffer;\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#release(DataBuffer)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "release DataBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#release(DataBuffer)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected void release(DataBuffer... buffers) {\n    Arrays.stream(buffers).forEach(DataBufferUtils::release);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#release(DataBuffer)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#release(DataBuffer)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "DataBuffer",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#release(DataBuffer)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "DataBufferUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stringConsumer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "DataBuffer",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected Consumer<DataBuffer> stringConsumer(String expected) { return stringConsumer(expected, UTF_8); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String,Charset)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "stringConsumer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String,Charset)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "DataBuffer",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String,Charset)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Charset",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String,Charset)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "DataBufferUtils",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#stringConsumer(String,Charset)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "assertThat",
            "tail_type": "apiFunction"
        },
        {
            "head": "stringConsumer",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "protected Consumer<DataBuffer> stringConsumer(String expected, Charset charset) {\n    return dataBuffer -> {\n        String value = dataBuffer.toString(charset);\n        DataBufferUtils.release(dataBuffer);\n        assertThat(value).isEqualTo(expected);\n    };\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#waitForDataBufferRelease(Duration)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "waitForDataBufferRelease",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#waitForDataBufferRelease(Duration)",
            "head_type": "method",
            "relation": "have",
            "tail": "Wait until allocations are at 0, or the given duration elapses.",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#waitForDataBufferRelease(Duration)",
            "head_type": "method",
            "relation": "have",
            "tail": "private void waitForDataBufferRelease(Duration duration) throws InterruptedException {\n    Instant start = Instant.now();\n    while (true) {\n        try {\n            verifyAllocations();\n            break;\n        } catch (AssertionError ex) {\n            if (Instant.now().isAfter(start.plus(duration))) {\n                throw ex;\n            }\n        }\n        Thread.sleep(50);\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "waitForDataBufferRelease",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Wait until allocations are at 0, or the given duration elapses.",
            "tail_type": "useScenario"
        },
        {
            "head": "waitForDataBufferRelease",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "private void waitForDataBufferRelease(Duration duration) throws InterruptedException {\n    Instant start = Instant.now();\n    while (true) {\n        try {\n            verifyAllocations();\n            break;\n        } catch (AssertionError ex) {\n            if (Instant.now().isAfter(start.plus(duration))) {\n                throw ex;\n            }\n        }\n        Thread.sleep(50);\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#verifyAllocations()",
            "head_type": "method",
            "relation": "haveFuntion",
            "tail": "verifyAllocations",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#verifyAllocations()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "tail_type": "class"
        },
        {
            "head": "verifyAllocations",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "private void verifyAllocations() {\n    if (this.bufferFactory instanceof NettyDataBufferFactory) {\n        ByteBufAllocator allocator = ((NettyDataBufferFactory) this.bufferFactory).getByteBufAllocator();\n        if (allocator instanceof PooledByteBufAllocator) {\n            Instant start = Instant.now();\n            while (true) {\n                PooledByteBufAllocatorMetric metric = ((PooledByteBufAllocator) allocator).metric();\n                long total = getAllocations(metric.directArenas()) + getAllocations(metric.heapArenas());\n                if (total == 0) {\n                    return;\n                }\n                if (Instant.now().isBefore(start.plus(Duration.ofSeconds(5)))) {\n                    try {\n                        Thread.sleep(50);\n                    } catch (InterruptedException ex) {\n                        // ignore\n                    }\n                    continue;\n                }\n                assertThat(total).as(\"ByteBuf Leak: \" + total + \" unreleased allocations\").isEqualTo(0);\n            }\n        }\n    }\n}",
            "tail_type": "String"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#getAllocations(List<PoolArenaMetric>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "summing allocations",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#getAllocations(List<PoolArenaMetric>)",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "private static long getAllocations(List<PoolArenaMetric> metrics) {\n    return metrics.stream().mapToLong(PoolArenaMetric::numActiveAllocations).sum();\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "byteBufAllocatorConfiguration",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty4OnHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty4OffHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty4OnHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty4OffHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty5OnHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty5OffHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty5OnHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "have",
            "tail": "netty5OffHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#createAllocators()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests",
            "tail_type": "class"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty4OnHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty4OffHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty4OnHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty4OffHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty5OnHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty5OffHeapUnpooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty5OnHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "byteBufAllocatorConfiguration",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "netty5OffHeapPooledConfiguration",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#closeAllocators()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "closeAllocators",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#closeAllocators()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "netty5OnHeapUnpooled",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#closeAllocators()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "netty5OffHeapUnpooled",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#closeAllocators()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "netty5OnHeapPooled",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#closeAllocators()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "netty5OffHeapPooled",
            "tail_type": "class"
        },
        {
            "head": "closeAllocators",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "closeAllocatorsSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "closeAllocatorsSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "closeAllocatorsSampleCodeContent",
            "tail_type": "useSampleCodeContent"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractDataBufferAllocatingTests#dataBufferFactories()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "AbstractDataBufferAllocatingTests.dataBufferFactories()",
            "tail_type": "apiFunction"
        },
        {
            "head": "AbstractDataBufferAllocatingTests.dataBufferFactories()",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Stream<Arguments> dataBufferFactories()",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Stream<Arguments> dataBufferFactories()",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "NettyDataBufferFactory",
            "tail_type": "class"
        },
        {
            "head": "Stream<Arguments> dataBufferFactories()",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "Netty5DataBufferFactory",
            "tail_type": "class"
        },
        {
            "head": "Stream<Arguments> dataBufferFactories()",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "DefaultDataBufferFactory",
            "tail_type": "class"
        },
        {
            "head": "AbstractDataBufferAllocatingTests.dataBufferFactories()",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "AbstractDataBufferAllocatingTests.dataBufferFactories()",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitRecordComponent",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitTypeAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitAttribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitEnd",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "apiVersionConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "recordComponentVisitorUsage",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "have",
            "tail": "recordComponentVisitorSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "have",
            "tail": "recordComponentVisitorRelatedConcepts",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor",
            "head_type": "class",
            "relation": "have",
            "tail": "recordComponentVisitorDesignPrinciples",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "delegation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "nullability",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "record component visitor",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "The method returns the delegate RecordComponentVisitor if it exists, otherwise returns null.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle followed here is to allow for flexible and dynamic delegation, which can be null if no delegation is required.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "java\npackage org.springframework.asm;\n\npublic class RecordComponentVisitorExample {\n    private RecordComponentVisitor delegate;\n\n    public RecordComponentVisitor getDelegate() {\n        return delegate;\n    }\n\n    public void setDelegate(RecordComponentVisitor delegate) {\n        this.delegate = delegate;\n    }\n}\n",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "descriptor must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "record component annotation visiting",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "record component annotation explanation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for visitAnnotation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTypeAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "typeRefConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "recordComponentSignatureAnnotation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitTypeAnnotationSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "typeAnnotationConcept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleTypeAnnotation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "typeRefConstraint",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "org.springframework.asm.TypeReference",
            "tail_type": "class"
        },
        {
            "head": "recordComponentSignatureAnnotation",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "visitTypeAnnotationSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "typeAnnotationConcept",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "designPrincipleTypeAnnotation",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit non standard attribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit non standard attribute sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visit non standard attribute sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "java\npublic void visitAttribute(final Attribute attribute) {\n    if (delegate != null) {\n        delegate.visitAttribute(attribute);\n    }\n}\n",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visiting the end of the record component",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "This method is the last one to be called and is used to inform the visitor that everything has been visited.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitEnd() {\n    if (delegate != null) {\n        delegate.visitEnd();\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentVisitor#visitEnd()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "allocate data buffers via a DataBufferFactory",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "all created buffers must be released",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "unit tests",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "have",
            "tail": "sample code for checking leaks",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "LeakAwareDataBufferFactory",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "have",
            "tail": "related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests",
            "head_type": "class",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check for data buffer leaks",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "must be called after buffer creation",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "test cleanup phase",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for checking data buffer leaks",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "have",
            "tail": "explanation of data buffer leak checking",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principles behind data buffer leak checking",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.AbstractLeakCheckingTests#checkForLeaks()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.BufferFactory",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.DataBufferTestUtils",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "dumpBytes",
            "tail_type": "apiFunction"
        },
        {
            "head": "dumpBytes",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "Memory Consumption Constraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "dumpBytes",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "DataBuffer Manipulation",
            "tail_type": "useScenario"
        },
        {
            "head": "dumpBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Complete Dump Bytes Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "dumpBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Related Concept Interpretation for Dump Bytes",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "dumpBytes",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Design Principle Interpretation for Dump Bytes",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.DataBufferTestUtils",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "DataBuffer",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "storeConstants",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "constructRecordComponent",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitTypeAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitAttribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitEnd",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "computeRecordComponentInfoSize",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "putRecordComponentInfo",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "collectAttributePrototypes",
            "tail_type": "apiFunction"
        },
        {
            "head": "storeConstants",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "symbolTableConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "constructRecordComponent",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "recordComponentCreation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitAnnotation",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "annotationProcessing",
            "tail_type": "useScenario"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "typeAnnotationProcessing",
            "tail_type": "useScenario"
        },
        {
            "head": "visitAttribute",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "attributeProcessing",
            "tail_type": "useScenario"
        },
        {
            "head": "computeRecordComponentInfoSize",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "recordComponentSizeCalculation",
            "tail_type": "useScenario"
        },
        {
            "head": "putRecordComponentInfo",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "recordComponentInfoGeneration",
            "tail_type": "useScenario"
        },
        {
            "head": "collectAttributePrototypes",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "attributePrototypeCollection",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.SymbolTable",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.AnnotationWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Attribute",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAnnotation sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.RecordComponentWriter#visitAnnotation(String,boolean) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTypeAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "RecordComponentWriter",
            "tail_type": "class"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTypeAnnotation Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitTypeAnnotation Sample Code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Complete visitTypeAnnotation Example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAttribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAttribute(Attribute) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAttribute(Attribute) sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.RecordComponentWriter#visitAttribute(Attribute) code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "No Operation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "No Operation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#computeRecordComponentInfoSize()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "compute the size of the record component JVMS structure",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#computeRecordComponentInfoSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "Returns the size of the record component JVMS structure generated by this RecordComponentWriter. Also adds the names of the attributes of this record component in the constant pool.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#computeRecordComponentInfoSize()",
            "head_type": "method",
            "relation": "have",
            "tail": "package org.springframework.asm; public class RecordComponentWriter { // specific code }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#computeRecordComponentInfoSize()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "puts the content of the record component",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "output must be a ByteVector",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "generate record component info",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "void putRecordComponentInfo(final ByteVector output) { ... }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "related to ByteVector manipulation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle of efficient data handling",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.RecordComponentWriter#putRecordComponentInfo(ByteVector)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "collectAttributePrototypes",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "have",
            "tail": "Collects the attributes of this record component into the given set of attribute prototypes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method iterates over the attributes of the record component and adds them to the provided set of attribute prototypes.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.RecordComponentWriter#collectAttributePrototypes(Attribute.Set)",
            "head_type": "method",
            "relation": "have",
            "tail": "package com.example;\n\nimport org.springframework.asm.Attribute;\nimport org.springframework.asm.RecordComponentWriter;\n\npublic class Example {\n    public static void main(String[] args) {\n        RecordComponentWriter writer = new RecordComponentWriter();\n        Attribute.Set attributePrototypes = new Attribute.Set();\n        writer.collectAttributePrototypes(attributePrototypes);\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.SpringAsmInfo",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "exposing constants related to Spring's internal repackaging of the ASM bytecode library",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.SpringAsmInfo",
            "head_type": "class",
            "relation": "have",
            "tail": "The ASM compatibility version for Spring's ASM visitor implementations: currently Opcodes.ASM10_EXPERIMENTAL, as of Spring Framework 5.3.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm(SpringAsmInfo",
            "head_type": "class",
            "relation": "have",
            "tail": "Utility class",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm(SpringAsmInfo",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "Opcodes",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm(SpringAsmInfo",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "Spring Framework",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "createLeakError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "leakError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "isAllocated",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "retain",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "touch",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "release",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "factory",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "toString",
            "tail_type": "apiFunction"
        },
        {
            "head": "createLeakError",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "leakError",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "isAllocated",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "retain",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "touch",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "release",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "factory",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "toString",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#createLeakError(DataBuffer)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "createLeakError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#createLeakError(DataBuffer)",
            "head_type": "method",
            "relation": "have",
            "tail": "createLeakErrorSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "createLeakErrorSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer",
            "tail_type": "package"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#leakError()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "leakError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#leakError()",
            "head_type": "method",
            "relation": "have",
            "tail": "AssertionError leakError() { return this.leakError; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer#leakError()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.io.buffer.LeakAwareDataBuffer",
            "tail_type": "class"
        }
    ]
}