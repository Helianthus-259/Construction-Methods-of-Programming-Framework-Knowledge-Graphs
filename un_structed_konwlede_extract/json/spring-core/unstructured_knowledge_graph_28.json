{
    "relationships": [
        {
            "head": "org.springframework.core.task.NoOpRunnable",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "no operation execution",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.NoOpRunnable",
            "head_type": "class",
            "relation": "have",
            "tail": "This class does not perform any operation when its run method is called.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.task.NoOpRunnable",
            "head_type": "class",
            "relation": "have",
            "tail": "The design principle behind this class is to provide a default implementation of the Runnable interface that does nothing, which can be useful in scenarios where a Runnable is required but no action is desired.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.task.NoOpRunnable",
            "head_type": "class",
            "relation": "have",
            "tail": "package org.springframework.core.task;\n\nimport java.lang.Runnable;\n\npublic class NoOpRunnable implements Runnable {\n    @Override\n    public void run() {\n        // no-op\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.task.NoOpRunnable#run()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "no-operation execution",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.NoOpRunnable#run()",
            "head_type": "method",
            "relation": "have",
            "tail": "This method does not perform any operation.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.task.NoOpRunnable#run()",
            "head_type": "method",
            "relation": "have",
            "tail": "package org.springframework.core.task; public class NoOpRunnable implements Runnable { @Override public void run() { // no-op } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "thread synchronization",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "thread notification",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "relatedConceptInterpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "thread synchronization",
            "tail_type": "apiFunction"
        },
        {
            "head": "relatedConceptInterpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "thread notification",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable",
            "head_type": "class",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "thread synchronization",
            "tail_type": "apiFunction"
        },
        {
            "head": "useSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "thread notification",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "thread synchronization",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "execution of doRun() method",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "notifying all waiting threads",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "must be called within a synchronized block",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.core.task.AbstractNotifyingRunnable",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#run()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#doRun()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "abstract execution",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.core.task.AbstractNotifyingRunnable",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.core.task.TaskExecutor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.task.AbstractNotifyingRunnable#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "getThreadName",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "isVirtual",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "runCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "doRun",
            "tail_type": "apiFunction"
        },
        {
            "head": "getThreadName",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "isVirtual",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "runCount",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "doRun",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#getThreadName()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "retrieve thread name",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#getThreadName()",
            "head_type": "method",
            "relation": "have",
            "tail": "public String getThreadName() {\n    return this.threadName;\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "retrieve thread name",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.core.task.ThreadNameHarvester",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "retrieve thread name",
            "tail_type": "apiFunction"
        },
        {
            "head": "retrieve thread name",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Used to fetch the name of the current thread.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "retrieve thread name",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "This method is typically used for logging and diagnostic purposes to identify the current thread.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#isVirtual()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check if the thread is virtual",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#isVirtual()",
            "head_type": "method",
            "relation": "have",
            "tail": "public boolean isVirtual() {\n    return this.virtual;\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#isVirtual()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.task.ThreadNameHarvester",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#runCount()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "retrieve run count",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#runCount()",
            "head_type": "method",
            "relation": "have",
            "tail": "public int runCount() {\n    return this.runCount.get();\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "retrieve run count",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.core.task.ThreadNameHarvester",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#runCount()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.task.ThreadNameHarvester",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#doRun()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "thread name harvesting",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "This method harvests the name of the current thread and whether it is virtual.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "The method increments a counter each time it is run to keep track of the number of executions.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.task.ThreadNameHarvester#doRun()",
            "head_type": "method",
            "relation": "have",
            "tail": "package com.healthMgr.common.email;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nclass ThreadNameHarvester {\n    private String threadName;\n    private boolean virtual;\n    private AtomicInteger runCount = new AtomicInteger();\n\n    public void doRun() {\n        Thread thread = Thread.currentThread();\n        this.threadName = thread.getName();\n        this.virtual = thread.isVirtual();\n        runCount.incrementAndGet();\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "delegation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "nullability",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "method call delegation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#getDelegate()",
            "head_type": "method",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit a parameter of this method",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "api < Opcodes.ASM5",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "only ACC_FINAL, ACC_SYNTHETIC or/and ACC_MANDATED are allowed",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitParameter(String name, final int access) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitParameter(name, access); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a parameter of this method.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design principle for visiting parameters in method visitors.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameter(String,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Opcodes",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit default value of annotation interface method",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "visitor must call exactly one visit method followed by visitEnd",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "annotation interface method default value visitation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for visiting annotation default value",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "have",
            "tail": "explanation of annotation visitor and visit methods",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for visiting annotation default values",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.AnnotationVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotationSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAnnotationSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitAnnotationSampleCodeContent",
            "tail_type": "useSampleCodeContent"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotationRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitAnnotationRelatedConceptInterpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "visitAnnotationRelatedConceptInterpretationContent",
            "tail_type": "relatedConceptInterpretationContent"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotationDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitAnnotationDesignPrincipleInterpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "visitAnnotationDesignPrincipleInterpretationContent",
            "tail_type": "designPrincipleInterpretationContent"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTypeAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "typeRefConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "methodSignatureAnnotation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTypeAnnotationSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "TypeReference",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "TypePath",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "parameterCountConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "methodParameterAnnotation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotableParameterCountSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "parameterAnnotationInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleOfvisitAnnotableParameterCount",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitAnnotableParameterCount",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "parameterCountConstraint",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "methodParameterAnnotation",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitAnnotableParameterCountSampleCode",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "parameterAnnotationInterpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "designPrincipleOfvisitAnnotableParameterCount",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitParameterAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "parameter index must be strictly smaller than the number of parameters",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "visiting annotations of method parameters",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for visiting parameter annotations",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "explanation of visiting parameter annotations",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principles for visiting parameter annotations",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit non standard attribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute) related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute) design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Attribute",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitCode()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit method's code",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitCode()",
            "head_type": "method",
            "relation": "have",
            "tail": "visit method's code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitCode()",
            "head_type": "method",
            "relation": "have",
            "tail": "non abstract method",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitCode()",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitCode()",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitCode()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit current state of local variables and operand stack elements",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "must be called just before any instruction that follows an unconditional branch instruction",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "method's parameters and access flags",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "have",
            "tail": "visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack)",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visit current state of local variables and operand stack elements",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "tail_type": "method"
        },
        {
            "head": "must be called just before any instruction that follows an unconditional branch instruction",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "tail_type": "method"
        },
        {
            "head": "method's parameters and access flags",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "tail_type": "method"
        },
        {
            "head": "visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack)",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "tail_type": "method"
        },
        {
            "head": "relatedConceptInterpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "tail_type": "method"
        },
        {
            "head": "designPrincipleInterpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFrame(int,int,Object[],int,Object[])",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsn(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Visits a zero operand instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a zero operand instruction. @param opcode the opcode of the instruction to be visited. This opcode is either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "The opcode of the instruction to be visited includes NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER, or MONITOREXIT.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method visitInsn is designed to handle a variety of opcodes, which are fundamental to the Java Virtual Machine (JVM) instruction set. Each opcode corresponds to a specific operation, such as loading constants, performing arithmetic operations, and managing the stack. The method ensures that each instruction is visited and processed accordingly, which is crucial for the correct execution of bytecode. The design principle behind this method is to provide a flexible and comprehensive way to handle all possible zero-operand instructions in the JVM.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit an instruction with a single int operand",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode value constraints",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "visit instructions with specific opcodes",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitIntInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitIntInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "complete example for visiting an instruction with a single int operand",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "related concept interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "interpretation of opcodes and their usage",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "design principle interpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "principles behind visiting instructions with specific opcodes",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit local variable instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "loading or storing local variable",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitVarInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitVarInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "complete example of visiting local variable instruction",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle of visitVarInsn",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit type instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode must be NEW, ANEWARRAY, CHECKCAST or INSTANCEOF",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "type instruction that takes the internal name of a class as parameter",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitTypeInsn(final int opcode, final String type) { if (mv != null) { mv.visitTypeInsn(opcode, type); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a type instruction. A type instruction is an instruction that takes the internal name of a class as parameter (see Type#getInternalName()).",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design principle: Delegation. The method delegates the visitTypeInsn call to the underlying MethodVisitor if it is not null.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Type",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit field instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode must be GETSTATIC, PUTSTATIC, GETFIELD, or PUTFIELD",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "loading or storing the value of a field of an object",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {    if (mv != null) {        mv.visitFieldInsn(opcode, owner, name, descriptor);    }}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visit field instruction",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "tail_type": "method"
        },
        {
            "head": "opcode must be GETSTATIC, PUTSTATIC, GETFIELD, or PUTFIELD",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "tail_type": "method"
        },
        {
            "head": "loading or storing the value of a field of an object",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitFieldInsn(int,String,String,String)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Visits a method instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode must be INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a method instruction. A method instruction is an instruction that invokes a method.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "Deprecated. Use visitMethodInsn(int, String, String, String, boolean) instead.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor) { ... }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit a method instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode must be INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "invoking a method",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitMethodInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitMethodInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "complete example of visiting a method instruction",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle of visitMethodInsn",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Type",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit invokedynamic instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "API version must be at least ASM5",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "invoking dynamic methods",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for visitInvokeDynamicInsn",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for visitInvokeDynamicInsn",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit a jump instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "opcode must be a valid jump instruction opcode",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "jump to another instruction based on condition",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitJumpInsn(final int opcode, final Label label) { if (mv != null) { mv.visitJumpInsn(opcode, label); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visit a jump instruction",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "tail_type": "method"
        },
        {
            "head": "opcode must be a valid jump instruction opcode",
            "head_type": "useConstraint",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "tail_type": "method"
        },
        {
            "head": "jump to another instruction based on condition",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitJumpInsn(int,Label)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Visits a label",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLabel(Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "A label designates the instruction that will be visited just after it.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLabel(Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitLabel(final Label label) {    if (mv != null) {        mv.visitLabel(label);    }}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLabel(Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design Principle: Delegation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLabel(Label)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Label",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLdcInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "value must be non null",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "loading constants on the stack",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitLdcInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for visitLdcInsn",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for visitLdcInsn",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitLdcInsn",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit IINC instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit IINC instruction sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visit IINC instruction sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit IINC instruction related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visit IINC instruction related concept interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int) related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit IINC instruction design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visit IINC instruction design principle interpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitIincInsn(int,int) design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Visits a TABLESWITCH instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a TABLESWITCH instruction",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "The method visitTableSwitchInsn is used to visit a TABLESWITCH instruction in Java bytecode. It takes four parameters: min (the minimum key value), max (the maximum key value), dflt (the beginning of the default handler block), and labels (the beginnings of the handler blocks). The method is part of the MethodVisitor class in the org.springframework.asm package, which is used for generating and transforming Java bytecode.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind the visitTableSwitchInsn method is to provide a way to generate TABLESWITCH instructions in Java bytecode. This instruction is used to implement switch statements with a dense set of case values. The method takes parameters for the minimum and maximum key values, the default handler block, and the handler blocks for each case. It allows for efficient generation of bytecode for switch statements with many cases.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Visits a LOOKUPSWITCH instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a LOOKUPSWITCH instruction",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "The method visitLookupSwitchInsn visits a LOOKUPSWITCH instruction in Java bytecode. It takes three parameters: a Label for the default handler block, an array of integers representing the keys, and an array of Labels representing the handler blocks for each key. This method is typically used in the context of generating bytecode for switch statements.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "The design principle behind visitLookupSwitchInsn is to provide a way to generate bytecode for switch statements that use a lookup table. This method is part of the MethodVisitor class in the ASM library, which is a common Java bytecode manipulation and analysis framework. The method ensures that the generated bytecode adheres to the Java Virtual Machine (JVM) specifications for switch statements.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit a MULTIANEWARRAY instruction",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "descriptor must be a valid array type descriptor",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "array allocation with multiple dimensions",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for visitMultiANewArrayInsn",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for visitMultiANewArrayInsn",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Type",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsnAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitInsnAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitInsnAnnotation",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "apiVersionCheck",
            "tail_type": "useConstraint"
        },
        {
            "head": "visitInsnAnnotation",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "instructionAnnotation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitInsnAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsnAnnotationSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitInsnAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsnAnnotationRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitInsnAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsnAnnotationDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsnAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.TypeReference",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsnAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.TypePath",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitInsnAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.AnnotationVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTryCatchBlock",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "IllegalArgumentException if label visited",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "exception handling",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for visitTryCatchBlock",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for exception handling",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for visitTryCatchBlock",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Label",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchBlock(Label,Label,Label,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.Type",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit annotation on exception handler type",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "must be called after visitTryCatchBlock",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "annotated exception handler",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit annotation values",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitTryCatchAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "TypeReference",
            "tail_type": "class"
        },
        {
            "head": "visit annotation on exception handler type",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related to visiting annotations on exception handlers",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visit annotation on exception handler type",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle for visiting annotations on exception handlers",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariable(String,String,String,Label,Label,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLocalVariable",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariable(String,String,String,Label,Label,int)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "IllegalArgumentException",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariable(String,String,String,Label,Label,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a local variable declaration",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariable(String,String,String,Label,Label,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitLocalVariable(final String name, final String descriptor, final String signature, final Label start, final Label end, final int index) {    if (mv != null) {        mv.visitLocalVariable(name, descriptor, signature, start, end, index);    }}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLocalVariable",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLocalVariableAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "api < Opcodes.ASM5",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "annotated local variable type",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitLocalVariableAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "AnnotationVisitor interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for visitLocalVariableAnnotation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitLocalVariableAnnotation sample code",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor#visitLocalVariableAnnotation(int,TypePath,Label[],Label[],int[],String,boolean)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLineNumber(int,Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLineNumber",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLineNumber(int,Label)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "IllegalArgumentException if start has not already been visited",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLineNumber(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits a line number declaration",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitLineNumber(int,Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitLineNumber(final int line, final Label start) { if (mv != null) { mv.visitLineNumber(line, start); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLineNumber",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "public void visitLineNumber(final int line, final Label start) { if (mv != null) { mv.visitLineNumber(line, start); } }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLineNumber",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Visits a line number declaration",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMaxs(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visit maximum stack size and local variables",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMaxs(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visit maximum stack size and local variables sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visit maximum stack size and local variables sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "java\npackage org.springframework.asm;\n\nimport java.lang.reflect.Method;\n\npublic class MethodVisitorExample {\n    public static void main(String[] args) throws NoSuchMethodException, SecurityException {\n        Method method = MethodVisitorExample.class.getMethod(\"exampleMethod\", int.class, int.class);\n        MethodVisitor mv = new MethodVisitorExample();\n        mv.visitMaxs(10, 5);\n    }\n\n    public void visitMaxs(final int maxStack, final int maxLocals) {\n        System.out.println(\"Max Stack: \" + maxStack + \", Max Locals: \" + maxLocals);\n    }\n\n    public static void exampleMethod(int maxStack, int maxLocals) {\n        // Example method\n    }\n}\n",
            "tail_type": "code"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMaxs(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "related concept interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "The method visitMaxs is used to specify the maximum stack size and the maximum number of local variables for a method in a class file being generated or transformed. This is important for bytecode manipulation libraries like ASM, which allow developers to dynamically generate or modify compiled Java classes at runtime.",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitMaxs(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "design principle interpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "The design principle behind visitMaxs is to provide a way to accurately describe the requirements of a method in terms of stack and local variable usage. This is crucial for ensuring that the generated bytecode is valid and can be executed correctly by the Java Virtual Machine (JVM).",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitEnd()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitEnd",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "Visits the end of the method. This method, which is the last one to be called, is used to inform the visitor that all the annotations and attributes of the method have been visited.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodVisitor#visitEnd()",
            "head_type": "method",
            "relation": "have",
            "tail": "public void visitEnd() {\n    if (mv != null) {\n        mv.visitEnd();\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generate.value.ExampleClass$$GeneratedBy",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "fakeCglibGeneratedClass",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generate.value.ExampleClass$$GeneratedBy",
            "head_type": "class",
            "relation": "have",
            "tail": "fakeCglibGeneratedClassDescription",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "fakeCglibGeneratedClass",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "fakeCglibGeneratedClassDescription",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generate.value.ExampleClass",
            "head_type": "class",
            "relation": "have",
            "tail": "Public example class used for test",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generate.value.ExampleClass",
            "head_type": "class",
            "relation": "have",
            "tail": "Author: Phillip Webb",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedGenericParameter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "constructor",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedGenericParameter",
            "head_type": "class",
            "relation": "have",
            "tail": "constructor code example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "constructor code example",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "constructor example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedParameter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "constructor",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedParameter",
            "head_type": "class",
            "relation": "have",
            "tail": "constructor code example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "protectedTypeFunctionality",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "protectedTypeConstraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "protectedTypeScenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "have",
            "tail": "protectedTypeSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "have",
            "tail": "protectedTypeRelatedConcept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "have",
            "tail": "protectedTypeDesignPrinciple",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.ProtectedType",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "relatedClassOrMethod",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "PublicFactoryBean",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "protectedTypeFactoryBean",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "resolveToProtectedGenericParameter",
            "tail_type": "apiFunction"
        },
        {
            "head": "PublicFactoryBean",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "protectedTypeFactoryBean",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "resolveToProtectedGenericParameter",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "protectedTypeFactoryBean",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
            "head_type": "method",
            "relation": "have",
            "tail": "public static PublicFactoryBean<ProtectedType> protectedTypeFactoryBean() { return new PublicFactoryBean<>(ProtectedType.class); }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "PublicFactoryBean",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#protectedTypeFactoryBean()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "ProtectedType",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#resolveToProtectedGenericParameter()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Resolving to Protected Generic Parameter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.aot.generator.visibility.PublicFactoryBean#resolveToProtectedGenericParameter()",
            "head_type": "method",
            "relation": "have",
            "tail": "Resolving to Protected Generic Parameter Sample Code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Resolving to Protected Generic Parameter Sample Code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "Complete Example for Resolving to Protected Generic Parameter",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasFrames()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check if method has frames",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasFrames()",
            "head_type": "method",
            "relation": "have",
            "tail": "stackMapTableNumberOfEntries > 0",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasFrames()",
            "head_type": "method",
            "relation": "have",
            "tail": "stackMapTableNumberOfEntries indicates the number of stack map frame entries",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasFrames()",
            "head_type": "method",
            "relation": "have",
            "tail": "the method returns true if stackMapTableNumberOfEntries is greater than 0",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasAsmInstructions()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "check presence of Asm instructions",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasAsmInstructions()",
            "head_type": "method",
            "relation": "have",
            "tail": "boolean hasAsmInstructions() { return hasAsmInstructions; }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#hasAsmInstructions()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitParameter(String,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitParameter",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitParameter(String,int)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitParameter(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitParameter sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitParameter sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitParameter(String,int) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotationDefault",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAnnotationDefault()",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotationDefault() sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAnnotationDefault() sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAnnotation(String,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAnnotation sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitAnnotation(String,boolean) sample code content",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTypeAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTypeAnnotation(int,TypePath,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "visitTypeAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTypeAnnotationSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitTypeAnnotationSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitTypeAnnotationSampleCodeContent",
            "tail_type": "useSampleCodeContent"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAnnotableParameterCount",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAnnotableParameterCount(int,boolean)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAnnotableParameterCountSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAnnotableParameterCountSampleCode",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitParameterAnnotation",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitParameterAnnotation(int,String,boolean)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitParameterAnnotation",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitAttribute",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitAttribute(Attribute)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitAttribute(Attribute) sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitAttribute(Attribute) sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitAttribute(Attribute) code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitCode()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitCode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitCode()",
            "head_type": "method",
            "relation": "have",
            "tail": "visitCode sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitCode sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFrame(int,int,Object[],int,Object[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitFrame",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitFrame",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "compute must not be COMPUTE_ALL_FRAMES",
            "tail_type": "useConstraint"
        },
        {
            "head": "visitFrame",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "stack map frame computation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitFrame",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "stack map frame computation example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitFrame",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitFrame related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitFrame",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitFrame design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInsn(int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsn adds an instruction to the bytecode of the method",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsn updates the maximum stack size and number of locals",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsn handles stack map frames",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitInsn ends the current basic block if a return or throw instruction is encountered",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitInsn adds an instruction to the bytecode of the method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitInsn updates the maximum stack size and number of locals",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitInsn handles stack map frames",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInsn(int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitInsn ends the current basic block if a return or throw instruction is encountered",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitIntInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitIntInsn_sample_code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitIntInsn_sample_code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitIntInsn_code",
            "tail_type": "code"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitIntInsn_related_concept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitIntInsn_related_concept",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "visitIntInsn_concept_description",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitIntInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitIntInsn_design_principle",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitIntInsn_design_principle",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "visitIntInsn_design_description",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#canDecode()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Decoder#canDecode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#canDecode()",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Decoder#canDecode.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#canDecode",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decode()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Decoder#decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decode()",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Decoder#decode, possibly using testDecodeAll or other helper methods.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decode",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decode()",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decode()",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Decoder#decode, possibly using testDecodeAll or other helper methods.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decodeToMono()",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Decoder#decodeToMono",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decodeToMono()",
            "head_type": "method",
            "relation": "have",
            "tail": "testDecodeToMonoAll",
            "tail_type": "useScenario"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "apiFunction",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decodeToMono()",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#decodeToMono()",
            "head_type": "method",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Decoder#decodeToMono, possibly using testDecodeToMonoAll.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "Subclasses should implement this method to test Decoder#decodeToMono, possibly using testDecodeToMonoAll.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "This method is used to decode data to a Mono.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decoding scenarios",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Helper method that tests for a variety of Flux decoding scenarios",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method invokes several other methods including testDecode, testDecodeError, testDecodeCancel, and testDecodeEmpty",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected <T> void testDecodeAll(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\n    testDecodeAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitVarInsn(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitVarInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitVarInsn",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "varIndex must be valid",
            "tail_type": "useConstraint"
        },
        {
            "head": "visitVarInsn",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "method bytecode manipulation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitVarInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitVarInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitVarInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitVarInsn related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitVarInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitVarInsn design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodVisitor",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "test a variety of Flux decoding scenarios",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "decoding Flux",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Helper method that tests for a variety of Flux decoding scenarios",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "This method invokes several other methods to test different aspects of decoding",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeError(Publisher, ResolvableType, MimeType, Map)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeCancel(Publisher, ResolvableType, MimeType, Map)",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeEmpty(ResolvableType, MimeType, Map)",
            "tail_type": "method"
        },
        {
            "head": "testDecode(Publisher, ResolvableType, Consumer, MimeType, Map)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "testDecodeError(Publisher, ResolvableType, MimeType, Map)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode error",
            "tail_type": "apiFunction"
        },
        {
            "head": "testDecodeCancel(Publisher, ResolvableType, MimeType, Map)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode cancel",
            "tail_type": "apiFunction"
        },
        {
            "head": "testDecodeEmpty(ResolvableType, MimeType, Map)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode empty",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTypeInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitTypeInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTypeInsnSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitTypeInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTypeInsnRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitTypeInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTypeInsnDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTypeInsn(int,String)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "visitTypeInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Decoder#decode decode scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected <T> void testDecode(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {    testDecode(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Decoder#decode decode scenario",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "protected <T> void testDecode(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {    testDecode(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "Decoder#decode decode scenario",
            "head_type": "useScenario",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "protected <T> void testDecode(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {    testDecode(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);}",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Decoder#decode decode scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "Decoder#decode decode scenario",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "protected <T> void testDecode(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n    Flux<T> result = (Flux<T>) this.decoder.decode(input, outputType, mimeType, hints);\n    StepVerifier.FirstStep<T> step = StepVerifier.create(result);\n    stepConsumer.accept(step);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecode(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "Decoder#decode decode scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "protected <T> void testDecode(Publisher<DataBuffer> input, ResolvableType outputType, Consumer<StepVerifier.FirstStep<T>> stepConsumer, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n    Flux<T> result = (Flux<T>) this.decoder.decode(input, outputType, mimeType, hints);\n    StepVerifier.FirstStep<T> step = StepVerifier.create(result);\n    stepConsumer.accept(step);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "Decoder#decode decode scenario",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "Decoder#decode decode scenario",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitFieldInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitFieldInsn(int,String,String,String)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitFieldInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitFieldInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitFieldInsn complete example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "input stream contains an error",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "feed the first element of the input stream to the decoder, followed by an InputException",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected void testDecodeError(Publisher<DataBuffer> input, ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) { ... }",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "InputException",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "This test method will feed the first element of the input stream to the decoder, followed by an InputException. The result is expected to contain one \"normal\" element, followed by the error.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design Principle: The method is designed to test error handling in decoders, ensuring that decoders can handle errors gracefully and continue processing subsequent elements.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Decoder#decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "Decoder#decode",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "input stream cancellation",
            "tail_type": "useScenario"
        },
        {
            "head": "Decoder#decode",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "input stream cancellation sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Decoder#decode",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related concept interpretation for Decoder#decode",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decode",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle interpretation for Decoder#decode",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMethodInsn(int,String,String,String,boolean)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitMethodInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitMethodInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitMethodInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitMethodInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "related concept interpretation for visitMethodInsn",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitMethodInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "design principle interpretation for visitMethodInsn",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "empty input stream decoding",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "empty input stream decoding sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "empty input stream decoding sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "protected void testDecodeEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n    Flux<DataBuffer> input = Flux.empty();\n    Flux<?> result = this.decoder.decode(input, outputType, mimeType, hints);\n    StepVerifier.create(result).verifyComplete();\n}",
            "tail_type": "code"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Decoder#decode with empty input interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decode with empty input interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "When the input stream is empty, the decode method should return an empty output as well. This is to ensure that the decoding process handles empty inputs gracefully without throwing errors or exceptions.",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle for handling empty inputs in Decoder#decode",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "design principle for handling empty inputs in Decoder#decode",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "The design principle for handling empty inputs in Decoder#decode is to ensure that the method can handle and return a meaningful result even when the input is empty. This principle promotes robustness and fault tolerance in the decoding process, ensuring that the system can gracefully handle unexpected or edge-case inputs without crashing or behaving unpredictably.",
            "tail_type": "description"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitInvokeDynamicInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitInvokeDynamicInsn(String,String,Handle,Object)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "have",
            "tail": "visitInvokeDynamicInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitInvokeDynamicInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "useSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitInvokeDynamicInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "relatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitInvokeDynamicInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "designPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decoding scenarios",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Helper method that tests for a variety of Mono decoding scenarios",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Mono",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "org.springframework.core.testfixture.codec.AbstractDecoderTests",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected <T> void testDecodeToMonoAll(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\n    testDecodeToMonoAll(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "testDecodeToMonoAll",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Helper method that tests for a variety of Mono decoding scenarios",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "testDecodeToMonoAll",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "decoding scenarios",
            "tail_type": "useScenario"
        },
        {
            "head": "testDecodeToMonoAll",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "decoding scenarios",
            "tail_type": "useScenario"
        },
        {
            "head": "testDecodeToMonoAll",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "invokes multiple decoding methods",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeToMono",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeToMonoError",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeToMonoCancel",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoAll(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "testDecodeToMonoEmpty",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decodeToMono",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "have",
            "tail": "Decoder#decodeToMono decode scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "Decoder#decodeToMono decode scenario",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "protected <T> void testDecodeToMono(Publisher<DataBuffer> input, Class<? extends T> outputClass, Consumer<StepVerifier.FirstStep<T>> stepConsumer) {\n    testDecodeToMono(input, ResolvableType.forClass(outputClass), stepConsumer, null, null);\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,Class<? extends T>,Consumer<StepVerifier.FirstStep<T>>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "Decoder#decodeToMono decode scenario",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "This scenario tests the standard decode functionality of a Decoder, where it decodes data from a Publisher of DataBuffers to a specified output class. The method takes the input data as Publisher<DataBuffer>, the desired output class, and a Consumer to verify the output using StepVerifier. The example provided shows how to use Flux to concatenate multiple byte arrays into a single input for decoding, and then verify the output matches the expected combined byte array.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decodeToMono decode scenario",
            "head_type": "useScenario",
            "relation": "have",
            "tail": "The design principle behind this scenario is to ensure that the Decoder can handle multiple inputs and produce the correct output. It verifies the Decoder's ability to concatenate and decode data buffers correctly, which is crucial for streaming data applications. The use of StepVerifier ensures that the output can be tested and validated effectively, adhering to the principles of robust testing and verification in data processing systems.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitJumpInsn(int,Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitJumpInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitJumpInsn",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "offset constraint",
            "tail_type": "useConstraint"
        },
        {
            "head": "visitJumpInsn",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "bytecode manipulation",
            "tail_type": "useScenario"
        },
        {
            "head": "visitJumpInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitJumpInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitJumpInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "bytecode manipulation concept",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitJumpInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "bytecode design principle",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "visitJumpInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decodeToMono",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "standard decode scenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for decodeToMono",
            "tail_type": "useSampleCode"
        },
        {
            "head": "sample code for decodeToMono",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "complete example of decodeToMono usage",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMono(Publisher<DataBuffer>,ResolvableType,Consumer<StepVerifier.FirstStep<T>>,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder#decodeToMono",
            "tail_type": "method"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for Decoder",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for Decoder",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decodeToMonoError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "inputStreamError",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "errorDecodingScenario",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "errorDecodingSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "errorDecodingRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "errorDecodingDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoError(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "decodeToMono",
            "tail_type": "apiFunction"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "constrained_by",
            "tail": "inputStreamError",
            "tail_type": "useConstraint"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "applied_to",
            "tail": "errorDecodingScenario",
            "tail_type": "useScenario"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "errorDecodingSampleCode",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "errorDecodingRelatedConceptInterpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "have",
            "tail": "errorDecodingDesignPrincipleInterpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Resolving forward references to a label",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Updating basic block references",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Managing debug only labels",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Consolidating state for labels with the same bytecode offset",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Appending label to the basic block list",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Ending the current basic block",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Starting a new current basic block",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Updating frame owner for inserted frames",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Computing max stack and local variables",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "Managing the initial visitLabel call in the constructor",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Related concept interpretation for MethodWriter and Label",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Design principle interpretation for MethodWriter",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLabel(Label)",
            "head_type": "method",
            "relation": "have",
            "tail": "Sample code for using visitLabel method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "Resolving forward references to a label",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "Label must be already defined",
            "tail_type": "useConstraint"
        },
        {
            "head": "Updating basic block references",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "Label should not be a debug only label",
            "tail_type": "useConstraint"
        },
        {
            "head": "Consolidating state for labels with the same bytecode offset",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "Labels should have the same bytecode offset",
            "tail_type": "useConstraint"
        },
        {
            "head": "Appending label to the basic block list",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Appending a new label to the end of the list",
            "tail_type": "useScenario"
        },
        {
            "head": "Ending the current basic block",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Ending the current block and adding a new successor",
            "tail_type": "useScenario"
        },
        {
            "head": "Starting a new current basic block",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Starting a new block with a new label",
            "tail_type": "useScenario"
        },
        {
            "head": "Updating frame owner for inserted frames",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Updating frame owner when compute is COMPUTE_INSERTED_FRAMES",
            "tail_type": "useScenario"
        },
        {
            "head": "Computing max stack and local variables",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Computing when compute is COMPUTE_MAX_STACK_AND_LOCAL",
            "tail_type": "useScenario"
        },
        {
            "head": "Managing the initial visitLabel call in the constructor",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "Handling the initial visitLabel call",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decodeToMonoCancel",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "input stream cancellation",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "decoding scenario with immediate cancellation",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "sample code for decodeToMonoCancel",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation for decodeToMonoCancel",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation for decodeToMonoCancel",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoCancel(Publisher<DataBuffer>,ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder",
            "tail_type": "class"
        },
        {
            "head": "Decoder",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "decodeToMono",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "decodeToMono",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "input stream is empty",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "The output is expected to be empty as well",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "have",
            "tail": "protected void testDecodeToMonoEmpty(ResolvableType outputType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {\n    Mono<?> result = this.decoder.decodeToMono(Flux.empty(), outputType, mimeType, hints);\n    StepVerifier.create(result).verifyComplete();\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#testDecodeToMonoEmpty(ResolvableType,MimeType,Map<String,Object>)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "Decoder#decodeToMono",
            "tail_type": "class"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "decode",
            "tail_type": "apiFunction"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "class",
            "relation": "have",
            "tail": "The method decodeToMono() is used to decode the input stream and produce a Mono as output.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "Decoder#decodeToMono",
            "head_type": "class",
            "relation": "have",
            "tail": "The design principle behind Decoder#decodeToMono is to provide a reactive way to decode data streams, ensuring efficient handling of resources and backpressure.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "creating a deferred DataBuffer",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
            "head_type": "method",
            "relation": "have",
            "tail": "Creates a deferred DataBuffer containing the given bytes.",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
            "head_type": "method",
            "relation": "have",
            "tail": "The method returns a Mono that emits a single DataBuffer.",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.core.testfixture.codec.AbstractDecoderTests#dataBuffer(byte[])",
            "head_type": "method",
            "relation": "have",
            "tail": "package com.healthMgr.common.email;\nimport reactor.core.publisher.Mono;\nimport org.springframework.core.io.buffer.DataBuffer;\nimport org.springframework.core.io.buffer.DataBufferFactory;\nimport org.springframework.core.io.buffer.DefaultDataBufferFactory;\n\npublic class DataBufferExample {\n    public static void main(String[] args) {\n        DataBufferFactory bufferFactory = new DefaultDataBufferFactory();\n        byte[] bytes = {65, 66, 67}; // ASCII values for 'A', 'B', 'C'\n\n        Mono<DataBuffer> dataBufferMono = dataBuffer(bufferFactory, bytes);\n        dataBufferMono.doOnNext(dataBuffer -> {\n            System.out.println(\"DataBuffer contents: \" + dataBuffer.toString());\n        }).subscribe();\n    }\n\n    protected static Mono<DataBuffer> dataBuffer(DataBufferFactory bufferFactory, byte[] bytes) {\n        return Mono.fromCallable(() -> {\n            DataBuffer dataBuffer = bufferFactory.allocateBuffer(bytes.length);\n            dataBuffer.write(bytes);\n            return dataBuffer;\n        });\n    }\n}",
            "tail_type": "useSampleCode"
        },
        {
            "head": "creating a deferred DataBuffer",
            "head_type": "apiFunction",
            "relation": "constrained_by",
            "tail": "bytes must not be null",
            "tail_type": "useConstraint"
        },
        {
            "head": "creating a deferred DataBuffer",
            "head_type": "apiFunction",
            "relation": "applied_to",
            "tail": "storing bytes in a buffer",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.core.testfixture.codec.InputException",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testDecodeError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.InputException",
            "head_type": "class",
            "relation": "haveFunction",
            "tail": "testDecodeToMonoError",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.core.testfixture.codec.InputException",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "testDecodeError",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.core.testfixture.codec.InputException",
            "head_type": "class",
            "relation": "associated_with",
            "tail": "testDecodeToMonoError",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLdcInsn(Object)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLdcInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "visitLdcInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitLdcInsn adds a LDC instruction to the bytecode of the method",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLdcInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitLdcInsn handles different types of constants and updates the stack size accordingly",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "visitLdcInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitLdcInsn is designed to be efficient and handle various constant types",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitIincInsn(int,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitIincInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitIincInsn(int,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitIincInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitIincInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitIincInsn(int,int) code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitTableSwitchInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitTableSwitchInsn(int,int,Label,Label)",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "visitTableSwitchInsn",
            "head_type": "apiFunction",
            "relation": "have",
            "tail": "visitTableSwitchInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitTableSwitchInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitTableSwitchInsn complete example",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitLookupSwitchInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter",
            "tail_type": "class"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitLookupSwitchInsn(Label,int[],Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "visitLookupSwitchInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitLookupSwitchInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "org.springframework.asm.MethodWriter#visitLookupSwitchInsn(Label,int[],Label[])",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitSwitchInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "head_type": "method",
            "relation": "constrained_by",
            "tail": "currentBasicBlock must not be null",
            "tail_type": "useConstraint"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "head_type": "method",
            "relation": "applied_to",
            "tail": "asm method writing",
            "tail_type": "useScenario"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "visitSwitchInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "visitSwitchInsn related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "head_type": "method",
            "relation": "have",
            "tail": "visitSwitchInsn design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "visitSwitchInsn sample code",
            "head_type": "useSampleCode",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "tail_type": "method"
        },
        {
            "head": "visitSwitchInsn related concept interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "tail_type": "method"
        },
        {
            "head": "visitSwitchInsn design principle interpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "associated_with",
            "tail": "org.springframework.asm.MethodWriter#visitSwitchInsn(Label,Label[])",
            "tail_type": "method"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "haveFunction",
            "tail": "visitMultiANewArrayInsn",
            "tail_type": "apiFunction"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "visitMultiANewArrayInsn sample code",
            "tail_type": "useSampleCode"
        },
        {
            "head": "visitMultiANewArrayInsn sample code",
            "head_type": "useSampleCode",
            "relation": "have",
            "tail": "visitMultiANewArrayInsn(String descriptor, final int numDimensions) {\n    lastBytecodeOffset = code.length;\n    // Add the instruction to the bytecode of the method.\n    Symbol descSymbol = symbolTable.addConstantClass(descriptor);\n    code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);\n    // If needed, update the maximum stack size and number of locals, and stack map frames.\n    if (currentBasicBlock != null) {\n        if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {\n            currentBasicBlock.frame.execute(Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);\n        } else {\n            // No need to update maxRelativeStackSize (the stack size delta is always negative).\n            relativeStackSize += 1 - numDimensions;\n        }\n    }\n}",
            "tail_type": "String"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "related concept interpretation",
            "tail_type": "relatedConceptInterpretation"
        },
        {
            "head": "related concept interpretation",
            "head_type": "relatedConceptInterpretation",
            "relation": "have",
            "tail": "The visitMultiANewArrayInsn method is used to add a multi-dimensional array creation instruction to the bytecode of a method. It takes a descriptor for the array type and the number of dimensions as arguments. The method updates the bytecode, symbol table, and stack size accordingly.",
            "tail_type": "String"
        },
        {
            "head": "org.springframework.asm.MethodWriter#visitMultiANewArrayInsn(String,int)",
            "head_type": "method",
            "relation": "have",
            "tail": "design principle interpretation",
            "tail_type": "designPrincipleInterpretation"
        },
        {
            "head": "design principle interpretation",
            "head_type": "designPrincipleInterpretation",
            "relation": "have",
            "tail": "The design principle behind visitMultiANewArrayInsn is to provide a way to add complex array creation instructions to the bytecode. This method encapsulates the logic for handling multi-dimensional arrays, ensuring that the bytecode generation is consistent and efficient.",
            "tail_type": "String"
        }
    ]
}